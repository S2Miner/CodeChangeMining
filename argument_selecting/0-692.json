[{"original_method":"public void testExecutionUsingAProfileWhichSetsAProperty()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project2\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        // Check with profile not active\n\n        MavenExecutionRequest requestWithoutProfile = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) );\n\n        MavenExecutionResult r0 = mavenEmbedder.execute( requestWithoutProfile );\n\n        assertNoExceptions( r0 );\n\n        MavenProject p0 = r0.getProject();\n\n        assertNull( p0.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"name\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"occupation\" ) );\n\n        // Check with profile activated\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) )\n            .addActiveProfile( \"embedderProfile\" );\n\n        MavenExecutionResult r1 = mavenEmbedder.execute( request );\n\n        MavenProject p1 = r1.getProject();\n\n        System.out.println( p1 );\n        System.out.println( p1.getProperties() );\n        \n        assertEquals( \"true\", p1.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertEquals( \"jason\", p1.getProperties().getProperty( \"name\" ) );\n\n        assertEquals( \"somnambulance\", p1.getProperties().getProperty( \"occupation\" ) );\n    }","id":0,"modified_method":"public void testExecutionUsingAProfileWhichSetsAProperty()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project2\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        // Check with profile not active\n\n        MavenExecutionRequest requestWithoutProfile = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n\n        /*\n        MavenExecutionRequest requestWithoutProfile = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) );\n        */\n\n        MavenExecutionResult r0 = mavenEmbedder.execute( requestWithoutProfile );\n\n        assertNoExceptions( r0 );\n\n        MavenProject p0 = r0.getProject();\n\n        assertNull( p0.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"name\" ) );\n\n        assertNull( p0.getProperties().getProperty( \"occupation\" ) );\n\n        // Check with profile activated\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n        request.addActiveProfile( \"embedderProfile\" );\n        \n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) )\n            .setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"validate\" } ) )\n            .addActiveProfile( \"embedderProfile\" );\n        */\n\n        MavenExecutionResult r1 = mavenEmbedder.execute( request );\n\n        MavenProject p1 = r1.getProject();\n\n        System.out.println( p1 );\n        System.out.println( p1.getProperties() );\n        \n        assertEquals( \"true\", p1.getProperties().getProperty( \"embedderProfile\" ) );\n\n        assertEquals( \"jason\", p1.getProperties().getProperty( \"name\" ) );\n\n        assertEquals( \"somnambulance\", p1.getProperties().getProperty( \"occupation\" ) );\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"public void testExecutionUsingAPomFile()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project1\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n        \n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","id":1,"modified_method":"public void testExecutionUsingAPomFile()\n        throws Exception\n    {\n        File testDirectory = new File( basedir, \"src/test/embedder-test-project\" );\n\n        File targetDirectory = new File( basedir, \"target/embedder-test-project1\" );\n\n        FileUtils.copyDirectoryStructure( testDirectory, targetDirectory );\n\n        MavenExecutionRequest request = createMavenExecutionRequest( new File( targetDirectory, \"pom.xml\" ) );        \n\n        /*\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setPom( new File( targetDirectory, \"pom.xml\" ) ).setShowErrors( true )\n            .setGoals( Arrays.asList( new String[] { \"package\" } ) );\n        */\n\n        MavenExecutionResult result = mavenEmbedder.execute( request );\n\n        assertNoExceptions( result );\n        \n        MavenProject project = result.getProject();\n\n        assertEquals( \"embedder-test-project\", project.getArtifactId() );\n\n        File jar = new File( targetDirectory, \"target/embedder-test-project-1.0-SNAPSHOT.jar\" );\n\n        assertTrue( jar.exists() );\n    }","commit_id":"3d9dea68d943ff46fb89309cd1c4425d51b4421e","url":"https://github.com/apache/maven"},{"original_method":"private static boolean postCredentials(String user, String password) {\n    String url = stepicUrl + \"accounts/login/\";\n    final HttpPost request = new HttpPost(url);\n    List <NameValuePair> nvps = new ArrayList <NameValuePair>();\n    nvps.add(new BasicNameValuePair(\"csrfmiddlewaretoken\", ourCSRFToken));\n    nvps.add(new BasicNameValuePair(\"login\", user));\n    nvps.add(new BasicNameValuePair(\"next\", \"/\"));\n    nvps.add(new BasicNameValuePair(\"password\", password));\n    nvps.add(new BasicNameValuePair(\"remember\", \"on\"));\n\n    try {\n      request.setEntity(new UrlEncodedFormEntity(nvps, HTTP.UTF_8));\n    }\n    catch (UnsupportedEncodingException e) {\n      LOG.error(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n\n    setHeaders(request, \"application/x-www-form-urlencoded\");\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String s = EntityUtils.toString(response.getEntity());\n      saveCSRFToken();\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 302) {\n        LOG.error(\"Failed to login \" + EntityUtils.toString(response.getEntity()));\n        ourClient = null;\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.warn(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n    return true;\n  }","id":2,"modified_method":"private static boolean postCredentials(String user, String password) {\n    String url = stepicUrl + \"accounts/login/\";\n    final HttpPost request = new HttpPost(url);\n    List <NameValuePair> nvps = new ArrayList <NameValuePair>();\n    nvps.add(new BasicNameValuePair(\"csrfmiddlewaretoken\", ourCSRFToken));\n    nvps.add(new BasicNameValuePair(\"login\", user));\n    nvps.add(new BasicNameValuePair(\"next\", \"/\"));\n    nvps.add(new BasicNameValuePair(\"password\", password));\n    nvps.add(new BasicNameValuePair(\"remember\", \"on\"));\n\n    try {\n      request.setEntity(new UrlEncodedFormEntity(nvps, HTTP.UTF_8));\n    }\n    catch (UnsupportedEncodingException e) {\n      LOG.error(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n\n    setHeaders(request, \"application/x-www-form-urlencoded\");\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      saveCSRFToken();\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 302) {\n        final HttpEntity responseEntity = response.getEntity();\n        final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n        LOG.error(\"Failed to login \" + responseString);\n        ourClient = null;\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.warn(e.getMessage());\n      ourClient = null;\n      return false;\n    }\n    return true;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int postLesson(Project project, @NotNull final Lesson lesson, ProgressIndicator indicator) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"lessons\");\n    if (ourClient == null) {\n      showLoginDialog();\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new LessonWrapper(lesson));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n        return 0;\n      }\n      final Lesson postedLesson = new Gson().fromJson(responseString, Course.class).getLessons().get(0);\n      for (Task task : lesson.getTaskList()) {\n        indicator.checkCanceled();\n        postTask(project, task, postedLesson.id);\n      }\n      return postedLesson.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","id":3,"modified_method":"public static int postLesson(Project project, @NotNull final Lesson lesson, ProgressIndicator indicator) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"lessons\");\n    if (ourClient == null) {\n      showLoginDialog();\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new LessonWrapper(lesson));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n        return 0;\n      }\n      final Lesson postedLesson = new Gson().fromJson(responseString, Course.class).getLessons().get(0);\n      for (Task task : lesson.getTaskList()) {\n        indicator.checkCanceled();\n        postTask(project, task, postedLesson.id);\n      }\n      return postedLesson.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int postModule(int courseId, int position, @NotNull final String title) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"sections\");\n    setHeaders(request, \"application/json\");\n    final Section section = new Section();\n    section.course = courseId;\n    section.title = title;\n    section.position = position;\n    final SectionWrapper sectionContainer = new SectionWrapper();\n    sectionContainer.section = section;\n    String requestBody = new Gson().toJson(sectionContainer);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n      final Section postedSection = new Gson().fromJson(responseString, SectionContainer.class).sections.get(0);\n      return postedSection.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","id":4,"modified_method":"private static int postModule(int courseId, int position, @NotNull final String title) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"sections\");\n    setHeaders(request, \"application/json\");\n    final Section section = new Section();\n    section.course = courseId;\n    section.title = title;\n    section.position = position;\n    final SectionWrapper sectionContainer = new SectionWrapper();\n    sectionContainer.section = section;\n    String requestBody = new Gson().toJson(sectionContainer);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n      final Section postedSection = new Gson().fromJson(responseString, SectionContainer.class).sections.get(0);\n      return postedSection.id;\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return -1;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void postAttempt(@NotNull final Task task, boolean passed, @Nullable String login, @Nullable String password) {\n    if (task.getStepicId() <= 0) {\n      return;\n    }\n    if (ourClient == null) {\n      if (StringUtil.isEmptyOrSpaces(login) || StringUtil.isEmptyOrSpaces(password)) {\n        return;\n      }\n      else {\n        final boolean success = login(login, password);\n        if (!success) return;\n      }\n    }\n\n    final HttpPost attemptRequest = new HttpPost(stepicApiUrl + \"attempts\");\n    setHeaders(attemptRequest, \"application/json\");\n    String attemptRequestBody = new Gson().toJson(new AttemptWrapper(task.getStepicId()));\n    attemptRequest.setEntity(new StringEntity(attemptRequestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse attemptResponse = ourClient.execute(attemptRequest);\n      final String attemptResponseString = EntityUtils.toString(attemptResponse.getEntity());\n      final StatusLine statusLine = attemptResponse.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to make attempt \" + attemptResponseString);\n      }\n      final AttemptWrapper.Attempt attempt = new Gson().fromJson(attemptResponseString, AttemptContainer.class).attempts.get(0);\n\n      final Map<String, TaskFile> taskFiles = task.getTaskFiles();\n      final ArrayList<SolutionFile> files = new ArrayList<SolutionFile>();\n      for (TaskFile fileEntry : taskFiles.values()) {\n        files.add(new SolutionFile(fileEntry.name, fileEntry.text));\n      }\n      postSubmission(passed, attempt, files);\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","id":5,"modified_method":"public static void postAttempt(@NotNull final Task task, boolean passed, @Nullable String login, @Nullable String password) {\n    if (task.getStepicId() <= 0) {\n      return;\n    }\n    if (ourClient == null) {\n      if (StringUtil.isEmptyOrSpaces(login) || StringUtil.isEmptyOrSpaces(password)) {\n        return;\n      }\n      else {\n        final boolean success = login(login, password);\n        if (!success) return;\n      }\n    }\n\n    final HttpPost attemptRequest = new HttpPost(stepicApiUrl + \"attempts\");\n    setHeaders(attemptRequest, \"application/json\");\n    String attemptRequestBody = new Gson().toJson(new AttemptWrapper(task.getStepicId()));\n    attemptRequest.setEntity(new StringEntity(attemptRequestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse attemptResponse = ourClient.execute(attemptRequest);\n      final HttpEntity responseEntity = attemptResponse.getEntity();\n      final String attemptResponseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine statusLine = attemptResponse.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to make attempt \" + attemptResponseString);\n      }\n      final AttemptWrapper.Attempt attempt = new Gson().fromJson(attemptResponseString, AttemptContainer.class).attempts.get(0);\n\n      final Map<String, TaskFile> taskFiles = task.getTaskFiles();\n      final ArrayList<SolutionFile> files = new ArrayList<SolutionFile>();\n      for (TaskFile fileEntry : taskFiles.values()) {\n        files.add(new SolutionFile(fileEntry.name, fileEntry.text));\n      }\n      postSubmission(passed, attempt, files);\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void postSubmission(boolean passed, AttemptWrapper.Attempt attempt, ArrayList<SolutionFile> files) throws IOException {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"submissions\");\n    setHeaders(request, \"application/json\");\n\n    String requestBody = new Gson().toJson(new SubmissionWrapper(attempt.id, passed ? \"1\" : \"0\", files));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final String responseString = EntityUtils.toString(response.getEntity());\n    final StatusLine line = response.getStatusLine();\n    if (line.getStatusCode() != 201) {\n      LOG.error(\"Failed to make submission \" + responseString);\n    }\n  }","id":6,"modified_method":"private static void postSubmission(boolean passed, AttemptWrapper.Attempt attempt, ArrayList<SolutionFile> files) throws IOException {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"submissions\");\n    setHeaders(request, \"application/json\");\n\n    String requestBody = new Gson().toJson(new SubmissionWrapper(attempt.id, passed ? \"1\" : \"0\", files));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final HttpEntity responseEntity = response.getEntity();\n    final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n    final StatusLine line = response.getStatusLine();\n    if (line.getStatusCode() != 201) {\n      LOG.error(\"Failed to make submission \" + responseString);\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void postCourse(final Project project, @NotNull Course course, boolean relogin, @NotNull final ProgressIndicator indicator) {\n    indicator.setText(\"Uploading course to \" + stepicUrl);\n    final HttpPost request = new HttpPost(stepicApiUrl + \"courses\");\n    if (ourClient == null || !relogin) {\n      if (!login()) return;\n    }\n    final AuthorWrapper user = getCurrentUser();\n    if (user != null) {\n      course.setAuthors(user.users);\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new CourseWrapper(course));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        if (!relogin) {\n          login();\n          postCourse(project, course, true, indicator);\n        }\n        LOG.error(\"Failed to push \" + responseString);\n        return;\n      }\n      final CourseInfo postedCourse = new Gson().fromJson(responseString, CoursesContainer.class).courses.get(0);\n\n      final int sectionId = postModule(postedCourse.id, 1, String.valueOf(postedCourse.getName()));\n      int position = 1;\n      for (Lesson lesson : course.getLessons()) {\n        indicator.checkCanceled();\n        final int lessonId = postLesson(project, lesson, indicator);\n        postUnit(lessonId, position, sectionId);\n        position += 1;\n      }\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          postAdditionalFiles(project, postedCourse.id, indicator);\n        }\n      });\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","id":7,"modified_method":"private static void postCourse(final Project project, @NotNull Course course, boolean relogin, @NotNull final ProgressIndicator indicator) {\n    indicator.setText(\"Uploading course to \" + stepicUrl);\n    final HttpPost request = new HttpPost(stepicApiUrl + \"courses\");\n    if (ourClient == null || !relogin) {\n      if (!login()) return;\n    }\n    final AuthorWrapper user = getCurrentUser();\n    if (user != null) {\n      course.setAuthors(user.users);\n    }\n\n    setHeaders(request, \"application/json\");\n    String requestBody = new Gson().toJson(new CourseWrapper(course));\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        if (!relogin) {\n          login();\n          postCourse(project, course, true, indicator);\n        }\n        LOG.error(\"Failed to push \" + responseString);\n        return;\n      }\n      final CourseInfo postedCourse = new Gson().fromJson(responseString, CoursesContainer.class).courses.get(0);\n\n      final int sectionId = postModule(postedCourse.id, 1, String.valueOf(postedCourse.getName()));\n      int position = 1;\n      for (Lesson lesson : course.getLessons()) {\n        indicator.checkCanceled();\n        final int lessonId = postLesson(project, lesson, indicator);\n        postUnit(lessonId, position, sectionId);\n        position += 1;\n      }\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          postAdditionalFiles(project, postedCourse.id, indicator);\n        }\n      });\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static <T> T getFromStepic(String link, final Class<T> container) throws IOException {\n    final HttpGet request = new HttpGet(stepicApiUrl + link);\n    if (ourClient == null) {\n      initializeClient();\n    }\n    setHeaders(request, \"application/json\");\n\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final StatusLine statusLine = response.getStatusLine();\n    final String responseString = EntityUtils.toString(response.getEntity());\n    if (statusLine.getStatusCode() != 200) {\n      throw new IOException(\"Stepic returned non 200 status code \" + responseString);\n    }\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    return gson.fromJson(responseString, container);\n  }","id":8,"modified_method":"private static <T> T getFromStepic(String link, final Class<T> container) throws IOException {\n    final HttpGet request = new HttpGet(stepicApiUrl + link);\n    if (ourClient == null) {\n      initializeClient();\n    }\n    setHeaders(request, \"application/json\");\n\n    final CloseableHttpResponse response = ourClient.execute(request);\n    final StatusLine statusLine = response.getStatusLine();\n    final HttpEntity responseEntity = response.getEntity();\n    final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n    if (statusLine.getStatusCode() != 200) {\n      throw new IOException(\"Stepic returned non 200 status code \" + responseString);\n    }\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n    return gson.fromJson(responseString, container);\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void postUnit(int lessonId, int position, int sectionId) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"units\");\n    setHeaders(request, \"application/json\");\n    final UnitWrapper unitWrapper = new UnitWrapper();\n    unitWrapper.unit = new Unit();\n    unitWrapper.unit.lesson = lessonId;\n    unitWrapper.unit.position = position;\n    unitWrapper.unit.section = sectionId;\n\n    String requestBody = new Gson().toJson(unitWrapper);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","id":9,"modified_method":"private static void postUnit(int lessonId, int position, int sectionId) {\n    final HttpPost request = new HttpPost(stepicApiUrl + \"units\");\n    setHeaders(request, \"application/json\");\n    final UnitWrapper unitWrapper = new UnitWrapper();\n    unitWrapper.unit = new Unit();\n    unitWrapper.unit.lesson = lessonId;\n    unitWrapper.unit.position = position;\n    unitWrapper.unit.section = sectionId;\n\n    String requestBody = new Gson().toJson(unitWrapper);\n    request.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(request);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine line = response.getStatusLine();\n      if (line.getStatusCode() != 201) {\n        LOG.error(\"Failed to push \" + responseString);\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean createUser(@NotNull final String user, @NotNull final String password) {\n    final HttpPost userRequest = new HttpPost(stepicApiUrl + \"users\");\n    initializeClient();\n    setHeaders(userRequest, \"application/json\");\n    String requestBody = new Gson().toJson(new UserWrapper(user, password));\n    userRequest.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(userRequest);\n      final String responseString = EntityUtils.toString(response.getEntity());\n      final StatusLine statusLine = response.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to create user \" + responseString);\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return true;\n  }","id":10,"modified_method":"public static boolean createUser(@NotNull final String user, @NotNull final String password) {\n    final HttpPost userRequest = new HttpPost(stepicApiUrl + \"users\");\n    initializeClient();\n    setHeaders(userRequest, \"application/json\");\n    String requestBody = new Gson().toJson(new UserWrapper(user, password));\n    userRequest.setEntity(new StringEntity(requestBody, ContentType.APPLICATION_JSON));\n\n    try {\n      final CloseableHttpResponse response = ourClient.execute(userRequest);\n      final HttpEntity responseEntity = response.getEntity();\n      final String responseString = responseEntity != null ? EntityUtils.toString(responseEntity) : \"\";\n      final StatusLine statusLine = response.getStatusLine();\n      if (statusLine.getStatusCode() != 201) {\n        LOG.error(\"Failed to create user \" + responseString);\n        return false;\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e.getMessage());\n    }\n    return true;\n  }","commit_id":"bafa7e3af923aafad7f023780111d932c0740dd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                firstNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                secondNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","id":11,"modified_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord( \n                firstNode.getNextRel() );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord(  \n                secondNode.getNextRel() );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","commit_id":"b751f703ed006cd3ec94a7af077d5c3849df310b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                firstNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                secondNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","id":12,"modified_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord( \n                firstNode.getNextRel() );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord(  \n                secondNode.getNextRel() );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","commit_id":"b7961b9b6217a569ce0fc0bfcc3efa96f7d7f8a5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                firstNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipRecord( \n                secondNode.getNextRel() & 0xFFFFFFFFL );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","id":13,"modified_method":"private void connectRelationship( NodeRecord firstNode, \n        NodeRecord secondNode, RelationshipRecord rel )\n    {\n        rel.setFirstNextRel( firstNode.getNextRel() );\n        rel.setSecondNextRel( secondNode.getNextRel() );\n        if ( firstNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord( \n                firstNode.getNextRel() );\n            if ( nextRel.getFirstNode() == firstNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == firstNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        if ( secondNode.getNextRel() != Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            RelationshipRecord nextRel = getRelationshipStore().getRecord(  \n                secondNode.getNextRel() );\n            if ( nextRel.getFirstNode() == secondNode.getId() )\n            {\n                nextRel.setFirstPrevRel( rel.getId() );\n            }\n            else if ( nextRel.getSecondNode() == secondNode.getId() )\n            {\n                nextRel.setSecondPrevRel( rel.getId() );\n            }\n            else\n            {\n                throw new RuntimeException( firstNode + \" dont match \"\n                    + nextRel );\n            }\n            getRelationshipStore().updateRecord( nextRel );\n        }\n        firstNode.setNextRel( rel.getId() );\n        secondNode.setNextRel( rel.getId() );\n    }","commit_id":"2745fbfa91f80001d361da0c8a6fd30423ab6c20","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n   * Main entry point for the import of a file hierarchy.\n   * Instantiates the engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if (!bs.mkdirs() && bs.exists())\n          throw new IOException(BACKINGEXISTS + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      if(Prop.fuse) {\n        atts.add(MOUNTPOINT  , token(mountpoint));\n        atts.add(SIZE        , Token.EMPTY);\n        atts.add(BACKINGSTORE, token(mybackingpath));\n      } else {\n        atts.add(NAME        , NOTMOUNTED);\n        atts.add(SIZE        , Token.EMPTY);\n        atts.add(BACKINGSTORE, token(fsimportpath));\n      }\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() :\n        new File[] { new File(fsimportpath).getCanonicalFile() }) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","id":14,"modified_method":"/**\n   * Main entry point for the import of a file hierarchy.\n   * Instantiates the engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if (!bs.mkdirs() && bs.exists())\n          throw new IOException(BACKINGEXISTS + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      final byte[] mnt = Prop.fuse ? token(mountpoint) : NOTMOUNTED;\n      final byte[] bck = Prop.fuse ? token(mybackingpath) : token(fsimportpath);\n      atts.add(MOUNTPOINT  , mnt);\n      atts.add(SIZE        , Token.EMPTY);\n      atts.add(BACKINGSTORE, bck);\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() :\n        new File[] { new File(fsimportpath).getCanonicalFile() }) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","commit_id":"8af58dd7e555d01091cb3f7a625169ba382627e0","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Main entry point for the import of a file hierarchy. Instantiates the\n   * engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if(!bs.mkdirs() && bs.exists()) throw new IOException(BACKINGEXISTS\n          + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      if(Prop.fuse) {\n        atts.add(MOUNTPOINT, token(mountpoint));\n        atts.add(SIZE, Token.EMPTY);\n        atts.add(BACKINGSTORE, token(mybackingpath));\n      } else {\n        atts.add(NAME, NOTMOUNTED);\n        atts.add(SIZE, Token.EMPTY);\n        atts.add(BACKINGSTORE, token(fsimportpath));\n      }\n      if(ADD_TYPE_ATTR) builder.startNS(Token.token(\"xsi\"),\n          Token.token(\"http://www.w3.org/2001/XMLSchema-instance\"));\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() : new File[] { new File(\n          fsimportpath).getCanonicalFile()}) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","id":15,"modified_method":"/**\n   * Main entry point for the import of a file hierarchy. Instantiates the\n   * engine and starts the traversal.\n   * @param build instance passed by {@link CreateFS}.\n   * @throws IOException I/O exception\n   */\n  @Override\n  public void parse(final Builder build) throws IOException {\n    builder = build;\n    builder.encoding(Prop.ENCODING);\n\n    builder.meta.backingpath = mybackingpath;\n    builder.meta.mountpoint = mountpoint;\n\n    // -- create backing store (DeepFS depends on it).\n    if(Prop.fuse && !singlemode) {\n      File bs = new File(mybackingpath);\n      if(!bs.mkdirs() && bs.exists()) throw new IOException(BACKINGEXISTS\n          + mybackingpath);\n    }\n\n    builder.startDoc(token(io.name()));\n\n    if(singlemode) {\n      file(new File(io.path()).getCanonicalFile());\n    } else {\n      atts.reset();\n      final byte[] mnt = Prop.fuse ? token(mountpoint) : NOTMOUNTED;\n      final byte[] bck = Prop.fuse ? token(mybackingpath) : token(fsimportpath);\n      atts.add(MOUNTPOINT  , mnt);\n      atts.add(SIZE        , Token.EMPTY);\n      atts.add(BACKINGSTORE, bck);\n\n      if(ADD_TYPE_ATTR) builder.startNS(Token.token(\"xsi\"),\n          Token.token(\"http://www.w3.org/2001/XMLSchema-instance\"));\n\n      builder.startElem(DEEPFS, atts);\n\n      for(final File f : root ? File.listRoots() : new File[] { new File(\n          fsimportpath).getCanonicalFile()}) {\n\n        importRootLength = f.getAbsolutePath().length();\n        sizeStack[0] = 0;\n        parse(f);\n        builder.setAttValue(preStack[0] + SIZEOFFSET, token(sizeStack[0]));\n      }\n      builder.endElem(DEEPFS);\n    }\n    builder.endDoc();\n  }","commit_id":"8af58dd7e555d01091cb3f7a625169ba382627e0","url":"https://github.com/BaseXdb/basex"},{"original_method":"private synchronized ForeignSource get(File file) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(ForeignSource.class).unmarshal(new StreamSource(file), ForeignSource.class).getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + file.getPath(), e);\n        }\n    }","id":16,"modified_method":"private synchronized ForeignSource get(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(ForeignSource.class);\n            JAXBElement<ForeignSource> fs = um.unmarshal(new StreamSource(inputFile), ForeignSource.class);\n            return fs.getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"291622bb707ffdcbefb83873590ce1447a84e13d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(Requisition.class).unmarshal(new StreamSource(inputFile), Requisition.class).getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","id":17,"modified_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(Requisition.class);\n            JAXBElement<Requisition> req = um.unmarshal(new StreamSource(inputFile), Requisition.class);\n            return req.getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"291622bb707ffdcbefb83873590ce1447a84e13d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized ForeignSource get(File file) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(ForeignSource.class).unmarshal(new StreamSource(file), ForeignSource.class).getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + file.getPath(), e);\n        }\n    }","id":18,"modified_method":"private synchronized ForeignSource get(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(ForeignSource.class);\n            JAXBElement<ForeignSource> fs = um.unmarshal(new StreamSource(inputFile), ForeignSource.class);\n            return fs.getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"0dfbd0198a1c6c4dcc89cebaf4c6d188ff1f9c27","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(Requisition.class).unmarshal(new StreamSource(inputFile), Requisition.class).getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","id":19,"modified_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(Requisition.class);\n            JAXBElement<Requisition> req = um.unmarshal(new StreamSource(inputFile), Requisition.class);\n            return req.getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"0dfbd0198a1c6c4dcc89cebaf4c6d188ff1f9c27","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized ForeignSource get(File file) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(ForeignSource.class).unmarshal(new StreamSource(file), ForeignSource.class).getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + file.getPath(), e);\n        }\n    }","id":20,"modified_method":"private synchronized ForeignSource get(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(ForeignSource.class);\n            JAXBElement<ForeignSource> fs = um.unmarshal(new StreamSource(inputFile), ForeignSource.class);\n            return fs.getValue();\n        } catch (JAXBException e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"2f3066172d17029427faf81bca6b5c598c19c5cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            return getUnmarshaller(Requisition.class).unmarshal(new StreamSource(inputFile), Requisition.class).getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","id":21,"modified_method":"private synchronized Requisition getRequisition(File inputFile) throws ForeignSourceRepositoryException {\n        try {\n            Unmarshaller um = getUnmarshaller(Requisition.class);\n            JAXBElement<Requisition> req = um.unmarshal(new StreamSource(inputFile), Requisition.class);\n            return req.getValue();\n        } catch (Exception e) {\n            throw new ForeignSourceRepositoryException(\"unable to unmarshal \" + inputFile.getPath(), e);\n        }\n    }","commit_id":"2f3066172d17029427faf81bca6b5c598c19c5cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void beforeCommitHook() throws CommitFailedException {\n        store.setEditor(new CommitEditor() {\n            @Override\n            public NodeState editCommit(\n                    NodeStore store, NodeState before, NodeState after) {\n                NodeBuilder rootBuilder = store.getBuilder(after);\n                NodeBuilder testBuilder = store.getBuilder(after.getChildNode(\"test\"));\n                testBuilder.setNode(\"fromHook\", MemoryNodeState.EMPTY_NODE);\n                rootBuilder.setNode(\"test\", testBuilder.getNodeState());\n                return rootBuilder.getNodeState();\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder = store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        final CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch(EmptyEditor.INSTANCE);\n        branch.setRoot(newRoot);\n        branch.merge();\n\n        NodeState test = store.getRoot().getChildNode(\"test\");\n        assertNotNull(test.getChildNode(\"newNode\"));\n        assertNotNull(test.getChildNode(\"fromHook\"));\n        assertNull(test.getChildNode(\"a\"));\n        assertEquals(fortyTwo, test.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(test, store.getRoot().getChildNode(\"test\"));\n    }","id":22,"modified_method":"@Test\n    public void beforeCommitHook() throws CommitFailedException {\n        store.setEditor(new CommitEditor() {\n            @Override\n            public NodeState editCommit(\n                    NodeStore store, NodeState before, NodeState after) {\n                NodeBuilder rootBuilder = store.getBuilder(after);\n                NodeBuilder testBuilder = store.getBuilder(after.getChildNode(\"test\"));\n                testBuilder.setNode(\"fromHook\", MemoryNodeState.EMPTY_NODE);\n                rootBuilder.setNode(\"test\", testBuilder.getNodeState());\n                return rootBuilder.getNodeState();\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder = store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        final CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch();\n        branch.setRoot(newRoot);\n        branch.merge(EmptyEditor.INSTANCE);\n\n        NodeState test = store.getRoot().getChildNode(\"test\");\n        assertNotNull(test.getChildNode(\"newNode\"));\n        assertNotNull(test.getChildNode(\"fromHook\"));\n        assertNull(test.getChildNode(\"a\"));\n        assertEquals(fortyTwo, test.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(test, store.getRoot().getChildNode(\"test\"));\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void afterCommitHook() throws CommitFailedException {\n        final NodeState[] states = new NodeState[2]; // { before, after }\n        store.setObserver(new Observer() {\n            @Override\n            public void contentChanged(\n                    NodeStore store, NodeState before, NodeState after) {\n                states[0] = before;\n                states[1] = after;\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder= store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch(EmptyEditor.INSTANCE);\n        branch.setRoot(newRoot);\n        branch.merge();\n        store.getRoot(); // triggers the observer\n\n        NodeState before = states[0];\n        NodeState after = states[1];\n        assertNotNull(before);\n        assertNotNull(after);\n\n        assertNull(before.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNotNull(after.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNull(after.getChildNode(\"test\").getChildNode(\"a\"));\n        assertEquals(fortyTwo, after.getChildNode(\"test\").getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(newRoot, after);\n    }","id":23,"modified_method":"@Test\n    public void afterCommitHook() throws CommitFailedException {\n        final NodeState[] states = new NodeState[2]; // { before, after }\n        store.setObserver(new Observer() {\n            @Override\n            public void contentChanged(\n                    NodeStore store, NodeState before, NodeState after) {\n                states[0] = before;\n                states[1] = after;\n            }\n        });\n\n        NodeState root = store.getRoot();\n        NodeBuilder rootBuilder= store.getBuilder(root);\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        testBuilder.removeNode(\"a\");\n\n        NodeState newRoot = rootBuilder.getNodeState();\n\n        NodeStoreBranch branch = store.branch();\n        branch.setRoot(newRoot);\n        branch.merge(EmptyEditor.INSTANCE);\n        store.getRoot(); // triggers the observer\n\n        NodeState before = states[0];\n        NodeState after = states[1];\n        assertNotNull(before);\n        assertNotNull(after);\n\n        assertNull(before.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNotNull(after.getChildNode(\"test\").getChildNode(\"newNode\"));\n        assertNull(after.getChildNode(\"test\").getChildNode(\"a\"));\n        assertEquals(fortyTwo, after.getChildNode(\"test\").getChildNode(\"newNode\").getProperty(\"n\").getValue());\n        assertEquals(newRoot, after);\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void branch() throws CommitFailedException {\n        NodeStoreBranch branch = store.branch(EmptyEditor.INSTANCE);\n\n        NodeBuilder rootBuilder = store.getBuilder(branch.getRoot());\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        testBuilder.removeNode(\"x\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        // Assert changes are present in the builder\n        NodeState testState = rootBuilder.getNodeState().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.setRoot(rootBuilder.getNodeState());\n\n        // Assert changes are present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.merge();\n\n        // Assert changes are present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n    }","id":24,"modified_method":"@Test\n    public void branch() throws CommitFailedException {\n        NodeStoreBranch branch = store.branch();\n\n        NodeBuilder rootBuilder = store.getBuilder(branch.getRoot());\n        NodeBuilder testBuilder = rootBuilder.getChildBuilder(\"test\");\n        NodeBuilder newNodeBuilder = testBuilder.getChildBuilder(\"newNode\");\n\n        testBuilder.removeNode(\"x\");\n\n        CoreValue fortyTwo = store.getValueFactory().createValue(42);\n        newNodeBuilder.setProperty(\"n\", fortyTwo);\n\n        // Assert changes are present in the builder\n        NodeState testState = rootBuilder.getNodeState().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.setRoot(rootBuilder.getNodeState());\n\n        // Assert changes are present in the branch\n        testState = branch.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n\n        // Assert changes are not yet present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNull(testState.getChildNode(\"newNode\"));\n        assertNotNull(testState.getChildNode(\"x\"));\n\n        branch.merge(EmptyEditor.INSTANCE);\n\n        // Assert changes are present in the trunk\n        testState = store.getRoot().getChildNode(\"test\");\n        assertNotNull(testState.getChildNode(\"newNode\"));\n        assertNull(testState.getChildNode(\"x\"));\n        assertEquals(fortyTwo, testState.getChildNode(\"newNode\").getProperty(\"n\").getValue());\n    }","commit_id":"6c6d8f903e5d1bf4a97d732a86f3a9c08c1680d7","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.geohashes(hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.points(new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.point(2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").geohashes(\"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","id":25,"modified_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", 2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", \"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","commit_id":"c108a4ce6d32f43397d5adbcb4b930f5be174d48","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.geohashes(hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.points(new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.point(2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").geohashes(\"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","id":26,"modified_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", 2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", \"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","commit_id":"9432d57409b76a3f4c5397120a8b1c298c2fafa5","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\", 2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", \"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\", 2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","id":27,"modified_method":"public void testSinglePointGeoDistanceSort() throws ExecutionException, InterruptedException, IOException {\n        assertAcked(prepareCreate(\"index\").addMapping(\"type\", \"location\", \"type=geo_point\"));\n        indexRandom(true,\n                client().prepareIndex(\"index\", \"type\", \"d1\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 1).endObject().endObject()),\n                client().prepareIndex(\"index\", \"type\", \"d2\").setSource(jsonBuilder().startObject().startObject(\"location\").field(\"lat\", 1).field(\"lon\", 2).endObject().endObject()));\n        ensureYellow();\n\n        String hashPoint = \"s037ms06g7h0\";\n\n        GeoDistanceSortBuilder geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.geohashes(hashPoint);\n\n        SearchResponse searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.points(new GeoPoint(2, 2));\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        geoDistanceSortBuilder = new GeoDistanceSortBuilder(\"location\");\n        geoDistanceSortBuilder.point(2, 2);\n\n        searchResponse = client().prepareSearch()\n                .setQuery(matchAllQuery())\n                .addSort(geoDistanceSortBuilder.sortMode(\"min\").order(SortOrder.ASC).geoDistance(GeoDistance.PLANE).unit(DistanceUnit.KILOMETERS))\n                .execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").geohashes(\"s037ms06g7h0\")\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n\n        searchResponse = client()\n                .prepareSearch()\n                .setSource(\n                        new SearchSourceBuilder().sort(SortBuilders.geoDistanceSort(\"location\").point(2.0, 2.0)\n                                .unit(DistanceUnit.KILOMETERS).geoDistance(GeoDistance.PLANE))).execute().actionGet();\n        checkCorrectSortOrderForGeoSort(searchResponse);\n    }","commit_id":"8cca0395ef6449651def09bf1e96465bad2beaa4","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void doHandle(String target, Request baseRequest,HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException\n    {\n        DispatcherType type = baseRequest.getDispatcherType();\n        \n        ServletHolder servlet_holder=(ServletHolder) baseRequest.getUserIdentityScope();\n        FilterChain chain=null;\n\n        // find the servlet\n        if (target.startsWith(\"/\"))\n        {\n            if (servlet_holder!=null && _filterMappings!=null && _filterMappings.length>0)\n                chain=getFilterChain(baseRequest, target, servlet_holder);\n        }\n        else\n        {\n            if (servlet_holder!=null)\n            {\n                if (_filterMappings!=null && _filterMappings.length>0)\n                {\n                    chain=getFilterChain(baseRequest, null,servlet_holder);\n                }\n            }\n        }\n\n        LOG.debug(\"chain={}\",chain);\n        \n        try\n        {\n            if (servlet_holder==null)\n            {\n                notFound(request, response);\n            }\n            else\n            {\n                // unwrap any tunnelling of base Servlet request/responses\n                ServletRequest req = request;\n                if (req instanceof ServletRequestHttpWrapper)\n                    req = ((ServletRequestHttpWrapper)req).getRequest();\n                ServletResponse res = response;\n                if (res instanceof ServletResponseHttpWrapper)\n                    res = ((ServletResponseHttpWrapper)res).getResponse();\n\n                // Do the filter/handling thang\n                if (chain!=null)\n                    chain.doFilter(req, res);\n                else \n                    servlet_holder.handle(baseRequest,req,res);\n            }\n        }\n        catch(EofException e)\n        {\n            throw e;\n        }\n        catch(RuntimeIOException e)\n        {\n            throw e;\n        }\n        catch(ContinuationThrowable e)\n        {   \n            throw e;\n        }\n        catch(Exception e)\n        {\n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n            {\n                if (e instanceof IOException)\n                    throw (IOException)e;\n                if (e instanceof RuntimeException)\n                    throw (RuntimeException)e;\n                if (e instanceof ServletException)\n                    throw (ServletException)e;\n            }\n\n            // unwrap cause\n            Throwable th=e;\n            if (th instanceof UnavailableException)\n            {\n                LOG.debug(th); \n            }\n            else if (th instanceof ServletException)\n            {\n                LOG.debug(th);\n                Throwable cause=((ServletException)th).getRootCause();\n                if (cause!=null)\n                    th=cause;\n            }\n            else if (th instanceof RuntimeIOException)\n            {\n                LOG.debug(th);\n                Throwable cause=(IOException)((RuntimeIOException)th).getCause();\n                if (cause!=null)\n                    th=cause;\n            }\n\n            // handle or log exception\n            if (th instanceof HttpException)\n                throw (HttpException)th;\n            else if (th instanceof RuntimeIOException)\n                throw (RuntimeIOException)th;\n            else if (th instanceof EofException)\n                throw (EofException)th;\n\n            else if (LOG.isDebugEnabled())\n            {\n                LOG.warn(request.getRequestURI(), th); \n                LOG.debug(request.toString()); \n            }\n            else if (th instanceof IOException || th instanceof UnavailableException)\n            {\n                LOG.debug(request.getRequestURI(),th);\n            }\n            else\n            {\n                LOG.warn(request.getRequestURI(),th);\n            }\n\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,th.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,th);\n                if (th instanceof UnavailableException)\n                {\n                    UnavailableException ue = (UnavailableException)th;\n                    if (ue.isPermanent())\n                        response.sendError(HttpServletResponse.SC_NOT_FOUND,th.getMessage());\n                    else\n                        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,th.getMessage());\n                }\n                else\n                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,th.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \"+th);\n        }\n        catch(Error e)\n        {   \n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n                throw e;\n            LOG.warn(\"Error for \"+request.getRequestURI(),e);\n            if(LOG.isDebugEnabled())LOG.debug(request.toString());\n\n            // TODO httpResponse.getHttpConnection().forceClose();\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,e.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,e);\n                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,e.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \",e);\n        }\n        finally\n        {\n            baseRequest.setHandled(true);\n        }\n    }","id":28,"modified_method":"@Override\n    public void doHandle(String target, Request baseRequest,HttpServletRequest request, HttpServletResponse response)\n        throws IOException, ServletException\n    {\n        DispatcherType type = baseRequest.getDispatcherType();\n        \n        ServletHolder servlet_holder=(ServletHolder) baseRequest.getUserIdentityScope();\n        FilterChain chain=null;\n\n        // find the servlet\n        if (target.startsWith(\"/\"))\n        {\n            if (servlet_holder!=null && _filterMappings!=null && _filterMappings.length>0)\n                chain=getFilterChain(baseRequest, target, servlet_holder);\n        }\n        else\n        {\n            if (servlet_holder!=null)\n            {\n                if (_filterMappings!=null && _filterMappings.length>0)\n                {\n                    chain=getFilterChain(baseRequest, null,servlet_holder);\n                }\n            }\n        }\n\n        LOG.debug(\"chain={}\",chain);\n        \n        try\n        {\n            if (servlet_holder==null)\n            {\n                if (getHandler()==null)\n                    notFound(request, response);\n                else\n                    nextHandle(target,baseRequest,request,response);\n            }\n            else\n            {\n                // unwrap any tunnelling of base Servlet request/responses\n                ServletRequest req = request;\n                if (req instanceof ServletRequestHttpWrapper)\n                    req = ((ServletRequestHttpWrapper)req).getRequest();\n                ServletResponse res = response;\n                if (res instanceof ServletResponseHttpWrapper)\n                    res = ((ServletResponseHttpWrapper)res).getResponse();\n\n                // Do the filter/handling thang\n                if (chain!=null)\n                    chain.doFilter(req, res);\n                else \n                    servlet_holder.handle(baseRequest,req,res);\n            }\n        }\n        catch(EofException e)\n        {\n            throw e;\n        }\n        catch(RuntimeIOException e)\n        {\n            throw e;\n        }\n        catch(ContinuationThrowable e)\n        {   \n            throw e;\n        }\n        catch(Exception e)\n        {\n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n            {\n                if (e instanceof IOException)\n                    throw (IOException)e;\n                if (e instanceof RuntimeException)\n                    throw (RuntimeException)e;\n                if (e instanceof ServletException)\n                    throw (ServletException)e;\n            }\n\n            // unwrap cause\n            Throwable th=e;\n            if (th instanceof UnavailableException)\n            {\n                LOG.debug(th); \n            }\n            else if (th instanceof ServletException)\n            {\n                LOG.debug(th);\n                Throwable cause=((ServletException)th).getRootCause();\n                if (cause!=null)\n                    th=cause;\n            }\n            else if (th instanceof RuntimeIOException)\n            {\n                LOG.debug(th);\n                Throwable cause=(IOException)((RuntimeIOException)th).getCause();\n                if (cause!=null)\n                    th=cause;\n            }\n\n            // handle or log exception\n            if (th instanceof HttpException)\n                throw (HttpException)th;\n            else if (th instanceof RuntimeIOException)\n                throw (RuntimeIOException)th;\n            else if (th instanceof EofException)\n                throw (EofException)th;\n\n            else if (LOG.isDebugEnabled())\n            {\n                LOG.warn(request.getRequestURI(), th); \n                LOG.debug(request.toString()); \n            }\n            else if (th instanceof IOException || th instanceof UnavailableException)\n            {\n                LOG.debug(request.getRequestURI(),th);\n            }\n            else\n            {\n                LOG.warn(request.getRequestURI(),th);\n            }\n\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,th.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,th);\n                if (th instanceof UnavailableException)\n                {\n                    UnavailableException ue = (UnavailableException)th;\n                    if (ue.isPermanent())\n                        response.sendError(HttpServletResponse.SC_NOT_FOUND,th.getMessage());\n                    else\n                        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,th.getMessage());\n                }\n                else\n                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,th.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \"+th);\n        }\n        catch(Error e)\n        {   \n            if (!(DispatcherType.REQUEST.equals(type) || DispatcherType.ASYNC.equals(type)))\n                throw e;\n            LOG.warn(\"Error for \"+request.getRequestURI(),e);\n            if(LOG.isDebugEnabled())LOG.debug(request.toString());\n\n            // TODO httpResponse.getHttpConnection().forceClose();\n            if (!response.isCommitted())\n            {\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION_TYPE,e.getClass());\n                request.setAttribute(Dispatcher.ERROR_EXCEPTION,e);\n                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,e.getMessage());\n            }\n            else\n                LOG.debug(\"Response already committed for handling \",e);\n        }\n        finally\n        {\n            baseRequest.setHandled(true);\n        }\n    }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void doFilter(ServletRequest request, ServletResponse response) \n            throws IOException, ServletException\n        {\n            // pass to next filter\n            if (_filterHolder!=null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call filter \" + _filterHolder);\n                Filter filter= _filterHolder.getFilter();\n                if (_filterHolder.isAsyncSupported())\n                    filter.doFilter(request, response, _next);\n                else\n                {\n                    final Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n                    final boolean suspendable=baseRequest.isAsyncSupported();\n                    if (suspendable)\n                    {\n                        try\n                        {\n                            baseRequest.setAsyncSupported(false);\n                            filter.doFilter(request, response, _next);\n                        }\n                        finally\n                        {\n                            baseRequest.setAsyncSupported(true);\n                        }\n                    }\n                    else\n                        filter.doFilter(request, response, _next);\n                }\n                return;\n            }\n\n            // Call servlet\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call servlet \" + _servletHolder);\n                final Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n                _servletHolder.handle(baseRequest,request, response);\n            }\n            else // Not found\n                notFound((HttpServletRequest)request, (HttpServletResponse)response);\n        }","id":29,"modified_method":"public void doFilter(ServletRequest request, ServletResponse response) \n            throws IOException, ServletException\n        {                   \n            final Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n\n            // pass to next filter\n            if (_filterHolder!=null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call filter \" + _filterHolder);\n                Filter filter= _filterHolder.getFilter();\n                if (_filterHolder.isAsyncSupported())\n                    filter.doFilter(request, response, _next);\n                else\n                {\n                    final boolean suspendable=baseRequest.isAsyncSupported();\n                    if (suspendable)\n                    {\n                        try\n                        {\n                            baseRequest.setAsyncSupported(false);\n                            filter.doFilter(request, response, _next);\n                        }\n                        finally\n                        {\n                            baseRequest.setAsyncSupported(true);\n                        }\n                    }\n                    else\n                        filter.doFilter(request, response, _next);\n                }\n                return;\n            }\n\n            // Call servlet\n            \n            HttpServletRequest srequest = (HttpServletRequest)request;\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"call servlet \" + _servletHolder);\n                _servletHolder.handle(baseRequest,request, response);\n            }\n            else if (getHandler()==null)\n                notFound(srequest, (HttpServletResponse)response);\n            else\n                nextHandle(URIUtil.addPaths(srequest.getServletPath(),srequest.getPathInfo()),\n                           baseRequest,srequest,(HttpServletResponse)response);\n            \n        }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void doFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException\n        {\n            if (LOG.isDebugEnabled()) \n                LOG.debug(\"doFilter \" + _filter);\n\n            // pass to next filter\n            if (_filter < LazyList.size(_chain))\n            {\n                FilterHolder holder= (FilterHolder)LazyList.get(_chain, _filter++);\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call filter \" + holder);\n                Filter filter= holder.getFilter();\n                \n                if (holder.isAsyncSupported() || !_baseRequest.isAsyncSupported())\n                {\n                    filter.doFilter(request, response, this);\n                }\n                else\n                {\n                    try\n                    {\n                        _baseRequest.setAsyncSupported(false);\n                        filter.doFilter(request, response, this);\n                    }\n                    finally\n                    {\n                        _baseRequest.setAsyncSupported(true);\n                    }\n                }\n                    \n                return;\n            }\n\n            // Call servlet\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call servlet \" + _servletHolder);\n                _servletHolder.handle(_baseRequest,request, response);\n            }\n            else // Not found\n                notFound((HttpServletRequest)request, (HttpServletResponse)response);\n        }","id":30,"modified_method":"public void doFilter(ServletRequest request, ServletResponse response)\n            throws IOException, ServletException\n        {\n            if (LOG.isDebugEnabled()) \n                LOG.debug(\"doFilter \" + _filter);\n\n            // pass to next filter\n            if (_filter < LazyList.size(_chain))\n            {\n                FilterHolder holder= (FilterHolder)LazyList.get(_chain, _filter++);\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call filter \" + holder);\n                Filter filter= holder.getFilter();\n                \n                if (holder.isAsyncSupported() || !_baseRequest.isAsyncSupported())\n                {\n                    filter.doFilter(request, response, this);\n                }\n                else\n                {\n                    try\n                    {\n                        _baseRequest.setAsyncSupported(false);\n                        filter.doFilter(request, response, this);\n                    }\n                    finally\n                    {\n                        _baseRequest.setAsyncSupported(true);\n                    }\n                }\n                    \n                return;\n            }\n\n            // Call servlet\n            HttpServletRequest srequest = (HttpServletRequest)request;\n            if (_servletHolder != null)\n            {\n                if (LOG.isDebugEnabled()) \n                    LOG.debug(\"call servlet \" + _servletHolder);\n                _servletHolder.handle(_baseRequest,request, response);\n            }\n            else if (getHandler()==null)\n                notFound(srequest, (HttpServletResponse)response);\n            else\n            {            \n                Request baseRequest=(request instanceof Request)?((Request)request):AbstractHttpConnection.getCurrentConnection().getRequest();\n                nextHandle(URIUtil.addPaths(srequest.getServletPath(),srequest.getPathInfo()),\n                           baseRequest,srequest,(HttpServletResponse)response);\n            }\n        }","commit_id":"050afb8d57ee38d2c384a81f821677d76d340fe3","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n   public void parseTMX() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Dates were modified to match the TM header in the file\n      Calendar cal = Calendar.getInstance();\n      cal.setTime(tm.getCreationDate());\n      assertThat(cal.get(Calendar.YEAR), is(2013));\n      assertThat(cal.get(Calendar.MONTH), is(4));\n      assertThat(cal.get(Calendar.DATE), is(10));\n\n      assertThat(tm.getSourceLanguage(), equalTo(\"en\"));\n\n      // TM metadata\n      assertThat(tm.getMetadata().size(), greaterThan(0));\n      assertThat(tm.getMetadata().get(TMMetadataType.TMX14), notNullValue());\n\n      // Translation Units\n      for(TransMemoryUnit tu : tm.getTranslationUnits())\n      {\n         assertThat(tu.getTransUnitVariants().size(), greaterThan(0));\n      }\n   }","id":31,"modified_method":"@Test\n   public void parseTMX() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Dates were modified to match the TM header in the file\n      Calendar cal = Calendar.getInstance();\n      cal.setTime(tm.getCreationDate());\n      assertThat(cal.get(Calendar.YEAR), is(2013));\n      assertThat(cal.get(Calendar.MONTH), is(4));\n      assertThat(cal.get(Calendar.DATE), is(10));\n\n      assertThat(tm.getSourceLanguage(), equalTo(\"en\"));\n\n      // TM metadata\n      assertThat(tm.getMetadata().size(), greaterThan(0));\n      assertThat(tm.getMetadata().get(TMMetadataType.TMX14), notNullValue());\n\n      // Translation Units\n      for(TransMemoryUnit tu : tm.getTranslationUnits())\n      {\n         assertThat(tu.getTransUnitVariants().size(), greaterThan(0));\n      }\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void mergeComplementaryTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should add all new tuids)\n      populateTMFromFile(tm, \"/tmx/valid-tm-with-tuids.tmx\");\n\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(8));\n   }","id":32,"modified_method":"@Test\n   public void mergeComplementaryTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should add all new tuids)\n      populateTMFromFile(tm, \"/tmx/valid-tm-with-tuids.tmx\");\n\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(8));\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void parseTMXWithMetadata() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/valid-tmx-with-metadata.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n\n      // Metadata at the header level\n      Map<String,String> tmAtts = TMXMetadataHelper.getAttributes(tm);\n      assertThat(tmAtts.size(), is(9));\n      assertThat(tmAtts, hasEntry(\"segtype\", \"paragraph\"));\n      assertThat(tmAtts, hasEntry(\"creationtoolversion\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"creationtool\", \"Zanata TransMemoryExportTMXStrategy\"));\n      assertThat(tmAtts, hasEntry(\"datatype\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"adminlang\", \"en\"));\n      assertThat(tmAtts, hasEntry(\"o-tmf\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"srclang\", \"*all*\"));\n      assertThat(tmAtts, hasKey(\"creationdate\"));\n      assertThat(tmAtts, hasKey(\"changedate\"));\n\n      List<Element> tmChildren = TMXMetadataHelper.getChildren(tm);\n      assertThat(tmChildren.size(), is(2));\n      assertThat(tmChildren.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tmChildren.get(0).getValue(), is(\"Header Prop value\"));\n      assertThat(tmChildren.get(1).getLocalName(), is(\"note\"));\n      assertThat(tmChildren.get(1).getValue(), is(\"Header Note value\"));\n\n      // Metadata at the TU level\n      TransMemoryUnit tu0 = findInCollection(tm.getTranslationUnits(), \"doc0:resId0\");\n      Map<String,String> tu0Atts = TMXMetadataHelper.getAttributes(tu0);\n      assertThat(tu0Atts.size(), is(4));\n      assertThat(tu0Atts, hasEntry(\"tuid\", \"doc0:resId0\"));\n      assertThat(tu0Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu0Atts, hasKey(\"creationdate\"));\n      assertThat(tu0Atts, hasKey(\"changedate\"));\n\n      List<Element> tu0Children = TMXMetadataHelper.getChildren(tu0);\n      assertThat(tu0Children.size(), is(2));\n      assertThat(tu0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu0Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tu0Children.get(1).getValue(), is(\"Custom note\"));\n\n      TransMemoryUnit tu1 = findInCollection(tm.getTranslationUnits(), \"doc0:resId1\");\n      Map<String,String> tu1Atts = TMXMetadataHelper.getAttributes(tu1);\n      assertThat(tu1Atts.size(), is(4));\n      assertThat(tu1Atts, hasEntry(\"tuid\", \"doc0:resId1\"));\n      assertThat(tu1Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu1Atts, hasKey(\"creationdate\"));\n      assertThat(tu1Atts, hasKey(\"changedate\"));\n\n      List<Element> tu1Children = TMXMetadataHelper.getChildren(tu1);\n      assertThat(tu1Children.size(), is(4));\n      assertThat(tu1Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu1Children.get(1).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(1).getValue(), is(\"Custom prop1 value\"));\n      assertThat(tu1Children.get(2).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(2).getValue(), is(\"Custom note0\"));\n      assertThat(tu1Children.get(3).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(3).getValue(), is(\"Custom note1\"));\n\n      // Metadata at the TUV level\n      TransMemoryUnitVariant tuv0 = tu0.getTransUnitVariants().get(\"en\");\n      Map<String, String> tuv0Atts = TMXMetadataHelper.getAttributes(tuv0);\n      assertThat(tuv0Atts.size(), is(3));\n      assertThat(tuv0Atts, hasEntry(\"xml:lang\", \"en\"));\n      assertThat(tuv0Atts, hasKey(\"creationdate\"));\n      assertThat(tuv0Atts, hasKey(\"changedate\"));\n\n      List<Element> tuv0Children = TMXMetadataHelper.getChildren(tuv0);\n      assertThat(tuv0Children.size(), is(2));\n      assertThat(tuv0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tuv0Children.get(0).getValue(), is(\"Custom prop0 value on tuv\"));\n      assertThat(tuv0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tuv0Children.get(1).getValue(), is(\"Custom note on tuv\"));\n   }","id":33,"modified_method":"@Test\n   public void parseTMXWithMetadata() throws Exception\n   {\n      // Create a TM\n      TransMemory tm = createTMFromFile(\"/tmx/valid-tmx-with-metadata.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n\n      // Metadata at the header level\n      Map<String,String> tmAtts = TMXMetadataHelper.getAttributes(tm);\n      assertThat(tmAtts.size(), is(9));\n      assertThat(tmAtts, hasEntry(\"segtype\", \"paragraph\"));\n      assertThat(tmAtts, hasEntry(\"creationtoolversion\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"creationtool\", \"Zanata TransMemoryExportTMXStrategy\"));\n      assertThat(tmAtts, hasEntry(\"datatype\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"adminlang\", \"en\"));\n      assertThat(tmAtts, hasEntry(\"o-tmf\", \"unknown\"));\n      assertThat(tmAtts, hasEntry(\"srclang\", \"*all*\"));\n      assertThat(tmAtts, hasKey(\"creationdate\"));\n      assertThat(tmAtts, hasKey(\"changedate\"));\n\n      List<Element> tmChildren = TMXMetadataHelper.getChildren(tm);\n      assertThat(tmChildren.size(), is(2));\n      assertThat(tmChildren.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tmChildren.get(0).getValue(), is(\"Header Prop value\"));\n      assertThat(tmChildren.get(1).getLocalName(), is(\"note\"));\n      assertThat(tmChildren.get(1).getValue(), is(\"Header Note value\"));\n\n      // Metadata at the TU level\n      TransMemoryUnit tu0 = findInCollection(tm.getTranslationUnits(), \"doc0:resId0\");\n      Map<String,String> tu0Atts = TMXMetadataHelper.getAttributes(tu0);\n      assertThat(tu0Atts.size(), is(4));\n      assertThat(tu0Atts, hasEntry(\"tuid\", \"doc0:resId0\"));\n      assertThat(tu0Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu0Atts, hasKey(\"creationdate\"));\n      assertThat(tu0Atts, hasKey(\"changedate\"));\n\n      List<Element> tu0Children = TMXMetadataHelper.getChildren(tu0);\n      assertThat(tu0Children.size(), is(2));\n      assertThat(tu0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu0Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tu0Children.get(1).getValue(), is(\"Custom note\"));\n\n      TransMemoryUnit tu1 = findInCollection(tm.getTranslationUnits(), \"doc0:resId1\");\n      Map<String,String> tu1Atts = TMXMetadataHelper.getAttributes(tu1);\n      assertThat(tu1Atts.size(), is(4));\n      assertThat(tu1Atts, hasEntry(\"tuid\", \"doc0:resId1\"));\n      assertThat(tu1Atts, hasEntry(\"srclang\", \"en\"));\n      assertThat(tu1Atts, hasKey(\"creationdate\"));\n      assertThat(tu1Atts, hasKey(\"changedate\"));\n\n      List<Element> tu1Children = TMXMetadataHelper.getChildren(tu1);\n      assertThat(tu1Children.size(), is(4));\n      assertThat(tu1Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(0).getValue(), is(\"Custom prop0 value\"));\n      assertThat(tu1Children.get(1).getLocalName(), is(\"prop\"));\n      assertThat(tu1Children.get(1).getValue(), is(\"Custom prop1 value\"));\n      assertThat(tu1Children.get(2).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(2).getValue(), is(\"Custom note0\"));\n      assertThat(tu1Children.get(3).getLocalName(), is(\"note\"));\n      assertThat(tu1Children.get(3).getValue(), is(\"Custom note1\"));\n\n      // Metadata at the TUV level\n      TransMemoryUnitVariant tuv0 = tu0.getTransUnitVariants().get(\"en\");\n      Map<String, String> tuv0Atts = TMXMetadataHelper.getAttributes(tuv0);\n      assertThat(tuv0Atts.size(), is(3));\n      assertThat(tuv0Atts, hasEntry(\"xml:lang\", \"en\"));\n      assertThat(tuv0Atts, hasKey(\"creationdate\"));\n      assertThat(tuv0Atts, hasKey(\"changedate\"));\n\n      List<Element> tuv0Children = TMXMetadataHelper.getChildren(tuv0);\n      assertThat(tuv0Children.size(), is(2));\n      assertThat(tuv0Children.get(0).getLocalName(), is(\"prop\"));\n      assertThat(tuv0Children.get(0).getValue(), is(\"Custom prop0 value on tuv\"));\n      assertThat(tuv0Children.get(1).getLocalName(), is(\"note\"));\n      assertThat(tuv0Children.get(1).getValue(), is(\"Custom note on tuv\"));\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void mergeSameTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should yield the same result)\n      populateTMFromFile(tm, \"/tmx/default-valid-tm.tmx\");\n\n      getEm().flush();\n      getEm().refresh(tm);\n      assertThat(tm.getTranslationUnits().size(), is(4));\n   }","id":34,"modified_method":"@Test\n   public void mergeSameTM() throws Exception\n   {\n      // Initial load\n      TransMemory tm = createTMFromFile(\"/tmx/default-valid-tm.tmx\");\n\n      // Make sure everything is stored properly\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n\n      // Second load (should yield the same result)\n      populateTMFromFile(tm, \"/tmx/default-valid-tm.tmx\");\n\n      tm = getEm().find(TransMemory.class, tm.getId());\n      assertThat(tm.getTranslationUnits().size(), is(4));\n   }","commit_id":"860f62f3952f4223d2da4b2c18cbce13f7677f7e","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes) throws CantRunException {\n    final String packageName = myConfig.getPersistantData().getPackageName();\n    PsiPackage psiPackage = ApplicationManager.getApplication().runReadAction(\n      new Computable<PsiPackage>() {\n        @Nullable\n        public PsiPackage compute() {\n          return JavaPsiFacade.getInstance(myConfig.getProject()).findPackage(packageName);\n        }\n      }\n    );\n    if (psiPackage == null) {\n      throw CantRunException.packageNotFound(packageName);\n    }\n    else {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      //TODO we should narrow this down by module really, if that's what's specified\n      TestClassFilter projectFilter =\n        new TestClassFilter(scope.getSourceScope(myConfig).getGlobalSearchScope(), myConfig.getProject(), true, true);\n      TestClassFilter filter = projectFilter.intersectionWith(PackageScope.packageScope(psiPackage, true));\n      calculateDependencies(null, classes, getSearchScope(), TestNGUtil.getAllTestClasses(filter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in the package \\\"\" + packageName + '\\\"');\n      }\n    }\n  }","id":35,"modified_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes) throws CantRunException {\n    final String packageName = myConfig.getPersistantData().getPackageName();\n    PsiPackage psiPackage = ApplicationManager.getApplication().runReadAction(\n      new Computable<PsiPackage>() {\n        @Nullable\n        public PsiPackage compute() {\n          return JavaPsiFacade.getInstance(myConfig.getProject()).findPackage(packageName);\n        }\n      }\n    );\n    if (psiPackage == null) {\n      throw CantRunException.packageNotFound(packageName);\n    }\n    else {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      //TODO we should narrow this down by module really, if that's what's specified\n      SourceScope sourceScope = scope.getSourceScope(myConfig);\n      TestClassFilter projectFilter =\n        new TestClassFilter(sourceScope != null ? sourceScope.getGlobalSearchScope() : GlobalSearchScope.projectScope(myConfig.getProject()), myConfig.getProject(), true, true);\n      TestClassFilter filter = projectFilter.intersectionWith(PackageScope.packageScope(psiPackage, true));\n      calculateDependencies(null, classes, getSearchScope(), TestNGUtil.getAllTestClasses(filter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in the package \\\"\" + packageName + '\\\"');\n      }\n    }\n  }","commit_id":"e00caa280b3980702c0a65aa138b4d46a49a115d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    //for a group, we include all classes\n    final TestClassFilter classFilter =\n      new TestClassFilter(data.getScope().getSourceScope(myConfig).getGlobalSearchScope(), myConfig.getProject(), true, true);\n    PsiClass[] testClasses = TestNGUtil.getAllTestClasses(classFilter, false);\n    if (testClasses != null) {\n      for (PsiClass c : testClasses) {\n        classes.put(c, new LinkedHashMap<PsiMethod, List<String>>());\n      }\n    }\n  }","id":36,"modified_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    //for a group, we include all classes\n    final SourceScope sourceScope = data.getScope().getSourceScope(myConfig);\n    final TestClassFilter classFilter =\n      new TestClassFilter(sourceScope != null ? sourceScope.getGlobalSearchScope() : GlobalSearchScope.allScope(myConfig.getProject()),\n                          myConfig.getProject(), true, true);\n    PsiClass[] testClasses = TestNGUtil.getAllTestClasses(classFilter, false);\n    if (testClasses != null) {\n      for (PsiClass c : testClasses) {\n        classes.put(c, new LinkedHashMap<PsiMethod, List<String>>());\n      }\n    }\n  }","commit_id":"ef27a59a57e5d11ef9b43dffdf65c2d0259135f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    for (final String pattern : data.getPatterns()) {\n      final String className;\n      final String methodName;\n      if (pattern.contains(\",\")) {\n        methodName = StringUtil.getShortName(pattern, ',');\n        className = StringUtil.getPackageName(pattern, ',');\n      } else {\n        className = pattern;\n        methodName = null;\n      }\n\n      final PsiClass psiClass = ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>() {\n        @Nullable\n        @Override\n        public PsiClass compute() {\n          return ClassUtil.findPsiClass(PsiManager.getInstance(myConfig.getProject()), className.replace('/', '.'), null, true, getSearchScope());\n        }\n      });\n      if (psiClass != null) {\n        final Boolean hasTest = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n          @Override\n          public Boolean compute() {\n            return TestNGUtil.hasTest(psiClass);\n          }\n        });\n        if (hasTest) {\n          if (StringUtil.isEmpty(methodName)) {\n            calculateDependencies(null, classes, psiClass);\n          }\n          else {\n            collectTestMethods(classes, psiClass, methodName);\n          }\n        } else {\n          throw new CantRunException(\"No tests found in class \" + className);\n        }\n      }\n    }\n    if (classes.size() != data.getPatterns().size()) {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      final List<Pattern> compilePatterns = new ArrayList<Pattern>();\n      for (String p : data.getPatterns()) {\n        final Pattern compilePattern;\n        try {\n          compilePattern = Pattern.compile(p);\n        }\n        catch (PatternSyntaxException e) {\n          continue;\n        }\n        if (compilePattern != null) {\n          compilePatterns.add(compilePattern);\n        }\n      }\n      TestClassFilter projectFilter =\n        new TestClassFilter(scope.getSourceScope(myConfig).getGlobalSearchScope(), myConfig.getProject(), true, true){\n          @Override\n          public boolean isAccepted(PsiClass psiClass) {\n            if (super.isAccepted(psiClass)) {\n              final String qualifiedName = psiClass.getQualifiedName();\n              LOG.assertTrue(qualifiedName != null);\n              for (Pattern pattern : compilePatterns) {\n                if (pattern.matcher(qualifiedName).matches()) return true;\n              }\n            }\n            return false;\n          }\n        };\n      calculateDependencies(null, classes, TestNGUtil.getAllTestClasses(projectFilter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in for patterns \\\"\" + StringUtil.join(data.getPatterns(), \" || \") + '\\\"');\n      }\n    }\n  }","id":37,"modified_method":"@Override\n  public void fillTestObjects(Map<PsiClass, Map<PsiMethod, List<String>>> classes)\n    throws CantRunException {\n    final TestData data = myConfig.getPersistantData();\n    for (final String pattern : data.getPatterns()) {\n      final String className;\n      final String methodName;\n      if (pattern.contains(\",\")) {\n        methodName = StringUtil.getShortName(pattern, ',');\n        className = StringUtil.getPackageName(pattern, ',');\n      } else {\n        className = pattern;\n        methodName = null;\n      }\n\n      final PsiClass psiClass = ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>() {\n        @Nullable\n        @Override\n        public PsiClass compute() {\n          return ClassUtil.findPsiClass(PsiManager.getInstance(myConfig.getProject()), className.replace('/', '.'), null, true, getSearchScope());\n        }\n      });\n      if (psiClass != null) {\n        final Boolean hasTest = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n          @Override\n          public Boolean compute() {\n            return TestNGUtil.hasTest(psiClass);\n          }\n        });\n        if (hasTest) {\n          if (StringUtil.isEmpty(methodName)) {\n            calculateDependencies(null, classes, psiClass);\n          }\n          else {\n            collectTestMethods(classes, psiClass, methodName);\n          }\n        } else {\n          throw new CantRunException(\"No tests found in class \" + className);\n        }\n      }\n    }\n    if (classes.size() != data.getPatterns().size()) {\n      TestSearchScope scope = myConfig.getPersistantData().getScope();\n      final List<Pattern> compilePatterns = new ArrayList<Pattern>();\n      for (String p : data.getPatterns()) {\n        final Pattern compilePattern;\n        try {\n          compilePattern = Pattern.compile(p);\n        }\n        catch (PatternSyntaxException e) {\n          continue;\n        }\n        compilePatterns.add(compilePattern);\n      }\n      final SourceScope sourceScope = scope.getSourceScope(myConfig);\n      TestClassFilter projectFilter =\n        new TestClassFilter(sourceScope != null ? sourceScope.getGlobalSearchScope() : GlobalSearchScope.allScope(myConfig.getProject()), myConfig.getProject(), true, true){\n          @Override\n          public boolean isAccepted(PsiClass psiClass) {\n            if (super.isAccepted(psiClass)) {\n              final String qualifiedName = psiClass.getQualifiedName();\n              LOG.assertTrue(qualifiedName != null);\n              for (Pattern pattern : compilePatterns) {\n                if (pattern.matcher(qualifiedName).matches()) return true;\n              }\n            }\n            return false;\n          }\n        };\n      calculateDependencies(null, classes, TestNGUtil.getAllTestClasses(projectFilter, false));\n      if (classes.size() == 0) {\n        throw new CantRunException(\"No tests found in for patterns \\\"\" + StringUtil.join(data.getPatterns(), \" || \") + '\\\"');\n      }\n    }\n  }","commit_id":"ef27a59a57e5d11ef9b43dffdf65c2d0259135f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateImpl(PresentationData data) {\n    final PsiClass value = getValue();\n    if (value != null) {\n      data.setPresentableText(value.getName());\n    }\n  }","id":38,"modified_method":"public void updateImpl(PresentationData data) {\n    final PsiClass aClass = getValue();\n    if (aClass != null) {\n      data.setPresentableText(aClass.getName());\n      final String qName = aClass.getQualifiedName();\n      if (qName != null) {\n        final CoverageDataManager coverageManager = CoverageDataManager.getInstance(aClass.getProject());\n        final String coverageString = coverageManager.getClassCoverageInormationString(qName);\n        if (coverageString != null) {\n          data.setLocationString(coverageString);\n        }\n      }\n    }\n  }","commit_id":"3f8d1c24b825c9b5d175e519d4b8740601cd676a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateImpl(PresentationData data) {\n    final PsiClass value = getPsiClass();\n    if (value != null) {\n      data.setPresentableText(value.getName());\n    }\n  }","id":39,"modified_method":"public void updateImpl(PresentationData data) {\n    final PsiClass aClass = getPsiClass();\n    if (aClass != null) {\n      data.setPresentableText(aClass.getName());\n      final String qName = aClass.getQualifiedName();\n      if (qName != null) {\n        final CoverageDataManager coverageManager = CoverageDataManager.getInstance(myProject);\n        data.setLocationString(coverageManager.getClassCoverageInformationString(qName));\n      }\n    }\n  }","commit_id":"a97ad858cc65e177a22f2de7d8e3b0e47ac86521","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void updateImpl(PresentationData data) {\n        JetClassOrObject value = getValue();\n        if (value != null) {\n            data.setPresentableText(value.getName());\n        }\n    }","id":40,"modified_method":"@Override\n    protected void updateImpl(PresentationData data) {\n        JetClassOrObject classOrObject = getValue();\n        if (classOrObject != null) {\n            data.setPresentableText(classOrObject.getName());\n\n            AbstractTreeNode parent = getParent();\n            if (JetIconProvider.getMainClass((JetFile) classOrObject.getContainingFile()) != null) {\n                if (parent instanceof JetFileTreeNode) {\n                    update(parent.getParent());\n                }\n            }\n            else {\n                if (!(parent instanceof JetClassOrObjectTreeNode) && !(parent instanceof JetFileTreeNode)) {\n                    update(parent);\n                }\n            }\n        }\n    }","commit_id":"9aee8a98e0c19b5ae037b34b57be91e0501e14a0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":41,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"91ace34713edccaac6d02aedbbbdde2a626fdf21","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":42,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"0027ff4b655905986745b74c92bdc18ef22095a4","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":43,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"9be424b4481c15bc98772c49ff9063b125d27d93","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":44,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"71385703557babd76a92606bceac6c7bce914383","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":45,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"799d4d91102cec187bed5d9aef4199b019e041f5","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                FakeSlaveBroker broker = new FakeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() ); \n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":46,"modified_method":"@Override\n    protected void initializeDbs( int numSlaves, Map<String,String> config )\n    {\n        try\n        {\n            createDeadDbs( numSlaves );\n            haDbs = new ArrayList<GraphDatabaseService>();\n            startUpMaster( config );\n            for ( int i = 1; i <= numSlaves; i++ )\n            {\n                File slavePath = dbPath( i );\n                Broker broker = makeSlaveBroker( master, 0, i, slavePath.getAbsolutePath() );\n                Map<String,String> cfg = new HashMap<String, String>(config);\n                cfg.put( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, Integer.toString(i) );\n                cfg.put( Config.KEEP_LOGICAL_LOGS, \"true\" );\n                HighlyAvailableGraphDatabase db = new HighlyAvailableGraphDatabase(\n                        slavePath.getAbsolutePath(), cfg, AbstractBroker.wrapSingleBroker( broker ) );\n                // db.newMaster( null, new Exception() );\n                haDbs.add( db );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"b244d4bc370b9f7fd23fa46990b13d24051115b7","url":"https://github.com/neo4j/neo4j"},{"original_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            prepareNextLevel();\n        }","id":47,"modified_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            \n            if ( sharedCurrentDepth.value < maxDepth )\n            {\n                prepareNextLevel();\n            }\n            else\n            {\n                this.nextRelationships = Collections.<Relationship>emptyList().iterator();\n            }\n        }","commit_id":"cbf41d1e195b5be27030620879f59d9366129671","url":"https://github.com/neo4j/neo4j"},{"original_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            prepareNextLevel();\n        }","id":48,"modified_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            \n            if ( sharedCurrentDepth.value < maxDepth )\n            {\n                prepareNextLevel();\n            }\n            else\n            {\n                this.nextRelationships = Collections.<Relationship>emptyList().iterator();\n            }\n        }","commit_id":"6d1cee1f931c634a2a9f500fe01c38aa127c004a","url":"https://github.com/neo4j/neo4j"},{"original_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            prepareNextLevel();\n        }","id":49,"modified_method":"DirectionData( Node startNode, Collection<Long> sharedVisitedRels,\n                MutableInteger sharedFrozenDepth, MutableBoolean sharedStop,\n                MutableInteger sharedCurrentDepth, boolean stopAsap,\n                RelationshipExpander expander )\n        {\n            this.startNode = startNode;\n            this.visitedNodes.put( startNode, new LevelData( null, 0 ) );\n            this.nextNodes.add( startNode );\n            this.sharedFrozenDepth = sharedFrozenDepth;\n            this.sharedStop = sharedStop;\n            this.sharedCurrentDepth = sharedCurrentDepth;\n            this.stopAsap = stopAsap;\n            this.expander = expander;\n            this.sharedVisitedRels = sharedVisitedRels;\n            \n            if ( sharedCurrentDepth.value < maxDepth )\n            {\n                prepareNextLevel();\n            }\n            else\n            {\n                this.nextRelationships = Collections.<Relationship>emptyList().iterator();\n            }\n        }","commit_id":"e6a9493a54aeef9ee3be6c6fe63cb7d847013c54","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Build div, optional input, and JavaScript into response.\n     *\n     * @see er.ajax.AjaxDynamicElement#appendToResponse(com.webobjects.appserver.WOResponse, com.webobjects.appserver.WOContext)\n     */\n    @Override\n    public void appendToResponse(WOResponse response, WOContext context) {\n        // We don't contain anything, but we need to call super so it calls addRequiredWebResources(WOResponse, WOContext)\n        super.appendToResponse(response, context);\n\n        // Build div like <div  id=\"e_1_0_0_1_3_7\" class=\"rating_container\"><\/div>\n        String id = id(context);\n        response.appendContentString(\"<div \");\n        appendTagAttributeToResponse(response, \"id\", id);\n        appendTagAttributeToResponse(response, \"class\", \"rating_container\");\n        response.appendContentString(\"><\/div>\");\n\n        // Build optional input like <input  id=\"e_1_0_0_1_3_7_input\" name=\"e_1_0_0_1_3_7_value\" value=\"5\" type=\"hidden\"/>\n        if (actAsInput(context)) {\n            response.appendContentString(\"<input \");\n            appendTagAttributeToResponse(response, \"id\", id + \"_input\");\n            appendTagAttributeToResponse(response, \"name\", formValueName(context));\n            appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", context.component()));\n            appendTagAttributeToResponse(response, \"type\", \"hidden\");\n            response.appendContentString(\"/>\");\n        }\n\n        // Build script like\n        // <script type=\"text/javascript\">\n        //     var e_1_0_0_1_3_7 = new Control.Rating('e_1_0_0_1_3_7',\n        //         {multiple:true, value:5, min:2, max:8, rated:false, input:'e_1_0_0_1_3_7_input', updateParameterName:'e_1_0_0_1_3_7_value'});\n        // <\/script>\n        response.appendContentString(\"<script type=\\\"text/javascript\\\">\");\n        response.appendContentString(\"var \");\n        response.appendContentString(id);\n        response.appendContentString(\" = new Control.Rating('\");\n        response.appendContentString(id);\n        response.appendContentString(\"', \");\n        AjaxOptions.appendToResponse(createOptions(context), response, context);\n        response.appendContentString(\"); <\/script>\");\n    }","id":50,"modified_method":"/**\n     * Build div, optional input, and JavaScript into response.\n     *\n     * @see er.ajax.AjaxDynamicElement#appendToResponse(com.webobjects.appserver.WOResponse, com.webobjects.appserver.WOContext)\n     */\n    @Override\n    public void appendToResponse(WOResponse response, WOContext context) {\n        // We don't contain anything, but we need to call super so it calls addRequiredWebResources(WOResponse, WOContext)\n        super.appendToResponse(response, context);\n\n        // Build container element like <div id=\"e_1_0_0_1_3_7\" class=\"rating_container\"><\/div>\n        \n        String id = id(context);\n        String elementName = (String) valueForBinding(\"elementName\", \"div\", context.component()); \n        response.appendContentString(\"<\");\n        response.appendContentString(elementName);\n        response.appendContentString(\" \");\n        appendTagAttributeToResponse(response, \"id\", id);\n        \n        String className = \"rating_container\";\n        if (hasBinding(\"class\")) {\n            className += \" \" + stringValueForBinding(\"class\", context.component());            \n        }\n        appendTagAttributeToResponse(response, \"class\", className);\n\n        if (hasBinding(\"style\")) {\n            appendTagAttributeToResponse(response, \"style\", stringValueForBinding(\"style\", context.component()));            \n        }\n        response.appendContentString(\"><\/\");\n        response.appendContentString(elementName);\n        response.appendContentString(\">\");\n\n        // Build optional input like <input id=\"e_1_0_0_1_3_7_input\" name=\"e_1_0_0_1_3_7_value\" value=\"5\" type=\"hidden\"/>\n        if (actAsInput(context)) {\n            response.appendContentString(\"<input \");\n            appendTagAttributeToResponse(response, \"id\", id + \"_input\");\n            appendTagAttributeToResponse(response, \"name\", formValueName(context));\n            appendTagAttributeToResponse(response, \"value\", valueForBinding(\"value\", context.component()));\n            appendTagAttributeToResponse(response, \"type\", \"hidden\");\n            response.appendContentString(\"/>\");\n        }\n\n        // Build script like\n        // <script type=\"text/javascript\">\n        //     var e_1_0_0_1_3_7 = new Control.Rating('e_1_0_0_1_3_7',\n        //         {multiple:true, value:5, min:2, max:8, rated:false, input:'e_1_0_0_1_3_7_input', updateParameterName:'e_1_0_0_1_3_7_value'});\n        // <\/script>\n        response.appendContentString(\"<script type=\\\"text/javascript\\\">\");\n        response.appendContentString(\"var \");\n        response.appendContentString(id);\n        response.appendContentString(\" = new Control.Rating('\");\n        response.appendContentString(id);\n        response.appendContentString(\"', \");\n        AjaxOptions.appendToResponse(createOptions(context), response, context);\n        response.appendContentString(\"); <\/script>\");\n    }","commit_id":"df6cb8f673da9069bc5ef81db463e22d5843cae8","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Creates the tabs and pane control.\n     */\n    public void appendToResponse(WOResponse response, WOContext context) {\n        WOComponent component = context.component();\n        String idString = (String) id.valueInComponent(component);\n        if (idString == null) {\n        \tthrow new RuntimeException(\"id binding evaluated to null\");\n        }\n\n        // UL for tabs\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanel\\\"\");\n        appendTagAttributeToResponse(response, \"id\", idString);\n        if (onLoad != null) {\n            appendTagAttributeToResponse(response, \"onLoad\", onLoad.valueInComponent(component));\n        }\n        response.appendContentString(\">\\n\");\n\n        String paneControlID = idString + \"_panecontrol\";\n\n        for (int i = 0; i < tabs.count(); i++) {\n            String index = new Integer(i).toString();\n            String tabID = idString + \"_tab_\" + index;\n            AjaxTabbedPanelTab tab = (AjaxTabbedPanelTab)tabs.objectAtIndex(i);\n            if (tab.isVisble(component)) {\n\t            boolean isSelectedTab = tab.isSelected(context.component());\n\t            String panelTabID = (String) tab.id().valueInComponent(component);\n\t            String panelID = panelTabID + \"_panel\";\n\t            response.appendContentString(\"  <li class=\\\"ajaxTabbedPanelTab-\");\n\t            response.appendContentString(isSelectedTab ? \"selected\" : \"unselected\");\n\t            response.appendContentString(\"\\\" \");\n\t            appendTagAttributeToResponse(response, \"id\", tabID);\n\t            response.appendContentString(\">\\n\");\n\t            response.appendContentString(\"<a \");\n\t            appendTagAttributeToResponse(response, \"id\", panelTabID);\n\t            response.appendContentString(\" href=\\\"javascript:void(0)\\\" onclick=\\\"\");\n\t\n\t            response.appendContentString(\"AjaxTabbedPanel.loadPanel('\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString((busyDiv != null) ? (String)busyDiv.valueInComponent(component) : \"\");\n\t            response.appendContentString(\"', \");\n\t            response.appendContentString(tab.refreshesOnSelect(context.component()).toString());\n\t            response.appendContentString(\"); \");\n\t\n\t            response.appendContentString(\"AjaxTabbedPanel.selectTab('\");\n\t            response.appendContentString(idString);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(tabID);\n\t            response.appendContentString(\"'); AjaxTabbedPanel.selectPanel('\");\n\t            response.appendContentString(paneControlID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"');\\\">\");\n\t            response.appendContentString((String) tab.name().valueInComponent(component));\n\t            response.appendContentString(\"<\/a>\\n\");\n\t            response.appendContentString(\"<\/li>\\n\");\n            }\n        }\n\n        response.appendContentString(\"<\/ul>\\n\");\n\n        // UL for panes\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanelPanes\\\" \");\n        appendTagAttributeToResponse(response, \"id\", paneControlID);\n        response.appendContentString(\">\\n\");\n        // The tabs render themselves as panes\n        if (content !=  null) {\n        \tcontent.appendToResponse(response, context);\n        }\n        response.appendContentString(\"<\/ul>\\n\");\n        super.appendToResponse(response, context);\n\n        response.appendContentString(\"<script>AjaxTabbedPanel.onLoad('\");\n        response.appendContentString(idString);\n        response.appendContentString(\"');<\/script>\\n\");\n    }","id":51,"modified_method":"/**\n     * Creates the tabs and pane control.\n     */\n    public void appendToResponse(WOResponse response, WOContext context) {\n        WOComponent component = context.component();\n        String idString = (String) id.valueInComponent(component);\n        if (idString == null) {\n        \tthrow new RuntimeException(\"id binding evaluated to null\");\n        }\n\n        // UL for tabs\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanel\\\"\");\n        appendTagAttributeToResponse(response, \"id\", idString);\n        \n        // Optional JavaScriplets\n        if (onLoad != null) {\n            appendTagAttributeToResponse(response, \"onLoad\", onLoad.valueInComponent(component));\n        }\n        if (onSelect != null) {\n            appendTagAttributeToResponse(response, \"onSelect\", onSelect.valueInComponent(component));\n        }\n        \n        response.appendContentString(\">\\n\");\n\n        String paneControlID = idString + \"_panecontrol\";\n\n        for (int i = 0; i < tabs.count(); i++) {\n            String index = new Integer(i).toString();\n            String tabID = idString + \"_tab_\" + index;\n            AjaxTabbedPanelTab tab = (AjaxTabbedPanelTab)tabs.objectAtIndex(i);\n            if (tab.isVisble(component)) {\n\t            boolean isSelectedTab = tab.isSelected(context.component());\n\t            String panelTabID = (String) tab.id().valueInComponent(component);\n\t            String panelID = panelTabID + \"_panel\";\n\t            response.appendContentString(\"  <li class=\\\"ajaxTabbedPanelTab-\");\n\t            response.appendContentString(isSelectedTab ? \"selected\" : \"unselected\");\n\t            response.appendContentString(\"\\\" \");\n\t            appendTagAttributeToResponse(response, \"id\", tabID);\n\t            response.appendContentString(\">\\n\");\n\t            response.appendContentString(\"<a \");\n\t            appendTagAttributeToResponse(response, \"id\", panelTabID);\n\t            response.appendContentString(\" href=\\\"javascript:void(0)\\\" onclick=\\\"\");\n\t\n\t            // Load the tab contents\n\t            response.appendContentString(\"AjaxTabbedPanel.loadPanel('\");\n\t            response.appendContentString(idString);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString((busyDiv != null) ? (String)busyDiv.valueInComponent(component) : \"\");\n\t            response.appendContentString(\"', \");\n\t            response.appendContentString(tab.refreshesOnSelect(context.component()).toString());\n\t            response.appendContentString(\"); \");\n\t            \n\t            // Select the tab contents\n\t            response.appendContentString(\"AjaxTabbedPanel.selectPanel('\");\n\t            response.appendContentString(paneControlID);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(panelID);\n\t            response.appendContentString(\"'); \");\n\t            \n\t            // Select the tab control\n\t            response.appendContentString(\"AjaxTabbedPanel.selectTab('\");\n\t            response.appendContentString(idString);\n\t            response.appendContentString(\"', '\");\n\t            response.appendContentString(tabID);\n\t            response.appendContentString(\"'); \");\n\t            \n\t            response.appendContentString(\"\\\">\");\n\t            response.appendContentString((String) tab.name().valueInComponent(component));\n\t            response.appendContentString(\"<\/a>\\n\");\n\t            response.appendContentString(\"<\/li>\\n\");\n            }\n        }\n\n        response.appendContentString(\"<\/ul>\\n\");\n\n        // UL for panes\n        response.appendContentString(\"<ul class=\\\"ajaxTabbedPanelPanes\\\" \");\n        appendTagAttributeToResponse(response, \"id\", paneControlID);\n        response.appendContentString(\">\\n\");\n        // The tabs render themselves as panes\n        if (content !=  null) {\n        \tcontent.appendToResponse(response, context);\n        }\n        response.appendContentString(\"<\/ul>\\n\");\n        super.appendToResponse(response, context);\n\n        response.appendContentString(\"<script>AjaxTabbedPanel.onLoad('\");\n        response.appendContentString(idString);\n        response.appendContentString(\"');<\/script>\\n\");\n    }","commit_id":"a1bc7570d92f4359d19a72c2e6900351b15ef209","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\t}","id":52,"modified_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.FORMATTED);\n\t\t}\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void partition(final String volumeId, final String device)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\t}","id":53,"modified_method":"@Override\n\tpublic void partition(final String volumeId, final String device)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.PARTITIONED);\n\t\t}\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem, timeoutInMillis);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\n\t}","id":54,"modified_method":"@Override\n\tpublic void format(final String volumeId, final String device, final String fileSystem, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot format when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Formatting device \" + device + \" to File System \" + fileSystem);\n\t\tVolumeUtils.format(device, fileSystem, timeoutInMillis);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.FORMATTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.FORMATTED);\n\t\t}\n\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\t}","id":55,"modified_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.MOUNTED);\n\t\t}\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path, timeoutInMillis);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\n\t}","id":56,"modified_method":"@Override\n\tpublic void mount(final String volumeId, final String device, final String path, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot mount when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Mounting device \" + device + \" to mount point \" + path);\n\t\tVolumeUtils.mount(device, path, timeoutInMillis);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.MOUNTED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.MOUNTED);\n\t\t}\n\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void partition(final String volumeId, final String device, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device, timeoutInMillis);\n\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\n\t}","id":57,"modified_method":"@Override\n\tpublic void partition(final String volumeId, final String device, final long timeoutInMillis)\n\t\t\tthrows LocalStorageOperationException, TimeoutException {\n\t\tvalidateNotWindows();\n\t\tif (!serviceContext.isPrivileged()) {\n\t\t\tthrow new IllegalStateException(\"Cannot partition when not running in privileged mode\");\n\t\t}\n\t\tlogger.info(\"Partitioning device \" + device);\n\t\tVolumeUtils.partition(device, timeoutInMillis);\n\t\tif (volumeId != null) {\n\t\t\tchangeStateOfVolumeWithId(volumeId, VolumeState.PARTITIONED);\n\t\t} else {\n\t\t\tchangeStateOfVolumeWithDevice(device, VolumeState.PARTITIONED);\n\t\t}\n\n\t}","commit_id":"e0e8dff0ed817a9236843d1f422d2cf51bfc8f95","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public static void handleDownload(ToadletContext context, Bucket data, BucketFactory bucketFactory, String mimeType, String requestedMimeType, String forceString, boolean forceDownload, String basePath, FreenetURI key, String extras, String referrer, boolean downloadLink, ToadletContext ctx, NodeClientCore core, boolean dontFreeData) throws ToadletContextClosedException, IOException {\n\t\tToadletContainer container = context.getContainer();\n\t\tif(Logger.shouldLog(Logger.MINOR, FProxyToadlet.class))\n\t\t\tLogger.minor(FProxyToadlet.class, \"handleDownload(data.size=\"+data.size()+\", mimeType=\"+mimeType+\", requestedMimeType=\"+requestedMimeType+\", forceDownload=\"+forceDownload+\", basePath=\"+basePath+\", key=\"+key);\n\t\tString extrasNoMime = extras; // extras will not include MIME type to start with - REDFLAG maybe it should be an array\n\t\tif(requestedMimeType != null) {\n\t\t\tif(mimeType == null || !requestedMimeType.equals(mimeType)) {\n\t\t\t\tif(extras == null) extras = \"\";\n\t\t\t\textras = extras + \"&type=\" + requestedMimeType;\n\t\t\t}\n\t\t\tmimeType = requestedMimeType;\n\t\t}\n\t\tlong size = data.size();\n\t\t\n\t\tlong now = System.currentTimeMillis();\n\t\tboolean force = false;\n\t\tif(forceString != null) {\n\t\t\tif(forceString.equals(getForceValue(key, now)) || \n\t\t\t\t\tforceString.equals(getForceValue(key, now-FORCE_GRAIN_INTERVAL)))\n\t\t\t\tforce = true;\n\t\t}\n\n\t\tBucket toFree = null;\n\t\tBucket tmpRange = null;\n\t\ttry {\n\t\t\tif((!force) && (!forceDownload)) {\n\t\t\t\tFilterOutput fo = ContentFilter.filter(data, bucketFactory, mimeType, key.toURI(basePath), container.enableInlinePrefetch() ? prefetchHook : null);\n\t\t\t\tif(data != fo.data) toFree = fo.data;\n\t\t\t\tdata = fo.data;\n\t\t\t\tmimeType = fo.type;\n\t\t\t\t\n\t\t\t\tif(horribleEvilHack(data) && !(mimeType.startsWith(\"application/rss+xml\"))) {\n\t\t\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousRSSTitle\"), context);\n\t\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\t\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"dangerousRSSSubtitle\"));\n\t\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\tinfoboxContent.addChild(\"#\", L10n.getString(\"FProxyToadlet.dangerousRSS\", new String[] { \"type\" }, new String[] { mimeType }));\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\tHTMLNode option = optionList.addChild(\"li\");\n\t\t\t\t\t\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSAsPlainText\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain&force=\"+getForceValue(key,now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\t// \tFIXME: is this safe? See bug #131\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSForceDisk\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tboolean mimeRSS = mimeType.startsWith(\"application/xml+rss\") || mimeType.startsWith(\"text/xml\"); /* blergh! */\n\t\t\t\t\tif(!(mimeRSS || mimeType.startsWith(\"text/plain\"))) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSForce\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\", \"mime\" },\n\t\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?force=\"+getForceValue(key, now)+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\t\"<\/b>\",\n\t\t\t\t\t\t\t\t\tHTMLEncoder.encode(mimeType) /* these are not encoded because mostly they are tags, so we have to encode it */ });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSAsRSS\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath + key.toString() + \"?type=application/xml+rss&force=\" + getForceValue(key, now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tif(referrer != null) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\t\t\tcontext.writeData(pageBytes);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (forceDownload) {\n\t\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t\t\theaders.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + key.getPreferredFilename() + '\"');\n\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", headers, \"application/x-msdownload\", data.size());\n\t\t\t\tcontext.writeData(data);\n\t\t\t} else {\n\t\t\t\t// Send the data, intact\n\t\t\t\tMultiValueTable<String, String> hdr = context.getHeaders();\n\t\t\t\tString rangeStr = hdr.get(\"range\");\n\t\t\t\t// was a range request\n\t\t\t\tif (rangeStr != null) {\n\t\t\t\t\t\n\t\t\t\t\tlong range[] = parseRange(rangeStr);\n\t\t\t\t\tif (range[1] == -1 || range[1] >= data.size()) {\n\t\t\t\t\t\trange[1] = data.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\ttmpRange = bucketFactory.makeBucket(range[1] - range[0]);\n\t\t\t\t\tInputStream is = data.getInputStream();\n\t\t\t\t\tOutputStream os = tmpRange.getOutputStream();\n\t\t\t\t\tif (range[0] > 0)\n\t\t\t\t\t\tis.skip(range[0]);\n\t\t\t\t\tFileUtil.copy(is, os, range[1] - range[0] + 1);\n\t\t\t\t\tos.close();\n\t\t\t\t\tis.close();\n\t\t\t\t\tMultiValueTable<String, String> retHdr = new MultiValueTable<String, String>();\n\t\t\t\t\tretHdr.put(\"Content-Range\", \"bytes \" + range[0] + \"-\" + range[1] + \"/\" + data.size());\n\t\t\t\t\tcontext.sendReplyHeaders(206, \"Partial content\", retHdr, mimeType, tmpRange.size());\n\t\t\t\t\tcontext.writeData(tmpRange);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), mimeType, data.size());\n\t\t\t\t\tcontext.writeData(data);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (URISyntaxException use1) {\n\t\t\t/* shouldn't happen */\n\t\t\tuse1.printStackTrace();\n\t\t\tLogger.error(FProxyToadlet.class, \"could not create URI\", use1);\n\t\t} catch (UnsafeContentTypeException e) {\n\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousContentTitle\"), context);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", e.getRawTitle());\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode list = infoboxContent.addChild(\"ul\");\n\t\t\twriteSizeAndMIME(list, size, mimeType, true);\n\t\t\t\n\t\t\tHTMLNode option = list.addChild(\"li\");\n\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, mimeType));\n\t\t\t\n\t\t\tinfoboxContent.addChild(\"p\").addChild(e.getHTMLExplanation());\n\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\n\t\t\tif((mimeType.equals(\"application/x-freenet-index\")) && (core.node.pluginManager.isPluginLoaded(\"plugins.ThawIndexBrowser.ThawIndexBrowser\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsThawIndex\", new String[] { \"link\", \"/link\" }, new String[] { \"<b><a href=\\\"\"+basePath + \"plugins/plugins.ThawIndexBrowser.ThawIndexBrowser/?key=\" + key.toString() + \"\\\">\", \"<\/a><\/b>\" });\n\t\t\t}\n\t\t\t\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\t// FIXME: is this safe? See bug #131\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsText\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain\"+extrasNoMime+\"\\\">\", \"<\/a>\" });\n\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForceDisk\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\", \"<\/a>\" });\n\t\t\tif(!(mimeType.equals(\"application/octet-stream\") || mimeType.equals(\"application/x-msdownload\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForce\", new String[] { \"link\", \"/link\", \"mime\" }, new String[] { \"<a href=\\\"\"+basePath + key.toString() + \"?force=\" + getForceValue(key, now)+extras+\"\\\">\", \"<\/a>\", HTMLEncoder.encode(mimeType)});\n\t\t\t}\n\t\t\tif(referrer != null) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t}\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\tif(ctx.isAllowedFullAccess() || !container.publicGatewayMode()) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\n\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\toptionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\n\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\tcontext.writeData(pageBytes);\n\t\t} catch (HTTPRangeException e) {\n\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t} finally {\n\t\t\tif(toFree != null && !dontFreeData) toFree.free();\n\t\t\tif(tmpRange != null) tmpRange.free();\n\t\t}\n\t}","id":58,"modified_method":"public static void handleDownload(ToadletContext context, Bucket data, BucketFactory bucketFactory, String mimeType, String requestedMimeType, String forceString, boolean forceDownload, String basePath, FreenetURI key, String extras, String referrer, boolean downloadLink, ToadletContext ctx, NodeClientCore core, boolean dontFreeData) throws ToadletContextClosedException, IOException {\n\t\tToadletContainer container = context.getContainer();\n\t\tif(Logger.shouldLog(Logger.MINOR, FProxyToadlet.class))\n\t\t\tLogger.minor(FProxyToadlet.class, \"handleDownload(data.size=\"+data.size()+\", mimeType=\"+mimeType+\", requestedMimeType=\"+requestedMimeType+\", forceDownload=\"+forceDownload+\", basePath=\"+basePath+\", key=\"+key);\n\t\tString extrasNoMime = extras; // extras will not include MIME type to start with - REDFLAG maybe it should be an array\n\t\tif(requestedMimeType != null) {\n\t\t\tif(mimeType == null || !requestedMimeType.equals(mimeType)) {\n\t\t\t\tif(extras == null) extras = \"\";\n\t\t\t\textras = extras + \"&type=\" + requestedMimeType;\n\t\t\t}\n\t\t\tmimeType = requestedMimeType;\n\t\t}\n\t\tlong size = data.size();\n\t\t\n\t\tlong now = System.currentTimeMillis();\n\t\tboolean force = false;\n\t\tif(forceString != null) {\n\t\t\tif(forceString.equals(getForceValue(key, now)) || \n\t\t\t\t\tforceString.equals(getForceValue(key, now-FORCE_GRAIN_INTERVAL)))\n\t\t\t\tforce = true;\n\t\t}\n\n\t\tBucket toFree = null;\n\t\tBucket tmpRange = null;\n\t\ttry {\n\t\t\tif((!force) && (!forceDownload)) {\n\t\t\t\tFilterOutput fo = ContentFilter.filter(data, bucketFactory, mimeType, key.toURI(basePath), container.enableInlinePrefetch() ? prefetchHook : null);\n\t\t\t\tif(data != fo.data) toFree = fo.data;\n\t\t\t\tdata = fo.data;\n\t\t\t\tmimeType = fo.type;\n\t\t\t\t\n\t\t\t\tif(horribleEvilHack(data) && !(mimeType.startsWith(\"application/rss+xml\"))) {\n\t\t\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousRSSTitle\"), context);\n\t\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\t\n\t\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"dangerousRSSSubtitle\"));\n\t\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\tinfoboxContent.addChild(\"#\", L10n.getString(\"FProxyToadlet.dangerousRSS\", new String[] { \"type\" }, new String[] { mimeType }));\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\tHTMLNode option = optionList.addChild(\"li\");\n\t\t\t\t\t\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSAsPlainText\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain&force=\"+getForceValue(key,now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\t// \tFIXME: is this safe? See bug #131\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openPossRSSForceDisk\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tboolean mimeRSS = mimeType.startsWith(\"application/xml+rss\") || mimeType.startsWith(\"text/xml\"); /* blergh! */\n\t\t\t\t\tif(!(mimeRSS || mimeType.startsWith(\"text/plain\"))) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSForce\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\", \"mime\" },\n\t\t\t\t\t\t\t\tnew String[] { \n\t\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath+key.toString()+\"?force=\"+getForceValue(key, now)+extras+\"\\\">\",\n\t\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\t\"<\/b>\",\n\t\t\t\t\t\t\t\t\tHTMLEncoder.encode(mimeType) /* these are not encoded because mostly they are tags, so we have to encode it */ });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openRSSAsRSS\", new String[] { \"link\", \"/link\", \"bold\", \"/bold\" },\n\t\t\t\t\t\t\tnew String[] {\n\t\t\t\t\t\t\t\t\"<a href=\\\"\"+basePath + key.toString() + \"?type=application/xml+rss&force=\" + getForceValue(key, now)+extrasNoMime+\"\\\">\",\n\t\t\t\t\t\t\t\t\"<\/a>\",\n\t\t\t\t\t\t\t\t\"<b>\",\n\t\t\t\t\t\t\t\t\"<\/b>\" });\n\t\t\t\t\tif(referrer != null) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\t\t\tcontext.writeData(pageBytes);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (forceDownload) {\n\t\t\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t\t\theaders.put(\"Content-Disposition\", \"attachment; filename=\\\"\" + key.getPreferredFilename() + '\"');\n\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", headers, \"application/x-msdownload\", data.size());\n\t\t\t\tcontext.writeData(data);\n\t\t\t} else {\n\t\t\t\t// Send the data, intact\n\t\t\t\tMultiValueTable<String, String> hdr = context.getHeaders();\n\t\t\t\tString rangeStr = hdr.get(\"range\");\n\t\t\t\t// was a range request\n\t\t\t\tif (rangeStr != null) {\n\t\t\t\t\t\n\t\t\t\t\tlong range[] = parseRange(rangeStr);\n\t\t\t\t\tif (range[1] == -1 || range[1] >= data.size()) {\n\t\t\t\t\t\trange[1] = data.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t\ttmpRange = bucketFactory.makeBucket(range[1] - range[0]);\n\t\t\t\t\tInputStream is = data.getInputStream();\n\t\t\t\t\tOutputStream os = tmpRange.getOutputStream();\n\t\t\t\t\tif (range[0] > 0)\n\t\t\t\t\t\tis.skip(range[0]);\n\t\t\t\t\tFileUtil.copy(is, os, range[1] - range[0] + 1);\n\t\t\t\t\tos.close();\n\t\t\t\t\tis.close();\n\t\t\t\t\tMultiValueTable<String, String> retHdr = new MultiValueTable<String, String>();\n\t\t\t\t\tretHdr.put(\"Content-Range\", \"bytes \" + range[0] + \"-\" + range[1] + \"/\" + data.size());\n\t\t\t\t\tcontext.sendReplyHeaders(206, \"Partial content\", retHdr, mimeType, tmpRange.size());\n\t\t\t\t\tcontext.writeData(tmpRange);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), mimeType, data.size());\n\t\t\t\t\tcontext.writeData(data);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (URISyntaxException use1) {\n\t\t\t/* shouldn't happen */\n\t\t\tuse1.printStackTrace();\n\t\t\tLogger.error(FProxyToadlet.class, \"could not create URI\", use1);\n\t\t} catch (UnsafeContentTypeException e) {\n\t\t\tPageNode page = context.getPageMaker().getPageNode(l10n(\"dangerousContentTitle\"), context);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-alert\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", e.getRawTitle());\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode list = infoboxContent.addChild(\"ul\");\n\t\t\twriteSizeAndMIME(list, size, mimeType, true);\n\t\t\t\n\t\t\tHTMLNode option = list.addChild(\"li\");\n\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, mimeType));\n\t\t\t\n\t\t\tinfoboxContent.addChild(\"p\").addChild(e.getHTMLExplanation());\n\t\t\tinfoboxContent.addChild(\"p\", l10n(\"options\"));\n\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\n\t\t\tif((mimeType.equals(\"application/x-freenet-index\")) && (core.node.pluginManager.isPluginLoaded(\"plugins.ThawIndexBrowser.ThawIndexBrowser\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsThawIndex\", new String[] { \"link\", \"/link\" }, new String[] { \"<b><a href=\\\"\"+basePath + \"plugins/plugins.ThawIndexBrowser.ThawIndexBrowser/?key=\" + key.toString() + \"\\\">\", \"<\/a><\/b>\" });\n\t\t\t}\n\t\t\t\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\t// FIXME: is this safe? See bug #131\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openAsText\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?type=text/plain\"+extrasNoMime+\"\\\">\", \"<\/a>\" });\n\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForceDisk\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"\"+basePath+key.toString()+\"?forcedownload\"+extras+\"\\\">\", \"<\/a>\" });\n\t\t\tif(!(mimeType.equals(\"application/octet-stream\") || mimeType.equals(\"application/x-msdownload\"))) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openForce\", new String[] { \"link\", \"/link\", \"mime\" }, new String[] { \"<a href=\\\"\"+basePath + key.toString() + \"?force=\" + getForceValue(key, now)+extras+\"\\\">\", \"<\/a>\", HTMLEncoder.encode(mimeType)});\n\t\t\t}\n\t\t\tif(referrer != null) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToReferrer\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\t\tnew String[] { \"<a href=\\\"\"+HTMLEncoder.encode(referrer)+\"\\\">\", \"<\/a>\" });\n\t\t\t}\n\t\t\toption = optionList.addChild(\"li\");\n\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.backToFProxy\", new String[] { \"link\", \"/link\" },\n\t\t\t\t\tnew String[] { \"<a href=\\\"/\\\">\", \"<\/a>\" });\n\t\t\tif(ctx.isAllowedFullAccess() || !container.publicGatewayMode()) {\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mimeType });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\n\t\t\tbyte[] pageBytes = pageNode.generate().getBytes(\"UTF-8\");\n\t\t\tcontext.sendReplyHeaders(200, \"OK\", new MultiValueTable<String, String>(), \"text/html; charset=utf-8\", pageBytes.length);\n\t\t\tcontext.writeData(pageBytes);\n\t\t} catch (HTTPRangeException e) {\n\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t} finally {\n\t\t\tif(toFree != null && !dontFreeData) toFree.free();\n\t\t\tif(tmpRange != null) tmpRange.free();\n\t\t}\n\t}","commit_id":"da2dd05f88fe1aef52c7e8e0b1514d1420651645","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString requestedMimeType = httprequest.getParam(\"type\");\n\t\t\t\tlong maxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\t\tString location = getLink(newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\tstrm.close();\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/feed/\") || ks.equals(\"/feed\")) {\n\t\t\t//TODO Better way to find the host. Find if https is used?\n\t\t\tString host = ctx.getHeaders().get(\"host\");\n\t\t\tString atom = core.alerts.getAtom(\"http://\" + host);\n\t\t\tbyte[] buf = atom.getBytes(\"UTF-8\");\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"application/atom+xml\", buf.length);\n\t\t\tctx.writeData(buf, 0, buf.length);\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/queue/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/downloads/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/config/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/config/node\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\t//first check of httprange before get\n\t\t// only valid number format is checked here\n\t\tString rangeStr = ctx.getHeaders().get(\"range\");\n\t\tif (rangeStr != null) {\n\t\t\ttry {\n\t\t\t\tparseRange(rangeStr);\n\t\t\t} catch (HTTPRangeException e) {\n\t\t\t\tLogger.normal(this, \"Invalid Range Header: \"+rangeStr, e);\n\t\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\n\t\tBucket data = null;\n\t\tString mimeType = null;\n\t\tString referer = sanitizeReferer(ctx);\n\t\tFetchException fe = null;\n\t\t\n\n\t\tMultiValueTable<String,String> headers = ctx.getHeaders();\n\t\tString ua = headers.get(\"user-agent\");\n\t\tString accept = headers.get(\"accept\");\n\t\tFProxyFetchResult fr = null;\n\t\tif(logMINOR) Logger.minor(this, \"UA = \"+ua+\" accept = \"+accept);\n\t\tif(isBrowser(ua) && !ctx.disableProgressPage() && (accept == null || accept.indexOf(\"text/html\") > -1) && !httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tFProxyFetchWaiter fetch = null;\n\t\t\ttry {\n\t\t\t\tfetch = fetchTracker.makeFetcher(key, maxSize);\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfe = fr.failed;\n\t\t\t}\n\t\t\tif(fetch != null)\n\t\t\twhile(true) {\n\t\t\tfr = fetch.getResult();\n\t\t\tif(fr.hasData()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\t\t\tdata = fr.data;\n\t\t\t\tmimeType = fr.mimeType;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else if(fr.failed != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Request failed\");\n\t\t\t\tfe = fr.failed;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Still in progress\");\n\t\t\t\t// Still in progress\n\t\t\t\tboolean isJsEnabled=ctx.getContainer().isFProxyJavascriptEnabled() && ua != null && !ua.contains(\"AppleWebKit/\");\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fetchingPageTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tString location = getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\tHTMLNode headNode=page.headNode;\n\t\t\t\tif(isJsEnabled){\n\t\t\t\t\t//If the user has enabled javascript, we add a <noscript> http refresh(if he has disabled it in the browser)\n\t\t\t\t\t//And the script file\n\t\t\t\t\theadNode.addChild(\"noscript\").addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t\tHTMLNode scriptNode=headNode.addChild(\"script\",\"//abc\");\n\t\t\t\t\tscriptNode.addAttribute(\"type\", \"text/javascript\");\n\t\t\t\t\tscriptNode.addAttribute(\"src\", \"/static/js/progresspage.js\");\n\t\t\t\t}else{\n\t\t\t\t\t//If he disabled it, we just put the http refresh meta, without the noscript\n\t\t\t\t\theadNode.addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageBox\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addAttribute(\"id\", \"infoContent\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"filenameLabel\")+ \" \");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/\"+key.toString(false, false), key.getPreferredFilename());\n\t\t\t\tif(fr.mimeType != null) infoboxContent.addChild(\"br\", l10n(\"contentTypeLabel\")+\" \"+fr.mimeType);\n\t\t\t\tif(fr.size > 0) infoboxContent.addChild(\"br\", \"Size: \"+SizeUtil.formatSize(fr.size));\n\t\t\t\tif(core.isAdvancedModeEnabled()) {\n\t\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"blocksDetail\", \n\t\t\t\t\t\t\tnew String[] { \"fetched\", \"required\", \"total\", \"failed\", \"fatallyfailed\" },\n\t\t\t\t\t\t\tnew String[] { Integer.toString(fr.fetchedBlocks), Integer.toString(fr.requiredBlocks), Integer.toString(fr.totalBlocks), Integer.toString(fr.failedBlocks), Integer.toString(fr.fatallyFailedBlocks) }));\n\t\t\t\t}\n\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"timeElapsedLabel\")+\" \"+TimeUtil.formatTime(System.currentTimeMillis() - fr.timeStarted));\n\t\t\t\tlong eta = fr.eta;\n\t\t\t\tif(eta > 0)\n\t\t\t\t\tinfoboxContent.addChild(\"br\", \"ETA: \"+TimeUtil.formatTime(eta));\n\t\t\t\tif(fr.goneToNetwork)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressDownloading\"));\n\t\t\t\telse\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressCheckingStore\"));\n\t\t\t\tif(!fr.finalizedBlocks)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressNotFinalized\"));\n\t\t\t\t\n\t\t\t\tHTMLNode table = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tHTMLNode progressCell = table.addChild(\"tr\").addChild(\"td\", \"class\", \"request-progress\");\n\t\t\t\tif(fr.totalBlocks <= 0)\n\t\t\t\t\tprogressCell.addChild(\"#\", L10n.getString(\"QueueToadlet.unknown\"));\n\t\t\t\telse {\n\t\t\t\t\tint total = fr.requiredBlocks;\n\t\t\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\t\t\tHTMLNode progressBar = progressCell.addChild(\"div\", \"class\", \"progressbar\");\n\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\t\t\n\t\t\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageOptions\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\t\tHTMLNode ul = infoboxContent.addChild(\"ul\");\n\t\t\t\tul.addChild(\"li\").addChild(\"p\", l10n(\"progressOptionZero\"));\n\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\n\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\toptionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\n\t\t\t\t}\n\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\tMultiValueTable<String, String> retHeaders = new MultiValueTable<String, String>();\n\t\t\t\t//retHeaders.put(\"Refresh\", \"2; url=\"+location);\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", retHeaders, pageNode.generate());\n\t\t\t\tfr.close();\n\t\t\t\tfetch.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tif(data == null && fe == null) {\n\t\t\tFetchResult result = fetch(key, maxSize, new RequestClient() {\n\t\t\t\tpublic boolean persistent() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpublic void removeFrom(ObjectContainer container) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t} }); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tmimeType = result.getMimeType();\n\t\t\t} else if(fe != null) throw fe;\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, maxSize != MAX_LENGTH ? \"&max-size=\"+maxSize : \"\", referer, true, ctx, core, fr != null);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg,\n\t\t\t\t\tgetLink(e.newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionTable = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\tHTMLNode optionForm = option.addChild(\"td\").addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] {'/' + key.toString(), \"get\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"max-size\", String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2) });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"fetch\", l10n(\"fetchLargeFileAnywayAndDisplayButton\") });\n\t\t\t\t\toption.addChild(\"td\", l10n(\"fetchLargeFileAnywayAndDisplay\"));\n\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\n\t\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\t\t\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\t\tL10n.addL10nSubstitution(option.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\toptionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE || e.mode == FetchException.NOT_ENOUGH_PATH_COMPONENTS) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString() + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t}\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\")});\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\tif(core.node.securityLevels.getPhysicalThreatLevel() != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\t\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\")});\n\t\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(fr == null && data != null) data.free();\n\t\t\tif(fr != null) fr.close();\n\t\t}\n\t}","id":59,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest httprequest, ToadletContext ctx) \n\t\t\tthrows ToadletContextClosedException, IOException, RedirectException {\n\n\t\tString ks = uri.getPath();\n\t\t\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\t\n\t\tif (ks.equals(\"/\")) {\n\t\t\tif (httprequest.isParameterSet(\"key\")) {\n\t\t\t\tString k = httprequest.getParam(\"key\");\n\t\t\t\tFreenetURI newURI;\n\t\t\t\ttry {\n\t\t\t\t\tnewURI = new FreenetURI(k);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tLogger.normal(this, \"Invalid key: \"+e+\" for \"+k, e);\n\t\t\t\t\tsendErrorPage(ctx, 404, l10n(\"notFoundTitle\"), L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Redirecting to FreenetURI: \"+newURI);\n\t\t\t\tString requestedMimeType = httprequest.getParam(\"type\");\n\t\t\t\tlong maxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\t\tString location = getLink(newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\twriteTemporaryRedirect(ctx, null, location);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString querystring = uri.getQuery();\n\t\t\t\t\n\t\t\t\tif (querystring == null) {\n\t\t\t\t\tthrow new RedirectException(welcome);\n\t\t\t\t} else {\n\t\t\t\t\t// TODP possibly a proper URLEncode method\n\t\t\t\t\tquerystring = querystring.replace(' ', '+');\n\t\t\t\t\tthrow new RedirectException(\"/welcome/?\" + querystring);\n\t\t\t\t}\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\t// HUH!?!\n\t\t\t}\n\t\t}else if(ks.equals(\"/favicon.ico\")){\n\t\t\tbyte[] buf = new byte[1024];\n\t\t\tint len;\n\t\t\tInputStream strm = getClass().getResourceAsStream(\"staticfiles/favicon.ico\");\n\t\t\t\n\t\t\tif (strm == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, l10n(\"pathNotFoundTitle\"), l10n(\"pathNotFound\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/x-icon\", strm.available());\n\t\t\t\n\t\t\twhile ( (len = strm.read(buf)) > 0) {\n\t\t\t\tctx.writeData(buf, 0, len);\n\t\t\t}\n\t\t\tstrm.close();\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/feed/\") || ks.equals(\"/feed\")) {\n\t\t\t//TODO Better way to find the host. Find if https is used?\n\t\t\tString host = ctx.getHeaders().get(\"host\");\n\t\t\tString atom = core.alerts.getAtom(\"http://\" + host);\n\t\t\tbyte[] buf = atom.getBytes(\"UTF-8\");\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"application/atom+xml\", buf.length);\n\t\t\tctx.writeData(buf, 0, buf.length);\n\t\t\treturn;\n\t\t}else if(ks.equals(\"/robots.txt\") && ctx.doRobots()){\n\t\t\tthis.writeTextReply(ctx, 200, \"Ok\", \"User-agent: *\\nDisallow: /\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/darknet/\") || ks.equals(\"/darknet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/friends/\");\n\t\t\treturn;\n\t\t}else if(ks.startsWith(\"/opennet/\") || ks.equals(\"/opennet\")) { //TODO (pre-build 1045 url format) remove when obsolete\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/strangers/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/queue/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/downloads/\");\n\t\t\treturn;\n\t\t} else if(ks.startsWith(\"/config/\")) {\n\t\t\twritePermanentRedirect(ctx, \"obsoleted\", \"/config/node\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(ks.startsWith(\"/\"))\n\t\t\tks = ks.substring(1);\n\t\t\n\t\tlong maxSize;\n\t\t\n\t\tboolean restricted = (container.publicGatewayMode() && !ctx.isAllowedFullAccess());\n\t\t\n\t\tif(restricted)\n\t\t\tmaxSize = MAX_LENGTH;\n\t\telse \n\t\t\tmaxSize = httprequest.getLongParam(\"max-size\", MAX_LENGTH);\n\t\t\n\t\t//first check of httprange before get\n\t\t// only valid number format is checked here\n\t\tString rangeStr = ctx.getHeaders().get(\"range\");\n\t\tif (rangeStr != null) {\n\t\t\ttry {\n\t\t\t\tparseRange(rangeStr);\n\t\t\t} catch (HTTPRangeException e) {\n\t\t\t\tLogger.normal(this, \"Invalid Range Header: \"+rangeStr, e);\n\t\t\t\tctx.sendReplyHeaders(416, \"Requested Range Not Satisfiable\", null, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tFreenetURI key;\n\t\ttry {\n\t\t\tkey = new FreenetURI(ks);\n\t\t} catch (MalformedURLException e) {\n\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"invalidKeyTitle\"), ctx);\n\t\t\tHTMLNode pageNode = page.outer;\n\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\tHTMLNode errorInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\terrorInfobox.addChild(\"div\", \"class\", \"infobox-header\", L10n.getString(\"FProxyToadlet.invalidKeyWithReason\", new String[] { \"reason\" }, new String[] { e.toString() }));\n\t\t\tHTMLNode errorContent = errorInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\terrorContent.addChild(\"#\", l10n(\"expectedKeyButGot\"));\n\t\t\terrorContent.addChild(\"code\", ks);\n\t\t\terrorContent.addChild(\"br\");\n\t\t\terrorContent.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBack\")));\n\t\t\terrorContent.addChild(\"br\");\n\t\t\taddHomepageLink(errorContent);\n\n\t\t\tthis.writeHTMLReply(ctx, 400, l10n(\"invalidKeyTitle\"), pageNode.generate());\n\t\t\treturn;\n\t\t}\n\t\tString requestedMimeType = httprequest.getParam(\"type\", null);\n\t\tString override = (requestedMimeType == null) ? \"\" : \"?type=\"+URLEncoder.encode(requestedMimeType,true);\n\t\t// No point passing ?force= across a redirect, since the key will change.\n\t\t// However, there is every point in passing ?forcedownload.\n\t\tif(httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tif(override.length() == 0) override = \"?forcedownload\";\n\t\t\telse override = override+\"&forcedownload\";\n\t\t}\n\n\t\tBucket data = null;\n\t\tString mimeType = null;\n\t\tString referer = sanitizeReferer(ctx);\n\t\tFetchException fe = null;\n\t\t\n\n\t\tMultiValueTable<String,String> headers = ctx.getHeaders();\n\t\tString ua = headers.get(\"user-agent\");\n\t\tString accept = headers.get(\"accept\");\n\t\tFProxyFetchResult fr = null;\n\t\tif(logMINOR) Logger.minor(this, \"UA = \"+ua+\" accept = \"+accept);\n\t\tif(isBrowser(ua) && !ctx.disableProgressPage() && (accept == null || accept.indexOf(\"text/html\") > -1) && !httprequest.isParameterSet(\"forcedownload\")) {\n\t\t\tFProxyFetchWaiter fetch = null;\n\t\t\ttry {\n\t\t\t\tfetch = fetchTracker.makeFetcher(key, maxSize);\n\t\t\t} catch (FetchException e) {\n\t\t\t\tfe = fr.failed;\n\t\t\t}\n\t\t\tif(fetch != null)\n\t\t\twhile(true) {\n\t\t\tfr = fetch.getResult();\n\t\t\tif(fr.hasData()) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Found data\");\n\t\t\t\tdata = fr.data;\n\t\t\t\tmimeType = fr.mimeType;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else if(fr.failed != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Request failed\");\n\t\t\t\tfe = fr.failed;\n\t\t\t\tfetch.close(); // Not waiting any more, but still locked the results until sent\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Still in progress\");\n\t\t\t\t// Still in progress\n\t\t\t\tboolean isJsEnabled=ctx.getContainer().isFProxyJavascriptEnabled() && ua != null && !ua.contains(\"AppleWebKit/\");\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fetchingPageTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tString location = getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"));\n\t\t\t\tHTMLNode headNode=page.headNode;\n\t\t\t\tif(isJsEnabled){\n\t\t\t\t\t//If the user has enabled javascript, we add a <noscript> http refresh(if he has disabled it in the browser)\n\t\t\t\t\t//And the script file\n\t\t\t\t\theadNode.addChild(\"noscript\").addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t\tHTMLNode scriptNode=headNode.addChild(\"script\",\"//abc\");\n\t\t\t\t\tscriptNode.addAttribute(\"type\", \"text/javascript\");\n\t\t\t\t\tscriptNode.addAttribute(\"src\", \"/static/js/progresspage.js\");\n\t\t\t\t}else{\n\t\t\t\t\t//If he disabled it, we just put the http refresh meta, without the noscript\n\t\t\t\t\theadNode.addChild(\"meta\", \"http-equiv\", \"Refresh\").addAttribute(\"content\", \"2;URL=\" + location);\n\t\t\t\t}\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageBox\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addAttribute(\"id\", \"infoContent\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"filenameLabel\")+ \" \");\n\t\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/\"+key.toString(false, false), key.getPreferredFilename());\n\t\t\t\tif(fr.mimeType != null) infoboxContent.addChild(\"br\", l10n(\"contentTypeLabel\")+\" \"+fr.mimeType);\n\t\t\t\tif(fr.size > 0) infoboxContent.addChild(\"br\", \"Size: \"+SizeUtil.formatSize(fr.size));\n\t\t\t\tif(core.isAdvancedModeEnabled()) {\n\t\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"blocksDetail\", \n\t\t\t\t\t\t\tnew String[] { \"fetched\", \"required\", \"total\", \"failed\", \"fatallyfailed\" },\n\t\t\t\t\t\t\tnew String[] { Integer.toString(fr.fetchedBlocks), Integer.toString(fr.requiredBlocks), Integer.toString(fr.totalBlocks), Integer.toString(fr.failedBlocks), Integer.toString(fr.fatallyFailedBlocks) }));\n\t\t\t\t}\n\t\t\t\tinfoboxContent.addChild(\"br\", l10n(\"timeElapsedLabel\")+\" \"+TimeUtil.formatTime(System.currentTimeMillis() - fr.timeStarted));\n\t\t\t\tlong eta = fr.eta;\n\t\t\t\tif(eta > 0)\n\t\t\t\t\tinfoboxContent.addChild(\"br\", \"ETA: \"+TimeUtil.formatTime(eta));\n\t\t\t\tif(fr.goneToNetwork)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressDownloading\"));\n\t\t\t\telse\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressCheckingStore\"));\n\t\t\t\tif(!fr.finalizedBlocks)\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"progressNotFinalized\"));\n\t\t\t\t\n\t\t\t\tHTMLNode table = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tHTMLNode progressCell = table.addChild(\"tr\").addChild(\"td\", \"class\", \"request-progress\");\n\t\t\t\tif(fr.totalBlocks <= 0)\n\t\t\t\t\tprogressCell.addChild(\"#\", L10n.getString(\"QueueToadlet.unknown\"));\n\t\t\t\telse {\n\t\t\t\t\tint total = fr.requiredBlocks;\n\t\t\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\t\t\tint failedPercent = (int) (fr.failedBlocks / (double) total * 100);\n\t\t\t\t\tint fatallyFailedPercent = (int) (fr.fatallyFailedBlocks / (double) total * 100);\n\t\t\t\t\tHTMLNode progressBar = progressCell.addChild(\"div\", \"class\", \"progressbar\");\n\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-done\", \"width: \" + fetchedPercent + \"%;\" });\n\n\t\t\t\t\tif (fr.failedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed\", \"width: \" + failedPercent + \"%;\" });\n\t\t\t\t\tif (fr.fatallyFailedBlocks > 0)\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"style\" }, new String[] { \"progressbar-failed2\", \"width: \" + fatallyFailedPercent + \"%;\" });\n\t\t\t\t\t\n\t\t\t\t\tNumberFormat nf = NumberFormat.getInstance();\n\t\t\t\t\tnf.setMaximumFractionDigits(1);\n\t\t\t\t\tString prefix = '('+Integer.toString(fr.fetchedBlocks) + \"/ \" + Integer.toString(total)+\"): \";\n\t\t\t\t\tif (fr.finalizedBlocks) {\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarAccurate\") }, nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0) + '%');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString text = nf.format((int) ((fr.fetchedBlocks / (double) total) * 1000) / 10.0)+ '%';\n\t\t\t\t\t\ttext = \"\" + fr.fetchedBlocks + \" (\"+text+\"??)\";\n\t\t\t\t\t\tprogressBar.addChild(\"div\", new String[] { \"class\", \"title\" }, new String[] { \"progress_fraction_not_finalized\", prefix + L10n.getString(\"QueueToadlet.progressbarNotAccurate\") }, text);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"fetchingPageOptions\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\t\tHTMLNode ul = infoboxContent.addChild(\"ul\");\n\t\t\t\tul.addChild(\"li\").addChild(\"p\", l10n(\"progressOptionZero\"));\n\t\t\t\t\n\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\t\n\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\n\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(ul.addChild(\"li\").addChild(\"p\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\n\t\t\t\t}\n\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tul.addChild(\"li\").addChild(\"p\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\tMultiValueTable<String, String> retHeaders = new MultiValueTable<String, String>();\n\t\t\t\t//retHeaders.put(\"Refresh\", \"2; url=\"+location);\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", retHeaders, pageNode.generate());\n\t\t\t\tfr.close();\n\t\t\t\tfetch.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"FProxy fetching \"+key+\" (\"+maxSize+ ')');\n\t\t\tif(data == null && fe == null) {\n\t\t\tFetchResult result = fetch(key, maxSize, new RequestClient() {\n\t\t\t\tpublic boolean persistent() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpublic void removeFrom(ObjectContainer container) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t} }); \n\t\t\t\n\t\t\t// Now, is it safe?\n\t\t\t\n\t\t\tdata = result.asBucket();\n\t\t\tmimeType = result.getMimeType();\n\t\t\t} else if(fe != null) throw fe;\n\t\t\t\n\t\t\t\n\t\t\thandleDownload(ctx, data, ctx.getBucketFactory(), mimeType, requestedMimeType, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"), \"/\", key, maxSize != MAX_LENGTH ? \"&max-size=\"+maxSize : \"\", referer, true, ctx, core, fr != null);\n\t\t\t\n\t\t} catch (FetchException e) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\tLogger.minor(this, \"Failed to fetch \"+uri+\" : \"+e);\n\t\t\tif(e.newURI != null) {\n\t\t\t\tToadlet.writePermanentRedirect(ctx, msg,\n\t\t\t\t\tgetLink(e.newURI, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\")));\n\t\t\t} else if(e.mode == FetchException.TOO_BIG) {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(l10n(\"fileInformationTitle\"), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\t\t\t\t\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"largeFile\"));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\t\n\t\t\t\tinfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-information\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"#\", l10n(\"largeFileExplanationAndOptions\"));\n\t\t\t\tHTMLNode optionTable = infoboxContent.addChild(\"table\", \"border\", \"0\");\n\t\t\t\tif(!restricted) {\n\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\tHTMLNode optionForm = option.addChild(\"td\").addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] {'/' + key.toString(), \"get\" });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"max-size\", String.valueOf(e.expectedSize == -1 ? Long.MAX_VALUE : e.expectedSize*2) });\n\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"fetch\", l10n(\"fetchLargeFileAnywayAndDisplayButton\") });\n\t\t\t\t\toption.addChild(\"td\", l10n(\"fetchLargeFileAnywayAndDisplay\"));\n\t\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\") });\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\n\t\t\t\t\t\toption = optionTable.addChild(\"tr\");\n\t\t\t\t\t\t\n\t\t\t\t\t\toptionForm = ctx.addFormChild(option.addChild(\"td\"), \"/downloads/\", \"tooBigQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\") });\n\t\t\t\t\t\tL10n.addL10nSubstitution(option.addChild(\"td\"), \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\toptionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionTable.addChild(\"tr\").addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.generate());\n\t\t\t} else {\n\t\t\t\tPageNode page = ctx.getPageMaker().getPageNode(FetchException.getShortMessage(e.mode), ctx);\n\t\t\t\tHTMLNode pageNode = page.outer;\n\t\t\t\tHTMLNode contentNode = page.content;\n\n\t\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-error\");\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"errorWithReason\", \"error\", FetchException.getShortMessage(e.mode)));\n\t\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode fileInformationList = infoboxContent.addChild(\"ul\");\n\t\t\t\tHTMLNode option = fileInformationList.addChild(\"li\");\n\t\t\t\toption.addChild(\"#\", (l10n(\"filenameLabel\") + ' '));\n\t\t\t\toption.addChild(\"a\", \"href\", '/' + key.toString(), getFilename(key, e.getExpectedMimeType()));\n\n\t\t\t\tString mime = writeSizeAndMIME(fileInformationList, e);\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"explanationTitle\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"unableToRetrieve\"));\n\t\t\t\tif(e.isFatal())\n\t\t\t\t\tinfoboxContent.addChild(\"p\", l10n(\"errorIsFatal\"));\n\t\t\t\tinfoboxContent.addChild(\"p\", msg);\n\t\t\t\tif(e.errorCodes != null) {\n\t\t\t\t\tinfoboxContent.addChild(\"p\").addChild(\"pre\").addChild(\"#\", e.errorCodes.toVerboseString());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", l10n(\"options\"));\n\t\t\t\tinfoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\t\n\t\t\t\tHTMLNode optionList = infoboxContent.addChild(\"ul\");\n\t\t\t\t\n\t\t\t\tif((e.mode == FetchException.NOT_IN_ARCHIVE || e.mode == FetchException.NOT_ENOUGH_PATH_COMPONENTS) && (core.node.pluginManager.isPluginLoaded(\"plugins.KeyExplorer.KeyExplorer\"))) {\n\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\tL10n.addL10nSubstitution(option, \"FProxyToadlet.openWithKeyExplorer\", new String[] { \"link\", \"/link\" }, new String[] { \"<a href=\\\"/plugins/plugins.KeyExplorer.KeyExplorer/?key=\" + key.toString() + \"\\\">\", \"<\/a>\" });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!e.isFatal() && (ctx.isAllowedFullAccess() || !container.publicGatewayMode())) {\n\t\t\t\t\tPHYSICAL_THREAT_LEVEL threatLevel = core.node.securityLevels.getPhysicalThreatLevel();\n\t\t\t\t\t\n\t\t\t\t\tif(!(threatLevel == PHYSICAL_THREAT_LEVEL.HIGH || threatLevel == PHYSICAL_THREAT_LEVEL.MAXIMUM)) {\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"disk\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToDiskButton\")});\n\t\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToDisk\", new String[] { \"dir\", \"page\", \"/link\" }, new String[] { HTMLEncoder.encode(core.getDownloadDir().getAbsolutePath()), \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(threatLevel != PHYSICAL_THREAT_LEVEL.LOW) {\n\t\t\t\t\t\t\n\t\t\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\t\t\tHTMLNode optionForm = ctx.addFormChild(option, \"/downloads/\", \"dnfQueueForm\");\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"key\", key.toString() });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"return-type\", \"direct\" });\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"persistence\", \"forever\" });\n\t\t\t\t\t\tif (mime != null) {\n\t\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"type\", mime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"download\", l10n(\"downloadInBackgroundToTempSpaceButton\")});\n\t\t\t\t\t\toptionForm.addChild(\"#\", \" - \");\n\t\t\t\t\t\tL10n.addL10nSubstitution(optionForm, \"FProxyToadlet.downloadInBackgroundToTempSpace\", new String[] { \"page\", \"/link\" }, new String[] { \"<a href=\\\"/downloads\\\">\", \"<\/a>\" });\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\toptionList.addChild(\"li\").\n\t\t\t\t\t\taddChild(\"a\", \"href\", getLink(key, requestedMimeType, maxSize, httprequest.getParam(\"force\", null), httprequest.isParameterSet(\"forcedownload\"))).addChild(\"#\", l10n(\"retryNow\"));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toptionList.addChild(\"li\").addChild(\"a\", new String[] { \"href\", \"title\" }, new String[] { \"/\", L10n.getString(\"Toadlet.homepage\") }, l10n(\"abortToHomepage\"));\n\t\t\t\t\n\t\t\t\toption = optionList.addChild(\"li\");\n\t\t\t\toption.addChild(ctx.getPageMaker().createBackLink(ctx, l10n(\"goBackToPrev\")));\n\t\t\t\t\n\t\t\t\tthis.writeHTMLReply(ctx, (e.mode == 10) ? 404 : 500 /* close enough - FIXME probably should depend on status code */,\n\t\t\t\t\t\t\"Internal Error\", pageNode.generate());\n\t\t\t}\n\t\t} catch (SocketException e) {\n\t\t\t// Probably irrelevant\n\t\t\tif(e.getMessage().equals(\"Broken pipe\")) {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Caught \"+e+\" while handling GET\", e);\n\t\t\t} else {\n\t\t\t\tLogger.normal(this, \"Caught \"+e);\n\t\t\t}\n\t\t\tthrow e;\n\t\t} catch (Throwable t) {\n\t\t\twriteInternalError(t, ctx);\n\t\t} finally {\n\t\t\tif(fr == null && data != null) data.free();\n\t\t\tif(fr != null) fr.close();\n\t\t}\n\t}","commit_id":"da2dd05f88fe1aef52c7e8e0b1514d1420651645","url":"https://github.com/freenet/fred"},{"original_method":"public void build(final RuleBuildContext context,\r\n                      final RuleDescr ruleDescr) {\r\n        // pushing consequence LHS into the stack for variable resolution\r\n        context.getBuildStack().push( context.getRule().getLhs() );\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n        factory.setPreviousDeclarationMap( context.getDeclarationResolver().getDeclarations() );\r\n        factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) ruleDescr.getConsequence() );\r\n\r\n        context.getRule().setConsequence( new MVELConsequence( expr,\r\n                                                               factory ) );\r\n    }","id":60,"modified_method":"public void build(final RuleBuildContext context,\r\n                      final RuleDescr ruleDescr) {\r\n        // pushing consequence LHS into the stack for variable resolution\r\n        context.getBuildStack().push( context.getRule().getLhs() );\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(context.getDeclarationResolver().getDeclarations(), null,  context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) ruleDescr.getConsequence() );\r\n\r\n        context.getRule().setConsequence( new MVELConsequence( expr,\r\n                                                               factory ) );\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Builds and returns an Eval Conditional Element\r\n     * \r\n     * @param context The current build context\r\n     * @param utils The current build utils instance\r\n     * @param patternBuilder not used by EvalBuilder\r\n     * @param descr The Eval Descriptor to build the eval conditional element from\r\n     * \r\n     * @return the Eval Conditional Element\r\n     */\r\n    public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        // it must be an EvalDescr\r\n        final EvalDescr evalDescr = (EvalDescr) descr;\r\n\r\n        final Declaration[] declarations = new Declaration[0];\r\n        //        final List[] usedIdentifiers = utils.getUsedIdentifiers( context,\r\n        //                                                                 evalDescr,\r\n        //                                                                 evalDescr.getText() );\r\n        //\r\n        //        final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n        //        for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n        //            declarations[i] = (Declaration) context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n        //        }\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n        factory.setPreviousDeclarationMap( context.getDeclarationResolver().getDeclarations() );\r\n        factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) evalDescr.getContent() );\r\n        final EvalCondition eval = new EvalCondition( declarations );\r\n        eval.setEvalExpression( new MVELEvalExpression( expr,\r\n                                                        factory ) );\r\n\r\n        return eval;\r\n    }","id":61,"modified_method":"/**\r\n     * Builds and returns an Eval Conditional Element\r\n     * \r\n     * @param context The current build context\r\n     * @param utils The current build utils instance\r\n     * @param patternBuilder not used by EvalBuilder\r\n     * @param descr The Eval Descriptor to build the eval conditional element from\r\n     * \r\n     * @return the Eval Conditional Element\r\n     */\r\n    public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        // it must be an EvalDescr\r\n        final EvalDescr evalDescr = (EvalDescr) descr;\r\n\r\n        final Declaration[] declarations = new Declaration[0];\r\n        //        final List[] usedIdentifiers = utils.getUsedIdentifiers( context,\r\n        //                                                                 evalDescr,\r\n        //                                                                 evalDescr.getText() );\r\n        //\r\n        //        final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n        //        for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n        //            declarations[i] = (Declaration) context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n        //        }\r\n\r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(context.getDeclarationResolver().getDeclarations(), null,  context.getPkg().getGlobals() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) evalDescr.getContent() );\r\n        final EvalCondition eval = new EvalCondition( declarations );\r\n        eval.setEvalExpression( new MVELEvalExpression( expr,\r\n                                                        factory ) );\r\n\r\n        return eval;\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        final FromDescr fromDescr = (FromDescr) descr;\r\n\r\n        final PatternBuilder patternBuilder = (PatternBuilder) context.getDialect().getBuilder( PatternDescr.class );\r\n        \r\n        final Pattern pattern = patternBuilder.build( context,\r\n                                                      fromDescr.getReturnedPattern() );\r\n\r\n        if ( pattern == null ) {\r\n            return null;\r\n        }\r\n\r\n        final AccessorDescr accessor = (AccessorDescr) fromDescr.getDataSource();\r\n        DataProvider dataProvider = null;\r\n        try {\r\n            //            JFDIParser parser = createParser( utils,\r\n            //                                              accessor.toString() );\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory();\r\n            factory.setPreviousDeclarationMap( context.getDeclarationResolver().getDeclarations() );\r\n            factory.setGlobalsMap( context.getPkg().getGlobals() );\r\n\r\n            //parser.setValueHandlerFactory( factory );\r\n            final Serializable compiled = MVEL.compileExpression( accessor.toString() );\r\n\r\n            dataProvider = new MVELDataProvider( compiled,\r\n                                                 factory );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    fromDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'from' node '\" + accessor.toString() + \"'\" ) );\r\n            return null;\r\n        }\r\n\r\n        return new From( pattern,\r\n                         dataProvider );\r\n    }","id":62,"modified_method":"public ConditionalElement build(final RuleBuildContext context,\r\n                                    final BaseDescr descr) {\r\n        final FromDescr fromDescr = (FromDescr) descr;\r\n\r\n        final PatternBuilder patternBuilder = (PatternBuilder) context.getDialect().getBuilder( PatternDescr.class );\r\n        \r\n        final Pattern pattern = patternBuilder.build( context,\r\n                                                      fromDescr.getReturnedPattern() );\r\n\r\n        if ( pattern == null ) {\r\n            return null;\r\n        }\r\n\r\n        final AccessorDescr accessor = (AccessorDescr) fromDescr.getDataSource();\r\n        DataProvider dataProvider = null;\r\n        try {\r\n            //            JFDIParser parser = createParser( utils,\r\n            //                                              accessor.toString() );\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory(context.getDeclarationResolver().getDeclarations(), null,  context.getPkg().getGlobals() );\r\n\r\n            //parser.setValueHandlerFactory( factory );\r\n            final Serializable compiled = MVEL.compileExpression( accessor.toString() );\r\n\r\n            dataProvider = new MVELDataProvider( compiled,\r\n                                                 factory );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    fromDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'from' node '\" + accessor.toString() + \"'\" ) );\r\n            return null;\r\n        }\r\n\r\n        return new From( pattern,\r\n                         dataProvider );\r\n    }","commit_id":"df0d5ee01c32380913fea49ea14434c3ad258320","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n\t * Construct a MethodDescriptor from JavaClass and method.\r\n\t * \r\n\t * @param jclass a JavaClass\r\n\t * @param method a Method belonging to the JavaClass\r\n\t * @return a MethodDescriptor identifying the method\r\n\t */\r\n\tpublic static MethodDescriptor getMethodDescriptor(JavaClass jclass, Method method) {\r\n\t\treturn new MethodDescriptor(\r\n\t\t\t\tjclass.getClassName().replace('.', '/'), method.getName(), method.getSignature(), method.isStatic());\r\n\t}","id":63,"modified_method":"/**\r\n\t * Construct a MethodDescriptor from JavaClass and method.\r\n\t * \r\n\t * @param jclass a JavaClass\r\n\t * @param method a Method belonging to the JavaClass\r\n\t * @return a MethodDescriptor identifying the method\r\n\t */\r\n\tpublic static MethodDescriptor getMethodDescriptor(JavaClass jclass, Method method) {\r\n\t\treturn DescriptorFactory.instance().getMethodDescriptor(\r\n\t\t\t\tjclass.getClassName().replace('.', '/'), method.getName(), method.getSignature(), method.isStatic());\r\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Get the MethodDescriptor that (hopefully) uniqely names\n\t * this method.\n\t * \n\t * @return the MethodDescriptor uniquely naming this method\n\t */\n\tpublic MethodDescriptor toMethodDescriptor() {\n\t\treturn new MethodDescriptor(\n\t\t\t\tgetSlashedClassName(),\n\t\t\t\tmethod.getName(),\n\t\t\t\tmethod.getSignature(),\n\t\t\t\tmethod.isStatic());\n\t}","id":64,"modified_method":"/**\n\t * Get the MethodDescriptor that (hopefully) uniqely names\n\t * this method.\n\t * \n\t * @return the MethodDescriptor uniquely naming this method\n\t */\n\tpublic MethodDescriptor toMethodDescriptor() {\n\t\treturn DescriptorFactory.instance().getMethodDescriptor(\n\t\t\t\tgetSlashedClassName(),\n\t\t\t\tmethod.getName(),\n\t\t\t\tmethod.getSignature(),\n\t\t\t\tmethod.isStatic());\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Object analyze(IAnalysisCache analysisCache, MethodDescriptor descriptor) throws CheckedAnalysisException {\n\t\tJavaClass jclass = analysisCache.getClassAnalysis(JavaClass.class, descriptor.getClassDescriptor());\n\t\tMethod[] methodList = jclass.getMethods();\n\t\t\n\t\tMethod result = null;\n\t\t\n\t\t// As a side-effect, cache all of the Methods for this JavaClass\n\t\tfor (Method method : methodList) {\n\t\t\tMethodDescriptor methodDescriptor =\n\t\t\t\tnew MethodDescriptor(descriptor.getSlashedClassName(), method.getName(), method.getSignature(), method.isStatic());\n\t\t\t\n\t\t\t// Put in cache eagerly\n\t\t\tanalysisCache.eagerlyPutMethodAnalysis(Method.class, methodDescriptor, method);\n\t\t\t\n\t\t\tif (methodDescriptor.equals(descriptor)) {\n\t\t\t\tresult = method;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}","id":65,"modified_method":"public Object analyze(IAnalysisCache analysisCache, MethodDescriptor descriptor) throws CheckedAnalysisException {\n\t\tJavaClass jclass = analysisCache.getClassAnalysis(JavaClass.class, descriptor.getClassDescriptor());\n\t\tMethod[] methodList = jclass.getMethods();\n\t\t\n\t\tMethod result = null;\n\t\t\n\t\t// As a side-effect, cache all of the Methods for this JavaClass\n\t\tfor (Method method : methodList) {\n\t\t\tMethodDescriptor methodDescriptor =\n\t\t\t\tDescriptorFactory.instance().getMethodDescriptor(descriptor.getSlashedClassName(), method.getName(), method.getSignature(), method.isStatic());\n\t\t\t\n\t\t\t// Put in cache eagerly\n\t\t\tanalysisCache.eagerlyPutMethodAnalysis(Method.class, methodDescriptor, method);\n\t\t\t\n\t\t\tif (methodDescriptor.equals(descriptor)) {\n\t\t\t\tresult = method;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}","commit_id":"56bbde748bcaceb62b64ebb2d3d310528f862453","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public Collection getResources(CollectionAgent agent) {\n        LinkedList resources = new LinkedList();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","id":66,"modified_method":"public Collection<? extends CollectionResource> getResources(CollectionAgent agent) {\n        LinkedList<CollectionResource> resources = new LinkedList<CollectionResource>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection getAttributeTypes(CollectionAgent agent) {\n        HashSet set = new HashSet();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","id":67,"modified_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent) {\n        HashSet<AttributeType> set = new HashSet<AttributeType>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","commit_id":"24d2821d45cbb5ed9070f203343c00edc8e528bb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection getAttributeTypes(CollectionAgent agent) {\n        HashSet set = new HashSet();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","id":68,"modified_method":"public Collection<AttributeType> getAttributeTypes(CollectionAgent agent) {\n        HashSet<AttributeType> set = new HashSet<AttributeType>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            set.addAll(resourceType.getAttributeTypes());\n        }\n        return set;\n\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Collection getResources(CollectionAgent agent) {\n        LinkedList resources = new LinkedList();\n        for (Iterator it = getResourceTypes(agent).iterator(); it.hasNext();) {\n            ResourceType resourceType = (ResourceType) it.next();\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","id":69,"modified_method":"public Collection<? extends CollectionResource> getResources(CollectionAgent agent) {\n        LinkedList<CollectionResource> resources = new LinkedList<CollectionResource>();\n        for (ResourceType resourceType : getResourceTypes(agent)) {\n            resources.addAll(resourceType.getResources());\n        }\n        return resources;\n    }","commit_id":"3de231b188878458b457ffb96b40dbe9017908ad","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected static ASTNode findClosestParentNode(int lineNumber, ASTNode node) {\n    Iterator<StructuralPropertyDescriptor> it = node\n        .structuralPropertiesForType().iterator();\n    // Base.loge(\"Props of \" + node.getClass().getName());\n    while (it.hasNext()) {\n      StructuralPropertyDescriptor prop = it.next();\n\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n//            log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n            int cLineNum = ((CompilationUnit) cnode.getRoot())\n                .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n            if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n              return findClosestParentNode(lineNumber, cnode);\n            }\n          }\n        }\n      }\n\n      else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          int cLineNum = ((CompilationUnit) cnode.getRoot())\n              .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n//          log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n          if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n            return findClosestParentNode(lineNumber, cnode);\n          }\n        }\n      }\n    }\n    return node;\n  }","id":70,"modified_method":"protected static ASTNode findClosestParentNode(int lineNumber, ASTNode node) {\n    // Base.loge(\"Props of \" + node.getClass().getName());\n    for (StructuralPropertyDescriptor prop : (Iterable<StructuralPropertyDescriptor>) node\n        .structuralPropertiesForType()) {\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n//            log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n            int cLineNum = ((CompilationUnit) cnode.getRoot())\n                .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n            if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n              return findClosestParentNode(lineNumber, cnode);\n            }\n          }\n        }\n      } else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          int cLineNum = ((CompilationUnit) cnode.getRoot())\n              .getLineNumber(cnode.getStartPosition() + cnode.getLength());\n//          log(\"Looking at \" + getNodeAsString(cnode)+ \" for line num \" + lineNumber);\n          if (getLineNumber(cnode) <= lineNumber && lineNumber <= cLineNum) {\n            return findClosestParentNode(lineNumber, cnode);\n          }\n        }\n      }\n    }\n    return node;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public ASTNode dfsLookForASTNode(ASTNode root, String name, int startOffset,\n                                   int endOffset) {\n//    log(\"dfsLookForASTNode() lookin for \" + name + \" Offsets: \" + startOffset\n//        + \",\" + endOffset);\n    Stack<ASTNode> stack = new Stack<ASTNode>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n      ASTNode node = stack.pop();\n      //log(\"Popped from stack: \" + getNodeAsString(node));\n      Iterator<StructuralPropertyDescriptor> it =\n          node.structuralPropertiesForType().iterator();\n      while (it.hasNext()) {\n        StructuralPropertyDescriptor prop = it.next();\n\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode temp = (ASTNode) node.getStructuralProperty(prop);\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n              if(temp instanceof SimpleName){\n                if(name.equals(temp.toString())){\n//                  log(\"Found simplename: \" + getNodeAsString(temp));\n                  return temp;\n                }\n//                log(\"Bummer, didn't match\");\n              }\n              else\n                stack.push(temp);\n                //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        }\n        else if (prop.isChildListProperty()) {\n          List<ASTNode> nodelist =\n            (List<ASTNode>) node.getStructuralProperty(prop);\n          for (ASTNode temp : nodelist) {\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n                stack.push(temp);\n//                log(\"Pushed onto stack: \" + getNodeAsString(temp));\n                if(temp instanceof SimpleName){\n                  if(name.equals(temp.toString())){\n//                    log(\"Found simplename: \" + getNodeAsString(temp));\n                    return temp;\n                  }\n//                  log(\"Bummer, didn't match\");\n                }\n                else\n                  stack.push(temp);\n                  //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        }\n      }\n    }\n//    log(\"dfsLookForASTNode() not found \" + name);\n    return null;\n  }","id":71,"modified_method":"public ASTNode dfsLookForASTNode(ASTNode root, String name, int startOffset,\n                                   int endOffset) {\n//    log(\"dfsLookForASTNode() lookin for \" + name + \" Offsets: \" + startOffset\n//        + \",\" + endOffset);\n    Stack<ASTNode> stack = new Stack<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n      ASTNode node = stack.pop();\n      //log(\"Popped from stack: \" + getNodeAsString(node));\n      for (StructuralPropertyDescriptor prop : (Iterable<StructuralPropertyDescriptor>) node.structuralPropertiesForType()) {\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode temp = (ASTNode) node.getStructuralProperty(prop);\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n              if (temp instanceof SimpleName) {\n                if (name.equals(temp.toString())) {\n//                  log(\"Found simplename: \" + getNodeAsString(temp));\n                  return temp;\n                }\n//                log(\"Bummer, didn't match\");\n              } else\n                stack.push(temp);\n              //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        } else if (prop.isChildListProperty()) {\n          List<ASTNode> nodelist =\n              (List<ASTNode>) node.getStructuralProperty(prop);\n          for (ASTNode temp : nodelist) {\n            if (temp.getStartPosition() <= startOffset\n                && (temp.getStartPosition() + temp.getLength()) >= endOffset) {\n              stack.push(temp);\n//                log(\"Pushed onto stack: \" + getNodeAsString(temp));\n              if (temp instanceof SimpleName) {\n                if (name.equals(temp.toString())) {\n//                    log(\"Found simplename: \" + getNodeAsString(temp));\n                  return temp;\n                }\n//                  log(\"Bummer, didn't match\");\n              } else\n                stack.push(temp);\n              //log(\"Pushed onto stack: \" + getNodeAsString(temp));\n            }\n          }\n        }\n      }\n    }\n//    log(\"dfsLookForASTNode() not found \" + name);\n    return null;\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public static void printRecur(ASTNode node) {\n    Iterator<StructuralPropertyDescriptor> it = node\n        .structuralPropertiesForType().iterator();\n    //Base.loge(\"Props of \" + node.getClass().getName());\n    while (it.hasNext()) {\n      StructuralPropertyDescriptor prop = it.next();\n\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n            log(getNodeAsString(cnode));\n            printRecur(cnode);\n          }\n        }\n      }\n\n      else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          log(getNodeAsString(cnode));\n          printRecur(cnode);\n        }\n      }\n    }\n  }","id":72,"modified_method":"public static void printRecur(ASTNode node) {\n    //Base.loge(\"Props of \" + node.getClass().getName());\n    for (StructuralPropertyDescriptor prop : (Iterable<StructuralPropertyDescriptor>) node\n        .structuralPropertiesForType()) {\n      if (prop.isChildProperty() || prop.isSimpleProperty()) {\n        if (node.getStructuralProperty(prop) != null) {\n//          System.out\n//              .println(node.getStructuralProperty(prop) + \" -> \" + (prop));\n          if (node.getStructuralProperty(prop) instanceof ASTNode) {\n            ASTNode cnode = (ASTNode) node.getStructuralProperty(prop);\n            log(getNodeAsString(cnode));\n            printRecur(cnode);\n          }\n        }\n      } else if (prop.isChildListProperty()) {\n        List<ASTNode> nodelist = (List<ASTNode>) node\n            .getStructuralProperty(prop);\n        for (ASTNode cnode : nodelist) {\n          log(getNodeAsString(cnode));\n          printRecur(cnode);\n        }\n      }\n    }\n  }","commit_id":"25173460c121d371db4e906a22a762a94d1e00fb","url":"https://github.com/processing/processing"},{"original_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tfinal HTTPRequest request = new HTTPRequest(uri);\n\t\t\n\t\tString path = uri.getPath();\n\t\tif(path.endsWith(\"myref.fref\")) {\n\t\t\tSimpleFieldSet fs = node.exportPublicFieldSet();\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tfs.writeTo(sw);\n\t\t\tthis.writeReply(ctx, 200, \"text/plain\", \"OK\", sw.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\tfinal boolean fProxyJavascriptEnabled = node.isFProxyJavascriptEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\t\n\t\t\t\tif(request.isParameterSet(\"sortBy\")){\n\t\t\t\t\tfinal String sortBy = request.getParam(\"sortBy\"); \n\t\t\t\t\tif(sortBy.equals(\"name\")){\n\t\t\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t\t\t}else if(sortBy.equals(\"address\")){\n\t\t\t\t\t\treturn firstNode.getPeerAddress().compareToIgnoreCase(secondNode.getPeerAddress());\n\t\t\t\t\t}else if(sortBy.equals(\"location\")){\n\t\t\t\t\t\tdouble diff = firstNode.getLocation() - secondNode.getLocation();\n\t\t\t\t\t\treturn diff > 0 ? -1 : 1; // It shouldn't ever be equal anyway\n\t\t\t\t\t}else if(sortBy.equals(\"version\")){\n\t\t\t\t\t\treturn firstNode.getVersion().compareTo(secondNode.getVersion());\n\t\t\t\t\t}else if(sortBy.equals(\"privnote\")){\n\t\t\t\t\t\treturn firstNode.getPrivateDarknetCommentNote().compareTo(secondNode.getPrivateDarknetCommentNote());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tint numberOfSimpleConnected = numberOfConnected + numberOfRoutingBackedOff;\n\t\tint numberOfNotConnected = numberOfTooNew + numberOfTooOld + numberOfDisconnected + numberOfNeverConnected + numberOfDisabled + numberOfBursting + numberOfListening + numberOfListenOnly;\n\t\tString titleCountString = null;\n\t\tif(advancedEnabled) {\n\t\t\ttitleCountString = \"(\" + numberOfConnected + '/' + numberOfRoutingBackedOff + '/' + numberOfTooNew + '/' + numberOfTooOld + '/' + numberOfNotConnected + ')';\n\t\t} else {\n\t\t\ttitleCountString = (numberOfNotConnected + numberOfSimpleConnected)>0 ? String.valueOf(numberOfSimpleConnected) : \"\";\n\t\t}\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(titleCountString + \" Darknet Peers of \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimateRecent = 0;\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimateRecent = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix4 = new DecimalFormat(\"0.0000\");\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tDecimalFormat fix1 = new DecimalFormat(\"##0.0%\");\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\t// BEGIN OVERVIEW TABLE\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateRecent:\\u00a0\" + networkSizeEstimateRecent + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix1.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix1.format(node.pRejectIncomingInstantly()));\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0]) + \"\\u00a0(\" + SizeUtil.formatSize(total_output_rate) + \"ps)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload) + \"\\u00a0(\" + SizeUtil.formatSize(total_payload_rate) + \"ps) (\"+percent+\"%)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1]) + \"\\u00a0(\" + SizeUtil.formatSize(total_input_rate) + \"ps)\");\n\t\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\t\tactivityList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate) + \"ps\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate) + \"ps\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// END OVERVIEW TABLE\n\n\t\t\t// BEGIN PEER TABLE\n\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\tStringBuffer jsBuf = new StringBuffer();\n\t\t\t\t// FIXME: There's probably some icky Javascript in here (this is the first thing that worked for me); feel free to fix up to Javascript guru standards\n\t\t\t\tjsBuf.append( \"  function peerNoteChange() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\t//jsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).submit();\\n\" );\n\t\t\t\tjsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).doAction.click();\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tjsBuf.append( \"  function peerNoteBlur() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tcontentNode.addChild(\"script\", \"type\", \"text/javascript\").addChild(\"%\", jsBuf.toString());\n\t\t\t}\n\t\t\tHTMLNode peerTableInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode peerTableInfoboxHeader = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \"My peers\");\n\t\t\tif (advancedEnabled) {\n\t\t\t\tif (!path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \" \");\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"a\", \"href\", \"displaymessagetypes.html\", \"(more detailed)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tHTMLNode peerTableInfoboxContent = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tif (peerNodeStatuses.length == 0) {\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \"Freenet can not work as you have not added any peers so far. Please go to the \");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"a\", \"href\", \"/\", \"node homepage\");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \" and read the top infobox to see how it is done.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode peerForm = peerTableInfoboxContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\", \"id\", \"name\" }, new String[] { \".\", \"post\", \"multipart/form-data\", \"peersForm\", \"peersForm\" });\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\t\tHTMLNode peerTable = peerForm.addChild(\"table\", \"class\", \"darknet_connections\");\n\t\t\t\tHTMLNode peerTableHeaderRow = peerTable.addChild(\"tr\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=status\").addChild(\"#\", \"Status\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=name\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's name. Click on the name link to send the node a N2NTM (Node To Node Text Message)\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Name\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=address\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's network address as IP:Port\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Address\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=version\").addChild(\"#\", \"Version\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=location\").addChild(\"#\", \"Location\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Other node busy? Display: Percentage of time the node is overloaded, Current wait time remaining (0=not overloaded)/total/last overload reason\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Backoff\");\n\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Probability of the node rejecting a request due to overload or causing a timeout.\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Overload Probability\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"How long since the node was connected or last seen\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\\u00a0/\\u00a0Idle\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=privnote\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"A private note concerning this peer\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Private Note\");\n\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"%\\u00a0Time Routable\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"Total\\u00a0Traffic\\u00a0(in/out)\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int peerIndex = 0, peerCount = peerNodeStatuses.length; peerIndex < peerCount; peerIndex++) {\n\t\t\t\t\tPeerNodeStatus peerNodeStatus = peerNodeStatuses[peerIndex];\n\t\t\t\t\tHTMLNode peerRow = peerTable.addChild(\"tr\");\n\n\t\t\t\t\t// check box column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-marker\").addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"node_\" + peerNodeStatus.hashCode() });\n\n\t\t\t\t\t// status column\n\t\t\t\t\tString statusString = peerNodeStatus.getStatusName();\n\t\t\t\t\tif (!advancedEnabled && (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF)) {\n\t\t\t\t\t\tstatusString = \"BUSY\";\n\t\t\t\t\t}\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-status\").addChild(\"span\", \"class\", peerNodeStatus.getStatusCSSName(), statusString + (peerNodeStatus.isFetchingARK() ? \"*\" : \"\"));\n\n\t\t\t\t\t// name column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-name\").addChild(\"a\", \"href\", \"/send_n2ntm/?peernode_hashcode=\" + peerNodeStatus.hashCode(), peerNodeStatus.getName());\n\n\t\t\t\t\t// address column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tString pingTime = \"\";\n\t\t\t\t\t\tif (peerNodeStatus.isConnected()) {\n\t\t\t\t\t\t\tpingTime = \" (\" + (int) peerNodeStatus.getAveragePingTime() + \"ms)\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-address\").addChild(\"#\", ((peerNodeStatus.getPeerAddress() != null) ? (peerNodeStatus.getPeerAddress() + ':' + peerNodeStatus.getPeerPort()) : (\"(unknown address)\")) + pingTime);\n\t\t\t\t\t}\n\n\t\t\t\t\t// version column\n\t\t\t\t\tif (peerNodeStatus.getStatusValue() != Node.PEER_NODE_STATUS_NEVER_CONNECTED && (peerNodeStatus.isPublicInvalidVersion() || peerNodeStatus.isPublicReverseInvalidVersion())) {  // Don't draw attention to a version problem if NEVER CONNECTED\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"span\", \"class\", \"peer_version_problem\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"#\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t}\n\n\t\t\t\t\t// location column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-location\", String.valueOf(peerNodeStatus.getLocation()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\t// backoff column\n\t\t\t\t\t\tHTMLNode backoffCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\");\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", fix1.format(peerNodeStatus.getBackedOffPercent()));\n\t\t\t\t\t\tint backoff = (int) (Math.max(peerNodeStatus.getRoutingBackedOffUntil() - now, 0));\n\t\t\t\t\t\t// Don't list the backoff as zero before it's actually zero\n\t\t\t\t\t\tif ((backoff > 0) && (backoff < 1000)) {\n\t\t\t\t\t\t\tbackoff = 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", ' ' + String.valueOf(backoff / 1000) + '/' + String.valueOf(peerNodeStatus.getRoutingBackoffLength() / 1000));\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", (peerNodeStatus.getLastBackoffReason() == null) ? \"\" : ('/' + (peerNodeStatus.getLastBackoffReason())));\n\n\t\t\t\t\t\t// overload probability column\n\t\t\t\t\t\tHTMLNode pRejectCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\"); // FIXME\n\t\t\t\t\t\tpRejectCell.addChild(\"#\", fix1.format(peerNodeStatus.getPReject()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// idle column\n\t\t\t\t\tlong idle = peerNodeStatus.getTimeLastRoutable();\n\t\t\t\t\tif (peerNodeStatus.isRoutable()) {\n\t\t\t\t\t\tidle = peerNodeStatus.getTimeLastConnectionCompleted();\n\t\t\t\t\t} else if (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_NEVER_CONNECTED) {\n\t\t\t\t\t\tidle = peerNodeStatus.getPeerAddedTime();\n\t\t\t\t\t}\n\t\t\t\t\tif(!peerNodeStatus.isConnected() && (now - idle) > (2 * 7 * 24 * 60 * 60 * (long) 1000)) { // 2 weeks\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\").addChild(\"span\", \"class\", \"peer_idle_old\", idleToString(now, idle));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\", idleToString(now, idle));\n\t\t\t\t\t}\n\n\t\t\t\t\t// private darknet node comment note column\n\t\t\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"onBlur\", \"onChange\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", \"peerNoteBlur();\", \"peerNoteChange();\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t}\n\n\t\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\t\t// percent of time connected column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", fix1.format(peerNodeStatus.getPercentTimeRoutableConnection()));\n\t\t\t\t\t\t// total traffic column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", SizeUtil.formatSize(peerNodeStatus.getTotalInputBytes())+\" / \"+SizeUtil.formatSize(peerNodeStatus.getTotalOutputBytes()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\t\tHTMLNode messageCountRow = peerTable.addChild(\"tr\", \"class\", \"message-status\");\n\t\t\t\t\t\tmessageCountRow.addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\t\t\tHTMLNode messageCountCell = messageCountRow.addChild(\"td\", \"colspan\", String.valueOf(advancedEnabled ? 9 : 5));  // = total table row width - 2 from above colspan\n\t\t\t\t\t\tHTMLNode messageCountTable = messageCountCell.addChild(\"table\", \"class\", \"message-count\");\n\t\t\t\t\t\tHTMLNode countHeaderRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Message\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Incoming\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Outgoing\");\n\t\t\t\t\t\tList messageNames = new ArrayList();\n\t\t\t\t\t\tMap messageCounts = new HashMap();\n\t\t\t\t\t\tfor (Iterator incomingMessages = peerNodeStatus.getLocalMessagesReceived().keySet().iterator(); incomingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) incomingMessages.next();\n\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesReceived().get(messageName);\n\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { messageCount, new Long(0) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Iterator outgoingMessages = peerNodeStatus.getLocalMessagesSent().keySet().iterator(); outgoingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) outgoingMessages.next();\n\t\t\t\t\t\t\tif (!messageNames.contains(messageName)) {\n\t\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesSent().get(messageName);\n\t\t\t\t\t\t\tLong[] existingCounts = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tif (existingCounts == null) {\n\t\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { new Long(0), messageCount });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\texistingCounts[1] = messageCount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(messageNames, new Comparator() {\n\t\t\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\t\t\treturn ((String) first).compareToIgnoreCase((String) second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (Iterator messageNamesIterator = messageNames.iterator(); messageNamesIterator.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) messageNamesIterator.next();\n\t\t\t\t\t\t\tLong[] messageCount = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tHTMLNode messageRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", messageName);\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[0]));\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tHTMLNode actionSelect = peerForm.addChild(\"select\", new String[] { \"id\", \"name\" }, new String[] { \"action\", \"action\" });\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- Select action --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"send_n2ntm\", \"Send N2NTM to selected peers\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"update_notes\", \"Update changed private notes\");\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"enable\", \"Enable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"disable\", \"Disable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_burst_only\", \"On selected peers, set BurstOnly (only set this if you have a static IP and are not NATed and neither is the peer)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_burst_only\", \"On selected peers, clear BurstOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_listen_only\", \"On selected peers, set ListenOnly (not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_listen_only\", \"On selected peers, clear ListenOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_allow_local\", \"On selected peers, set allowLocalAddresses (useful if you are connecting to another node on the same LAN)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_allow_local\", \"On selected peers, clear allowLocalAddresses\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_ignore_source_port\", \"On selected peers, set ignoreSourcePort (try this if behind an evil corporate firewall; otherwise not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_ignore_source_port\", \"On selected peers, clear ignoreSourcePort\");\n\t\t\t\t}\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- -- --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"remove\", \"Remove selected peers\");\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"doAction\", \"Go\" });\n\t\t\t}\n\t\t\t// END PEER TABLE\n\n\t\t}\n\t\t\n\t\t// BEGIN PEER ADDITION BOX\n\t\tHTMLNode peerAdditionInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tpeerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Add another peer\");\n\t\tHTMLNode peerAdditionContent = peerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode peerAdditionForm = peerAdditionContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\" }, new String[] { \".\", \"post\", \"multipart/form-data\" });\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\tpeerAdditionForm.addChild(\"#\", \"Paste the reference here:\");\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"textarea\", new String[] { \"id\", \"name\", \"rows\", \"cols\" }, new String[] { \"reftext\", \"ref\", \"8\", \"74\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter the URL of the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"refurl\", \"text\", \"url\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Choose the file containing the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"reffile\", \"file\", \"reffile\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter a node description: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"peerPrivateNote\", \"text\", \"peerPrivateNote\", \"16\", \"250\", \"\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"add\", \"Add\" });\n\t\t\n\t\t// our reference\n\t\tHTMLNode referenceInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-header\").addChild(\"a\", \"href\", \"myref.fref\", \"My reference\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-content\").addChild(\"pre\", \"id\", \"reference\", node.exportPublicFieldSet().toString());\n\t\t\n\t\t// our ports\n\t\tHTMLNode portInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tportInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node's Ports\");\n\t\tHTMLNode portInfoboxContent = portInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode portInfoList = portInfoboxContent.addChild(\"ul\");\n\t\tSimpleFieldSet fproxyConfig = node.config.get(\"fproxy\").exportFieldSet(true);\n\t\tSimpleFieldSet fcpConfig = node.config.get(\"fcp\").exportFieldSet(true);\n\t\tSimpleFieldSet tmciConfig = node.config.get(\"console\").exportFieldSet(true);\n\t\tportInfoList.addChild(\"li\", \"FNP:\\u00a0\" + node.getFNPPort() + \"/udp\\u00a0\\u00a0\\u00a0(between nodes; this is usually the only port that you might want to port forward)\");\n\t\ttry {\n\t\t\tif(fproxyConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0\" + fproxyConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t}\n\t\t\tif(fcpConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0\" + fcpConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t}\n\t\t\tif(tmciConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0\" + tmciConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\t// ignore\n\t\t}\n\t\t\n\t\tStringBuffer pageBuffer = new StringBuffer();\n\t\tpageNode.generate(pageBuffer);\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageBuffer.toString());\n\t}","id":73,"modified_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tfinal HTTPRequest request = new HTTPRequest(uri);\n\t\t\n\t\tString path = uri.getPath();\n\t\tif(path.endsWith(\"myref.fref\")) {\n\t\t\tSimpleFieldSet fs = node.exportPublicFieldSet();\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tfs.writeTo(sw);\n\t\t\tthis.writeReply(ctx, 200, \"text/plain\", \"OK\", sw.toString());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\tfinal boolean fProxyJavascriptEnabled = node.isFProxyJavascriptEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\t\n\t\t\t\tif(request.isParameterSet(\"sortBy\")){\n\t\t\t\t\tfinal String sortBy = request.getParam(\"sortBy\"); \n\t\t\t\t\tif(sortBy.equals(\"name\")){\n\t\t\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t\t\t}else if(sortBy.equals(\"address\")){\n\t\t\t\t\t\treturn firstNode.getPeerAddress().compareToIgnoreCase(secondNode.getPeerAddress());\n\t\t\t\t\t}else if(sortBy.equals(\"location\")){\n\t\t\t\t\t\tdouble diff = firstNode.getLocation() - secondNode.getLocation();\n\t\t\t\t\t\treturn diff > 0 ? -1 : 1; // It shouldn't ever be equal anyway\n\t\t\t\t\t}else if(sortBy.equals(\"version\")){\n\t\t\t\t\t\treturn firstNode.getVersion().compareTo(secondNode.getVersion());\n\t\t\t\t\t}else if(sortBy.equals(\"privnote\")){\n\t\t\t\t\t\treturn firstNode.getPrivateDarknetCommentNote().compareTo(secondNode.getPrivateDarknetCommentNote());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = PeerNodeStatus.getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tint numberOfSimpleConnected = numberOfConnected + numberOfRoutingBackedOff;\n\t\tint numberOfNotConnected = numberOfTooNew + numberOfTooOld + numberOfDisconnected + numberOfNeverConnected + numberOfDisabled + numberOfBursting + numberOfListening + numberOfListenOnly;\n\t\tString titleCountString = null;\n\t\tif(advancedEnabled) {\n\t\t\ttitleCountString = \"(\" + numberOfConnected + '/' + numberOfRoutingBackedOff + '/' + numberOfTooNew + '/' + numberOfTooOld + '/' + numberOfNotConnected + ')';\n\t\t} else {\n\t\t\ttitleCountString = (numberOfNotConnected + numberOfSimpleConnected)>0 ? String.valueOf(numberOfSimpleConnected) : \"\";\n\t\t}\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(titleCountString + \" Darknet Peers of \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimateRecent = 0;\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimateRecent = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix4 = new DecimalFormat(\"0.0000\");\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tDecimalFormat fix1 = new DecimalFormat(\"##0.0%\");\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\t// BEGIN OVERVIEW TABLE\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateRecent:\\u00a0\" + networkSizeEstimateRecent + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix1.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix1.format(node.pRejectIncomingInstantly()));\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0], true) + \"\\u00a0(\" + SizeUtil.formatSize(total_output_rate, true) + \"ps)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload, true) + \"\\u00a0(\" + SizeUtil.formatSize(total_payload_rate, true) + \"ps) (\"+percent+\"%)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1], true) + \"\\u00a0(\" + SizeUtil.formatSize(total_input_rate, true) + \"ps)\");\n\t\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\t\tSubConfig nodeConfig = node.config.get(\"node\");\n\t\t\t\t\tint outputBandwidthLimit = nodeConfig.getInt(\"outputBandwidthLimit\");\n\t\t\t\t\tint inputBandwidthLimit = nodeConfig.getInt(\"inputBandwidthLimit\");\n\t\t\t\t\tif(inputBandwidthLimit == -1) {\n\t\t\t\t\t\tinputBandwidthLimit = outputBandwidthLimit * 4;\n\t\t\t\t\t}\n\t\t\t\t\tactivityList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(outputBandwidthLimit, true)+\"ps)\");\n\t\t\t\t\tactivityList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(inputBandwidthLimit, true)+\"ps)\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// END OVERVIEW TABLE\n\n\t\t\t// BEGIN PEER TABLE\n\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\tStringBuffer jsBuf = new StringBuffer();\n\t\t\t\t// FIXME: There's probably some icky Javascript in here (this is the first thing that worked for me); feel free to fix up to Javascript guru standards\n\t\t\t\tjsBuf.append( \"  function peerNoteChange() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\t//jsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).submit();\\n\" );\n\t\t\t\tjsBuf.append( \"    document.getElementById( \\\"peersForm\\\" ).doAction.click();\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tjsBuf.append( \"  function peerNoteBlur() {\\n\" );\n\t\t\t\tjsBuf.append( \"    var theobj = document.getElementById( \\\"action\\\" );\\n\" );\n\t\t\t\tjsBuf.append( \"    var length = theobj.options.length;\\n\" );\n\t\t\t\tjsBuf.append( \"    for (var i = 0; i < length; i++) {\\n\" );\n\t\t\t\tjsBuf.append( \"      if(theobj.options[i] == \\\"update_notes\\\") {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = true;\\n\" );\n\t\t\t\tjsBuf.append( \"      } else {\\n\" );\n\t\t\t\tjsBuf.append( \"        theobj.options[i].select = false;\\n\" );\n\t\t\t\tjsBuf.append( \"      }\\n\" );\n\t\t\t\tjsBuf.append( \"    }\\n\" );\n\t\t\t\tjsBuf.append( \"    theobj.value=\\\"update_notes\\\";\\n\" );\n\t\t\t\tjsBuf.append( \"  }\\n\" );\n\t\t\t\tcontentNode.addChild(\"script\", \"type\", \"text/javascript\").addChild(\"%\", jsBuf.toString());\n\t\t\t}\n\t\t\tHTMLNode peerTableInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\t\tHTMLNode peerTableInfoboxHeader = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-header\");\n\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \"My peers\");\n\t\t\tif (advancedEnabled) {\n\t\t\t\tif (!path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"#\", \" \");\n\t\t\t\t\tpeerTableInfoboxHeader.addChild(\"a\", \"href\", \"displaymessagetypes.html\", \"(more detailed)\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tHTMLNode peerTableInfoboxContent = peerTableInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\n\t\t\tif (peerNodeStatuses.length == 0) {\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \"Freenet can not work as you have not added any peers so far. Please go to the \");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"a\", \"href\", \"/\", \"node homepage\");\n\t\t\t\tpeerTableInfoboxContent.addChild(\"#\", \" and read the top infobox to see how it is done.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode peerForm = peerTableInfoboxContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\", \"id\", \"name\" }, new String[] { \".\", \"post\", \"multipart/form-data\", \"peersForm\", \"peersForm\" });\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\t\tHTMLNode peerTable = peerForm.addChild(\"table\", \"class\", \"darknet_connections\");\n\t\t\t\tHTMLNode peerTableHeaderRow = peerTable.addChild(\"tr\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=status\").addChild(\"#\", \"Status\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=name\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's name. Click on the name link to send the node a N2NTM (Node To Node Text Message)\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Name\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=address\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"The node's network address as IP:Port\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Address\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=version\").addChild(\"#\", \"Version\");\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=location\").addChild(\"#\", \"Location\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Other node busy? Display: Percentage of time the node is overloaded, Current wait time remaining (0=not overloaded)/total/last overload reason\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Backoff\");\n\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"Probability of the node rejecting a request due to overload or causing a timeout.\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Overload Probability\");\n\t\t\t\t}\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"How long since the node was connected or last seen\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\\u00a0/\\u00a0Idle\");\n\t\t\t\tpeerTableHeaderRow.addChild(\"th\").addChild(\"a\", \"href\", \"?sortBy=privnote\").addChild(\"span\", new String[] { \"title\", \"style\" }, new String[] { \"A private note concerning this peer\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Private Note\");\n\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"%\\u00a0Time Routable\");\n\t\t\t\t\tpeerTableHeaderRow.addChild(\"th\", \"Total\\u00a0Traffic\\u00a0(in/out)\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int peerIndex = 0, peerCount = peerNodeStatuses.length; peerIndex < peerCount; peerIndex++) {\n\t\t\t\t\tPeerNodeStatus peerNodeStatus = peerNodeStatuses[peerIndex];\n\t\t\t\t\tHTMLNode peerRow = peerTable.addChild(\"tr\");\n\n\t\t\t\t\t// check box column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-marker\").addChild(\"input\", new String[] { \"type\", \"name\" }, new String[] { \"checkbox\", \"node_\" + peerNodeStatus.hashCode() });\n\n\t\t\t\t\t// status column\n\t\t\t\t\tString statusString = peerNodeStatus.getStatusName();\n\t\t\t\t\tif (!advancedEnabled && (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF)) {\n\t\t\t\t\t\tstatusString = \"BUSY\";\n\t\t\t\t\t}\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-status\").addChild(\"span\", \"class\", peerNodeStatus.getStatusCSSName(), statusString + (peerNodeStatus.isFetchingARK() ? \"*\" : \"\"));\n\n\t\t\t\t\t// name column\n\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-name\").addChild(\"a\", \"href\", \"/send_n2ntm/?peernode_hashcode=\" + peerNodeStatus.hashCode(), peerNodeStatus.getName());\n\n\t\t\t\t\t// address column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tString pingTime = \"\";\n\t\t\t\t\t\tif (peerNodeStatus.isConnected()) {\n\t\t\t\t\t\t\tpingTime = \" (\" + (int) peerNodeStatus.getAveragePingTime() + \"ms)\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-address\").addChild(\"#\", ((peerNodeStatus.getPeerAddress() != null) ? (peerNodeStatus.getPeerAddress() + ':' + peerNodeStatus.getPeerPort()) : (\"(unknown address)\")) + pingTime);\n\t\t\t\t\t}\n\n\t\t\t\t\t// version column\n\t\t\t\t\tif (peerNodeStatus.getStatusValue() != Node.PEER_NODE_STATUS_NEVER_CONNECTED && (peerNodeStatus.isPublicInvalidVersion() || peerNodeStatus.isPublicReverseInvalidVersion())) {  // Don't draw attention to a version problem if NEVER CONNECTED\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"span\", \"class\", \"peer_version_problem\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-version\").addChild(\"#\", peerNodeStatus.getSimpleVersion());\n\t\t\t\t\t}\n\n\t\t\t\t\t// location column\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-location\", String.valueOf(peerNodeStatus.getLocation()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\t\t// backoff column\n\t\t\t\t\t\tHTMLNode backoffCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\");\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", fix1.format(peerNodeStatus.getBackedOffPercent()));\n\t\t\t\t\t\tint backoff = (int) (Math.max(peerNodeStatus.getRoutingBackedOffUntil() - now, 0));\n\t\t\t\t\t\t// Don't list the backoff as zero before it's actually zero\n\t\t\t\t\t\tif ((backoff > 0) && (backoff < 1000)) {\n\t\t\t\t\t\t\tbackoff = 1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", ' ' + String.valueOf(backoff / 1000) + '/' + String.valueOf(peerNodeStatus.getRoutingBackoffLength() / 1000));\n\t\t\t\t\t\tbackoffCell.addChild(\"#\", (peerNodeStatus.getLastBackoffReason() == null) ? \"\" : ('/' + (peerNodeStatus.getLastBackoffReason())));\n\n\t\t\t\t\t\t// overload probability column\n\t\t\t\t\t\tHTMLNode pRejectCell = peerRow.addChild(\"td\", \"class\", \"peer-backoff\"); // FIXME\n\t\t\t\t\t\tpRejectCell.addChild(\"#\", fix1.format(peerNodeStatus.getPReject()));\n\t\t\t\t\t}\n\n\t\t\t\t\t// idle column\n\t\t\t\t\tlong idle = peerNodeStatus.getTimeLastRoutable();\n\t\t\t\t\tif (peerNodeStatus.isRoutable()) {\n\t\t\t\t\t\tidle = peerNodeStatus.getTimeLastConnectionCompleted();\n\t\t\t\t\t} else if (peerNodeStatus.getStatusValue() == Node.PEER_NODE_STATUS_NEVER_CONNECTED) {\n\t\t\t\t\t\tidle = peerNodeStatus.getPeerAddedTime();\n\t\t\t\t\t}\n\t\t\t\t\tif(!peerNodeStatus.isConnected() && (now - idle) > (2 * 7 * 24 * 60 * 60 * (long) 1000)) { // 2 weeks\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\").addChild(\"span\", \"class\", \"peer_idle_old\", idleToString(now, idle));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\", idleToString(now, idle));\n\t\t\t\t\t}\n\n\t\t\t\t\t// private darknet node comment note column\n\t\t\t\t\tif(fProxyJavascriptEnabled) {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"onBlur\", \"onChange\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", \"peerNoteBlur();\", \"peerNoteChange();\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-private-darknet-comment-note\").addChild(\"input\", new String[] { \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"text\", \"peerPrivateNote_\" + peerNodeStatus.hashCode(), \"16\", \"250\", peerNodeStatus.getPrivateDarknetCommentNote() });\n\t\t\t\t\t}\n\n\t\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\t\t// percent of time connected column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", fix1.format(peerNodeStatus.getPercentTimeRoutableConnection()));\n\t\t\t\t\t\t// total traffic column\n\t\t\t\t\t\tpeerRow.addChild(\"td\", \"class\", \"peer-idle\" /* FIXME */).addChild(\"#\", SizeUtil.formatSize(peerNodeStatus.getTotalInputBytes())+\" / \"+SizeUtil.formatSize(peerNodeStatus.getTotalOutputBytes()));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (path.endsWith(\"displaymessagetypes.html\")) {\n\t\t\t\t\t\tHTMLNode messageCountRow = peerTable.addChild(\"tr\", \"class\", \"message-status\");\n\t\t\t\t\t\tmessageCountRow.addChild(\"td\", \"colspan\", \"2\");\n\t\t\t\t\t\tHTMLNode messageCountCell = messageCountRow.addChild(\"td\", \"colspan\", String.valueOf(advancedEnabled ? 9 : 5));  // = total table row width - 2 from above colspan\n\t\t\t\t\t\tHTMLNode messageCountTable = messageCountCell.addChild(\"table\", \"class\", \"message-count\");\n\t\t\t\t\t\tHTMLNode countHeaderRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Message\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Incoming\");\n\t\t\t\t\t\tcountHeaderRow.addChild(\"th\", \"Outgoing\");\n\t\t\t\t\t\tList messageNames = new ArrayList();\n\t\t\t\t\t\tMap messageCounts = new HashMap();\n\t\t\t\t\t\tfor (Iterator incomingMessages = peerNodeStatus.getLocalMessagesReceived().keySet().iterator(); incomingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) incomingMessages.next();\n\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesReceived().get(messageName);\n\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { messageCount, new Long(0) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Iterator outgoingMessages = peerNodeStatus.getLocalMessagesSent().keySet().iterator(); outgoingMessages.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) outgoingMessages.next();\n\t\t\t\t\t\t\tif (!messageNames.contains(messageName)) {\n\t\t\t\t\t\t\t\tmessageNames.add(messageName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLong messageCount = (Long) peerNodeStatus.getLocalMessagesSent().get(messageName);\n\t\t\t\t\t\t\tLong[] existingCounts = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tif (existingCounts == null) {\n\t\t\t\t\t\t\t\tmessageCounts.put(messageName, new Long[] { new Long(0), messageCount });\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\texistingCounts[1] = messageCount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tCollections.sort(messageNames, new Comparator() {\n\t\t\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\t\t\treturn ((String) first).compareToIgnoreCase((String) second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (Iterator messageNamesIterator = messageNames.iterator(); messageNamesIterator.hasNext(); ) {\n\t\t\t\t\t\t\tString messageName = (String) messageNamesIterator.next();\n\t\t\t\t\t\t\tLong[] messageCount = (Long[]) messageCounts.get(messageName);\n\t\t\t\t\t\t\tHTMLNode messageRow = messageCountTable.addChild(\"tr\");\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", messageName);\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[0]));\n\t\t\t\t\t\t\tmessageRow.addChild(\"td\", \"class\", \"right-align\", String.valueOf(messageCount[1]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tHTMLNode actionSelect = peerForm.addChild(\"select\", new String[] { \"id\", \"name\" }, new String[] { \"action\", \"action\" });\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- Select action --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"send_n2ntm\", \"Send N2NTM to selected peers\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"update_notes\", \"Update changed private notes\");\n\t\t\t\tif(advancedEnabled) {\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"enable\", \"Enable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"disable\", \"Disable selected peers\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_burst_only\", \"On selected peers, set BurstOnly (only set this if you have a static IP and are not NATed and neither is the peer)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_burst_only\", \"On selected peers, clear BurstOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_listen_only\", \"On selected peers, set ListenOnly (not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_listen_only\", \"On selected peers, clear ListenOnly\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_allow_local\", \"On selected peers, set allowLocalAddresses (useful if you are connecting to another node on the same LAN)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_allow_local\", \"On selected peers, clear allowLocalAddresses\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"set_ignore_source_port\", \"On selected peers, set ignoreSourcePort (try this if behind an evil corporate firewall; otherwise not recommended)\");\n\t\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"clear_ignore_source_port\", \"On selected peers, clear ignoreSourcePort\");\n\t\t\t\t}\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"\", \"-- -- --\");\n\t\t\t\tactionSelect.addChild(\"option\", \"value\", \"remove\", \"Remove selected peers\");\n\t\t\t\tpeerForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"doAction\", \"Go\" });\n\t\t\t}\n\t\t\t// END PEER TABLE\n\n\t\t}\n\t\t\n\t\t// BEGIN PEER ADDITION BOX\n\t\tHTMLNode peerAdditionInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tpeerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Add another peer\");\n\t\tHTMLNode peerAdditionContent = peerAdditionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode peerAdditionForm = peerAdditionContent.addChild(\"form\", new String[] { \"action\", \"method\", \"enctype\" }, new String[] { \".\", \"post\", \"multipart/form-data\" });\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\tpeerAdditionForm.addChild(\"#\", \"Paste the reference here:\");\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"textarea\", new String[] { \"id\", \"name\", \"rows\", \"cols\" }, new String[] { \"reftext\", \"ref\", \"8\", \"74\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter the URL of the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"refurl\", \"text\", \"url\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Choose the file containing the reference here: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\" }, new String[] { \"reffile\", \"file\", \"reffile\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"#\", \"Enter a node description: \");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"id\", \"type\", \"name\", \"size\", \"maxlength\", \"value\" }, new String[] { \"peerPrivateNote\", \"text\", \"peerPrivateNote\", \"16\", \"250\", \"\" });\n\t\tpeerAdditionForm.addChild(\"br\");\n\t\tpeerAdditionForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"add\", \"Add\" });\n\t\t\n\t\t// our reference\n\t\tHTMLNode referenceInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-header\").addChild(\"a\", \"href\", \"myref.fref\", \"My reference\");\n\t\treferenceInfobox.addChild(\"div\", \"class\", \"infobox-content\").addChild(\"pre\", \"id\", \"reference\", node.exportPublicFieldSet().toString());\n\t\t\n\t\t// our ports\n\t\tHTMLNode portInfobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-normal\");\n\t\tportInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node's Ports\");\n\t\tHTMLNode portInfoboxContent = portInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\tHTMLNode portInfoList = portInfoboxContent.addChild(\"ul\");\n\t\tSimpleFieldSet fproxyConfig = node.config.get(\"fproxy\").exportFieldSet(true);\n\t\tSimpleFieldSet fcpConfig = node.config.get(\"fcp\").exportFieldSet(true);\n\t\tSimpleFieldSet tmciConfig = node.config.get(\"console\").exportFieldSet(true);\n\t\tportInfoList.addChild(\"li\", \"FNP:\\u00a0\" + node.getFNPPort() + \"/udp\\u00a0\\u00a0\\u00a0(between nodes; this is usually the only port that you might want to port forward)\");\n\t\ttry {\n\t\t\tif(fproxyConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0\" + fproxyConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FProxy:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(this web interface)\");\n\t\t\t}\n\t\t\tif(fcpConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0\" + fcpConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"FCP:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(for Freenet clients such as Frost and Thaw)\");\n\t\t\t}\n\t\t\tif(tmciConfig.getBoolean(\"enabled\", false)) {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0\" + tmciConfig.getInt(\"port\") + \"/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t} else {\n\t\t\t\tportInfoList.addChild(\"li\", \"TMCI:\\u00a0disabled/tcp\\u00a0\\u00a0\\u00a0(simple telnet-based command-line interface)\");\n\t\t\t}\n\t\t} catch (FSParseException e) {\n\t\t\t// ignore\n\t\t}\n\t\t\n\t\tStringBuffer pageBuffer = new StringBuffer();\n\t\tpageNode.generate(pageBuffer);\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageBuffer.toString());\n\t}","commit_id":"b0d8a0763474a0e66850bdecaa333d4ab5fd0503","url":"https://github.com/freenet/fred"},{"original_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Statistics for \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\n\t\t// Generate a Thread-Dump\n\t\tif(node.isUsingWrapper()){\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"Request a Thread Dump to be generated\"));\n\t\t\tHTMLNode threadDumpForm = ctx.getPageMaker().getContentNode(infobox).addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] { \"/\", \"POST\" });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"getThreadDump\", \"Generate a Thread Dump\" });\n\t\t}\n\t\t\n\t\tdouble swaps = (double)node.getSwaps();\n\t\tdouble noSwaps = (double)node.getNoSwaps();\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimate24h = 0;\n\t\t\tint networkSizeEstimate48h = 0;\n\t\t\tdouble numberOfRemotePeerLocationsSeenInSwaps = (double)node.getNumberOfRemotePeerLocationsSeenInSwaps();\n\t\t\t\n\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\tnetworkSizeEstimate24h = node.getNetworkSizeEstimate(now - (24*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimate48h = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix1p4 = new DecimalFormat(\"0.0000\");\n\t\t\tDecimalFormat fix6p6 = new DecimalFormat(\"#####0.0#####\");\n\t\t\tDecimalFormat fix1p6sci = new DecimalFormat(\"0.######E0\");\n\t\t\tDecimalFormat fix3p1pct = new DecimalFormat(\"##0.0%\");\n            NumberFormat thousendPoint = NumberFormat.getInstance();\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate24h:\\u00a0\" + networkSizeEstimate24h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate48h:\\u00a0\" + networkSizeEstimate48h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif ((numberOfRemotePeerLocationsSeenInSwaps > 0.0) && ((swaps > 0.0) || (noSwaps > 0.0))) {\n\t\t\t\t\toverviewList.addChild(\"li\", \"avrConnPeersPerNode:\\u00a0\" + fix6p6.format(numberOfRemotePeerLocationsSeenInSwaps/(swaps+noSwaps)) + \"\\u00a0peers\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix1p4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix3p1pct.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix3p1pct.format(node.pRejectIncomingInstantly()));\n\t\t\t\toverviewList.addChild(\"li\", \"unclaimedFIFOSize:\\u00a0\" + node.getUnclaimedFIFOSize());\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Swap statistics box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tint startedSwaps = node.getStartedSwaps();\n\t\t\t\tint swapsRejectedAlreadyLocked = node.getSwapsRejectedAlreadyLocked();\n\t\t\t\tint swapsRejectedNowhereToGo = node.getSwapsRejectedNowhereToGo();\n\t\t\t\tint swapsRejectedRateLimit = node.getSwapsRejectedRateLimit();\n\t\t\t\tint swapsRejectedLoop = node.getSwapsRejectedLoop();\n\t\t\t\tint swapsRejectedRecognizedID = node.getSwapsRejectedRecognizedID();\n\t\t\t\tdouble locChangeSession = node.getLocationChangeSession();\n\t\t\t\t\n\t\t\t\tHTMLNode locationSwapInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tlocationSwapInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Location swaps\");\n\t\t\t\tHTMLNode locationSwapInfoboxContent = locationSwapInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode locationSwapList = locationSwapInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangeSession:\\u00a0\" + fix1p6sci.format(locChangeSession));\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerSwap:\\u00a0\" + fix1p6sci.format(locChangeSession/swaps));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerMinute:\\u00a0\" + fix1p6sci.format(locChangeSession/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerMinute:\\u00a0\" + fix1p6sci.format(swaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((noSwaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwapsPerMinute:\\u00a0\" + fix1p6sci.format(noSwaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (noSwaps > 0.0)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerNoSwaps:\\u00a0\" + fix1p6sci.format(swaps/noSwaps));\n\t\t\t\t}\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swaps:\\u00a0\" + (int)swaps);\n\t\t\t\t}\n\t\t\t\tif (noSwaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwaps:\\u00a0\" + (int)noSwaps);\n\t\t\t\t}\n\t\t\t\tif (startedSwaps > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"startedSwaps:\\u00a0\" + startedSwaps);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedAlreadyLocked > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedAlreadyLocked:\\u00a0\" + swapsRejectedAlreadyLocked);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedNowhereToGo > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedNowhereToGo:\\u00a0\" + swapsRejectedNowhereToGo);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRateLimit > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRateLimit:\\u00a0\" + swapsRejectedRateLimit);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedLoop > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedLoop:\\u00a0\" + swapsRejectedLoop);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRecognizedID > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRecognizedID:\\u00a0\" + swapsRejectedRecognizedID);\n\t\t\t\t}\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\t\t\t\n\t\t\t// Bandwidth box\n\t\t\tif (advancedEnabled) {\n\t\t\t\tHTMLNode bandwidthInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Bandwidth\");\n\t\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode bandwidthList = bandwidthInfoboxContent.addChild(\"ul\");\n\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0]) + \"\\u00a0(\" + SizeUtil.formatSize(total_output_rate) + \"ps)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload) + \"\\u00a0(\" + SizeUtil.formatSize(total_payload_rate) + \"ps) (\"+percent+\"%)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1]) + \"\\u00a0(\" + SizeUtil.formatSize(total_input_rate) + \"ps)\");\n\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\tbandwidthList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate) + \"ps\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate) + \"ps\");\n                nextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // store size box\n            if (advancedEnabled) {\n                HTMLNode storeSizeInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Store size\");\n                HTMLNode storeSizeInfoboxContent = storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode storeSizeList = storeSizeInfoboxContent.addChild(\"ul\");\n                \n                final long fix32kb = 32 * 1024;\n                \n                long cachedKeys = node.getChkDatacache().keyCount();\n                long cachedSize = cachedKeys * fix32kb;\n                long storeKeys = node.getChkDatastore().keyCount();\n                long storeSize = storeKeys * fix32kb;\n                long overallKeys = cachedKeys + storeKeys;\n                long overallSize = cachedSize + storeSize;\n                \n//                long maxCachedKeys = node.getChkDatacache().getMaxKeys();\n//                long maxStoreKeys = node.getChkDatastore().getMaxKeys();\n                long maxOverallKeys = node.getMaxTotalKeys();\n                long maxOverallSize = maxOverallKeys * fix32kb;\n                \n                long cachedStoreHits = node.getChkDatacache().hits();\n                long cachedStoreMisses = node.getChkDatacache().misses();\n                long cacheAccesses = cachedStoreHits + cachedStoreMisses;\n                long storeHits = node.getChkDatastore().hits();\n                long storeMisses = node.getChkDatastore().misses();\n                long storeAccesses = storeHits + storeMisses;\n                long overallAccesses = storeAccesses + cacheAccesses;\n                \n                storeSizeList.addChild(\"li\", \n                        \"Cached keys:\\u00a0\" + thousendPoint.format(cachedKeys) + \n                        \"\\u00a0(\" + SizeUtil.formatSize(cachedSize) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Stored keys:\\u00a0\" + thousendPoint.format(storeKeys) + \n                        \"\\u00a0(\" + SizeUtil.formatSize(storeSize) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Overall size:\\u00a0\" + thousendPoint.format(overallKeys) + \n                        \"\\u00a0/\\u00a0\" + thousendPoint.format(maxOverallKeys) +\n                        \"\\u00a0(\" + SizeUtil.formatSize(overallSize) + \n                        \"\\u00a0/\\u00a0\" + SizeUtil.formatSize(maxOverallSize) + \n                        \")\\u00a0(\" + ((overallKeys*100)/maxOverallKeys) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Cache hits:\\u00a0\" + thousendPoint.format(cachedStoreHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(cacheAccesses) +\n                        \"\\u00a0(\" + ((cachedStoreHits*100) / (cacheAccesses)) + \"%)\");\n                \n                storeSizeList.addChild(\"li\", \n                        \"Store hits:\\u00a0\" + thousendPoint.format(storeHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(storeAccesses) +\n                        \"\\u00a0(\" + ((storeHits*100) / (storeAccesses)) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Avg. access rate:\\u00a0\" + thousendPoint.format(overallAccesses/nodeUptimeSeconds) + \"/s\");\n            }\n            \n            nextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n            // jvm stats box\n            if (advancedEnabled) {\n                HTMLNode jvmStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"JVM info\");\n                HTMLNode jvmStatsInfoboxContent = jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode jvmStatsList = jvmStatsInfoboxContent.addChild(\"ul\");\n\n                Runtime rt = Runtime.getRuntime();\n                float freeMemory = (float) rt.freeMemory();\n                float totalMemory = (float) rt.totalMemory();\n                float maxMemory = (float) rt.maxMemory();\n\n                long usedJavaMem = (long)(totalMemory - freeMemory);\n                long allocatedJavaMem = (long)totalMemory;\n                long maxJavaMem = (long)maxMemory;\n                int threadCount = Thread.activeCount();\n                int availableCpus = rt.availableProcessors();\n\n                jvmStatsList.addChild(\"li\", \"Used Java memory:\\u00a0\" + SizeUtil.formatSize(usedJavaMem));\n                jvmStatsList.addChild(\"li\", \"Allocated Java memory:\\u00a0\" + SizeUtil.formatSize(allocatedJavaMem));\n                jvmStatsList.addChild(\"li\", \"Maximum Java memory:\\u00a0\" + SizeUtil.formatSize(maxJavaMem));\n                jvmStatsList.addChild(\"li\", \"Available CPUs:\\u00a0\" + availableCpus);\n                jvmStatsList.addChild(\"li\", \"Running threads:\\u00a0\" + thousendPoint.format(threadCount));\n            }\n\t\t\t\n\t\t\t// unclaimedFIFOMessageCounts box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tMap unclaimedFIFOMessageCountsMap = node.getUSM().getUnclaimedFIFOMessageCounts();\n\t\t\t\tSTMessageCount[] unclaimedFIFOMessageCountsArray = new STMessageCount[unclaimedFIFOMessageCountsMap.size()];\n\t\t\t\tint i = 0;\n\t\t\t\tint totalCount = 0;\n\t\t\t\tfor (Iterator messageCounts = unclaimedFIFOMessageCountsMap.keySet().iterator(); messageCounts.hasNext(); ) {\n\t\t\t\t\tString messageName = (String) messageCounts.next();\n\t\t\t\t\tint messageCount = ((Integer) unclaimedFIFOMessageCountsMap.get(messageName)).intValue();\n\t\t\t\t\ttotalCount = totalCount + messageCount;\n\t\t\t\t\tunclaimedFIFOMessageCountsArray[i++] = new STMessageCount( messageName, messageCount );\n\t\t\t\t}\n\t\t\t\tArrays.sort(unclaimedFIFOMessageCountsArray, new Comparator() {\n\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\tSTMessageCount firstCount = (STMessageCount) first;\n\t\t\t\t\t\tSTMessageCount secondCount = (STMessageCount) second;\n\t\t\t\t\t\treturn secondCount.messageCount - firstCount.messageCount;  // sort in descending order\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tunclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"unclaimedFIFO Message Counts\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfoboxContent = unclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsList = unclaimedFIFOMessageCountsInfoboxContent.addChild(\"ul\");\n\t\t\t\tfor (int countsArrayIndex = 0, countsArrayCount = unclaimedFIFOMessageCountsArray.length; countsArrayIndex < countsArrayCount; countsArrayIndex++) {\n\t\t\t\t\tSTMessageCount messageCountItem = (STMessageCount) unclaimedFIFOMessageCountsArray[countsArrayIndex];\n\t\t\t\t\tint thisMessageCount = messageCountItem.messageCount;\n\t\t\t\t\tdouble thisMessagePercentOfTotal = ((double) thisMessageCount) / ((double) totalCount);\n\t\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"\" + messageCountItem.messageName + \":\\u00a0\" + thisMessageCount + \"\\u00a0(\" + fix3p1pct.format(thisMessagePercentOfTotal) + ')');\n\t\t\t\t}\n\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"Unclaimed Messages Considered:\\u00a0\" + totalCount);\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // node version information box\n            if (advancedEnabled) {\n                HTMLNode versionInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                versionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node Version Information\");\n                HTMLNode versionInfoboxContent = versionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet \" + Version.nodeVersion + \" Build #\" + Version.buildNumber() + \" r\" + Version.cvsRevision);\n\t\t\t\tversionInfoboxContent.addChild(\"br\");\n\t\t\t\tif(NodeStarter.extBuildNumber < NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER) {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + '(' + NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER + \") r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t} else {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + \" r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t}\n            }\n\t\t}\n\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t}","id":74,"modified_method":"public void handleGet(URI uri, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\t\n\t\tfinal boolean advancedEnabled = node.isAdvancedDarknetEnabled();\n\t\t\n\t\t/* gather connection statistics */\n\t\tPeerNodeStatus[] peerNodeStatuses = node.getPeerNodeStatuses();\n\t\tArrays.sort(peerNodeStatuses, new Comparator() {\n\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\tPeerNodeStatus firstNode = (PeerNodeStatus) first;\n\t\t\t\tPeerNodeStatus secondNode = (PeerNodeStatus) second;\n\t\t\t\tint statusDifference = firstNode.getStatusValue() - secondNode.getStatusValue();\n\t\t\t\tif (statusDifference != 0) {\n\t\t\t\t\treturn statusDifference;\n\t\t\t\t}\n\t\t\t\treturn firstNode.getName().compareToIgnoreCase(secondNode.getName());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint numberOfConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_CONNECTED);\n\t\tint numberOfRoutingBackedOff = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_ROUTING_BACKED_OFF);\n\t\tint numberOfTooNew = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_NEW);\n\t\tint numberOfTooOld = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_TOO_OLD);\n\t\tint numberOfDisconnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISCONNECTED);\n\t\tint numberOfNeverConnected = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_NEVER_CONNECTED);\n\t\tint numberOfDisabled = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_DISABLED);\n\t\tint numberOfBursting = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_BURSTING);\n\t\tint numberOfListening = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTENING);\n\t\tint numberOfListenOnly = getPeerStatusCount(peerNodeStatuses, Node.PEER_NODE_STATUS_LISTEN_ONLY);\n\t\t\n\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Statistics for \" + node.getMyName());\n\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\n\t\t// FIXME! We need some nice images\n\t\tlong now = System.currentTimeMillis();\n\t\n\t\tcontentNode.addChild(core.alerts.createSummary());\n\n\t\t// Generate a Thread-Dump\n\t\tif(node.isUsingWrapper()){\n\t\t\tHTMLNode infobox = contentNode.addChild(ctx.getPageMaker().getInfobox(\"Request a Thread Dump to be generated\"));\n\t\t\tHTMLNode threadDumpForm = ctx.getPageMaker().getContentNode(infobox).addChild(\"form\", new String[] { \"action\", \"method\" }, new String[] { \"/\", \"POST\" });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"formPassword\", core.formPassword });\n\t\t\tthreadDumpForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"getThreadDump\", \"Generate a Thread Dump\" });\n\t\t}\n\t\t\n\t\tdouble swaps = (double)node.getSwaps();\n\t\tdouble noSwaps = (double)node.getNoSwaps();\n\t\t\n\t\tif(peerNodeStatuses.length>0){\n\n\t\t\t/* node status values */\n\t\t\tlong nodeUptimeSeconds = (now - node.startupTime) / 1000;\n\t\t\tint bwlimitDelayTime = (int) node.getBwlimitDelayTime();\n\t\t\tint nodeAveragePingTime = (int) node.getNodeAveragePingTime();\n\t\t\tint networkSizeEstimateSession = node.getNetworkSizeEstimate(-1);\n\t\t\tint networkSizeEstimate24h = 0;\n\t\t\tint networkSizeEstimate48h = 0;\n\t\t\tdouble numberOfRemotePeerLocationsSeenInSwaps = (double)node.getNumberOfRemotePeerLocationsSeenInSwaps();\n\t\t\t\n\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\tnetworkSizeEstimate24h = node.getNetworkSizeEstimate(now - (24*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\tnetworkSizeEstimate48h = node.getNetworkSizeEstimate(now - (48*60*60*1000));  // 48 hours\n\t\t\t}\n\t\t\tDecimalFormat fix1p4 = new DecimalFormat(\"0.0000\");\n\t\t\tDecimalFormat fix6p6 = new DecimalFormat(\"#####0.0#####\");\n\t\t\tDecimalFormat fix1p6sci = new DecimalFormat(\"0.######E0\");\n\t\t\tDecimalFormat fix3p1pct = new DecimalFormat(\"##0.0%\");\n            NumberFormat thousendPoint = NumberFormat.getInstance();\n\t\t\tdouble routingMissDistance =  node.routingMissDistance.currentValue();\n\t\t\tdouble backedOffPercent =  node.backedOffPercent.currentValue();\n\t\t\tString nodeUptimeString = TimeUtil.formatTime(nodeUptimeSeconds * 1000);  // *1000 to convert to milliseconds\n\n\t\t\tHTMLNode overviewTable = contentNode.addChild(\"table\", \"class\", \"column\");\n\t\t\tHTMLNode overviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\tHTMLNode nextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\n\t\t\t/* node status overview box */\n\t\t\tif(advancedEnabled) {\n\t\t\t\tHTMLNode overviewInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\toverviewInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node status overview\");\n\t\t\t\tHTMLNode overviewInfoboxContent = overviewInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode overviewList = overviewInfoboxContent.addChild(\"ul\");\n\t\t\t\toverviewList.addChild(\"li\", \"bwlimitDelayTime:\\u00a0\" + bwlimitDelayTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"nodeAveragePingTime:\\u00a0\" + nodeAveragePingTime + \"ms\");\n\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimateSession:\\u00a0\" + networkSizeEstimateSession + \"\\u00a0nodes\");\n\t\t\t\tif(nodeUptimeSeconds > (24*60*60)) {  // 24 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate24h:\\u00a0\" + networkSizeEstimate24h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif(nodeUptimeSeconds > (48*60*60)) {  // 48 hours\n\t\t\t\t\toverviewList.addChild(\"li\", \"networkSizeEstimate48h:\\u00a0\" + networkSizeEstimate48h + \"\\u00a0nodes\");\n\t\t\t\t}\n\t\t\t\tif ((numberOfRemotePeerLocationsSeenInSwaps > 0.0) && ((swaps > 0.0) || (noSwaps > 0.0))) {\n\t\t\t\t\toverviewList.addChild(\"li\", \"avrConnPeersPerNode:\\u00a0\" + fix6p6.format(numberOfRemotePeerLocationsSeenInSwaps/(swaps+noSwaps)) + \"\\u00a0peers\");\n\t\t\t\t}\n\t\t\t\toverviewList.addChild(\"li\", \"nodeUptime:\\u00a0\" + nodeUptimeString);\n\t\t\t\toverviewList.addChild(\"li\", \"routingMissDistance:\\u00a0\" + fix1p4.format(routingMissDistance));\n\t\t\t\toverviewList.addChild(\"li\", \"backedOffPercent:\\u00a0\" + fix3p1pct.format(backedOffPercent));\n\t\t\t\toverviewList.addChild(\"li\", \"pInstantReject:\\u00a0\" + fix3p1pct.format(node.pRejectIncomingInstantly()));\n\t\t\t\toverviewList.addChild(\"li\", \"unclaimedFIFOSize:\\u00a0\" + node.getUnclaimedFIFOSize());\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n\t\t\t// Activity box\n\t\t\tint numInserts = node.getNumInserts();\n\t\t\tint numRequests = node.getNumRequests();\n\t\t\tint numTransferringRequests = node.getNumTransferringRequests();\n\t\t\tint numARKFetchers = node.getNumARKFetchers();\n\n\t\t\tHTMLNode activityInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tactivityInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Current activity\");\n\t\t\tHTMLNode activityInfoboxContent = activityInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tif ((numInserts == 0) && (numRequests == 0) && (numTransferringRequests == 0) && (numARKFetchers == 0)) {\n\t\t\t\tactivityInfoboxContent.addChild(\"#\", \"Your node is not processing any requests right now.\");\n\t\t\t} else {\n\t\t\t\tHTMLNode activityList = activityInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (numInserts > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Inserts:\\u00a0\" + numInserts);\n\t\t\t\t}\n\t\t\t\tif (numRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Requests:\\u00a0\" + numRequests);\n\t\t\t\t}\n\t\t\t\tif (numTransferringRequests > 0) {\n\t\t\t\t\tactivityList.addChild(\"li\", \"Transferring\\u00a0Requests:\\u00a0\" + numTransferringRequests);\n\t\t\t\t}\n\t\t\t\tif (advancedEnabled) {\n\t\t\t\t\tif (numARKFetchers > 0) {\n\t\t\t\t\t\tactivityList.addChild(\"li\", \"ARK\\u00a0Fetch\\u00a0Requests:\\u00a0\" + numARKFetchers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n\t\t\t// Peer statistics box\n\t\t\tHTMLNode peerStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\tpeerStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer statistics\");\n\t\t\tHTMLNode peerStatsContent = peerStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tHTMLNode peerStatsList = peerStatsContent.addChild(\"ul\");\n\t\t\tif (numberOfConnected > 0) {\n\t\t\t\tHTMLNode peerStatsConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_connected\", \"Connected: We're successfully connected to these nodes\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Connected\");\n\t\t\t\tpeerStatsConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfConnected);\n\t\t\t}\n\t\t\tif (numberOfRoutingBackedOff > 0) {\n\t\t\t\tHTMLNode peerStatsRoutingBackedOffListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_backed_off\", (advancedEnabled ? \"Connected but backed off: These peers are connected but we're backed off of them\" : \"Busy: These peers are connected but they're busy\") + \", so the node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, advancedEnabled ? \"Backed off\" : \"Busy\");\n\t\t\t\tpeerStatsRoutingBackedOffListItem.addChild(\"span\", \":\\u00a0\" + numberOfRoutingBackedOff);\n\t\t\t}\n\t\t\tif (numberOfTooNew > 0) {\n\t\t\t\tHTMLNode peerStatsTooNewListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_new\", \"Connected but too new: These peers' minimum mandatory build is higher than this node's build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too New\");\n\t\t\t\tpeerStatsTooNewListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooNew);\n\t\t\t}\n\t\t\tif (numberOfTooOld > 0) {\n\t\t\t\tHTMLNode peerStatsTooOldListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_too_old\", \"Connected but too old: This node's minimum mandatory build is higher than these peers' build. This node is not routing requests to them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Too Old\");\n\t\t\t\tpeerStatsTooOldListItem.addChild(\"span\", \":\\u00a0\" + numberOfTooOld);\n\t\t\t}\n\t\t\tif (numberOfDisconnected > 0) {\n\t\t\t\tHTMLNode peerStatsDisconnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disconnected\", \"Not connected: No connection so far but this node is continuously trying to connect\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disconnected\");\n\t\t\t\tpeerStatsDisconnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisconnected);\n\t\t\t}\n\t\t\tif (numberOfNeverConnected > 0) {\n\t\t\t\tHTMLNode peerStatsNeverConnectedListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_never_connected\", \"Never Connected: The node has never connected with these peers\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Never Connected\");\n\t\t\t\tpeerStatsNeverConnectedListItem.addChild(\"span\", \":\\u00a0\" + numberOfNeverConnected);\n\t\t\t}\n\t\t\tif (numberOfDisabled > 0) {\n\t\t\t\tHTMLNode peerStatsDisabledListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_disabled\", \"Not connected and disabled: because the user has instructed to not connect to peers \", \"border-bottom: 1px dotted; cursor: help;\" }, \"Disabled\");\n\t\t\t\tpeerStatsDisabledListItem.addChild(\"span\", \":\\u00a0\" + numberOfDisabled);\n\t\t\t}\n\t\t\tif (numberOfBursting > 0) {\n\t\t\t\tHTMLNode peerStatsBurstingListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_bursting\", \"Not connected and bursting: this node is, for a short period, trying to connect to these peers because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Bursting\");\n\t\t\t\tpeerStatsBurstingListItem.addChild(\"span\", \":\\u00a0\" + numberOfBursting);\n\t\t\t}\n\t\t\tif (numberOfListening > 0) {\n\t\t\t\tHTMLNode peerStatsListeningListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listening\", \"Not connected but listening: this node won't try to connect to these peers very often because the user has set BurstOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listening\");\n\t\t\t\tpeerStatsListeningListItem.addChild(\"span\", \":\\u00a0\" + numberOfListening);\n\t\t\t}\n\t\t\tif (numberOfListenOnly > 0) {\n\t\t\t\tHTMLNode peerStatsListenOnlyListItem = peerStatsList.addChild(\"li\").addChild(\"span\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", new String[] { \"class\", \"title\", \"style\" }, new String[] { \"peer_listen_only\", \"Not connected and listen only: this node won't try to connect to these peers at all because the user has set ListenOnly on them\", \"border-bottom: 1px dotted; cursor: help;\" }, \"Listen Only\");\n\t\t\t\tpeerStatsListenOnlyListItem.addChild(\"span\", \":\\u00a0\" + numberOfListenOnly);\n\t\t\t}\n\n\t\t\t// Peer routing backoff reason box\n\t\t\tif(advancedEnabled) {\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\t\t\t\tHTMLNode backoffReasonInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbackoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Peer backoff reasons\");\n\t\t\t\tHTMLNode backoffReasonContent = backoffReasonInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tString [] routingBackoffReasons = node.getPeerNodeRoutingBackoffReasons();\n\t\t\t\tif(routingBackoffReasons.length == 0) {\n\t\t\t\t\tbackoffReasonContent.addChild(\"#\", \"Good, your node is not backed off from any peers!\");\n\t\t\t\t} else {\n\t\t\t\t\tHTMLNode reasonList = backoffReasonContent.addChild(\"ul\");\n\t\t\t\t\tfor(int i=0;i<routingBackoffReasons.length;i++) {\n\t\t\t\t\t\tint reasonCount = node.getPeerNodeRoutingBackoffReasonSize(routingBackoffReasons[i]);\n\t\t\t\t\t\tif(reasonCount > 0) {\n\t\t\t\t\t\t\treasonList.addChild(\"li\", routingBackoffReasons[i] + '\\u00a0' + reasonCount);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//Swap statistics box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tint startedSwaps = node.getStartedSwaps();\n\t\t\t\tint swapsRejectedAlreadyLocked = node.getSwapsRejectedAlreadyLocked();\n\t\t\t\tint swapsRejectedNowhereToGo = node.getSwapsRejectedNowhereToGo();\n\t\t\t\tint swapsRejectedRateLimit = node.getSwapsRejectedRateLimit();\n\t\t\t\tint swapsRejectedLoop = node.getSwapsRejectedLoop();\n\t\t\t\tint swapsRejectedRecognizedID = node.getSwapsRejectedRecognizedID();\n\t\t\t\tdouble locChangeSession = node.getLocationChangeSession();\n\t\t\t\t\n\t\t\t\tHTMLNode locationSwapInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tlocationSwapInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Location swaps\");\n\t\t\t\tHTMLNode locationSwapInfoboxContent = locationSwapInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode locationSwapList = locationSwapInfoboxContent.addChild(\"ul\");\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangeSession:\\u00a0\" + fix1p6sci.format(locChangeSession));\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerSwap:\\u00a0\" + fix1p6sci.format(locChangeSession/swaps));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"locChangePerMinute:\\u00a0\" + fix1p6sci.format(locChangeSession/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerMinute:\\u00a0\" + fix1p6sci.format(swaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((noSwaps > 0.0) && (nodeUptimeSeconds >= 60)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwapsPerMinute:\\u00a0\" + fix1p6sci.format(noSwaps/(double)(nodeUptimeSeconds/60.0)));\n\t\t\t\t}\n\t\t\t\tif ((swaps > 0.0) && (noSwaps > 0.0)) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsPerNoSwaps:\\u00a0\" + fix1p6sci.format(swaps/noSwaps));\n\t\t\t\t}\n\t\t\t\tif (swaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swaps:\\u00a0\" + (int)swaps);\n\t\t\t\t}\n\t\t\t\tif (noSwaps > 0.0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"noSwaps:\\u00a0\" + (int)noSwaps);\n\t\t\t\t}\n\t\t\t\tif (startedSwaps > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"startedSwaps:\\u00a0\" + startedSwaps);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedAlreadyLocked > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedAlreadyLocked:\\u00a0\" + swapsRejectedAlreadyLocked);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedNowhereToGo > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedNowhereToGo:\\u00a0\" + swapsRejectedNowhereToGo);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRateLimit > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRateLimit:\\u00a0\" + swapsRejectedRateLimit);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedLoop > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedLoop:\\u00a0\" + swapsRejectedLoop);\n\t\t\t\t}\n\t\t\t\tif (swapsRejectedRecognizedID > 0) {\n\t\t\t\t\tlocationSwapList.addChild(\"li\", \"swapsRejectedRecognizedID:\\u00a0\" + swapsRejectedRecognizedID);\n\t\t\t\t}\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\t\t\t\n\t\t\t// Bandwidth box\n\t\t\tif (advancedEnabled) {\n\t\t\t\tHTMLNode bandwidthInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tbandwidthInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Bandwidth\");\n\t\t\t\tHTMLNode bandwidthInfoboxContent = bandwidthInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode bandwidthList = bandwidthInfoboxContent.addChild(\"ul\");\n\t\t\t\tlong[] total = IOStatisticCollector.getTotalIO();\n\t\t\t\tlong total_output_rate = (total[0]) / nodeUptimeSeconds;\n\t\t\t\tlong total_input_rate = (total[1]) / nodeUptimeSeconds;\n\t\t\t\tlong totalPayload = node.getTotalPayloadSent();\n\t\t\t\tlong total_payload_rate = totalPayload / nodeUptimeSeconds;\n\t\t\t\tint percent = (int) (100 * totalPayload / total[0]);\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Output:\\u00a0\" + SizeUtil.formatSize(total[0]) + \" (\" + SizeUtil.formatSize(total_output_rate, true) + \"ps)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Payload Output:\\u00a0\" + SizeUtil.formatSize(totalPayload) + \" (\" + SizeUtil.formatSize(total_payload_rate, true) + \"ps) (\"+percent+\"%)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Total Input:\\u00a0\" + SizeUtil.formatSize(total[1]) + \" (\" + SizeUtil.formatSize(total_input_rate, true) + \"ps)\");\n\t\t\t\tlong[] rate = node.getNodeIOStats();\n\t\t\t\tlong delta = (rate[5] - rate[2]) / 1000;\n\t\t\t\tlong output_rate = (rate[3] - rate[0]) / delta;\n\t\t\t\tlong input_rate = (rate[4] - rate[1]) / delta;\n\t\t\t\tSubConfig nodeConfig = node.config.get(\"node\");\n\t\t\t\tint outputBandwidthLimit = nodeConfig.getInt(\"outputBandwidthLimit\");\n\t\t\t\tint inputBandwidthLimit = nodeConfig.getInt(\"inputBandwidthLimit\");\n\t\t\t\tif(inputBandwidthLimit == -1) {\n\t\t\t\t\tinputBandwidthLimit = outputBandwidthLimit * 4;\n\t\t\t\t}\n\t\t\t\tbandwidthList.addChild(\"li\", \"Output Rate:\\u00a0\" + SizeUtil.formatSize(output_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(outputBandwidthLimit, true)+\"ps)\");\n\t\t\t\tbandwidthList.addChild(\"li\", \"Input Rate:\\u00a0\" + SizeUtil.formatSize(input_rate, true) + \"ps (of\\u00a0\"+SizeUtil.formatSize(inputBandwidthLimit, true)+\"ps)\");\n                nextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // store size box\n            if (advancedEnabled) {\n                HTMLNode storeSizeInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Store size\");\n                HTMLNode storeSizeInfoboxContent = storeSizeInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode storeSizeList = storeSizeInfoboxContent.addChild(\"ul\");\n                \n                final long fix32kb = 32 * 1024;\n                \n                long cachedKeys = node.getChkDatacache().keyCount();\n                long cachedSize = cachedKeys * fix32kb;\n                long storeKeys = node.getChkDatastore().keyCount();\n                long storeSize = storeKeys * fix32kb;\n                long overallKeys = cachedKeys + storeKeys;\n                long overallSize = cachedSize + storeSize;\n                \n//                long maxCachedKeys = node.getChkDatacache().getMaxKeys();\n//                long maxStoreKeys = node.getChkDatastore().getMaxKeys();\n                long maxOverallKeys = node.getMaxTotalKeys();\n                long maxOverallSize = maxOverallKeys * fix32kb;\n                \n                long cachedStoreHits = node.getChkDatacache().hits();\n                long cachedStoreMisses = node.getChkDatacache().misses();\n                long cacheAccesses = cachedStoreHits + cachedStoreMisses;\n                long storeHits = node.getChkDatastore().hits();\n                long storeMisses = node.getChkDatastore().misses();\n                long storeAccesses = storeHits + storeMisses;\n                long overallAccesses = storeAccesses + cacheAccesses;\n                \n                storeSizeList.addChild(\"li\", \n                        \"Cached keys:\\u00a0\" + thousendPoint.format(cachedKeys) + \n                        \" (\" + SizeUtil.formatSize(cachedSize, true) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Stored keys:\\u00a0\" + thousendPoint.format(storeKeys) + \n                        \" (\" + SizeUtil.formatSize(storeSize, true) + ')');\n\n                storeSizeList.addChild(\"li\", \n                        \"Overall size:\\u00a0\" + thousendPoint.format(overallKeys) + \n                        \"\\u00a0/\\u00a0\" + thousendPoint.format(maxOverallKeys) +\n                        \" (\" + SizeUtil.formatSize(overallSize, true) + \n                        \"\\u00a0/\\u00a0\" + SizeUtil.formatSize(maxOverallSize, true) + \n                        \")\\u00a0(\" + ((overallKeys*100)/maxOverallKeys) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Cache hits:\\u00a0\" + thousendPoint.format(cachedStoreHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(cacheAccesses) +\n                        \"\\u00a0(\" + ((cachedStoreHits*100) / (cacheAccesses)) + \"%)\");\n                \n                storeSizeList.addChild(\"li\", \n                        \"Store hits:\\u00a0\" + thousendPoint.format(storeHits) + \n                        \"\\u00a0/\\u00a0\"+thousendPoint.format(storeAccesses) +\n                        \"\\u00a0(\" + ((storeHits*100) / (storeAccesses)) + \"%)\");\n\n                storeSizeList.addChild(\"li\", \n                        \"Avg. access rate:\\u00a0\" + thousendPoint.format(overallAccesses/nodeUptimeSeconds) + \"/s\");\n            }\n            \n            nextTableCell = advancedEnabled ? overviewTableRow.addChild(\"td\") : overviewTableRow.addChild(\"td\", \"class\", \"last\");\n\n            // jvm stats box\n            if (advancedEnabled) {\n                HTMLNode jvmStatsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"JVM info\");\n                HTMLNode jvmStatsInfoboxContent = jvmStatsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n                HTMLNode jvmStatsList = jvmStatsInfoboxContent.addChild(\"ul\");\n\n                Runtime rt = Runtime.getRuntime();\n                float freeMemory = (float) rt.freeMemory();\n                float totalMemory = (float) rt.totalMemory();\n                float maxMemory = (float) rt.maxMemory();\n\n                long usedJavaMem = (long)(totalMemory - freeMemory);\n                long allocatedJavaMem = (long)totalMemory;\n                long maxJavaMem = (long)maxMemory;\n                int threadCount = Thread.activeCount();\n                int availableCpus = rt.availableProcessors();\n\n                jvmStatsList.addChild(\"li\", \"Used Java memory:\\u00a0\" + SizeUtil.formatSize(usedJavaMem, true));\n                jvmStatsList.addChild(\"li\", \"Allocated Java memory:\\u00a0\" + SizeUtil.formatSize(allocatedJavaMem, true));\n                jvmStatsList.addChild(\"li\", \"Maximum Java memory:\\u00a0\" + SizeUtil.formatSize(maxJavaMem, true));\n                jvmStatsList.addChild(\"li\", \"Available CPUs:\\u00a0\" + availableCpus);\n                jvmStatsList.addChild(\"li\", \"Running threads:\\u00a0\" + thousendPoint.format(threadCount));\n            }\n\t\t\t\n\t\t\t// unclaimedFIFOMessageCounts box\n\t\t\tif(advancedEnabled) {\n\t\t\t\toverviewTableRow = overviewTable.addChild(\"tr\");\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\", \"class\", \"first\");\n\t\t\t\tMap unclaimedFIFOMessageCountsMap = node.getUSM().getUnclaimedFIFOMessageCounts();\n\t\t\t\tSTMessageCount[] unclaimedFIFOMessageCountsArray = new STMessageCount[unclaimedFIFOMessageCountsMap.size()];\n\t\t\t\tint i = 0;\n\t\t\t\tint totalCount = 0;\n\t\t\t\tfor (Iterator messageCounts = unclaimedFIFOMessageCountsMap.keySet().iterator(); messageCounts.hasNext(); ) {\n\t\t\t\t\tString messageName = (String) messageCounts.next();\n\t\t\t\t\tint messageCount = ((Integer) unclaimedFIFOMessageCountsMap.get(messageName)).intValue();\n\t\t\t\t\ttotalCount = totalCount + messageCount;\n\t\t\t\t\tunclaimedFIFOMessageCountsArray[i++] = new STMessageCount( messageName, messageCount );\n\t\t\t\t}\n\t\t\t\tArrays.sort(unclaimedFIFOMessageCountsArray, new Comparator() {\n\t\t\t\t\tpublic int compare(Object first, Object second) {\n\t\t\t\t\t\tSTMessageCount firstCount = (STMessageCount) first;\n\t\t\t\t\t\tSTMessageCount secondCount = (STMessageCount) second;\n\t\t\t\t\t\treturn secondCount.messageCount - firstCount.messageCount;  // sort in descending order\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n\t\t\t\tunclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"unclaimedFIFO Message Counts\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsInfoboxContent = unclaimedFIFOMessageCountsInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tHTMLNode unclaimedFIFOMessageCountsList = unclaimedFIFOMessageCountsInfoboxContent.addChild(\"ul\");\n\t\t\t\tfor (int countsArrayIndex = 0, countsArrayCount = unclaimedFIFOMessageCountsArray.length; countsArrayIndex < countsArrayCount; countsArrayIndex++) {\n\t\t\t\t\tSTMessageCount messageCountItem = (STMessageCount) unclaimedFIFOMessageCountsArray[countsArrayIndex];\n\t\t\t\t\tint thisMessageCount = messageCountItem.messageCount;\n\t\t\t\t\tdouble thisMessagePercentOfTotal = ((double) thisMessageCount) / ((double) totalCount);\n\t\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"\" + messageCountItem.messageName + \":\\u00a0\" + thisMessageCount + \"\\u00a0(\" + fix3p1pct.format(thisMessagePercentOfTotal) + ')');\n\t\t\t\t}\n\t\t\t\tunclaimedFIFOMessageCountsList.addChild(\"li\", \"Unclaimed Messages Considered:\\u00a0\" + totalCount);\n\t\t\t\tnextTableCell = overviewTableRow.addChild(\"td\");\n\t\t\t}\n\n            // node version information box\n            if (advancedEnabled) {\n                HTMLNode versionInfobox = nextTableCell.addChild(\"div\", \"class\", \"infobox\");\n                versionInfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Node Version Information\");\n                HTMLNode versionInfoboxContent = versionInfobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet \" + Version.nodeVersion + \" Build #\" + Version.buildNumber() + \" r\" + Version.cvsRevision);\n\t\t\t\tversionInfoboxContent.addChild(\"br\");\n\t\t\t\tif(NodeStarter.extBuildNumber < NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER) {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + '(' + NodeStarter.RECOMMENDED_EXT_BUILD_NUMBER + \") r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t} else {\n\t\t\t\t\tversionInfoboxContent.addChild(\"#\", \"Freenet-ext Build #\" + NodeStarter.extBuildNumber + \" r\" + NodeStarter.extRevisionNumber);\n\t\t\t\t}\n            }\n\t\t}\n\n\t\tthis.writeReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t}","commit_id":"b0d8a0763474a0e66850bdecaa333d4ab5fd0503","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":75,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":76,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"64f48874ac4aab6e0ffb085e07642ffa44d8c7ca","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":77,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        Builder builder = FileStore.builder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n\n        closer.register(asCloseable(fs));\n        return new TarNodeStore(SegmentNodeStore.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.setHead(lastRoot, ((SegmentNodeBuilder) builder).getNodeState());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256).withMemoryMapping(mmap);\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","id":78,"modified_method":"@Override\n    public NodeStore create(BlobStore blobStore, Closer closer) throws IOException {\n        final FileStoreBuilder builder = fileStoreBuilder(new File(dir, \"segmentstore\"));\n        if (blobStore != null) {\n            builder.withBlobStore(blobStore);\n        }\n        builder.withMaxFileSize(256);\n        if (disableMmap) {\n            builder.withMemoryMapping(false);\n        } else {\n            builder.withDefaultMemoryMapping();\n        }\n        final FileStore fs;\n        try {\n            fs = builder.build();\n        } catch (InvalidFileStoreVersionException e) {\n            throw new IllegalStateException(e);\n        }\n        closer.register(asCloseable(fs));\n\n        return new TarNodeStore(SegmentNodeStoreBuilders.builder(fs).build(), new TarNodeStore.SuperRootProvider() {\n            @Override\n            public void setSuperRoot(NodeBuilder builder) {\n                checkArgument(builder instanceof SegmentNodeBuilder);\n                SegmentNodeBuilder segmentBuilder = (SegmentNodeBuilder) builder;\n                SegmentNodeState lastRoot = (SegmentNodeState) getSuperRoot();\n\n                if (!lastRoot.getRecordId().equals(((SegmentNodeState) segmentBuilder.getBaseState()).getRecordId())) {\n                    throw new IllegalArgumentException(\"The new head is out of date\");\n                }\n\n                fs.getRevisions().setHead(lastRoot.getRecordId(), segmentBuilder.getNodeState().getRecordId());\n            }\n\n            @Override\n            public NodeState getSuperRoot() {\n                return fs.getHead();\n            }\n        });\n    }","commit_id":"be1f9647b7989093bf31adb0691f4d12cfebf96c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected long getPortletRenderTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer renderTimeout = portletDefinition.getRenderTimeout();\n        if (renderTimeout != null) {\n            return renderTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":79,"modified_method":"protected long getPortletRenderTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer renderTimeout = portletDefinition.getRenderTimeout();\n        if (renderTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, renderTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected long getPortletEventTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer eventTimeout = portletDefinition.getEventTimeout();\n        if (eventTimeout != null) {\n            return eventTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":80,"modified_method":"protected long getPortletEventTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer eventTimeout = portletDefinition.getEventTimeout();\n        if (eventTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, eventTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected long getPortletActionTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer actionTimeout = portletDefinition.getActionTimeout();\n        if (actionTimeout != null) {\n            return actionTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":81,"modified_method":"protected long getPortletActionTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer actionTimeout = portletDefinition.getActionTimeout();\n        if (actionTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, actionTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected long getPortletResourceTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer resourceTimeout = portletDefinition.getResourceTimeout();\n        if (resourceTimeout != null) {\n            return resourceTimeout;\n        }\n        \n        return portletDefinition.getTimeout();\n    }","id":82,"modified_method":"protected long getPortletResourceTimeout(IPortletWindowId portletWindowId, HttpServletRequest request) {\n        if (this.ignoreTimeouts) {\n            return DEBUG_TIMEOUT;\n        }\n        \n        final IPortletDefinition portletDefinition = getPortletDefinition(portletWindowId, request);\n        final Integer resourceTimeout = portletDefinition.getResourceTimeout();\n        if (resourceTimeout != null) {\n            return getModifiedTimeout(portletDefinition, request, resourceTimeout);\n        }\n        \n        return getModifiedTimeout(portletDefinition, request, portletDefinition.getTimeout());\n    }","commit_id":"22b2fd00a6b551e450b75ec1bb5a9488eea1ef52","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            applicationContext = ctx;\n            if (getBus() == null) {\n                // Don't relate on the DefaultBus\n                BusFactory factory = new SpringBusFactory(ctx);\n                Bus bus = factory.createBus();               \n                setBus(bus);\n            }\n            BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(getBus(), ctx);\n        }","id":83,"modified_method":"@SuppressWarnings(\"deprecation\")\n        public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            applicationContext = ctx;\n            if (bus == null) {\n                if (Version.getCurrentVersion().startsWith(\"2.3\")) {\n                    // Don't relate on the DefaultBus\n                    BusFactory factory = new SpringBusFactory(ctx);\n                    bus = factory.createBus();               \n                    BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                } else {\n                    bus = BusWiringBeanFactoryPostProcessor.addDefaultBus(ctx);\n                }\n            }\n        }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (getBus() == null) {\n                // Don't relate on the DefaultBus\n                BusFactory factory = new SpringBusFactory(ctx);\n                Bus bus = factory.createBus();    \n                BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                setBus(bus);\n            }\n        }","id":84,"modified_method":"@SuppressWarnings(\"deprecation\")\n        public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (bus == null) {\n                if (Version.getCurrentVersion().startsWith(\"2.3\")) {\n                    // Don't relate on the DefaultBus\n                    BusFactory factory = new SpringBusFactory(ctx);\n                    bus = factory.createBus();    \n                    BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                    setBus(bus);\n                } else {\n                    setBus(BusWiringBeanFactoryPostProcessor.addDefaultBus(ctx));\n                }\n            }\n        }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (getBus() == null) {\n                // Don't relate on the DefaultBus\n                BusFactory factory = new SpringBusFactory(ctx);\n                Bus bus = factory.createBus();  \n                BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                setBus(bus);\n            }\n        }","id":85,"modified_method":"@SuppressWarnings(\"deprecation\")\n        public void setApplicationContext(ApplicationContext ctx) throws BeansException {\n            if (bus == null) {\n                if (Version.getCurrentVersion().startsWith(\"2.3\")) {\n                    // Don't relate on the DefaultBus\n                    BusFactory factory = new SpringBusFactory(ctx);\n                    bus = factory.createBus();               \n                    setBus(bus);\n                    BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(bus, ctx);\n                } else {\n                    setBus(BusWiringBeanFactoryPostProcessor.addDefaultBus(ctx));\n                }\n            }\n        }","commit_id":"46b622678e419de689d1debd514fa3b6876816e4","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Get the around-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getAroundConstructInterceptors() {\n        return aroundConstructInterceptors.getSortedItems();\n    }","id":86,"modified_method":"/**\n     * Get the around-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getAroundConstructInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = aroundConstructInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the pre-destroy interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptor\n     */\n    public List<InterceptorFactory> getPreDestroyInterceptors() {\n        return preDestroyInterceptors.getSortedItems();\n    }","id":87,"modified_method":"/**\n     * Get the pre-destroy interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptor\n     */\n    public List<InterceptorFactory> getPreDestroyInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = preDestroyInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the post-activate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostActivateInterceptors() {\n        return postActivateInterceptors.getSortedItems();\n    }","id":88,"modified_method":"/**\n     * Get the post-activate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostActivateInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = postActivateInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the pre-passivate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPrePassivateInterceptors() {\n        return prePassivateInterceptors.getSortedItems();\n    }","id":89,"modified_method":"/**\n     * Get the pre-passivate interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPrePassivateInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = prePassivateInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Get the post-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostConstructInterceptors() {\n        return postConstructInterceptors.getSortedItems();\n    }","id":90,"modified_method":"/**\n     * Get the post-construct interceptors.\n     * <p/>\n     * This method should only be called after all interceptors have been added\n     *\n     * @return the sorted interceptors\n     */\n    public List<InterceptorFactory> getPostConstructInterceptors() {\n        List<List<InterceptorFactory>> sortedItems = postConstructInterceptors.getSortedItems();\n        List<InterceptorFactory> interceptorFactories = new ArrayList<>();\n        for(List<InterceptorFactory> i : sortedItems) {\n            interceptorFactories.addAll(i);\n        }\n        return interceptorFactories;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Gets the interceptor list for a given method. This should not be called until\n     * all interceptors have been added.\n     *\n     * @param method the component method\n     * @return the deque\n     */\n    public List<InterceptorFactory> getComponentInterceptors(Method method) {\n        Map<Method, OrderedItemContainer<InterceptorFactory>> map = componentInterceptors;\n        OrderedItemContainer<InterceptorFactory> interceptors = map.get(method);\n        if (interceptors == null) {\n            return Collections.emptyList();\n        }\n        return interceptors.getSortedItems();\n    }","id":91,"modified_method":"/**\n     * Gets the interceptor list for a given method. This should not be called until\n     * all interceptors have been added.\n     *\n     * @param method the component method\n     * @return the deque\n     */\n    public List<InterceptorFactory> getComponentInterceptors(Method method) {\n        Map<Method, OrderedItemContainer<List<InterceptorFactory>>> map = componentInterceptors;\n        OrderedItemContainer<List<InterceptorFactory>> interceptors = map.get(method);\n        if (interceptors == null) {\n            return Collections.emptyList();\n        }\n        List<List<InterceptorFactory>> sortedItems = interceptors.getSortedItems();\n        List<InterceptorFactory> ret = new ArrayList<>();\n        for(List<InterceptorFactory> item : sortedItems) {\n            ret.addAll(item);\n        }\n        return ret;\n    }","commit_id":"f7debaecc41ae1719621bb1040d2eb61cea53fa4","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\r\n   * Remove record ids from the index.\r\n   * @param ix index of the key\r\n   * @param key record key\r\n   * @param ids list of record ids to delete\r\n   * @return number of remaining records\r\n   */\r\n  private int deleteIds(final int ix, final byte[] key, final int[] ids) {\r\n    final long pos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(pos);\r\n\r\n    if(numold == ids.length) {\r\n      // all ids should be deteted: the key itself will be deleted, too\r\n      cache.delete(key);\r\n      return 0;\r\n    }\r\n\r\n    // read each id from the list and skip the ones which should be deleted\r\n    // collect remaining values\r\n    final int[] nids = new int[numold - ids.length];\r\n    for(int i = 0, j = 0, cid = 0, pid = 0; i < nids.length;) {\r\n      cid += idxl.readNum();\r\n      if(j < ids.length && ids[j] == cid) ++j;\r\n      else {\r\n        nids[i++] = cid - pid;\r\n        pid = cid;\r\n      }\r\n    }\r\n\r\n    idxl.writeNums(pos, nids);\r\n\r\n    // check if key is cached and update the cache entry\r\n    final int cacheid = cache.id(key);\r\n    if(cacheid > 0)\r\n      cache.update(cacheid, nids.length, pos + Num.length(nids.length));\r\n\r\n    return nids.length;\r\n  }","id":92,"modified_method":"/**\r\n   * Remove record ids from the index.\r\n   * @param ix index of the key\r\n   * @param key record key\r\n   * @param ids list of record ids to delete\r\n   * @return number of remaining records\r\n   */\r\n  private int deleteIds(final int ix, final byte[] key, final int[] ids) {\r\n    final long pos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(pos);\r\n\r\n    if(numold == ids.length) {\r\n      // all ids should be deteted: the key itself will be deleted, too\r\n      cache.delete(key);\r\n      return 0;\r\n    }\r\n\r\n    // read each id from the list and skip the ones which should be deleted\r\n    // collect remaining values\r\n    final int[] nids = new int[numold - ids.length];\r\n    for(int i = 0, j = 0, cid = 0, pid = 0; i < nids.length;) {\r\n      cid += idxl.readNum();\r\n      if(j < ids.length && ids[j] == cid) ++j;\r\n      else {\r\n        nids[i++] = cid - pid;\r\n        pid = cid;\r\n      }\r\n    }\r\n\r\n    idxl.writeNums(pos, nids);\r\n\r\n    // update the cache entry\r\n    cache.add(key, nids.length, pos + Num.length(nids.length));\r\n\r\n    return nids.length;\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Add a text entry to the index.\r\n   * @param key text to index\r\n   * @param id id value\r\n   */\r\n  private void insertId(final byte[] key, final int id) {\r\n    int ix = get(key);\r\n    if(ix < 0) {\r\n      ix = -(ix + 1);\r\n\r\n      // shift all entries with bigger keys to the right\r\n      for(int i = size; i > ix; --i)\r\n        idxr.write5(i * 5L, idxr.read5((i - 1) * 5L));\r\n\r\n      // add the key and the id\r\n      idxr.write5(ix * 5L, idxl.appendNums(new int[] { id}));\r\n      ctext.add(ix, key);\r\n      // [DP] should the entry be added to the cache?\r\n\r\n      ++size;\r\n    } else {\r\n      // add id to the list of ids in the index node\r\n      final long pos = idxr.read5(ix * 5L);\r\n      final int num = idxl.readNum(pos);\r\n\r\n      final int[] ids = new int[num + 1];\r\n      boolean notadded = true;\r\n      int cid = 0;\r\n      for(int i = 0, j = -1; i < num; ++i) {\r\n        int v = idxl.readNum();\r\n\r\n        if(notadded && id < cid + v) {\r\n          // add the new id\r\n          ids[++j] = id - cid;\r\n          notadded = false;\r\n          // decrement the difference to the next id\r\n          v -= id - cid;\r\n          cid = id;\r\n        }\r\n\r\n        ids[++j] = v;\r\n        cid += v;\r\n      }\r\n\r\n      if(notadded) ids[ids.length - 1] = id - cid;\r\n\r\n      final long newpos = idxl.appendNums(ids);\r\n      idxr.write5(ix * 5L, newpos);\r\n\r\n      // check if key is cached and update the cache entry\r\n      final int cacheid = cache.id(key);\r\n      if(cacheid > 0)\r\n        cache.update(cacheid, ids.length, newpos + Num.length(ids.length));\r\n    }\r\n  }","id":93,"modified_method":"/**\r\n   * Add a text entry to the index.\r\n   * @param key text to index\r\n   * @param id id value\r\n   */\r\n  private void insertId(final byte[] key, final int id) {\r\n    int ix = get(key);\r\n    if(ix < 0) {\r\n      ix = -(ix + 1);\r\n\r\n      // shift all entries with bigger keys to the right\r\n      for(int i = size; i > ix; --i)\r\n        idxr.write5(i * 5L, idxr.read5((i - 1) * 5L));\r\n\r\n      // add the key and the id\r\n      idxr.write5(ix * 5L, idxl.appendNums(new int[] { id}));\r\n      ctext.add(ix, key);\r\n      // [DP] should the entry be added to the cache?\r\n\r\n      ++size;\r\n    } else {\r\n      // add id to the list of ids in the index node\r\n      final long pos = idxr.read5(ix * 5L);\r\n      final int num = idxl.readNum(pos);\r\n\r\n      final int[] ids = new int[num + 1];\r\n      boolean notadded = true;\r\n      int cid = 0;\r\n      for(int i = 0, j = -1; i < num; ++i) {\r\n        int v = idxl.readNum();\r\n\r\n        if(notadded && id < cid + v) {\r\n          // add the new id\r\n          ids[++j] = id - cid;\r\n          notadded = false;\r\n          // decrement the difference to the next id\r\n          v -= id - cid;\r\n          cid = id;\r\n        }\r\n\r\n        ids[++j] = v;\r\n        cid += v;\r\n      }\r\n\r\n      if(notadded) ids[ids.length - 1] = id - cid;\r\n\r\n      final long newpos = idxl.appendNums(ids);\r\n      idxr.write5(ix * 5L, newpos);\r\n\r\n      // update the cache entry\r\n      cache.add(key, ids.length, newpos + Num.length(ids.length));\r\n    }\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Add record ids to an index entry.\r\n   * @param ix index of the key\r\n   * @param key key\r\n   * @param nids sorted list of record ids to add: the first value is the\r\n   * smallest id and all others are only difference to the previous one\r\n   */\r\n  private void appendIds(final int ix, final byte[] key, final int[] nids) {\r\n    final long oldpos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(oldpos);\r\n    final int[] ids = new int[numold + nids.length];\r\n\r\n    // read the old ids\r\n    for(int i = 0; i < numold; ++i) {\r\n      final int v = idxl.readNum();\r\n      nids[0] -= v; // adjust the first new id\r\n      ids[i] = v;\r\n    }\r\n\r\n    // append the new ids - they are bigger than the old ones\r\n    System.arraycopy(nids, 0, ids, numold, nids.length);\r\n\r\n    final long newpos = idxl.appendNums(ids);\r\n    idxr.write5(ix * 5L, newpos);\r\n\r\n    // check if key is cached and update the cache entry\r\n    final int cacheid = cache.id(key);\r\n    if(cacheid > 0)\r\n      cache.update(cacheid, ids.length, newpos + Num.length(ids.length));\r\n  }","id":94,"modified_method":"/**\r\n   * Add record ids to an index entry.\r\n   * @param ix index of the key\r\n   * @param key key\r\n   * @param nids sorted list of record ids to add: the first value is the\r\n   * smallest id and all others are only difference to the previous one\r\n   */\r\n  private void appendIds(final int ix, final byte[] key, final int[] nids) {\r\n    final long oldpos = idxr.read5(ix * 5L);\r\n    final int numold = idxl.readNum(oldpos);\r\n    final int[] ids = new int[numold + nids.length];\r\n\r\n    // read the old ids\r\n    for(int i = 0; i < numold; ++i) {\r\n      final int v = idxl.readNum();\r\n      nids[0] -= v; // adjust the first new id\r\n      ids[i] = v;\r\n    }\r\n\r\n    // append the new ids - they are bigger than the old ones\r\n    System.arraycopy(nids, 0, ids, numold, nids.length);\r\n\r\n    final long newpos = idxl.appendNums(ids);\r\n    idxr.write5(ix * 5L, newpos);\r\n\r\n    // update the cache entry\r\n    cache.add(key, ids.length, newpos + Num.length(ids.length));\r\n  }","commit_id":"bcaa9e49833de8c3f2e066b5a82404025576d136","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * @see org.opencms.workplace.editor.I_CmsEditorActionHandler#getEditMode(org.opencms.file.CmsObject, java.lang.String, java.lang.String, javax.servlet.ServletRequest)\n     */\n    public String getEditMode(CmsObject cmsObject, String filename, String element, ServletRequest req) {\n    \n        try {\n            \n            CmsResource resource = cmsObject.readFileHeader(filename, CmsResourceFilter.ALL);\n            int currentProject = cmsObject.getRequestContext().currentProject().getId();\n            CmsUUID userId = cmsObject.getRequestContext().currentUser().getId();\n            CmsLock lock = cmsObject.getLock(filename);\n            boolean locked = !(lock.isNullLock() || (lock.getUserId().equals(userId) && lock.getProjectId() == currentProject));\n        \n            if (currentProject == I_CmsConstants.C_PROJECT_ONLINE_ID) {\n                // don't render direct edit button in online project\n                return null;\n            } else if (!cmsObject.getResourceType(resource.getType()).isDirectEditable()) {\n                // don't render direct edit button for non-editable resources \n                return null;\n            } else if (CmsResource.getName(filename).startsWith(org.opencms.main.I_CmsConstants.C_TEMP_PREFIX)) {\n                // don't show direct edit button on temporary file\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.isInsideCurrentProject(resource)) {\n                // don't show direct edit button on files not belonging to the current project\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.hasPermissions(resource, new CmsPermissionSet(I_CmsConstants.C_PERMISSION_WRITE))) {\n                // don't show direct edit button on files without write permissions\n                if (locked) {\n                    return C_DIRECT_EDIT_MODE_DISABLED;\n                } else {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }\n            } else if (locked) {\n                return C_DIRECT_EDIT_MODE_DISABLED;\n            }\n              \n            if ((element != null) && (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID)) {\n                // check if the desired element is available (in case of xml page)\n                CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n                if (page == null) {\n                    // make sure a page is only read once (not every time for each element)\n                    page = CmsXmlPage.read(cmsObject, cmsObject.readFile(filename));\n                    req.setAttribute(filename, page);\n                }    \n                Locale locale = OpenCms.getLocaleManager().getBestMatchingLocale(null, OpenCms.getLocaleManager().getDefaultLocales(cmsObject, filename), page.getLocales());\n                if (!page.hasElement(element, locale) || !page.isEnabled(element, locale)) {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }                \n            }\n\n            // otherwise the resource is editable\n            return C_DIRECT_EDIT_MODE_ENABLED;\n            \n        }  catch (CmsException e) {\n            if (OpenCms.getLog(this).isWarnEnabled()) {\n                OpenCms.getLog(this).warn(\"Error while calculation edit mode for \" + filename, e);\n            }\n            // something went wrong - so the resource seems not to be editable\n            return C_DIRECT_EDIT_MODE_INACTIVE;\n        }\n    }","id":95,"modified_method":"/**\n     * @see org.opencms.workplace.editor.I_CmsEditorActionHandler#getEditMode(org.opencms.file.CmsObject, java.lang.String, java.lang.String, javax.servlet.ServletRequest)\n     */\n    public String getEditMode(CmsObject cmsObject, String filename, String element, ServletRequest req) {\n    \n        try {\n            \n            CmsResource resource = cmsObject.readFileHeader(filename, CmsResourceFilter.ALL);\n            int currentProject = cmsObject.getRequestContext().currentProject().getId();\n            CmsUUID userId = cmsObject.getRequestContext().currentUser().getId();\n            CmsLock lock = cmsObject.getLock(filename);\n            boolean locked = !(lock.isNullLock() || (lock.getUserId().equals(userId) && lock.getProjectId() == currentProject));\n        \n            if (currentProject == I_CmsConstants.C_PROJECT_ONLINE_ID) {\n                // don't render direct edit button in online project\n                return null;\n            } else if (!cmsObject.getResourceType(resource.getType()).isDirectEditable()) {\n                // don't render direct edit button for non-editable resources \n                return null;\n            } else if (CmsResource.getName(filename).startsWith(org.opencms.main.I_CmsConstants.C_TEMP_PREFIX)) {\n                // don't show direct edit button on temporary file\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.isInsideCurrentProject(resource)) {\n                // don't show direct edit button on files not belonging to the current project\n                return C_DIRECT_EDIT_MODE_INACTIVE;\n            } else if (!cmsObject.hasPermissions(resource, new CmsPermissionSet(I_CmsConstants.C_PERMISSION_WRITE))) {\n                // don't show direct edit button on files without write permissions\n                if (locked) {\n                    return C_DIRECT_EDIT_MODE_DISABLED;\n                } else {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }\n            } else if (locked) {\n                return C_DIRECT_EDIT_MODE_DISABLED;\n            }\n              \n            if ((element != null) && (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID)) {\n                // check if the desired element is available (in case of xml page)\n                CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n                if (page == null) {\n                    // make sure a page is only read once (not every time for each element)\n                    page = CmsXmlPage.read(cmsObject, cmsObject.readFile(filename));\n                    req.setAttribute(filename, page);\n                }\n                List locales = page.getLocales();\n                Locale locale;\n                if ((locales == null) || (locales.size() == 0)) {\n                    locale = (Locale)OpenCms.getLocaleManager().getDefaultLocales(cmsObject, filename).get(0);                    \n                } else { \n                    locale = OpenCms.getLocaleManager().getBestMatchingLocale(null, OpenCms.getLocaleManager().getDefaultLocales(cmsObject, filename), locales);\n                }\n                if (!page.hasElement(element, locale) || !page.isEnabled(element, locale)) {\n                    return C_DIRECT_EDIT_MODE_INACTIVE;\n                }                \n            }\n\n            // otherwise the resource is editable\n            return C_DIRECT_EDIT_MODE_ENABLED;\n            \n        }  catch (CmsException e) {\n            if (OpenCms.getLog(this).isWarnEnabled()) {\n                OpenCms.getLog(this).warn(\"Error while calculation edit mode for \" + filename, e);\n            }\n            // something went wrong - so the resource seems not to be editable\n            return C_DIRECT_EDIT_MODE_INACTIVE;\n        }\n    }","commit_id":"6606adb1e2cd6397451e8e8dc4f9fb00d841c3a1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.loader.I_CmsResourceLoader#service(org.opencms.file.CmsObject, org.opencms.file.CmsResource, javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     */\n    public void service(CmsObject cms, CmsResource resource, ServletRequest req, ServletResponse res) \n    throws IOException, CmsException {\n        \n        // get the absolute path of the resource\n        String absolutePath = cms.readAbsolutePath(resource);\n        \n        // get the requested page\n        CmsXmlPage page = (CmsXmlPage)req.getAttribute(absolutePath);\n            \n        if (page == null) {      \n            // make sure a page is only read once (not every time for each element)\n            page = CmsXmlPage.read(cms, CmsFile.upgrade(resource, cms));\n            req.setAttribute(absolutePath, page);\n        }        \n        \n        // get the element selector\n        String elementName = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);\n        \n        // check the current locales\n        Locale locale = OpenCms.getLocaleManager().getBestMatchingLocale(cms.getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(cms, absolutePath), page.getLocales(elementName));\n        \n        // get the appropriate content and convert it to bytes\n        byte[] result = page.getContent(cms, elementName, locale).getBytes(page.getEncoding()); \n        \n        // append the result to the output stream\n        if (result != null) {\n            res.getOutputStream().write(result);\n        }        \n    }","id":96,"modified_method":"/**\n     * @see org.opencms.loader.I_CmsResourceLoader#service(org.opencms.file.CmsObject, org.opencms.file.CmsResource, javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n     */\n    public void service(CmsObject cms, CmsResource resource, ServletRequest req, ServletResponse res) \n    throws IOException, CmsException {\n        \n        // get the absolute path of the resource\n        String absolutePath = cms.readAbsolutePath(resource);\n        \n        // get the requested page\n        CmsXmlPage page = (CmsXmlPage)req.getAttribute(absolutePath);\n            \n        if (page == null) {      \n            // make sure a page is only read once (not every time for each element)\n            page = CmsXmlPage.read(cms, CmsFile.upgrade(resource, cms));\n            req.setAttribute(absolutePath, page);\n        }        \n        \n        // get the element selector\n        String elementName = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);\n        \n        // check the current locales\n        List locales = page.getLocales(elementName);\n        Locale locale;\n        if ((locales == null) || (locales.size() == 0)) {\n            // no content for the selected element is available\n            return;                    \n        } else { \n            locale = OpenCms.getLocaleManager().getBestMatchingLocale(cms.getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(cms, absolutePath), locales);\n        }        \n        \n        // get the appropriate content and convert it to bytes\n        byte[] result = page.getContent(cms, elementName, locale).getBytes(page.getEncoding()); \n        \n        // append the result to the output stream\n        if (result != null) {\n            res.getOutputStream().write(result);\n        }        \n    }","commit_id":"6606adb1e2cd6397451e8e8dc4f9fb00d841c3a1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Internal action method.<p>\n     * \n     * @param element the selected element\n     * @param elementlist list the list of elements to check\n     * @param checkall flag to indicate that all elements should be checked\n     * @param checknone flag to indicate that the check is done for nonexisting elements\n     * @param req the current request \n     * @return boolean <code>true<\/code> if this element should be inclued, <code>false<\/code>\n     * otherwise\n     */    \n    public static boolean templateTagAction(String element, String elementlist, boolean checkall, boolean checknone, ServletRequest req) {\n\n        if (elementlist != null) {\n            \n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            String filename = controller.getCmsObject().getRequestContext().getUri();\n            \n            CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n            if (page == null) {\n                CmsResource resource = controller.getCmsResource();\n                if (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID) {\n                    try {\n                        // make sure a page is only read once (not every time for each element)\n                        page = CmsXmlPage.unmarshal(controller.getCmsObject(), CmsFile.upgrade(resource, controller.getCmsObject()));\n                        req.setAttribute(filename, page);                \n                    } catch (CmsException e) {\n                        OpenCms.getLog(CmsJspTagTemplate.class).error(\"Error checking for XML page\", e);\n                    }\n                }    \n            }    \n            \n            if (page != null) {\n                String absolutePath = controller.getCmsObject().readAbsolutePath(page.getFile());\n                Locale locale = OpenCms.getLocaleManager().getBestMatchingLocale(controller.getCmsObject().getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(controller.getCmsObject(), absolutePath), page.getLocales());\n                \n                // check the elements in the elementlist, if the check fails don't render the body\n                String elements[] = CmsStringSubstitution.split(elementlist, \",\");\n                boolean found = false;\n                for (int i = 0; i < elements.length; i++) {\n                    String el = elements[i].trim();\n                    if (page.hasElement(el, locale) && page.isEnabled(el, locale)) {\n                        found = true;\n                        if (!checkall) {\n                            // found at least an element that is available\n                            break;\n                        }\n                    } else {\n                        if (checkall) {\n                            // found at least an element that is not available\n                            return false;\n                        }\n                    }\n                }\n                \n                if (!found && !checknone) {\n                    // no element found while checking for existing elements\n                    return false;\n                } else if (found && checknone) {\n                    // element found while checking for nonexisting elements\n                    return false;\n                }\n            } \n        }\n        \n        // otherwise, check if an element was defined and if its equal to the desired element\n        String param = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);        \n        return ((element ==  null) || (param == null) || (param.equals(element)));\n    }","id":97,"modified_method":"/**\n     * Internal action method.<p>\n     * \n     * @param element the selected element\n     * @param elementlist list the list of elements to check\n     * @param checkall flag to indicate that all elements should be checked\n     * @param checknone flag to indicate that the check is done for nonexisting elements\n     * @param req the current request \n     * @return boolean <code>true<\/code> if this element should be inclued, <code>false<\/code>\n     * otherwise\n     */    \n    public static boolean templateTagAction(String element, String elementlist, boolean checkall, boolean checknone, ServletRequest req) {\n\n        if (elementlist != null) {\n            \n            CmsFlexController controller = (CmsFlexController)req.getAttribute(CmsFlexController.ATTRIBUTE_NAME);\n            String filename = controller.getCmsObject().getRequestContext().getUri();\n            \n            CmsXmlPage page = (CmsXmlPage)req.getAttribute(filename);                    \n            if (page == null) {\n                CmsResource resource = controller.getCmsResource();\n                if (resource.getType() == CmsResourceTypeXmlPage.C_RESOURCE_TYPE_ID) {\n                    try {\n                        // make sure a page is only read once (not every time for each element)\n                        page = CmsXmlPage.unmarshal(controller.getCmsObject(), CmsFile.upgrade(resource, controller.getCmsObject()));\n                        req.setAttribute(filename, page);                \n                    } catch (CmsException e) {\n                        OpenCms.getLog(CmsJspTagTemplate.class).error(\"Error checking for XML page\", e);\n                    }\n                }    \n            }    \n            \n            if (page != null) {\n                String absolutePath = controller.getCmsObject().readAbsolutePath(page.getFile());\n                // check the elements in the elementlist, if the check fails don't render the body\n                String elements[] = CmsStringSubstitution.split(elementlist, \",\");\n                boolean found = false;\n                for (int i = 0; i < elements.length; i++) {                    \n                    String el = elements[i].trim();\n                    List locales = page.getLocales(el);\n                    Locale locale = null;\n                    if ((locales != null) && (locales.size() != 0)) {\n                        locale = OpenCms.getLocaleManager().getBestMatchingLocale(controller.getCmsObject().getRequestContext().getLocale(), OpenCms.getLocaleManager().getDefaultLocales(controller.getCmsObject(), absolutePath), locales);\n                    }                     \n                    if ((locale != null) && page.hasElement(el, locale) && page.isEnabled(el, locale)) {\n                        \n                        found = true;\n                        if (!checkall) {\n                            // found at least an element that is available\n                            break;\n                        }\n                    } else {\n                        if (checkall) {\n                            // found at least an element that is not available\n                            return false;\n                        }\n                    }\n                }\n                \n                if (!found && !checknone) {\n                    // no element found while checking for existing elements\n                    return false;\n                } else if (found && checknone) {\n                    // element found while checking for nonexisting elements\n                    return false;\n                }\n            } \n        }\n        \n        // otherwise, check if an element was defined and if its equal to the desired element\n        String param = req.getParameter(I_CmsConstants.C_PARAMETER_ELEMENT);        \n        return ((element ==  null) || (param == null) || (param.equals(element)));\n    }","commit_id":"5a052c95c2f32800175f5ca59bfa74abd002fd1a","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public static HashMap getProfile(yacySeed targetSeed) {\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // this post a message to the remote message board\r\n        final serverObjects post = new serverObjects(2);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        String address = targetSeed.getAddress();\r\n        if (address == null) { address = \"localhost:8080\"; }\r\n        try {\r\n            final ArrayList v = httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/profile.html\"), \r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    10000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n            );\r\n            \r\n            return nxTools.table(v);\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.getProfile error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":98,"modified_method":"public static HashMap getProfile(yacySeed targetSeed) {\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // this post a message to the remote message board\r\n        final serverObjects post = new serverObjects(2);\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"youare\", targetSeed.hash);\r\n        String address = targetSeed.getAddress();\r\n        if (address == null) { address = \"localhost:8080\"; }\r\n        try {\r\n            return nxTools.table(\r\n                httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/profile.html\"), \r\n                    targetSeed.getHexHash() + \".yacyh\",\r\n                    10000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n                ), \"UTF-8\");\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.getProfile error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap postMessage(String targetHash, String subject, byte[] message) {\r\n        // this post a message to the remote message board\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n            post.put(\"key\", key);\r\n            post.put(\"process\", \"post\");\r\n            post.put(\"myseed\", yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            post.put(\"youare\", targetHash);\r\n            post.put(\"subject\", subject);\r\n            post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            try {\r\n                post.put(\"message\", new String(message, \"UTF-8\"));\r\n            } catch (UnsupportedEncodingException e) {\r\n                post.put(\"message\", new String(message));\r\n            }\r\n        // get target address    \r\n        String address = targetAddress(targetHash);\r\n        \r\n        // sending request\r\n        try {\r\n            final ArrayList v = httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/message.html\"),\r\n                    yacySeed.b64Hash2hexHash(targetHash) + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n            );\r\n\r\n            return nxTools.table(v);\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":99,"modified_method":"public static HashMap postMessage(String targetHash, String subject, byte[] message) {\r\n        // this post a message to the remote message board\r\n        \r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n            post.put(\"key\", key);\r\n            post.put(\"process\", \"post\");\r\n            post.put(\"myseed\", yacyCore.seedDB.mySeed.genSeedStr(key));\r\n            post.put(\"youare\", targetHash);\r\n            post.put(\"subject\", subject);\r\n            post.put(yacySeed.MYTIME, yacyCore.universalDateShortString(new Date()));\r\n            try {\r\n                post.put(\"message\", new String(message, \"UTF-8\"));\r\n            } catch (UnsupportedEncodingException e) {\r\n                post.put(\"message\", new String(message));\r\n            }\r\n        // get target address    \r\n        String address = targetAddress(targetHash);\r\n        \r\n        // sending request\r\n        try {\r\n            return nxTools.table(\r\n                httpc.wput(\r\n                    new URL(\"http://\" + address + \"/yacy/message.html\"),\r\n                    yacySeed.b64Hash2hexHash(targetHash) + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    null\r\n               ), \"UTF-8\");\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static HashMap transferStore(String targetAddress, String access, String filename, byte[] file) {\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB != null) &&\r\n                           (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"store\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"purpose\", \"crcon\");\r\n        post.put(\"filename\", filename);\r\n        post.put(\"filesize\", Long.toString(file.length));\r\n        post.put(\"md5\", serverCodings.encodeMD5Hex(file));\r\n        post.put(\"access\", access);\r\n        HashMap files = new HashMap();\r\n        files.put(\"filename\", file);\r\n        \r\n        // sending request\r\n        try {\r\n            final URL url = new URL(\"http://\" + targetAddress + \"/yacy/transfer.html\");\r\n            final ArrayList v = httpc.wput(\r\n                    url,\r\n                    url.getHost(), // yacyCore.seedDB.mySeed.getHexHash() + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    files\r\n            );\r\n\r\n            return nxTools.table(v);\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","id":100,"modified_method":"public static HashMap transferStore(String targetAddress, String access, String filename, byte[] file) {\r\n        // should we use the proxy?\r\n        boolean useProxy = (yacyCore.seedDB != null) &&\r\n                           (yacyCore.seedDB.sb.remoteProxyConfig != null) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy()) && \r\n                           (yacyCore.seedDB.sb.remoteProxyConfig.useProxy4Yacy());\r\n        \r\n        // adding all needed parameters\r\n        final String key = crypt.randomSalt();\r\n        final serverObjects post = new serverObjects(7);\r\n        post.put(\"key\", key);\r\n        post.put(\"process\", \"store\");\r\n        post.put(\"iam\", yacyCore.seedDB.mySeed.hash);\r\n        post.put(\"purpose\", \"crcon\");\r\n        post.put(\"filename\", filename);\r\n        post.put(\"filesize\", Long.toString(file.length));\r\n        post.put(\"md5\", serverCodings.encodeMD5Hex(file));\r\n        post.put(\"access\", access);\r\n        HashMap files = new HashMap();\r\n        files.put(\"filename\", file);\r\n        \r\n        // sending request\r\n        try {\r\n            final URL url = new URL(\"http://\" + targetAddress + \"/yacy/transfer.html\");\r\n            return nxTools.table(\r\n                httpc.wput(\r\n                    url,\r\n                    url.getHost(), // yacyCore.seedDB.mySeed.getHexHash() + \".yacyh\",\r\n                    20000, \r\n                    null, \r\n                    null,\r\n                    (useProxy)?yacyCore.seedDB.sb.remoteProxyConfig:null, \r\n                    post,\r\n                    files\r\n                ), \"UTF-8\");\r\n        } catch (Exception e) {\r\n            yacyCore.log.logSevere(\"yacyClient.postMessage error:\" + e.getMessage());\r\n            return null;\r\n        }\r\n    }","commit_id":"fb7902aa68a14ae248136d7c09495abaa47ec946","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":101,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"70c558093074ab5f6632357ce22a9a4b38a37917","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":102,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"cf7ebe39393a8884218f416346a56d39d434abb7","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":103,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"bc366978f6a44d3fd6f53106b9f1a3707247aeb9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Integer start(String[] args) {\n        \n        try {\n            this.configurator = new Configurator(new Validator(new DatabaseLocationMustBeSpecifiedRule()), getConfigFile());\n            webServerPort = configurator.configuration().getInt(WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT);\n\n            this.database = new Database(configurator.configuration().getString(DATABASE_LOCATION_PROPERTY_KEY));\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info(\"Starting Neo Server on port [%s]\", webServerPort);\n            webServer.setPort(webServerPort);\n\n            log.info(\"Mounting webadmin at [%s]\", WEB_ADMIN_PATH);\n            webServer.addStaticContent(STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH);\n\n            log.info(\"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME);\n            webServer.addJAXRSPackages(listFrom(new String[] { WEB_ADMIN_REST_API_PACKAGE }), WEB_ADMIN_REST_API_SERVICE_NAME);\n\n            log.info(\"Mounting REST API at [%s]\", REST_API_SERVICE_NAME);            \n            webServer.addJAXRSPackages(listFrom(new String[] { REST_API_PACKAGE }), REST_API_SERVICE_NAME);\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container\n            String bundleDirectory = configurator.configuration().getString( OSGi_BUNDLE_DIR, \"../\" );\n            OSGiContainer container = new OSGiContainer( bundleDirectory );\n            container.startContainer();\n            \n            webServer.start();\n            \n            log.info(\"Started Neo Server on port [%s]\", restApiUri().getPort());\n            \n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.error(\"Failed to start Neo Server on port [%s]\", webServerPort);\n            e.printStackTrace();\n            return 1;\n        }\n    }","id":104,"modified_method":"public Integer start( String[] args )\n    {\n\n        try\n        {\n            this.configurator = new Configurator( new Validator( new DatabaseLocationMustBeSpecifiedRule() ), getConfigFile() );\n            webServerPort = configurator.configuration().getInt( WEBSERVER_PORT_PROPERTY_KEY, DEFAULT_WEBSERVER_PORT );\n\n            this.database = new Database( configurator.configuration().getString( DATABASE_LOCATION_PROPERTY_KEY ) );\n\n            this.webServer = new Jetty6WebServer( database );\n\n            log.info( \"Starting Neo Server on port [%s]\", webServerPort );\n            webServer.setPort( webServerPort );\n\n            log.info( \"Mounting webadmin at [%s]\", WEB_ADMIN_PATH );\n            webServer.addStaticContent( STATIC_CONTENT_LOCATION, WEB_ADMIN_PATH );\n\n            log.info( \"Mounting management API at [%s]\", WEB_ADMIN_REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{WEB_ADMIN_REST_API_PACKAGE} ), WEB_ADMIN_REST_API_SERVICE_NAME );\n\n            log.info( \"Mounting REST API at [%s]\", REST_API_SERVICE_NAME );\n            webServer.addJAXRSPackages( listFrom( new String[]{REST_API_PACKAGE} ), REST_API_SERVICE_NAME );\n\n            //Temporary coffee shop\n            //webServer.addJAXRSPackages(listFrom(new String[] {\"org.example.coffeeshop\"}), \"/\");\n\n            // Start embedded OSGi container, maybe\n            boolean osgiServerShouldStart = configurator.configuration().getBoolean( ENABLE_OSGI_SERVER_PROPERTY_KEY, false );\n            if ( osgiServerShouldStart )\n            {\n                String bundleDirectory = configurator.configuration().getString( OSGI_BUNDLE_DIR_PROPERTY_KEY, \"../\" );\n                OSGiContainer container = new OSGiContainer( bundleDirectory );\n                container.startContainer();\n            }\n\n            webServer.start();\n\n            log.info( \"Started Neo Server on port [%s]\", restApiUri().getPort() );\n\n            return null; // This is for the service wrapper, and though it looks weird, it's correct\n        } catch ( Exception e )\n        {\n            e.printStackTrace();\n            log.error( \"Failed to start Neo Server on port [%s]\", webServerPort );\n            e.printStackTrace();\n            return 1;\n        }\n    }","commit_id":"a471b9c863c6599a7a4e91a89dec35969cd308bb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":105,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":106,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"7f12ff825aed2b72a29fc56ddd2a12826b0a3c40","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":107,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":108,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"25a5e23d733b213a7884977d08d78ed03e77eaf3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":109,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = LIST_TYPE.getPlainNodeReference();\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes()!=null) {\n                    GenericsType clazzGT = receiver.getGenericsTypes()[0];\n                    receivers.add(clazzGT.getType());\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":110,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        if (mn.size()==1) typeCheckMethodsWithGenerics(currentReceiver, args, mn.get(0), call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"a972f869be7eaeca8e214844d0492fd1d5e3bb82","url":"https://github.com/apache/groovy"},{"original_method":"public ThreadLocalProxy getContextSetterProxy(Method m) {\n        return setterProxyMap == null ? null : setterProxyMap.get(m);\n    }","id":111,"modified_method":"public ThreadLocalProxy getContextSetterProxy(Method m) {\n        return getProxy(setterProxyMap, m);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"public ThreadLocalProxy getResourceFieldProxy(Field f) {\n        return resourceProxyMap == null ? null\n               : resourceProxyMap.get(f);\n    }","id":112,"modified_method":"public ThreadLocalProxy getResourceFieldProxy(Field f) {\n        return getProxy(resourceProxyMap, f);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"public ThreadLocalProxy getContextFieldProxy(Field f) {\n        return fieldProxyMap == null ? null\n               : fieldProxyMap.get(f);\n    }","id":113,"modified_method":"public ThreadLocalProxy getContextFieldProxy(Field f) {\n        return getProxy(fieldProxyMap, f);\n    }","commit_id":"4532786a75cb019ac856484e05c0cb494171b5b6","url":"https://github.com/apache/cxf"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    String projectFile = SamplesExtractor.getInstance().getSamplesPath() + File.separator + \"complexLanguage\" + File.separator + \"Complex.mpr\";\n    if (!new File(projectFile).exists()) {\n      SamplesExtractor.getInstance().extractSamples();\n    }\n    ProjectUtil.openProject(projectFile, e.getData(PlatformDataKeys.PROJECT), false);\n  }","id":114,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    String projectFile = SamplesExtractor.getInstance().getSamplesPath() + File.separator + \"complexLanguage\" + File.separator + \"Complex.mpr\";\n    if (!new File(projectFile).exists()) {\n      SamplesExtractor.getInstance().extractSamples();\n    }\n    Project project = ProjectUtil.openProject(projectFile, e.getData(PlatformDataKeys.PROJECT), false);\n    if (project != null) {\n      ProjectBaseDirectory.getInstance(project).setBaseDir(project.getBaseDir());\n    }\n  }","commit_id":"bf26b90c6bc21a9eac64109a17928a111272adbb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    TreeFileChooser chooser = new TreeFileChooser();\n\n    chooser.setFileFilter(new IFileFilter() {\n      public boolean accept(IFile file) {\n        return file.isDirectory() || file.getName().toLowerCase().endsWith(MPSExtentions.DOT_MPS_PROJECT);\n      }\n    });\n\n    IFile file = chooser.showDialog((Frame) null);\n    if (file == null) {\n      return;\n    }\n\n    String filePath = file.getPath();\n\n    ProjectUtil.openProject(filePath, e.getData(PlatformDataKeys.PROJECT), false);\n  }","id":115,"modified_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    TreeFileChooser chooser = new TreeFileChooser();\n\n    chooser.setFileFilter(new IFileFilter() {\n      public boolean accept(IFile file) {\n        return file.isDirectory() || file.getName().toLowerCase().endsWith(MPSExtentions.DOT_MPS_PROJECT);\n      }\n    });\n\n    IFile file = chooser.showDialog((Frame) null);\n    if (file == null) {\n      return;\n    }\n\n    String filePath = file.getPath();\n\n    Project project = ProjectUtil.openProject(filePath, e.getData(PlatformDataKeys.PROJECT), false);\n    if (project != null) {\n      ProjectBaseDirectory.getInstance(project).setBaseDir(project.getBaseDir());\n    }\n  }","commit_id":"bf26b90c6bc21a9eac64109a17928a111272adbb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    String projectFile = SamplesExtractor.getInstance().getSamplesPath() + File.separator + \"theSimplestLanguage\" + File.separator + \"theSimplestLanguage.mpr\";\n    if (!new File(projectFile).exists()) {\n      SamplesExtractor.getInstance().extractSamples();\n    }\n    ProjectUtil.openProject(projectFile, e.getData(PlatformDataKeys.PROJECT), false);\n  }","id":116,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    String projectFile = SamplesExtractor.getInstance().getSamplesPath() + File.separator + \"theSimplestLanguage\" + File.separator + \"theSimplestLanguage.mpr\";\n    if (!new File(projectFile).exists()) {\n      SamplesExtractor.getInstance().extractSamples();\n    }\n    Project project = ProjectUtil.openProject(projectFile, e.getData(PlatformDataKeys.PROJECT), false);\n    if (project != null) {\n      ProjectBaseDirectory.getInstance(project).setBaseDir(project.getBaseDir());\n    }\n  }","commit_id":"bf26b90c6bc21a9eac64109a17928a111272adbb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean processCheckedOutDirectory(Project project, File directory) {\n    File[] files = directory.listFiles(new FilenameFilter() {\n      public boolean accept(File dir, String name) {\n        return name.endsWith(MPSExtentions.DOT_MPS_PROJECT);\n      }\n    });\n    if (files != null && files.length > 0) {\n      int rc = Messages.showYesNoDialog(project, \"You have checked out an MPS project file:\\n\" + files[0].getAbsolutePath() + \"\\nWould you like to open it?\", \"Checkout from Version Control\", Messages.getQuestionIcon());\n      if (rc == 0) {\n        ProjectUtil.openProject(files[0].getAbsolutePath(), project, false);\n      }\n      return true;\n    }\n    return false;\n  }","id":117,"modified_method":"public boolean processCheckedOutDirectory(Project project, File directory) {\n    File[] files = directory.listFiles(new FilenameFilter() {\n      public boolean accept(File dir, String name) {\n        return name.endsWith(MPSExtentions.DOT_MPS_PROJECT);\n      }\n    });\n    if (files != null && files.length > 0) {\n      int rc = Messages.showYesNoDialog(project, \"You have checked out an MPS project file:\\n\" + files[0].getAbsolutePath() + \"\\nWould you like to open it?\", \"Checkout from Version Control\", Messages.getQuestionIcon());\n      if (rc == 0) {\n        Project openedProject = ProjectUtil.openProject(files[0].getAbsolutePath(), project, false);\n        if (openedProject != null) {\n          ProjectBaseDirectory.getInstance(openedProject).setBaseDir(openedProject.getBaseDir());\n        }\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"bf26b90c6bc21a9eac64109a17928a111272adbb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                value = stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n            }\n        }","id":118,"modified_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n\n                value = isDeleted() ? ByteBufferUtil.hexToBytes((String) fields.get(1))\n                                    : stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n            }\n        }","commit_id":"84de35d2d7a06875937086655e364633a849e9d1","url":"https://github.com/apache/cassandra"},{"original_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                value = stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n            }\n        }","id":119,"modified_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n\n                value = isDeleted() ? ByteBufferUtil.hexToBytes((String) fields.get(1))\n                                    : stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n            }\n        }","commit_id":"e2fe59d7b614141f3b63e7d46bcc0b305ea9c920","url":"https://github.com/apache/cassandra"},{"original_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                value = stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n            }\n        }","id":120,"modified_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n\n                value = isDeleted() ? ByteBufferUtil.hexToBytes((String) fields.get(1))\n                                    : stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n            }\n        }","commit_id":"bc281a7fa0abb665bd5675dc449d53440239e91f","url":"https://github.com/apache/cassandra"},{"original_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                value = stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n            }\n        }","id":121,"modified_method":"public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)\n        {\n            AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;\n\n            if (json instanceof List)\n            {\n                List fields = (List<?>) json;\n\n                assert fields.size() >= 3 : \"Column definition should have at least 3\";\n\n                name  = stringAsType((String) fields.get(0), comparator);\n                timestamp = (Long) fields.get(2);\n                kind = \"\";\n\n                if (fields.size() > 3)\n                {\n                    if (fields.get(3) instanceof Boolean)\n                    {\n                        // old format, reading this for backward compatibility sake\n                        if (fields.size() == 6)\n                        {\n                            kind = \"e\";\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else\n                        {\n                            kind = ((Boolean) fields.get(3)) ? \"d\" : \"\";\n                        }\n                    }\n                    else\n                    {\n                        kind = (String) fields.get(3);\n                        if (isExpiring())\n                        {\n                            ttl = (Integer) fields.get(4);\n                            localExpirationTime = (int) (long) ((Long) fields.get(5));\n                        }\n                        else if (isCounter())\n                        {\n                            timestampOfLastDelete = (long) ((Integer) fields.get(4));\n                        }\n                    }\n                }\n\n                value = isDeleted() ? ByteBufferUtil.hexToBytes((String) fields.get(1))\n                                    : stringAsType((String) fields.get(1), meta.getValueValidator(name.duplicate()));\n            }\n        }","commit_id":"03f24a9a32c24f2f4e1046ecd074400a65263bb2","url":"https://github.com/apache/cassandra"},{"original_method":"public static XMLStreamWriter createXMLStreamWriter(OutputStream out, String encoding) {\n        if (encoding == null) {\n            encoding = \"UTF-8\";\n        }\n\n        try {\n            return getXMLOutputFactory().createXMLStreamWriter(out, encoding);\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(\"Cant' create XMLStreamWriter\", e);\n        }\n    }","id":122,"modified_method":"public static XMLStreamWriter createXMLStreamWriter(OutputStream out, String encoding) {\n        if (encoding == null) {\n            encoding = \"UTF-8\";\n        }\n\n        try {\n            XMLOutputFactory factory = getXMLOutputFactory();\n            synchronized (factory) {\n                return factory.createXMLStreamWriter(out, encoding);\n            }\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(\"Cant' create XMLStreamWriter\", e);\n        }\n    }","commit_id":"d7c8eed4bbb875456f93cdc6ce7459d8ccb18078","url":"https://github.com/apache/cxf"},{"original_method":"public static XMLStreamWriter createXMLStreamWriter(Result r) {\n        try {\n            return getXMLOutputFactory().createXMLStreamWriter(r);\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(\"Cant' create XMLStreamWriter\", e);\n        }\n    }","id":123,"modified_method":"public static XMLStreamWriter createXMLStreamWriter(Result r) {\n        try {\n            XMLOutputFactory factory = getXMLOutputFactory();\n            synchronized (factory) {\n                return factory.createXMLStreamWriter(r);\n            }\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(\"Cant' create XMLStreamWriter\", e);\n        }\n    }","commit_id":"d7c8eed4bbb875456f93cdc6ce7459d8ccb18078","url":"https://github.com/apache/cxf"},{"original_method":"public static XMLStreamWriter createXMLStreamWriter(Writer out) {\n        try {\n            return getXMLOutputFactory().createXMLStreamWriter(out);\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(\"Cant' create XMLStreamWriter\", e);\n        }\n    }","id":124,"modified_method":"public static XMLStreamWriter createXMLStreamWriter(Writer out) {\n        try {\n            XMLOutputFactory factory = getXMLOutputFactory();\n            synchronized (factory) {\n                return factory.createXMLStreamWriter(out);\n            }\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(\"Cant' create XMLStreamWriter\", e);\n        }\n    }","commit_id":"d7c8eed4bbb875456f93cdc6ce7459d8ccb18078","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Generate the PDF.\n     *\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void generatePdf()\n        throws MojoExecutionException, IOException\n    {\n        Locale.setDefault( getDefaultLocale() );\n\n        for ( final Iterator iterator = getAvailableLocales().iterator(); iterator.hasNext(); )\n        {\n            final Locale locale = (Locale) iterator.next();\n\n            final File workingDir = getLocaleDirectory( workingDirectory, locale );\n\n            File siteDirectoryFile = getLocaleDirectory( getSiteDirectoryTmp(), locale );\n\n            copyResources( locale );\n\n            generateMavenReports( locale );\n\n            DocumentRendererContext context = new DocumentRendererContext();\n            context.put( \"project\", project );\n            context.put( \"settings\", settings );\n            context.put( \"PathTool\", new PathTool() );\n            context.put( \"FileUtils\", new FileUtils() );\n            context.put( \"StringUtils\", new StringUtils() );\n            context.put( \"i18n\", i18n );\n            context.put( \"generateTOC\", generateTOC );\n            context.put( \"validate\", Boolean.valueOf( validate ) );\n\n            final DocumentModel model = aggregate ? getDocumentModel( locale ) : null;\n\n            try\n            {\n                // TODO use interface see DOXIASITETOOLS-30\n                ( (AbstractDocumentRenderer) docRenderer ).render( siteDirectoryFile, workingDir, model, context );\n            }\n            catch ( DocumentRendererException e )\n            {\n                throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage(), e );\n            }\n        }\n    }","id":125,"modified_method":"/**\n     * Generate the PDF.\n     *\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void generatePdf()\n        throws MojoExecutionException, IOException\n    {\n        Locale.setDefault( getDefaultLocale() );\n\n        for ( final Locale locale : getAvailableLocales() )\n        {\n            final File workingDir = getLocaleDirectory( workingDirectory, locale );\n\n            File siteDirectoryFile = getLocaleDirectory( getSiteDirectoryTmp(), locale );\n\n            copyResources( locale );\n\n            generateMavenReports( locale );\n\n            DocumentRendererContext context = new DocumentRendererContext();\n            context.put( \"project\", project );\n            context.put( \"settings\", settings );\n            context.put( \"PathTool\", new PathTool() );\n            context.put( \"FileUtils\", new FileUtils() );\n            context.put( \"StringUtils\", new StringUtils() );\n            context.put( \"i18n\", i18n );\n            context.put( \"generateTOC\", generateTOC );\n            context.put( \"validate\", Boolean.valueOf( validate ) );\n\n            final DocumentModel model = aggregate ? getDocumentModel( locale ) : null;\n\n            try\n            {\n                // TODO use interface see DOXIASITETOOLS-30\n                ( (AbstractDocumentRenderer) docRenderer ).render( siteDirectoryFile, workingDir, model, context );\n            }\n            catch ( DocumentRendererException e )\n            {\n                throw new MojoExecutionException( \"Error during document generation: \" + e.getMessage(), e );\n            }\n        }\n    }","commit_id":"81f4c0fdccc50e871943f7aae7e9e83a585745dc","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Copy the generated PDF to outputDirectory.\n     *\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void copyGeneratedPdf()\n        throws MojoExecutionException, IOException\n    {\n        if ( outputDirectory.getCanonicalPath().equals( workingDirectory.getCanonicalPath() ) )\n        {\n            return;\n        }\n\n        String outputName = getDocumentModel( getDefaultLocale() ).getOutputName().trim();\n        if ( !outputName.endsWith( \".pdf\" ) )\n        {\n            outputName = outputName.concat( \".pdf\" );\n        }\n\n        for ( final Iterator iterator = getAvailableLocales().iterator(); iterator.hasNext(); )\n        {\n            final Locale locale = (Locale) iterator.next();\n\n            File generatedPdfSource = new File( getLocaleDirectory( workingDirectory, locale), outputName );\n\n            if ( !generatedPdfSource.exists() )\n            {\n                getLog().warn( \"Unable to find the generated pdf: \" + generatedPdfSource.getAbsolutePath() );\n                continue;\n            }\n\n            File generatedPdfDest = new File( getLocaleDirectory( outputDirectory, locale), outputName );\n\n            FileUtils.copyFile( generatedPdfSource, generatedPdfDest );\n            generatedPdfSource.delete();\n        }\n    }","id":126,"modified_method":"/**\n     * Copy the generated PDF to outputDirectory.\n     *\n     * @throws MojoExecutionException if any\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void copyGeneratedPdf()\n        throws MojoExecutionException, IOException\n    {\n        if ( outputDirectory.getCanonicalPath().equals( workingDirectory.getCanonicalPath() ) )\n        {\n            return;\n        }\n\n        String outputName = getDocumentModel( getDefaultLocale() ).getOutputName().trim();\n        if ( !outputName.endsWith( \".pdf\" ) )\n        {\n            outputName = outputName.concat( \".pdf\" );\n        }\n\n        for ( final Locale locale : getAvailableLocales() )\n        {\n            File generatedPdfSource = new File( getLocaleDirectory( workingDirectory, locale), outputName );\n\n            if ( !generatedPdfSource.exists() )\n            {\n                getLog().warn( \"Unable to find the generated pdf: \" + generatedPdfSource.getAbsolutePath() );\n                continue;\n            }\n\n            File generatedPdfDest = new File( getLocaleDirectory( outputDirectory, locale), outputName );\n\n            FileUtils.copyFile( generatedPdfSource, generatedPdfDest );\n            generatedPdfSource.delete();\n        }\n    }","commit_id":"81f4c0fdccc50e871943f7aae7e9e83a585745dc","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Copy the from site dir to the to dir.\n     *\n     * @param from not null\n     * @param to not null\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void copySiteDir( final File from, final File to )\n        throws IOException\n    {\n        if ( from == null || !from.exists() )\n        {\n            return;\n        }\n\n        // copy generated-site\n        for ( final Iterator iterator = getAvailableLocales().iterator(); iterator.hasNext(); )\n        {\n            final Locale locale = (Locale) iterator.next();\n\n            String excludes = getDefaultExcludesWithLocales( getAvailableLocales(), getDefaultLocale() );\n            List siteFiles = FileUtils.getFileNames( siteDirectory, \"**/*\", excludes, false );\n            File siteDirectoryLocale = new File( siteDirectory, locale.getLanguage() );\n            if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) && siteDirectoryLocale.exists() )\n            {\n                siteFiles = FileUtils.getFileNames( siteDirectoryLocale, \"**/*\", excludes, false );\n            }\n\n            List generatedSiteFiles = FileUtils.getFileNames( from, \"**/*\", excludes, false );\n            File fromLocale = new File( from, locale.getLanguage() );\n            if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) && fromLocale.exists() )\n            {\n                generatedSiteFiles = FileUtils.getFileNames( fromLocale, \"**/*\", excludes, false );\n            }\n\n            for ( final Iterator it = generatedSiteFiles.iterator(); it.hasNext(); )\n            {\n                final String generatedSiteFile = it.next().toString();\n\n                if ( siteFiles.contains( generatedSiteFile ) )\n                {\n                    getLog().warn( \"Generated-site already contains a file in site: \" + generatedSiteFile\n                                       + \". Ignoring copying it!\" );\n                    continue;\n                }\n\n                if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) )\n                {\n                    if ( fromLocale.exists() )\n                    {\n                        File in = new File( fromLocale, generatedSiteFile );\n                        File out = new File( new File( to, locale.getLanguage() ), generatedSiteFile );\n                        out.getParentFile().mkdirs();\n                        FileUtils.copyFile( in, out );\n                    }\n                }\n                else\n                {\n                    File in = new File( from, generatedSiteFile );\n                    File out = new File( to, generatedSiteFile );\n                    out.getParentFile().mkdirs();\n                    FileUtils.copyFile( in, out );\n                }\n            }\n        }\n    }","id":127,"modified_method":"/**\n     * Copy the from site dir to the to dir.\n     *\n     * @param from not null\n     * @param to not null\n     * @throws IOException if any\n     * @since 1.1\n     */\n    private void copySiteDir( final File from, final File to )\n        throws IOException\n    {\n        if ( from == null || !from.exists() )\n        {\n            return;\n        }\n\n        // copy generated-site\n        for ( final Locale locale : getAvailableLocales() )\n        {\n            String excludes = getDefaultExcludesWithLocales( getAvailableLocales(), getDefaultLocale() );\n            List siteFiles = FileUtils.getFileNames( siteDirectory, \"**/*\", excludes, false );\n            File siteDirectoryLocale = new File( siteDirectory, locale.getLanguage() );\n            if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) && siteDirectoryLocale.exists() )\n            {\n                siteFiles = FileUtils.getFileNames( siteDirectoryLocale, \"**/*\", excludes, false );\n            }\n\n            List generatedSiteFiles = FileUtils.getFileNames( from, \"**/*\", excludes, false );\n            File fromLocale = new File( from, locale.getLanguage() );\n            if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) && fromLocale.exists() )\n            {\n                generatedSiteFiles = FileUtils.getFileNames( fromLocale, \"**/*\", excludes, false );\n            }\n\n            for ( final Iterator it = generatedSiteFiles.iterator(); it.hasNext(); )\n            {\n                final String generatedSiteFile = it.next().toString();\n\n                if ( siteFiles.contains( generatedSiteFile ) )\n                {\n                    getLog().warn( \"Generated-site already contains a file in site: \" + generatedSiteFile\n                                       + \". Ignoring copying it!\" );\n                    continue;\n                }\n\n                if ( !locale.getLanguage().equals( getDefaultLocale().getLanguage() ) )\n                {\n                    if ( fromLocale.exists() )\n                    {\n                        File in = new File( fromLocale, generatedSiteFile );\n                        File out = new File( new File( to, locale.getLanguage() ), generatedSiteFile );\n                        out.getParentFile().mkdirs();\n                        FileUtils.copyFile( in, out );\n                    }\n                }\n                else\n                {\n                    File in = new File( from, generatedSiteFile );\n                    File out = new File( to, generatedSiteFile );\n                    out.getParentFile().mkdirs();\n                    FileUtils.copyFile( in, out );\n                }\n            }\n        }\n    }","commit_id":"81f4c0fdccc50e871943f7aae7e9e83a585745dc","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testHeartbeat() throws IOException {\n        DBBPool pool = new DBBPool();\n        HeartbeatMessage mn = new HeartbeatMessage(100222, 555555555555L, 97L);\n\n        HeartbeatMessage mn2 = (HeartbeatMessage) checkVoltMessage(mn, pool);\n\n        assertEquals(mn.getInitiatorHSId(), mn2.getInitiatorHSId());\n        assertEquals(mn.getCoordinatorHSId(), mn2.getCoordinatorHSId());\n        assertEquals(mn.getTxnId(), mn2.getTxnId());\n        assertEquals(mn.isReadOnly(), mn2.isReadOnly());\n        assertEquals(mn.getLastSafeTxnId(), mn2.getLastSafeTxnId());\n        mn.discard();\n        mn2.discard();\n        pool.clear();\n    }","id":128,"modified_method":"public void testHeartbeat() throws IOException {\n        HeartbeatMessage mn = new HeartbeatMessage(100222, 555555555555L, 97L);\n\n        HeartbeatMessage mn2 = (HeartbeatMessage) checkVoltMessage(mn);\n\n        assertEquals(mn.getInitiatorHSId(), mn2.getInitiatorHSId());\n        assertEquals(mn.getCoordinatorHSId(), mn2.getCoordinatorHSId());\n        assertEquals(mn.getTxnId(), mn2.getTxnId());\n        assertEquals(mn.isReadOnly(), mn2.isReadOnly());\n        assertEquals(mn.getLastSafeTxnId(), mn2.getLastSafeTxnId());\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testHeartbeatResponse() throws IOException {\n        DBBPool pool = new DBBPool();\n        HeartbeatResponseMessage mn = new HeartbeatResponseMessage(55, 100222, true);\n\n        HeartbeatResponseMessage mn2 = (HeartbeatResponseMessage) checkVoltMessage(mn, pool);\n\n        assertEquals(mn.getExecSiteId(), mn2.getExecSiteId());\n        assertEquals(mn.getLastReceivedTxnId(), mn2.getLastReceivedTxnId());\n        assertEquals(mn.isBlocked(), mn2.isBlocked());\n        mn.discard();\n        mn2.discard();\n        pool.clear();\n    }","id":129,"modified_method":"public void testHeartbeatResponse() throws IOException {\n        HeartbeatResponseMessage mn = new HeartbeatResponseMessage(55, 100222, true);\n\n        HeartbeatResponseMessage mn2 = (HeartbeatResponseMessage) checkVoltMessage(mn);\n\n        assertEquals(mn.getExecHSId(), mn2.getExecHSId());\n        assertEquals(mn.getLastReceivedTxnId(), mn2.getLastReceivedTxnId());\n        assertEquals(mn.isBlocked(), mn2.isBlocked());\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testInitiateTask() throws IOException {\n        DBBPool pool = new DBBPool();\n        StoredProcedureInvocation spi = new StoredProcedureInvocation();\n        spi.setClientHandle(25);\n        spi.setProcName(\"johnisgreat\");\n        spi.setParams(57, \"gooniestoo\");\n\n        InitiateTaskMessage itask = new InitiateTaskMessage(23, 8, 100045, true, false, spi, 2101);\n\n        InitiateTaskMessage itask2 = (InitiateTaskMessage) checkVoltMessage(itask, pool);\n\n        assertEquals(itask.getInitiatorHSId(), itask2.getInitiatorHSId());\n        assertEquals(itask.getTxnId(), itask2.getTxnId());\n        assertEquals(itask.isReadOnly(), itask2.isReadOnly());\n        assertEquals(itask.isSinglePartition(), itask2.isSinglePartition());\n        assertEquals(itask.getStoredProcedureName(), itask2.getStoredProcedureName());\n        assertEquals(itask.getParameterCount(), itask2.getParameterCount());\n        assertEquals(itask.getLastSafeTxnId(), itask2.getLastSafeTxnId());\n\n        itask.discard();\n        itask2.discard();\n        pool.clear();\n    }","id":130,"modified_method":"public void testInitiateTask() throws IOException {\n        StoredProcedureInvocation spi = new StoredProcedureInvocation();\n        spi.setClientHandle(25);\n        spi.setProcName(\"johnisgreat\");\n        spi.setParams(57, \"gooniestoo\", \"dudemandude\");\n\n        InitiateTaskMessage itask = new InitiateTaskMessage(23, 8, 100045, true, false, spi, 2101);\n\n        InitiateTaskMessage itask2 = (InitiateTaskMessage) checkVoltMessage(itask);\n\n        assertEquals(itask.getInitiatorHSId(), itask2.getInitiatorHSId());\n        assertEquals(itask.getTxnId(), itask2.getTxnId());\n        assertEquals(itask.isReadOnly(), itask2.isReadOnly());\n        assertEquals(itask.isSinglePartition(), itask2.isSinglePartition());\n        assertEquals(itask.getStoredProcedureName(), itask2.getStoredProcedureName());\n        assertEquals(itask.getParameterCount(), itask2.getParameterCount());\n        assertEquals(itask.getLastSafeTxnId(), itask2.getLastSafeTxnId());\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFragmentResponse() throws IOException {\n        DBBPool pool = new DBBPool();\n        FragmentTaskMessage ft = new FragmentTaskMessage(\n                15, 12, 37,\n                false, new long[0], null,\n                new ByteBuffer[0], false);\n\n        VoltTable table = new VoltTable(\n                new VoltTable.ColumnInfo(\"bearhugg\", VoltType.STRING)\n        );\n        table.addRow(\"sandimashighschoolfootballrules\");\n\n        FragmentResponseMessage fr = new FragmentResponseMessage(ft, 23);\n        fr.setStatus(FragmentResponseMessage.UNEXPECTED_ERROR, new EEException(1));\n        fr.addDependency(99, table);\n\n        FragmentResponseMessage fr2 = (FragmentResponseMessage) checkVoltMessage(fr, pool);\n\n        assertEquals(fr.getExecutorSiteId(), fr2.getExecutorSiteId());\n        assertEquals(fr.getDestinationSiteId(), fr2.getDestinationSiteId());\n        assertEquals(fr.getTxnId(), fr2.getTxnId());\n        assertEquals(fr.getStatusCode(), fr2.getStatusCode());\n        assertEquals(fr.getTableCount(), fr2.getTableCount());\n\n        VoltTable t1 = fr.getTableAtIndex(0);\n        VoltTable t2 = fr2.getTableAtIndex(0);\n        assertEquals(t1.fetchRow(0).getString(0), t2.fetchRow(0).getString(0));\n        ft.discard();\n        fr2.discard();\n        fr.discard();\n        pool.clear();\n    }","id":131,"modified_method":"public void testFragmentResponse() throws IOException {\n        FragmentTaskMessage ft = new FragmentTaskMessage(\n                15, 12, 37,\n                false, new long[0], null,\n                new ByteBuffer[0], false);\n\n        VoltTable table = new VoltTable(\n                new VoltTable.ColumnInfo(\"bearhugg\", VoltType.STRING)\n        );\n        table.addRow(\"sandimashighschoolfootballrules\");\n\n        FragmentResponseMessage fr = new FragmentResponseMessage(ft, 23);\n        fr.setStatus(FragmentResponseMessage.UNEXPECTED_ERROR, new EEException(1));\n        fr.addDependency(99, table);\n\n        FragmentResponseMessage fr2 = (FragmentResponseMessage) checkVoltMessage(fr);\n\n        assertEquals(fr.getExecutorSiteId(), fr2.getExecutorSiteId());\n        assertEquals(fr.getDestinationSiteId(), fr2.getDestinationSiteId());\n        assertEquals(fr.getTxnId(), fr2.getTxnId());\n        assertEquals(fr.getStatusCode(), fr2.getStatusCode());\n        assertEquals(fr.getTableCount(), fr2.getTableCount());\n\n        VoltTable t1 = fr.getTableAtIndex(0);\n        VoltTable t2 = fr2.getTableAtIndex(0);\n        assertEquals(t1.fetchRow(0).getString(0), t2.fetchRow(0).getString(0));\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testInitiateResponse() throws IOException {\n        DBBPool pool = new DBBPool();\n        StoredProcedureInvocation spi = new StoredProcedureInvocation();\n        spi.setClientHandle(25);\n        spi.setProcName(\"elmerfudd\");\n        spi.setParams(57, \"wrascallywabbit\");\n\n        InitiateTaskMessage itask = new InitiateTaskMessage(23, 8, 100045, true, false, spi, 2101);\n\n        VoltTable table = new VoltTable(\n                new VoltTable.ColumnInfo(\"foobar\", VoltType.STRING)\n        );\n        table.addRow(\"howmanylicksdoesittaketogettothecenterofatootsiepop\");\n\n        InitiateResponseMessage iresponse = new InitiateResponseMessage(itask);\n        iresponse.setResults( new ClientResponseImpl(ClientResponseImpl.GRACEFUL_FAILURE,\n                new VoltTable[] { table }, \"knockknockbananna\", new EEException(1)));\n        iresponse.setClientHandle(99);\n\n        InitiateResponseMessage iresponse2 = (InitiateResponseMessage) checkVoltMessage(iresponse, pool);\n\n        assertEquals(iresponse.getTxnId(), iresponse2.getTxnId());\n        iresponse.discard();\n        iresponse2.discard();\n        pool.clear();\n    }","id":132,"modified_method":"public void testInitiateResponse() throws IOException {\n        StoredProcedureInvocation spi = new StoredProcedureInvocation();\n        spi.setClientHandle(25);\n        spi.setProcName(\"elmerfudd\");\n        spi.setParams(57, \"wrascallywabbit\");\n\n        InitiateTaskMessage itask = new InitiateTaskMessage(23, 8, 100045, true, false, spi, 2101);\n\n        VoltTable table = new VoltTable(\n                new VoltTable.ColumnInfo(\"foobar\", VoltType.STRING)\n        );\n        table.addRow(\"howmanylicksdoesittaketogettothecenterofatootsiepop\");\n\n        InitiateResponseMessage iresponse = new InitiateResponseMessage(itask);\n        iresponse.setResults( new ClientResponseImpl(ClientResponseImpl.GRACEFUL_FAILURE,\n                new VoltTable[] { table }, \"knockknockbananna\", new EEException(1)));\n        iresponse.setClientHandle(99);\n\n        InitiateResponseMessage iresponse2 = (InitiateResponseMessage) checkVoltMessage(iresponse);\n\n        assertEquals(iresponse.getTxnId(), iresponse2.getTxnId());\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFragmentTask() throws IOException {\n        DBBPool pool = new DBBPool();\n        FragmentTaskMessage ft = new FragmentTaskMessage(9, 70654312, -75, true,\n            new long[] { 5 }, new int[] { 12 }, new ByteBuffer[] { ByteBuffer.allocate(0) }, true);\n        ft.setFragmentTaskType(FragmentTaskMessage.SYS_PROC_PER_PARTITION);\n\n        FragmentTaskMessage ft2 = (FragmentTaskMessage) checkVoltMessage(ft, pool);\n\n        assertEquals(ft.getInitiatorHSId(), ft2.getInitiatorHSId());\n        assertEquals(ft.getCoordinatorHSId(), ft2.getCoordinatorHSId());\n        assertEquals(ft.getTxnId(), ft2.getTxnId());\n        assertEquals(ft.isReadOnly(), ft2.isReadOnly());\n\n        assertEquals(ft.getFragmentCount(), ft2.getFragmentCount());\n\n        assertEquals(ft.isFinalTask(), ft2.isFinalTask());\n        assertEquals(ft.isSysProcTask(), ft2.isSysProcTask());\n        ft.discard();\n        ft2.discard();\n        pool.clear();\n    }","id":133,"modified_method":"public void testFragmentTask() throws IOException {\n        FragmentTaskMessage ft = new FragmentTaskMessage(9, 70654312, -75, true,\n            new long[] { 5 }, new int[] { 12 }, new ByteBuffer[] { ByteBuffer.allocate(0) }, true);\n        ft.setFragmentTaskType(FragmentTaskMessage.SYS_PROC_PER_PARTITION);\n\n        FragmentTaskMessage ft2 = (FragmentTaskMessage) checkVoltMessage(ft);\n\n        assertEquals(ft.getInitiatorHSId(), ft2.getInitiatorHSId());\n        assertEquals(ft.getCoordinatorHSId(), ft2.getCoordinatorHSId());\n        assertEquals(ft.getTxnId(), ft2.getTxnId());\n        assertEquals(ft.isReadOnly(), ft2.isReadOnly());\n\n        assertEquals(ft.getFragmentCount(), ft2.getFragmentCount());\n\n        assertEquals(ft.isFinalTask(), ft2.isFinalTask());\n        assertEquals(ft.isSysProcTask(), ft2.isSysProcTask());\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testMembershipNotice() throws IOException {\n        DBBPool pool = new DBBPool();\n        MultiPartitionParticipantMessage mn = new MultiPartitionParticipantMessage(100222, -75, 555555555555L, false);\n\n        MultiPartitionParticipantMessage mn2 = (MultiPartitionParticipantMessage) checkVoltMessage(mn, pool);\n\n        assertEquals(mn.getInitiatorHSId(), mn2.getInitiatorHSId());\n        assertEquals(mn.getCoordinatorHSId(), mn2.getCoordinatorHSId());\n        assertEquals(mn.getTxnId(), mn2.getTxnId());\n        assertEquals(mn.isReadOnly(), mn2.isReadOnly());\n        mn.discard();\n        mn2.discard();\n        pool.clear();\n    }","id":134,"modified_method":"public void testMembershipNotice() throws IOException {\n        MultiPartitionParticipantMessage mn = new MultiPartitionParticipantMessage(100222, -75, 555555555555L, false);\n\n        MultiPartitionParticipantMessage mn2 =\n            (MultiPartitionParticipantMessage) checkVoltMessage(mn);\n\n        assertEquals(mn.getInitiatorHSId(), mn2.getInitiatorHSId());\n        assertEquals(mn.getCoordinatorHSId(), mn2.getCoordinatorHSId());\n        assertEquals(mn.getTxnId(), mn2.getTxnId());\n        assertEquals(mn.isReadOnly(), mn2.isReadOnly());\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testFragmentTaskWithTwoFrags() throws IOException {\n        DBBPool pool = new DBBPool();\n\n        Object[] params1 = {(Integer)10, (Double)10.1};\n        Object[] params2 = {(Integer)20, (Double)20.2};\n\n        ParameterSet param_set1 = new ParameterSet(true);\n        param_set1.setParameters(params1);\n        ParameterSet param_set2 = new ParameterSet(true);\n        param_set2.setParameters(params2);\n\n        FastSerializer param1_fs = new FastSerializer();\n        param1_fs.writeObject(param_set1);\n        ByteBuffer param1_buf = param1_fs.getBuffer();\n\n        FastSerializer param2_fs = new FastSerializer();\n        param2_fs.writeObject(param_set2);\n        ByteBuffer param2_buf = param2_fs.getBuffer();\n\n        FragmentTaskMessage ft = new FragmentTaskMessage(9, 70654312, -75, true,\n            new long[] { 5, 10 }, new int[] { 12, 24 },\n            new ByteBuffer[] { param1_buf, param2_buf }, true);\n        ft.setFragmentTaskType(FragmentTaskMessage.SYS_PROC_PER_PARTITION);\n\n        FragmentTaskMessage ft2 = (FragmentTaskMessage) checkVoltMessage(ft, pool);\n\n        assertEquals(ft.getInitiatorHSId(), ft2.getInitiatorHSId());\n        assertEquals(ft.getCoordinatorHSId(), ft2.getCoordinatorHSId());\n        assertEquals(ft.getTxnId(), ft2.getTxnId());\n        assertEquals(ft.isReadOnly(), ft2.isReadOnly());\n\n        assertEquals(ft.getFragmentCount(), ft2.getFragmentCount());\n\n        assertEquals(ft.isFinalTask(), ft2.isFinalTask());\n        assertEquals(ft.isSysProcTask(), ft2.isSysProcTask());\n\n        assertEquals(2, ft2.getFragmentCount());\n        ParameterSet params = null;\n        ByteBuffer paramData = ft2.getParameterDataForFragment(0);\n        if (paramData != null) {\n            final FastDeserializer fds = new FastDeserializer(paramData);\n            params = fds.readObject(ParameterSet.class);\n        }\n        assertEquals(10, params.toArray()[0]);\n        assertEquals(10.1, params.toArray()[1]);\n\n        params = null;\n        paramData = ft2.getParameterDataForFragment(1);\n        if (paramData != null) {\n            final FastDeserializer fds = new FastDeserializer(paramData);\n            params = fds.readObject(ParameterSet.class);\n        }\n        assertEquals(20, params.toArray()[0]);\n        assertEquals(20.2, params.toArray()[1]);\n\n        ft.discard();\n        ft2.discard();\n        pool.clear();\n    }","id":135,"modified_method":"public void testFragmentTaskWithTwoFrags() throws IOException {\n        Object[] params1 = {(Integer)10, (Double)10.1};\n        Object[] params2 = {(Integer)20, (Double)20.2};\n\n        ParameterSet param_set1 = new ParameterSet(true);\n        param_set1.setParameters(params1);\n        ParameterSet param_set2 = new ParameterSet(true);\n        param_set2.setParameters(params2);\n\n        FastSerializer param1_fs = new FastSerializer();\n        param1_fs.writeObject(param_set1);\n        ByteBuffer param1_buf = param1_fs.getBuffer();\n\n        FastSerializer param2_fs = new FastSerializer();\n        param2_fs.writeObject(param_set2);\n        ByteBuffer param2_buf = param2_fs.getBuffer();\n\n        FragmentTaskMessage ft = new FragmentTaskMessage(9, 70654312, -75, true,\n            new long[] { 5, 10 }, new int[] { 12, 24 },\n            new ByteBuffer[] { param1_buf, param2_buf }, true);\n        ft.setFragmentTaskType(FragmentTaskMessage.SYS_PROC_PER_PARTITION);\n\n        FragmentTaskMessage ft2 = (FragmentTaskMessage) checkVoltMessage(ft);\n\n        assertEquals(ft.getInitiatorHSId(), ft2.getInitiatorHSId());\n        assertEquals(ft.getCoordinatorHSId(), ft2.getCoordinatorHSId());\n        assertEquals(ft.getTxnId(), ft2.getTxnId());\n        assertEquals(ft.isReadOnly(), ft2.isReadOnly());\n\n        assertEquals(ft.getFragmentCount(), ft2.getFragmentCount());\n\n        assertEquals(ft.isFinalTask(), ft2.isFinalTask());\n        assertEquals(ft.isSysProcTask(), ft2.isSysProcTask());\n\n        assertEquals(2, ft2.getFragmentCount());\n        ParameterSet params = null;\n        ByteBuffer paramData = ft2.getParameterDataForFragment(0);\n        if (paramData != null) {\n            final FastDeserializer fds = new FastDeserializer(paramData);\n            params = fds.readObject(ParameterSet.class);\n        }\n        assertEquals(10, params.toArray()[0]);\n        assertEquals(10.1, params.toArray()[1]);\n\n        params = null;\n        paramData = ft2.getParameterDataForFragment(1);\n        if (paramData != null) {\n            final FastDeserializer fds = new FastDeserializer(paramData);\n            params = fds.readObject(ParameterSet.class);\n        }\n        assertEquals(20, params.toArray()[0]);\n        assertEquals(20.2, params.toArray()[1]);\n    }","commit_id":"ceea7635e195e9789d5d735a646c315ed3d38ca8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void reportExceptions( MavenExecutionResult result,\n                                   File basedir,\n                                   boolean expectExceptions )\n    {\n        assertTrue( !expectExceptions || result.hasExceptions() );\n\n        StringWriter writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter( writer );\n\n        writer.write( \"Failed to build project in: \" );\n        writer.write( basedir.getPath() );\n        writer.write( \"\\nEncountered the following errors:\" );\n\n        for ( Iterator it = result.getExceptions().iterator(); it.hasNext(); )\n        {\n            Throwable error = (Throwable) it.next();\n            writer.write( \"\\n\\n\" );\n            error.printStackTrace( pWriter );\n        }\n\n        if ( expectExceptions )\n        {\n            fail( writer.toString() );\n        }\n        else\n        {\n            System.out.println( writer.toString() );\n        }\n    }","id":136,"modified_method":"private void reportExceptions( MavenExecutionResult result,\n                                   File basedir,\n                                   boolean expectExceptions )\n    {\n        assertTrue( !expectExceptions || result.hasExceptions() );\n\n        StringWriter writer = new StringWriter();\n        PrintWriter pWriter = new PrintWriter( writer );\n\n        writer.write( \"Failed to build project in: \" );\n        writer.write( basedir.getPath() );\n        writer.write( \"\\nEncountered the following errors:\" );\n\n        for ( Throwable error : (Collection<Throwable>) result.getExceptions() )\n        {\n            writer.write( \"\\n\\n\" );\n            error.printStackTrace( pWriter );\n        }\n\n        if ( expectExceptions )\n        {\n            fail( writer.toString() );\n        }\n        else\n        {\n            System.out.println( writer.toString() );\n        }\n    }","commit_id":"3acaa63cf8a167a0c8f10116dbd7545f1929d128","url":"https://github.com/apache/maven"},{"original_method":"public void test()\n        throws Exception\n    {\n        Configuration configuration = new DefaultConfiguration();\n        configuration.setMavenEmbedderLogger( new MavenEmbedderConsoleLogger() );\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        File pom = new File( \"src/test/projects/bad-module-non-recursive/pom.xml\" ).getCanonicalFile();\n\n        System.out.println( pom.getCanonicalFile() );\n\n        DefaultMavenExecutionRequest request = new DefaultMavenExecutionRequest();\n        request.setOffline( false );\n        request.setUseReactor( false );\n        request.setRecursive( false );\n        //request.setLoggingLevel( Logger.LEVEL_DEBUG );\n        request.setPom( pom );\n        request.setBaseDirectory( pom.getParentFile() );\n        MavenExecutionResult result = embedder.readProjectWithDependencies( request );\n        MavenProject project = result.getProject();\n\n        if ( result.hasExceptions() )\n        {\n            for ( Iterator it = result.getExceptions().iterator(); it.hasNext(); )\n            {\n                Exception ex = (Exception) it.next();\n                ex.printStackTrace();\n            }\n        }\n\n        assertNotNull( project );\n    }","id":137,"modified_method":"public void test()\n        throws Exception\n    {\n        Configuration configuration = new SimpleConfiguration();\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        File pom = new File( \"src/test/projects/bad-module-non-recursive/pom.xml\" ).getCanonicalFile();\n\n        System.out.println( pom.getCanonicalFile() );\n\n        DefaultMavenExecutionRequest request = new DefaultMavenExecutionRequest();\n        request.setOffline( false );\n        request.setUseReactor( false );\n        request.setRecursive( false );\n        //request.setLoggingLevel( Logger.LEVEL_DEBUG );\n        request.setPom( pom );\n        request.setBaseDirectory( pom.getParentFile() );\n        MavenExecutionResult result = embedder.readProjectWithDependencies( request );\n        MavenProject project = result.getProject();\n\n        if ( result.hasExceptions() )\n        {\n            for ( Exception e : result.getExceptions() )\n            {\n                e.printStackTrace();\n            }\n        }\n\n        assertNotNull( project );\n    }","commit_id":"0ba6f79521e8833d4606532877d0765f7b667a14","url":"https://github.com/apache/maven"},{"original_method":"public void testEmbedderWillStillStartupWhenTheSettingsConfigurationIsCrap()\n        throws Exception\n    {\n        // START SNIPPET: simple-embedder-example\n\n        File projectDirectory = getTestFile( \"src/examples/simple-project\" );\n\n        File user = new File( projectDirectory, \"invalid-settings.xml\" );\n\n        Configuration configuration = new DefaultConfiguration()\n            .setUserSettingsFile( user )\n            .setClassLoader( Thread.currentThread().getContextClassLoader() );\n\n        ConfigurationValidationResult validationResult = MavenEmbedder.validateConfiguration( configuration );\n\n        assertFalse( validationResult.isValid() );\n\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        assertNotNull( embedder.getLocalRepository().getBasedir() );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( projectDirectory )\n            .setGoals( Arrays.asList( new String[]{\"validate\"} ) );\n\n        MavenExecutionResult result = embedder.execute( request );\n        \n        for ( Iterator i = result.getExceptions().iterator(); i.hasNext(); )\n        {\n            Exception e = (Exception) i.next();\n            e.printStackTrace();\n        }\n        \n        assertFalse( result.hasExceptions() );\n\n        assertNotNull( result.getProject() );\n\n        MavenProject project = result.getProject();\n\n        String environment = project.getProperties().getProperty( \"environment\" );\n\n        assertEquals( \"development\", environment );\n\n        // END SNIPPET: simple-embedder-example\n    }","id":138,"modified_method":"public void testEmbedderWillStillStartupWhenTheSettingsConfigurationIsCrap()\n        throws Exception\n    {\n        // START SNIPPET: simple-embedder-example\n\n        File projectDirectory = getTestFile( \"src/examples/simple-project\" );\n\n        File user = new File( projectDirectory, \"invalid-settings.xml\" );\n\n        Configuration configuration = new SimpleConfiguration()\n            .setUserSettingsFile( user );\n\n        ConfigurationValidationResult validationResult = MavenEmbedder.validateConfiguration( configuration );\n\n        assertFalse( validationResult.isValid() );\n\n        MavenEmbedder embedder = new MavenEmbedder( configuration );\n\n        assertNotNull( embedder.getLocalRepository().getBasedir() );\n\n        MavenExecutionRequest request = new DefaultMavenExecutionRequest()\n            .setBaseDirectory( projectDirectory )\n            .setGoals( Arrays.asList( new String[]{\"validate\"} ) );\n\n        MavenExecutionResult result = embedder.execute( request );\n        \n        for ( Exception e : result.getExceptions() )\n        {\n            e.printStackTrace();\n        }\n        \n        assertFalse( result.hasExceptions() );\n\n        assertNotNull( result.getProject() );\n\n        MavenProject project = result.getProject();\n\n        String environment = project.getProperties().getProperty( \"environment\" );\n\n        assertEquals( \"development\", environment );\n\n        // END SNIPPET: simple-embedder-example\n    }","commit_id":"0ba6f79521e8833d4606532877d0765f7b667a14","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        List<OnmsNode> nodes = new FindByVarCharAssetColumnAndCategoryList(getDataSource(), columnName, categoryNames).execute(columnValue);\n        log().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","id":139,"modified_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        \n    \tNodeHierarchyMapper rowMapper = new NodeHierarchyMapper(getDataSource());\n    \t\n\n    \tfinal String hierarchyQuery = \"SELECT \" +\n    \trowMapper.getColumns() +\n    \t\"FROM node \" +\n    \t\"JOIN assets ON (node.nodeid = assets.nodeid) \" +\n    \t\"JOIN category_node ON (node.nodeid = category_node.nodeid) \" +\n    \t\"JOIN categories ON (category_node.categoryid = category.categoryid) \" +\n    \t\"LEFT JOIN ipInterface ON (node.nodeId = ipInterface.nodeId) \" +\n    \t\"LEFT JOIN ifservices ON (ipInterface.nodeId = ifservices.nodeId AND ipInterface.ipAddr = ifservices.ipAddr) \" +\n    \t\"LEFT JOIN outages ON (ifServices.nodeId = outages.nodeId AND ifServices.ipAddr = outages.ipAddr AND ifServices.serviceID = outages.serviceId AND outages.ifRegainedService is null) \" +\n    \t\"WHERE assets.\" + columnName +\" = ? \" +\n    \t\"AMD categories.categoryName in (\"+StringUtils.collectionToDelimitedString(categoryNames, \",\", \"'\", \"'\")+\")\" +\n    \t\"\";\n    \t\n    \tSet<OnmsNode> nodes = new HashSet<OnmsNode>(getJdbcTemplate().query(hierarchyQuery, new Object[] { columnValue }, rowMapper));\n\n    \tlog().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","commit_id":"cccd42d2a0e3e13cb77dcb9e2fe75ec432ea1ec7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        List<OnmsNode> nodes = new FindByVarCharAssetColumnAndCategoryList(getDataSource(), columnName, categoryNames).execute(columnValue);\n        log().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","id":140,"modified_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        \n    \tNodeHierarchyMapper rowMapper = new NodeHierarchyMapper(getDataSource());\n    \t\n\n    \tfinal String hierarchyQuery = \"SELECT \" +\n    \trowMapper.getColumns() +\n    \t\"FROM node \" +\n    \t\"JOIN assets ON (node.nodeid = assets.nodeid) \" +\n    \t\"JOIN category_node ON (node.nodeid = category_node.nodeid) \" +\n    \t\"JOIN categories ON (category_node.categoryid = category.categoryid) \" +\n    \t\"LEFT JOIN ipInterface ON (node.nodeId = ipInterface.nodeId) \" +\n    \t\"LEFT JOIN ifservices ON (ipInterface.nodeId = ifservices.nodeId AND ipInterface.ipAddr = ifservices.ipAddr) \" +\n    \t\"LEFT JOIN outages ON (ifServices.nodeId = outages.nodeId AND ifServices.ipAddr = outages.ipAddr AND ifServices.serviceID = outages.serviceId AND outages.ifRegainedService is null) \" +\n    \t\"WHERE assets.\" + columnName +\" = ? \" +\n    \t\"AMD categories.categoryName in (\"+StringUtils.collectionToDelimitedString(categoryNames, \",\", \"'\", \"'\")+\")\" +\n    \t\"\";\n    \t\n    \tSet<OnmsNode> nodes = new HashSet<OnmsNode>(getJdbcTemplate().query(hierarchyQuery, new Object[] { columnValue }, rowMapper));\n\n    \tlog().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","commit_id":"17ddc6b7a1384dfd1f5571eecfad9afda80ac50f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        \n    \tNodeHierarchyMapper rowMapper = new NodeHierarchyMapper(getDataSource());\n    \t\n\n    \tfinal String hierarchyQuery = \"SELECT \" +\n    \trowMapper.getColumns() +\n    \t\"FROM node \" +\n    \t\"JOIN assets ON (node.nodeid = assets.nodeid) \" +\n    \t\"JOIN category_node ON (node.nodeid = category_node.nodeid) \" +\n    \t\"JOIN categories ON (category_node.categoryid = category.categoryid) \" +\n    \t\"LEFT JOIN ipInterface ON (node.nodeId = ipInterface.nodeId) \" +\n    \t\"LEFT JOIN ifservices ON (ipInterface.nodeId = ifservices.nodeId AND ipInterface.ipAddr = ifservices.ipAddr) \" +\n    \t\"LEFT JOIN outages ON (ifServices.nodeId = outages.nodeId AND ifServices.ipAddr = outages.ipAddr AND ifServices.serviceID = outages.serviceId AND outages.ifRegainedService is null) \" +\n    \t\"WHERE assets.\" + columnName +\" = ? \" +\n    \t\"AMD categories.categoryName in (\"+StringUtils.collectionToDelimitedString(categoryNames, \",\", \"'\", \"'\")+\")\" +\n    \t\"\";\n    \t\n    \tSet<OnmsNode> nodes = new HashSet<OnmsNode>(getJdbcTemplate().query(hierarchyQuery, new Object[] { columnValue }, rowMapper));\n\n    \tlog().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","id":141,"modified_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        List<OnmsNode> nodes = new FindByVarCharAssetColumnAndCategoryList(getDataSource(), columnName, categoryNames).execute(columnValue);\n\n        for (OnmsNode node : nodes) {\n\t\t\tgetHierarchy(node.getId());\n\t\t}\n        \n// Turns out its faster just go thru and load the hierarchy of each node... go figure!        \n//    \tNodeHierarchyMapper rowMapper = new NodeHierarchyMapper(getDataSource());\n//    \t\n//\n//    \tfinal String hierarchyQuery = \"SELECT \" +\n//    \trowMapper.getColumns() +\n//    \t\"FROM node \" +\n//    \t\"JOIN assets ON (node.nodeid = assets.nodeid) \" +\n//    \t\"JOIN category_node ON (node.nodeid = category_node.nodeid) \" +\n//    \t\"JOIN categories ON (category_node.categoryid = category.categoryid) \" +\n//    \t\"LEFT JOIN ipInterface ON (node.nodeId = ipInterface.nodeId) \" +\n//    \t\"LEFT JOIN ifservices ON (ipInterface.nodeId = ifservices.nodeId AND ipInterface.ipAddr = ifservices.ipAddr) \" +\n//    \t\"LEFT JOIN outages ON (ifServices.nodeId = outages.nodeId AND ifServices.ipAddr = outages.ipAddr AND ifServices.serviceID = outages.serviceId AND outages.ifRegainedService is null) \" +\n//    \t\"WHERE assets.\" + columnName +\" = ? \" +\n//    \t\"AMD categories.categoryName in (\"+StringUtils.collectionToDelimitedString(categoryNames, \",\", \"'\", \"'\")+\")\" +\n//    \t\"\";\n//    \t\n//    \tSet<OnmsNode> nodes = new HashSet<OnmsNode>(getJdbcTemplate().query(hierarchyQuery, new Object[] { columnValue }, rowMapper));\n\n    \tlog().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","commit_id":"d517fc1582ba5c17f0dbe690537863b305a7b599","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        \n    \tNodeHierarchyMapper rowMapper = new NodeHierarchyMapper(getDataSource());\n    \t\n\n    \tfinal String hierarchyQuery = \"SELECT \" +\n    \trowMapper.getColumns() +\n    \t\"FROM node \" +\n    \t\"JOIN assets ON (node.nodeid = assets.nodeid) \" +\n    \t\"JOIN category_node ON (node.nodeid = category_node.nodeid) \" +\n    \t\"JOIN categories ON (category_node.categoryid = category.categoryid) \" +\n    \t\"LEFT JOIN ipInterface ON (node.nodeId = ipInterface.nodeId) \" +\n    \t\"LEFT JOIN ifservices ON (ipInterface.nodeId = ifservices.nodeId AND ipInterface.ipAddr = ifservices.ipAddr) \" +\n    \t\"LEFT JOIN outages ON (ifServices.nodeId = outages.nodeId AND ifServices.ipAddr = outages.ipAddr AND ifServices.serviceID = outages.serviceId AND outages.ifRegainedService is null) \" +\n    \t\"WHERE assets.\" + columnName +\" = ? \" +\n    \t\"AMD categories.categoryName in (\"+StringUtils.collectionToDelimitedString(categoryNames, \",\", \"'\", \"'\")+\")\" +\n    \t\"\";\n    \t\n    \tSet<OnmsNode> nodes = new HashSet<OnmsNode>(getJdbcTemplate().query(hierarchyQuery, new Object[] { columnValue }, rowMapper));\n\n    \tlog().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","id":142,"modified_method":"/**\n     * This method searches for nodes matching a column in the assets table and also having been\n     * assigned to a category in the cateories table.  Note: this implmentation requires that\n     * the column type be of type VARCHAR.\n     * \n     * @param columnName is VARCHAR column in assets table used in where clause\n     * @param columnValue is the value used for matching <code>columnName<\/code>\n     * @param categoryNames is a collection of names from categories\n     *  table assigned to the node via category_node table\n     * @return Collection of nodes.\n     */\n    public Collection<OnmsNode> findAllByVarCharAssetColumnCategoryList(String columnName, String columnValue, Collection<String> categoryNames) {\n        log().debug(\"findAllByVarCharAssetColumnCategoryList: beginning find.\");\n        List<OnmsNode> nodes = new FindByVarCharAssetColumnAndCategoryList(getDataSource(), columnName, categoryNames).execute(columnValue);\n\n        for (OnmsNode node : nodes) {\n\t\t\tgetHierarchy(node.getId());\n\t\t}\n        \n// Turns out its faster just go thru and load the hierarchy of each node... go figure!        \n//    \tNodeHierarchyMapper rowMapper = new NodeHierarchyMapper(getDataSource());\n//    \t\n//\n//    \tfinal String hierarchyQuery = \"SELECT \" +\n//    \trowMapper.getColumns() +\n//    \t\"FROM node \" +\n//    \t\"JOIN assets ON (node.nodeid = assets.nodeid) \" +\n//    \t\"JOIN category_node ON (node.nodeid = category_node.nodeid) \" +\n//    \t\"JOIN categories ON (category_node.categoryid = category.categoryid) \" +\n//    \t\"LEFT JOIN ipInterface ON (node.nodeId = ipInterface.nodeId) \" +\n//    \t\"LEFT JOIN ifservices ON (ipInterface.nodeId = ifservices.nodeId AND ipInterface.ipAddr = ifservices.ipAddr) \" +\n//    \t\"LEFT JOIN outages ON (ifServices.nodeId = outages.nodeId AND ifServices.ipAddr = outages.ipAddr AND ifServices.serviceID = outages.serviceId AND outages.ifRegainedService is null) \" +\n//    \t\"WHERE assets.\" + columnName +\" = ? \" +\n//    \t\"AMD categories.categoryName in (\"+StringUtils.collectionToDelimitedString(categoryNames, \",\", \"'\", \"'\")+\")\" +\n//    \t\"\";\n//    \t\n//    \tSet<OnmsNode> nodes = new HashSet<OnmsNode>(getJdbcTemplate().query(hierarchyQuery, new Object[] { columnValue }, rowMapper));\n\n    \tlog().debug(\"findAllByVarCharAssetColumnCateoryList: find complete. Nodes found: \"+nodes.size());\n        return nodes;\n    }","commit_id":"b5ded7d1a73b41106c3fdbd739a09f3b04889df7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\r\n    public int getConvertedManaCost() {\r\n        if (this.isCopy()) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return this.topHalfCard.getConvertedManaCost() + this.bottomHalfCard.getConvertedManaCost();\r\n        }\r\n    }","id":143,"modified_method":"@Override\r\n    public int getConvertedManaCost() {\r\n        if (this.isCopy()) {\r\n            return 0;\r\n        } else {\r\n            return (this.topHalfCard != null ? this.topHalfCard.getConvertedManaCost() : 0)\r\n                    + (this.bottomHalfCard != null ? this.bottomHalfCard.getConvertedManaCost() : 0);\r\n        }\r\n    }","commit_id":"54ad8a6ec0e931f33c6b3abf31e49b44a10c4e12","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public int getConvertedManaCost() {\n        if (this.isCopy()) {\n            return 0;\n        }\n        else {\n            return this.topHalfCard.getConvertedManaCost() + this.bottomHalfCard.getConvertedManaCost();\n        }\n    }","id":144,"modified_method":"@Override\n    public int getConvertedManaCost() {\n        if (this.isCopy()) {\n            return 0;\n        } else {\n            return (this.topHalfCard != null ? this.topHalfCard.getConvertedManaCost() : 0)\n                    + (this.bottomHalfCard != null ? this.bottomHalfCard.getConvertedManaCost() : 0);\n        }\n    }","commit_id":"2a55110627368b48a950de2289eebfb054057db6","url":"https://github.com/magefree/mage"},{"original_method":"private void validateNodeRel1( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor( \n                    keyId ).getKey() );\n                assertEquals( \"string1\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string1\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 1 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -1 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( true ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( false ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = \n            rStore.getRelationshipChainPosition( node );\n        for ( RelationshipData rel : \n            rStore.getMoreRelationships( node, pos ) )\n        {\n            if ( rel.getId() == rel1 )\n            {\n                assertEquals( node, rel.firstNode() );\n                assertEquals( relType1, rel.relationshipType() );\n            }\n            else if ( rel.getId() == rel2 )\n            {\n                assertEquals( node, rel.secondNode() );\n                assertEquals( relType2, rel.relationshipType() );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 2, count );\n    }","id":145,"modified_method":"private void validateNodeRel1( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor( \n                    keyId ).getKey() );\n                assertEquals( \"string1\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string1\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 1 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -1 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( true ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( false ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = rStore.getRelationshipChainPosition( node );\n        while ( true )\n        {\n            Iterable<RelationshipData> relData = rStore.getMoreRelationships( node, pos );\n            if ( !relData.iterator().hasNext() )\n            {\n                break;\n            }\n            for ( RelationshipData rel : relData )\n            {\n                if ( rel.getId() == rel1 )\n                {\n                    assertEquals( node, rel.firstNode() );\n                    assertEquals( relType1, rel.relationshipType() );\n                }\n                else if ( rel.getId() == rel2 )\n                {\n                    assertEquals( node, rel.secondNode() );\n                    assertEquals( relType2, rel.relationshipType() );\n                }\n                else\n                {\n                    throw new IOException();\n                }\n                count++;\n            }\n        }\n        assertEquals( 2, count );\n    }","commit_id":"58781ed25750f8e7ed0ea85f811fa7c2146517c9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void validateNodeRel2( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( \"string2\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string2\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 2 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -2 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( false ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( true ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = \n            rStore.getRelationshipChainPosition( node );\n        for ( RelationshipData rel : \n            rStore.getMoreRelationships( node, pos ) )\n        {\n            if ( rel.getId() == rel1 )\n            {\n                assertEquals( node, rel.secondNode() );\n                assertEquals( relType1, rel.relationshipType() );\n            }\n            else if ( rel.getId() == rel2 )\n            {\n                assertEquals( node, rel.firstNode() );\n                assertEquals( relType2, rel.relationshipType() );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 2, count );\n    }","id":146,"modified_method":"private void validateNodeRel2( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( \"string2\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string2\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 2 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -2 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( false ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( true ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        \n        RelationshipChainPosition pos = rStore.getRelationshipChainPosition( node );\n        while ( true )\n        {\n            Iterable<RelationshipData> relData = rStore.getMoreRelationships( node, pos );\n            if ( !relData.iterator().hasNext() )\n            {\n                break;\n            }\n            for ( RelationshipData rel : relData )\n            {\n                if ( rel.getId() == rel1 )\n                {\n                    assertEquals( node, rel.secondNode() );\n                    assertEquals( relType1, rel.relationshipType() );\n                }\n                else if ( rel.getId() == rel2 )\n                {\n                    assertEquals( node, rel.firstNode() );\n                    assertEquals( relType2, rel.relationshipType() );\n                }\n                else\n                {\n                    throw new IOException();\n                }\n                count++;\n            }\n        }\n        assertEquals( 2, count );\n    }","commit_id":"58781ed25750f8e7ed0ea85f811fa7c2146517c9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void validateNodeRel2( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( \"string2\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string2\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 2 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -2 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( false ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( true ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = \n            rStore.getRelationshipChainPosition( node );\n        for ( RelationshipData rel : \n            rStore.getMoreRelationships( node, pos ) )\n        {\n            if ( rel.getId() == rel1 )\n            {\n                assertEquals( node, rel.secondNode() );\n                assertEquals( relType1, rel.relationshipType() );\n            }\n            else if ( rel.getId() == rel2 )\n            {\n                assertEquals( node, rel.firstNode() );\n                assertEquals( relType2, rel.relationshipType() );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 2, count );\n    }","id":147,"modified_method":"private void validateNodeRel2( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( \"string2\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string2\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 2 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -2 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( false ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( true ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        \n        RelationshipChainPosition pos = rStore.getRelationshipChainPosition( node );\n        while ( true )\n        {\n            Iterable<RelationshipData> relData = rStore.getMoreRelationships( node, pos );\n            if ( !relData.iterator().hasNext() )\n            {\n                break;\n            }\n            for ( RelationshipData rel : relData )\n            {\n                if ( rel.getId() == rel1 )\n                {\n                    assertEquals( node, rel.secondNode() );\n                    assertEquals( relType1, rel.relationshipType() );\n                }\n                else if ( rel.getId() == rel2 )\n                {\n                    assertEquals( node, rel.firstNode() );\n                    assertEquals( relType2, rel.relationshipType() );\n                }\n                else\n                {\n                    throw new IOException();\n                }\n                count++;\n            }\n        }\n        assertEquals( 2, count );\n    }","commit_id":"62823c7dc285876e8e33becc0a878de345e86475","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void validateNodeRel1( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor( \n                    keyId ).getKey() );\n                assertEquals( \"string1\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string1\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 1 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -1 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( true ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( false ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = \n            rStore.getRelationshipChainPosition( node );\n        for ( RelationshipData rel : \n            rStore.getMoreRelationships( node, pos ) )\n        {\n            if ( rel.getId() == rel1 )\n            {\n                assertEquals( node, rel.firstNode() );\n                assertEquals( relType1, rel.relationshipType() );\n            }\n            else if ( rel.getId() == rel2 )\n            {\n                assertEquals( node, rel.secondNode() );\n                assertEquals( relType2, rel.relationshipType() );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 2, count );\n    }","id":148,"modified_method":"private void validateNodeRel1( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor( \n                    keyId ).getKey() );\n                assertEquals( \"string1\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string1\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 1 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -1 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( true ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( false ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = rStore.getRelationshipChainPosition( node );\n        while ( true )\n        {\n            Iterable<RelationshipData> relData = rStore.getMoreRelationships( node, pos );\n            if ( !relData.iterator().hasNext() )\n            {\n                break;\n            }\n            for ( RelationshipData rel : relData )\n            {\n                if ( rel.getId() == rel1 )\n                {\n                    assertEquals( node, rel.firstNode() );\n                    assertEquals( relType1, rel.relationshipType() );\n                }\n                else if ( rel.getId() == rel2 )\n                {\n                    assertEquals( node, rel.secondNode() );\n                    assertEquals( relType2, rel.relationshipType() );\n                }\n                else\n                {\n                    throw new IOException();\n                }\n                count++;\n            }\n        }\n        assertEquals( 2, count );\n    }","commit_id":"62823c7dc285876e8e33becc0a878de345e86475","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void validateNodeRel1( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor( \n                    keyId ).getKey() );\n                assertEquals( \"string1\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string1\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 1 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -1 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( true ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( false ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = \n            rStore.getRelationshipChainPosition( node );\n        for ( RelationshipData rel : \n            rStore.getMoreRelationships( node, pos ) )\n        {\n            if ( rel.getId() == rel1 )\n            {\n                assertEquals( node, rel.firstNode() );\n                assertEquals( relType1, rel.relationshipType() );\n            }\n            else if ( rel.getId() == rel2 )\n            {\n                assertEquals( node, rel.secondNode() );\n                assertEquals( relType2, rel.relationshipType() );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 2, count );\n    }","id":149,"modified_method":"private void validateNodeRel1( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor( \n                    keyId ).getKey() );\n                assertEquals( \"string1\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string1\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 1 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -1 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( true ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( false ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = rStore.getRelationshipChainPosition( node );\n        while ( true )\n        {\n            Iterable<RelationshipData> relData = rStore.getMoreRelationships( node, pos );\n            if ( !relData.iterator().hasNext() )\n            {\n                break;\n            }\n            for ( RelationshipData rel : relData )\n            {\n                if ( rel.getId() == rel1 )\n                {\n                    assertEquals( node, rel.firstNode() );\n                    assertEquals( relType1, rel.relationshipType() );\n                }\n                else if ( rel.getId() == rel2 )\n                {\n                    assertEquals( node, rel.secondNode() );\n                    assertEquals( relType2, rel.relationshipType() );\n                }\n                else\n                {\n                    throw new IOException();\n                }\n                count++;\n            }\n        }\n        assertEquals( 2, count );\n    }","commit_id":"40a99e5e725ec89b093d738d7d2ebce603db2a2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void validateNodeRel2( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( \"string2\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string2\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 2 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -2 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( false ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( true ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        RelationshipChainPosition pos = \n            rStore.getRelationshipChainPosition( node );\n        for ( RelationshipData rel : \n            rStore.getMoreRelationships( node, pos ) )\n        {\n            if ( rel.getId() == rel1 )\n            {\n                assertEquals( node, rel.secondNode() );\n                assertEquals( relType1, rel.relationshipType() );\n            }\n            else if ( rel.getId() == rel2 )\n            {\n                assertEquals( node, rel.firstNode() );\n                assertEquals( relType2, rel.relationshipType() );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 2, count );\n    }","id":150,"modified_method":"private void validateNodeRel2( int node, int prop1, int prop2, int prop3,\n        int rel1, int rel2, int relType1, int relType2 ) throws IOException\n    {\n        assertTrue( nStore.loadLightNode( node ) );\n        ArrayMap<Integer,PropertyData> props = nStore.getProperties( node, \n                false );\n        int count = 0;\n        for ( int keyId : props.keySet() )\n        {\n            int id = props.get( keyId ).getId();\n            PropertyRecord record = pStore.getRecord( id );\n            PropertyData data = new PropertyData( id, getValue( record ) );\n            if ( data.getId() == prop1 )\n            {\n                assertEquals( \"prop1\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( \"string2\", data.getValue() );\n                nStore.changeProperty( node, prop1, \"-string2\" );\n            }\n            else if ( data.getId() == prop2 )\n            {\n                assertEquals( \"prop2\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Integer( 2 ), data.getValue() );\n                nStore.changeProperty( node, prop2, new Integer( -2 ) );\n            }\n            else if ( data.getId() == prop3 )\n            {\n                assertEquals( \"prop3\", MyPropertyIndex.getIndexFor(\n                    keyId ).getKey() );\n                assertEquals( new Boolean( false ), data.getValue() );\n                nStore.changeProperty( node, prop3, new Boolean( true ) );\n            }\n            else\n            {\n                throw new IOException();\n            }\n            count++;\n        }\n        assertEquals( 3, count );\n        count = 0;\n        \n        RelationshipChainPosition pos = rStore.getRelationshipChainPosition( node );\n        while ( true )\n        {\n            Iterable<RelationshipData> relData = rStore.getMoreRelationships( node, pos );\n            if ( !relData.iterator().hasNext() )\n            {\n                break;\n            }\n            for ( RelationshipData rel : relData )\n            {\n                if ( rel.getId() == rel1 )\n                {\n                    assertEquals( node, rel.secondNode() );\n                    assertEquals( relType1, rel.relationshipType() );\n                }\n                else if ( rel.getId() == rel2 )\n                {\n                    assertEquals( node, rel.firstNode() );\n                    assertEquals( relType2, rel.relationshipType() );\n                }\n                else\n                {\n                    throw new IOException();\n                }\n                count++;\n            }\n        }\n        assertEquals( 2, count );\n    }","commit_id":"40a99e5e725ec89b093d738d7d2ebce603db2a2b","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * @see org.apache.sling.api.resource.ResourceProvider#listChildren(org.apache.sling.api.resource.Resource)\n     */\n    public Iterator<Resource> listChildren(final Resource parent) {\n        final String[] info = this.extractResourceInfo(parent.getPath());\n        if ( info != null ) {\n            if ( info.length == 0 ) {\n                // all collections\n                final Set<String> names = new HashSet<String>(context.getDatabase().getCollectionNames());\n                names.removeAll(this.context.getFilterCollectionNames());\n                final Iterator<String> i = names.iterator();\n                return new Iterator<Resource>() {\n\n                    public boolean hasNext() {\n                        return i.hasNext();\n                    }\n\n                    public Resource next() {\n                        final String name = i.next();\n                        return new MongoDBCollectionResource(parent.getResourceResolver(), parent.getPath() + '/' + name);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"remove\");\n                    }\n\n                };\n            }\n            if ( this.hasDatabase(info[0]) ) {\n                final DBCollection col = this.context.getDatabase().getCollection(info[0]);\n                if ( col != null ) {\n                    final String pattern;\n                    if ( info.length == 1 ) {\n                        pattern = \"^([^/])*$\";\n                    } else {\n                        pattern = \"^\" + Pattern.quote(info[1]) + \"/([^/])*$\";\n                    }\n\n                    final DBObject query = QueryBuilder.start(PROP_PATH).regex(Pattern.compile(pattern)).get();\n                    final DBCursor cur = col.find(query).\n                                    sort(BasicDBObjectBuilder.start(PROP_PATH, 1).get());\n                    return new Iterator<Resource>() {\n\n                        public boolean hasNext() {\n                            return cur.hasNext();\n                        }\n\n                        public Resource next() {\n                            final DBObject obj = cur.next();\n                            final String objPath = obj.get(PROP_PATH).toString();\n                            final int lastSlash = objPath.lastIndexOf('/');\n                            final String name;\n                            if (lastSlash == -1) {\n                                name = objPath;\n                            } else {\n                                name = objPath.substring(lastSlash + 1);\n                            }\n                            return new MongoDBResource(parent.getResourceResolver(),\n                                            parent.getPath() + '/' + name,\n                                            info[0],\n                                            obj,\n                                            MongoDBResourceProvider.this);\n                        }\n\n                        public void remove() {\n                            throw new UnsupportedOperationException(\"remove\");\n                        }\n\n                    };\n                }\n            }\n        }\n        return null;\n    }","id":151,"modified_method":"/**\n     * @see org.apache.sling.api.resource.ResourceProvider#listChildren(org.apache.sling.api.resource.Resource)\n     */\n    public Iterator<Resource> listChildren(final Resource parent) {\n        final String[] info = this.extractResourceInfo(parent.getPath());\n        if ( info != null ) {\n            if ( info.length == 0 ) {\n                // all collections\n                final Set<String> names = new HashSet<String>(context.getDatabase().getCollectionNames());\n                names.removeAll(this.context.getFilterCollectionNames());\n                final Iterator<String> i = names.iterator();\n                return new Iterator<Resource>() {\n\n                    public boolean hasNext() {\n                        return i.hasNext();\n                    }\n\n                    public Resource next() {\n                        final String name = i.next();\n                        return new MongoDBCollectionResource(parent.getResourceResolver(), parent.getPath() + '/' + name);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"remove\");\n                    }\n\n                };\n            }\n            final DBCollection col = this.getCollection(info[0]);\n            if ( col != null ) {\n                final String pattern;\n                if ( info.length == 1 ) {\n                    pattern = \"^([^/])*$\";\n                } else {\n                    pattern = \"^\" + Pattern.quote(info[1]) + \"/([^/])*$\";\n                }\n\n                final DBObject query = QueryBuilder.start(PROP_PATH).regex(Pattern.compile(pattern)).get();\n                final DBCursor cur = col.find(query).\n                                sort(BasicDBObjectBuilder.start(PROP_PATH, 1).get());\n                return new Iterator<Resource>() {\n\n                    public boolean hasNext() {\n                        return cur.hasNext();\n                    }\n\n                    public Resource next() {\n                        final DBObject obj = cur.next();\n                        final String objPath = obj.get(PROP_PATH).toString();\n                        final int lastSlash = objPath.lastIndexOf('/');\n                        final String name;\n                        if (lastSlash == -1) {\n                            name = objPath;\n                        } else {\n                            name = objPath.substring(lastSlash + 1);\n                        }\n                        return new MongoDBResource(parent.getResourceResolver(),\n                                        parent.getPath() + '/' + name,\n                                        info[0],\n                                        obj,\n                                        MongoDBResourceProvider.this);\n                    }\n\n                    public void remove() {\n                        throw new UnsupportedOperationException(\"remove\");\n                    }\n\n                };\n            }\n        }\n        return null;\n    }","commit_id":"f255a27b307d22fea7deee54755b00c5e5781a89","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.api.resource.ModifyingResourceProvider#commit()\n     */\n    public void commit() throws PersistenceException {\n        try {\n            for(final String deleted : this.deletedResources) {\n                final String[] info = this.extractResourceInfo(deleted);\n\n                // check if the database still exists\n                if ( this.hasDatabase(info[0]) ) {\n                    final DBCollection col = this.context.getDatabase().getCollection(info[0]);\n                    if ( col != null ) {\n                        col.findAndRemove(QueryBuilder.start(PROP_PATH).is(info[1]).get());\n                    }\n                }\n            }\n            for(final MongoDBResource changed : this.changedResources.values()) {\n\n                final DBCollection col = this.context.getDatabase().getCollection(changed.getCollection());\n                if ( col != null ) {\n                    // create or update?\n                    if ( changed.getProperties().get(PROP_ID) != null ) {\n                        col.update(QueryBuilder.start(PROP_PATH).is(changed.getProperties().get(PROP_PATH)).get(),\n                                        changed.getProperties());\n                    } else {\n                        // create\n                        col.save(changed.getProperties());\n                    }\n                } else {\n                    throw new PersistenceException(\"Unable to create collection \" + changed.getCollection(), null, changed.getPath(), null);\n                }\n            }\n        } finally {\n            this.revert();\n        }\n    }","id":152,"modified_method":"/**\n     * @see org.apache.sling.api.resource.ModifyingResourceProvider#commit()\n     */\n    public void commit() throws PersistenceException {\n        try {\n            for(final String deleted : this.deletedResources) {\n                final String[] info = this.extractResourceInfo(deleted);\n\n                // check if the collection still exists\n                final DBCollection col = this.getCollection(info[0]);\n                if ( col != null ) {\n                    col.findAndRemove(QueryBuilder.start(PROP_PATH).is(info[1]).get());\n                }\n            }\n            for(final MongoDBResource changed : this.changedResources.values()) {\n\n                final DBCollection col = this.context.getDatabase().getCollection(changed.getCollection());\n                if ( col != null ) {\n                    // create or update?\n                    if ( changed.getProperties().get(PROP_ID) != null ) {\n                        col.update(QueryBuilder.start(PROP_PATH).is(changed.getProperties().get(PROP_PATH)).get(),\n                                        changed.getProperties());\n                    } else {\n                        // create\n                        col.save(changed.getProperties());\n                    }\n                } else {\n                    throw new PersistenceException(\"Unable to create collection \" + changed.getCollection(), null, changed.getPath(), null);\n                }\n            }\n        } finally {\n            this.revert();\n        }\n    }","commit_id":"f255a27b307d22fea7deee54755b00c5e5781a89","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Create a resource\n     */\n    private Resource getResource(final ResourceResolver resourceResolver, final String path, final String[] info) {\n        if ( info.length == 0 ) {\n            // special resource : all collections\n            return new MongoDBCollectionResource(resourceResolver, path);\n        } else if ( info.length == 1 ) {\n            // special resource : collection\n            if ( this.hasDatabase(info[0]) ) {\n                return new MongoDBCollectionResource(resourceResolver, path);\n            }\n            return null;\n        }\n        logger.info(\"Searching {} in {}\", info[1], info[0]);\n        if ( this.hasDatabase(info[0]) ) {\n            final DBCollection col = this.context.getDatabase().getCollection(info[0]);\n            if ( col != null ) {\n                final DBObject obj = col.findOne(QueryBuilder.start(PROP_PATH).is(info[1]).get());\n                logger.info(\"Result={}\", obj);\n                if ( obj != null ) {\n                    return new MongoDBResource(resourceResolver,\n                                    path,\n                                    info[0],\n                                    obj,\n                                    this);\n                }\n            }\n        }\n        return null;\n    }","id":153,"modified_method":"/**\n     * Get a resource\n     */\n    private Resource getResource(final ResourceResolver resourceResolver, final String path, final String[] info) {\n        if ( info.length == 0 ) {\n            // special resource : all collections\n            return new MongoDBCollectionResource(resourceResolver, path);\n        } else if ( info.length == 1 ) {\n            // special resource : collection\n            if ( this.hasCollection(info[0]) ) {\n                return new MongoDBCollectionResource(resourceResolver, path);\n            }\n            return null;\n        }\n        logger.debug(\"Searching {} in {}\", info[1], info[0]);\n        final DBCollection col = this.getCollection(info[0]);\n        if ( col != null ) {\n            final DBObject obj = col.findOne(QueryBuilder.start(PROP_PATH).is(info[1]).get());\n            logger.debug(\"Found {}\", obj);\n            if ( obj != null ) {\n                return new MongoDBResource(resourceResolver,\n                                path,\n                                info[0],\n                                obj,\n                                this);\n            }\n        }\n\n        return null;\n    }","commit_id":"f255a27b307d22fea7deee54755b00c5e5781a89","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected void doDispatch(MuleEvent event) throws Exception\n    {\n        JobConfig jobConfig = (JobConfig) endpoint.getProperty(QuartzConnector.PROPERTY_JOB_CONFIG);\n        if (jobConfig == null)\n        {\n            throw new IllegalArgumentException(CoreMessages.objectIsNull(QuartzConnector.PROPERTY_JOB_CONFIG).getMessage());\n        }\n\n        JobDetail jobDetail = new JobDetail();\n        // make the job name unique per endpoint (MULE-753)\n        jobDetail.setName(endpoint.getEndpointURI().getAddress() + \"-\" + event.getId());\n\n        JobDataMap jobDataMap = new JobDataMap();\n        jobDataMap.put(QuartzConnector.PROPERTY_JOB_DYNAMIC, Boolean.TRUE);\n        MuleMessage msg = event.getMessage();\n        // populate from invocation and outbound scopes only\n        for (String key : msg.getInvocationPropertyNames())\n        {\n            jobDataMap.put(key, msg.getInvocationProperty(key));\n        }\n        for (String key : msg.getOutboundPropertyNames())\n        {\n            jobDataMap.put(key, msg.getOutboundProperty(key));\n        }\n\n        if (jobConfig instanceof ScheduledDispatchJobConfig) \n        {\n            ScheduledDispatchJobConfig scheduledDispatchJobConfig = (ScheduledDispatchJobConfig) jobConfig;\n            String endpointRef = event.getMuleContext()\n                .getExpressionManager()\n                .parse(scheduledDispatchJobConfig.getEndpointRef(), event);\n\n            jobDataMap.put(\"endpointRef\", endpointRef);\n        }\n        jobDetail.setJobDataMap(jobDataMap);\n\n        Job job = null;\n        // work out what we're actually calling\n        Object payload = event.getMessage().getPayload();\n\n        if(jobConfig instanceof CustomJobConfig)\n        {\n            job = ((CustomJobConfig) jobConfig).getJob();\n        }\n        else if(jobConfig instanceof CustomJobFromMessageConfig)\n        {\n            job = ((CustomJobFromMessageConfig) jobConfig).getJob(msg);\n            //rewrite the jobConfig to the real Jobconfig on the message\n            jobConfig = ((CustomJobFromMessageConfig) jobConfig).getJobConfig(msg);\n        }\n\n        jobDataMap.put(QuartzConnector.PROPERTY_JOB_CONFIG, jobConfig);        \n        jobDetail.setJobClass(jobConfig.getJobClass());\n        // If there has been a job created or found then we default to a customJob configuration\n        if (job != null)\n        {\n            jobDataMap.put(QuartzConnector.PROPERTY_JOB_OBJECT, job);\n            jobDetail.setJobClass(CustomJob.class);\n        }\n       \n        // The payload will be ignored by the CustomJob - don't know why we need it here\n        //RM: The custom job may want the message and the Job type may not be delegating job\n        jobDataMap.put(QuartzConnector.PROPERTY_PAYLOAD, payload);\n\n        Trigger trigger;\n        String cronExpression = jobDataMap.getString(QuartzConnector.PROPERTY_CRON_EXPRESSION);\n        String repeatInterval = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_INTERVAL);\n        String repeatCount = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_COUNT);\n        String startDelay = jobDataMap.getString(QuartzConnector.PROPERTY_START_DELAY);\n        String groupName = jobConfig.getGroupName();\n        String jobGroupName = jobConfig.getJobGroupName();\n\n        if (groupName == null)\n        {\n            groupName = QuartzConnector.DEFAULT_GROUP_NAME;\n        }\n        if (jobGroupName == null)\n        {\n            jobGroupName = groupName;\n        }\n\n        jobDetail.setGroup(groupName);\n\n        if (cronExpression != null)\n        {\n            CronTrigger ctrigger = new CronTrigger();\n            ctrigger.setCronExpression(cronExpression);\n            trigger = ctrigger;\n        }\n        else if (repeatInterval != null)\n        {\n            SimpleTrigger strigger = new SimpleTrigger();\n            strigger.setRepeatInterval(Long.parseLong(repeatInterval));\n            if (repeatCount != null)\n            {\n                strigger.setRepeatCount(Integer.parseInt(repeatCount));\n            }\n            else\n            {\n                strigger.setRepeatCount(-1);\n            }\n            trigger = strigger;\n        }\n        else\n        {\n            throw new IllegalArgumentException(\n                QuartzMessages.cronExpressionOrIntervalMustBeSet().getMessage());\n        }\n        trigger.setName(endpoint.getEndpointURI().toString() + \"-\" + event.getId());\n        trigger.setGroup(groupName);\n        trigger.setJobName(jobDetail.getName());\n        trigger.setJobGroup(jobGroupName);\n\n        Scheduler scheduler = ((QuartzConnector) this.getConnector()).getQuartzScheduler();\n\n        // Minimize the the time window capturing the start time and scheduling the job.\n        long start = System.currentTimeMillis();\n        if (startDelay != null)\n        {\n            start += Long.parseLong(startDelay);\n        }\n        trigger.setStartTime(new Date(start));\n\n        scheduler.scheduleJob(jobDetail, trigger);\n    }","id":154,"modified_method":"@Override\n    protected void doDispatch(MuleEvent event) throws Exception\n    {\n        JobConfig jobConfig = (JobConfig) endpoint.getProperty(QuartzConnector.PROPERTY_JOB_CONFIG);\n        if (jobConfig == null)\n        {\n            throw new IllegalArgumentException(CoreMessages.objectIsNull(QuartzConnector.PROPERTY_JOB_CONFIG).getMessage());\n        }\n\n\n        JobDataMap jobDataMap = new JobDataMap();\n        jobDataMap.put(QuartzConnector.PROPERTY_JOB_DYNAMIC, Boolean.TRUE);\n        MuleMessage msg = event.getMessage();\n        // populate from invocation and outbound scopes only\n        for (String key : msg.getInvocationPropertyNames())\n        {\n            jobDataMap.put(key, msg.getInvocationProperty(key));\n        }\n        for (String key : msg.getOutboundPropertyNames())\n        {\n            jobDataMap.put(key, msg.getOutboundProperty(key));\n        }\n\n        if (jobConfig instanceof ScheduledDispatchJobConfig) \n        {\n            ScheduledDispatchJobConfig scheduledDispatchJobConfig = (ScheduledDispatchJobConfig) jobConfig;\n            String endpointRef = event.getMuleContext()\n                .getExpressionManager()\n                .parse(scheduledDispatchJobConfig.getEndpointRef(), event);\n\n            jobDataMap.put(\"endpointRef\", endpointRef);\n        }\n\n        Job job = null;\n        // work out what we're actually calling\n        Object payload = event.getMessage().getPayload();\n\n        if(jobConfig instanceof CustomJobConfig)\n        {\n            job = ((CustomJobConfig) jobConfig).getJob();\n        }\n        else if(jobConfig instanceof CustomJobFromMessageConfig)\n        {\n            job = ((CustomJobFromMessageConfig) jobConfig).getJob(msg);\n            //rewrite the jobConfig to the real Jobconfig on the message\n            jobConfig = ((CustomJobFromMessageConfig) jobConfig).getJobConfig(msg);\n        }\n\n        jobDataMap.put(QuartzConnector.PROPERTY_JOB_CONFIG, jobConfig);\n        Class<? extends Job> jobClass = jobConfig.getJobClass();\n        // If there has been a job created or found then we default to a customJob configuration\n        if (job != null)\n        {\n            jobDataMap.put(QuartzConnector.PROPERTY_JOB_OBJECT, job);\n            jobClass = CustomJob.class;\n        }\n       \n        // The payload will be ignored by the CustomJob - don't know why we need it here\n        //RM: The custom job may want the message and the Job type may not be delegating job\n        jobDataMap.put(QuartzConnector.PROPERTY_PAYLOAD, payload);\n\n        String cronExpression = jobDataMap.getString(QuartzConnector.PROPERTY_CRON_EXPRESSION);\n        String repeatInterval = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_INTERVAL);\n        String repeatCount = jobDataMap.getString(QuartzConnector.PROPERTY_REPEAT_COUNT);\n        String startDelay = jobDataMap.getString(QuartzConnector.PROPERTY_START_DELAY);\n        String groupName = jobConfig.getGroupName();\n        String jobGroupName = jobConfig.getJobGroupName();\n\n        if (groupName == null)\n        {\n            groupName = QuartzConnector.DEFAULT_GROUP_NAME;\n        }\n        if (jobGroupName == null)\n        {\n            jobGroupName = groupName;\n        }\n\n        JobDetail jobDetail = newJob(jobClass)\n            // make the job name unique per endpoint (MULE-753)\n            .withIdentity(endpoint.getEndpointURI().getAddress() + \"-\" + event.getId(), groupName)\n            .usingJobData(jobDataMap)\n                .build();\n\n        TriggerBuilder triggerBuilder = newTrigger()\n            .withIdentity(endpoint.getEndpointURI().toString() + \"-\" + event.getId(), groupName)\n            .forJob(jobDetail.getKey().getName(), jobGroupName);\n\n        if (cronExpression != null)\n        {\n            triggerBuilder.withSchedule(cronSchedule(cronExpression));\n        }\n        else if (repeatInterval != null)\n        {\n            triggerBuilder.withSchedule(simpleSchedule()\n                .withIntervalInMilliseconds(Long.parseLong(repeatInterval))\n                .withRepeatCount(repeatCount != null ? Integer.parseInt(repeatCount) : SimpleTrigger.REPEAT_INDEFINITELY));\n        }\n        else\n        {\n            throw new IllegalArgumentException(\n                QuartzMessages.cronExpressionOrIntervalMustBeSet().getMessage());\n        }\n\n        Scheduler scheduler = ((QuartzConnector) this.getConnector()).getQuartzScheduler();\n\n        // Minimize the the time window capturing the start time and scheduling the job.\n        long start = System.currentTimeMillis();\n        if (startDelay != null)\n        {\n            start += Long.parseLong(startDelay);\n        }\n        triggerBuilder.startAt(new Date(start));\n\n        scheduler.scheduleJob(jobDetail, triggerBuilder.build());\n    }","commit_id":"89f3b2b1db0f45eb24fdcc28195d9d96eec2c73d","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    protected void doStart() throws MuleException\n    {\n        try\n        {\n            Scheduler scheduler = connector.getQuartzScheduler();\n\n            JobConfig jobConfig = (JobConfig) endpoint.getProperty(QuartzConnector.PROPERTY_JOB_CONFIG);\n            if (jobConfig == null)\n            {\n                throw new IllegalArgumentException(CoreMessages.objectIsNull(QuartzConnector.PROPERTY_JOB_CONFIG).getMessage());\n            }\n\n            JobDetail jobDetail = new JobDetail();\n            jobDetail.setName(endpoint.getEndpointURI().getAddress());\n            Class<? extends Job> jobClass = jobConfig.getJobClass();\n            jobDetail.setJobClass(jobClass);\n            isStateful = StatefulJob.class.isAssignableFrom(jobClass);\n            JobDataMap jobDataMap = new JobDataMap();\n            jobDataMap.put(QUARTZ_RECEIVER_PROPERTY, this.getReceiverKey());\n            jobDataMap.put(QUARTZ_CONNECTOR_PROPERTY, this.connector.getName());\n            jobDataMap.putAll(endpoint.getProperties());\n\n            if (jobConfig instanceof EventGeneratorJobConfig)\n            {\n                jobDataMap.put(QuartzConnector.PROPERTY_PAYLOAD, ((EventGeneratorJobConfig) jobConfig).getPayload());\n            }\n            jobDataMap.put(QuartzConnector.PROPERTY_JOB_CONFIG, jobConfig);\n\n            Job job = null;\n            if (jobConfig instanceof CustomJobConfig)\n            {\n                job = ((CustomJobConfig) jobConfig).getJob();\n            }\n            // If there has been a job created or found then we default to a custom Job configuration\n            if (job != null)\n            {\n                jobDataMap.put(QuartzConnector.PROPERTY_JOB_OBJECT, job);\n                jobDetail.setJobClass(jobClass);\n            }\n\n            jobDetail.setJobDataMap(jobDataMap);\n\n            Trigger trigger;\n            String cronExpression = (String)endpoint.getProperty(QuartzConnector.PROPERTY_CRON_EXPRESSION);\n            String repeatInterval = (String)endpoint.getProperty(QuartzConnector.PROPERTY_REPEAT_INTERVAL);\n            String repeatCount = (String)endpoint.getProperty(QuartzConnector.PROPERTY_REPEAT_COUNT);\n            String startDelay = (String)endpoint.getProperty(QuartzConnector.PROPERTY_START_DELAY);\n            String groupName = jobConfig.getGroupName();\n            String jobGroupName = jobConfig.getJobGroupName();\n\n            if (groupName == null)\n            {\n                groupName = QuartzConnector.DEFAULT_GROUP_NAME;\n            }\n            if (jobGroupName == null)\n            {\n                jobGroupName = groupName;\n            }\n\n            jobDetail.setGroup(groupName);\n\n            if (cronExpression != null)\n            {\n                CronTrigger ctrigger = new CronTrigger();\n                ctrigger.setCronExpression(cronExpression);\n                trigger = ctrigger;\n            }\n            else if (repeatInterval != null)\n            {\n                SimpleTrigger strigger = new SimpleTrigger();\n                strigger.setRepeatInterval(Long.parseLong(repeatInterval));\n                if (repeatCount != null)\n                {\n                    strigger.setRepeatCount(Integer.parseInt(repeatCount));\n                }\n                else\n                {\n                    strigger.setRepeatCount(-1);\n                }\n                trigger = strigger;\n            }\n            else\n            {\n                throw new IllegalArgumentException(\n                        QuartzMessages.cronExpressionOrIntervalMustBeSet().getMessage());\n            }\n\n            trigger.setName(endpoint.getEndpointURI().getAddress());\n            trigger.setGroup(groupName);\n            trigger.setJobName(endpoint.getEndpointURI().getAddress());\n            trigger.setJobGroup(jobGroupName);\n\n            // Minimize the the time window capturing the start time and scheduling the job.\n            long start = System.currentTimeMillis();\n            if (startDelay != null)\n            {\n                start += Long.parseLong(startDelay);\n            }\n            trigger.setStartTime(new Date(start));\n\n            // We need to handle cases when the job has already been persisted\n            try\n            {\n                scheduler.scheduleJob(jobDetail, trigger);\n            }\n            catch (ObjectAlreadyExistsException oaee)\n            {\n                logger.warn(\"A quartz Job with name: \" + endpoint.getEndpointURI().getAddress() +\n                        \" has already been registered. Cannot register again\");\n            }\n        }\n        catch (Exception e)\n        {\n            throw new EndpointException(CoreMessages.failedToStart(\"Quartz receiver\"), e);\n        }\n    }","id":155,"modified_method":"@Override\n    protected void doStart() throws MuleException\n    {\n        try\n        {\n            Scheduler scheduler = connector.getQuartzScheduler();\n\n            JobConfig jobConfig = (JobConfig) endpoint.getProperty(QuartzConnector.PROPERTY_JOB_CONFIG);\n            if (jobConfig == null)\n            {\n                throw new IllegalArgumentException(CoreMessages.objectIsNull(QuartzConnector.PROPERTY_JOB_CONFIG).getMessage());\n            }\n\n            Class<? extends Job> jobClass = jobConfig.getJobClass();\n            JobBuilder jobBuilder = newJob(jobClass);\n            isStateful = StatefulJob.class.isAssignableFrom(jobClass);\n            JobDataMap jobDataMap = new JobDataMap();\n            jobDataMap.put(QUARTZ_RECEIVER_PROPERTY, this.getReceiverKey());\n            jobDataMap.put(QUARTZ_CONNECTOR_PROPERTY, this.connector.getName());\n            jobDataMap.putAll(endpoint.getProperties());\n\n            if (jobConfig instanceof EventGeneratorJobConfig)\n            {\n                jobDataMap.put(QuartzConnector.PROPERTY_PAYLOAD, ((EventGeneratorJobConfig) jobConfig).getPayload());\n            }\n            jobDataMap.put(QuartzConnector.PROPERTY_JOB_CONFIG, jobConfig);\n\n            Job job = null;\n            if (jobConfig instanceof CustomJobConfig)\n            {\n                job = ((CustomJobConfig) jobConfig).getJob();\n            }\n            // If there has been a job created or found then we default to a custom Job configuration\n            if (job != null)\n            {\n                jobDataMap.put(QuartzConnector.PROPERTY_JOB_OBJECT, job);\n            }\n\n            jobBuilder.usingJobData(jobDataMap);\n\n            String cronExpression = (String)endpoint.getProperty(QuartzConnector.PROPERTY_CRON_EXPRESSION);\n            String repeatInterval = (String)endpoint.getProperty(QuartzConnector.PROPERTY_REPEAT_INTERVAL);\n            String repeatCount = (String)endpoint.getProperty(QuartzConnector.PROPERTY_REPEAT_COUNT);\n            String startDelay = (String)endpoint.getProperty(QuartzConnector.PROPERTY_START_DELAY);\n            String groupName = jobConfig.getGroupName();\n            String jobGroupName = jobConfig.getJobGroupName();\n\n            if (groupName == null)\n            {\n                groupName = QuartzConnector.DEFAULT_GROUP_NAME;\n            }\n            if (jobGroupName == null)\n            {\n                jobGroupName = groupName;\n            }\n\n            jobBuilder.withIdentity(endpoint.getEndpointURI().getAddress(), groupName);\n\n            TriggerBuilder triggerBuilder = newTrigger()\n                    .withIdentity(endpoint.getEndpointURI().getAddress(), groupName)\n                    .forJob(endpoint.getEndpointURI().getAddress(), jobGroupName);\n\n            if (cronExpression != null)\n            {\n                triggerBuilder.withSchedule(cronSchedule(cronExpression));\n            }\n            else if (repeatInterval != null)\n            {\n                triggerBuilder.withSchedule(simpleSchedule()\n                    .withIntervalInMilliseconds(Long.parseLong(repeatInterval))\n                    .withRepeatCount(repeatCount != null ? Integer.parseInt(repeatCount) : SimpleTrigger.REPEAT_INDEFINITELY));\n            }\n            else\n            {\n                throw new IllegalArgumentException(\n                        QuartzMessages.cronExpressionOrIntervalMustBeSet().getMessage());\n            }\n\n\n            // Minimize the the time window capturing the start time and scheduling the job.\n            long start = System.currentTimeMillis();\n            if (startDelay != null)\n            {\n                start += Long.parseLong(startDelay);\n            }\n            triggerBuilder.startAt(new Date(start));\n\n            // We need to handle cases when the job has already been persisted\n            try\n            {\n                scheduler.scheduleJob(jobBuilder.build(), triggerBuilder.build());\n            }\n            catch (ObjectAlreadyExistsException oaee)\n            {\n                logger.warn(\"A quartz Job with name: \" + endpoint.getEndpointURI().getAddress() +\n                        \" has already been registered. Cannot register again\");\n            }\n        }\n        catch (Exception e)\n        {\n            throw new EndpointException(CoreMessages.failedToStart(\"Quartz receiver\"), e);\n        }\n    }","commit_id":"89f3b2b1db0f45eb24fdcc28195d9d96eec2c73d","url":"https://github.com/mulesoft/mule"},{"original_method":"private void changeText() {\n    String replacement = (String)suggestionList.getSelectedValue();\n    XText text = xTextDoc.getText();\n    XTextCursor cursor = text.createTextCursor();\n    cursor.gotoStart(false);\n    cursor.goRight((short)(currentRuleMatch.getFromPos()-replacementCorrection), false);\n    // FIXME: what if cast fails?\n    short errorLength = (short)(currentRuleMatch.getToPos()-currentRuleMatch.getFromPos());\n    //System.err.println(text.getString().replaceAll(\"\\n\", \"#\\n\"));\n    //System.err.println(currentRuleMatch.getFromPos() + \", len=\"+errorLength);\n    cursor.goRight(errorLength, true);\n    cursor.setString(replacement);\n    replacementCorrection += errorLength - replacement.length();\n    gotoNextMatch();\n  }","id":156,"modified_method":"private void changeText() {\n    String replacement = (String)suggestionList.getSelectedValue();\n    XText text = xTextDoc.getText();\n    // FIXME: what if cast fails?\n    short errorLength = (short)(currentRuleMatch.getToPos()-currentRuleMatch.getFromPos());\n    if (xViewCursor == null) {\n      // working on complete text:\n      XTextCursor cursor = text.createTextCursor();\n      cursor.gotoStart(false);\n      cursor.goRight((short)(currentRuleMatch.getFromPos()-replacementCorrection), false);\n      cursor.goRight(errorLength, true);\n      cursor.setString(replacement);\n    } else {\n      // working on selected text only:\n      if (startTextRange == null) {\n        startTextRange = xViewCursor.getStart();\n      }\n      xViewCursor.gotoRange(startTextRange, false);\n      xViewCursor.goRight((short)(currentRuleMatch.getFromPos()-replacementCorrection), false);\n      xViewCursor.goRight((short)errorLength, true);\n      xViewCursor.setString(replacement);\n    }\n    replacementCorrection += errorLength - replacement.length();\n    gotoNextMatch();\n  }","commit_id":"158ed8579c470a9f1ec46301180dc1d6fa9337e8","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void showError(int i) {\n    RuleMatch match = (RuleMatch) ruleMatches.get(i);\n    currentRuleMatch = match;\n    currentRuleMatchPos = i;\n    String msg = match.getMessage();\n    StringBuffer sb = new StringBuffer();\n    if (ruleMatches.size() == 1)\n      sb.append(ruleMatches.size() + \" match in total\");\n    else\n      sb.append(ruleMatches.size() + \" matches in total\");\n    sb.append(\"<br>\\n<br>\\n<b>\" +(i+1)+ \".<\/b> \");\n    sb.append(\"<b>Match:<\/b> \");\n    sb.append(msg);\n    sb.append(\"<br>\\n\");\n    contextArea.setText(Tools.getContext(match.getFromPos(), match.getToPos(), text));\n    messageArea.setText(sb.toString());\n    setSuggestions();\n    // Place visible cursor on the error:\n    if (xTextDoc != null) {\n      XModel xModel = (XModel)UnoRuntime.queryInterface(XModel.class, xTextDoc); \n      XController xController = xModel.getCurrentController(); \n      XTextViewCursorSupplier xViewCursorSupplier = (XTextViewCursorSupplier)UnoRuntime.queryInterface(XTextViewCursorSupplier.class, xController); \n      XTextViewCursor xViewCursor = xViewCursorSupplier.getViewCursor();\n      xViewCursor.gotoStart(false);\n      int errorLength = currentRuleMatch.getToPos() - currentRuleMatch.getFromPos();\n      xViewCursor.goRight((short)(currentRuleMatch.getFromPos()-replacementCorrection), false);\n      xViewCursor.goRight((short)errorLength, true);\n    }\n  }","id":157,"modified_method":"private void showError(int i) {\n    RuleMatch match = (RuleMatch) ruleMatches.get(i);\n    currentRuleMatch = match;\n    currentRuleMatchPos = i;\n    String msg = match.getMessage();\n    StringBuffer sb = new StringBuffer();\n    if (ruleMatches.size() == 1)\n      sb.append(ruleMatches.size() + \" match in total\");\n    else\n      sb.append(ruleMatches.size() + \" matches in total\");\n    sb.append(\"<br>\\n<br>\\n<b>\" +(i+1)+ \".<\/b> \");\n    sb.append(\"<b>Match:<\/b> \");\n    sb.append(msg);\n    sb.append(\"<br>\\n\");\n    contextArea.setText(Tools.getContext(match.getFromPos(), match.getToPos(), text));\n    messageArea.setText(sb.toString());\n    setSuggestions();\n    // Place visible cursor on the error:\n    if (xTextDoc != null) {\n      XModel xModel = (XModel)UnoRuntime.queryInterface(XModel.class, xTextDoc); \n      XController xController = xModel.getCurrentController(); \n      XTextViewCursorSupplier xViewCursorSupplier = \n        (XTextViewCursorSupplier)UnoRuntime.queryInterface(XTextViewCursorSupplier.class, xController); \n      int errorLength = currentRuleMatch.getToPos() - currentRuleMatch.getFromPos();\n      if (xViewCursor == null) {\n        // working on complete text:\n        XTextViewCursor tmpxViewCursor = xViewCursorSupplier.getViewCursor();\n        tmpxViewCursor.gotoStart(false);\n        tmpxViewCursor.goRight((short)(currentRuleMatch.getFromPos()-replacementCorrection), false);\n        tmpxViewCursor.goRight((short)errorLength, true);\n      } else {\n        // working on selected text only:\n        if (startTextRange == null) {\n          startTextRange = xViewCursor.getStart();\n        }\n        xViewCursor.gotoRange(startTextRange, false);\n        xViewCursor.goRight((short)(currentRuleMatch.getFromPos()-replacementCorrection), false);\n        xViewCursor.goRight((short)errorLength, true);\n      }\n    }\n  }","commit_id":"158ed8579c470a9f1ec46301180dc1d6fa9337e8","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public Object loadResult(\n\t\tboolean entityCacheEnabled, Class<?> classObj,\n\t\tSerializable primaryKeyObj, SessionFactory sessionFactory) {\n\n\t\tif (!PropsValues.VALUE_OBJECT_ENTITY_CACHE_ENABLED ||\n\t\t\t!entityCacheEnabled || !CacheRegistry.isActive()) {\n\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = sessionFactory.openSession();\n\n\t\t\t\treturn session.load(classObj, primaryKeyObj);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsessionFactory.closeSession(session);\n\t\t\t}\n\t\t}\n\n\t\tMap<String, Object> localCache = _localCache.get();\n\n\t\tString localCacheKey = _encodeLocalCacheKey(classObj, primaryKeyObj);\n\n\t\tObject result = localCache.get(localCacheKey);\n\n\t\tif (result == null) {\n\t\t\tPortalCache portalCache = _getPortalCache(classObj.getName());\n\n\t\t\tString cacheKey = _encodeCacheKey(primaryKeyObj);\n\n\t\t\tresult = _multiVMPool.get(portalCache, cacheKey);\n\n\t\t\tif (result == null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Load \" + classObj + \" \" + primaryKeyObj +\n\t\t\t\t\t\t\t\" from session\");\n\t\t\t\t}\n\n\t\t\t\tSession session = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tsession = sessionFactory.openSession();\n\n\t\t\t\t\tresult = session.load(classObj, primaryKeyObj);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\tresult = StringPool.BLANK;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = _objectToResult(result);\n\n\t\t\t\t\t_multiVMPool.put(portalCache, cacheKey, result);\n\n\t\t\t\t\tsessionFactory.closeSession(session);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlocalCache.put(localCacheKey, result);\n\t\t}\n\n\t\tresult = _objectToResult(result);\n\n\t\treturn result;\n\t}","id":158,"modified_method":"public Object loadResult(\n\t\tboolean entityCacheEnabled, Class<?> classObj,\n\t\tSerializable primaryKeyObj, SessionFactory sessionFactory) {\n\n\t\tif (!PropsValues.VALUE_OBJECT_ENTITY_CACHE_ENABLED ||\n\t\t\t!entityCacheEnabled || !CacheRegistry.isActive()) {\n\n\t\t\tSession session = null;\n\n\t\t\ttry {\n\t\t\t\tsession = sessionFactory.openSession();\n\n\t\t\t\treturn session.load(classObj, primaryKeyObj);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tsessionFactory.closeSession(session);\n\t\t\t}\n\t\t}\n\n\t\tObject result = null;\n\n\t\tMap<String, Object> localCache = null;\n\n\t\tString localCacheKey = null;\n\n\t\tif (_localCacheEnabled) {\n\t\t\tlocalCache = _localCache.get();\n\n\t\t\tlocalCacheKey = _encodeLocalCacheKey(classObj, primaryKeyObj);\n\n\t\t\tresult = localCache.get(localCacheKey);\n\t\t}\n\n\t\tif (result == null) {\n\t\t\tPortalCache portalCache = _getPortalCache(classObj.getName());\n\n\t\t\tString cacheKey = _encodeCacheKey(primaryKeyObj);\n\n\t\t\tresult = _multiVMPool.get(portalCache, cacheKey);\n\n\t\t\tif (result == null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Load \" + classObj + \" \" + primaryKeyObj +\n\t\t\t\t\t\t\t\" from session\");\n\t\t\t\t}\n\n\t\t\t\tSession session = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tsession = sessionFactory.openSession();\n\n\t\t\t\t\tresult = session.load(classObj, primaryKeyObj);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\tresult = StringPool.BLANK;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = _objectToResult(result);\n\n\t\t\t\t\t_multiVMPool.put(portalCache, cacheKey, result);\n\n\t\t\t\t\tsessionFactory.closeSession(session);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_localCacheEnabled) {\n\t\t\t\tlocalCache.put(localCacheKey, result);\n\t\t\t}\n\t\t}\n\n\t\tresult = _objectToResult(result);\n\n\t\treturn result;\n\t}","commit_id":"625f722980f6eb48f6eda0cd1d172a833890140a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object getResult(\n\t\tboolean entityCacheEnabled, Class<?> classObj,\n\t\tSerializable primaryKeyObj, SessionFactory sessionFactory) {\n\n\t\tif (!PropsValues.VALUE_OBJECT_ENTITY_CACHE_ENABLED ||\n\t\t\t!entityCacheEnabled || !CacheRegistry.isActive()) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, Object> localCache = _localCache.get();\n\n\t\tString localCacheKey = _encodeLocalCacheKey(classObj, primaryKeyObj);\n\n\t\tObject result = localCache.get(localCacheKey);\n\n\t\tif (result == null) {\n\t\t\tPortalCache portalCache = _getPortalCache(classObj.getName());\n\n\t\t\tString cacheKey = _encodeCacheKey(primaryKeyObj);\n\n\t\t\tresult = _multiVMPool.get(portalCache, cacheKey);\n\n\t\t\tif (result == null) {\n\t\t\t\tresult = StringPool.BLANK;\n\n\t\t\t\t_multiVMPool.put(portalCache, cacheKey, result);\n\t\t\t}\n\n\t\t\tlocalCache.put(localCacheKey, result);\n\t\t}\n\n\t\tif (result != null) {\n\t\t\tresult = _objectToResult(result);\n\t\t}\n\n\t\treturn result;\n\t}","id":159,"modified_method":"public Object getResult(\n\t\tboolean entityCacheEnabled, Class<?> classObj,\n\t\tSerializable primaryKeyObj, SessionFactory sessionFactory) {\n\n\t\tif (!PropsValues.VALUE_OBJECT_ENTITY_CACHE_ENABLED ||\n\t\t\t!entityCacheEnabled || !CacheRegistry.isActive()) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tObject result = null;\n\n\t\tMap<String, Object> localCache = null;\n\n\t\tString localCacheKey = null;\n\n\t\tif (_localCacheEnabled) {\n\t\t\tlocalCache = _localCache.get();\n\n\t\t\tlocalCacheKey = _encodeLocalCacheKey(classObj, primaryKeyObj);\n\n\t\t\tresult = localCache.get(localCacheKey);\n\t\t}\n\n\t\tif (result == null) {\n\t\t\tPortalCache portalCache = _getPortalCache(classObj.getName());\n\n\t\t\tString cacheKey = _encodeCacheKey(primaryKeyObj);\n\n\t\t\tresult = _multiVMPool.get(portalCache, cacheKey);\n\n\t\t\tif (result == null) {\n\t\t\t\tresult = StringPool.BLANK;\n\n\t\t\t\t_multiVMPool.put(portalCache, cacheKey, result);\n\t\t\t}\n\n\t\t\tif (_localCacheEnabled) {\n\t\t\t\tlocalCache.put(localCacheKey, result);\n\t\t\t}\n\t\t}\n\n\t\tif (result != null) {\n\t\t\tresult = _objectToResult(result);\n\t\t}\n\n\t\treturn result;\n\t}","commit_id":"625f722980f6eb48f6eda0cd1d172a833890140a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object getResult(\n\t\tFinderPath finderPath, Object[] args, SessionFactory sessionFactory) {\n\n\t\tif (!PropsValues.VALUE_OBJECT_FINDER_CACHE_ENABLED ||\n\t\t\t!finderPath.isFinderCacheEnabled() || !CacheRegistry.isActive()) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String, Object> localCache = _localCache.get();\n\n\t\tString localCacheKey = _encodeLocalCacheKey(\n\t\t\tfinderPath.getClassName(), finderPath.getMethodName(),\n\t\t\tfinderPath.getParams(), args);\n\n\t\tObject primaryKey = localCache.get(localCacheKey);\n\n\t\tif (primaryKey == null) {\n\t\t\tPortalCache portalCache = _getPortalCache(\n\t\t\t\tfinderPath.getClassName());\n\n\t\t\tString cacheKey = _encodeCacheKey(\n\t\t\t\tfinderPath.getMethodName(), finderPath.getParams(), args);\n\n\t\t\tprimaryKey = _multiVMPool.get(portalCache, cacheKey);\n\n\t\t\tif (primaryKey != null) {\n\t\t\t\tlocalCache.put(localCacheKey, primaryKey);\n\t\t\t}\n\t\t}\n\n\t\tif (primaryKey != null) {\n\t\t\treturn _primaryKeyToResult(finderPath, sessionFactory, primaryKey);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":160,"modified_method":"public Object getResult(\n\t\tFinderPath finderPath, Object[] args, SessionFactory sessionFactory) {\n\n\t\tif (!PropsValues.VALUE_OBJECT_FINDER_CACHE_ENABLED ||\n\t\t\t!finderPath.isFinderCacheEnabled() || !CacheRegistry.isActive()) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tObject primaryKey = null;\n\n\t\tMap<String, Object> localCache = null;\n\n\t\tString localCacheKey = null;\n\n\t\tif (_localCacheEnabled) {\n\t\t\tlocalCache = _localCache.get();\n\n\t\t\tlocalCacheKey = _encodeLocalCacheKey(\n\t\t\t\tfinderPath.getClassName(), finderPath.getMethodName(),\n\t\t\t\tfinderPath.getParams(), args);\n\n\t\t\tprimaryKey = localCache.get(localCacheKey);\n\t\t}\n\n\t\tif (primaryKey == null) {\n\t\t\tPortalCache portalCache = _getPortalCache(\n\t\t\t\tfinderPath.getClassName());\n\n\t\t\tString cacheKey = _encodeCacheKey(\n\t\t\t\tfinderPath.getMethodName(), finderPath.getParams(), args);\n\n\t\t\tprimaryKey = _multiVMPool.get(portalCache, cacheKey);\n\n\t\t\tif (primaryKey != null) {\n\t\t\t\tif (_localCacheEnabled) {\n\t\t\t\t\tlocalCache.put(localCacheKey, primaryKey);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (primaryKey != null) {\n\t\t\treturn _primaryKeyToResult(finderPath, sessionFactory, primaryKey);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"625f722980f6eb48f6eda0cd1d172a833890140a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        long socketRef = socketWrapper.getSocket().longValue();\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n                if (!endpoint.isPaused()) {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    inputBuffer.parseHeaders();\n                    if (!disableUploadTimeout) {\n                        Socket.timeoutSet(socketRef,\n                                connectionUploadTimeout * 1000);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) {\n                Socket.timeoutSet(socketRef, endpoint.getSoTimeout() * 1000);\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet  || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","id":161,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n\n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        long socketRef = socketWrapper.getSocket().longValue();\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n                \n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    inputBuffer.parseHeaders();\n                    if (!disableUploadTimeout) {\n                        Socket.timeoutSet(socketRef,\n                                connectionUploadTimeout * 1000);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if (error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) {\n                Socket.timeoutSet(socketRef, endpoint.getSoTimeout() * 1000);\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet  || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","commit_id":"cc8d09db52c3c1bdf5b79ab746ccdfc34465e78b","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<NioChannel> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n        \n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n                if (!endpoint.isPaused()) {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    if ( !inputBuffer.parseHeaders() ) {\n                        //we've read part of the request, don't recycle it\n                        //instead associate it with the socket\n                        openSocket = true;\n                        readComplete = false;\n                        break;\n                    }\n                    if (!disableUploadTimeout) { //only for body, not for request headers\n                        socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(\n                                connectionUploadTimeout);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if(error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) { //only for body, not for request headers\n                socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(\n                        endpoint.getSoTimeout());\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","id":162,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @param socketWrapper Socket from which the HTTP requests will be read\n     *               and the HTTP responses will be written.\n     *  \n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<NioChannel> socketWrapper)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socketWrapper;\n        inputBuffer.init(socketWrapper, endpoint);\n        outputBuffer.init(socketWrapper, endpoint);\n\n        // Flags\n        error = false;\n        keepAlive = true;\n        comet = false;\n        openSocket = false;\n        sendfileInProgress = false;\n        readComplete = true;\n        if (endpoint.getUsePolling()) {\n            keptAlive = false;\n        } else {\n            keptAlive = socketWrapper.isKeptAlive();\n        }\n        \n        if (disableKeepAlive()) {\n            socketWrapper.setKeepAliveLeft(0);\n        }\n\n        while (!error && keepAlive && !comet && !isAsync() &&\n                !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                setRequestLineReadTimeout();\n                \n                if (!inputBuffer.parseRequestLine(keptAlive)) {\n                    if (handleIncompleteRequestLineRead()) {\n                        break;\n                    }\n                }\n                \n                if (endpoint.isPaused()) {\n                    // 503 - Service unavailable\n                    response.setStatus(503);\n                    adapter.log(request, response, 0);\n                    error = true;\n                } else {\n                    request.setStartTime(System.currentTimeMillis());\n                    keptAlive = true;\n                    if ( !inputBuffer.parseHeaders() ) {\n                        //we've read part of the request, don't recycle it\n                        //instead associate it with the socket\n                        openSocket = true;\n                        readComplete = false;\n                        break;\n                    }\n                    if (!disableUploadTimeout) { //only for body, not for request headers\n                        socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(\n                                connectionUploadTimeout);\n                    }\n                }\n            } catch (IOException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), e);\n                }\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\"http11processor.header.parse\"), t);\n                }\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"http11processor.request.prepare\"), t);\n                    }\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n            \n            if (maxKeepAliveRequests == 1) {\n                keepAlive = false;\n            } else if (maxKeepAliveRequests > 0 &&\n                    socketWrapper.decrementKeepAlive() <= 0) {\n                keepAlive = false;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                    // Handle when the response was committed before a serious\n                    // error occurred.  Throwing a ServletException should both\n                    // set the status to 500 and set the errorException.\n                    // If we fail here, then the response is likely already\n                    // committed, so we can't try and set headers.\n                    if(keepAlive && !error) { // Avoid checking twice.\n                        error = response.getErrorException() != null ||\n                                (!isAsync() &&\n                                statusDropsConnection(response.getStatus()));\n                    }\n                    setCometTimeouts(socketWrapper);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"http11processor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Finish the handling of the request\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);\n\n            if (!isAsync() && !comet) {\n                if(error) {\n                    // If we know we are closing the connection, don't drain\n                    // input. This way uploading a 100GB file doesn't tie up the\n                    // thread if the servlet has rejected it.\n                    inputBuffer.setSwallowInput(false);\n                }\n                endRequest();\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            if (!comet && !isAsync()) {\n                // Next request\n                inputBuffer.nextRequest();\n                outputBuffer.nextRequest();\n            }\n\n            if (!disableUploadTimeout) { //only for body, not for request headers\n                socketWrapper.getSocket().getIOChannel().socket().setSoTimeout(\n                        endpoint.getSoTimeout());\n            }\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n\n            if (breakKeepAliveLoop(socketWrapper)) {\n                break;\n            }\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (comet || isAsync()) {\n            return SocketState.LONG;\n        } else {\n            if (sendfileInProgress) {\n                return SocketState.SENDFILE;\n            } else {\n                if (openSocket) {\n                    if (readComplete) {\n                        return SocketState.OPEN;\n                    } else {\n                        return SocketState.LONG;\n                    }\n                } else {\n                    return SocketState.CLOSED;\n                }\n            }\n        }\n    }","commit_id":"cc8d09db52c3c1bdf5b79ab746ccdfc34465e78b","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        long socketRef = socket.getSocket().longValue();\n        Socket.setrbb(socketRef, inputBuffer);\n        Socket.setsbb(socketRef, outputBuffer);\n\n        // Error flag\n        error = false;\n\n        boolean keptAlive = false;\n\n        while (!error && !endpoint.isPaused()) {\n\n            // Parsing the request header\n            try {\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage, true, keptAlive)) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    break;\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    if (endpoint.isPaused()) {\n                        recycle(true);\n                        break;\n                    }\n                    if (Socket.send(socketRef, pongMessageArray, 0,\n                            pongMessageArray.length) < 0) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Unexpected packet type. Unread body packets should have\n                    // been swallowed in finish().\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \" + type);\n                    }\n                    error = true;\n                    break;\n                }\n\n                keptAlive = true;\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle(false);\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n        \n        if (error || endpoint.isPaused()) {\n            return SocketState.CLOSED;\n        } else if (isAsync()) {\n            return SocketState.LONG;\n        } else {\n            return SocketState.OPEN;\n        }\n    }","id":163,"modified_method":"/**\n     * Process pipelined HTTP requests using the specified input and output\n     * streams.\n     *\n     * @throws IOException error during an I/O operation\n     */\n    @Override\n    public SocketState process(SocketWrapper<Long> socket)\n        throws IOException {\n        RequestInfo rp = request.getRequestProcessor();\n        rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);\n\n        // Setting up the socket\n        this.socket = socket;\n        long socketRef = socket.getSocket().longValue();\n        Socket.setrbb(socketRef, inputBuffer);\n        Socket.setsbb(socketRef, outputBuffer);\n\n        // Error flag\n        error = false;\n\n        boolean keptAlive = false;\n\n        while (!error && !endpoint.isPaused()) {\n            // Parsing the request header\n            try {\n                // Get first message of the request\n                if (!readMessage(requestHeaderMessage, true, keptAlive)) {\n                    // This means that no data is available right now\n                    // (long keepalive), so that the processor should be recycled\n                    // and the method should return true\n                    break;\n                }\n                // Check message type, process right away and break if\n                // not regular request processing\n                int type = requestHeaderMessage.getByte();\n                if (type == Constants.JK_AJP13_CPING_REQUEST) {\n                    if (endpoint.isPaused()) {\n                        recycle(true);\n                        break;\n                    }\n                    if (Socket.send(socketRef, pongMessageArray, 0,\n                            pongMessageArray.length) < 0) {\n                        error = true;\n                    }\n                    continue;\n                } else if(type != Constants.JK_AJP13_FORWARD_REQUEST) {\n                    // Unexpected packet type. Unread body packets should have\n                    // been swallowed in finish().\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Unexpected message: \" + type);\n                    }\n                    error = true;\n                    break;\n                }\n                keptAlive = true;\n                request.setStartTime(System.currentTimeMillis());\n            } catch (IOException e) {\n                error = true;\n                break;\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.debug(sm.getString(\"ajpprocessor.header.error\"), t);\n                // 400 - Bad Request\n                response.setStatus(400);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            if (!error) {\n                // Setting up filters, and parse some request headers\n                rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);\n                try {\n                    prepareRequest();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.debug(sm.getString(\"ajpprocessor.request.prepare\"), t);\n                    // 400 - Internal Server Error\n                    response.setStatus(400);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (endpoint.isPaused()) {\n                // 503 - Service unavailable\n                response.setStatus(503);\n                adapter.log(request, response, 0);\n                error = true;\n            }\n\n            // Process the request in the adapter\n            if (!error) {\n                try {\n                    rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);\n                    adapter.service(request, response);\n                } catch (InterruptedIOException e) {\n                    error = true;\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.error(sm.getString(\"ajpprocessor.request.process\"), t);\n                    // 500 - Internal Server Error\n                    response.setStatus(500);\n                    adapter.log(request, response, 0);\n                    error = true;\n                }\n            }\n\n            if (isAsync() && !error) {\n                break;\n            }\n\n            // Finish the response if not done yet\n            if (!finished) {\n                try {\n                    finish();\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    error = true;\n                }\n            }\n\n            // If there was an error, make sure the request is counted as\n            // and error, and update the statistics counter\n            if (error) {\n                response.setStatus(500);\n            }\n            request.updateCounters();\n\n            rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);\n            recycle(false);\n        }\n\n        rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);\n\n        if (!error && !endpoint.isPaused()) {\n            if (isAsync()) {\n                return SocketState.LONG;\n            } else {\n                return SocketState.OPEN;\n            }\n        } else {\n            return SocketState.CLOSED;\n        }\n    }","commit_id":"de04cd3123c2ec64d0cd038a87551742f86a814a","url":"https://github.com/apache/tomcat"},{"original_method":"/** Read and send messages in range [read-index .. read-index+available_msgs-1] */\n    public void sendBundledMessages(final Message[] buf, final int read_index, final int available_msgs) {\n        int       max_bundle_size=transport.getMaxBundleSize();\n        byte[]    cluster_name=transport.cluster_name.chars();\n        int       start=read_index;\n        final int end=index(start + available_msgs-1); // index of the last message to be read\n\n        for(;;) {\n            Message msg=buf[start];\n            if(msg == null) {\n                if(start == end)\n                    break;\n                start=advance(start);\n                continue;\n            }\n\n            Address dest=msg.dest();\n            try {\n                output.position(0);\n                Util.writeMessageListHeader(dest, msg.src(), cluster_name, 1, output, dest == null);\n\n                // remember the position at which the number of messages (an int) was written, so we can later set the\n                // correct value (when we know the correct number of messages)\n                int size_pos=output.position() - Global.INT_SIZE;\n                int num_msgs=marshalMessagesToSameDestination(dest, buf, start, end, max_bundle_size);\n                int current_pos=output.position();\n                output.position(size_pos);\n                output.writeInt(num_msgs);\n                output.position(current_pos);\n                transport.doSend(output.buffer(), 0, output.position(), dest);\n                if(transport.statsEnabled())\n                    transport.incrBatchesSent(num_msgs);\n            }\n            catch(Exception ex) {\n                log.error(\"failed to send message(s)\", ex);\n            }\n\n            if(start == end)\n                break;\n            start=advance(start);\n        }\n    }","id":164,"modified_method":"/** Read and send messages in range [read-index .. read-index+available_msgs-1] */\n    public void sendBundledMessages(final Message[] buf, final int read_index, final int available_msgs) {\n        int       max_bundle_size=transport.getMaxBundleSize();\n        byte[]    cluster_name=transport.cluster_name.chars();\n        int       start=read_index;\n        final int end=index(start + available_msgs-1); // index of the last message to be read\n\n        for(;;) {\n            Message msg=buf[start];\n            if(msg == null) {\n                if(start == end)\n                    break;\n                start=advance(start);\n                continue;\n            }\n\n            Address dest=msg.dest();\n            try {\n                output.position(0);\n                Util.writeMessageListHeader(dest, msg.src(), cluster_name, 1, output, dest == null);\n\n                // remember the position at which the number of messages (an int) was written, so we can later set the\n                // correct value (when we know the correct number of messages)\n                int size_pos=output.position() - Global.INT_SIZE;\n                int num_msgs=marshalMessagesToSameDestination(dest, buf, start, end, max_bundle_size);\n                if(num_msgs > 1) {\n                    int current_pos=output.position();\n                    output.position(size_pos);\n                    output.writeInt(num_msgs);\n                    output.position(current_pos);\n                }\n                transport.doSend(output.buffer(), 0, output.position(), dest);\n                if(transport.statsEnabled())\n                    transport.incrBatchesSent(num_msgs);\n            }\n            catch(Exception ex) {\n                log.error(\"failed to send message(s)\", ex);\n            }\n\n            if(start == end)\n                break;\n            start=advance(start);\n        }\n    }","commit_id":"0f234319344be7751af5c44094c7c8915a4727c6","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Read and send messages in range [read-index .. read-index+available_msgs-1] */\n    protected int sendBundledMessages(final Message[] buf, final int read_index, int available_msgs) {\n        int       max_bundle_size=transport.getMaxBundleSize();\n        byte[]    cluster_name=transport.cluster_name.chars();\n        int       start=read_index;\n        int       sent_msgs=0;\n\n        while(available_msgs > 0) {\n            Message msg=buf[start];\n            if(msg == null) {\n                start=increment(start);\n                available_msgs--;\n                continue;\n            }\n\n            Address dest=msg.dest();\n            try {\n                output.position(0);\n                Util.writeMessageListHeader(dest, msg.src(), cluster_name, 1, output, dest == null);\n\n                // remember the position at which the number of messages (an int) was written, so we can later set the\n                // correct value (when we know the correct number of messages)\n                int size_pos=output.position() - Global.INT_SIZE;\n                int num_msgs=marshalMessagesToSameDestination(dest, buf, start, available_msgs, max_bundle_size);\n                sent_msgs+=num_msgs;\n                int current_pos=output.position();\n                output.position(size_pos);\n                output.writeInt(num_msgs);\n                output.position(current_pos);\n                transport.doSend(output.buffer(), 0, output.position(), dest);\n                if(transport.statsEnabled())\n                    transport.incrBatchesSent(num_msgs);\n            }\n            catch(Exception ex) {\n                log.error(\"failed to send message(s)\", ex);\n            }\n\n            available_msgs--;\n            start=increment(start);\n        }\n        return sent_msgs;\n    }","id":165,"modified_method":"/** Read and send messages in range [read-index .. read-index+available_msgs-1] */\n    protected int sendBundledMessages(final Message[] buf, final int read_index, int available_msgs) {\n        int       max_bundle_size=transport.getMaxBundleSize();\n        byte[]    cluster_name=transport.cluster_name.chars();\n        int       start=read_index;\n        int       sent_msgs=0;\n\n        while(available_msgs > 0) {\n            Message msg=buf[start];\n            if(msg == null) {\n                start=increment(start);\n                available_msgs--;\n                continue;\n            }\n\n            Address dest=msg.dest();\n            try {\n                output.position(0);\n                Util.writeMessageListHeader(dest, msg.src(), cluster_name, 1, output, dest == null);\n\n                // remember the position at which the number of messages (an int) was written, so we can later set the\n                // correct value (when we know the correct number of messages)\n                int size_pos=output.position() - Global.INT_SIZE;\n                int num_msgs=marshalMessagesToSameDestination(dest, buf, start, available_msgs, max_bundle_size);\n                sent_msgs+=num_msgs;\n                if(num_msgs > 1) {\n                    int current_pos=output.position();\n                    output.position(size_pos);\n                    output.writeInt(num_msgs);\n                    output.position(current_pos);\n                }\n                transport.doSend(output.buffer(), 0, output.position(), dest);\n                if(transport.statsEnabled())\n                    transport.incrBatchesSent(num_msgs);\n            }\n            catch(Exception ex) {\n                log.error(\"failed to send message(s)\", ex);\n            }\n\n            available_msgs--;\n            start=increment(start);\n        }\n        return sent_msgs;\n    }","commit_id":"0f234319344be7751af5c44094c7c8915a4727c6","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Read and send messages in range [read-index+1 .. write_index-1] */\n    protected int sendBundledMessages(final Message[] buf, final int read_index, final int write_index) {\n        int       max_bundle_size=transport.getMaxBundleSize();\n        byte[]    cluster_name=transport.cluster_name.chars();\n        int       sent_msgs=0;\n\n        for(int i=increment(read_index); i != write_index; i=increment(i)) {\n            Message msg=buf[i];\n            if(msg == NULL_MSG)\n                continue;\n            if(msg == null)\n                break;\n\n            Address dest=msg.dest();\n            try {\n                output.position(0);\n                Util.writeMessageListHeader(dest, msg.src(), cluster_name, 1, output, dest == null);\n\n                // remember the position at which the number of messages (an int) was written, so we can later set the\n                // correct value (when we know the correct number of messages)\n                int size_pos=output.position() - Global.INT_SIZE;\n                int num_msgs=marshalMessagesToSameDestination(dest, buf, i, write_index, max_bundle_size);\n                sent_msgs+=num_msgs;\n                int current_pos=output.position();\n                output.position(size_pos);\n                output.writeInt(num_msgs);\n                output.position(current_pos);\n                transport.doSend(output.buffer(), 0, output.position(), dest);\n                if(transport.statsEnabled())\n                    transport.incrBatchesSent(num_msgs);\n            }\n            catch(Exception ex) {\n                log.error(\"failed to send message(s)\", ex);\n            }\n        }\n        return sent_msgs;\n    }","id":166,"modified_method":"/** Read and send messages in range [read-index+1 .. write_index-1] */\n    protected int sendBundledMessages(final Message[] buf, final int read_index, final int write_index) {\n        int       max_bundle_size=transport.getMaxBundleSize();\n        byte[]    cluster_name=transport.cluster_name.chars();\n        int       sent_msgs=0;\n\n        for(int i=increment(read_index); i != write_index; i=increment(i)) {\n            Message msg=buf[i];\n            if(msg == NULL_MSG)\n                continue;\n            if(msg == null)\n                break;\n\n            Address dest=msg.dest();\n            try {\n                output.position(0);\n                Util.writeMessageListHeader(dest, msg.src(), cluster_name, 1, output, dest == null);\n\n                // remember the position at which the number of messages (an int) was written, so we can later set the\n                // correct value (when we know the correct number of messages)\n                int size_pos=output.position() - Global.INT_SIZE;\n                int num_msgs=marshalMessagesToSameDestination(dest, buf, i, write_index, max_bundle_size);\n                sent_msgs+=num_msgs;\n                if(num_msgs > 1) {\n                    int current_pos=output.position();\n                    output.position(size_pos);\n                    output.writeInt(num_msgs);\n                    output.position(current_pos);\n                }\n                transport.doSend(output.buffer(), 0, output.position(), dest);\n                if(transport.statsEnabled())\n                    transport.incrBatchesSent(num_msgs);\n            }\n            catch(Exception ex) {\n                log.error(\"failed to send message(s)\", ex);\n            }\n        }\n        return sent_msgs;\n    }","commit_id":"0f234319344be7751af5c44094c7c8915a4727c6","url":"https://github.com/belaban/JGroups"},{"original_method":"public IndexHits<Long> get( String key, Object value )\n    {\n        return query( type.get( key, value ) );\n    }","id":167,"modified_method":"public IndexHits<Long> get( String key, Object value )\n    {\n        IndexHits<Long> cached = getFromCache( key, value );\n        return cached != null ? cached : query( type.get( key, value ), key, value );\n    }","commit_id":"50f951ad31188e63dffcccf2dd17ba52d5d9de4a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IndexHits<Long> get( String key, Object value )\n    {\n        return query( type.get( key, value ) );\n    }","id":168,"modified_method":"public IndexHits<Long> get( String key, Object value )\n    {\n        IndexHits<Long> cached = getFromCache( key, value );\n        return cached != null ? cached : query( type.get( key, value ), key, value );\n    }","commit_id":"56c0e26cafce3aae6b98d4723c988fd23af41d17","url":"https://github.com/neo4j/neo4j"},{"original_method":"public IndexHits<Long> get( String key, Object value )\n    {\n        return query( type.get( key, value ) );\n    }","id":169,"modified_method":"public IndexHits<Long> get( String key, Object value )\n    {\n        IndexHits<Long> cached = getFromCache( key, value );\n        return cached != null ? cached : query( type.get( key, value ), key, value );\n    }","commit_id":"283d655a6fa8ae648ef5c1cc3cb22bf65cea0eba","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void fetchWithCertainPathsTwoRevisions() throws Exception {\n        SimpleNodeScenario scenario = new SimpleNodeScenario(getNodeStore());\n        Long firstRevisionId = scenario.create();\n        Long secondRevisionId = scenario.update_A_and_add_D_and_E();\n\n        FetchNodesAction query = new FetchNodesAction(getNodeStore(),\n                getPathSet(\"/a\", \"/a/b\", \"/a/c\", \"/a/d\", \"/a/b/e\", \"not_existing\"),\n                firstRevisionId);\n        List<Node> actuals = toNode(query.execute());\n        String json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%1$s\\\" : { \\\"int\\\" : 1 , \\\"b#%1$s\\\" : { \\\"string\\\" : \\\"foo\\\" } , \\\"c#%1$s\\\" : { \\\"bool\\\" : true } } } }\",\n                firstRevisionId);\n        Node expected = NodeBuilder.build(json);\n        Iterator<Node> expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n\n        query = new FetchNodesAction(getNodeStore(),\n                getPathSet(\"/a\", \"/a/b\", \"/a/c\", \"/a/d\", \"/a/b/e\", \"not_existing\"),\n                secondRevisionId);\n        actuals = toNode(query.execute());\n        json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%2$s\\\" : { \\\"int\\\" : 1 , \\\"double\\\" : 0.123 , \\\"b#%2$s\\\" : { \\\"string\\\" : \\\"foo\\\" , \\\"e#%2$s\\\" : { \\\"array\\\" : [ 123, null, 123.456, \\\"for:bar\\\", true ] } } , \\\"c#%1$s\\\" : { \\\"bool\\\" : true }, \\\"d#%2$s\\\" : { \\\"null\\\" : null } } } }\",\n                firstRevisionId, secondRevisionId);\n        expected = NodeBuilder.build(json);\n        expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n    }","id":170,"modified_method":"@Test\n    public void fetchWithCertainPathsTwoRevisions() throws Exception {\n        SimpleNodeScenario scenario = new SimpleNodeScenario(getNodeStore());\n        Long firstRevisionId = scenario.create();\n        Long secondRevisionId = scenario.update_A_and_add_D_and_E();\n\n        List<Node> actuals = createAndExecuteQuery(firstRevisionId, getPathSet(\"/a\", \"/a/b\", \"/a/c\", \"/a/d\", \"/a/b/e\", \"not_existing\"));\n        String json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%1$s\\\" : { \\\"int\\\" : 1 , \\\"b#%1$s\\\" : { \\\"string\\\" : \\\"foo\\\" } , \\\"c#%1$s\\\" : { \\\"bool\\\" : true } } } }\",\n                firstRevisionId);\n        Node expected = NodeBuilder.build(json);\n        Iterator<Node> expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n\n        actuals = createAndExecuteQuery(secondRevisionId, getPathSet(\"/a\", \"/a/b\", \"/a/c\", \"/a/d\", \"/a/b/e\", \"not_existing\"));\n        json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%2$s\\\" : { \\\"int\\\" : 1 , \\\"double\\\" : 0.123 , \\\"b#%2$s\\\" : { \\\"string\\\" : \\\"foo\\\" , \\\"e#%2$s\\\" : { \\\"array\\\" : [ 123, null, 123.456, \\\"for:bar\\\", true ] } } , \\\"c#%1$s\\\" : { \\\"bool\\\" : true }, \\\"d#%2$s\\\" : { \\\"null\\\" : null } } } }\",\n                firstRevisionId, secondRevisionId);\n        expected = NodeBuilder.build(json);\n        expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n    }","commit_id":"bafb9217709ab06ed7ee143f49a0d641dcb1973f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void fetchWithCertainPathsOneRevision() throws Exception {\n        SimpleNodeScenario scenario = new SimpleNodeScenario(getNodeStore());\n        Long revisionId = scenario.create();\n\n        FetchNodesAction query = new FetchNodesAction(getNodeStore(),\n                getPathSet(\"/a\", \"/a/b\", \"/a/c\", \"not_existing\"), revisionId);\n        List<Node> actuals = toNode(query.execute());\n        String json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%1$s\\\" : { \\\"int\\\" : 1 , \\\"b#%1$s\\\" : { \\\"string\\\" : \\\"foo\\\" } , \\\"c#%1$s\\\" : { \\\"bool\\\" : true } } } }\",\n                revisionId);\n        Node expected = NodeBuilder.build(json);\n        Iterator<Node> expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n\n        query = new FetchNodesAction(getNodeStore(),\n                getPathSet(\"/a\", \"not_existing\"), revisionId);\n        actuals = toNode(query.execute());\n        json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%1$s\\\" : { \\\"int\\\" : 1 } } }\",\n                revisionId);\n        expected = NodeBuilder.build(json);\n        expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n    }","id":171,"modified_method":"@Test\n    public void fetchWithCertainPathsOneRevision() throws Exception {\n        SimpleNodeScenario scenario = new SimpleNodeScenario(getNodeStore());\n        Long revisionId = scenario.create();\n\n        List<Node> actuals = createAndExecuteQuery(revisionId, getPathSet(\"/a\", \"/a/b\", \"/a/c\", \"not_existing\"));\n        String json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%1$s\\\" : { \\\"int\\\" : 1 , \\\"b#%1$s\\\" : { \\\"string\\\" : \\\"foo\\\" } , \\\"c#%1$s\\\" : { \\\"bool\\\" : true } } } }\",\n                revisionId);\n        Node expected = NodeBuilder.build(json);\n        Iterator<Node> expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n\n        actuals = createAndExecuteQuery(revisionId, getPathSet(\"/a\", \"not_existing\"));\n        json = String.format(\"{ \\\"/#%1$s\\\" : { \\\"a#%1$s\\\" : { \\\"int\\\" : 1 } } }\",\n                revisionId);\n        expected = NodeBuilder.build(json);\n        expecteds = expected.getChildNodeEntries(0, -1);\n        NodeAssert.assertEquals(expecteds, actuals);\n    }","commit_id":"bafb9217709ab06ed7ee143f49a0d641dcb1973f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        KotlinJsModuleConfigurator configurator = (KotlinJsModuleConfigurator) getConfiguratorByName(NAME);\n        assert configurator != null : \"Cannot find configurator with name \" + NAME;\n\n        String defaultPathToJsFileDir = createRelativePath(null, contextDirectory, \"script\");\n        String defaultPathToJarFileDir = createRelativePath(null, contextDirectory, \"lib\");\n\n        boolean jsFilePresent = isJsFilePresent(defaultPathToJsFileDir);\n        boolean jarFilePresent = getFileInDir(configurator.getJarName(), defaultPathToJarFileDir).exists();\n\n        if (jarFilePresent && jsFilePresent) {\n            return createConfiguration(getFileInDir(configurator.getJarName(), defaultPathToJarFileDir));\n        }\n\n        CreateJavaScriptLibraryDialog dialog =\n                new CreateJavaScriptLibraryDialog(defaultPathToJarFileDir, defaultPathToJsFileDir, !jarFilePresent, !jsFilePresent);\n        dialog.show();\n\n        if (!dialog.isOK()) return null;\n\n        String copyJsFileIntoPath = dialog.getCopyJsIntoPath();\n        if (!jsFilePresent && copyJsFileIntoPath != null) {\n            configurator.copyFileToDir(configurator.getJsFile(), copyJsFileIntoPath);\n        }\n\n        if (jarFilePresent) {\n            return createConfiguration(getFileInDir(configurator.getJarName(), defaultPathToJarFileDir));\n        }\n        else {\n            String copyIntoPath = dialog.getCopyLibraryIntoPath();\n            File existedJarFile = configurator.getExistedJarFile();\n            if (copyIntoPath != null) {\n                return createConfiguration(configurator.copyFileToDir(existedJarFile, copyIntoPath));\n            }\n            else {\n                return createConfiguration(existedJarFile);\n            }\n        }\n    }","id":172,"modified_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        KotlinJsModuleConfigurator jsConfigurator = (KotlinJsModuleConfigurator) getConfiguratorByName(NAME);\n        assert jsConfigurator != null : \"Cannot find configurator with name \" + NAME;\n\n        deferredCopyFileRequests = new DeferredCopyFileRequests(jsConfigurator);\n\n        String defaultPathToJsFileDir =\n                useRelativePaths ? DEFAULT_SCRIPT_DIR_NAME : createRelativePath(null, contextDirectory, DEFAULT_SCRIPT_DIR_NAME);\n        String defaultPathToJarFileDir =\n                useRelativePaths ? DEFAULT_LIB_DIR_NAME : createRelativePath(null, contextDirectory, DEFAULT_LIB_DIR_NAME);\n\n        boolean jsFilePresent = isJsFilePresent(defaultPathToJsFileDir);\n        boolean jarFilePresent = getFileInDir(jsConfigurator.getJarName(), defaultPathToJarFileDir).exists();\n\n        if (jarFilePresent && jsFilePresent) {\n            return createConfiguration(getFileInDir(jsConfigurator.getJarName(), defaultPathToJarFileDir));\n        }\n\n        CreateJavaScriptLibraryDialog dialog =\n                new CreateJavaScriptLibraryDialog(defaultPathToJarFileDir, defaultPathToJsFileDir, !jarFilePresent, !jsFilePresent);\n        dialog.show();\n\n        if (!dialog.isOK()) return null;\n\n        String copyJsFileIntoPath = dialog.getCopyJsIntoPath();\n        if (!jsFilePresent && copyJsFileIntoPath != null) {\n            deferredCopyFileRequests.addCopyRequest(jsConfigurator.getJsFile(), copyJsFileIntoPath);\n        }\n\n        if (jarFilePresent) {\n            return createConfiguration(getFileInDir(jsConfigurator.getJarName(), defaultPathToJarFileDir));\n        }\n        else {\n            String copyIntoPath = dialog.getCopyLibraryIntoPath();\n            File existedJarFile = jsConfigurator.getExistedJarFile();\n\n            if (copyIntoPath != null) {\n                deferredCopyFileRequests.addCopyWithReplaceRequest(existedJarFile, copyIntoPath);\n            }\n\n            return createConfiguration(existedJarFile);\n        }\n    }","commit_id":"8ddbdab8c8851f25f28263ca33eafb920b75222f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        KotlinJavaModuleConfigurator configurator = (KotlinJavaModuleConfigurator) ConfigureKotlinInProjectUtils\n                .getConfiguratorByName(KotlinJavaModuleConfigurator.NAME);\n        assert configurator != null : \"Configurator with name \" + KotlinJavaModuleConfigurator.NAME + \" should exists\";\n\n        String defaultPathToJarFile = FileUIUtils.createRelativePath(null, contextDirectory, \"lib\");\n\n        boolean jarFilePresent = getFileInDir(configurator.getJarName(), defaultPathToJarFile).exists();\n\n        File libraryFile;\n        File librarySrcFile;\n        if (jarFilePresent) {\n            libraryFile = getFileInDir(configurator.getJarName(), defaultPathToJarFile);\n            File sourcesJar = getFileInDir(configurator.getSourcesJarName(), defaultPathToJarFile);\n            librarySrcFile = sourcesJar.exists() ? sourcesJar\n                                                 : configurator.copyFileToDir(configurator.getExistedSourcesJarFile(), libraryFile.getParent());\n        }\n        else {\n            CreateJavaLibraryDialog dialog = new CreateJavaLibraryDialog(defaultPathToJarFile);\n            dialog.show();\n\n            if (!dialog.isOK()) return null;\n\n            String copyIntoPath = dialog.getCopyIntoPath();\n\n            File existedJarFile = configurator.getExistedJarFile();\n            libraryFile = copyIntoPath != null ? configurator.copyFileToDir(existedJarFile, copyIntoPath) : existedJarFile;\n\n            File existedSourcesJarFile = configurator.getExistedSourcesJarFile();\n            librarySrcFile = copyIntoPath != null ? configurator.copyFileToDir(existedSourcesJarFile, copyIntoPath) : existedSourcesJarFile;\n        }\n\n        final String libraryFileUrl = VfsUtil.getUrlForLibraryRoot(libraryFile);\n        final String libraryFileSrcUrl = VfsUtil.getUrlForLibraryRoot(librarySrcFile);\n\n        return new NewLibraryConfiguration(LIBRARY_NAME, getDownloadableLibraryType(), new LibraryVersionProperties()) {\n            @Override\n            public void addRoots(@NotNull LibraryEditor editor) {\n                editor.addRoot(libraryFileUrl, OrderRootType.CLASSES);\n                editor.addRoot(libraryFileSrcUrl, OrderRootType.SOURCES);\n            }\n        };\n    }","id":173,"modified_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        KotlinJavaModuleConfigurator jvmConfigurator =\n                (KotlinJavaModuleConfigurator) ConfigureKotlinInProjectUtils.getConfiguratorByName(KotlinJavaModuleConfigurator.NAME);\n        assert jvmConfigurator != null : \"Configurator with name \" + KotlinJavaModuleConfigurator.NAME + \" should exists\";\n\n        deferredCopyFileRequests = new DeferredCopyFileRequests(jvmConfigurator);\n\n        String defaultPathToJarFile = useRelativePaths ? DEFAULT_LIB_DIR_NAME\n                                                       : FileUIUtils.createRelativePath(null, contextDirectory, DEFAULT_LIB_DIR_NAME);\n\n        File bundledLibJarFile = jvmConfigurator.getExistedJarFile();\n        File bundledLibSourcesJarFile = jvmConfigurator.getExistedSourcesJarFile();\n\n        File libraryFile;\n        File librarySrcFile;\n\n        File stdJarInDefaultPath = getFileInDir(jvmConfigurator.getJarName(), defaultPathToJarFile);\n        if (stdJarInDefaultPath.exists()) {\n            libraryFile = stdJarInDefaultPath;\n\n            File sourcesJar = getFileInDir(jvmConfigurator.getSourcesJarName(), defaultPathToJarFile);\n            if (sourcesJar.exists()) {\n                librarySrcFile = sourcesJar;\n            }\n            else {\n                deferredCopyFileRequests.addCopyWithReplaceRequest(bundledLibSourcesJarFile, libraryFile.getParent());\n                librarySrcFile = bundledLibSourcesJarFile;\n            }\n        }\n        else {\n            CreateJavaLibraryDialog dialog = new CreateJavaLibraryDialog(defaultPathToJarFile);\n            dialog.show();\n\n            if (!dialog.isOK()) return null;\n\n            String copyIntoPath = dialog.getCopyIntoPath();\n            if (copyIntoPath != null) {\n                deferredCopyFileRequests.addCopyWithReplaceRequest(bundledLibJarFile, copyIntoPath);\n                deferredCopyFileRequests.addCopyWithReplaceRequest(bundledLibSourcesJarFile, copyIntoPath);\n            }\n\n            libraryFile = bundledLibJarFile;\n            librarySrcFile = bundledLibSourcesJarFile;\n        }\n\n        final String libraryFileUrl = VfsUtil.getUrlForLibraryRoot(libraryFile);\n        final String libraryFileSrcUrl = VfsUtil.getUrlForLibraryRoot(librarySrcFile);\n\n        return new NewLibraryConfiguration(LIBRARY_NAME, null, new LibraryVersionProperties()) {\n            @Override\n            public void addRoots(@NotNull LibraryEditor editor) {\n                editor.addRoot(libraryFileUrl, OrderRootType.CLASSES);\n                editor.addRoot(libraryFileSrcUrl, OrderRootType.SOURCES);\n            }\n        };\n    }","commit_id":"8ddbdab8c8851f25f28263ca33eafb920b75222f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void runGoals()\n        throws MojoExecutionException\n    {\n        // TODO: we need to get a reference to the maven component and use that so this\n        // will work purely in an embedded mode. Not sure how to pass the release setting to the plugin in that\n        // instance though - still via -D, or is there a better way?\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"m2\" );\n\n        cl.setWorkingDirectory( workingDirectory );\n\n        cl.createArgument().setLine( goals );\n\n        cl.createArgument().setLine( \"-DperformRelease=true\" );\n\n        cl.createArgument().setLine( \"--no-plugin-updates\" );\n\n        cl.createArgument().setLine( \"--batch-mode\" );\n\n        StreamConsumer consumer = new DefaultConsumer();\n\n        try\n        {\n            CommandLineUtils.executeCommandLine( cl, consumer, consumer );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\n        }\n    }","id":174,"modified_method":"private void runGoals()\n        throws MojoExecutionException\n    {\n        // TODO: we need to get a reference to the maven component and use that so this\n        // will work purely in an embedded mode. Not sure how to pass the release setting to the plugin in that\n        // instance though - still via -D, or is there a better way?\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"m2\" );\n\n        cl.setWorkingDirectory( workingDirectory );\n\n        cl.createArgument().setLine( goals );\n\n        cl.createArgument().setLine( \"-DperformRelease=true\" );\n\n        cl.createArgument().setLine( \"--no-plugin-updates\" );\n\n        cl.createArgument().setLine( \"--batch-mode\" );\n        \n        StreamConsumer consumer = new DefaultConsumer();\n\n        try\n        {\n            int result = CommandLineUtils.executeCommandLine( cl, consumer, consumer );\n            \n            if ( result != 0 )\n            {\n                throw new MojoExecutionException(\"Result of m2 execution is: \\'\" + result + \"\\'. Release failed.\" );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\n        }\n    }","commit_id":"e7b8e16dfab722e407a88e9123023eb41679615d","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\r\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\r\n     */\r\n    protected void execute()\r\n        throws MavenReportException\r\n    {\r\n        try\r\n        {\r\n            File outputDir = new File( getConfiguration().getReportOutputDirectory().getAbsolutePath() + \"/apidocs\" );\r\n            outputDir.mkdirs();\r\n\r\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\r\n            String year;\r\n            if ( getConfiguration().getModel().getInceptionYear() != null\r\n                 && Integer.valueOf( getConfiguration().getModel().getInceptionYear() ).intValue() == actualYear )\r\n            {\r\n                year = getConfiguration().getModel().getInceptionYear();\r\n            }\r\n            else\r\n            {\r\n                year = getConfiguration().getModel().getInceptionYear() + \"-\" + String.valueOf( actualYear );\r\n            }\r\n\r\n            StringBuffer classpath = new StringBuffer();\r\n            for ( Iterator i = getConfiguration().getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\r\n            {\r\n                classpath.append( (String) i.next() );\r\n                if ( i.hasNext() )\r\n                {\r\n                    classpath.append( \";\" );\r\n                }\r\n            }\r\n\r\n            StringBuffer sourcePath = new StringBuffer();\r\n            String[] fileList = new String[1];\r\n            for ( Iterator i = getConfiguration().getCompileSourceRoots().iterator(); i.hasNext(); )\r\n            {\r\n                String sourceDirectory = (String) i.next();\r\n                fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[] { \"java\" } );\r\n                sourcePath.append( sourceDirectory );\r\n            }\r\n\r\n            File javadocDirectory = new File( getConfiguration().getProject().getBuild().getDirectory() + \"/javadoc\" );\r\n            if ( fileList != null && fileList.length != 0 )\r\n            {\r\n                StringBuffer files = new StringBuffer();\r\n                for ( int i = 0; i < fileList.length; i++ )\r\n                {\r\n                    files.append( fileList[i] );\r\n                    files.append( \"\\n\" );\r\n                }\r\n                javadocDirectory.mkdirs();\r\n                FileUtils.fileWrite( new File( javadocDirectory, \"files\" ).getAbsolutePath(), files.toString() );\r\n            }\r\n            else\r\n            {\r\n                return;\r\n            }\r\n\r\n            Commandline cl = new Commandline();\r\n            cl.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\r\n            cl.setExecutable( getJavadocPath() );\r\n            cl.createArgument().setValue( \"-use\" );\r\n            cl.createArgument().setValue( \"-version\" );\r\n            cl.createArgument().setValue( \"-author\" );\r\n            cl.createArgument().setValue( \"-windowtitle\" );\r\n            cl.createArgument().setValue(\r\n                                          getConfiguration().getModel().getName() + \" \"\r\n                                              + getConfiguration().getModel().getVersion() );\r\n            cl.createArgument().setValue( \"-bottom\" );\r\n            cl.createArgument().setValue( \"Copyright &copy; \" + year + \" \"\r\n                                          + getConfiguration().getModel().getOrganization().getName()\r\n                                          + \". All Rights Reserved.\" );\r\n            cl.createArgument().setValue( \"-sourcePath\" );\r\n            cl.createArgument().setValue( sourcePath.toString() );\r\n            cl.createArgument().setValue( \"-d\" );\r\n            cl.createArgument().setValue( outputDir.getAbsolutePath() );\r\n            cl.createArgument().setValue( \"-classpath\" );\r\n            cl.createArgument().setValue( classpath.toString() );\r\n            cl.createArgument().setValue( \"@files\" );\r\n            System.out.println( Commandline.toString( cl.getCommandline() ) );\r\n            System.out.println( cl.getWorkingDirectory() );\r\n            CommandLineUtils.executeCommandLine( cl, new DefaultConsumer(), new DefaultConsumer() );\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MavenReportException( \"An error is occurred in javadoc report generation.\", e );\r\n        }\r\n    }","id":175,"modified_method":"/**\r\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\r\n     */\r\n    protected void execute()\r\n        throws MavenReportException\r\n    {\r\n        try\r\n        {\r\n            File outputDir = new File( getConfiguration().getReportOutputDirectory().getAbsolutePath() + \"/apidocs\" );\r\n            outputDir.mkdirs();\r\n\r\n            int actualYear = Calendar.getInstance().get( Calendar.YEAR );\r\n            String year;\r\n            if ( getConfiguration().getModel().getInceptionYear() != null\r\n                 && Integer.valueOf( getConfiguration().getModel().getInceptionYear() ).intValue() == actualYear )\r\n            {\r\n                year = getConfiguration().getModel().getInceptionYear();\r\n            }\r\n            else\r\n            {\r\n                year = getConfiguration().getModel().getInceptionYear() + \"-\" + String.valueOf( actualYear );\r\n            }\r\n\r\n            StringBuffer classpath = new StringBuffer();\r\n            for ( Iterator i = getConfiguration().getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\r\n            {\r\n                classpath.append( (String) i.next() );\r\n                if ( i.hasNext() )\r\n                {\r\n                    classpath.append( \";\" );\r\n                }\r\n            }\r\n\r\n            StringBuffer sourcePath = new StringBuffer();\r\n            String[] fileList = new String[1];\r\n            for ( Iterator i = getConfiguration().getCompileSourceRoots().iterator(); i.hasNext(); )\r\n            {\r\n                String sourceDirectory = (String) i.next();\r\n                fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[] { \"java\" } );\r\n                sourcePath.append( sourceDirectory );\r\n            }\r\n\r\n            File javadocDirectory = new File( getConfiguration().getProject().getBuild().getDirectory() + \"/javadoc\" );\r\n            if ( fileList != null && fileList.length != 0 )\r\n            {\r\n                StringBuffer files = new StringBuffer();\r\n                for ( int i = 0; i < fileList.length; i++ )\r\n                {\r\n                    files.append( fileList[i] );\r\n                    files.append( \"\\n\" );\r\n                }\r\n                javadocDirectory.mkdirs();\r\n                FileUtils.fileWrite( new File( javadocDirectory, \"files\" ).getAbsolutePath(), files.toString() );\r\n            }\r\n            else\r\n            {\r\n                return;\r\n            }\r\n\r\n            Commandline cl = new Commandline();\r\n            cl.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\r\n            cl.setExecutable( getJavadocPath() );\r\n            cl.createArgument().setValue( \"-use\" );\r\n            cl.createArgument().setValue( \"-version\" );\r\n            cl.createArgument().setValue( \"-author\" );\r\n            cl.createArgument().setValue( \"-windowtitle\" );\r\n            cl.createArgument().setValue(\r\n                                          getConfiguration().getModel().getName() + \" \"\r\n                                              + getConfiguration().getModel().getVersion() );\r\n            cl.createArgument().setValue( \"-bottom\" );\r\n            cl.createArgument().setValue( \"Copyright &copy; \" + year + \" \"\r\n                                          + getConfiguration().getModel().getOrganization().getName()\r\n                                          + \". All Rights Reserved.\" );\r\n            cl.createArgument().setValue( \"-sourcePath\" );\r\n            cl.createArgument().setValue( sourcePath.toString() );\r\n            cl.createArgument().setValue( \"-d\" );\r\n            cl.createArgument().setValue( outputDir.getAbsolutePath() );\r\n            cl.createArgument().setValue( \"-classpath\" );\r\n            cl.createArgument().setValue( classpath.toString() );\r\n            cl.createArgument().setValue( \"@files\" );\r\n            System.out.println( getJavadocPath() );\r\n            System.out.println( Commandline.toString( cl.getCommandline() ) );\r\n            System.out.println( cl.getWorkingDirectory() );\r\n            int exitCode = CommandLineUtils.executeCommandLine( cl, new DefaultConsumer(), new DefaultConsumer() );\r\n            if ( exitCode != 0 )\r\n            {\r\n                throw new MavenReportException( \"exit code: \" + exitCode );\r\n            }\r\n        }\r\n        catch ( Exception e )\r\n        {\r\n            throw new MavenReportException( \"An error is occurred in javadoc report generation.\", e );\r\n        }\r\n    }","commit_id":"84bde74bf49d0cf4334d5347b0f1564797366aae","url":"https://github.com/apache/maven"},{"original_method":"private void runGoals()\n        throws MojoExecutionException\n    {\n        // TODO: we need to get a reference to the maven component and use that so this\n        // will work purely in an embedded mode. Not sure how to pass the release setting to the plugin in that\n        // instance though - still via -D, or is there a better way?\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"m2\" );\n\n        cl.setWorkingDirectory( workingDirectory );\n\n        cl.createArgument().setLine( goals );\n\n        cl.createArgument().setLine( \"-DperformRelease=true\" );\n\n        cl.createArgument().setLine( \"--no-plugin-updates\" );\n\n        cl.createArgument().setLine( \"--batch-mode\" );\n\n        StreamConsumer consumer = new DefaultConsumer();\n\n        try\n        {\n            CommandLineUtils.executeCommandLine( cl, consumer, consumer );\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\n        }\n    }","id":176,"modified_method":"private void runGoals()\n        throws MojoExecutionException\n    {\n        // TODO: we need to get a reference to the maven component and use that so this\n        // will work purely in an embedded mode. Not sure how to pass the release setting to the plugin in that\n        // instance though - still via -D, or is there a better way?\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"m2\" );\n\n        cl.setWorkingDirectory( workingDirectory );\n\n        cl.createArgument().setLine( goals );\n\n        cl.createArgument().setLine( \"-DperformRelease=true\" );\n\n        cl.createArgument().setLine( \"--no-plugin-updates\" );\n\n        cl.createArgument().setLine( \"--batch-mode\" );\n        \n        StreamConsumer consumer = new DefaultConsumer();\n\n        try\n        {\n            int result = CommandLineUtils.executeCommandLine( cl, consumer, consumer );\n            \n            if ( result != 0 )\n            {\n                throw new MojoExecutionException(\"Result of m2 execution is: \\'\" + result + \"\\'. Release failed.\" );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\n        }\n    }","commit_id":"66dddfc944763a6455f5e9b77c168a3148870a70","url":"https://github.com/apache/maven"},{"original_method":"private String href() {\n\t\treturn ERXWOContext.ajaxActionUrl(context());\n\t}","id":177,"modified_method":"private String href() {\n\t\treturn context().componentActionURL(WOApplication.application().componentRequestHandlerKey());\n\t}","commit_id":"2d87556c30539dd91d4f34654e52d690eca9c580","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String href() {\n    \tif (hasBinding(Bindings.action)) {\n    \t\treturn ERXWOContext.ajaxActionUrl(context());\n    \t} else if (hasBinding(Bindings.directActionName)) {\n    \t\tNSDictionary queryDictionary = hasBinding(Bindings.queryDictionary) ? queryDictionary() : null;\n    \t\treturn context().directActionURLForActionNamed(directActionName(), queryDictionary);\n    \t} else return \"#\";\n    }","id":178,"modified_method":"public String href() {\n    \tif (hasBinding(Bindings.action)) {\n    \t\treturn context().componentActionURL(WOApplication.application().componentRequestHandlerKey());\n    \t} else if (hasBinding(Bindings.directActionName)) {\n    \t\tNSDictionary queryDictionary = hasBinding(Bindings.queryDictionary) ? queryDictionary() : null;\n    \t\treturn context().directActionURLForActionNamed(directActionName(), queryDictionary);\n    \t} else return \"#\";\n    }","commit_id":"2d87556c30539dd91d4f34654e52d690eca9c580","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String href() {\n\t\tif (hasBinding(Bindings.action)) {\n\t\t\treturn ERXWOContext.ajaxActionUrl(context());\n\t\t} else if (hasBinding(Bindings.directActionName)) {\n\t\t\tNSDictionary queryDictionary = hasBinding(Bindings.queryDictionary) ? queryDictionary() : null;\n\t\t\treturn context().directActionURLForActionNamed(directActionName(), queryDictionary);\n\t\t} else return \"#\";\n\t}","id":179,"modified_method":"public String href() {\n\t\tif (hasBinding(Bindings.action)) {\n    \t\treturn context().componentActionURL(WOApplication.application().componentRequestHandlerKey());\n\t\t} else if (hasBinding(Bindings.directActionName)) {\n\t\t\tNSDictionary queryDictionary = hasBinding(Bindings.queryDictionary) ? queryDictionary() : null;\n\t\t\treturn context().directActionURLForActionNamed(directActionName(), queryDictionary);\n\t\t} else return \"#\";\n\t}","commit_id":"2d87556c30539dd91d4f34654e52d690eca9c580","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n    public void visitField(@NotNull PsiField field) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(field)) {\n        return;\n      }\n      if (!hasDeprecatedComment(field) || hasDeprecatedAnnotation(field)) {\n        return;\n      }\n      registerFieldError(field);\n    }","id":180,"modified_method":"@Override\n    public void visitField(@NotNull PsiField field) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(field)) {\n        return;\n      }\n      if (hasDeprecatedAnnotation(field)) {\n        if (warnOnMissingJavadoc && !hasDeprecatedComment(field, true)) {\n          registerFieldError(field, Boolean.FALSE);\n        }\n      }\n      else if (hasDeprecatedComment(field, false)) {\n        registerFieldError(field, Boolean.TRUE);\n      }\n    }","commit_id":"ff0a2db4435345ec32fc9221bc367855d4197b33","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(method)) {\n        return;\n      }\n      if (method.getNameIdentifier() == null) {\n        return;\n      }\n      if (!hasDeprecatedComment(method) || hasDeprecatedAnnotation(method)) {\n        return;\n      }\n      registerMethodError(method);\n    }","id":181,"modified_method":"@Override\n    public void visitMethod(@NotNull PsiMethod method) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(method)) {\n        return;\n      }\n      if (method.getNameIdentifier() == null) {\n        return;\n      }\n      if (hasDeprecatedAnnotation(method)) {\n        if (warnOnMissingJavadoc && !hasDeprecatedComment(method, true)) {\n          registerMethodError(method, Boolean.FALSE);\n        }\n      }\n      else if (hasDeprecatedComment(method, false)) {\n        registerMethodError(method, Boolean.TRUE);\n      }\n    }","commit_id":"ff0a2db4435345ec32fc9221bc367855d4197b33","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitClass(@NotNull PsiClass aClass) {\n      super.visitClass(aClass);\n      if (!PsiUtil.isLanguageLevel5OrHigher(aClass)) {\n        return;\n      }\n      if (!hasDeprecatedComment(aClass) || hasDeprecatedAnnotation(aClass)) {\n        return;\n      }\n      registerClassError(aClass);\n    }","id":182,"modified_method":"@Override\n    public void visitClass(@NotNull PsiClass aClass) {\n      super.visitClass(aClass);\n      if (!PsiUtil.isLanguageLevel5OrHigher(aClass)) {\n        return;\n      }\n      if (hasDeprecatedAnnotation(aClass)) {\n        if (warnOnMissingJavadoc && !hasDeprecatedComment(aClass, true)) {\n          registerClassError(aClass, Boolean.FALSE);\n        }\n      }\n      else if (hasDeprecatedComment(aClass, false)) {\n        registerClassError(aClass, Boolean.TRUE);\n      }\n    }","commit_id":"ff0a2db4435345ec32fc9221bc367855d4197b33","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void completeLocalVariableName(Set<LookupElement> set, PrefixMatcher matcher, PsiVariable var, boolean includeOverlapped) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"editing.completion.variable.name\");\n    final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(var.getProject());\n    final VariableKind variableKind = codeStyleManager.getVariableKind(var);\n\n    String propertyName = null;\n    if (variableKind == VariableKind.PARAMETER) {\n      final PsiMethod method = PsiTreeUtil.getParentOfType(var, PsiMethod.class);\n      propertyName = PropertyUtil.getPropertyName(method);\n    }\n\n    final PsiType type = var.getType();\n    SuggestedNameInfo suggestedNameInfo = codeStyleManager.suggestVariableName(variableKind, propertyName, null, type, StringUtil.isEmpty(matcher.getPrefix()));\n    final String[] suggestedNames = suggestedNameInfo.names;\n    tunePreferencePolicy(LookupItemUtil.addLookupItems(set, suggestedNames, matcher), suggestedNameInfo);\n    if (set.isEmpty()) {\n      if (type.equalsToText(CommonClassNames.JAVA_LANG_OBJECT) && matcher.prefixMatches(\"object\")) {\n        set.add(LookupElementBuilder.create(\"object\"));\n      }\n      if (type.equalsToText(CommonClassNames.JAVA_LANG_STRING) && matcher.prefixMatches(\"string\")) {\n        set.add(LookupElementBuilder.create(\"string\"));\n      }\n    }\n\n    if (set.isEmpty() && includeOverlapped) {\n      suggestedNameInfo = new SuggestedNameInfo(getOverlappedNameVersions(matcher.getPrefix(), suggestedNames, \"\")) {\n        public void nameChoosen(String name) {\n        }\n      };\n\n      tunePreferencePolicy(LookupItemUtil.addLookupItems(set, suggestedNameInfo.names, matcher), suggestedNameInfo);\n    }\n    PsiElement parent = PsiTreeUtil.getParentOfType(var, PsiCodeBlock.class);\n    if(parent == null) parent = PsiTreeUtil.getParentOfType(var, PsiMethod.class);\n    tunePreferencePolicy(LookupItemUtil.addLookupItems(set, getUnresolvedReferences(parent, false), matcher), suggestedNameInfo);\n\n    PsiExpression initializer = var.getInitializer();\n    if (initializer != null) {\n      SuggestedNameInfo initializerSuggestions = IntroduceVariableBase.getSuggestedName(type, initializer);\n      tunePreferencePolicy(LookupItemUtil.addLookupItems(set, initializerSuggestions.names, matcher), initializerSuggestions);\n    }\n  }","id":183,"modified_method":"private static void completeLocalVariableName(Set<LookupElement> set, PrefixMatcher matcher, PsiVariable var, boolean includeOverlapped) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"editing.completion.variable.name\");\n    final JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(var.getProject());\n    final VariableKind variableKind = codeStyleManager.getVariableKind(var);\n\n    String propertyName = null;\n    if (variableKind == VariableKind.PARAMETER) {\n      final PsiMethod method = PsiTreeUtil.getParentOfType(var, PsiMethod.class);\n      propertyName = PropertyUtil.getPropertyName(method);\n    }\n\n    final PsiType type = var.getType();\n    SuggestedNameInfo suggestedNameInfo = codeStyleManager.suggestVariableName(variableKind, propertyName, null, type, StringUtil.isEmpty(matcher.getPrefix()));\n    suggestedNameInfo = codeStyleManager.suggestUniqueVariableName(suggestedNameInfo, var, false);\n    final String[] suggestedNames = suggestedNameInfo.names;\n    addLookupItems(set, suggestedNameInfo, matcher, suggestedNames);\n    if (set.isEmpty()) {\n      if (type.equalsToText(CommonClassNames.JAVA_LANG_OBJECT) && matcher.prefixMatches(\"object\")) {\n        set.add(LookupElementBuilder.create(\"object\"));\n      }\n      if (type.equalsToText(CommonClassNames.JAVA_LANG_STRING) && matcher.prefixMatches(\"string\")) {\n        set.add(LookupElementBuilder.create(\"string\"));\n      }\n    }\n\n    if (set.isEmpty() && includeOverlapped) {\n      addLookupItems(set, null, matcher, getOverlappedNameVersions(matcher.getPrefix(), suggestedNames, \"\"));\n    }\n    PsiElement parent = PsiTreeUtil.getParentOfType(var, PsiCodeBlock.class);\n    if(parent == null) parent = PsiTreeUtil.getParentOfType(var, PsiMethod.class);\n    addLookupItems(set, suggestedNameInfo, matcher, getUnresolvedReferences(parent, false));\n\n    PsiExpression initializer = var.getInitializer();\n    if (initializer != null) {\n      SuggestedNameInfo initializerSuggestions = IntroduceVariableBase.getSuggestedName(type, initializer);\n      addLookupItems(set, initializerSuggestions, matcher, initializerSuggestions.names);\n    }\n  }","commit_id":"744cc3c5ed2571bcd8057ba04ef89ef4a48f500b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void completeFieldName(Set<LookupElement> set, PsiField var, final PrefixMatcher matcher, boolean includeOverlapped) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"editing.completion.variable.name\");\n\n    JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(var.getProject());\n    final VariableKind variableKind = JavaCodeStyleManager.getInstance(var.getProject()).getVariableKind(var);\n\n    final String prefix = matcher.getPrefix();\n    if (PsiType.VOID.equals(var.getType()) || psiField().inClass(psiClass().isInterface()).accepts(var)) {\n      completeVariableNameForRefactoring(var.getProject(), set, matcher, var.getType(), variableKind, includeOverlapped, true);\n      return;\n    }\n\n    SuggestedNameInfo suggestedNameInfo = codeStyleManager.suggestVariableName(variableKind, null, null, var.getType());\n    final String[] suggestedNames = suggestedNameInfo.names;\n    tunePreferencePolicy(LookupItemUtil.addLookupItems(set, suggestedNames, matcher), suggestedNameInfo);\n\n    if (set.isEmpty() && includeOverlapped) {\n      // use suggested names as suffixes\n      final String requiredSuffix = codeStyleManager.getSuffixByVariableKind(variableKind);\n      if(variableKind != VariableKind.STATIC_FINAL_FIELD){\n        for (int i = 0; i < suggestedNames.length; i++)\n          suggestedNames[i] = codeStyleManager.variableNameToPropertyName(suggestedNames[i], variableKind);\n      }\n\n\n      suggestedNameInfo = new SuggestedNameInfo(getOverlappedNameVersions(prefix, suggestedNames, requiredSuffix)) {\n        public void nameChoosen(String name) {\n        }\n      };\n\n      tunePreferencePolicy(LookupItemUtil.addLookupItems(set, suggestedNameInfo.names, matcher), suggestedNameInfo);\n    }\n\n    tunePreferencePolicy(LookupItemUtil.addLookupItems(set, getUnresolvedReferences(var.getParent(), false), matcher), suggestedNameInfo);\n\n    PsiExpression initializer = var.getInitializer();\n    PsiClass containingClass = var.getContainingClass();\n    if (initializer != null && containingClass != null) {\n      SuggestedNameInfo initializerSuggestions = InplaceIntroduceFieldPopup.\n        suggestFieldName(var.getType(), null, initializer, var.hasModifierProperty(PsiModifier.STATIC), containingClass);\n      tunePreferencePolicy(LookupItemUtil.addLookupItems(set, initializerSuggestions.names, matcher), initializerSuggestions);\n    }\n  }","id":184,"modified_method":"private static void completeFieldName(Set<LookupElement> set, PsiField var, final PrefixMatcher matcher, boolean includeOverlapped) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"editing.completion.variable.name\");\n\n    JavaCodeStyleManager codeStyleManager = JavaCodeStyleManager.getInstance(var.getProject());\n    final VariableKind variableKind = JavaCodeStyleManager.getInstance(var.getProject()).getVariableKind(var);\n\n    final String prefix = matcher.getPrefix();\n    if (PsiType.VOID.equals(var.getType()) || psiField().inClass(psiClass().isInterface()).accepts(var)) {\n      completeVariableNameForRefactoring(var.getProject(), set, matcher, var.getType(), variableKind, includeOverlapped, true);\n      return;\n    }\n\n    SuggestedNameInfo suggestedNameInfo = codeStyleManager.suggestVariableName(variableKind, null, null, var.getType());\n    final String[] suggestedNames = suggestedNameInfo.names;\n    addLookupItems(set, suggestedNameInfo, matcher, suggestedNames);\n\n    if (set.isEmpty() && includeOverlapped) {\n      // use suggested names as suffixes\n      final String requiredSuffix = codeStyleManager.getSuffixByVariableKind(variableKind);\n      if(variableKind != VariableKind.STATIC_FINAL_FIELD){\n        for (int i = 0; i < suggestedNames.length; i++)\n          suggestedNames[i] = codeStyleManager.variableNameToPropertyName(suggestedNames[i], variableKind);\n      }\n\n\n      addLookupItems(set, null, matcher, getOverlappedNameVersions(prefix, suggestedNames, requiredSuffix));\n    }\n\n    addLookupItems(set, suggestedNameInfo, matcher, getUnresolvedReferences(var.getParent(), false));\n\n    PsiExpression initializer = var.getInitializer();\n    PsiClass containingClass = var.getContainingClass();\n    if (initializer != null && containingClass != null) {\n      SuggestedNameInfo initializerSuggestions = InplaceIntroduceFieldPopup.\n        suggestFieldName(var.getType(), null, initializer, var.hasModifierProperty(PsiModifier.STATIC), containingClass);\n      addLookupItems(set, initializerSuggestions, matcher, initializerSuggestions.names);\n    }\n  }","commit_id":"744cc3c5ed2571bcd8057ba04ef89ef4a48f500b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Double rtt = null;\n        InetAddress host = (InetAddress) iface.getAddress();\n\n        try {\n            \n            // get parameters\n            //\n            int retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n            long timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n            \n            rtt = (double)Pinger.ping(host, timeout, retries);\n        } catch (Exception e) {\n            log.debug(\"failed to ping \" + host, e);\n        }\n        \n        if (rtt != null) {\n            return PollStatus.available(rtt);\n        } else {\n            // TODO add a reason code for unavailability\n            return PollStatus.unavailable();\n        }\n\n    }","id":185,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        Long rtt = null;\n        InetAddress host = (InetAddress) iface.getAddress();\n\n        try {\n            \n            // get parameters\n            //\n            int retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n            long timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n            \n            rtt = Pinger.ping(host, timeout, retries);\n        } catch (Exception e) {\n            log.debug(\"failed to ping \" + host, e);\n        }\n        \n        if (rtt != null) {\n            return PollStatus.available(rtt.doubleValue());\n        } else {\n            // TODO add a reason code for unavailability\n            return PollStatus.unavailable();\n        }\n\n    }","commit_id":"566d665edec1c32b76a9cb00cec8844f55dffccd","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Double rtt = null;\n        InetAddress host = (InetAddress) iface.getAddress();\n\n        try {\n            \n            // get parameters\n            //\n            int retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n            long timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n            \n            rtt = (double)Pinger.ping(host, timeout, retries);\n        } catch (Exception e) {\n            log.debug(\"failed to ping \" + host, e);\n        }\n        \n        if (rtt != null) {\n            return PollStatus.available(rtt);\n        } else {\n            // TODO add a reason code for unavailability\n            return PollStatus.unavailable();\n        }\n\n    }","id":186,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        Long rtt = null;\n        InetAddress host = (InetAddress) iface.getAddress();\n\n        try {\n            \n            // get parameters\n            //\n            int retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n            long timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n            \n            rtt = Pinger.ping(host, timeout, retries);\n        } catch (Exception e) {\n            log.debug(\"failed to ping \" + host, e);\n        }\n        \n        if (rtt != null) {\n            return PollStatus.available(rtt.doubleValue());\n        } else {\n            // TODO add a reason code for unavailability\n            return PollStatus.unavailable();\n        }\n\n    }","commit_id":"4826f4ee4b3d53eda88a1236d0252372f4b25a1f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availibility of the interface and if a transition event\n     *         should be supressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        PollStatus serviceStatus = PollStatus.unavailable();\n        Double rtt = null;\n        InetAddress host = (InetAddress) iface.getAddress();\n\n        try {\n            \n            // get parameters\n            //\n            int retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n            long timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n            \n            rtt = (double)Pinger.ping(host, timeout, retries);\n        } catch (Exception e) {\n            log.debug(\"failed to ping \" + host, e);\n        }\n        \n        if (rtt != null) {\n            return PollStatus.available(rtt);\n        } else {\n            // TODO add a reason code for unavailability\n            return PollStatus.unavailable();\n        }\n\n    }","id":187,"modified_method":"/**\n     * <P>\n     * Poll the specified address for ICMP service availability.\n     * <\/P>\n     * \n     * <P>\n     * The ICMP service monitor relies on Discovery for the actual generation of\n     * IMCP 'ping' requests. A JSDT session with two channels (send/recv) is\n     * utilized for passing poll requests and receiving poll replies from\n     * discovery. All exchanges are SOAP/XML compliant.\n     * <\/P>\n     * @param parameters\n     *            The package parameters (timeout, retry, etc...) to be used for\n     *            this poll.\n     * @param iface\n     *            The network interface to test the service on.\n     * @return The availability of the interface and if a transition event\n     *         should be suppressed.\n     * \n     */\n    public PollStatus poll(MonitoredService svc, Map parameters) {\n        NetworkInterface iface = svc.getNetInterface();\n\n        // Get interface address from NetworkInterface\n        //\n        if (iface.getType() != NetworkInterface.TYPE_IPV4)\n            throw new NetworkInterfaceNotSupportedException(\"Unsupported interface type, only TYPE_IPV4 currently supported\");\n\n        Category log = ThreadCategory.getInstance(this.getClass());\n        Long rtt = null;\n        InetAddress host = (InetAddress) iface.getAddress();\n\n        try {\n            \n            // get parameters\n            //\n            int retries = ParameterMap.getKeyedInteger(parameters, \"retry\", Pinger.DEFAULT_RETRIES);\n            long timeout = ParameterMap.getKeyedLong(parameters, \"timeout\", Pinger.DEFAULT_TIMEOUT);\n            \n            rtt = Pinger.ping(host, timeout, retries);\n        } catch (Exception e) {\n            log.debug(\"failed to ping \" + host, e);\n        }\n        \n        if (rtt != null) {\n            return PollStatus.available(rtt.doubleValue());\n        } else {\n            // TODO add a reason code for unavailability\n            return PollStatus.unavailable();\n        }\n\n    }","commit_id":"0af15d7a2531d224bddf5b9f8ad0ba478be1cb6e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void run()\n    {\n        try\n        {\n            while ( run )\n            {\n                Long logVersion = queue.poll();\n                if ( logVersion != null )\n                {\n                    if ( logVersion == xaDs.getCurrentLogVersion() )\n                    {\n                        ReadableByteChannel logChannel = \n                            xaDs.getLogicalLog( logVersion );\n                        xaDs.applyLog( logChannel );\n                    }\n                }\n                else\n                {\n                    synchronized ( this )\n                    {\n                        try\n                        {\n                            this.wait( 250 );\n                        }\n                        catch ( InterruptedException e )\n                        {\n                            interrupted();\n                        }\n                    }\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println( \"Failed to apply log: \" + e );\n            e.printStackTrace();\n        }\n        finally\n        {\n            run = false;\n        }\n    }","id":188,"modified_method":"public void run()\n    {\n        try\n        {\n            while ( run )\n            {\n//                Long logVersion = queue.poll();\n//                if ( logVersion != null )\n//                {\n                long logVersion = xaDs.getCurrentLogVersion();\n                if ( xaDs.hasLogicalLog( logVersion ) )\n                {\n                    ReadableByteChannel logChannel = \n                        xaDs.getLogicalLog( logVersion );\n                    xaDs.applyLog( logChannel );\n                }\n                else\n                {\n                    synchronized ( this )\n                    {\n                        try\n                        {\n                            this.wait( 250 );\n                        }\n                        catch ( InterruptedException e )\n                        {\n                            interrupted();\n                        }\n                    }\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println( \"Failed to apply log: \" + e );\n            e.printStackTrace();\n        }\n        finally\n        {\n            run = false;\n        }\n    }","commit_id":"12f003c4c82fa01756e3a877c79fcf079595a934","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void run()\n    {\n        try\n        {\n            while ( run )\n            {\n                Long logVersion = queue.poll();\n                if ( logVersion != null )\n                {\n                    if ( logVersion == xaDs.getCurrentLogVersion() )\n                    {\n                        ReadableByteChannel logChannel = \n                            xaDs.getLogicalLog( logVersion );\n                        xaDs.applyLog( logChannel );\n                    }\n                }\n                else\n                {\n                    synchronized ( this )\n                    {\n                        try\n                        {\n                            this.wait( 250 );\n                        }\n                        catch ( InterruptedException e )\n                        {\n                            interrupted();\n                        }\n                    }\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println( \"Failed to apply log: \" + e );\n            e.printStackTrace();\n        }\n        finally\n        {\n            run = false;\n        }\n    }","id":189,"modified_method":"public void run()\n    {\n        try\n        {\n            while ( run )\n            {\n//                Long logVersion = queue.poll();\n//                if ( logVersion != null )\n//                {\n                long logVersion = xaDs.getCurrentLogVersion();\n                if ( xaDs.hasLogicalLog( logVersion ) )\n                {\n                    ReadableByteChannel logChannel = \n                        xaDs.getLogicalLog( logVersion );\n                    xaDs.applyLog( logChannel );\n                }\n                else\n                {\n                    synchronized ( this )\n                    {\n                        try\n                        {\n                            this.wait( 250 );\n                        }\n                        catch ( InterruptedException e )\n                        {\n                            interrupted();\n                        }\n                    }\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println( \"Failed to apply log: \" + e );\n            e.printStackTrace();\n        }\n        finally\n        {\n            run = false;\n        }\n    }","commit_id":"bb6f48ae9424014df9a423f9a395c2b731cb48a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void run()\n    {\n        try\n        {\n            while ( run )\n            {\n                Long logVersion = queue.poll();\n                if ( logVersion != null )\n                {\n                    if ( logVersion == xaDs.getCurrentLogVersion() )\n                    {\n                        ReadableByteChannel logChannel = \n                            xaDs.getLogicalLog( logVersion );\n                        xaDs.applyLog( logChannel );\n                    }\n                }\n                else\n                {\n                    synchronized ( this )\n                    {\n                        try\n                        {\n                            this.wait( 250 );\n                        }\n                        catch ( InterruptedException e )\n                        {\n                            interrupted();\n                        }\n                    }\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println( \"Failed to apply log: \" + e );\n            e.printStackTrace();\n        }\n        finally\n        {\n            run = false;\n        }\n    }","id":190,"modified_method":"public void run()\n    {\n        try\n        {\n            while ( run )\n            {\n//                Long logVersion = queue.poll();\n//                if ( logVersion != null )\n//                {\n                long logVersion = xaDs.getCurrentLogVersion();\n                if ( xaDs.hasLogicalLog( logVersion ) )\n                {\n                    ReadableByteChannel logChannel = \n                        xaDs.getLogicalLog( logVersion );\n                    xaDs.applyLog( logChannel );\n                }\n                else\n                {\n                    synchronized ( this )\n                    {\n                        try\n                        {\n                            this.wait( 250 );\n                        }\n                        catch ( InterruptedException e )\n                        {\n                            interrupted();\n                        }\n                    }\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            System.err.println( \"Failed to apply log: \" + e );\n            e.printStackTrace();\n        }\n        finally\n        {\n            run = false;\n        }\n    }","commit_id":"315e5d2a37221dba5dff1f89d503991832de1817","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void startClusterMerge(final Address targetAddress) {\n        ClusterServiceImpl clusterService = node.clusterService;\n\n        if (!prepareClusterState(clusterService)) {\n            return;\n        }\n\n        OperationService operationService = node.nodeEngine.getOperationService();\n        Collection<Member> memberList = clusterService.getMembers();\n        for (Member member : memberList) {\n            if (!member.localMember()) {\n                Operation op = new MergeClustersOperation(targetAddress);\n                operationService.invokeOnTarget(ClusterServiceImpl.SERVICE_NAME, op, member.getAddress());\n            }\n        }\n\n        Operation mergeClustersOperation = new MergeClustersOperation(targetAddress);\n        mergeClustersOperation.setNodeEngine(node.nodeEngine).setService(clusterService)\n                .setOperationResponseHandler(createEmptyResponseHandler());\n        operationService.runOperationOnCallingThread(mergeClustersOperation);\n    }","id":191,"modified_method":"protected void startClusterMerge(final Address targetAddress) {\n        ClusterServiceImpl clusterService = node.clusterService;\n\n        if (!prepareClusterState(clusterService)) {\n            return;\n        }\n\n        OperationService operationService = node.nodeEngine.getOperationService();\n        Collection<Member> memberList = clusterService.getMembers();\n        Collection<Future> futures = new ArrayList<Future>(memberList.size());\n        for (Member member : memberList) {\n            if (!member.localMember()) {\n                Operation op = new MergeClustersOperation(targetAddress);\n                Future<Object> future =\n                        operationService.invokeOnTarget(ClusterServiceImpl.SERVICE_NAME, op, member.getAddress());\n                futures.add(future);\n            }\n        }\n\n        waitWithDeadline(futures, SPLIT_BRAIN_MERGE_TIMEOUT_SECONDS, TimeUnit.SECONDS, splitBrainMergeExceptionHandler);\n\n        Operation mergeClustersOperation = new MergeClustersOperation(targetAddress);\n        mergeClustersOperation.setNodeEngine(node.nodeEngine).setService(clusterService)\n                .setOperationResponseHandler(createEmptyResponseHandler());\n        operationService.runOperationOnCallingThread(mergeClustersOperation);\n    }","commit_id":"bd2187e6c505b3a80dae4c73952a340f5925b67d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void enableStatisticManagementOnOtherNodes(String cacheName, boolean statOrMan, boolean enabled) {\n        final String cacheNameWithPrefix = getCacheNameWithPrefix(cacheName);\n        final Collection<MemberImpl> members = nodeEngine.getClusterService().getMemberList();\n        for (MemberImpl member : members) {\n            if (!member.localMember()) {\n                final CacheManagementConfigOperation op = new CacheManagementConfigOperation(cacheNameWithPrefix, statOrMan,\n                        enabled);\n                nodeEngine.getOperationService().invokeOnTarget(CacheService.SERVICE_NAME, op, member.getAddress());\n            }\n        }\n    }","id":192,"modified_method":"private void enableStatisticManagementOnOtherNodes(String cacheName, boolean statOrMan, boolean enabled) {\n        final String cacheNameWithPrefix = getCacheNameWithPrefix(cacheName);\n        final Collection<MemberImpl> members = nodeEngine.getClusterService().getMemberList();\n        final Collection<Future> futures = new ArrayList<Future>();\n        for (MemberImpl member : members) {\n            if (!member.localMember()) {\n                final CacheManagementConfigOperation op = new CacheManagementConfigOperation(cacheNameWithPrefix, statOrMan,\n                        enabled);\n                final Future future = nodeEngine.getOperationService()\n                                                .invokeOnTarget(CacheService.SERVICE_NAME, op, member.getAddress());\n                futures.add(future);\n            }\n        }\n        try {\n            FutureUtil.waitWithDeadline(futures, CacheProxyUtil.AWAIT_COMPLETION_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        } catch (TimeoutException e) {\n            logger.warning(e);\n        }\n\n    }","commit_id":"7fb3ffefb14d5d54822561284bf7768e4d6b344a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void enableStatisticManagementOnOtherNodes(String cacheName, boolean statOrMan, boolean enabled) {\n        final String cacheNameWithPrefix = getCacheNameWithPrefix(cacheName);\n        final Collection<MemberImpl> members = nodeEngine.getClusterService().getMemberList();\n        for (MemberImpl member : members) {\n            if (!member.localMember()) {\n                final CacheManagementConfigOperation op = new CacheManagementConfigOperation(cacheNameWithPrefix, statOrMan,\n                        enabled);\n                nodeEngine.getOperationService().invokeOnTarget(CacheService.SERVICE_NAME, op, member.getAddress());\n            }\n        }\n    }","id":193,"modified_method":"private void enableStatisticManagementOnOtherNodes(String cacheName, boolean statOrMan, boolean enabled) {\n        final String cacheNameWithPrefix = getCacheNameWithPrefix(cacheName);\n        final Collection<MemberImpl> members = nodeEngine.getClusterService().getMemberList();\n        final Collection<Future> futures = new ArrayList<Future>();\n        for (MemberImpl member : members) {\n            if (!member.localMember()) {\n                final CacheManagementConfigOperation op = new CacheManagementConfigOperation(cacheNameWithPrefix, statOrMan,\n                        enabled);\n                final Future future = nodeEngine.getOperationService()\n                                                .invokeOnTarget(CacheService.SERVICE_NAME, op, member.getAddress());\n                futures.add(future);\n            }\n        }\n        try {\n            FutureUtil.waitWithDeadline(futures, CacheProxyUtil.AWAIT_COMPLETION_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        } catch (TimeoutException e) {\n            logger.warning(e);\n        }\n\n    }","commit_id":"27820c4d9e08b5e8398de5fdb08d738011cdcd46","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(moveRBTregex, moveRBTsurgeon, t);\n  }","id":194,"modified_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    for (TregexPattern pattern : moveRBTregex) {\n      t = Tsurgeon.processPattern(pattern, moveRBTsurgeon, t);\n    }\n    return t;\n  }","commit_id":"5f1ec57a90bf3a863c350191a0a5c0df16db8cd6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(moveRBTregex, moveRBTsurgeon, t);\n  }","id":195,"modified_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    for (TregexPattern pattern : moveRBTregex) {\n      t = Tsurgeon.processPattern(pattern, moveRBTsurgeon, t);\n    }\n    return t;\n  }","commit_id":"5d27780f8cd2cebc2e49a614539019118e057565","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(moveRBTregex, moveRBTsurgeon, t);\n  }","id":196,"modified_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    for (TregexPattern pattern : moveRBTregex) {\n      t = Tsurgeon.processPattern(pattern, moveRBTsurgeon, t);\n    }\n    return t;\n  }","commit_id":"fdc6ede47092680e4d1deb768af611cb3bcce2cc","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(moveRBTregex, moveRBTsurgeon, t);\n  }","id":197,"modified_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    for (TregexPattern pattern : moveRBTregex) {\n      t = Tsurgeon.processPattern(pattern, moveRBTsurgeon, t);\n    }\n    return t;\n  }","commit_id":"d0238d9376f7d59d9664f14300fb6db14fac6223","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(moveRBTregex, moveRBTsurgeon, t);\n  }","id":198,"modified_method":"public Tree moveRB(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    for (TregexPattern pattern : moveRBTregex) {\n      t = Tsurgeon.processPattern(pattern, moveRBTsurgeon, t);\n    }\n    return t;\n  }","commit_id":"6430082c7e5712d26a8b88bf8b86d975056170eb","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void pushByDoubleMath(int seen, Item it, Item it2) {\n\t\tItem result;\n\t\tint specialKind = Item.FLOAT_MATH;\n\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t\t\tif (seen == DADD)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) + ((Double) it.getConstant()));\n\t\t\telse if (seen == DSUB)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) - ((Double) it.getConstant()));\n\t\t\telse if (seen == DMUL)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) * ((Double) it.getConstant()));\n\t\t\telse if (seen == DDIV)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) / ((Double) it.getConstant()));\n\t\t\telse \n\t\t\t\tresult = new Item(\"D\");\t//?\t\n\t\t\t} else {\n\t\t\tresult = new Item(\"D\");\n\t\t\tif (seen == DDIV)\n\t\t\t\tspecialKind = Item.NASTY_FLOAT_MATH;\n\t\t}\n\t\tresult.setSpecialKind(specialKind);\n\t\tpush(result);\n\t}","id":199,"modified_method":"private void pushByDoubleMath(int seen, Item it, Item it2) {\n\t\tItem result;\n\t\tint specialKind = Item.FLOAT_MATH;\n\t\tif ((it.getConstant() instanceof Double) && it2.getConstant() instanceof Double) {\n\t\t\tif (seen == DADD)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) + ((Double) it.getConstant()));\n\t\t\telse if (seen == DSUB)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) - ((Double) it.getConstant()));\n\t\t\telse if (seen == DMUL)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) * ((Double) it.getConstant()));\n\t\t\telse if (seen == DDIV)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) / ((Double) it.getConstant()));\n\t\t\telse if (seen == DREM)\n\t\t\t\tresult = new Item(\"D\", ((Double) it2.getConstant()) % ((Double) it.getConstant()));\n\t\t\telse \n\t\t\t\tresult = new Item(\"D\");\t//?\t\n\t\t\t} else {\n\t\t\tresult = new Item(\"D\");\n\t\t\tif (seen == DDIV)\n\t\t\t\tspecialKind = Item.NASTY_FLOAT_MATH;\n\t\t}\n\t\tresult.setSpecialKind(specialKind);\n\t\tpush(result);\n\t}","commit_id":"4d28dbf5a1bfa5d8f4e1d49cf46240abac892f84","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void pushByFloatMath(int seen, Item it, Item it2) {\n\t\tItem result;\n\t\tint specialKind = Item.FLOAT_MATH;\n\t\tif ((it.getConstant() != null) && it2.getConstant() != null) {\n\t\t\tif (seen == FADD)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) + ((Float) it.getConstant()));\n\t\t\telse if (seen == FSUB)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) - ((Float) it.getConstant()));\n\t\t\telse if (seen == FMUL)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) * ((Float) it.getConstant()));\n\t\t\telse if (seen == FDIV)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) / ((Float) it.getConstant()));\n\t\t\t\telse result =new Item(\"F\");\n\t\t} else {\n\t\t\tresult =new Item(\"F\");\n\t\t\tif (seen == DDIV)\n\t\t\t\tspecialKind = Item.NASTY_FLOAT_MATH;\n\t\t}\n\t\tresult.setSpecialKind(specialKind);\n\t\tpush(result);\n\t}","id":200,"modified_method":"private void pushByFloatMath(int seen, Item it, Item it2) {\n\t\tItem result;\n\t\tint specialKind = Item.FLOAT_MATH;\n\t\tif ((it.getConstant() instanceof Float) && it2.getConstant() instanceof Float) {\n\t\t\tif (seen == FADD)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) + ((Float) it.getConstant()));\n\t\t\telse if (seen == FSUB)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) - ((Float) it.getConstant()));\n\t\t\telse if (seen == FMUL)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) * ((Float) it.getConstant()));\n\t\t\telse if (seen == FDIV)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) / ((Float) it.getConstant()));\n\t\t\telse if (seen == FREM)\n\t\t\t\tresult =new Item(\"F\", ((Float) it2.getConstant()) % ((Float) it.getConstant()));\n\t\t\telse result =new Item(\"F\");\n\t\t} else {\n\t\t\tresult =new Item(\"F\");\n\t\t\tif (seen == DDIV)\n\t\t\t\tspecialKind = Item.NASTY_FLOAT_MATH;\n\t\t}\n\t\tresult.setSpecialKind(specialKind);\n\t\tpush(result);\n\t}","commit_id":"4d28dbf5a1bfa5d8f4e1d49cf46240abac892f84","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private String getContentAnswer(ItemContentsBean item, PublishedAnswer answer, PrintSettingsBean printSetting) {\n\t\tStringBuffer contentBuffer = new StringBuffer();\n\t\t\n\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT) ||\n\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE) ||\n\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY) ||\n\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT_SINGLE_SELECTION)) {\n\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT))\n\t\t\t\tcontentBuffer.append(\"<td colspan='1'><img src='/samigo-app/images/unchecked.gif' /><\/td>\");\n\t\t\telse\n\t\t\t\tcontentBuffer.append(\"<td colspan='1'><img src='/samigo-app/images/radiounchecked.gif' /><\/td>\");\n\t\t\t\t\n\t\t\tif (printSetting.getShowKeysFeedback()) {\n\t\t\t\tcontentBuffer.append(\"<td colspan='10'>\");\n\t\t\t\tif (!item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY)) {\n\t\t\t\t\tcontentBuffer.append(answer.getLabel());\n\t\t\t\t\tcontentBuffer.append(\". \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(answer.getText())));\n\t\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t\t\tcontentBuffer.append(\"<td colspan='9'>\");\n\t\t\t\tcontentBuffer.append(\"<h6>\");\n\t\t\t\tcontentBuffer.append(commonMessages.getString(\"feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (answer.getGeneralAnswerFeedback() != null && !answer.getGeneralAnswerFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(answer.getGeneralAnswerFeedback())));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t\tcontentBuffer.append(\"<\/h6>\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontentBuffer.append(\"<td colspan='19'>\");\n\t\t\t\tif (!item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY)) {\n\t\t\t\t\tcontentBuffer.append(answer.getLabel());\n\t\t\t\t\tcontentBuffer.append(\". \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(answer.getText())));\n\t\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t\t}\n\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t}\n\n\t\tif (item.getItemData().getTypeId().equals(TypeIfc.TRUE_FALSE)) {\n\t\t\tcontentBuffer.append(\"<td colspan='1'><img src='/samigo-app/images/radiounchecked.gif' /><\/td>\");\n\t\t\tcontentBuffer.append(\"<td colspan='19'>\");\n\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(answer.getText())));\n\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t}\n\n\t\treturn contentBuffer.toString();\n\t}","id":201,"modified_method":"private String getContentAnswer(ItemContentsBean item, PublishedAnswer answer, PrintSettingsBean printSetting) {\n\t\tStringBuffer contentBuffer = new StringBuffer();\n\t\t\n\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT) ||\n\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE) ||\n\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY) ||\n\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT_SINGLE_SELECTION)) {\n\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT))\n\t\t\t\tcontentBuffer.append(\"<td colspan='1'><img src='/samigo-app/images/unchecked.gif' /><\/td>\");\n\t\t\telse\n\t\t\t\tcontentBuffer.append(\"<td colspan='1'><img src='/samigo-app/images/radiounchecked.gif' /><\/td>\");\n\t\t\t\t\n\t\t\tif (printSetting.getShowKeysFeedback()) {\n\t\t\t\tcontentBuffer.append(\"<td colspan='10'>\");\n\t\t\t\tif (!item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY)) {\n\t\t\t\t\tcontentBuffer.append(answer.getLabel());\n\t\t\t\t\tcontentBuffer.append(\". \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontentBuffer.append(convertFormattedText(answer.getText()));\n\t\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t\t\tcontentBuffer.append(\"<td colspan='9'>\");\n\t\t\t\tcontentBuffer.append(\"<h6>\");\n\t\t\t\tcontentBuffer.append(commonMessages.getString(\"feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (answer.getGeneralAnswerFeedback() != null && !answer.getGeneralAnswerFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(convertFormattedText(answer.getGeneralAnswerFeedback()));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t\tcontentBuffer.append(\"<\/h6>\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontentBuffer.append(\"<td colspan='19'>\");\n\t\t\t\tif (!item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY)) {\n\t\t\t\t\tcontentBuffer.append(answer.getLabel());\n\t\t\t\t\tcontentBuffer.append(\". \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontentBuffer.append(convertFormattedText(answer.getText()));\n\t\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t\t}\n\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t}\n\n\t\tif (item.getItemData().getTypeId().equals(TypeIfc.TRUE_FALSE)) {\n\t\t\tcontentBuffer.append(\"<td colspan='1'><img src='/samigo-app/images/radiounchecked.gif' /><\/td>\");\n\t\t\tcontentBuffer.append(\"<td colspan='19'>\");\n\t\t\tcontentBuffer.append(convertFormattedText(answer.getText()));\n\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t}\n\n\t\treturn contentBuffer.toString();\n\t}","commit_id":"12424a2614ec0d0d96d409569fe1f51b97c464f7","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String prepDocumentPDF() {\n\n\t\tDeliveryBean deliveryBean = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n\n\t\tPrintSettingsBean printSetting = (PrintSettingsBean) ContextUtil.lookupBean(\"printSettings\");\n\t\tsetBaseFontSize(printSetting.getFontSize());\n\n\t\tif (printSetting.getShowPartIntros().booleanValue()) {\n\t\t\tStringBuffer assessmentIntros = new StringBuffer();\n\t\t\tif (deliveryBean.getInstructorMessage() != null && !\"\".equals(deliveryBean.getInstructorMessage())) {\n\t\t\t\tassessmentIntros.append(deliveryBean.getInstructorMessage());\n\t\t\t\tassessmentIntros.append(\"<br />\");\n\t\t\t}\n\t\t\t\n\t\t\tif (deliveryBean.getAttachmentList() != null && deliveryBean.getAttachmentList().size() > 0) {\n\t\t\t\tassessmentIntros.append(\"<br />\");\n\t\t\t\tassessmentIntros.append(printMessages.getString(\"attachments\"));\n\n\t\t\t\tList assessmentAttachmentList = deliveryBean.getAttachmentList();\n\t\t\t\tIterator assessmentAttachmentIter = assessmentAttachmentList.iterator();\n\t\t\t\twhile (assessmentAttachmentIter.hasNext()) {\n\t\t\t\t\tassessmentIntros.append(\"<br />\");\n\t\t\t\t\tPublishedAssessmentAttachment assessmentAttachment = (PublishedAssessmentAttachment) assessmentAttachmentIter.next();\n\t\t\t\t\tif (assessmentAttachment.getMimeType().equalsIgnoreCase(\"image/jpeg\") || \n\t\t\t\t\t\t\tassessmentAttachment.getMimeType().equalsIgnoreCase(\"image/pjpeg\") || \n\t\t\t\t\t\t\tassessmentAttachment.getMimeType().equalsIgnoreCase(\"image/gif\") || \n\t\t\t\t\t\t\tassessmentAttachment.getMimeType().equalsIgnoreCase(\"image/png\")) {\n\t\t\t\t\t\tassessmentIntros.append(\"  <img src=\\\"/samigo\");\n\t\t\t\t\t\tassessmentIntros.append(assessmentAttachment.getResourceId());\n\t\t\t\t\t\tassessmentIntros.append(\"\\\" />\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassessmentIntros.append(\"  \");\n\t\t\t\t\t\tassessmentIntros.append(assessmentAttachment.getFilename());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsetIntro(assessmentIntros.toString());\t\n\t\t}\n\t\telse {\n\t\t\tsetIntro(\"\");\n\t\t}\n\n\t\tArrayList pdfParts = new ArrayList();\n\n\t\t//for each part in an assessment we add a pdfPart to the pdfBean\n\t\tfor (int i = 0; i < deliveryParts.size(); i++) {\n\t\t\t//get the current item\n\t\t\tSectionContentsBean section = (SectionContentsBean) deliveryParts.get(i);\n\t\t\tArrayList items = section.getItemContents();\n\t\t\tArrayList resources = new ArrayList();\n\n\t\t\t//create a new part and empty list to fill with items\n\t\t\tPDFPartBean pdfPart = new PDFPartBean();\n\t\t\tpdfPart.setSectionId(section.getSectionId());\n\n\t\t\tStringBuffer partIntros = new StringBuffer();\n\t\t\tpartIntros.append(\"<h2>\");\n\t\t\tpartIntros.append(authorMessages.getString(\"p\"));\n\t\t\tpartIntros.append(\" \");\n\t\t\tpartIntros.append(i+1);\n\t\t\tif (!printSetting.getShowPartIntros().booleanValue()) {\n\t\t\t\tpartIntros.append(\"<\/h2>\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (\"Default\".equalsIgnoreCase(section.getTitle())) {\n\t\t\t\t\tpartIntros.append(\"<\/h2>\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpartIntros.append(\": \");\n\t\t\t\t\tpartIntros.append(section.getTitle());\n\t\t\t\t\tpartIntros.append(\"<\/h2>\");\n\t\t\t\t}\n\t\t\t\tpartIntros.append(\"<br />\");\n\t\t\t\tif (section.getDescription() != null) {\n\t\t\t\t\tpartIntros.append(section.getDescription());\n\t\t\t\t}\n\t\t\t\tpartIntros.append(\"<br />\");\n\n\t\t\t\t\n\t\t\t\tif (section.getAttachmentList() != null && section.getAttachmentList().size() > 0) {\n\t\t\t\t\tpartIntros.append(\"<br />\");\n\t\t\t\t\tpartIntros.append(printMessages.getString(\"attachments\"));\n\n\t\t\t\t\tList partAttachmentList = section.getAttachmentList();\n\t\t\t\t\tIterator partAttachmentIter = partAttachmentList.iterator();\n\t\t\t\t\twhile (partAttachmentIter.hasNext()) {\n\t\t\t\t\t\tpartIntros.append(\"<br />\");\n\t\t\t\t\t\tPublishedSectionAttachment partAttachment = (PublishedSectionAttachment) partAttachmentIter.next();\n\t\t\t\t\t\tif (partAttachment.getMimeType().equalsIgnoreCase(\"image/jpeg\") || \n\t\t\t\t\t\t\t\tpartAttachment.getMimeType().equalsIgnoreCase(\"image/pjpeg\") || \n\t\t\t\t\t\t\t\tpartAttachment.getMimeType().equalsIgnoreCase(\"image/gif\") || \n\t\t\t\t\t\t\t\tpartAttachment.getMimeType().equalsIgnoreCase(\"image/png\")) {\n\t\t\t\t\t\t\tpartIntros.append(\"  <img src=\\\"/samigo\");\n\t\t\t\t\t\t\tpartIntros.append(partAttachment.getResourceId());\n\t\t\t\t\t\t\tpartIntros.append(\"\\\" />\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpartIntros.append(\"  \");\n\t\t\t\t\t\t\tpartIntros.append(partAttachment.getFilename());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpdfPart.setIntro(partIntros.toString());\n\n\t\t\tArrayList pdfItems = new ArrayList();\n\n\t\t\t//for each item in a section we add a blank pdfItem to the pdfPart\n\t\t\tfor (int j = 0; j < items.size(); j++) {\n\t\t\t\tPDFItemBean pdfItem = new PDFItemBean();\n\n\t\t\t\tItemContentsBean item = (ItemContentsBean) items.get(j);\n\t\t\t\t\n\t\t\t\tStringBuffer legacy = new StringBuffer(\"<h3>\");\n\t\t\t\tif (printSetting.getShowSequence().booleanValue()) {\n\t\t\t\t\tlegacy.append(item.getSequence());\n\t\t\t\t}\n\t\t\t\tlegacy.append(\"<\/h3>\");\n\n\t\t\t\tpdfItem.setItemId(item.getItemData().getItemId());\n\n\t\t\t\tStringBuffer contentBuffer = new StringBuffer(); \n\n\t\t\t\tif (!(item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) || item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC))) {\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(item.getItemData().getText())));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\t\t\t\tif (item.getItemData().getItemAttachmentList() != null && item.getItemData().getItemAttachmentList().size() > 0) {\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"attachments\"));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tList itemAttachmentList = item.getItemData().getItemAttachmentList();\n\t\t\t\t\tIterator itemAttachmentIter = itemAttachmentList.iterator();\n\t\t\t\t\twhile (itemAttachmentIter.hasNext()) {\n\t\t\t\t\t\tPublishedItemAttachment itemAttachment = (PublishedItemAttachment) itemAttachmentIter.next();\n\t\t\t\t\t\tif (itemAttachment.getMimeType().equalsIgnoreCase(\"image/jpeg\") || \n\t\t\t\t\t\t\titemAttachment.getMimeType().equalsIgnoreCase(\"image/pjpeg\") || \n\t\t\t\t\t\t\titemAttachment.getMimeType().equalsIgnoreCase(\"image/gif\") || \n\t\t\t\t\t\t\titemAttachment.getMimeType().equalsIgnoreCase(\"image/png\")) {\n\t\t\t\t\t\t\tcontentBuffer.append(\"  <img src=\\\"/samigo\");\n\t\t\t\t\t\t\tcontentBuffer.append(itemAttachment.getResourceId());\n\t\t\t\t\t\t\tcontentBuffer.append(\"\\\" />\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontentBuffer.append(\"  \");\n\t\t\t\t\t\t\tcontentBuffer.append(itemAttachment.getFilename());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) || item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC)) {\n\t\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC)) {\n\t\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\t\tcontentBuffer.append(deliveryMessages.getString(\"fin_accepted_instruction\"));\n\t\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\t}\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(item.getItemData().getText())));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.AUDIO_RECORDING)) {\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"time_allowed_seconds\"));\n\t\t\t\t\tcontentBuffer.append(\":\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getDuration());\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"number_of_tries\"));\n\t\t\t\t\tcontentBuffer.append(\":\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getTriesAllowed());\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILE_UPLOAD)) {\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"upload_instruction\"));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"file\"));\n\t\t\t\t\tcontentBuffer.append(\":\");\n\t\t\t\t\tcontentBuffer.append(\"<input type='text' size='50' />\");\n\t\t\t\t\tcontentBuffer.append(\"<input type='button' value='\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"browse\"));\n\t\t\t\t\tcontentBuffer.append(\":' />\");\n\t\t\t\t\tcontentBuffer.append(\"<input type='button' value='\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"upload\"));\n\t\t\t\t\tcontentBuffer.append(\":' />\");\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT_SINGLE_SELECTION) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.TRUE_FALSE) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MATRIX_CHOICES_SURVEY)) {\n\n\t\t\t\t\tList question = item.getItemData().getItemTextArraySorted();\n\t\t\t\t\tfor (int k=0; k<question.size(); k++) {\n\t\t\t\t\t\tPublishedItemText itemtext = (PublishedItemText)question.get(k);\n\t\t\t\t\t\tArrayList answers = itemtext.getAnswerArraySorted();\n\n\t\t\t\t\t\tcontentBuffer.append(\"<table cols='20' width='100%'>\");\n\t\t\t\t\t\tfor (int t=0; t<answers.size(); t++) {\n\t\t\t\t\t\t\tPublishedAnswer answer = (PublishedAnswer)answers.get(t);\n\t\t\t\t\t\t\tif (StringUtils.isBlank(answer.getText())) break;\n\t\t\t\t\t\t\tcontentBuffer.append(\"<tr>\");\n\t\t\t\t\t\t\tcontentBuffer.append(getContentAnswer(item, answer, printSetting));\n\t\t\t\t\t\t\tcontentBuffer.append(\"<\/tr>\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontentBuffer.append(\"<\/table>\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MATCHING)) {\n\t\t\t\t\tcontentBuffer.append(\"<table cols='20' width='100%'>\");\n\t\t\t\t\tList question = item.getMatchingArray();\n\t\t\t\t\tfor (int k=0; k<question.size(); k++) {\n\t\t\t\t\t\tMatchingBean matching = (MatchingBean)question.get(k);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if there are distractors or shared matches, answers will\n\t\t\t\t\t\t// have fewer answers that matches.\n\t\t\t\t\t\tString answer = \"\";\n\t\t\t\t\t\tif (k < item.getAnswers().size()) {\n\t\t\t\t\t\t\tanswer = (String)item.getAnswers().get(k);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (matching.getText() == null) break;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='10'>\");\n\t\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(matching.getText())));\n\t\t\t\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t\t\t\t\tcontentBuffer.append(\"<td colspan='10'>\");\n\t\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(answer)));\n\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcontentBuffer.append(\"<\/table>\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.EXTENDED_MATCHING_ITEMS)) {\n\t\t\t\t\tcontentBuffer.append(\"<table cols='20' width='100%'>\");\n\n\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getThemeText());\n\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\n\t\t\t\t\tif (item.getItemData().getIsAnswerOptionsSimple()) {\n\t\t\t\t\t\tList<AnswerIfc> emiAnswerOptions = item.getItemData().getEmiAnswerOptions();\n\t\t\t\t\t\tfor (AnswerIfc answerIfc : emiAnswerOptions) {\n\t\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\t\t\tcontentBuffer.append(answerIfc.getLabel() + \". \" + answerIfc.getText());\n\t\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.getItemData().getIsAnswerOptionsRich()) {\n\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\t\tcontentBuffer.append(item.getItemData().getEmiAnswerOptionsRichText());\n\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getLeadInText());\n\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\n\t\t\t\t\tList<ItemTextIfc> questionAnswerCombinations = item.getItemData().getEmiQuestionAnswerCombinations();\n\n\t\t\t\t\tfor (ItemTextIfc itemTextIfc : questionAnswerCombinations) {\n\t\t\t\t\t\tif (!itemTextIfc.getText().isEmpty()) {\n\t\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\t\t\tcontentBuffer.append(itemTextIfc.getSequence() + \". \" + itemTextIfc.getText() + \"  ____\");\n\t\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(\"<\/table>\");\n\t\t\t\t}\n\t\t\t\tif (printSetting.getShowKeys().booleanValue() || printSetting.getShowKeysFeedback().booleanValue()) {\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(getContentQuestion(item, printSetting));\n\t\t\t\t}\n\n\t\t\t\tpdfItem.setContent(contentBuffer.toString());\n\n\t\t\t\tif (legacy != null) {\n\t\t\t\t\tpdfItem.setMeta(legacy.toString()); \n\t\t\t\t}\n\n\t\t\t\tpdfItems.add(pdfItem);\n\t\t\t}\n\n\t\t\tpdfPart.setQuestions(pdfItems);\n\t\t\tpdfPart.setResources(resources);\n\t\t\tif (resources.size() > 0)\n\t\t\t\tpdfPart.setHasResources(Boolean.valueOf(true));\n\t\t\tpdfParts.add(pdfPart);\n\n\t\t}\n\n\t\t//set the new colleciton of PDF beans to be the contents of the pdfassessment\n\t\tsetParts(pdfParts);\n\n\t\tsetTitle(deliveryBean.getAssessmentTitle());\n\n\t\treturn \"print\";\n\t}","id":202,"modified_method":"public String prepDocumentPDF() {\n\n\t\tDeliveryBean deliveryBean = (DeliveryBean) ContextUtil.lookupBean(\"delivery\");\n\n\t\tPrintSettingsBean printSetting = (PrintSettingsBean) ContextUtil.lookupBean(\"printSettings\");\n\t\tsetBaseFontSize(printSetting.getFontSize());\n\n\t\tif (printSetting.getShowPartIntros().booleanValue()) {\n\t\t\tStringBuffer assessmentIntros = new StringBuffer();\n\t\t\tif (deliveryBean.getInstructorMessage() != null && !\"\".equals(deliveryBean.getInstructorMessage())) {\n\t\t\t\tassessmentIntros.append(deliveryBean.getInstructorMessage());\n\t\t\t\tassessmentIntros.append(\"<br />\");\n\t\t\t}\n\t\t\t\n\t\t\tif (deliveryBean.getAttachmentList() != null && deliveryBean.getAttachmentList().size() > 0) {\n\t\t\t\tassessmentIntros.append(\"<br />\");\n\t\t\t\tassessmentIntros.append(printMessages.getString(\"attachments\"));\n\n\t\t\t\tList assessmentAttachmentList = deliveryBean.getAttachmentList();\n\t\t\t\tIterator assessmentAttachmentIter = assessmentAttachmentList.iterator();\n\t\t\t\twhile (assessmentAttachmentIter.hasNext()) {\n\t\t\t\t\tassessmentIntros.append(\"<br />\");\n\t\t\t\t\tPublishedAssessmentAttachment assessmentAttachment = (PublishedAssessmentAttachment) assessmentAttachmentIter.next();\n\t\t\t\t\tif (assessmentAttachment.getMimeType().equalsIgnoreCase(\"image/jpeg\") || \n\t\t\t\t\t\t\tassessmentAttachment.getMimeType().equalsIgnoreCase(\"image/pjpeg\") || \n\t\t\t\t\t\t\tassessmentAttachment.getMimeType().equalsIgnoreCase(\"image/gif\") || \n\t\t\t\t\t\t\tassessmentAttachment.getMimeType().equalsIgnoreCase(\"image/png\")) {\n\t\t\t\t\t\tassessmentIntros.append(\"  <img src=\\\"/samigo\");\n\t\t\t\t\t\tassessmentIntros.append(assessmentAttachment.getResourceId());\n\t\t\t\t\t\tassessmentIntros.append(\"\\\" />\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassessmentIntros.append(\"  \");\n\t\t\t\t\t\tassessmentIntros.append(assessmentAttachment.getFilename());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsetIntro(assessmentIntros.toString());\t\n\t\t}\n\t\telse {\n\t\t\tsetIntro(\"\");\n\t\t}\n\n\t\tArrayList pdfParts = new ArrayList();\n\n\t\t//for each part in an assessment we add a pdfPart to the pdfBean\n\t\tfor (int i = 0; i < deliveryParts.size(); i++) {\n\t\t\t//get the current item\n\t\t\tSectionContentsBean section = (SectionContentsBean) deliveryParts.get(i);\n\t\t\tArrayList items = section.getItemContents();\n\t\t\tArrayList resources = new ArrayList();\n\n\t\t\t//create a new part and empty list to fill with items\n\t\t\tPDFPartBean pdfPart = new PDFPartBean();\n\t\t\tpdfPart.setSectionId(section.getSectionId());\n\n\t\t\tStringBuffer partIntros = new StringBuffer();\n\t\t\tpartIntros.append(\"<h2>\");\n\t\t\tpartIntros.append(authorMessages.getString(\"p\"));\n\t\t\tpartIntros.append(\" \");\n\t\t\tpartIntros.append(i+1);\n\t\t\tif (!printSetting.getShowPartIntros().booleanValue()) {\n\t\t\t\tpartIntros.append(\"<\/h2>\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (\"Default\".equalsIgnoreCase(section.getTitle())) {\n\t\t\t\t\tpartIntros.append(\"<\/h2>\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpartIntros.append(\": \");\n\t\t\t\t\tpartIntros.append(section.getTitle());\n\t\t\t\t\tpartIntros.append(\"<\/h2>\");\n\t\t\t\t}\n\t\t\t\tpartIntros.append(\"<br />\");\n\t\t\t\tif (section.getDescription() != null) {\n\t\t\t\t\tpartIntros.append(section.getDescription());\n\t\t\t\t}\n\t\t\t\tpartIntros.append(\"<br />\");\n\n\t\t\t\t\n\t\t\t\tif (section.getAttachmentList() != null && section.getAttachmentList().size() > 0) {\n\t\t\t\t\tpartIntros.append(\"<br />\");\n\t\t\t\t\tpartIntros.append(printMessages.getString(\"attachments\"));\n\n\t\t\t\t\tList partAttachmentList = section.getAttachmentList();\n\t\t\t\t\tIterator partAttachmentIter = partAttachmentList.iterator();\n\t\t\t\t\twhile (partAttachmentIter.hasNext()) {\n\t\t\t\t\t\tpartIntros.append(\"<br />\");\n\t\t\t\t\t\tPublishedSectionAttachment partAttachment = (PublishedSectionAttachment) partAttachmentIter.next();\n\t\t\t\t\t\tif (partAttachment.getMimeType().equalsIgnoreCase(\"image/jpeg\") || \n\t\t\t\t\t\t\t\tpartAttachment.getMimeType().equalsIgnoreCase(\"image/pjpeg\") || \n\t\t\t\t\t\t\t\tpartAttachment.getMimeType().equalsIgnoreCase(\"image/gif\") || \n\t\t\t\t\t\t\t\tpartAttachment.getMimeType().equalsIgnoreCase(\"image/png\")) {\n\t\t\t\t\t\t\tpartIntros.append(\"  <img src=\\\"/samigo\");\n\t\t\t\t\t\t\tpartIntros.append(partAttachment.getResourceId());\n\t\t\t\t\t\t\tpartIntros.append(\"\\\" />\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpartIntros.append(\"  \");\n\t\t\t\t\t\t\tpartIntros.append(partAttachment.getFilename());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpdfPart.setIntro(partIntros.toString());\n\n\t\t\tArrayList pdfItems = new ArrayList();\n\n\t\t\t//for each item in a section we add a blank pdfItem to the pdfPart\n\t\t\tfor (int j = 0; j < items.size(); j++) {\n\t\t\t\tPDFItemBean pdfItem = new PDFItemBean();\n\n\t\t\t\tItemContentsBean item = (ItemContentsBean) items.get(j);\n\t\t\t\t\n\t\t\t\tStringBuffer legacy = new StringBuffer(\"<h3>\");\n\t\t\t\tif (printSetting.getShowSequence().booleanValue()) {\n\t\t\t\t\tlegacy.append(item.getSequence());\n\t\t\t\t}\n\t\t\t\tlegacy.append(\"<\/h3>\");\n\n\t\t\t\tpdfItem.setItemId(item.getItemData().getItemId());\n\n\t\t\t\tStringBuffer contentBuffer = new StringBuffer(); \n\n\t\t\t\tif (!(item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) || item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC))) {\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(convertFormattedText(item.getItemData().getText()));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\t\t\t\tif (item.getItemData().getItemAttachmentList() != null && item.getItemData().getItemAttachmentList().size() > 0) {\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"attachments\"));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tList itemAttachmentList = item.getItemData().getItemAttachmentList();\n\t\t\t\t\tIterator itemAttachmentIter = itemAttachmentList.iterator();\n\t\t\t\t\twhile (itemAttachmentIter.hasNext()) {\n\t\t\t\t\t\tPublishedItemAttachment itemAttachment = (PublishedItemAttachment) itemAttachmentIter.next();\n\t\t\t\t\t\tif (itemAttachment.getMimeType().equalsIgnoreCase(\"image/jpeg\") || \n\t\t\t\t\t\t\titemAttachment.getMimeType().equalsIgnoreCase(\"image/pjpeg\") || \n\t\t\t\t\t\t\titemAttachment.getMimeType().equalsIgnoreCase(\"image/gif\") || \n\t\t\t\t\t\t\titemAttachment.getMimeType().equalsIgnoreCase(\"image/png\")) {\n\t\t\t\t\t\t\tcontentBuffer.append(\"  <img src=\\\"/samigo\");\n\t\t\t\t\t\t\tcontentBuffer.append(itemAttachment.getResourceId());\n\t\t\t\t\t\t\tcontentBuffer.append(\"\\\" />\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcontentBuffer.append(\"  \");\n\t\t\t\t\t\t\tcontentBuffer.append(itemAttachment.getFilename());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) || item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC)) {\n\t\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC)) {\n\t\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\t\tcontentBuffer.append(deliveryMessages.getString(\"fin_accepted_instruction\"));\n\t\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\t}\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(convertFormattedText(item.getItemData().getText()));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.AUDIO_RECORDING)) {\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"time_allowed_seconds\"));\n\t\t\t\t\tcontentBuffer.append(\":\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getDuration());\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"number_of_tries\"));\n\t\t\t\t\tcontentBuffer.append(\":\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getTriesAllowed());\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILE_UPLOAD)) {\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"upload_instruction\"));\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"file\"));\n\t\t\t\t\tcontentBuffer.append(\":\");\n\t\t\t\t\tcontentBuffer.append(\"<input type='text' size='50' />\");\n\t\t\t\t\tcontentBuffer.append(\"<input type='button' value='\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"browse\"));\n\t\t\t\t\tcontentBuffer.append(\":' />\");\n\t\t\t\t\tcontentBuffer.append(\"<input type='button' value='\");\n\t\t\t\t\tcontentBuffer.append(printMessages.getString(\"upload\"));\n\t\t\t\t\tcontentBuffer.append(\":' />\");\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT_SINGLE_SELECTION) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.TRUE_FALSE) ||\n\t\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MATRIX_CHOICES_SURVEY)) {\n\n\t\t\t\t\tList question = item.getItemData().getItemTextArraySorted();\n\t\t\t\t\tfor (int k=0; k<question.size(); k++) {\n\t\t\t\t\t\tPublishedItemText itemtext = (PublishedItemText)question.get(k);\n\t\t\t\t\t\tArrayList answers = itemtext.getAnswerArraySorted();\n\n\t\t\t\t\t\tcontentBuffer.append(\"<table cols='20' width='100%'>\");\n\t\t\t\t\t\tfor (int t=0; t<answers.size(); t++) {\n\t\t\t\t\t\t\tPublishedAnswer answer = (PublishedAnswer)answers.get(t);\n\t\t\t\t\t\t\tif (StringUtils.isBlank(answer.getText())) break;\n\t\t\t\t\t\t\tcontentBuffer.append(\"<tr>\");\n\t\t\t\t\t\t\tcontentBuffer.append(getContentAnswer(item, answer, printSetting));\n\t\t\t\t\t\t\tcontentBuffer.append(\"<\/tr>\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontentBuffer.append(\"<\/table>\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MATCHING)) {\n\t\t\t\t\tcontentBuffer.append(\"<table cols='20' width='100%'>\");\n\t\t\t\t\tList question = item.getMatchingArray();\n\t\t\t\t\tfor (int k=0; k<question.size(); k++) {\n\t\t\t\t\t\tMatchingBean matching = (MatchingBean)question.get(k);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if there are distractors or shared matches, answers will\n\t\t\t\t\t\t// have fewer answers that matches.\n\t\t\t\t\t\tString answer = \"\";\n\t\t\t\t\t\tif (k < item.getAnswers().size()) {\n\t\t\t\t\t\t\tanswer = (String)item.getAnswers().get(k);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (matching.getText() == null) break;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='10'>\");\n\t\t\t\t\t\tcontentBuffer.append(convertFormattedText(matching.getText()));\n\t\t\t\t\t\tcontentBuffer.append(\"<\/td>\");\n\t\t\t\t\t\tcontentBuffer.append(\"<td colspan='10'>\");\n\t\t\t\t\t\tcontentBuffer.append(convertFormattedText(answer));\n\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcontentBuffer.append(\"<\/table>\");\n\t\t\t\t}\n\n\t\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.EXTENDED_MATCHING_ITEMS)) {\n\t\t\t\t\tcontentBuffer.append(\"<table cols='20' width='100%'>\");\n\n\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getThemeText());\n\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\n\t\t\t\t\tif (item.getItemData().getIsAnswerOptionsSimple()) {\n\t\t\t\t\t\tList<AnswerIfc> emiAnswerOptions = item.getItemData().getEmiAnswerOptions();\n\t\t\t\t\t\tfor (AnswerIfc answerIfc : emiAnswerOptions) {\n\t\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\t\t\tcontentBuffer.append(answerIfc.getLabel() + \". \" + answerIfc.getText());\n\t\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.getItemData().getIsAnswerOptionsRich()) {\n\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\t\tcontentBuffer.append(item.getItemData().getEmiAnswerOptionsRichText());\n\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t}\n\n\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\tcontentBuffer.append(item.getItemData().getLeadInText());\n\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\n\t\t\t\t\tList<ItemTextIfc> questionAnswerCombinations = item.getItemData().getEmiQuestionAnswerCombinations();\n\n\t\t\t\t\tfor (ItemTextIfc itemTextIfc : questionAnswerCombinations) {\n\t\t\t\t\t\tif (!itemTextIfc.getText().isEmpty()) {\n\t\t\t\t\t\t\tcontentBuffer.append(\"<tr><td colspan='20'>\");\n\t\t\t\t\t\t\tcontentBuffer.append(itemTextIfc.getSequence() + \". \" + itemTextIfc.getText() + \"  ____\");\n\t\t\t\t\t\t\tcontentBuffer.append(\"<\/td><\/tr>\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(\"<\/table>\");\n\t\t\t\t}\n\t\t\t\tif (printSetting.getShowKeys().booleanValue() || printSetting.getShowKeysFeedback().booleanValue()) {\n\t\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\t\tcontentBuffer.append(getContentQuestion(item, printSetting));\n\t\t\t\t}\n\n\t\t\t\tpdfItem.setContent(contentBuffer.toString());\n\n\t\t\t\tif (legacy != null) {\n\t\t\t\t\tpdfItem.setMeta(legacy.toString()); \n\t\t\t\t}\n\n\t\t\t\tpdfItems.add(pdfItem);\n\t\t\t}\n\n\t\t\tpdfPart.setQuestions(pdfItems);\n\t\t\tpdfPart.setResources(resources);\n\t\t\tif (resources.size() > 0)\n\t\t\t\tpdfPart.setHasResources(Boolean.valueOf(true));\n\t\t\tpdfParts.add(pdfPart);\n\n\t\t}\n\n\t\t//set the new colleciton of PDF beans to be the contents of the pdfassessment\n\t\tsetParts(pdfParts);\n\n\t\tsetTitle(deliveryBean.getAssessmentTitle());\n\n\t\treturn \"print\";\n\t}","commit_id":"12424a2614ec0d0d96d409569fe1f51b97c464f7","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private String getContentQuestion(ItemContentsBean item, PrintSettingsBean printSetting) {\n\t\tStringBuffer contentBuffer = new StringBuffer(\"<h6>\");\n\t\t\n\t\tcontentBuffer.append(printMessages.getString(\"answer_point\"));\n\t\tcontentBuffer.append(\": \");\n\t\tcontentBuffer.append(item.getItemData().getScore());\n\t\tcontentBuffer.append(\" \");\n\t\tcontentBuffer.append(authorMessages.getString(\"points_lower_case\"));\n\n\t\tif (!item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY) &&\n\t\t\t\t!item.getItemData().getTypeId().equals(TypeIfc.AUDIO_RECORDING) &&\n\t\t\t\t!item.getItemData().getTypeId().equals(TypeIfc.FILE_UPLOAD)) {\n\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.ESSAY_QUESTION)) {\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"answer_model\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"answer_key\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t}\n\t\t\t\t\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC) || \n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MATCHING))\n\t\t\t\tcontentBuffer.append(item.getKey());\n\t\t\telse if (item.getItemData().getTypeId().equals(TypeIfc.ESSAY_QUESTION)) {\n\t\t\t\tif (item.getKey() != null && !item.getKey().equals(\"\") && !item.getKey().equals(\"null\"))\n\t\t\t\t\tcontentBuffer.append(item.getKey());\n\t\t\t\telse\n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontentBuffer.append(item.getItemData().getAnswerKey());\n\t\t}\n\n\t\tif (printSetting.getShowKeysFeedback().booleanValue()) {\n\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.ESSAY_QUESTION) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.AUDIO_RECORDING) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILE_UPLOAD)) {\n\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\tcontentBuffer.append(commonMessages.getString(\"feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (item.getItemData().getGeneralItemFeedback() != null && !item.getItemData().getGeneralItemFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(item.getItemData().getGeneralItemFeedback())));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t}\n\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT_SINGLE_SELECTION) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.TRUE_FALSE) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MATCHING)) {\n\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"correct_feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (item.getItemData().getCorrectItemFeedback() != null && !item.getItemData().getCorrectItemFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(item.getItemData().getCorrectItemFeedback())));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"incorrect_feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (item.getItemData().getInCorrectItemFeedback() != null && !item.getItemData().getInCorrectItemFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(FormattedText.convertPlaintextToFormattedText(FormattedText.convertFormattedTextToPlaintext(item.getItemData().getInCorrectItemFeedback())));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t}\n\n\t\t}\n\t\tcontentBuffer.append(\"<\/h6>\");\n\t\treturn contentBuffer.toString();\n\t}","id":203,"modified_method":"private String getContentQuestion(ItemContentsBean item, PrintSettingsBean printSetting) {\n\t\tStringBuffer contentBuffer = new StringBuffer(\"<h6>\");\n\t\t\n\t\tcontentBuffer.append(printMessages.getString(\"answer_point\"));\n\t\tcontentBuffer.append(\": \");\n\t\tcontentBuffer.append(item.getItemData().getScore());\n\t\tcontentBuffer.append(\" \");\n\t\tcontentBuffer.append(authorMessages.getString(\"points_lower_case\"));\n\n\t\tif (!item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE_SURVEY) &&\n\t\t\t\t!item.getItemData().getTypeId().equals(TypeIfc.AUDIO_RECORDING) &&\n\t\t\t\t!item.getItemData().getTypeId().equals(TypeIfc.FILE_UPLOAD)) {\n\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.ESSAY_QUESTION)) {\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"answer_model\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"answer_key\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t}\n\t\t\t\t\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC) || \n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MATCHING))\n\t\t\t\tcontentBuffer.append(item.getKey());\n\t\t\telse if (item.getItemData().getTypeId().equals(TypeIfc.ESSAY_QUESTION)) {\n\t\t\t\tif (item.getKey() != null && !item.getKey().equals(\"\") && !item.getKey().equals(\"null\"))\n\t\t\t\t\tcontentBuffer.append(item.getKey());\n\t\t\t\telse\n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontentBuffer.append(item.getItemData().getAnswerKey());\n\t\t}\n\n\t\tif (printSetting.getShowKeysFeedback().booleanValue()) {\n\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.ESSAY_QUESTION) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.AUDIO_RECORDING) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILE_UPLOAD)) {\n\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\tcontentBuffer.append(commonMessages.getString(\"feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (item.getItemData().getGeneralItemFeedback() != null && !item.getItemData().getGeneralItemFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(convertFormattedText(item.getItemData().getGeneralItemFeedback()));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t}\n\n\t\t\tif (item.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CHOICE) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MULTIPLE_CORRECT_SINGLE_SELECTION) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.TRUE_FALSE) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILL_IN_BLANK) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.FILL_IN_NUMERIC) ||\n\t\t\t\t\titem.getItemData().getTypeId().equals(TypeIfc.MATCHING)) {\n\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"correct_feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (item.getItemData().getCorrectItemFeedback() != null && !item.getItemData().getCorrectItemFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(convertFormattedText(item.getItemData().getCorrectItemFeedback()));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t\tcontentBuffer.append(\"<br />\");\n\t\t\t\tcontentBuffer.append(printMessages.getString(\"incorrect_feedback\"));\n\t\t\t\tcontentBuffer.append(\": \");\n\t\t\t\tif (item.getItemData().getInCorrectItemFeedback() != null && !item.getItemData().getInCorrectItemFeedback().equals(\"\"))\n\t\t\t\t\tcontentBuffer.append(convertFormattedText(item.getItemData().getInCorrectItemFeedback()));\n\t\t\t\telse \n\t\t\t\t\tcontentBuffer.append(\"--------\");\n\t\t\t}\n\n\t\t}\n\t\tcontentBuffer.append(\"<\/h6>\");\n\t\treturn contentBuffer.toString();\n\t}","commit_id":"12424a2614ec0d0d96d409569fe1f51b97c464f7","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void eval(SlingScript script, Map<String, Object> props)\n        throws SlingException, IOException {\n        \n        // This engine does not really run the script, we simply dump it\n        // to the client inside a skeleton HTML document, and let the\n        // client run the script\n        final PrintWriter w = (PrintWriter)(props.get(SlingScriptEngine.OUT));\n        final EspReader er = new EspReader(script.getScriptReader());\n        er.setOutInitStatement(\"out=document;\\n\");\n        \n        try {\n            // access our data (need a Node)\n            final Resource r = (Resource)props.get(SlingScriptEngine.RESOURCE);\n            final Node n = r.adaptTo(Node.class);\n            if(n == null) {\n                throw new HttpStatusCodeException(\n                        HttpServletResponse.SC_NOT_FOUND,\"Resource does not provide a Node, cannot render\");\n            }\n            \n            // output HEAD with javascript initializations\n            w.println(\"<html><head><title id=\\\"EctPageTitle\\\">\");\n            w.println(\"ECT rendering of \" + n.getPath());\n            w.println(\"<\/title>\");\n            \n            // library scripts\n            final SlingHttpServletRequest request = (SlingHttpServletRequest)props.get(SlingScriptEngine.REQUEST);\n            for(String lib : libraryScripts) {\n                final String fullScriptPath =             \n                    SlingRequestPaths.getContextPath(request)\n                    + SlingRequestPaths.getServletPath(request)\n                    + lib\n                ;\n                w.println(\"<script src=\\\"\" + fullScriptPath + \"\\\"><\/script>\");  \n            }\n            \n            // onLoad method\n            w.println(\"<script language=\\\"javascript\\\">\");\n            w.println(\"function ectOnLoad() { if(typeof onLoad == \\\"function\\\") { onLoad(); } }\");\n            w.println(\"<\/script>\");\n            \n            // node data in JSON format\n            final JsonItemWriter j = new JsonItemWriter(null);\n            final int maxRecursionLevels = 1;\n            w.println(\"<script language='javascript'>\");\n            w.print(\"var currentNode=\");\n            j.dump(n, w, maxRecursionLevels);\n            w.println(\";\");\n            w.println(\"<\/script>\");\n            w.println(\"<\/head><body onLoad=\\\"ectOnLoad()\\\">\");\n            \n            // output our parsed script, first in body\n            w.println(\"<div id=\\\"EctRenderingScript\\\">\\n<script language='javascript'>\");\n            copier.copy(er,w);\n            w.println(\"<\/script>\\n<\/div>\");\n            \n            // default rendering, turned off automatically from the javascript that \n            // follows, if javascript is enabled\n            w.println(\"<div id=\\\"EctDefaultRendering\\\">\");\n            htmlRenderer.render(w, r, n);\n            w.println(\"<\/div>\");\n            w.println(\"<script language=\\\"javascript\\\">\");\n            w.println(\"document.getElementById(\\\"EctDefaultRendering\\\").setAttribute(\\\"style\\\",\\\"display:none\\\");\");\n            w.println(\"<\/script>\");\n            \n            // all done\n            w.println(\"<\/body><\/html>\");\n            \n        } catch(RepositoryException re) {\n            throw new SlingException(\"RepositoryException in EctScriptEngine.eval()\",re);\n            \n        } catch(JSONException je) {\n            throw new SlingException(\"JSONException in EctScriptEngine.eval()\",je);\n            \n        }\n    }","id":204,"modified_method":"public void eval(SlingScript script, Map<String, Object> props)\n        throws SlingException, IOException {\n        \n        // This engine does not really run the script, we simply dump it\n        // to the client inside a skeleton HTML document, and let the\n        // client run the script\n        final PrintWriter w = (PrintWriter)(props.get(SlingScriptEngine.OUT));\n        final EspReader er = new EspReader(script.getScriptReader());\n        er.setOutInitStatement(\"out=document;\\n\");\n        \n        try {\n            // access our data (need a Node)\n            final Resource r = (Resource)props.get(SlingScriptEngine.RESOURCE);\n            \n            // to render we must have either a Node or a SyntheticResourceData\n            final Node n = r.adaptTo(Node.class);\n            final SyntheticResourceData srd = r.adaptTo(SyntheticResourceData.class);\n            if(srd==null && n == null) {\n                throw new HttpStatusCodeException(\n                        HttpServletResponse.SC_NOT_FOUND,\n                        \"Resource does not provide a Node or a SyntheticResourceData, cannot render\");\n            }\n            \n            // output HEAD with javascript initializations\n            w.println(\"<html><head><title id=\\\"EctPageTitle\\\">\");\n            w.println(\"ECT rendering of \" + r.getURI());\n            w.println(\"<\/title>\");\n            \n            // library scripts\n            final SlingHttpServletRequest request = (SlingHttpServletRequest)props.get(SlingScriptEngine.REQUEST);\n            for(String lib : libraryScripts) {\n                final String fullScriptPath =             \n                    SlingRequestPaths.getContextPath(request)\n                    + SlingRequestPaths.getServletPath(request)\n                    + lib\n                ;\n                w.println(\"<script src=\\\"\" + fullScriptPath + \"\\\"><\/script>\");  \n            }\n            \n            // onLoad method\n            w.println(\"<script language=\\\"javascript\\\">\");\n            w.println(\"function ectOnLoad() { if(typeof onLoad == \\\"function\\\") { onLoad(); } }\");\n            w.println(\"<\/script>\");\n            \n            // data in JSON format\n            final JsonItemWriter j = new JsonItemWriter(null);\n            final int maxRecursionLevels = 1;\n            w.println(\"<script language='javascript'>\");\n            w.print(\"var currentNode=\");\n            if(n!=null) {\n                j.dump(n, w, maxRecursionLevels);\n            } else {\n                w.print(\"{}\");\n            }\n            w.println(\";\");\n            w.println(\"<\/script>\");\n            w.println(\"<\/head><body onLoad=\\\"ectOnLoad()\\\">\");\n            \n            // output our parsed script, first in body\n            w.println(\"<div id=\\\"EctRenderingScript\\\">\\n<script language='javascript'>\");\n            copier.copy(er,w);\n            w.println(\"<\/script>\\n<\/div>\");\n            \n            // default rendering, turned off automatically from the javascript that \n            // follows, if javascript is enabled\n            w.println(\"<div id=\\\"EctDefaultRendering\\\">\");\n            if(n!=null) {\n                htmlRenderer.render(w, r, n);\n            } else {\n                htmlRenderer.render(w, r, srd);\n            }\n            w.println(\"<\/div>\");\n            w.println(\"<script language=\\\"javascript\\\">\");\n            w.println(\"document.getElementById(\\\"EctDefaultRendering\\\").setAttribute(\\\"style\\\",\\\"display:none\\\");\");\n            w.println(\"<\/script>\");\n            \n            // all done\n            w.println(\"<\/body><\/html>\");\n            \n        } catch(RepositoryException re) {\n            throw new SlingException(\"RepositoryException in EctScriptEngine.eval()\",re);\n            \n        } catch(JSONException je) {\n            throw new SlingException(\"JSONException in EctScriptEngine.eval()\",je);\n            \n        }\n    }","commit_id":"bfedb8aa2aab1b1b99c6567a3fca2f78d86857c1","url":"https://github.com/apache/sling"},{"original_method":"/**\r\n\t * Draws all the images defined for the specified cache ID.\r\n\t */\r\n\tpublic void draw (int cacheID) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteCache.begin must be called before draw.\");\r\n\r\n\t\tCache cache = caches.get(cacheID);\r\n\t\tint offset = cache.offset;\r\n\t\tTexture[] textures = cache.textures;\r\n\t\tint[] counts = cache.counts;\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tmesh.render(shader, GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tmesh.render(GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":205,"modified_method":"/**\r\n\t * Draws all the images defined for the specified cache ID.\r\n\t */\r\n\tpublic void draw (int cacheID) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteCache.begin must be called before draw.\");\r\n\r\n\t\tCache cache = caches.get(cacheID);\r\n\t\tint offset = cache.offset;\r\n\t\tTexture[] textures = cache.textures;\r\n\t\tint[] counts = cache.counts;\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tif(customShader != null) mesh.render(customShader, GL10.GL_TRIANGLES, offset, count); \r\n\t\t\t\telse mesh.render(shader, GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tmesh.render(GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"22f45469fc463e2e70a39032088531cc8d01bff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * Draws a subset of images defined for the specified cache ID.\r\n\t * @param offset The first image to render.\r\n\t * @param length The number of images from the first image (inclusive) to render.\r\n\t */\r\n\tpublic void draw (int cacheID, int offset, int length) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteCache.begin must be called before draw.\");\r\n\r\n\t\tCache cache = caches.get(cacheID);\r\n\t\toffset = offset * 6 + cache.offset;\r\n\t\tlength *= 6;\r\n\t\tTexture[] textures = cache.textures;\r\n\t\tint[] counts = cache.counts;\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\tif (count > length) {\r\n\t\t\t\t\ti = n;\r\n\t\t\t\t\tcount = length;\r\n\t\t\t\t} else\r\n\t\t\t\t\tlength -= count;\r\n\t\t\t\tmesh.render(shader, GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\tif (count > length) {\r\n\t\t\t\t\ti = n;\r\n\t\t\t\t\tcount = length;\r\n\t\t\t\t} else\r\n\t\t\t\t\tlength -= count;\r\n\t\t\t\tmesh.render(GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":206,"modified_method":"/**\r\n\t * Draws a subset of images defined for the specified cache ID.\r\n\t * @param offset The first image to render.\r\n\t * @param length The number of images from the first image (inclusive) to render.\r\n\t */\r\n\tpublic void draw (int cacheID, int offset, int length) {\r\n\t\tif (!drawing) throw new IllegalStateException(\"SpriteCache.begin must be called before draw.\");\r\n\r\n\t\tCache cache = caches.get(cacheID);\r\n\t\toffset = offset * 6 + cache.offset;\r\n\t\tlength *= 6;\r\n\t\tTexture[] textures = cache.textures;\r\n\t\tint[] counts = cache.counts;\r\n\t\tif (Gdx.graphics.isGL20Available()) {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\tif (count > length) {\r\n\t\t\t\t\ti = n;\r\n\t\t\t\t\tcount = length;\r\n\t\t\t\t} else\r\n\t\t\t\t\tlength -= count;\r\n\t\t\t\tif(customShader != null) mesh.render(customShader, GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\telse mesh.render(shader, GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (int i = 0, n = textures.length; i < n; i++) {\r\n\t\t\t\ttextures[i].bind();\r\n\t\t\t\tint count = counts[i];\r\n\t\t\t\tif (count > length) {\r\n\t\t\t\t\ti = n;\r\n\t\t\t\t\tcount = length;\r\n\t\t\t\t} else\r\n\t\t\t\t\tlength -= count;\r\n\t\t\t\tmesh.render(GL10.GL_TRIANGLES, offset, count);\r\n\t\t\t\toffset += count;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"22f45469fc463e2e70a39032088531cc8d01bff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void run() {\n\t\tfreenet.support.Logger.OSThread.logPID(this);\n\t\ttry {\n\t\t\trealRun();\n\t\t//The last thing that realRun() does is register as a request-sender listener, so any exception here is the end.\n\t\t} catch(NotConnectedException e) {\n\t\t\tLogger.normal(this, \"requestor gone, could not start request handler wait\");\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(e);\n\t\t\tboolean dontUnlock;\n\t\t\tsynchronized(this) {\n\t\t\t\tdontUnlock = this.dontUnlock;\n\t\t\t}\n\t\t\tif(!dontUnlock)\n\t\t\t\ttag.unlockHandler();\n\t\t} catch(Throwable t) {\n\t\t\tLogger.error(this, \"Caught \" + t, t);\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(t);\n\t\t\tboolean dontUnlock;\n\t\t\tsynchronized(this) {\n\t\t\t\tdontUnlock = this.dontUnlock;\n\t\t\t}\n\t\t\tif(!dontUnlock)\n\t\t\t\ttag.unlockHandler();\n\t\t}\n\t}","id":207,"modified_method":"public void run() {\n\t\tfreenet.support.Logger.OSThread.logPID(this);\n\t\ttry {\n\t\t\trealRun();\n\t\t//The last thing that realRun() does is register as a request-sender listener, so any exception here is the end.\n\t\t} catch(NotConnectedException e) {\n\t\t\tLogger.normal(this, \"requestor gone, could not start request handler wait\");\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(e);\n\t\t\ttag.unlockHandler();\n\t\t} catch(Throwable t) {\n\t\t\tLogger.error(this, \"Caught \" + t, t);\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(t);\n\t\t\ttag.unlockHandler();\n\t\t}\n\t}","commit_id":"ee7ea162a49eba7a706c9390ddcffeb7e06c55ab","url":"https://github.com/freenet/fred"},{"original_method":"public void run() {\n\t\tfreenet.support.Logger.OSThread.logPID(this);\n\t\ttry {\n\t\t\trealRun();\n\t\t//The last thing that realRun() does is register as a request-sender listener, so any exception here is the end.\n\t\t} catch(NotConnectedException e) {\n\t\t\tLogger.normal(this, \"requestor gone, could not start request handler wait\");\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(e);\n\t\t\tboolean dontUnlock;\n\t\t\tsynchronized(this) {\n\t\t\t\tdontUnlock = this.dontUnlock;\n\t\t\t}\n\t\t\tif(!dontUnlock)\n\t\t\t\ttag.unlockHandler();\n\t\t} catch(Throwable t) {\n\t\t\tLogger.error(this, \"Caught \" + t, t);\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(t);\n\t\t\tboolean dontUnlock;\n\t\t\tsynchronized(this) {\n\t\t\t\tdontUnlock = this.dontUnlock;\n\t\t\t}\n\t\t\tif(!dontUnlock)\n\t\t\t\ttag.unlockHandler();\n\t\t}\n\t}","id":208,"modified_method":"public void run() {\n\t\tfreenet.support.Logger.OSThread.logPID(this);\n\t\ttry {\n\t\t\trealRun();\n\t\t//The last thing that realRun() does is register as a request-sender listener, so any exception here is the end.\n\t\t} catch(NotConnectedException e) {\n\t\t\tLogger.normal(this, \"requestor gone, could not start request handler wait\");\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(e);\n\t\t\ttag.unlockHandler();\n\t\t} catch(Throwable t) {\n\t\t\tLogger.error(this, \"Caught \" + t, t);\n\t\t\tnode.removeTransferringRequestHandler(uid);\n\t\t\ttag.handlerThrew(t);\n\t\t\ttag.unlockHandler();\n\t\t}\n\t}","commit_id":"76b403aa188eecfef8914af1b254aa70da57e191","url":"https://github.com/freenet/fred"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n                .betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n\n                .aroundInside(ELSE_KEYWORD, IF).spaces(1)\n                .betweenInside(RPAR, THEN, IF).spaces(1)\n\n                .between(RPAR, BODY).spaces(1)\n                ;\n    }","id":209,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n                .betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)\n                .betweenInside(WHILE_KEYWORD, LPAR, WHILE).spacing(1, 1, 0, false, 0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n\n                .aroundInside(ELSE_KEYWORD, IF).spaces(1)\n                .betweenInside(RPAR, THEN, IF).spaces(1)\n\n                .between(RPAR, BODY).spaces(1)\n                ;\n    }","commit_id":"dddde11c6a66369c692edab522a683ba0a98b26d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n                .betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)\n                .betweenInside(WHILE_KEYWORD, LPAR, WHILE).spacing(1, 1, 0, false, 0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n\n                .aroundInside(ELSE_KEYWORD, IF).spaces(1)\n                .betweenInside(RPAR, THEN, IF).spaces(1)\n\n                .between(RPAR, BODY).spaces(1)\n                ;\n    }","id":210,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(\n                        jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n                .betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)\n                .betweenInside(WHILE_KEYWORD, LPAR, WHILE).spacing(1, 1, 0, false, 0)\n                .betweenInside(WHILE_KEYWORD, LPAR, DO_WHILE).spacing(1, 1, 0, false, 0)\n\n                .aroundInside(WHILE_KEYWORD, DO_WHILE).spaces(1)\n                .afterInside(DO_KEYWORD, DO_WHILE).spaces(1)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n\n                .aroundInside(ELSE_KEYWORD, IF).spaces(1)\n                .betweenInside(RPAR, THEN, IF).spaces(1)\n\n                .between(RPAR, BODY).spaces(1)\n                ;\n    }","commit_id":"80ab043d211acecf2dcf0f3777d41fb3065ae6f4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n                ;\n    }","id":211,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings, JetLanguage.INSTANCE)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_LIST).blankLines(1)\n\n                .before(DOC_COMMENT).lineBreakInCode()\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .aroundInside(TokenSet.create(PLUS, MINUS), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                .afterInside(LPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_PARAMETER_LIST).spaces(0)\n                .afterInside(LT, TYPE_PARAMETER_LIST).spaces(0)\n                .beforeInside(GT, TYPE_PARAMETER_LIST).spaces(0)\n                .afterInside(LPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(RPAR, VALUE_ARGUMENT_LIST).spaces(0)\n                .afterInside(LT, TYPE_ARGUMENT_LIST).spaces(0)\n                .beforeInside(GT, TYPE_ARGUMENT_LIST).spaces(0)\n\n                .betweenInside(FOR_KEYWORD, LPAR, FOR).spacing(1, 1, 0, false, 0)\n                .betweenInside(IF_KEYWORD, LPAR, IF).spacing(1, 1, 0, false, 0)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n\n                .between(VALUE_ARGUMENT_LIST, FUNCTION_LITERAL_EXPRESSION).spaces(1)\n                .beforeInside(ARROW, FUNCTION_LITERAL).spaceIf(jetSettings.SPACE_BEFORE_LAMBDA_ARROW)\n\n                //when\n                .aroundInside(ARROW, WHEN_ENTRY).spaceIf(jetSettings.SPACE_AROUND_WHEN_ARROW)\n                .beforeInside(LBRACE, WHEN).spacing(1, 1, 0, true, 0)          //omit blank lines before '{' in 'when' statement\n\n                .aroundInside(ARROW, FUNCTION_TYPE).spaceIf(jetSettings.SPACE_AROUND_FUNCTION_TYPE_ARROW)\n\n                .betweenInside(REFERENCE_EXPRESSION, FUNCTION_LITERAL_EXPRESSION, CALL_EXPRESSION).spaces(1)\n                ;\n    }","commit_id":"3e205d162ed94957a84bca4d590f5c6eccf631f3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type)Matchers.any(), Matchers.anyLong(), Matchers.anyLong(), Matchers.anyLong())).thenReturn(hosts);\n\n        remoteEp = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host.getId(), this.host.getPrivateIpAddress(), this.host.getPublicIpAddress());\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class), Matchers.any(DataObject.class))).thenReturn(remoteEp);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class))).thenReturn(remoteEp);\n        Mockito.when(epSelector.select(Matchers.any(DataStore.class))).thenReturn(remoteEp);\n        Mockito.when(hyGuruMgr.getGuruProcessedCommandTargetHost(Matchers.anyLong(), Matchers.any(Command.class))).thenReturn(this.host.getId());\n\n    }","id":212,"modified_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type)Matchers.any(), Matchers.anyLong(), Matchers.anyLong(), Matchers.anyLong())).thenReturn(hosts);\n        remoteEp = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class), Matchers.any(DataObject.class))).thenReturn(remoteEp);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class))).thenReturn(remoteEp);\n        Mockito.when(epSelector.select(Matchers.any(DataStore.class))).thenReturn(remoteEp);\n        Mockito.when(hyGuruMgr.getGuruProcessedCommandTargetHost(Matchers.anyLong(), Matchers.any(Command.class))).thenReturn(this.host.getId());\n\n    }","commit_id":"c40d03b41728c012012147a5f159d71aadf8b064","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type)Matchers.any(), Matchers.anyLong(), Matchers.anyLong(), Matchers.anyLong())).thenReturn(hosts);\n\n        RemoteHostEndPoint ep = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host.getId(), this.host.getPrivateIpAddress(), this.host.getPublicIpAddress());\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class), Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataStore.class))).thenReturn(ep);\n        Mockito.when(hyGuruMgr.getGuruProcessedCommandTargetHost(Matchers.anyLong(), Matchers.any(Command.class))).thenReturn(this.host.getId());\n    }","id":213,"modified_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type)Matchers.any(), Matchers.anyLong(), Matchers.anyLong(), Matchers.anyLong())).thenReturn(hosts);\n\n        RemoteHostEndPoint ep = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class), Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataStore.class))).thenReturn(ep);\n        Mockito.when(hyGuruMgr.getGuruProcessedCommandTargetHost(Matchers.anyLong(), Matchers.any(Command.class))).thenReturn(this.host.getId());\n    }","commit_id":"c40d03b41728c012012147a5f159d71aadf8b064","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type)Matchers.any(), Matchers.anyLong(), Matchers.anyLong(), Matchers.anyLong())).thenReturn(hosts);\n\n        RemoteHostEndPoint ep = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host.getId(), this.host.getPrivateIpAddress(), this.host.getPublicIpAddress());\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class), Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataStore.class))).thenReturn(ep);\n    }","id":214,"modified_method":"@Override\n    protected void injectMockito() {\n        List<HostVO> hosts = new ArrayList<HostVO>();\n        hosts.add(this.host);\n        Mockito.when(resourceMgr.listAllUpAndEnabledHosts((Type)Matchers.any(), Matchers.anyLong(), Matchers.anyLong(), Matchers.anyLong())).thenReturn(hosts);\n\n        RemoteHostEndPoint ep = RemoteHostEndPoint.getHypervisorHostEndPoint(this.host);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class), Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataObject.class))).thenReturn(ep);\n        Mockito.when(epSelector.select(Matchers.any(DataStore.class))).thenReturn(ep);\n    }","commit_id":"c40d03b41728c012012147a5f159d71aadf8b064","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testAsyncDetector() throws Exception{\n        m_detector.testDetectorConnection(InetAddress.getLocalHost());\n    }","id":215,"modified_method":"@Test\n    public void testAsyncDetector() throws Exception{\n        m_detector.setPort(9123);\n        m_detector.setDetectorHandler(new AsyncPop3Handler());\n        m_detector.init();\n        \n        DetectFuture future = m_detector.isServiceDetected(InetAddress.getLocalHost(), new NullDetectorMonitor());\n        assertNotNull(future);\n        \n        future.await();\n        \n        System.out.printf(\"future is complete, isServiceDetected: %s\\n\", future.isServiceDetected());\n    }","commit_id":"72b6ad2e223de954857e4b33231f9eac4f95d2f0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAsyncDetector() throws Exception{\n        m_detector.testDetectorConnection(InetAddress.getLocalHost());\n    }","id":216,"modified_method":"@Test\n    public void testAsyncDetector() throws Exception{\n        m_detector.setPort(9123);\n        m_detector.setDetectorHandler(new AsyncPop3Handler());\n        m_detector.init();\n        \n        DetectFuture future = m_detector.isServiceDetected(InetAddress.getLocalHost(), new NullDetectorMonitor());\n        assertNotNull(future);\n        \n        future.await();\n        \n        System.out.printf(\"future is complete, isServiceDetected: %s\\n\", future.isServiceDetected());\n    }","commit_id":"35445d942e2b68c20dde753d4a0f0ca33378de71","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testAsyncDetector() throws Exception{\n        m_detector.testDetectorConnection(InetAddress.getLocalHost());\n    }","id":217,"modified_method":"@Test\n    public void testAsyncDetector() throws Exception{\n        m_detector.setPort(9123);\n        m_detector.setDetectorHandler(new AsyncPop3Handler());\n        m_detector.init();\n        \n        DetectFuture future = m_detector.isServiceDetected(InetAddress.getLocalHost(), new NullDetectorMonitor());\n        assertNotNull(future);\n        \n        future.await();\n        \n        System.out.printf(\"future is complete, isServiceDetected: %s\\n\", future.isServiceDetected());\n    }","commit_id":"f0ca00612a86fcaa1ab8280ffb0b6860b3282e71","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void summary() throws IOException {\n        Package pkg = tool.getPackage(klass);\n\n        open(\"div class='nav menu'\");\n        open(\"div\");\n        around(\"a href='\" + getObjectUrl(module) + \"'\", \"Overview\");\n        close(\"div\");\n        open(\"div\");\n        around(\"a href='index.html'\", \"Package\");\n        close(\"div\");\n        open(\"div class='selected'\");\n        write(\"Class\");\n        close(\"div\");\n        open(\"div\");\n        write(pkg.getModule().getNameAsString() + \"/\" + pkg.getModule().getVersion());\n        close(\"div\");\n        open(\"div class='source-code'\");\n        around(\"a href='\" + getSrcUrl(klass) + \"'\", \"Source Code\");\n        close(\"div\");\n        close(\"div\");\n\n        open(\"div class='head summary'\");\n\n        // name\n        around(\"div class='package'\", \"<code>\" + pkg.getNameAsString() + \"<\/code>\");\n\n        around(\"div class='type'\", klass instanceof Class ? \"Class \" : \"Interface \", \"<code>\", getClassName(), \"<\/code>\");\n\n        // hierarchy tree - only for classes\n        if (klass instanceof Class) {\n            LinkedList<ProducedType> superTypes = new LinkedList<ProducedType>();\n            superTypes.add(klass.getType());\n            ProducedType type = klass.getExtendedType();\n            while (type != null) {\n                superTypes.add(0, type);\n                type = type.getDeclaration().getExtendedType();\n            }\n            int i = 0;\n            for (ProducedType superType : superTypes) {\n                open(\"ul class='inheritance'\", \"li\");\n                link(superType);\n                i++;\n            }\n            while (i-- > 0) {\n                close(\"li\", \"ul\");\n            }\n        }\n\n        tag(\"br\");\n        // interfaces\n        writeListOnSummary2(\"satisfied\", \"Satisfied Interfaces: \", superInterfaces);\n\n        // subclasses\n        writeListOnSummary(\"subclasses\", \"Direct Known Subclasses: \", subclasses);\n\n        // satisfying classes\n        writeListOnSummary(\"satisfyingClasses\", \"All Known Satisfying Classes: \", satisfyingClasses);\n\n        // satisfying interfaces\n        writeListOnSummary(\"satisfyingClasses\", \"All Known Satisfying Interfaces: \", satisfyingInterfaces);\n\n        // description\n        around(\"div class='doc'\", getDoc(klass));\n\n        writeSee(klass);\n        \n        close(\"div\");\n    }","id":218,"modified_method":"private void summary() throws IOException {\n        Package pkg = tool.getPackage(klass);\n\n        open(\"div class='nav menu'\");\n        open(\"div\");\n        around(\"a href='\" + getObjectUrl(module) + \"'\", \"Overview\");\n        close(\"div\");\n        open(\"div\");\n        around(\"a href='index.html'\", \"Package\");\n        close(\"div\");\n        open(\"div class='selected'\");\n        write(\"Class\");\n        close(\"div\");\n        open(\"div\");\n        write(pkg.getModule().getNameAsString() + \"/\" + pkg.getModule().getVersion());\n        close(\"div\");\n        if (!tool.isOmitSource()) {\n            open(\"div class='source-code'\");\n            around(\"a href='\" + getSrcUrl(klass) + \"'\", \"Source Code\");\n            close(\"div\");\n        }\n        close(\"div\");\n\n        open(\"div class='head summary'\");\n\n        // name\n        around(\"div class='package'\", \"<code>\" + pkg.getNameAsString() + \"<\/code>\");\n\n        around(\"div class='type'\", klass instanceof Class ? \"Class \" : \"Interface \", \"<code>\", getClassName(), \"<\/code>\");\n\n        // hierarchy tree - only for classes\n        if (klass instanceof Class) {\n            LinkedList<ProducedType> superTypes = new LinkedList<ProducedType>();\n            superTypes.add(klass.getType());\n            ProducedType type = klass.getExtendedType();\n            while (type != null) {\n                superTypes.add(0, type);\n                type = type.getDeclaration().getExtendedType();\n            }\n            int i = 0;\n            for (ProducedType superType : superTypes) {\n                open(\"ul class='inheritance'\", \"li\");\n                link(superType);\n                i++;\n            }\n            while (i-- > 0) {\n                close(\"li\", \"ul\");\n            }\n        }\n\n        tag(\"br\");\n        // interfaces\n        writeListOnSummary2(\"satisfied\", \"Satisfied Interfaces: \", superInterfaces);\n\n        // subclasses\n        writeListOnSummary(\"subclasses\", \"Direct Known Subclasses: \", subclasses);\n\n        // satisfying classes\n        writeListOnSummary(\"satisfyingClasses\", \"All Known Satisfying Classes: \", satisfyingClasses);\n\n        // satisfying interfaces\n        writeListOnSummary(\"satisfyingClasses\", \"All Known Satisfying Interfaces: \", satisfyingInterfaces);\n\n        // description\n        around(\"div class='doc'\", getDoc(klass));\n\n        writeSee(klass);\n        \n        close(\"div\");\n    }","commit_id":"b3edd548c59c90255ac9001adaf0b50c244a8731","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void summary() throws IOException {\n        open(\"div class='nav menu'\");\n        open(\"div\");\n        around(\"a href='\"+getObjectUrl(module)+\"'\", \"Overview\");\n        close(\"div\");\n        open(\"div class='selected'\");\n        write(\"Package\");\n        close(\"div\");\n        open(\"div\");\n        write(\"Class\");\n        close(\"div\");\n        open(\"div\");\n        write(pkg.getModule().getNameAsString() + \"/\" + pkg.getModule().getVersion());\n        close(\"div\");\n        open(\"div class='source-code'\");\n        around(\"a href='\" + getSrcUrl(pkg) + \"'\", \"Source Code\");\n        close(\"div\");\n        close(\"div\");\n\n        open(\"div class='head summary'\");\n        around(\"h1\", \"Package \", \"<code>\", pkg.getNameAsString(), \"<\/code>\");\n        close(\"div\");\n    }","id":219,"modified_method":"private void summary() throws IOException {\n        open(\"div class='nav menu'\");\n        open(\"div\");\n        around(\"a href='\"+getObjectUrl(module)+\"'\", \"Overview\");\n        close(\"div\");\n        open(\"div class='selected'\");\n        write(\"Package\");\n        close(\"div\");\n        open(\"div\");\n        write(\"Class\");\n        close(\"div\");\n        open(\"div\");\n        write(pkg.getModule().getNameAsString() + \"/\" + pkg.getModule().getVersion());\n        close(\"div\");\n        if (!tool.isOmitSource()) {\n            open(\"div class='source-code'\");\n            around(\"a href='\" + getSrcUrl(pkg) + \"'\", \"Source Code\");\n            close(\"div\");\n        }\n        close(\"div\");\n\n        open(\"div class='head summary'\");\n        around(\"h1\", \"Package \", \"<code>\", pkg.getNameAsString(), \"<\/code>\");\n        close(\"div\");\n    }","commit_id":"b3edd548c59c90255ac9001adaf0b50c244a8731","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void overview() throws IOException {\n        open(\"div class='nav'\");\n        open(\"div class='selected'\");\n        write(\"Overview\");\n        close(\"div\");\n        open(\"div\");\n        write(\"Package\");\n        close(\"div\");\n        open(\"div\");\n        write(\"Class\");\n        close(\"div\");\n        open(\"div\");\n        write(module.getNameAsString() + \"/\" + module.getVersion());\n        close(\"div\");\n        open(\"div class='source-code'\");\n        around(\"a href='\" + getSrcUrl(module) + \"'\", \"Source Code\");\n        close(\"div\");\n        close(\"div\");\n    }","id":220,"modified_method":"private void overview() throws IOException {\n        open(\"div class='nav'\");\n        open(\"div class='selected'\");\n        write(\"Overview\");\n        close(\"div\");\n        open(\"div\");\n        write(\"Package\");\n        close(\"div\");\n        open(\"div\");\n        write(\"Class\");\n        close(\"div\");\n        open(\"div\");\n        write(module.getNameAsString() + \"/\" + module.getVersion());\n        close(\"div\");\n        if (!tool.isOmitSource()) {\n            open(\"div class='source-code'\");\n            around(\"a href='\" + getSrcUrl(module) + \"'\", \"Source Code\");\n            close(\"div\");\n        }\n        close(\"div\");\n    }","commit_id":"b3edd548c59c90255ac9001adaf0b50c244a8731","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n\tpublic Collection<JavaFileObject> resolveClasses(\n\t\tBundleWiring bundleWiring, String path, int options) {\n\n\t\tBundle bundle = bundleWiring.getBundle();\n\n\t\tif (bundle.equals(_bundle) || bundle.equals(_jspBundle)) {\n\t\t\treturn toJavaFileObjects(\n\t\t\t\tbundle, bundleWiring.listResources(path, \"*.class\", options));\n\t\t}\n\n\t\tif (!isExportsPackage(bundleWiring, path.replace('/', '.'))) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tif (bundle.getBundleId() == 0) {\n\t\t\treturn handleSystemBundle(bundleWiring, path);\n\t\t}\n\n\t\treturn toJavaFileObjects(\n\t\t\tbundle, bundleWiring.listResources(path, \"*.class\", options));\n\t}","id":221,"modified_method":"@Override\n\tpublic Collection<String> resolveClasses(\n\t\tBundleWiring bundleWiring, String path, int options) {\n\n\t\tCollection<String> resources = null;\n\n\t\tBundle bundle = bundleWiring.getBundle();\n\n\t\tif (bundle.equals(_bundle) || bundle.equals(_jspBundle)) {\n\t\t\tresources = bundleWiring.listResources(path, \"*.class\", options);\n\t\t}\n\t\telse if (isExportsPackage(bundleWiring, path.replace('/', '.'))) {\n\t\t\tif (bundle.getBundleId() == 0) {\n\t\t\t\tresources = handleSystemBundle(bundleWiring, path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresources = bundleWiring.listResources(\n\t\t\t\t\tpath, \"*.class\", options);\n\t\t\t}\n\t\t}\n\n\t\treturn resources;\n\t}","commit_id":"34dae74748eefa45ba9fd2d0797de890d3a71d08","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Collection<String> resolveClasses(\n\t\tBundleWiring bundleWiring, String path, int options) {\n\n\t\tCollection<String> resources = null;\n\n\t\tBundle bundle = bundleWiring.getBundle();\n\n\t\tif (bundle.equals(_bundle) || bundle.equals(_jspBundle)) {\n\t\t\tresources = bundleWiring.listResources(path, \"*.class\", options);\n\t\t}\n\t\telse if (isExportsPackage(bundleWiring, path.replace('/', '.'))) {\n\t\t\tif (bundle.getBundleId() == 0) {\n\t\t\t\tresources = handleSystemBundle(bundleWiring, path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresources = bundleWiring.listResources(\n\t\t\t\t\tpath, \"*.class\", options);\n\t\t\t}\n\t\t}\n\n\t\treturn resources;\n\t}","id":222,"modified_method":"@Override\n\tpublic Collection<JavaFileObject> resolveClasses(\n\t\tBundleWiring bundleWiring, String path, int options) {\n\n\t\tBundle bundle = bundleWiring.getBundle();\n\n\t\tif (bundle.equals(_bundle) || bundle.equals(_jspBundle)) {\n\t\t\treturn toJavaFileObjects(\n\t\t\t\tbundle, bundleWiring.listResources(path, \"*.class\", options));\n\t\t}\n\n\t\tif (!isExportsPackage(bundleWiring, path.replace('/', '.'))) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tif (bundle.getBundleId() == 0) {\n\t\t\treturn handleSystemBundle(bundleWiring, path);\n\t\t}\n\n\t\treturn toJavaFileObjects(\n\t\t\tbundle, bundleWiring.listResources(path, \"*.class\", options));\n\t}","commit_id":"103a4e25bd2e922941bf6006658ddfa120dbddbf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic Collection<String> resolveClasses(\n\t\tBundleWiring bundleWiring, String path, int options) {\n\n\t\tCollection<String> resources = null;\n\n\t\tBundle bundle = bundleWiring.getBundle();\n\n\t\tif (bundle.equals(_bundle) || bundle.equals(_jspBundle)) {\n\t\t\tresources = bundleWiring.listResources(path, \"*.class\", options);\n\t\t}\n\t\telse if (isExportsPackage(bundleWiring, path.replace('/', '.'))) {\n\t\t\tif (bundle.getBundleId() == 0) {\n\t\t\t\tresources = handleSystemBundle(bundleWiring, path);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresources = bundleWiring.listResources(\n\t\t\t\t\tpath, \"*.class\", options);\n\t\t\t}\n\t\t}\n\n\t\treturn resources;\n\t}","id":223,"modified_method":"@Override\n\tpublic Collection<JavaFileObject> resolveClasses(\n\t\tBundleWiring bundleWiring, String path, int options) {\n\n\t\tBundle bundle = bundleWiring.getBundle();\n\n\t\tif (bundle.equals(_bundle) || bundle.equals(_jspBundle)) {\n\t\t\treturn toJavaFileObjects(\n\t\t\t\tbundle, bundleWiring.listResources(path, \"*.class\", options));\n\t\t}\n\n\t\tif (!isExportsPackage(bundleWiring, path.replace('/', '.'))) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tif (bundle.getBundleId() == 0) {\n\t\t\treturn handleSystemBundle(bundleWiring, path);\n\t\t}\n\n\t\treturn toJavaFileObjects(\n\t\t\tbundle, bundleWiring.listResources(path, \"*.class\", options));\n\t}","commit_id":"a4da7d36bc50e2b620124f35d660758d9ad4b586","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void warn(String msg, Throwable thrown)\n    {\n        _logger.log(Level.WARNING, msg, thrown);\n    }","id":224,"modified_method":"public void warn(String msg, Throwable thrown)\n    {\n        if (_logger.isLoggable(Level.WARNING))\n            log(Level.WARNING,msg,thrown);\n    }","commit_id":"dcb4c0d0a8ecb2d198977334b8b6a8c6180359b5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void info(String msg, Throwable thrown)\n    {\n        _logger.log(Level.INFO, msg, thrown);\n    }","id":225,"modified_method":"public void info(String msg, Throwable thrown)\n    {\n        if (_logger.isLoggable(Level.INFO))\n            log(Level.INFO,msg,thrown);\n    }","commit_id":"dcb4c0d0a8ecb2d198977334b8b6a8c6180359b5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void debug(String msg, Throwable thrown)\n    {\n        _logger.log(Level.FINE, msg, thrown);\n    }","id":226,"modified_method":"public void debug(String msg, Throwable thrown)\n    {\n        if (_logger.isLoggable(Level.FINE))\n            log(Level.FINE,msg,thrown);\n    }","commit_id":"dcb4c0d0a8ecb2d198977334b8b6a8c6180359b5","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public List<String> getConnectedPlayers(UUID roomId) throws MageException {\r\n        try {\r\n            return GamesRoomManager.getInstance().getRoom(roomId).getPlayers();\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","id":227,"modified_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public List<String> getConnectedPlayers(UUID roomId) throws MageException {\r\n        try {\r\n            GamesRoom room = GamesRoomManager.getInstance().getRoom(roomId);\r\n            if (room != null) {\r\n                return room.getPlayers();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","commit_id":"faafa3f8be1d06ad7ee2523245c079e12da5d2a2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public List<TableView> getTables(UUID roomId) throws MageException {\r\n        try {\r\n            return GamesRoomManager.getInstance().getRoom(roomId).getTables();\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","id":228,"modified_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public List<TableView> getTables(UUID roomId) throws MageException {\r\n        try {\r\n            GamesRoom room = GamesRoomManager.getInstance().getRoom(roomId);\r\n            if (room != null) {\r\n                return room.getTables();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","commit_id":"faafa3f8be1d06ad7ee2523245c079e12da5d2a2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public TableView getTable(UUID roomId, UUID tableId) throws MageException {\r\n        try {\r\n            return GamesRoomManager.getInstance().getRoom(roomId).getTable(tableId);\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","id":229,"modified_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public TableView getTable(UUID roomId, UUID tableId) throws MageException {\r\n        try {\r\n            GamesRoom room = GamesRoomManager.getInstance().getRoom(roomId);\r\n            if (room != null) {\r\n                return room.getTable(tableId);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","commit_id":"faafa3f8be1d06ad7ee2523245c079e12da5d2a2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public List<MatchView> getFinishedMatches(UUID roomId) throws MageException {\r\n        try {\r\n            return GamesRoomManager.getInstance().getRoom(roomId).getFinished();\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","id":230,"modified_method":"@Override\r\n    //FIXME: why no sessionId here???\r\n    public List<MatchView> getFinishedMatches(UUID roomId) throws MageException {\r\n        try {\r\n            GamesRoom room = GamesRoomManager.getInstance().getRoom(roomId);\r\n            if (room != null) {\r\n                return room.getFinished();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        catch (Exception ex) {\r\n            handleException(ex);\r\n        }\r\n        return null;\r\n    }","commit_id":"faafa3f8be1d06ad7ee2523245c079e12da5d2a2","url":"https://github.com/magefree/mage"},{"original_method":"private void setUpModeSelectionPanel() {\n        \n        modeSelectionPanel = new JPanel();\n        GridBagLayout gridbag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n        modeSelectionPanel.setLayout(gridbag);\n        Insets defaultInsets = new Insets(2,9,2,2);\n        \n        ButtonGroup modeSelectionGroup = new ButtonGroup();\n        JLabel topLabel = new JLabel(\"Select the Export Mode\");\n        \n        //area for displaying information about publishing mode\n        informationArea = new JTextArea(\" The Export function allows a user to deposit a concept map into a registered digital repository. Select the different modes to learn more.\");\n        informationArea.setEditable(false);\n        informationArea.setLineWrap(true);\n        informationArea.setWrapStyleWord(true);\n        informationArea.setRows(4);\n        informationArea.setBorder(new LineBorder(Color.BLACK));\n        //informationArea.setBackground(Color.WHITE);\n        informationArea.setSize(WIDTH-50, HEIGHT/3);\n        \n        JLabel dsLabel = new JLabel(\"Where would you like to save the map:\");\n        dataSourceComboBox = new JComboBox(DataSourceViewer.getPublishableDataSources(Publisher.PUBLISH_ALL_MODES));\n      \n        JPanel buttonPanel = new JPanel();\n        publishMapRButton = new JRadioButton(\"Export Map\");\n        publishCMapRButton = new JRadioButton(\"Export IMSCP Map\");\n        publishAllRButton = new JRadioButton(\"Export All\");\n        publishMapRButton.addActionListener(this);\n        publishCMapRButton.addActionListener(this);\n        publishAllRButton.addActionListener(this);\n        \n        modeSelectionGroup.add(publishMapRButton);\n        modeSelectionGroup.add(publishCMapRButton);\n        modeSelectionGroup.add(publishAllRButton);\n        buttonPanel.add(publishMapRButton);\n        buttonPanel.add(publishCMapRButton);\n        buttonPanel.add(publishAllRButton);\n        \n        JPanel bottomPanel = new JPanel();\n        // bottomPanel.setBorder(new LineBorder(Color.BLACK));\n        bottomPanel.add(nextButton);\n        bottomPanel.add(finishButton);\n        bottomPanel.add(cancelButton);\n        //bottomPanel.setSize(WIDTH/3, HEIGHT/10);\n        \n        \n        nextButton.setEnabled(false);\n        finishButton.setEnabled(false);\n        \n        c.gridy = 0;\n        c.gridx = 0;\n        c.gridwidth = 6;\n        c.anchor = GridBagConstraints.WEST;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(topLabel, c);\n        modeSelectionPanel.add(topLabel);\n        \n        c.gridy = 1;\n        c.insets = new Insets(2,0,2, 2);\n        gridbag.setConstraints(buttonPanel, c);\n        modeSelectionPanel.add(buttonPanel);\n        \n        c.gridy = 2;\n        c.gridwidth = 6;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(informationArea, c);\n        modeSelectionPanel.add(informationArea);\n        \n        c.gridy = 3;\n        c.gridwidth =2;\n        c.insets = new Insets(10,9,2, 2);\n        gridbag.setConstraints(dsLabel,c);\n        modeSelectionPanel.add(dsLabel);\n        \n        c.gridy = 4;\n        c.gridwidth =2;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(dataSourceComboBox,c);\n        modeSelectionPanel.add(dataSourceComboBox);\n        \n        c.gridy = 5;\n        c.gridx = 3;\n        c.gridwidth =3;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(bottomPanel, c);\n        modeSelectionPanel.add(bottomPanel);\n    }","id":231,"modified_method":"private void setUpModeSelectionPanel() {\n        \n        modeSelectionPanel = new JPanel();\n        GridBagLayout gridbag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n        modeSelectionPanel.setLayout(gridbag);\n        Insets defaultInsets = new Insets(2,0,2,2);\n        \n        ButtonGroup modeSelectionGroup = new ButtonGroup();\n        JLabel topLabel = new JLabel(\"Location\");\n        JLabel modeLabel = new JLabel(\"Mode\");\n        \n        //area for displaying information about publishing mode\n        informationArea = new JTextArea(\" The Export function allows a user to deposit a concept map into a registered digital repository. Select the different modes to learn more.\");\n        informationArea.setEditable(false);\n        informationArea.setLineWrap(true);\n        informationArea.setWrapStyleWord(true);\n        informationArea.setRows(4);\n        informationArea.setBorder(new LineBorder(Color.BLACK));\n        //informationArea.setBackground(Color.WHITE);\n        informationArea.setSize(WIDTH-50, HEIGHT/3);\n        JLabel dsLabel = new JLabel(\"Where would you like to save the map:\");\n        dataSourceComboBox = new JComboBox(DataSourceViewer.getPublishableDataSources(Publisher.PUBLISH_ALL_MODES));\n        dataSourceComboBox.setToolTipText(\"Select export location.\");\n        \n        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n        publishMapRButton = new JRadioButton(\"Export Map\");\n        publishCMapRButton = new JRadioButton(\"Export IMSCP Map\");\n        publishAllRButton = new JRadioButton(\"Export All\");\n        publishMapRButton.setToolTipText(\"Export map only without local resource files.\");\n        publishCMapRButton.setToolTipText(\"Export IMS content package that include local resource files.\");\n        publishAllRButton.setToolTipText(\"Export map and local resources as separate files.\");\n        publishMapRButton.addActionListener(this);\n        publishCMapRButton.addActionListener(this);\n        publishAllRButton.addActionListener(this);\n        modeSelectionGroup.add(publishMapRButton);\n        modeSelectionGroup.add(publishCMapRButton);\n        modeSelectionGroup.add(publishAllRButton);\n        buttonPanel.add(modeLabel);\n        buttonPanel.add(publishMapRButton);\n        buttonPanel.add(publishCMapRButton);\n        buttonPanel.add(publishAllRButton);\n        JPanel bottomPanel = new JPanel();\n        // bottomPanel.setBorder(new LineBorder(Color.BLACK));\n        \n        bottomPanel.add(nextButton);\n        bottomPanel.add(finishButton);\n        bottomPanel.add(cancelButton);\n        //bottomPanel.setSize(WIDTH/3, HEIGHT/10);\n        \n        \n        nextButton.setEnabled(false);\n        finishButton.setEnabled(false);\n        \n        c.weightx = 0;\n        c.gridwidth = GridBagConstraints.RELATIVE;\n        c.anchor = GridBagConstraints.WEST;\n        c.insets = new Insets(40,5,10, 2);;\n        gridbag.setConstraints(topLabel, c);\n        modeSelectionPanel.add(topLabel);\n        \n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.insets = new Insets(40,30,10, 2);;\n        gridbag.setConstraints(dataSourceComboBox,c);\n        modeSelectionPanel.add(dataSourceComboBox);\n        \n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.insets = new Insets(10,0,10, 2);\n        c.fill = GridBagConstraints.HORIZONTAL;\n        gridbag.setConstraints(buttonPanel, c);\n        modeSelectionPanel.add(buttonPanel);\n        \n        /**\n         * c.gridy = 2;\n         * c.gridwidth = 6;\n         * c.insets = defaultInsets;\n         * gridbag.setConstraints(informationArea, c);\n         * modeSelectionPanel.add(informationArea);\n         *\n         * c.gridy = 3;\n         * c.gridwidth =2;\n         * c.insets = new Insets(10,9,2, 2);\n         * gridbag.setConstraints(dsLabel,c);\n         * modeSelectionPanel.add(dsLabel);\n         **/\n        \n        c.fill = GridBagConstraints.NONE;\n        c.gridwidth = GridBagConstraints.REMAINDER;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = new Insets(10,0,10, 2);\n        gridbag.setConstraints(bottomPanel, c);\n        modeSelectionPanel.add(bottomPanel);\n    }","commit_id":"3ba6b958f1c9d29142f3b9506b663fdf31282d3d","url":"https://github.com/VUE/VUE"},{"original_method":"private MapsSelectionPanel() \n    {\n        setOpaque(false);\n        GridBagLayout gridBag = new GridBagLayout();\n        GridBagConstraints gridBagConstraints = new GridBagConstraints();\n        setLayout(gridBag);\n        \n        fileNameField = new JTextField(20);\n        browseButton = new JButton(\"Browse\");\n        browseButton.addActionListener(new ActionListener()\n        {\n           public void actionPerformed(ActionEvent e)\n           {\n               JFileChooser choose = new JFileChooser();\n               VueFileFilter vff = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n               choose.setFileFilter(vff);\n               choose.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\n               choose.showOpenDialog(MapsSelectionPanel.this);\n               File choice = choose.getSelectedFile();\n               if(choice.isDirectory())\n               {\n                  java.io.FileFilter iff = new java.io.FileFilter()\n                  {\n                      public boolean accept(File file)\n                      {\n                          if(file.getName().substring(file.getName().lastIndexOf(\".\")+1,file.getName().length()).equals(\"vue\"))\n                            return true;\n                          else \n                            return false;\n                      }\n                      \n                      public String getDescrption()\n                      {\n                          return \"VUE FILE\";\n                      }\n                  };\n                  File[] files =  choice.listFiles(iff);\n                  for(int i=0;i<files.length;i++)\n                  {\n                      File file = files[files.length-1-i];\n                      String name = file.getAbsolutePath();\n                      ((MapTableModel)maps.getModel()).addRow(name);\n                      String shortName = getShortNameForFile(name); \n                      fileNameField.setText(shortName);\n                      revalidate();\n                      scroll.getViewport().revalidate();\n                  }\n               }\n               else\n               {    \n                  String name = choice.getAbsolutePath();\n                  ((MapTableModel)maps.getModel()).addRow(name);\n                  fileNameField.setText(getShortNameForFile(name));\n                  revalidate();\n                  scroll.getViewport().revalidate();\n               }\n           }\n        });\n        VUE.getTabbedPane().addContainerListener(new java.awt.event.ContainerListener()\n        {\n            public void componentAdded(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component added \" + e);\n                revalidate();\n            }\n            \n            public void componentRemoved(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component removed \" + e);\n                revalidate();\n            }\n        });\n        VUE.getTabbedPane().addChangeListener(new ChangeListener()\n        {\n            public void stateChanged(javax.swing.event.ChangeEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane change event \" + e);\n            }\n        });\n        \n        VUE.getTabbedPane().addPropertyChangeListener(new PropertyChangeListener()\n        {\n            public void propertyChange(PropertyChangeEvent e)\n            {\n                revalidate();\n                repaint();\n                scroll.getViewport().revalidate();\n                //System.out.println(\"MSP: VUE tabbed pane property change event \" + e.getPropertyName());\n            }\n        });\n\n        JLabel stepOneLabel = new JLabel(stepOneMessage);\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        gridBag.setConstraints(stepOneLabel,gridBagConstraints);\n        stepOneLabel.setBorder(BorderFactory.createEmptyBorder(15,0,0,0));\n        add(stepOneLabel);\n        \n        JLabel stepTwoLabel = new JLabel(stepTwoMessage);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(stepTwoLabel,gridBagConstraints);\n        stepTwoLabel.setBorder(BorderFactory.createEmptyBorder(0,0,15,0));\n        add(stepTwoLabel);  \n               \n        bottomPanel = new JPanel();\n        filterOnBaseMap = new JCheckBox();\n        JLabel filterOnBaseMapMessage = new JLabel(filterOnBaseMapMessageString);\n        //filterOnBaseMapMessage.setOpaque(false);\n        bottomPanel.setOpaque(false);\n        bottomPanel.add(filterOnBaseMap);\n        bottomPanel.add(filterOnBaseMapMessage);\n        gridBagConstraints.weighty = 0.0;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(bottomPanel,gridBagConstraints);\n        add(bottomPanel);\n        \n        JLabel selectMapsLabel = new JLabel(\"Select maps:\");\n        selectMapsLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,8));\n        gridBagConstraints.gridwidth = 1;\n        gridBag.setConstraints(selectMapsLabel,gridBagConstraints);\n        add(selectMapsLabel);\n        \n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 0.0;\n        gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;\n        gridBag.setConstraints(fileNameField,gridBagConstraints);\n        add(fileNameField);\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(browseButton,gridBagConstraints);\n        add(browseButton);\n        maps = new JTable(new MapTableModel());\n        maps.setRowHeight(maps.getRowHeight()+6);\n        maps.getTableHeader().setReorderingAllowed(false);\n        maps.addMouseListener(new java.awt.event.MouseAdapter() {\n          public void mousePressed(java.awt.event.MouseEvent e)\n          {\n            MapTableModel model = (MapTableModel)maps.getModel();\n            //System.out.println(\"MSP mouse pressed, row column: \" + maps.getSelectedRow() + \",\" + maps.getSelectedColumn());\n            if(maps.getSelectedColumn() == 0)\n            {\n                if(model.isSelected(maps.getSelectedRow()))\n                    model.setSelected(false,maps.getSelectedRow());\n                else\n                    model.setSelected(true,maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 2)\n            {\n                model.setBaseMapIndex(maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 3)\n            {\n                deleteDown = true;\n            }\n            else\n            {\n                deleteDown = false;\n            }\n            repaint();\n            \n          }\n          \n          public void mouseReleased(java.awt.event.MouseEvent e)\n          {\n            if(maps.getSelectedColumn() == 3 && ((MapTableModel)maps.getModel()).getMapType(maps.getSelectedRow()) == LOCAL_FILE)\n            {\n                ((MapTableModel)maps.getModel()).localFiles.remove(maps.getSelectedRow());\n                deleteDown = false;\n            }     \n            repaint();\n          }\n          \n        });\n        maps.setDefaultRenderer(Object.class,new MapTableCellRenderer());\n        maps.getColumnModel().getColumn(0).setMinWidth(50);\n        maps.getColumnModel().getColumn(1).setMinWidth(360);\n        maps.getColumnModel().getColumn(2).setMinWidth(50);\n        maps.getColumnModel().getColumn(3).setMinWidth(80);\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        gridBagConstraints.anchor = GridBagConstraints.NORTH;\n        gridBagConstraints.fill = gridBagConstraints.BOTH;\n        scroll = new JScrollPane(maps);\n        gridBag.setConstraints(scroll,gridBagConstraints);\n        add(scroll);\n        \n    }","id":232,"modified_method":"private MapsSelectionPanel() \n    {\n        setOpaque(false);\n        GridBagLayout gridBag = new GridBagLayout();\n        GridBagConstraints gridBagConstraints = new GridBagConstraints();\n        setLayout(gridBag);\n        \n        //fileNameField = new JTextField(20);\n        browseButton = new JButton(\"Add Maps\");\n        browseButton.addActionListener(new ActionListener()\n        {\n           public void actionPerformed(ActionEvent e)\n           {\n               JFileChooser choose = new JFileChooser();\n               VueFileFilter vff = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n               choose.setFileFilter(vff);\n               choose.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\n               choose.showOpenDialog(MapsSelectionPanel.this);\n               File choice = choose.getSelectedFile();\n               if(choice.isDirectory())\n               {\n                  java.io.FileFilter iff = new java.io.FileFilter()\n                  {\n                      public boolean accept(File file)\n                      {\n                          if(file.getName().substring(file.getName().lastIndexOf(\".\")+1,file.getName().length()).equals(\"vue\"))\n                            return true;\n                          else \n                            return false;\n                      }\n                      \n                      public String getDescription()\n                      {\n                          return \"VUE FILE\";\n                      }\n                  };\n                  File[] files =  choice.listFiles(iff);\n                  for(int i=0;i<files.length;i++)\n                  {\n                      File file = files[files.length-1-i];\n                      String name = file.getAbsolutePath();\n                      ((MapTableModel)maps.getModel()).addRow(name);\n                      //String shortName = getShortNameForFile(name); \n                      //fileNameField.setText(shortName);\n                      revalidate();\n                      scroll.getViewport().revalidate();\n                  }\n               }\n               else\n               {    \n                  String name = choice.getAbsolutePath();\n                  ((MapTableModel)maps.getModel()).addRow(name);\n                  //fileNameField.setText(getShortNameForFile(name));\n                  revalidate();\n                  scroll.getViewport().revalidate();\n               }\n           }\n        });\n        VUE.getTabbedPane().addContainerListener(new java.awt.event.ContainerListener()\n        {\n            public void componentAdded(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component added \" + e);\n                revalidate();\n            }\n            \n            public void componentRemoved(java.awt.event.ContainerEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane component removed \" + e);\n                revalidate();\n            }\n        });\n        VUE.getTabbedPane().addChangeListener(new ChangeListener()\n        {\n            public void stateChanged(javax.swing.event.ChangeEvent e)\n            {\n                //System.out.println(\"MSP: VUE tabbed pane change event \" + e);\n            }\n        });\n        \n        VUE.getTabbedPane().addPropertyChangeListener(new PropertyChangeListener()\n        {\n            public void propertyChange(PropertyChangeEvent e)\n            {\n                revalidate();\n                repaint();\n                scroll.getViewport().revalidate();\n                //System.out.println(\"MSP: VUE tabbed pane property change event \" + e.getPropertyName());\n            }\n        });\n\n        JLabel stepOneLabel = new JLabel(stepOneMessage);\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        gridBag.setConstraints(stepOneLabel,gridBagConstraints);\n        stepOneLabel.setBorder(BorderFactory.createEmptyBorder(15,0,0,0));\n        add(stepOneLabel);\n        \n        JLabel stepTwoLabel = new JLabel(stepTwoMessage);\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(stepTwoLabel,gridBagConstraints);\n        stepTwoLabel.setBorder(BorderFactory.createEmptyBorder(0,0,15,0));\n        add(stepTwoLabel);  \n               \n        //bottomPanel = new JPanel();\n        filterOnBaseMap = new JCheckBox();\n        JLabel filterOnBaseMapMessage = new JLabel(filterOnBaseMapMessageString);\n        ////filterOnBaseMapMessage.setOpaque(false);\n        //bottomPanel.setOpaque(false);\n        //bottomPanel.add(filterOnBaseMap);\n        //bottomPanel.add(filterOnBaseMapMessage);\n        //gridBagConstraints.weighty = 0.0;\n        //gridBagConstraints.anchor = GridBagConstraints.WEST;\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        //gridBag.setConstraints(bottomPanel,gridBagConstraints);\n        //add(bottomPanel);\n        \n        \n        //JLabel selectMapsLabel = new JLabel(\"Select maps:\");\n        //selectMapsLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,8));\n        //gridBagConstraints.gridwidth = 1;\n        //gridBag.setConstraints(selectMapsLabel,gridBagConstraints);\n        //add(selectMapsLabel);\n        \n        //gridBagConstraints.weightx = 1.0;\n        //gridBagConstraints.weighty = 0.0;\n        //gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;\n        //gridBag.setConstraints(fileNameField,gridBagConstraints);\n        //add(fileNameField);\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.anchor = GridBagConstraints.WEST;\n        gridBagConstraints.gridwidth = 1;\n        //gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        gridBag.setConstraints(browseButton,gridBagConstraints);\n        browseButton.setOpaque(false);\n        add(browseButton);\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.anchor = GridBagConstraints.EAST;\n        gridBag.setConstraints(filterOnBaseMap,gridBagConstraints);\n        filterOnBaseMap.setOpaque(false);\n        add(filterOnBaseMap);\n        gridBagConstraints.weightx = 0.0;\n        gridBagConstraints.insets = new Insets(0,0,0,5);\n        gridBagConstraints.gridwidth = GridBagConstraints.REMAINDER;\n        filterOnBaseMapMessage.setForeground(new Color(77,109,109));\n        gridBag.setConstraints(filterOnBaseMapMessage,gridBagConstraints);\n        add(filterOnBaseMapMessage);\n        gridBagConstraints.insets = new Insets(0,0,0,0);\n        maps = new JTable(new MapTableModel());\n        maps.setRowHeight(maps.getRowHeight()+6);\n        maps.getTableHeader().setReorderingAllowed(false);\n        maps.addMouseListener(new java.awt.event.MouseAdapter() {\n          public void mousePressed(java.awt.event.MouseEvent e)\n          {\n            MapTableModel model = (MapTableModel)maps.getModel();\n            //System.out.println(\"MSP mouse pressed, row column: \" + maps.getSelectedRow() + \",\" + maps.getSelectedColumn());\n            if(maps.getSelectedColumn() == 0)\n            {\n                if(model.isSelected(maps.getSelectedRow()))\n                    model.setSelected(false,maps.getSelectedRow());\n                else\n                    model.setSelected(true,maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 2)\n            {\n                model.setBaseMapIndex(maps.getSelectedRow());\n            }\n            if(maps.getSelectedColumn() == 3)\n            {\n                deleteDown = true;\n            }\n            else\n            {\n                deleteDown = false;\n            }\n            repaint();\n            \n          }\n          \n          public void mouseReleased(java.awt.event.MouseEvent e)\n          {\n            if(maps.getSelectedColumn() == 3 && ((MapTableModel)maps.getModel()).getMapType(maps.getSelectedRow()) == LOCAL_FILE)\n            {\n                ((MapTableModel)maps.getModel()).localFiles.remove(maps.getSelectedRow());\n                deleteDown = false;\n            }     \n            repaint();\n          }\n          \n        });\n        maps.setDefaultRenderer(Object.class,new MapTableCellRenderer());\n        maps.getColumnModel().getColumn(0).setMinWidth(50);\n        maps.getColumnModel().getColumn(1).setMinWidth(360);\n        maps.getColumnModel().getColumn(2).setMinWidth(50);\n        maps.getColumnModel().getColumn(3).setMinWidth(80);\n        gridBagConstraints.weightx = 1.0;\n        gridBagConstraints.weighty = 1.0;\n        gridBagConstraints.anchor = GridBagConstraints.NORTH;\n        gridBagConstraints.fill = gridBagConstraints.BOTH;\n        scroll = new JScrollPane(maps);\n        gridBag.setConstraints(scroll,gridBagConstraints);\n        add(scroll);\n        \n    }","commit_id":"47e107519d1785bf8cd7d0437614683a1860af85","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean isApplicable(AnActionEvent event) {\n    ProjectView projectView = ProjectView.getInstance(DeleteFavoritesList_Action.this.project);\n    AbstractProjectViewPane pane = projectView.getCurrentProjectViewPane();\n    return pane instanceof FavoritesProjectPane;\n  }","id":233,"modified_method":"public boolean isApplicable(AnActionEvent event) {\n    return FavoritesUtil.isActiveFavorites(DeleteFavoritesList_Action.this.project);\n  }","commit_id":"2ab42425b5bc9bd789a5d864fd0e971644b7b593","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(AnActionEvent event) {\n    if (RemoveFromFavorites_Action.this.treeNodes.isEmpty()) {\n      return false;\n    }\n    ProjectView projectView = ProjectView.getInstance(RemoveFromFavorites_Action.this.project);\n    AbstractProjectViewPane pane = projectView.getCurrentProjectViewPane();\n    return pane instanceof FavoritesProjectPane;\n  }","id":234,"modified_method":"public boolean isApplicable(AnActionEvent event) {\n    if (RemoveFromFavorites_Action.this.treeNodes.isEmpty()) {\n      return false;\n    }\n    return FavoritesUtil.isActiveFavorites(RemoveFromFavorites_Action.this.project);\n  }","commit_id":"2ab42425b5bc9bd789a5d864fd0e971644b7b593","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(AnActionEvent event) {\n    ProjectView projectView = ProjectView.getInstance(RenameFavoritesList_Action.this.project);\n    AbstractProjectViewPane pane = projectView.getCurrentProjectViewPane();\n    return pane instanceof FavoritesProjectPane;\n  }","id":235,"modified_method":"public boolean isApplicable(AnActionEvent event) {\n    return FavoritesUtil.isActiveFavorites(RenameFavoritesList_Action.this.project);\n  }","commit_id":"2ab42425b5bc9bd789a5d864fd0e971644b7b593","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void PopulateFields(CCombo cc)\r\n\t {\r\n\t\t try{\r\n\t           \r\n\t\t\t\tcc.removeAll();\r\n\t\t\t\tRowMetaInterface r = transMeta.getPrevStepFields(stepname);\r\n\t\t\t\tif (r!=null)\r\n\t\t\t\t{\r\n\t\t             r.getFieldNames();\r\n\t\t             \r\n\t\t             for (int i=0;i<r.getFieldNames().length;i++)\r\n\t\t\t\t\t\t{\t\r\n\t\t\t\t\t\t\tcc.add(r.getFieldNames()[i]);\t\t\t\t\t\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t }catch(KettleException ke){\r\n\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"XsltDialog.FailedToGetFields.DialogTitle\"), BaseMessages.getString(PKG, \"XsltDialog.FailedToGetFields.DialogMessage\"), ke); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t}\r\n\r\n\t }","id":236,"modified_method":"private void PopulateFields(CCombo cc)\r\n\t {\r\n\t\t if(cc.isDisposed()) return;\r\n\t\t try{\r\n\t\t\tString initValue=cc.getText();\r\n\t\t\tcc.removeAll();\r\n\t\t\tRowMetaInterface r = transMeta.getPrevStepFields(stepname);\r\n\t\t\tif (r!=null) {\r\n\t             cc.setItems(r.getFieldNames());\r\n\t\t\t}\r\n\t\t\tif(!Const.isEmpty(initValue)) cc.setText(initValue);\r\n\t\t }catch(KettleException ke){\r\n\t\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG, \"XsltDialog.FailedToGetFields.DialogTitle\"), BaseMessages.getString(PKG, \"XsltDialog.FailedToGetFields.DialogMessage\"), ke); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t}\r\n\t\t \r\n\t }","commit_id":"f9f3215cab21e96a814151d163b382b5be8ca9c7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void get()\n\t {\n\t\t try{\n\t           \n\t\t\t    wFileName.removeAll();\n\t\t\t\tRowMetaInterface r = transMeta.getPrevStepFields(stepname);\n\t\t\t\tif (r!=null)\n\t\t\t\t{\n\t\t             r.getFieldNames();\n\t\t             \n\t\t             for (int i=0;i<r.getFieldNames().length;i++)\n\t\t\t\t\t{\t\n\t\t\t\t\t\twFileName.add(r.getFieldNames()[i]);\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t }catch(KettleException ke){\n\t\t\t\tnew ErrorDialog(shell, Messages.getString(\"FileExistsDialog.FailedToGetFields.DialogTitle\"), Messages.getString(\"FileExistsDialog.FailedToGetFields.DialogMessage\"), ke); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t }","id":237,"modified_method":"private void get()\n\t {\n\t\t if(!gotPreviousFields) {\n\t\t try{\n\t            String fieldvalue=wFileName.getText();\n\t\t\t    wFileName.removeAll();\n\t\t\t\tRowMetaInterface r = transMeta.getPrevStepFields(stepname);\n\t\t\t\tif (r!=null)\n\t\t\t\t{\n\t\t\t\t\twFileName.setItems(r.getFieldNames());\n\t\t\t\t}\n\t\t\t\tif(fieldvalue!=null) wFileName.setText(fieldvalue);\n\t\t\t\tgotPreviousFields=true;\n\t\t }catch(KettleException ke){\n\t\t\t\tnew ErrorDialog(shell, Messages.getString(\"FileExistsDialog.FailedToGetFields.DialogTitle\"), Messages.getString(\"FileExistsDialog.FailedToGetFields.DialogMessage\"), ke); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t}\n\t\t }\n\t }","commit_id":"654aa7a82de5256c43013949ba57b22c08a598e3","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getPreviousFields() {\n    try {\n      RowMetaInterface r = transMeta.getPrevStepFields( stepname );\n      if ( r != null ) {\n        r.getFieldNames();\n\n        for ( int i = 0; i < r.getFieldNames().length; i++ ) {\n          wfieldevaluate.add( r.getFieldNames()[i] );\n\n        }\n      }\n    } catch ( KettleException ke ) {\n      new ErrorDialog(\n        shell, BaseMessages.getString( PKG, \"RegexEvalDialog.FailedToGetFields.DialogTitle\" ), BaseMessages\n          .getString( PKG, \"RegexEvalDialog.FailedToGetFields.DialogMessage\" ), ke );\n    }\n  }","id":238,"modified_method":"private void getPreviousFields() {\n    // Save user-selected value, if applicable\n    String selectedValue = wfieldevaluate.getText();\n\n    // Clear the existing list, and reload\n    wfieldevaluate.removeAll();\n    try {\n      RowMetaInterface r = transMeta.getPrevStepFields( stepname );\n      if ( r != null ) {\n        for ( String item : r.getFieldNames() ) {\n            wfieldevaluate.add(  item );\n        }\n      }\n\n      // Re-select the user-selected value, if applicable\n      if ( !Const.isEmpty( selectedValue ) ) {\n        wfieldevaluate.select( wfieldevaluate.indexOf( selectedValue ) );\n      } else {\n        wfieldevaluate.select( 0 );\n      }\n    } catch ( KettleException ke ) {\n      new ErrorDialog(\n        shell, BaseMessages.getString( PKG, \"RegexEvalDialog.FailedToGetFields.DialogTitle\" ), BaseMessages\n          .getString( PKG, \"RegexEvalDialog.FailedToGetFields.DialogMessage\" ), ke );\n    }\n  }","commit_id":"88ed541f67c613f678d362b2febb5f2f025be36b","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getOuterAttrs() {\n\t//Note: don't generate zk_type here because Menupopup's zk_type diff\n\n\t\tfinal String attrs = super.getOuterAttrs();\n\t\tif (!zidRequired())\n\t\t\treturn attrs;\n\n\t\tfinal String id = getId();\n \t\tif (ComponentsCtrl.isAutoId(id))\n\t\t\treturn attrs;\n\n\t\tfinal StringBuffer sb = new StringBuffer(80).append(attrs);\n\t\tHTMLs.appendAttribute(sb, \"zid\", id);\n\t\treturn sb.toString();\n\t}","id":239,"modified_method":"public String getOuterAttrs() {\n\t//Note: don't generate zk_type here because Menupopup's zk_type diff\n\n\t\tfinal StringBuffer sb =\n\t\t\tnew StringBuffer(80).append(super.getOuterAttrs());\n\n\t\tif (isAsapRequired(\"onOpen\"))\n\t\t\tHTMLs.appendAttribute(sb, \"zk_onOpen\", true);\n\n\t\tif (zidRequired()) {\n\t\t\tfinal String id = getId();\n\t \t\tif (!ComponentsCtrl.isAutoId(id))\n\t\t\t\tHTMLs.appendAttribute(sb, \"zid\", id);\n\t\t}\n\t\treturn sb.toString();\n\t}","commit_id":"e5d9e5da292ef21c0d5171db0534c7c95c67bde5","url":"https://github.com/zkoss/zk"},{"original_method":"public String getOuterAttrs() {\n\t\tfinal String attrs = super.getOuterAttrs();\n\t\tif (isDisabled()) {\n\t\t\tfinal StringBuffer sb = new StringBuffer(60).append(attrs);\n\t\t\tHTMLs.appendAttribute(sb, \"z.disd\", true);\n\t\t\treturn sb.toString();\n\t\t}\n\t\treturn attrs;\n\t}","id":240,"modified_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb = new StringBuffer(60).append(super.getOuterAttrs());\n\t\tHTMLs.appendAttribute(sb, \"z.label\", XMLs.escapeXML(getLabel()));\n\t\t\t\n\t\tif (isDisabled())\n\t\t\tHTMLs.appendAttribute(sb, \"z.disd\", true);\n\t\treturn sb.toString();\n\t}","commit_id":"d52f2f1d3e287bd5e355bcf463d985b23149e147","url":"https://github.com/zkoss/zk"},{"original_method":"public String getOuterAttrs() {\n\t\tfinal String attrs = super.getOuterAttrs();\n\t\tif (\"none\".equals(_collapse)) return attrs;\n\n\t\tfinal StringBuffer sb = new StringBuffer(80).append(attrs);\n\t\tHTMLs.appendAttribute(sb, \"zk_colps\", _collapse);\n\t\treturn sb.toString();\n\t}","id":241,"modified_method":"public String getOuterAttrs() {\n\t\tfinal StringBuffer sb =\n\t\t\tnew StringBuffer(80).append(super.getOuterAttrs());\n\t\tif (\"vertical\".equals(getOrient()))\n\t\t\tHTMLs.appendAttribute(sb, \"zk_vert\", \"true\");\n\t\tif (\"none\".equals(_collapse))\n\t\t\tHTMLs.appendAttribute(sb, \"zk_colps\", _collapse);\n\t\treturn sb.toString();\n\t}","commit_id":"a7ddb11a9ff8150ca101413b79189564ff5854a7","url":"https://github.com/zkoss/zk"},{"original_method":"public static void nagUserOfReplacedMethod(String methodName, String replacement) {\n        if (isEnabled() && METHODS.add(methodName)) {\n            LOGGER.warn(String.format(\n                    \"The %s method %s. Please use the %s method instead.\",\n                    methodName, getDeprecationMessage(), replacement));\n            logTraceIfNecessary();\n        }\n    }","id":242,"modified_method":"public static void nagUserOfReplacedMethod(String methodName, String replacement) {\n        nagUserWith(String.format(\n                \"The %s method %s. Please use the %s method instead.\",\n                methodName, getDeprecationMessage(), replacement));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"public static void nagUserOfReplacedTaskType(String taskName, String replacement) {\n        if (isEnabled() && TASKS.add(taskName)) {\n            LOGGER.warn(String.format(\n                    \"The %s task type %s. Please use the %s instead.\",\n                    taskName, getDeprecationMessage(), replacement));\n            logTraceIfNecessary();\n        }\n    }","id":243,"modified_method":"public static void nagUserOfReplacedTaskType(String taskName, String replacement) {\n        nagUserWith(String.format(\n                \"The %s task type %s. Please use the %s instead.\",\n                taskName, getDeprecationMessage(), replacement));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"public static void nagUserOfDiscontinuedProperty(String propertyName, String advice) {\n        if (isEnabled() && PROPERTIES.add(propertyName)) {\n            LOGGER.warn(String.format(\"The %s property %s. %s\",\n                    propertyName, getDeprecationMessage(), advice));\n            logTraceIfNecessary();\n        }\n    }","id":244,"modified_method":"public static void nagUserOfDiscontinuedProperty(String propertyName, String advice) {\n        nagUserWith(String.format(\"The %s property %s. %s\",\n                propertyName, getDeprecationMessage(), advice));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"public static void nagUserOfReplacedProperty(String propertyName, String replacement) {\n        if (isEnabled() && PROPERTIES.add(propertyName)) {\n            LOGGER.warn(String.format(\n                    \"The %s property %s. Please use the %s property instead.\",\n                    propertyName, getDeprecationMessage(), replacement));\n            logTraceIfNecessary();\n        }\n    }","id":245,"modified_method":"public static void nagUserOfReplacedProperty(String propertyName, String replacement) {\n        nagUserWith(String.format(\n                \"The %s property %s. Please use the %s property instead.\",\n                propertyName, getDeprecationMessage(), replacement));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"public static void nagUserOfDiscontinuedMethod(String methodName) {\n        if (isEnabled() && METHODS.add(methodName)) {\n            LOGGER.warn(String.format(\"The %s method %s.\",\n                    methodName, getDeprecationMessage()));\n            logTraceIfNecessary();\n        }\n    }","id":246,"modified_method":"public static void nagUserOfDiscontinuedMethod(String methodName) {\n        nagUserWith(String.format(\"The %s method %s.\",\n                methodName, getDeprecationMessage()));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"public static void nagUserOfReplacedNamedParameter(String parameterName, String replacement) {\n        if (isEnabled() && NAMED_PARAMETERS.add(parameterName)) {\n            LOGGER.warn(String.format(\n                    \"The %s named parameter %s. Please use the %s named parameter instead.\",\n                    parameterName, getDeprecationMessage(), replacement));\n            logTraceIfNecessary();\n        }\n    }","id":247,"modified_method":"public static void nagUserOfReplacedNamedParameter(String parameterName, String replacement) {\n        nagUserWith(String.format(\n                \"The %s named parameter %s. Please use the %s named parameter instead.\",\n                parameterName, getDeprecationMessage(), replacement));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"public static void nagUserOfReplacedPlugin(String pluginName, String replacement) {\n        if (isEnabled() && PLUGINS.add(pluginName)) {\n            LOGGER.warn(String.format(\n                    \"The %s plugin %S. Please use the %s plugin instead.\",\n                    pluginName, getDeprecationMessage(), replacement));\n            logTraceIfNecessary();\n        }\n    }","id":248,"modified_method":"public static void nagUserOfReplacedPlugin(String pluginName, String replacement) {\n        nagUserWith(String.format(\n                \"The %s plugin %S. Please use the %s plugin instead.\",\n                pluginName, getDeprecationMessage(), replacement));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"public static void nagUserOfDiscontinuedConfiguration(String configurationName, String advice) {\n        if (isEnabled() && CONFIGURATIONS.add(configurationName)) {\n            LOGGER.warn(String.format(\"The %s configuration %s. %s\",\n                    configurationName, getDeprecationMessage(), advice));\n            logTraceIfNecessary();\n        }\n    }","id":249,"modified_method":"public static void nagUserOfDiscontinuedConfiguration(String configurationName, String advice) {\n        nagUserWith(String.format(\"The %s configuration %s. %s\",\n                configurationName, getDeprecationMessage(), advice));\n    }","commit_id":"32a43a3e9fa86edf0a9e6c8f4717e83f0f6bcc92","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n\tpublic void cachePortletResourceOutput(IPortletWindowId portletWindowId,\n\t\t\tHttpServletRequest httpRequest, byte[] content, String contentType, Map<String, String[]> headers, CacheControl cacheControl) {\n\t\tfinal IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpRequest, portletWindowId);\n        \n        final IPortletEntityId entityId = portletWindow.getPortletEntityId();\n        final IPortletEntity entity = this.portletEntityRegistry.getPortletEntity(httpRequest, entityId);\n        final IPortletDefinitionId definitionId = entity.getPortletDefinitionId();\t\n\t\t\n        final int expirationTime = cacheControl.getExpirationTime();\n\t\tCachedPortletData newData = new CachedPortletData();\n\t\tnewData.setEtag(cacheControl.getETag());\n\t\tnewData.setByteData(content);\n\t\tnewData.setExpirationTimeSeconds(expirationTime);\n\t\tnewData.setTimeStored(new Date());\n\t\tnewData.setContentType(contentType);\n\t\tnewData.setHeaders(headers);\n\t\t\n\t\t\n\t\tif(cacheControl.isPublicScope()) {\n\t\t\tSerializable publicCacheKey = generatePublicScopePortletDataCacheKey(definitionId, portletWindow.getRenderParameters(), portletWindow.getPublicRenderParameters());\n\t\t\tint ttl = findMinimumCacheTTL(publicScopePortletResourceOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tElement publicCacheElement = constructCacheElement(publicCacheKey, newData, ttl);\n\t\t\tthis.publicScopePortletResourceOutputCache.put(publicCacheElement);\t\t\n\t\t} else {\n\t\t\tSerializable privateCacheKey = generatePrivateScopePortletDataCacheKey(httpRequest, portletWindowId, entityId, definitionId, portletWindow.getRenderParameters());\n\t\t\tint ttl = findMinimumCacheTTL(privateScopePortletResourceOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tElement privateCacheElement = constructCacheElement(privateCacheKey, newData, ttl);\n\t\t\tthis.privateScopePortletResourceOutputCache.put(privateCacheElement);\n\t\t}\n\t}","id":250,"modified_method":"@Override\n\tpublic void cachePortletResourceOutput(IPortletWindowId portletWindowId,\n\t\t\tHttpServletRequest httpRequest, byte[] content, String contentType, Map<String, String[]> headers, CacheControl cacheControl) {\n\t\tfinal IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpRequest, portletWindowId);\n        \n        final IPortletEntityId entityId = portletWindow.getPortletEntityId();\n        final IPortletEntity entity = this.portletEntityRegistry.getPortletEntity(httpRequest, entityId);\n        final IPortletDefinitionId definitionId = entity.getPortletDefinitionId();\t\n\t\t\n        final int expirationTime = cacheControl.getExpirationTime();\n\t\tCachedPortletData newData = new CachedPortletData();\n\t\tnewData.setEtag(cacheControl.getETag());\n\t\tnewData.setByteData(content);\n\t\tnewData.setExpirationTimeSeconds(expirationTime);\n\t\tnewData.setTimeStored(new Date());\n\t\tnewData.setContentType(contentType);\n\t\tnewData.setHeaders(headers);\n\t\t\n\t\tif(cacheControl.isPublicScope()) {\n\t\t\tnewData.setCacheConfigurationMaxTTL(new Long(publicScopePortletResourceOutputCache.getCacheConfiguration().getTimeToLiveSeconds()).intValue());\n\t\t\tSerializable publicCacheKey = generatePublicScopePortletDataCacheKey(definitionId, portletWindow.getRenderParameters(), portletWindow.getPublicRenderParameters());\n\t\t\tElement publicCacheElement = constructCacheElement(publicCacheKey, newData, publicScopePortletResourceOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tthis.publicScopePortletResourceOutputCache.put(publicCacheElement);\t\t\n\t\t} else {\n\t\t\tnewData.setCacheConfigurationMaxTTL(new Long(privateScopePortletResourceOutputCache.getCacheConfiguration().getTimeToLiveSeconds()).intValue());\n\t\t\tSerializable privateCacheKey = generatePrivateScopePortletDataCacheKey(httpRequest, portletWindowId, entityId, definitionId, portletWindow.getRenderParameters());\n\t\t\tElement privateCacheElement = constructCacheElement(privateCacheKey, newData, privateScopePortletResourceOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tthis.privateScopePortletResourceOutputCache.put(privateCacheElement);\n\t\t}\n\t}","commit_id":"370cb11a3bf97df5de68ac0a771e298849b1e700","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n\tpublic void cachePortletRenderOutput(IPortletWindowId portletWindowId,\n\t\t\tHttpServletRequest httpRequest, String content,\n\t\t\tCacheControl cacheControl) {\n\t\tfinal IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpRequest, portletWindowId);\n        \n        final IPortletEntityId entityId = portletWindow.getPortletEntityId();\n        final IPortletEntity entity = this.portletEntityRegistry.getPortletEntity(httpRequest, entityId);\n        final IPortletDefinitionId definitionId = entity.getPortletDefinitionId();\t\n\t\t\n        final int expirationTime = cacheControl.getExpirationTime();\n\t\tCachedPortletData newData = new CachedPortletData();\n\t\tnewData.setExpirationTimeSeconds(expirationTime);\n\t\tnewData.setTimeStored(new Date());\n\t\tnewData.setStringData(content);\n\t\tnewData.setEtag(cacheControl.getETag());\n\t\t\n\t\tif(cacheControl.isPublicScope()) {\n\t\t\tSerializable publicCacheKey = generatePublicScopePortletDataCacheKey(definitionId, portletWindow.getRenderParameters(), portletWindow.getPublicRenderParameters());\n\t\t\tint ttl = findMinimumCacheTTL(publicScopePortletRenderOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tElement publicCacheElement = constructCacheElement(publicCacheKey, newData, ttl);\n\t\t\tthis.publicScopePortletRenderOutputCache.put(publicCacheElement);\t\t\n\t\t} else {\n\t\t\tSerializable privateCacheKey = generatePrivateScopePortletDataCacheKey(httpRequest, portletWindowId, entityId, definitionId, portletWindow.getRenderParameters());\n\t\t\tint ttl = findMinimumCacheTTL(privateScopePortletRenderOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tElement privateCacheElement = constructCacheElement(privateCacheKey, newData, ttl);\n\t\t\tthis.privateScopePortletRenderOutputCache.put(privateCacheElement);\n\t\t}\n\t}","id":251,"modified_method":"@Override\n\tpublic void cachePortletRenderOutput(IPortletWindowId portletWindowId,\n\t\t\tHttpServletRequest httpRequest, String content,\n\t\t\tCacheControl cacheControl) {\n\t\tfinal IPortletWindow portletWindow = this.portletWindowRegistry.getPortletWindow(httpRequest, portletWindowId);\n        \n        final IPortletEntityId entityId = portletWindow.getPortletEntityId();\n        final IPortletEntity entity = this.portletEntityRegistry.getPortletEntity(httpRequest, entityId);\n        final IPortletDefinitionId definitionId = entity.getPortletDefinitionId();\t\n\t\t\n        final int expirationTime = cacheControl.getExpirationTime();\n\t\tCachedPortletData newData = new CachedPortletData();\n\t\tnewData.setExpirationTimeSeconds(expirationTime);\n\t\tnewData.setTimeStored(new Date());\n\t\tnewData.setStringData(content);\n\t\tnewData.setEtag(cacheControl.getETag());\n\t\t\n\t\tif(cacheControl.isPublicScope()) {\n\t\t\tnewData.setCacheConfigurationMaxTTL(new Long(publicScopePortletRenderOutputCache.getCacheConfiguration().getTimeToLiveSeconds()).intValue());\n\t\t\tSerializable publicCacheKey = generatePublicScopePortletDataCacheKey(definitionId, portletWindow.getRenderParameters(), portletWindow.getPublicRenderParameters());\n\t\t\tElement publicCacheElement = constructCacheElement(publicCacheKey, newData, publicScopePortletRenderOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tthis.publicScopePortletRenderOutputCache.put(publicCacheElement);\t\t\n\t\t} else {\n\t\t\tnewData.setCacheConfigurationMaxTTL(new Long(privateScopePortletRenderOutputCache.getCacheConfiguration().getTimeToLiveSeconds()).intValue());\n\t\t\tSerializable privateCacheKey = generatePrivateScopePortletDataCacheKey(httpRequest, portletWindowId, entityId, definitionId, portletWindow.getRenderParameters());\n\t\t\tElement privateCacheElement = constructCacheElement(privateCacheKey, newData, privateScopePortletRenderOutputCache.getCacheConfiguration(), cacheControl);\n\t\t\tthis.privateScopePortletRenderOutputCache.put(privateCacheElement);\n\t\t}\n\t}","commit_id":"370cb11a3bf97df5de68ac0a771e298849b1e700","url":"https://github.com/Jasig/uPortal"},{"original_method":"public Connection() throws IOException {\n            m_sock = new Socket();\n            m_sock.connect(m_address, m_timeout);\n            m_sock.setSoTimeout(500);\n// Removed for fix\n//            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()));\n            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()), Charset.defaultCharset());\n            m_input = m_sock.getInputStream();\n            m_rdrThread = new Thread(\"TcpEventProxy Input Discarder\") {\n                public void run() {\n                    for (int ch = 0; ch != -1; ) {\n                        try {\n                            ch = m_input.read();\n                        } catch (InterruptedIOException e) {\n                            ch = 0;\n                        } catch (IOException e) {\n                            ch = -1;\n                        }\n                    }\n                }\n            };\n\n            m_rdrThread.setDaemon(true);\n            m_rdrThread.start();\n        }","id":252,"modified_method":"public Connection() throws IOException {\n            m_sock = new Socket();\n            m_sock.connect(m_address, m_timeout);\n            m_sock.setSoTimeout(500);\n            log().debug(\"Default Charset:\" + Charset.defaultCharset().displayName());\n            log().debug(\"Setting Charset: UTF-8\");\n            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()), Charset.forName(\"UTF-8\"));\n            m_input = m_sock.getInputStream();\n            m_rdrThread = new Thread(\"TcpEventProxy Input Discarder\") {\n                public void run() {\n                    for (int ch = 0; ch != -1; ) {\n                        try {\n                            ch = m_input.read();\n                        } catch (InterruptedIOException e) {\n                            ch = 0;\n                        } catch (IOException e) {\n                            ch = -1;\n                        }\n                    }\n                }\n            };\n\n            m_rdrThread.setDaemon(true);\n            m_rdrThread.start();\n        }","commit_id":"9cf0e7ca0659ff5480f8d0502fc125ae0406088d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Connection() throws IOException {\n            m_sock = new Socket();\n            m_sock.connect(m_address, m_timeout);\n            m_sock.setSoTimeout(500);\n// Removed for fix\n//            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()));\n            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()), Charset.defaultCharset());\n            m_input = m_sock.getInputStream();\n            m_rdrThread = new Thread(\"TcpEventProxy Input Discarder\") {\n                public void run() {\n                    for (int ch = 0; ch != -1; ) {\n                        try {\n                            ch = m_input.read();\n                        } catch (InterruptedIOException e) {\n                            ch = 0;\n                        } catch (IOException e) {\n                            ch = -1;\n                        }\n                    }\n                }\n            };\n\n            m_rdrThread.setDaemon(true);\n            m_rdrThread.start();\n        }","id":253,"modified_method":"public Connection() throws IOException {\n            m_sock = new Socket();\n            m_sock.connect(m_address, m_timeout);\n            m_sock.setSoTimeout(500);\n            log().debug(\"Default Charset:\" + Charset.defaultCharset().displayName());\n            log().debug(\"Setting Charset: UTF-8\");\n            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()), Charset.forName(\"UTF-8\"));\n            m_input = m_sock.getInputStream();\n            m_rdrThread = new Thread(\"TcpEventProxy Input Discarder\") {\n                public void run() {\n                    for (int ch = 0; ch != -1; ) {\n                        try {\n                            ch = m_input.read();\n                        } catch (InterruptedIOException e) {\n                            ch = 0;\n                        } catch (IOException e) {\n                            ch = -1;\n                        }\n                    }\n                }\n            };\n\n            m_rdrThread.setDaemon(true);\n            m_rdrThread.start();\n        }","commit_id":"3a7dd936c49f6db4f77ad261cbbfa5ab355e0b01","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Connection() throws IOException {\n            m_sock = new Socket();\n            m_sock.connect(m_address, m_timeout);\n            m_sock.setSoTimeout(500);\n// Removed for fix\n//            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()));\n            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()), Charset.defaultCharset());\n            m_input = m_sock.getInputStream();\n            m_rdrThread = new Thread(\"TcpEventProxy Input Discarder\") {\n                public void run() {\n                    for (int ch = 0; ch != -1; ) {\n                        try {\n                            ch = m_input.read();\n                        } catch (InterruptedIOException e) {\n                            ch = 0;\n                        } catch (IOException e) {\n                            ch = -1;\n                        }\n                    }\n                }\n            };\n\n            m_rdrThread.setDaemon(true);\n            m_rdrThread.start();\n        }","id":254,"modified_method":"public Connection() throws IOException {\n            m_sock = new Socket();\n            m_sock.connect(m_address, m_timeout);\n            m_sock.setSoTimeout(500);\n            log().debug(\"Default Charset:\" + Charset.defaultCharset().displayName());\n            log().debug(\"Setting Charset: UTF-8\");\n            m_writer = new OutputStreamWriter(new BufferedOutputStream(m_sock.getOutputStream()), Charset.forName(\"UTF-8\"));\n            m_input = m_sock.getInputStream();\n            m_rdrThread = new Thread(\"TcpEventProxy Input Discarder\") {\n                public void run() {\n                    for (int ch = 0; ch != -1; ) {\n                        try {\n                            ch = m_input.read();\n                        } catch (InterruptedIOException e) {\n                            ch = 0;\n                        } catch (IOException e) {\n                            ch = -1;\n                        }\n                    }\n                }\n            };\n\n            m_rdrThread.setDaemon(true);\n            m_rdrThread.start();\n        }","commit_id":"e7b51707ddfdcf74002cf9a2a349938ea7abcda8","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void addSourceRoots( XMLWriter writer, File projectBaseDir, File basedir, List sourceRoots, String output )\n    {\n        for ( Iterator it = sourceRoots.iterator(); it.hasNext(); )\n        {\n            String sourceRoot = (String) it.next();\n\n            if ( new File( sourceRoot ).isDirectory() )\n            {\n                writer.startElement( \"classpathentry\" );\n\n                writer.addAttribute( \"kind\", \"src\" );\n\n                sourceRoot = toRelative( projectBaseDir, sourceRoot );\n                if (!projectBaseDir.equals(basedir))\n                {\n                    sourceRoot = sourceRoot.replaceAll( \"/\", \"-\" );\n                }\n                \n                writer.addAttribute( \"path\", sourceRoot );\n\n                if ( output != null )\n                {\n                    writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n                }\n\n                writer.endElement();\n            }\n        }\n    }","id":255,"modified_method":"private void addSourceRoots( XMLWriter writer, File projectBaseDir, File basedir, List sourceRoots, String output, Map addedSourceRoots )\n    {\n        for ( Iterator it = sourceRoots.iterator(); it.hasNext(); )\n        {\n            String sourceRoot = (String) it.next();\n\n            if ( new File( sourceRoot ).isDirectory() )\n            {\n                // Don't add the same sourceroots twice. No include/exclude\n            \t// patterns possible in maven for (test|script|)source directories.\n                if ( addedSourceRoots.containsKey( sourceRoot ) )\n                {\n                \tcontinue; \n                }\n\n                writer.startElement( \"classpathentry\" );\n\n                writer.addAttribute( \"kind\", \"src\" );\n\n                String eclipseSourceRoot = toRelative( projectBaseDir, sourceRoot );\n                \n                if (!projectBaseDir.equals(basedir))\n                {\n                    eclipseSourceRoot = eclipseSourceRoot.replaceAll( \"/\", \"-\" );\n                }\n                \n                addedSourceRoots.put( sourceRoot, eclipseSourceRoot );\n                \n                writer.addAttribute( \"path\", eclipseSourceRoot );\n\n                if ( output != null )\n                {\n                    writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n                }\n\n                writer.endElement();\n            }\n        }\n    }","commit_id":"9f4e106da7718ea16de897173c86eece6d9b0ef0","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void addResources( XMLWriter writer, File projectBaseDir, File basedir, List resources, String output )\n    {\n        for ( Iterator it = resources.iterator(); it.hasNext(); )\n        {\n            Resource resource = (Resource) it.next();\n\n            if ( resource.getIncludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support include patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( resource.getExcludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support exclude patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( !StringUtils.isEmpty( resource.getTargetPath() ) )\n            {\n                log.error( \"This plugin currently doesn't support target paths for resources.\" );\n\n                return;\n            }\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() || !resourceDirectory.isDirectory() )\n            {\n                continue;\n            }\n\n            writer.startElement( \"classpathentry\" );\n\n            writer.addAttribute( \"kind\", \"src\" );\n\n            String resourceDir = resource.getDirectory();\n            resourceDir = toRelative( projectBaseDir, resourceDir );\n            if (!projectBaseDir.equals(basedir))\n            {\n                resourceDir = resourceDir.replaceAll( \"/\", \"-\" );\n            }\n            \n            writer.addAttribute( \"path\", resourceDir );\n\n            if ( output != null )\n            {\n                writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n            }\n\n            writer.endElement();\n        }\n    }","id":256,"modified_method":"private void addResources( XMLWriter writer, File projectBaseDir, File basedir, List resources, String output, Map addedSourceRoots )\n    {\n        for ( Iterator it = resources.iterator(); it.hasNext(); )\n        {\n            Resource resource = (Resource) it.next();\n\n            if ( resource.getIncludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support include patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( resource.getExcludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support exclude patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( !StringUtils.isEmpty( resource.getTargetPath() ) )\n            {\n            \toutput = resource.getTargetPath();\n            }\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() || !resourceDirectory.isDirectory() )\n            {\n                continue;\n            }\n\n            String resourceDir = resource.getDirectory();\n            \n            // don't add the same sourceroot twice; eclipse can't handle\n            // that, even with mutual exclusive include/exclude patterns.\n            if ( addedSourceRoots.containsKey( resourceDir ) )\n            {\n            \tcontinue;\n            }\n\n            String eclipseResourceDir = toRelative( projectBaseDir, resourceDir );\n            \n            if ( ! projectBaseDir.equals( basedir ) )\n            {\n                eclipseResourceDir = eclipseResourceDir.replaceAll( \"/\", \"-\" );\n            }\n\n            addedSourceRoots.put( resourceDir, eclipseResourceDir );\n            \n            writer.startElement( \"classpathentry\" );\n\n            writer.addAttribute( \"kind\", \"src\" );\n            \n            writer.addAttribute( \"path\", eclipseResourceDir );\n\n//\t\t\tExample of setting include/exclude patterns for future reference.\n//\n//          TODO: figure out how to merge if the same dir is specified twice\n//          with different in/exclude patterns. We can't write them now,\n//\t\t\tsince only the the first one would be included.\n//\n//          if ( resource.getIncludes().size() != 0 )\n//          {\n//          \twriter.addAttribute(\n//            \t\t\"including\", StringUtils.join( resource.getIncludes().iterator(), \"|\" )\n//        \t\t);\n//          }\n//\n//          if ( resource.getExcludes().size() != 0 )\n//          {\n//          \twriter.addAttribute(\n//          \t\t\"excluding\", StringUtils.join( resource.getExcludes().iterator(), \"|\" )\n//          \t);\n//          }\n            \n            if ( output != null )\n            {\n                writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n            }\n\n            writer.endElement();\n        }\n    }","commit_id":"9f4e106da7718ea16de897173c86eece6d9b0ef0","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void addResources( XMLWriter writer, File projectBaseDir, File basedir, List resources, String output )\n    {\n        for ( Iterator it = resources.iterator(); it.hasNext(); )\n        {\n            Resource resource = (Resource) it.next();\n\n            if ( resource.getIncludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support include patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( resource.getExcludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support exclude patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( !StringUtils.isEmpty( resource.getTargetPath() ) )\n            {\n                log.error( \"This plugin currently doesn't support target paths for resources.\" );\n\n                return;\n            }\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() || !resourceDirectory.isDirectory() )\n            {\n                continue;\n            }\n\n            writer.startElement( \"classpathentry\" );\n\n            writer.addAttribute( \"kind\", \"src\" );\n\n            String resourceDir = resource.getDirectory();\n            resourceDir = toRelative( projectBaseDir, resourceDir );\n            if (!projectBaseDir.equals(basedir))\n            {\n                resourceDir = resourceDir.replaceAll( \"/\", \"-\" );\n            }\n            \n            writer.addAttribute( \"path\", resourceDir );\n\n            if ( output != null )\n            {\n                writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n            }\n\n            writer.endElement();\n        }\n    }","id":257,"modified_method":"private void addResources( XMLWriter writer, File projectBaseDir, File basedir, List resources, String output, Map addedSourceRoots )\n    {\n        for ( Iterator it = resources.iterator(); it.hasNext(); )\n        {\n            Resource resource = (Resource) it.next();\n\n            if ( resource.getIncludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support include patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( resource.getExcludes().size() != 0 )\n            {\n                log.warn( \"This plugin currently doesn't support exclude patterns for resources. Adding the entire directory.\" );\n            }\n\n            if ( !StringUtils.isEmpty( resource.getTargetPath() ) )\n            {\n            \toutput = resource.getTargetPath();\n            }\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() || !resourceDirectory.isDirectory() )\n            {\n                continue;\n            }\n\n            String resourceDir = resource.getDirectory();\n            \n            // don't add the same sourceroot twice; eclipse can't handle\n            // that, even with mutual exclusive include/exclude patterns.\n            if ( addedSourceRoots.containsKey( resourceDir ) )\n            {\n            \tcontinue;\n            }\n\n            String eclipseResourceDir = toRelative( projectBaseDir, resourceDir );\n            \n            if ( ! projectBaseDir.equals( basedir ) )\n            {\n                eclipseResourceDir = eclipseResourceDir.replaceAll( \"/\", \"-\" );\n            }\n\n            addedSourceRoots.put( resourceDir, eclipseResourceDir );\n            \n            writer.startElement( \"classpathentry\" );\n\n            writer.addAttribute( \"kind\", \"src\" );\n            \n            writer.addAttribute( \"path\", eclipseResourceDir );\n\n//\t\t\tExample of setting include/exclude patterns for future reference.\n//\n//          TODO: figure out how to merge if the same dir is specified twice\n//          with different in/exclude patterns. We can't write them now,\n//\t\t\tsince only the the first one would be included.\n//\n//          if ( resource.getIncludes().size() != 0 )\n//          {\n//          \twriter.addAttribute(\n//            \t\t\"including\", StringUtils.join( resource.getIncludes().iterator(), \"|\" )\n//        \t\t);\n//          }\n//\n//          if ( resource.getExcludes().size() != 0 )\n//          {\n//          \twriter.addAttribute(\n//          \t\t\"excluding\", StringUtils.join( resource.getExcludes().iterator(), \"|\" )\n//          \t);\n//          }\n            \n            if ( output != null )\n            {\n                writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n            }\n\n            writer.endElement();\n        }\n    }","commit_id":"a98961eeedc4cd03fc02694b9502939edbfe43b2","url":"https://github.com/apache/maven"},{"original_method":"private void addSourceRoots( XMLWriter writer, File projectBaseDir, File basedir, List sourceRoots, String output )\n    {\n        for ( Iterator it = sourceRoots.iterator(); it.hasNext(); )\n        {\n            String sourceRoot = (String) it.next();\n\n            if ( new File( sourceRoot ).isDirectory() )\n            {\n                writer.startElement( \"classpathentry\" );\n\n                writer.addAttribute( \"kind\", \"src\" );\n\n                sourceRoot = toRelative( projectBaseDir, sourceRoot );\n                if (!projectBaseDir.equals(basedir))\n                {\n                    sourceRoot = sourceRoot.replaceAll( \"/\", \"-\" );\n                }\n                \n                writer.addAttribute( \"path\", sourceRoot );\n\n                if ( output != null )\n                {\n                    writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n                }\n\n                writer.endElement();\n            }\n        }\n    }","id":258,"modified_method":"private void addSourceRoots( XMLWriter writer, File projectBaseDir, File basedir, List sourceRoots, String output, Map addedSourceRoots )\n    {\n        for ( Iterator it = sourceRoots.iterator(); it.hasNext(); )\n        {\n            String sourceRoot = (String) it.next();\n\n            if ( new File( sourceRoot ).isDirectory() )\n            {\n                // Don't add the same sourceroots twice. No include/exclude\n            \t// patterns possible in maven for (test|script|)source directories.\n                if ( addedSourceRoots.containsKey( sourceRoot ) )\n                {\n                \tcontinue; \n                }\n\n                writer.startElement( \"classpathentry\" );\n\n                writer.addAttribute( \"kind\", \"src\" );\n\n                String eclipseSourceRoot = toRelative( projectBaseDir, sourceRoot );\n                \n                if (!projectBaseDir.equals(basedir))\n                {\n                    eclipseSourceRoot = eclipseSourceRoot.replaceAll( \"/\", \"-\" );\n                }\n                \n                addedSourceRoots.put( sourceRoot, eclipseSourceRoot );\n                \n                writer.addAttribute( \"path\", eclipseSourceRoot );\n\n                if ( output != null )\n                {\n                    writer.addAttribute( \"output\", toRelative( projectBaseDir, output ) );\n                }\n\n                writer.endElement();\n            }\n        }\n    }","commit_id":"a98961eeedc4cd03fc02694b9502939edbfe43b2","url":"https://github.com/apache/maven"},{"original_method":"protected boolean removeInternal(Data key, Data value) {\n        throwExceptionIfNull(key);\n        throwExceptionIfNull(value);\n        Collection<CollectionRecord> coll = txMap.get(key);\n        long timeout = tx.getTimeoutMillis();\n        long ttl = timeout*3/2;\n        if (coll == null){\n            CollectionResponse response = lockAndGet(key, timeout, ttl);\n            if (response == null){\n                throw new ConcurrentModificationException(\"Transaction couldn't obtain lock \" + getThreadId());\n            }\n            version = response.getTxVersion();\n            coll =  createCollection(response.getRecordCollection(getNodeEngine()));\n            txMap.put(key, coll);\n        }\n        CollectionRecord record = new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));\n        Iterator<CollectionRecord> iterator = coll.iterator();\n        long recordId = -1;\n        while (iterator.hasNext()){\n            CollectionRecord r = iterator.next();\n            if (r.equals(record)){\n                iterator.remove();\n                recordId = r.getRecordId();\n                break;\n            }\n        }\n        if (version != -1 || recordId != -1){\n            TxnRemoveOperation operation = new TxnRemoveOperation(proxyId, key, recordId, value);\n            MultiMapTransactionLog log = (MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));\n            if (log != null){\n                log.addOperation(operation);\n            }\n            else {\n                log = new MultiMapTransactionLog(key, proxyId, ttl, getThreadId(), version, operation);\n                tx.addTransactionLog(log);\n            }\n            return recordId != -1;\n        }\n        return false;\n    }","id":259,"modified_method":"protected boolean removeInternal(Data key, Data value) {\n        throwExceptionIfNull(key);\n        throwExceptionIfNull(value);\n        Collection<CollectionRecord> coll = txMap.get(key);\n        long timeout = tx.getTimeoutMillis();\n        long ttl = timeout*3/2;\n        final MultiMapTransactionLog log;\n        if (coll == null){\n            CollectionResponse response = lockAndGet(key, timeout, ttl);\n            if (response == null){\n                throw new ConcurrentModificationException(\"Transaction couldn't obtain lock \" + getThreadId());\n            }\n            log = new MultiMapTransactionLog(key, proxyId, ttl, getThreadId(), version);\n            tx.addTransactionLog(log);\n            version = response.getTxVersion();\n            coll =  createCollection(response.getRecordCollection(getNodeEngine()));\n            txMap.put(key, coll);\n        } else {\n            log = (MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));\n        }\n        CollectionRecord record = new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));\n        Iterator<CollectionRecord> iterator = coll.iterator();\n        long recordId = -1;\n        while (iterator.hasNext()){\n            CollectionRecord r = iterator.next();\n            if (r.equals(record)){\n                iterator.remove();\n                recordId = r.getRecordId();\n                break;\n            }\n        }\n        if (version != -1 || recordId != -1){\n            TxnRemoveOperation operation = new TxnRemoveOperation(proxyId, key, recordId, value);\n            log.addOperation(operation);\n            return recordId != -1;\n        }\n        return false;\n    }","commit_id":"f1e3931bd70fe430150bf4d17a31764bab6d0cd3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected Collection<CollectionRecord> removeAllInternal(Data key){\n        throwExceptionIfNull(key);\n        long timeout = tx.getTimeoutMillis();\n        long ttl = timeout*3/2;\n        Collection<CollectionRecord> coll = txMap.get(key);\n        if (coll == null){\n            CollectionResponse response = lockAndGet(key, timeout, ttl);\n            if (response == null){\n                throw new ConcurrentModificationException(\"Transaction couldn't obtain lock \" + getThreadId());\n            }\n            version = response.getTxVersion();\n            coll =  createCollection(response.getRecordCollection(getNodeEngine()));\n        }\n        txMap.put(key, createCollection());\n        TxnRemoveAllOperation operation = new TxnRemoveAllOperation(proxyId, key, coll);\n\n        MultiMapTransactionLog log = (MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));\n        if (log != null){\n            log.addOperation(operation);\n        }\n        else {\n            log = new MultiMapTransactionLog(key, proxyId, ttl, getThreadId(), version, operation);\n            tx.addTransactionLog(log);\n        }\n        return coll;\n    }","id":260,"modified_method":"protected Collection<CollectionRecord> removeAllInternal(Data key){\n        throwExceptionIfNull(key);\n        long timeout = tx.getTimeoutMillis();\n        long ttl = timeout*3/2;\n        Collection<CollectionRecord> coll = txMap.get(key);\n        final MultiMapTransactionLog log;\n        if (coll == null){\n            CollectionResponse response = lockAndGet(key, timeout, ttl);\n            if (response == null){\n                throw new ConcurrentModificationException(\"Transaction couldn't obtain lock \" + getThreadId());\n            }\n            log = new MultiMapTransactionLog(key, proxyId, ttl, getThreadId(), version);\n            version = response.getTxVersion();\n            coll =  createCollection(response.getRecordCollection(getNodeEngine()));\n        } else {\n            log = (MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));\n        }\n        txMap.put(key, createCollection());\n        TxnRemoveAllOperation operation = new TxnRemoveAllOperation(proxyId, key, coll);\n        log.addOperation(operation);\n        return coll;\n    }","commit_id":"f1e3931bd70fe430150bf4d17a31764bab6d0cd3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"protected boolean putInternal(Data key, Data value) {\n        throwExceptionIfNull(key);\n        throwExceptionIfNull(value);\n        Collection<CollectionRecord> coll = txMap.get(key);\n        long recordId = -1;\n        long timeout = tx.getTimeoutMillis();\n        long ttl = timeout*3/2;\n        if (coll == null){\n            CollectionResponse response = lockAndGet(key, timeout, ttl);\n            if (response == null){\n                throw new ConcurrentModificationException(\"Transaction couldn't obtain lock \" + getThreadId());\n            }\n            recordId = response.getNextRecordId();\n            version = response.getTxVersion();\n            coll =  createCollection(response.getRecordCollection(getNodeEngine()));\n            txMap.put(key, coll);\n        }\n        CollectionRecord record = new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));\n        if (coll.add(record)){\n            if (recordId == -1){\n                recordId = nextId(key);\n            }\n            record.setRecordId(recordId);\n            TxnPutOperation operation = new TxnPutOperation(proxyId, key, value, recordId);\n            MultiMapTransactionLog log = (MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));\n            if (log != null){\n                log.addOperation(operation);\n            }\n            else {\n                log = new MultiMapTransactionLog(key, proxyId, ttl, getThreadId(), version, operation);\n                tx.addTransactionLog(log);\n            }\n            return true;\n        }\n        return false;\n    }","id":261,"modified_method":"protected boolean putInternal(Data key, Data value) {\n        throwExceptionIfNull(key);\n        throwExceptionIfNull(value);\n        Collection<CollectionRecord> coll = txMap.get(key);\n        long recordId = -1;\n        long timeout = tx.getTimeoutMillis();\n        long ttl = timeout*3/2;\n        final MultiMapTransactionLog log;\n        if (coll == null){\n            CollectionResponse response = lockAndGet(key, timeout, ttl);\n            if (response == null){\n                throw new ConcurrentModificationException(\"Transaction couldn't obtain lock \" + getThreadId());\n            }\n            log = new MultiMapTransactionLog(key, proxyId, ttl, getThreadId(), version);\n            tx.addTransactionLog(log);\n            recordId = response.getNextRecordId();\n            version = response.getTxVersion();\n            coll =  createCollection(response.getRecordCollection(getNodeEngine()));\n            txMap.put(key, coll);\n        } else {\n            log = (MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));\n        }\n        CollectionRecord record = new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));\n        if (coll.add(record)){\n            if (recordId == -1){\n                recordId = nextId(key);\n            }\n            record.setRecordId(recordId);\n            TxnPutOperation operation = new TxnPutOperation(proxyId, key, value, recordId);\n            log.addOperation(operation);\n            return true;\n        }\n        return false;\n    }","commit_id":"f1e3931bd70fe430150bf4d17a31764bab6d0cd3","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n   * If @param isContextQuery, is true we return the list of unique available contexts at the next level,\n   * if its false, we would return the available unique metrics in a given context\n   * @param query\n   * @param isContextQuery\n   * @return\n   * @throws OperationException\n   */\n  private List<String> getAvailableContextAndMetrics(MetricsScanQuery query, boolean isContextQuery)\n    throws OperationException {\n    List<String> metricsScanResults = Lists.newArrayList();\n    int startTimeBase = getTimeBase(query.getStartTime());\n    int endTimeBase = getTimeBase(query.getEndTime());\n    byte[][] columns = null;\n    String tagPrefix = query.getTagPrefix();\n    if (tagPrefix == null) {\n      tagPrefix = MetricsConstants.EMPTY_TAG;\n    }\n\n    byte[] startRow = entityCodec.paddedEncode(query.getContextPrefix(), query.getMetricPrefix(), tagPrefix,\n                                        startTimeBase, query.getRunId(), 0);\n    byte[] endRow = entityCodec.paddedEncode(query.getContextPrefix(), query.getMetricPrefix(), tagPrefix,\n                                      endTimeBase + 1, query.getRunId(), 0xff);\n\n    Row rowResult;\n    // does multiple scan, but we skip duplicate row-keys by incrementing\n    // the sub-context or metrics part of rowkey before each scan.\n    do {\n      FuzzyRowFilter filter = getFilter(query, startTimeBase, endTimeBase + 1, false, FOUR_ONE_BYTES);\n\n      ScannerFields fields = new ScannerFields(startRow, endRow, columns, filter);\n      Scanner scanner = null;\n      try {\n        scanner = timeSeriesTable.scan(fields.startRow, fields.endRow, fields.columns, fields.filter);\n      } catch (Exception e) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, e.getMessage(), e);\n      }\n\n      rowResult = scanner.next();\n      if (rowResult != null) {\n        byte[] rowKey = rowResult.getRow();\n        // Decode context and metric from key\n        int offset = 0;\n        String contextStr = entityCodec.decode(MetricsEntityType.CONTEXT, rowKey, offset);\n\n        // Always have a \".\" suffix for unique matching\n        if (query.getContextPrefix() != null && !(contextStr + \".\").startsWith(query.getContextPrefix())) {\n          scanner.close();\n          break;\n        }\n\n        offset += entityCodec.getEncodedSize(MetricsEntityType.CONTEXT);\n        String metricName = entityCodec.decode(MetricsEntityType.METRIC, rowKey, offset);\n\n        if (isContextQuery) {\n          // update the rowkey, by incrementing the next-level context part\n          ByteBuffer contextPart = ByteBuffer.wrap(rowKey);\n          contextPart.limit(entityCodec.getEncodedSize(MetricsEntityType.CONTEXT));\n          contextPart = getNextContextTarget(contextPart, query.getContextPrefix());\n          if (contextPart == null) {\n            scanner.close();\n            break;\n          }\n          //update the start-row to be row-key for next scan\n          startRow = rowKey;\n          metricsScanResults.add(contextStr);\n        } else {\n          // update the rowkey, by incrementing the metrics part\n          ByteBuffer metricsPart = ByteBuffer.wrap(rowKey);\n          metricsPart.position(entityCodec.getEncodedSize(MetricsEntityType.CONTEXT));\n          metricsPart.limit(entityCodec.getEncodedSize(MetricsEntityType.CONTEXT) +\n                              entityCodec.getEncodedSize(MetricsEntityType.METRIC));\n          metricsPart = stopKeyForPrefix(metricsPart);\n          if (metricsPart == null) {\n            scanner.close();\n            break;\n          }\n          //update the start-row to be row-key for next scan\n          startRow = rowKey;\n          metricsScanResults.add(metricName);\n        }\n      }\n      // no more matching rows found\n      scanner.close();\n    } while (rowResult != null);\n\n    return metricsScanResults;\n  }","id":262,"modified_method":"/**\n   * If @param isContextQuery, is true we return the list of unique available contexts at the next level,\n   * if its false, we would return the available unique metrics in a given context\n   * @param query\n   * @param isContextQuery\n   * @return\n   * @throws OperationException\n   */\n  private List<String> getAvailableContextAndMetrics(MetricsScanQuery query, boolean isContextQuery)\n    throws OperationException {\n    List<String> metricsScanResults = Lists.newArrayList();\n    int startTimeBase = getTimeBase(query.getStartTime());\n    int endTimeBase = getTimeBase(query.getEndTime());\n    byte[][] columns = null;\n    String tagPrefix = query.getTagPrefix();\n    int contextOffset = 0 , contextLength = 0;\n    int metricsOffset = 0, metricsLength = 0;\n    if (tagPrefix == null) {\n      tagPrefix = MetricsConstants.EMPTY_TAG;\n    }\n\n    if (isContextQuery) {\n      // initialize context-offset and length-of-context to obtain all available context's after\n      // the given context-prefix.\n      String contextPrefix = query.getContextPrefix();\n      int entityParts = contextPrefix == null ? 0 : entityCodec.getEntityPartsLength(contextPrefix);\n      int idSize = entityCodec.getIdSize();\n      contextOffset = idSize * entityParts;\n      contextLength = idSize;\n    } else {\n      // initialize metrics-offset and length of metrics entity type to obtain\n      // all available metrics in the given context\n      metricsOffset = entityCodec.getEncodedSize(MetricsEntityType.CONTEXT);\n      metricsLength = entityCodec.getEncodedSize(MetricsEntityType.METRIC);\n    }\n\n    byte[] startRow = entityCodec.paddedEncode(query.getContextPrefix(), query.getMetricPrefix(), tagPrefix,\n                                        startTimeBase, query.getRunId(), 0);\n    byte[] endRow = entityCodec.paddedEncode(query.getContextPrefix(), query.getMetricPrefix(), tagPrefix,\n                                      endTimeBase, query.getRunId(), 0xff);\n\n    Row rowResult;\n\n    // multiple scans with incrementing the scans startRow row-key to get the next unique part of a context or\n    // next unique metric based on the parameter isContextQuery.\n    // by this way, we can skip multiple rows of duplicate rows and scan for the next\n    // unique context/metric part we are interested in.\n    // we stop when we cannot find any rows which matches the given contextPrefix or if there are no rows\n    // returned from the scan.\n    do {\n      FuzzyRowFilter filter = getFilter(query, -1, -1, false);\n      ScannerFields fields = new ScannerFields(startRow, endRow, columns, filter);\n      Scanner scanner = null;\n      try {\n        scanner = timeSeriesTable.scan(fields.startRow, fields.endRow, fields.columns, fields.filter);\n      } catch (Exception e) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, e.getMessage(), e);\n      }\n\n      rowResult = scanner.next();\n      if (rowResult != null) {\n        byte[] rowKey = rowResult.getRow();\n        int offset = 0;\n        String contextStr = entityCodec.decode(MetricsEntityType.CONTEXT, rowKey, offset);\n\n        if (query.getContextPrefix() != null && !contextStr.startsWith(query.getContextPrefix())) {\n          // if retrieved rowkey's contextPrefix does not match with the contextPrefix in query,\n          // we stop scanning and return\n          scanner.close();\n          break;\n        }\n\n        offset += entityCodec.getEncodedSize(MetricsEntityType.CONTEXT);\n\n        if (isContextQuery) {\n          metricsScanResults.add(contextStr);\n          // With the next scan we fast-forward to the next row that has different context name\n          // that we are searching for.\n          startRow = getNextRow(rowKey, contextOffset, contextLength);\n          if (startRow == null) {\n            //reached max possible key for the context, we will stop scanning now and return.\n            scanner.close();\n            break;\n          }\n        } else {\n          String metricName = entityCodec.decode(MetricsEntityType.METRIC, rowKey, offset);\n          metricsScanResults.add(metricName);\n          // With the next scan we fast-forward to the next row that has different metric name part\n          // that we are searching for.\n          startRow = getNextRow(rowKey, metricsOffset, metricsLength);\n          if (startRow == null) {\n            //reached max possible metrics key for the given context, we will stop scanning now and return.\n            scanner.close();\n            break;\n          }\n        }\n      }\n      // no more matching rows found\n      scanner.close();\n    } while (rowResult != null);\n\n    return metricsScanResults;\n  }","commit_id":"c7cfd070c6619d9537be16327373799b7e8196be","url":"https://github.com/caskdata/cdap"},{"original_method":"private List<String> getAvailableContextAndMetrics(MetricsScanQuery query, boolean isContextQuery)\n    throws OperationException {\n    List<String> metricsScanResults = Lists.newArrayList();\n    int startTimeBase = getTimeBase(query.getStartTime());\n    int endTimeBase = getTimeBase(query.getEndTime());\n\n    byte[] contextStart = null, contextEnd = null, metricsPrefix = null;\n    byte[] startRow = null, endRow = null;\n    byte[][] columns = null;\n    String tagPrefix = query.getTagPrefix();\n    if (tagPrefix == null) {\n      tagPrefix = MetricsConstants.EMPTY_TAG;\n    }\n    if (isContextQuery) {\n      contextStart = entityCodec.paddedEncode(MetricsEntityType.CONTEXT, query.getContextPrefix(), 0);\n      contextEnd = entityCodec.paddedEncode(MetricsEntityType.CONTEXT, query.getContextPrefix(), 0xff);\n    } else {\n      metricsPrefix = entityCodec.paddedEncode(MetricsEntityType.METRIC, query.getMetricPrefix(), 0);\n    }\n\n    Row rowResult;\n    do {\n      if (isContextQuery) {\n        startRow = getNextPaddedKey(contextStart, query.getRunId(),\n                                    query.getMetricPrefix(), tagPrefix, startTimeBase, 0);\n        endRow = getNextPaddedKey(contextEnd, query.getRunId(),\n                                  query.getMetricPrefix(), tagPrefix, endTimeBase + 1, 0xff);\n      } else {\n        startRow = getNextPaddedKey(query.getContextPrefix(), query.getRunId(),\n                                    metricsPrefix, tagPrefix, startTimeBase, 0);\n        endRow = getNextPaddedKey(query.getContextPrefix(), query.getRunId(),\n                                  metricsPrefix, tagPrefix, endTimeBase + 1, 0xff);\n      }\n\n      FuzzyRowFilter filter = getFilter(query, startTimeBase, endTimeBase + 1, false, FOUR_ONE_BYTES);\n\n      ScannerFields fields = new ScannerFields(startRow, endRow, columns, filter);\n      Scanner scanner = null;\n      try {\n        scanner = timeSeriesTable.scan(fields.startRow, fields.endRow, fields.columns, fields.filter);\n      } catch (Exception e) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, e.getMessage(), e);\n      }\n\n      rowResult = scanner.next();\n      if (rowResult != null) {\n        byte[] rowKey = rowResult.getRow();\n        // Decode context and metric from key\n        int offset = 0;\n        String contextStr = entityCodec.decode(MetricsEntityType.CONTEXT, rowKey, offset);\n\n        // Always have a \".\" suffix for unique matching\n        if (query.getContextPrefix() != null && !(contextStr + \".\").startsWith(query.getContextPrefix())) {\n          scanner.close();\n          break;\n        }\n\n        offset += entityCodec.getEncodedSize(MetricsEntityType.CONTEXT);\n        String metricName = entityCodec.decode(MetricsEntityType.METRIC, rowKey, offset);\n\n        if (isContextQuery) {\n          contextStart = getNextContextTarget(contextStart, query.getContextPrefix());\n          metricsScanResults.add(contextStr);\n        } else {\n          metricsPrefix = getNextMetricsTarget(\n            Arrays.copyOfRange(rowKey, entityCodec.getEncodedSize(MetricsEntityType.CONTEXT),\n                               entityCodec.getEncodedSize(MetricsEntityType.CONTEXT) +\n                                 entityCodec.getEncodedSize(MetricsEntityType.METRIC)));\n          metricsScanResults.add(metricName);\n        }\n      }\n      scanner.close();\n    } while (rowResult != null);\n\n    return metricsScanResults;\n  }","id":263,"modified_method":"/**\n   * If @param isContextQuery, is true we return the list of unique available contexts at the next level,\n   * if its false, we would return the available unique metrics in a given context\n   * @param query\n   * @param isContextQuery\n   * @return\n   * @throws OperationException\n   */\n  private List<String> getAvailableContextAndMetrics(MetricsScanQuery query, boolean isContextQuery)\n    throws OperationException {\n    List<String> metricsScanResults = Lists.newArrayList();\n    int startTimeBase = getTimeBase(query.getStartTime());\n    int endTimeBase = getTimeBase(query.getEndTime());\n    byte[][] columns = null;\n    String tagPrefix = query.getTagPrefix();\n    if (tagPrefix == null) {\n      tagPrefix = MetricsConstants.EMPTY_TAG;\n    }\n\n    byte[] startRow = entityCodec.paddedEncode(query.getContextPrefix(), query.getMetricPrefix(), tagPrefix,\n                                        startTimeBase, query.getRunId(), 0);\n    byte[] endRow = entityCodec.paddedEncode(query.getContextPrefix(), query.getMetricPrefix(), tagPrefix,\n                                      endTimeBase + 1, query.getRunId(), 0xff);\n\n    Row rowResult;\n    // does multiple scan, but we skip duplicate row-keys by incrementing\n    // the sub-context or metrics part of rowkey before each scan.\n    do {\n      FuzzyRowFilter filter = getFilter(query, startTimeBase, endTimeBase + 1, false, FOUR_ONE_BYTES);\n\n      ScannerFields fields = new ScannerFields(startRow, endRow, columns, filter);\n      Scanner scanner = null;\n      try {\n        scanner = timeSeriesTable.scan(fields.startRow, fields.endRow, fields.columns, fields.filter);\n      } catch (Exception e) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, e.getMessage(), e);\n      }\n\n      rowResult = scanner.next();\n      if (rowResult != null) {\n        byte[] rowKey = rowResult.getRow();\n        // Decode context and metric from key\n        int offset = 0;\n        String contextStr = entityCodec.decode(MetricsEntityType.CONTEXT, rowKey, offset);\n\n        // Always have a \".\" suffix for unique matching\n        if (query.getContextPrefix() != null && !(contextStr + \".\").startsWith(query.getContextPrefix())) {\n          scanner.close();\n          break;\n        }\n\n        offset += entityCodec.getEncodedSize(MetricsEntityType.CONTEXT);\n        String metricName = entityCodec.decode(MetricsEntityType.METRIC, rowKey, offset);\n\n        if (isContextQuery) {\n          // update the rowkey, by incrementing the next-level context part\n          ByteBuffer contextPart = ByteBuffer.wrap(rowKey);\n          contextPart.limit(entityCodec.getEncodedSize(MetricsEntityType.CONTEXT));\n          contextPart = getNextContextTarget(contextPart, query.getContextPrefix());\n          if (contextPart == null) {\n            scanner.close();\n            break;\n          }\n          //update the start-row to be row-key for next scan\n          startRow = rowKey;\n          metricsScanResults.add(contextStr);\n        } else {\n          // update the rowkey, by incrementing the metrics part\n          ByteBuffer metricsPart = ByteBuffer.wrap(rowKey);\n          metricsPart.position(entityCodec.getEncodedSize(MetricsEntityType.CONTEXT));\n          metricsPart.limit(entityCodec.getEncodedSize(MetricsEntityType.CONTEXT) +\n                              entityCodec.getEncodedSize(MetricsEntityType.METRIC));\n          metricsPart = stopKeyForPrefix(metricsPart);\n          if (metricsPart == null) {\n            scanner.close();\n            break;\n          }\n          //update the start-row to be row-key for next scan\n          startRow = rowKey;\n          metricsScanResults.add(metricName);\n        }\n      }\n      // no more matching rows found\n      scanner.close();\n    } while (rowResult != null);\n\n    return metricsScanResults;\n  }","commit_id":"b7a85cc6d212980a0739587aa27e486e5f08c4f1","url":"https://github.com/caskdata/cdap"},{"original_method":"/** Flush the buffers iteratively until no progress is made\n     * @param buffers The buffers to flush\n     * @return The unflushed buffers, or null if all flushed\n     * @throws IOException\n     */\n    protected ByteBuffer[] flush(ByteBuffer[] buffers) throws IOException\n    {\n        boolean progress=true;\n        while(progress && buffers!=null)\n        {\n            int before=buffers[0].remaining();\n            \n            if (_endPoint.flush(buffers))\n                return null;\n            int r=buffers[0].remaining();\n            progress=before!=r;\n            \n            int not_empty=0;\n            while(r==0)\n            {\n                if (++not_empty==buffers.length)\n                {\n                    buffers=null;\n                    not_empty=0;\n                    break;\n                }\n                r=buffers[not_empty].remaining();\n            }\n\n            if (not_empty>0)\n                buffers=Arrays.copyOfRange(buffers,not_empty,buffers.length);\n        }        \n        \n        // If buffers is null, then flush has returned false but has consumed all the data!\n        // This is probably SSL being unable to flush the encrypted buffer, so return EMPTY_BUFFERS\n        // and that will keep this WriteFlusher pending.\n        return buffers==null?EMPTY_BUFFERS:buffers;\n    }","id":264,"modified_method":"/** Flush the buffers iteratively until no progress is made\n     * @param buffers The buffers to flush\n     * @return The unflushed buffers, or null if all flushed\n     * @throws IOException\n     */\n    protected ByteBuffer[] flush(ByteBuffer[] buffers) throws IOException\n    {\n        boolean progress=true;\n        while(progress && buffers!=null)\n        {\n            int before=buffers.length==0?0:buffers[0].remaining();\n            boolean flushed=_endPoint.flush(buffers);\n            int r=buffers.length==0?0:buffers[0].remaining();\n            \n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Flushed={} {}/{}+{} {}\",flushed,before-r,before,buffers.length-1,this);\n            \n            if (flushed)\n                return null;\n            \n            progress=before!=r;\n            \n            int not_empty=0;\n            while(r==0)\n            {\n                if (++not_empty==buffers.length)\n                {\n                    buffers=null;\n                    not_empty=0;\n                    break;\n                }\n                progress=true;\n                r=buffers[not_empty].remaining();\n            }\n\n            if (not_empty>0)\n                buffers=Arrays.copyOfRange(buffers,not_empty,buffers.length);\n        }        \n\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"!fully flushed {}\",this);\n        \n        // If buffers is null, then flush has returned false but has consumed all the data!\n        // This is probably SSL being unable to flush the encrypted buffer, so return EMPTY_BUFFERS\n        // and that will keep this WriteFlusher pending.\n        return buffers==null?EMPTY_BUFFERS:buffers;\n    }","commit_id":"30776f9662eb943f8c7aab26bfc54e28dd2c2213","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/** Flush the buffers iteratively until no progress is made\n     * @param buffers The buffers to flush\n     * @return The unflushed buffers, or null if all flushed\n     * @throws IOException\n     */\n    protected ByteBuffer[] flush(ByteBuffer[] buffers) throws IOException\n    {\n        boolean progress=true;\n        while(progress && buffers!=null)\n        {\n            int before=buffers[0].remaining();\n            \n            if (_endPoint.flush(buffers))\n                return null;\n            int r=buffers[0].remaining();\n            progress=before!=r;\n            \n            int not_empty=0;\n            while(r==0)\n            {\n                if (++not_empty==buffers.length)\n                {\n                    buffers=null;\n                    not_empty=0;\n                    break;\n                }\n                r=buffers[not_empty].remaining();\n            }\n\n            if (not_empty>0)\n                buffers=Arrays.copyOfRange(buffers,not_empty,buffers.length);\n        }        \n        \n        // If buffers is null, then flush has returned false but has consumed all the data!\n        // This is probably SSL being unable to flush the encrypted buffer, so return EMPTY_BUFFERS\n        // and that will keep this WriteFlusher pending.\n        return buffers==null?EMPTY_BUFFERS:buffers;\n    }","id":265,"modified_method":"/** Flush the buffers iteratively until no progress is made\n     * @param buffers The buffers to flush\n     * @return The unflushed buffers, or null if all flushed\n     * @throws IOException\n     */\n    protected ByteBuffer[] flush(ByteBuffer[] buffers) throws IOException\n    {\n        boolean progress=true;\n        while(progress && buffers!=null)\n        {\n            int before=buffers.length==0?0:buffers[0].remaining();\n            boolean flushed=_endPoint.flush(buffers);\n            int r=buffers.length==0?0:buffers[0].remaining();\n            \n            if (flushed)\n                return null;\n            \n            progress=before!=r;\n            \n            int not_empty=0;\n            while(r==0)\n            {\n                if (++not_empty==buffers.length)\n                {\n                    buffers=null;\n                    not_empty=0;\n                    break;\n                }\n                progress=true;\n                r=buffers[not_empty].remaining();\n            }\n\n            if (not_empty>0)\n                buffers=Arrays.copyOfRange(buffers,not_empty,buffers.length);\n        }        \n        \n        // If buffers is null, then flush has returned false but has consumed all the data!\n        // This is probably SSL being unable to flush the encrypted buffer, so return EMPTY_BUFFERS\n        // and that will keep this WriteFlusher pending.\n        return buffers==null?EMPTY_BUFFERS:buffers;\n    }","commit_id":"981e27b38361987c8af5673dfcb9dd6bf38c6cd1","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void doInvoke(final PsiClass aClass, final String superClassName) throws IncorrectOperationException {\n    PsiJavaCodeReferenceElement ref = getRefElement();\n    assert ref != null;\n    String refName = ref.getReferenceName();\n    LOG.assertTrue(refName != null);\n    PsiElementFactory elementFactory = JavaPsiFacade.getInstance(aClass.getProject()).getElementFactory();\n    PsiClass created = myKind == INTERFACE\n                      ? elementFactory.createInterface(refName)\n                      : myKind == CLASS ? elementFactory.createClass(refName) : elementFactory.createEnum(refName);\n    final PsiModifierList modifierList = created.getModifierList();\n    LOG.assertTrue(modifierList != null);\n    modifierList.setModifierProperty(PsiModifier.PRIVATE, true);\n    if (superClassName != null) {\n      PsiJavaCodeReferenceElement superClass =\n        elementFactory.createReferenceElementByFQClassName(superClassName, created.getResolveScope());\n      final PsiReferenceList extendsList = created.getExtendsList();\n      LOG.assertTrue(extendsList != null);\n      extendsList.add(superClass);\n    }\n    CreateClassFromNewFix.setupGenericParameters(created, ref);\n\n    created = (PsiClass)aClass.add(created);\n    ref.bindToElement(created);\n  }","id":266,"modified_method":"private void doInvoke(final PsiClass aClass, final String superClassName) throws IncorrectOperationException {\n    PsiJavaCodeReferenceElement ref = getRefElement();\n    assert ref != null;\n    String refName = ref.getReferenceName();\n    LOG.assertTrue(refName != null);\n    PsiElementFactory elementFactory = JavaPsiFacade.getInstance(aClass.getProject()).getElementFactory();\n    PsiClass created = myKind == INTERFACE\n                      ? elementFactory.createInterface(refName)\n                      : myKind == CLASS ? elementFactory.createClass(refName) : elementFactory.createEnum(refName);\n    final PsiModifierList modifierList = created.getModifierList();\n    LOG.assertTrue(modifierList != null);\n    if (aClass.isInterface()) {\n      modifierList.setModifierProperty(PsiModifier.PACKAGE_LOCAL, true);\n    } else {\n      modifierList.setModifierProperty(PsiModifier.PRIVATE, true);\n    }\n    if (superClassName != null) {\n      PsiJavaCodeReferenceElement superClass =\n        elementFactory.createReferenceElementByFQClassName(superClassName, created.getResolveScope());\n      final PsiReferenceList extendsList = created.getExtendsList();\n      LOG.assertTrue(extendsList != null);\n      extendsList.add(superClass);\n    }\n    CreateClassFromNewFix.setupGenericParameters(created, ref);\n\n    created = (PsiClass)aClass.add(created);\n    ref.bindToElement(created);\n  }","commit_id":"ea622c99f36004e19d45e07ce40aecf3e1c330c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void performRefactoring(UsageInfo[] usages) {\n    if (!prepareWritable(usages)) return;\n    final List<PsiElement> importStatements = new ArrayList<PsiElement>();\n    if (!CodeStyleSettingsManager.getSettings(myProject).INSERT_INNER_CLASS_IMPORTS) {\n      usages = filterUsagesInImportStatements(usages, importStatements);\n    } else {\n      //rebind imports first\n      Arrays.sort(usages, new Comparator<UsageInfo>() {\n        public int compare(UsageInfo o1, UsageInfo o2) {\n          return PsiUtil.BY_POSITION.compare(o1.getElement(), o2.getElement());\n        }\n      });\n    }\n    saveNonCodeUsages(usages);\n    final Map<PsiElement, PsiElement> oldToNewElementsMapping = new HashMap<PsiElement, PsiElement>();\n    try {\n      for (PsiClass classToMove : myClassesToMove) {\n        ChangeContextUtil.encodeContextInfo(classToMove, true);\n        PsiClass newClass = (PsiClass)myTargetClass.addBefore(classToMove, myTargetClass.getRBrace());\n        PsiUtil.setModifierProperty(newClass, PsiModifier.STATIC, true);\n        newClass = (PsiClass)ChangeContextUtil.decodeContextInfo(newClass, null, null);\n        oldToNewElementsMapping.put(classToMove, newClass);\n      }\n\n      myNonCodeUsages = MoveClassesOrPackagesProcessor.retargetUsages(usages, oldToNewElementsMapping);\n      retargetNonCodeUsages(oldToNewElementsMapping);\n\n      retargetClassRefsInMoved(oldToNewElementsMapping);\n\n      JavaCodeStyleManager.getInstance(myProject).removeRedundantImports((PsiJavaFile)myTargetClass.getContainingFile());\n      for (PsiClass classToMove : myClassesToMove) {\n        classToMove.delete();\n      }\n\n      for (PsiElement element: importStatements) {\n        if (element.isValid()) {\n          element.delete();\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":267,"modified_method":"protected void performRefactoring(UsageInfo[] usages) {\n    if (!prepareWritable(usages)) return;\n    final List<PsiElement> importStatements = new ArrayList<PsiElement>();\n    if (!CodeStyleSettingsManager.getSettings(myProject).INSERT_INNER_CLASS_IMPORTS) {\n      usages = filterUsagesInImportStatements(usages, importStatements);\n    } else {\n      //rebind imports first\n      Arrays.sort(usages, new Comparator<UsageInfo>() {\n        public int compare(UsageInfo o1, UsageInfo o2) {\n          return PsiUtil.BY_POSITION.compare(o1.getElement(), o2.getElement());\n        }\n      });\n    }\n    saveNonCodeUsages(usages);\n    final Map<PsiElement, PsiElement> oldToNewElementsMapping = new HashMap<PsiElement, PsiElement>();\n    try {\n      for (PsiClass classToMove : myClassesToMove) {\n        ChangeContextUtil.encodeContextInfo(classToMove, true);\n        PsiClass newClass = (PsiClass)myTargetClass.addBefore(classToMove, myTargetClass.getRBrace());\n        if (myTargetClass.isInterface()) {\n          PsiUtil.setModifierProperty(newClass, PsiModifier.PACKAGE_LOCAL, true);\n        }\n        else {\n          PsiUtil.setModifierProperty(newClass, PsiModifier.STATIC, true);\n        }\n        newClass = (PsiClass)ChangeContextUtil.decodeContextInfo(newClass, null, null);\n        oldToNewElementsMapping.put(classToMove, newClass);\n      }\n\n      myNonCodeUsages = MoveClassesOrPackagesProcessor.retargetUsages(usages, oldToNewElementsMapping);\n      retargetNonCodeUsages(oldToNewElementsMapping);\n\n      retargetClassRefsInMoved(oldToNewElementsMapping);\n\n      JavaCodeStyleManager.getInstance(myProject).removeRedundantImports((PsiJavaFile)myTargetClass.getContainingFile());\n      for (PsiClass classToMove : myClassesToMove) {\n        classToMove.delete();\n      }\n\n      for (PsiElement element: importStatements) {\n        if (element.isValid()) {\n          element.delete();\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"b0a382dbfa4bf282dca24797eaeb62eeb7afbcc9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void invokeImpl(final PsiClass targetClass) {\n    PsiNewExpression newExpression = getNewExpression();\n    PsiJavaCodeReferenceElement ref = newExpression.getClassOrAnonymousClassReference();\n    assert ref != null;\n    String refName = ref.getReferenceName();\n    LOG.assertTrue(refName != null);\n    PsiElementFactory elementFactory = JavaPsiFacade.getInstance(newExpression.getProject()).getElementFactory();\n    PsiClass created = elementFactory.createClass(refName);\n    final PsiModifierList modifierList = created.getModifierList();\n    LOG.assertTrue(modifierList != null);\n    modifierList.setModifierProperty(PsiModifier.PRIVATE, true);\n    if (PsiUtil.getEnclosingStaticElement(newExpression, targetClass) != null || isInThisOrSuperCall(newExpression)) {\n      modifierList.setModifierProperty(PsiModifier.STATIC, true);\n    }\n    created = (PsiClass)targetClass.add(created);\n\n    setupClassFromNewExpression(created, newExpression);\n\n    setupGenericParameters(created, ref);\n  }","id":268,"modified_method":"@Override\n  protected void invokeImpl(final PsiClass targetClass) {\n    PsiNewExpression newExpression = getNewExpression();\n    PsiJavaCodeReferenceElement ref = newExpression.getClassOrAnonymousClassReference();\n    assert ref != null;\n    String refName = ref.getReferenceName();\n    LOG.assertTrue(refName != null);\n    PsiElementFactory elementFactory = JavaPsiFacade.getInstance(newExpression.getProject()).getElementFactory();\n    PsiClass created = elementFactory.createClass(refName);\n    final PsiModifierList modifierList = created.getModifierList();\n    LOG.assertTrue(modifierList != null);\n    if (targetClass.isInterface()) {\n      modifierList.setModifierProperty(PsiModifier.PACKAGE_LOCAL, true);\n    } else {\n      modifierList.setModifierProperty(PsiModifier.PRIVATE, true);\n    }\n    if (PsiUtil.getEnclosingStaticElement(newExpression, targetClass) != null || isInThisOrSuperCall(newExpression)) {\n      modifierList.setModifierProperty(PsiModifier.STATIC, true);\n    }\n    created = (PsiClass)targetClass.add(created);\n\n    setupClassFromNewExpression(created, newExpression);\n\n    setupGenericParameters(created, ref);\n  }","commit_id":"3d7a8fb300d5bdc15359fb3f8c19701de34a8de0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LogMatcher warn( String format, Object... arguments )\n        {\n            return new LogMatcher( contextMatcher, WARN_LEVEL_MATCHER, equalTo( format ), arrayContaining( ensureMatchers( arguments ) ), NULL_THROWABLE_MATCHER );\n        }","id":269,"modified_method":"public LogMatcher warn( String format, Object... arguments )\n        {\n            return warn( equalTo( format ), arguments );\n        }","commit_id":"db2e4f8282734c66f30c91e7a16fe52e5c134a88","url":"https://github.com/neo4j/neo4j"},{"original_method":"public LogMatcher debug( String format, Object... arguments )\n        {\n            return new LogMatcher( contextMatcher, DEBUG_LEVEL_MATCHER, equalTo( format ), arrayContaining( ensureMatchers( arguments ) ), NULL_THROWABLE_MATCHER );\n        }","id":270,"modified_method":"public LogMatcher debug( String format, Object... arguments )\n        {\n            return debug( equalTo( format ), arguments );\n        }","commit_id":"db2e4f8282734c66f30c91e7a16fe52e5c134a88","url":"https://github.com/neo4j/neo4j"},{"original_method":"public LogMatcher info( String format, Object... arguments )\n        {\n            return new LogMatcher( contextMatcher, INFO_LEVEL_MATCHER, equalTo( format ), arrayContaining( ensureMatchers( arguments ) ), NULL_THROWABLE_MATCHER );\n        }","id":271,"modified_method":"public LogMatcher info( String format, Object... arguments )\n        {\n            return info( equalTo( format ), arguments );\n        }","commit_id":"db2e4f8282734c66f30c91e7a16fe52e5c134a88","url":"https://github.com/neo4j/neo4j"},{"original_method":"public LogMatcher error( String format, Object... arguments )\n        {\n            return new LogMatcher( contextMatcher, ERROR_LEVEL_MATCHER, equalTo( format ), arrayContaining( ensureMatchers( arguments ) ), NULL_THROWABLE_MATCHER );\n        }","id":272,"modified_method":"public LogMatcher error( String format, Object... arguments )\n        {\n            return error( equalTo( format ), arguments );\n        }","commit_id":"db2e4f8282734c66f30c91e7a16fe52e5c134a88","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void registerTransformers_1_3_0(SubsystemRegistration subsystemRegistration) {\n        // earlier versions of the model didn't have the export-elytron-realm attribute, but the subsystem behavior is\n        // fully compatible if this attribute is left undefined or if its set to false.\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder().setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(false)),\n                SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .end();\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 3, 0));\n\n    }","id":273,"modified_method":"private void registerTransformers_1_3_0(SubsystemRegistration subsystemRegistration) {\n        // earlier versions of the model didn't have the export-elytron-realm attribute, but the subsystem behavior is\n        // fully compatible if this attribute is left undefined or if its set to false.\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .end();\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 3, 0));\n\n    }","commit_id":"893bac43ed5ffb83c36cd2b02bcbff2213484ea9","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder.getAttributeBuilder().addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecuritySubsystemRootResourceDefinition.DEEP_COPY_SUBJECT_MODE);\n        final ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder().setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(false)),\n                            SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecurityDomainResourceDefinition.CACHE_TYPE)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .end();\n\n        final ModulesToAttributeTransformer authClassicLoginModule = new ModulesToAttributeTransformer(Constants.LOGIN_MODULE, Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, authClassicLoginModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer policyModule = new ModulesToAttributeTransformer(Constants.POLICY_MODULE, Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer mappingModule = new ModulesToAttributeTransformer(Constants.MAPPING_MODULE, Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.TYPE, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer providerModule = new ModulesToAttributeTransformer(Constants.PROVIDER_MODULE, Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer identityTrustModule = new ModulesToAttributeTransformer(Constants.TRUST_MODULE, Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer aclModule = new ModulesToAttributeTransformer(Constants.ACL_MODULE, Constants.ACL_MODULES);\n        registerModuleTransformer(securityDomain, ACL_PATH, aclModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer authModule = new JaspiModulesToAttributeTransformer(Constants.AUTH_MODULE, Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .addRejectIfDefined(Constants.MODULE)\n                .build());\n\n        final ModulesToAttributeTransformer authLoginModule = new JaspiModulesToAttributeTransformer(Constants.LOGIN_MODULE, Constants.LOGIN_MODULES);\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, authLoginModule, null);\n\n        //reject expressions\n        builder.addChildResource(VAULT_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, VaultResourceDefinition.OPTIONS)\n                .end();\n        securityDomain.addChildResource(JSSE_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, JSSEResourceDefinition.ADDITIONAL_PROPERTIES)\n                .end();\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));\n    }","id":274,"modified_method":"private void registerTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder.getAttributeBuilder().addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecuritySubsystemRootResourceDefinition.DEEP_COPY_SUBJECT_MODE);\n        final ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, SecurityDomainResourceDefinition.CACHE_TYPE)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .end();\n\n        final ModulesToAttributeTransformer authClassicLoginModule = new ModulesToAttributeTransformer(Constants.LOGIN_MODULE, Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, authClassicLoginModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer policyModule = new ModulesToAttributeTransformer(Constants.POLICY_MODULE, Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer mappingModule = new ModulesToAttributeTransformer(Constants.MAPPING_MODULE, Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.TYPE, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer providerModule = new ModulesToAttributeTransformer(Constants.PROVIDER_MODULE, Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer identityTrustModule = new ModulesToAttributeTransformer(Constants.TRUST_MODULE, Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer aclModule = new ModulesToAttributeTransformer(Constants.ACL_MODULE, Constants.ACL_MODULES);\n        registerModuleTransformer(securityDomain, ACL_PATH, aclModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .build());\n\n        final ModulesToAttributeTransformer authModule = new JaspiModulesToAttributeTransformer(Constants.AUTH_MODULE, Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule,\n                ChildResourceTransformersRegistrar.createBuilder()\n                .addRejectExpressions(Constants.FLAG, Constants.MODULE_OPTIONS)\n                .addRejectIfDefined(Constants.MODULE)\n                .build());\n\n        final ModulesToAttributeTransformer authLoginModule = new JaspiModulesToAttributeTransformer(Constants.LOGIN_MODULE, Constants.LOGIN_MODULES);\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, authLoginModule, null);\n\n        //reject expressions\n        builder.addChildResource(VAULT_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, VaultResourceDefinition.OPTIONS)\n                .end();\n        securityDomain.addChildResource(JSSE_PATH).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, JSSEResourceDefinition.ADDITIONAL_PROPERTIES)\n                .end();\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));\n    }","commit_id":"893bac43ed5ffb83c36cd2b02bcbff2213484ea9","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_2_0(SubsystemRegistration subsystemRegistration) {\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder().setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, true, new ModelNode(false)),\n                SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .addRejectCheck(RejectAttributeChecker.DEFINED, SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .end();\n\n        // Transform any add op that includes the module list attribute into a compsosite of an add w/o that + write-attribute\n        AttributeToModulesTransformer loginModule = new AttributeToModulesTransformer(Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, loginModule);\n        AttributeToModulesTransformer policyModule = new AttributeToModulesTransformer(Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule);\n        AttributeToModulesTransformer mappingModule = new AttributeToModulesTransformer(Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule);\n        AttributeToModulesTransformer providerModule = new AttributeToModulesTransformer(Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule);\n        final AttributeToModulesTransformer identityTrustModule = new AttributeToModulesTransformer(Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule);\n        final AttributeToModulesTransformer aclModule = new AttributeToModulesTransformer(Constants.ACL_MODULES);\n        ResourceTransformationDescriptionBuilder aclBuilder = registerModuleTransformer(securityDomain, ACL_PATH, aclModule);\n        //https://issues.jboss.org/browse/WFLY-2474 acl-module was wrongly called login-module in 7.2.0\n        aclBuilder.addChildRedirection(PathElement.pathElement(Constants.ACL_MODULE), PathElement.pathElement(Constants.LOGIN_MODULE));\n\n        AttributeToModulesTransformer authModule = new AttributeToModulesTransformer(Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule);\n\n        // the module attribute is not recognized in the 1.2.0 version of the subsystem.\n        jaspiReg.addChildResource(PathElement.pathElement(Constants.AUTH_MODULE)).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, Constants.MODULE)\n                .end();\n\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, loginModule);\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 2, 0));\n    }","id":275,"modified_method":"private void registerTransformers_1_2_0(SubsystemRegistration subsystemRegistration) {\n        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        ResourceTransformationDescriptionBuilder securityDomain = builder.addChildResource(SECURITY_DOMAIN_PATH);\n        securityDomain.getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, SecurityDomainResourceDefinition.EXPORT_ELYTRON_REALM)\n                .end();\n\n        // Transform any add op that includes the module list attribute into a compsosite of an add w/o that + write-attribute\n        AttributeToModulesTransformer loginModule = new AttributeToModulesTransformer(Constants.LOGIN_MODULES);\n        registerModuleTransformer(securityDomain, PATH_CLASSIC_AUTHENTICATION, loginModule);\n        AttributeToModulesTransformer policyModule = new AttributeToModulesTransformer(Constants.POLICY_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUTHORIZATION_CLASSIC, policyModule);\n        AttributeToModulesTransformer mappingModule = new AttributeToModulesTransformer(Constants.MAPPING_MODULES);\n        registerModuleTransformer(securityDomain, PATH_MAPPING_CLASSIC, mappingModule);\n        AttributeToModulesTransformer providerModule = new AttributeToModulesTransformer(Constants.PROVIDER_MODULES);\n        registerModuleTransformer(securityDomain, PATH_AUDIT_CLASSIC, providerModule);\n        final AttributeToModulesTransformer identityTrustModule = new AttributeToModulesTransformer(Constants.TRUST_MODULES);\n        registerModuleTransformer(securityDomain, PATH_IDENTITY_TRUST_CLASSIC, identityTrustModule);\n        final AttributeToModulesTransformer aclModule = new AttributeToModulesTransformer(Constants.ACL_MODULES);\n        ResourceTransformationDescriptionBuilder aclBuilder = registerModuleTransformer(securityDomain, ACL_PATH, aclModule);\n        //https://issues.jboss.org/browse/WFLY-2474 acl-module was wrongly called login-module in 7.2.0\n        aclBuilder.addChildRedirection(PathElement.pathElement(Constants.ACL_MODULE), PathElement.pathElement(Constants.LOGIN_MODULE));\n\n        AttributeToModulesTransformer authModule = new AttributeToModulesTransformer(Constants.AUTH_MODULES);\n        ResourceTransformationDescriptionBuilder jaspiReg = registerModuleTransformer(securityDomain, PATH_JASPI_AUTH, authModule);\n\n        // the module attribute is not recognized in the 1.2.0 version of the subsystem.\n        jaspiReg.addChildResource(PathElement.pathElement(Constants.AUTH_MODULE)).getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.DEFINED, Constants.MODULE)\n                .end();\n\n        registerModuleTransformer(jaspiReg, PATH_LOGIN_MODULE_STACK, loginModule);\n\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 2, 0));\n    }","commit_id":"893bac43ed5ffb83c36cd2b02bcbff2213484ea9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        rc.getSingletons().add(new DatabaseProvider(server.getDatabase()));\n        rc.getSingletons().add(new GraphDatabaseServiceProvider(server.getDatabase().graph));\n        rc.getSingletons().add(new NeoServerProvider(server));\n        rc.getSingletons().add(new ConfigurationProvider(server.getConfiguration()));\n        if(server.getDatabase().rrdDb() != null) {\n            rc.getSingletons().add(new RrdDbProvider(server.getDatabase().rrdDb()));\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        rc.getSingletons().add(new InputFormatProvider(repository));\n        rc.getSingletons().add(new OutputFormatProvider(repository));\n        rc.getSingletons().add(new PluginInvocatorProvider(server.getExtensionManager()));\n    }","id":276,"modified_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        Set<Object> singletons = rc.getSingletons();\n        singletons.add( new DatabaseProvider( server.getDatabase() ) );\n        singletons.add( new GraphDatabaseServiceProvider( server.getDatabase().graph ) );\n        singletons.add( new NeoServerProvider( server ) );\n        singletons.add( new ConfigurationProvider( server.getConfiguration() ) );\n        if(server.getDatabase().rrdDb() != null) {\n            singletons.add( new RrdDbProvider( server.getDatabase().rrdDb() ) );\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        singletons.add( new InputFormatProvider( repository ) );\n        singletons.add( new OutputFormatProvider( repository ) );\n        singletons.add( new PluginInvocatorProvider( server.getExtensionManager() ) );\n\n        for ( final Injectable injectable : injectables )\n        {\n            singletons.add( new InjectableWrapper( injectable ) );\n        }\n    }","commit_id":"50615302ebceba6f0a094604f3d410c1e1b1affd","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        rc.getSingletons().add(new DatabaseProvider(server.getDatabase()));\n        rc.getSingletons().add(new GraphDatabaseServiceProvider(server.getDatabase().graph));\n        rc.getSingletons().add(new NeoServerProvider(server));\n        rc.getSingletons().add(new ConfigurationProvider(server.getConfiguration()));\n        if(server.getDatabase().rrdDb() != null) {\n            rc.getSingletons().add(new RrdDbProvider(server.getDatabase().rrdDb()));\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        rc.getSingletons().add(new InputFormatProvider(repository));\n        rc.getSingletons().add(new OutputFormatProvider(repository));\n        rc.getSingletons().add(new PluginInvocatorProvider(server.getExtensionManager()));\n    }","id":277,"modified_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        Set<Object> singletons = rc.getSingletons();\n        singletons.add( new DatabaseProvider( server.getDatabase() ) );\n        singletons.add( new GraphDatabaseServiceProvider( server.getDatabase().graph ) );\n        singletons.add( new NeoServerProvider( server ) );\n        singletons.add( new ConfigurationProvider( server.getConfiguration() ) );\n        if(server.getDatabase().rrdDb() != null) {\n            singletons.add( new RrdDbProvider( server.getDatabase().rrdDb() ) );\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        singletons.add( new InputFormatProvider( repository ) );\n        singletons.add( new OutputFormatProvider( repository ) );\n        singletons.add( new PluginInvocatorProvider( server.getExtensionManager() ) );\n\n        for ( final Injectable injectable : injectables )\n        {\n            singletons.add( new InjectableWrapper( injectable ) );\n        }\n    }","commit_id":"3dc67fc928203b08b50907b8114cb9dbfc761c93","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        rc.getSingletons().add(new DatabaseProvider(server.getDatabase()));\n        rc.getSingletons().add(new GraphDatabaseServiceProvider(server.getDatabase().graph));\n        rc.getSingletons().add(new NeoServerProvider(server));\n        rc.getSingletons().add(new ConfigurationProvider(server.getConfiguration()));\n        if(server.getDatabase().rrdDb() != null) {\n            rc.getSingletons().add(new RrdDbProvider(server.getDatabase().rrdDb()));\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        rc.getSingletons().add(new InputFormatProvider(repository));\n        rc.getSingletons().add(new OutputFormatProvider(repository));\n        rc.getSingletons().add(new PluginInvocatorProvider(server.getExtensionManager()));\n    }","id":278,"modified_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        Set<Object> singletons = rc.getSingletons();\n        singletons.add( new DatabaseProvider( server.getDatabase() ) );\n        singletons.add( new GraphDatabaseServiceProvider( server.getDatabase().graph ) );\n        singletons.add( new NeoServerProvider( server ) );\n        singletons.add( new ConfigurationProvider( server.getConfiguration() ) );\n        if(server.getDatabase().rrdDb() != null) {\n            singletons.add( new RrdDbProvider( server.getDatabase().rrdDb() ) );\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        singletons.add( new InputFormatProvider( repository ) );\n        singletons.add( new OutputFormatProvider( repository ) );\n        singletons.add( new PluginInvocatorProvider( server.getExtensionManager() ) );\n\n        for ( final Injectable injectable : injectables )\n        {\n            singletons.add( new InjectableWrapper( injectable ) );\n        }\n    }","commit_id":"ea52ffbf7b1ad3417b927cdfd130511a5c4b62e3","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        rc.getSingletons().add(new DatabaseProvider(server.getDatabase()));\n        rc.getSingletons().add(new GraphDatabaseServiceProvider(server.getDatabase().graph));\n        rc.getSingletons().add(new NeoServerProvider(server));\n        rc.getSingletons().add(new ConfigurationProvider(server.getConfiguration()));\n        if(server.getDatabase().rrdDb() != null) {\n            rc.getSingletons().add(new RrdDbProvider(server.getDatabase().rrdDb()));\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        rc.getSingletons().add(new InputFormatProvider(repository));\n        rc.getSingletons().add(new OutputFormatProvider(repository));\n        rc.getSingletons().add(new PluginInvocatorProvider(server.getExtensionManager()));\n    }","id":279,"modified_method":"@Override\n    protected void configure(WebConfig wc, ResourceConfig rc, WebApplication wa) {\n        super.configure(wc, rc, wa);\n\n        Set<Object> singletons = rc.getSingletons();\n        singletons.add( new DatabaseProvider( server.getDatabase() ) );\n        singletons.add( new GraphDatabaseServiceProvider( server.getDatabase().graph ) );\n        singletons.add( new NeoServerProvider( server ) );\n        singletons.add( new ConfigurationProvider( server.getConfiguration() ) );\n        if(server.getDatabase().rrdDb() != null) {\n            singletons.add( new RrdDbProvider( server.getDatabase().rrdDb() ) );\n        }\n        RepresentationFormatRepository repository = new RepresentationFormatRepository(server.getExtensionManager());\n        singletons.add( new InputFormatProvider( repository ) );\n        singletons.add( new OutputFormatProvider( repository ) );\n        singletons.add( new PluginInvocatorProvider( server.getExtensionManager() ) );\n\n        for ( final Injectable injectable : injectables )\n        {\n            singletons.add( new InjectableWrapper( injectable ) );\n        }\n    }","commit_id":"26a622acb5a9b8a11f4c3dc1039d741e8d1bcfb1","url":"https://github.com/neo4j/neo4j"},{"original_method":"private synchronized void syncVerificationKey(File keyDir) {\n            File keyFile = new File(keyDir, KeyManager.KEYFILE_PUBLIC_SIGNING);\n            boolean exists = (_signingPublicKey != null);\n            if (!exists)\n                _signingPublicKey  = new SigningPublicKey();\n            _signingPublicKey  = (SigningPublicKey)syncKey(keyFile, _signingPublicKey, exists);\n        }","id":280,"modified_method":"private synchronized void syncVerificationKey(File keyDir) {\n            DataStructure ds;\n            File keyFile = new File(keyDir, KEYFILE_PUBLIC_SIGNING);\n            boolean exists = (_signingPublicKey != null);\n            if (exists)\n                ds = _signingPublicKey;\n            else\n                ds = new SigningPublicKey();\n            DataStructure readin = syncKey(keyFile, ds, exists);\n            if (readin != null && !exists)\n                _signingPublicKey  = (SigningPublicKey) readin;\n        }","commit_id":"570d8d15af3d26155eff217af01ddd4522e9eab2","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private synchronized void syncSigningKey(File keyDir) {\n            File keyFile = new File(keyDir, KeyManager.KEYFILE_PRIVATE_SIGNING);\n            boolean exists = (_signingPrivateKey != null);\n            if (!exists)\n                _signingPrivateKey = new SigningPrivateKey();\n            _signingPrivateKey = (SigningPrivateKey)syncKey(keyFile, _signingPrivateKey, exists);\n        }","id":281,"modified_method":"private synchronized void syncSigningKey(File keyDir) {\n            DataStructure ds;\n            File keyFile = new File(keyDir, KEYFILE_PRIVATE_SIGNING);\n            boolean exists = (_signingPrivateKey != null);\n            if (exists)\n                ds = _signingPrivateKey;\n            else\n                ds = new SigningPrivateKey();\n            DataStructure readin = syncKey(keyFile, ds, exists);\n            if (readin != null && !exists)\n                _signingPrivateKey = (SigningPrivateKey) readin;\n        }","commit_id":"570d8d15af3d26155eff217af01ddd4522e9eab2","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private synchronized void syncPrivateKey(File keyDir) {\n            File keyFile = new File(keyDir, KeyManager.KEYFILE_PRIVATE_ENC);\n            boolean exists = (_privateKey != null);\n            if (!exists)\n                _privateKey = new PrivateKey();\n            _privateKey = (PrivateKey)syncKey(keyFile, _privateKey, exists);\n        }","id":282,"modified_method":"private synchronized void syncPrivateKey(File keyDir) {\n            DataStructure ds;\n            File keyFile = new File(keyDir, KEYFILE_PRIVATE_ENC);\n            boolean exists = (_privateKey != null);\n            if (exists)\n                ds = _privateKey;\n            else\n                ds = new PrivateKey();\n            DataStructure readin = syncKey(keyFile, ds, exists);\n            if (readin != null && !exists)\n                _privateKey = (PrivateKey) readin;\n        }","commit_id":"570d8d15af3d26155eff217af01ddd4522e9eab2","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private synchronized void syncPublicKey(File keyDir) {\n            File keyFile = new File(keyDir, KeyManager.KEYFILE_PUBLIC_ENC);\n            boolean exists = (_publicKey != null);\n            if (!exists)\n                _publicKey = new PublicKey();\n            _publicKey = (PublicKey)syncKey(keyFile, _publicKey, exists);\n        }","id":283,"modified_method":"private synchronized void syncPublicKey(File keyDir) {\n            DataStructure ds;\n            File keyFile = new File(keyDir, KEYFILE_PUBLIC_ENC);\n            boolean exists = (_publicKey != null);\n            if (exists)\n                ds = _publicKey;\n            else\n                ds = new PublicKey();\n            DataStructure readin = syncKey(keyFile, ds, exists);\n            if (readin != null && !exists)\n                _publicKey = (PublicKey) readin;\n        }","commit_id":"570d8d15af3d26155eff217af01ddd4522e9eab2","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public final static Indexable deserialize(byte[] data, int start, int len) throws EXistException {\n\t\t\n\t\tint type = data[start];\n\t\t\n\t\t//TODO : improve deserialization (use static methods in the org.exist.xquery.Value package\n\t\t\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(type, Type.STRING))\n\t\t{\n\t\t\tString s;\n\t\t\ttry {\n\t\t\t\ts = new String(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE),\n\t\t\t\tlen - (ValueIndexFactory.LENGTH_VALUE_TYPE), \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tLOG.error(e);\n\t\t\t\tthrow new EXistException(e);\n\t\t\t}\n\t\t\treturn new StringValue(s);\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(type, Type.DATE_TIME))\t\t{\n\t\t\t//get the dateTime back as a long\n\t\t\tlong value = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE));\n\t\t\t//Create a GregorianCalendar from the long (normalized datetime as milliseconds since the Epoch)\n\t\t\tGregorianCalendar utccal = new GregorianCalendar();\n\t\t\tutccal.setTimeInMillis(value);\n\t\t\t//Create a XMLGregorianCalendar from the GregorianCalendar\n\t\t\ttry\n\t\t\t{\n\t\t\t\tXMLGregorianCalendar xmlutccal = DatatypeFactory.newInstance().newXMLGregorianCalendar(utccal);\n\t\t\t\treturn new DateTimeValue(xmlutccal);\n\t\t\t}\n\t\t\tcatch(DatatypeConfigurationException dtce)\n\t\t\t{\n\t\t\t\tthrow new EXistException(\"Could not deserialize xs:dateTime data type for range index key: \" + Type.getTypeName(type) + \" - \" + dtce.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(type, Type.INTEGER))\n\t\t{\n\t\t\treturn new IntegerValue(ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L);\n\t\t}\n\n\t\t\n\t\t/* xs:double */\n\t\telse if (type == Type.DOUBLE)\n\t\t{\n\t\t\tlong bits = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L;\n\t\t\tdouble d = Double.longBitsToDouble(bits);\n\t\t\treturn new DoubleValue(d);\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (type == Type.FLOAT)\n\t\t{\n\t\t\tint bits = ByteConversion.byteToInt(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x80000000;\n\t\t\tfloat f = Float.intBitsToFloat(bits);\n\t\t\treturn new FloatValue(f);\n\t\t}\t\t\n\t\t\n\t\t/* xs:boolean */\n\t\telse if(type == Type.BOOLEAN)\n\t\t{\n\t\t\treturn new BooleanValue(data[start + (ValueIndexFactory.LENGTH_VALUE_TYPE)] == 1);\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for deserialization: \" + Type.getTypeName(type));\n\t\t}\n\t}","id":284,"modified_method":"public final static Indexable deserialize(byte[] data, int start, int len) throws EXistException {\n\t\t\n\t\tint type = data[start];\n\t\t\n\t\t//TODO : improve deserialization (use static methods in the org.exist.xquery.Value package\n\t\t\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(type, Type.STRING))\n\t\t{\n\t\t\tString s;\n\t\t\ttry {\n\t\t\t\ts = new String(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE),\n\t\t\t\tlen - (ValueIndexFactory.LENGTH_VALUE_TYPE), \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tLOG.error(e);\n\t\t\t\tthrow new EXistException(e);\n\t\t\t}\n\t\t\treturn new StringValue(s);\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(type, Type.DATE_TIME))\t\t{\n\t\t\t//get the dateTime back as a long\n\t\t\tlong value = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE));\n\t\t\t//Create a GregorianCalendar from the long (normalized datetime as milliseconds since the Epoch)\n\t\t\tGregorianCalendar utccal = new GregorianCalendar();\n\t\t\tutccal.setTimeInMillis(value);\n\t\t\t//Create a XMLGregorianCalendar from the GregorianCalendar\n\t\t\ttry\n\t\t\t{\n\t\t\t\tXMLGregorianCalendar xmlutccal = DatatypeFactory.newInstance().newXMLGregorianCalendar(utccal);\n\t\t\t\treturn new DateTimeValue(xmlutccal);\n\t\t\t}\n\t\t\tcatch(DatatypeConfigurationException dtce)\n\t\t\t{\n\t\t\t\tthrow new EXistException(\"Could not deserialize xs:dateTime data type for range index key: \" + Type.getTypeName(type) + \" - \" + dtce.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n    /* xs:date */\n    else if(Type.subTypeOf(type, Type.DATE))   {\n      //get the date back as a long\n      long value = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE));\n      //Create a GregorianCalendar from the long (normalized datetime as milliseconds since the Epoch)\n      GregorianCalendar utccal = new GregorianCalendar();\n      utccal.setTimeInMillis(value);\n      //Create a XMLGregorianCalendar from the GregorianCalendar\n      try\n      {\n        XMLGregorianCalendar xmlutccal = DatatypeFactory.newInstance().newXMLGregorianCalendar(utccal);\n        return new DateValue(xmlutccal);\n      }\n      catch(DatatypeConfigurationException dtce)\n      {\n        throw new EXistException(\"Could not deserialize xs:date data type for range index key: \" + Type.getTypeName(type) + \" - \" + dtce.getMessage());\n      }\n      catch(XPathException xpe)\n      {\n        throw new EXistException(\"Could not deserialize xs:date data type for range index key: \" + Type.getTypeName(type) + \" - \" + xpe.getMessage());\n      }\n    }\n    \n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(type, Type.INTEGER))\n\t\t{\n\t\t\treturn new IntegerValue(ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L);\n\t\t}\n\n\t\t\n\t\t/* xs:double */\n\t\telse if (type == Type.DOUBLE)\n\t\t{\n\t\t\tlong bits = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L;\n\t\t\tdouble d = Double.longBitsToDouble(bits);\n\t\t\treturn new DoubleValue(d);\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (type == Type.FLOAT)\n\t\t{\n\t\t\tint bits = ByteConversion.byteToInt(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x80000000;\n\t\t\tfloat f = Float.intBitsToFloat(bits);\n\t\t\treturn new FloatValue(f);\n\t\t}\t\t\n\t\t\n\t\t/* xs:boolean */\n\t\telse if(type == Type.BOOLEAN)\n\t\t{\n\t\t\treturn new BooleanValue(data[start + (ValueIndexFactory.LENGTH_VALUE_TYPE)] == 1);\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for deserialization: \" + Type.getTypeName(type));\n\t\t}\n\t}","commit_id":"9afb8bedb45d5501966de9c77d37b4427e044496","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @deprecated\n\t * @param value\n\t * @param offset\n\t * @param caseSensitive\n\t * @throws EXistException\n\t */\n\tpublic final static byte[] serialize(Indexable value, int offset, boolean caseSensitive) \n\tthrows EXistException {\n\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(value.getType(), Type.STRING))\n\t\t{\t\t\t\n\t\t\tfinal String val = caseSensitive ? \n\t\t\t\t((StringValue)value).getStringValue() : \n\t\t\t\t((StringValue)value).getStringValue().toLowerCase();\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + UTF8.encoded(val) ];\n\t\t\tdata[offset] = (byte) value.getType();\t// TODO: cast to byte is not safe\n\t\t\tUTF8.encode(val, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);  \n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(value.getType(), Type.DATE_TIME))\t\t{\n\t    \tGregorianCalendar utccal = ((AbstractDateTimeValue)value).calendar.normalize().toGregorianCalendar();\t//Get the dateTime (XMLGregorianCalendar) normalized to UTC (as a GregorianCalendar)\n\t\t\tlong millis = utccal.getTimeInMillis();\t\t\t\t\t\t\t\t\t//Get the normalized dateTime as a long (milliseconds since the Epoch)\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\t\t//allocate an appropriately sized byte array for holding Type,long\n\t\t\tdata[offset] = (byte) Type.DATE_TIME;\t\t\t\t//put the Type in the byte array\n\t\t\tByteConversion.longToByte(millis, data, offset+1);\t//put the long into the byte array\n\t\t\treturn(data);\t\t\t\t\t\t\t\t\t\t//return the byte array\n\t\t}\n\t\t\n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(value.getType(), Type.INTEGER))\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t\t\tdata[offset] = (byte) Type.INTEGER;\n\t        long l = ((IntegerValue)value).getValue() - Long.MIN_VALUE;\n\t\t\tByteConversion.longToByte(l, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:double */\n\t\telse if (value.getType() == Type.DOUBLE)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t        data[offset] = (byte) Type.DOUBLE;\n\t        final long bits = Double.doubleToLongBits(((DoubleValue)value).getValue()) ^ 0x8000000000000000L;\n\t        ByteConversion.longToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (value.getType() == Type.FLOAT)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 4];\n\t\t\tdata[offset] = (byte) Type.FLOAT;\n\t        final int bits = (int)(Float.floatToIntBits(((FloatValue)value).getValue()) ^ 0x80000000);\n\t        ByteConversion.intToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\t\t\n\t\n\t\t/* xs:boolean */\n\t\telse if(value.getType() == Type.BOOLEAN)\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 1];\n\t    \tdata[offset] = Type.BOOLEAN;\n\t        data[offset + ValueIndexFactory.LENGTH_VALUE_TYPE] = (byte)(((BooleanValue)value).getValue() ? 1 : 0);\n\t        return data;\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for serialization: \" + Type.getTypeName(value.getType()));\n\t\t}\t\n\t}","id":285,"modified_method":"/**\n\t * @deprecated\n\t * @param value\n\t * @param offset\n\t * @param caseSensitive\n\t * @throws EXistException\n\t */\n\tpublic final static byte[] serialize(Indexable value, int offset, boolean caseSensitive) \n\tthrows EXistException {\n\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(value.getType(), Type.STRING))\n\t\t{\t\t\t\n\t\t\tfinal String val = caseSensitive ? \n\t\t\t\t((StringValue)value).getStringValue() : \n\t\t\t\t((StringValue)value).getStringValue().toLowerCase();\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + UTF8.encoded(val) ];\n\t\t\tdata[offset] = (byte) value.getType();\t// TODO: cast to byte is not safe\n\t\t\tUTF8.encode(val, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);  \n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(value.getType(), Type.DATE_TIME))\t\t{\n\t    \tGregorianCalendar utccal = ((AbstractDateTimeValue)value).calendar.normalize().toGregorianCalendar();\t//Get the dateTime (XMLGregorianCalendar) normalized to UTC (as a GregorianCalendar)\n\t\t\tlong millis = utccal.getTimeInMillis();\t\t\t\t\t\t\t\t\t//Get the normalized dateTime as a long (milliseconds since the Epoch)\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\t\t//allocate an appropriately sized byte array for holding Type,long\n\t\t\tdata[offset] = (byte) Type.DATE_TIME;\t\t\t\t//put the Type in the byte array\n\t\t\tByteConversion.longToByte(millis, data, offset+1);\t//put the long into the byte array\n\t\t\treturn(data);\t\t\t\t\t\t\t\t\t\t//return the byte array\n\t\t}\n\t\t\n    /* xs:date */\n    else if(Type.subTypeOf(value.getType(), Type.DATE))    {\n        GregorianCalendar utccal = ((AbstractDateTimeValue)value).calendar.normalize().toGregorianCalendar(); //Get the dateTime (XMLGregorianCalendar) normalized to UTC (as a GregorianCalendar)\n      long millis = utccal.getTimeInMillis();                 //Get the normalized dateTime as a long (milliseconds since the Epoch)\n      final byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];   //allocate an appropriately sized byte array for holding Type,long\n      data[offset] = (byte) Type.DATE;       //put the Type in the byte array\n      ByteConversion.longToByte(millis, data, offset+1);  //put the long into the byte array\n      return(data);                   //return the byte array\n    }\n    \n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(value.getType(), Type.INTEGER))\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t\t\tdata[offset] = (byte) Type.INTEGER;\n\t        long l = ((IntegerValue)value).getValue() - Long.MIN_VALUE;\n\t\t\tByteConversion.longToByte(l, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:double */\n\t\telse if (value.getType() == Type.DOUBLE)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t        data[offset] = (byte) Type.DOUBLE;\n\t        final long bits = Double.doubleToLongBits(((DoubleValue)value).getValue()) ^ 0x8000000000000000L;\n\t        ByteConversion.longToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (value.getType() == Type.FLOAT)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 4];\n\t\t\tdata[offset] = (byte) Type.FLOAT;\n\t        final int bits = (int)(Float.floatToIntBits(((FloatValue)value).getValue()) ^ 0x80000000);\n\t        ByteConversion.intToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\t\t\n\t\n\t\t/* xs:boolean */\n\t\telse if(value.getType() == Type.BOOLEAN)\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 1];\n\t    \tdata[offset] = Type.BOOLEAN;\n\t        data[offset + ValueIndexFactory.LENGTH_VALUE_TYPE] = (byte)(((BooleanValue)value).getValue() ? 1 : 0);\n\t        return data;\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for serialization: \" + Type.getTypeName(value.getType()));\n\t\t}\t\n\t}","commit_id":"9afb8bedb45d5501966de9c77d37b4427e044496","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @deprecated\n\t * @param value\n\t * @param offset\n\t * @param caseSensitive\n\t * @throws EXistException\n\t */\n\tpublic final static byte[] serialize(Indexable value, int offset, boolean caseSensitive) \n\tthrows EXistException {\n\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(value.getType(), Type.STRING))\n\t\t{\t\t\t\n\t\t\tfinal String val = caseSensitive ? \n\t\t\t\t((StringValue)value).getStringValue() : \n\t\t\t\t((StringValue)value).getStringValue().toLowerCase();\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + UTF8.encoded(val) ];\n\t\t\tdata[offset] = (byte) value.getType();\t// TODO: cast to byte is not safe\n\t\t\tUTF8.encode(val, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);  \n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(value.getType(), Type.DATE_TIME))\t\t{\n\t    \tGregorianCalendar utccal = ((AbstractDateTimeValue)value).calendar.normalize().toGregorianCalendar();\t//Get the dateTime (XMLGregorianCalendar) normalized to UTC (as a GregorianCalendar)\n\t\t\tlong millis = utccal.getTimeInMillis();\t\t\t\t\t\t\t\t\t//Get the normalized dateTime as a long (milliseconds since the Epoch)\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\t\t//allocate an appropriately sized byte array for holding Type,long\n\t\t\tdata[offset] = (byte) Type.DATE_TIME;\t\t\t\t//put the Type in the byte array\n\t\t\tByteConversion.longToByte(millis, data, offset+1);\t//put the long into the byte array\n\t\t\treturn(data);\t\t\t\t\t\t\t\t\t\t//return the byte array\n\t\t}\n\t\t\n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(value.getType(), Type.INTEGER))\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t\t\tdata[offset] = (byte) Type.INTEGER;\n\t        long l = ((IntegerValue)value).getValue() - Long.MIN_VALUE;\n\t\t\tByteConversion.longToByte(l, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:double */\n\t\telse if (value.getType() == Type.DOUBLE)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t        data[offset] = (byte) Type.DOUBLE;\n\t        final long bits = Double.doubleToLongBits(((DoubleValue)value).getValue()) ^ 0x8000000000000000L;\n\t        ByteConversion.longToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (value.getType() == Type.FLOAT)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 4];\n\t\t\tdata[offset] = (byte) Type.FLOAT;\n\t        final int bits = (int)(Float.floatToIntBits(((FloatValue)value).getValue()) ^ 0x80000000);\n\t        ByteConversion.intToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\t\t\n\t\n\t\t/* xs:boolean */\n\t\telse if(value.getType() == Type.BOOLEAN)\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 1];\n\t    \tdata[offset] = Type.BOOLEAN;\n\t        data[offset + ValueIndexFactory.LENGTH_VALUE_TYPE] = (byte)(((BooleanValue)value).getValue() ? 1 : 0);\n\t        return data;\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for serialization: \" + Type.getTypeName(value.getType()));\n\t\t}\t\n\t}","id":286,"modified_method":"/**\n\t * @deprecated\n\t * @param value\n\t * @param offset\n\t * @param caseSensitive\n\t * @throws EXistException\n\t */\n\tpublic final static byte[] serialize(Indexable value, int offset, boolean caseSensitive) \n\tthrows EXistException {\n\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(value.getType(), Type.STRING))\n\t\t{\t\t\t\n\t\t\tfinal String val = caseSensitive ? \n\t\t\t\t((StringValue)value).getStringValue() : \n\t\t\t\t((StringValue)value).getStringValue().toLowerCase();\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + UTF8.encoded(val) ];\n\t\t\tdata[offset] = (byte) value.getType();\t// TODO: cast to byte is not safe\n\t\t\tUTF8.encode(val, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);  \n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(value.getType(), Type.DATE_TIME))\t\t{\n\t    \tGregorianCalendar utccal = ((AbstractDateTimeValue)value).calendar.normalize().toGregorianCalendar();\t//Get the dateTime (XMLGregorianCalendar) normalized to UTC (as a GregorianCalendar)\n\t\t\tlong millis = utccal.getTimeInMillis();\t\t\t\t\t\t\t\t\t//Get the normalized dateTime as a long (milliseconds since the Epoch)\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\t\t//allocate an appropriately sized byte array for holding Type,long\n\t\t\tdata[offset] = (byte) Type.DATE_TIME;\t\t\t\t//put the Type in the byte array\n\t\t\tByteConversion.longToByte(millis, data, offset+1);\t//put the long into the byte array\n\t\t\treturn(data);\t\t\t\t\t\t\t\t\t\t//return the byte array\n\t\t}\n\t\t\n    /* xs:date */\n    else if(Type.subTypeOf(value.getType(), Type.DATE))    {\n        GregorianCalendar utccal = ((AbstractDateTimeValue)value).calendar.normalize().toGregorianCalendar(); //Get the dateTime (XMLGregorianCalendar) normalized to UTC (as a GregorianCalendar)\n      long millis = utccal.getTimeInMillis();                 //Get the normalized dateTime as a long (milliseconds since the Epoch)\n      final byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];   //allocate an appropriately sized byte array for holding Type,long\n      data[offset] = (byte) Type.DATE;       //put the Type in the byte array\n      ByteConversion.longToByte(millis, data, offset+1);  //put the long into the byte array\n      return(data);                   //return the byte array\n    }\n    \n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(value.getType(), Type.INTEGER))\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t\t\tdata[offset] = (byte) Type.INTEGER;\n\t        long l = ((IntegerValue)value).getValue() - Long.MIN_VALUE;\n\t\t\tByteConversion.longToByte(l, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t\t\treturn data;\n\t\t}\n\t\t\n\t\t/* xs:double */\n\t\telse if (value.getType() == Type.DOUBLE)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 8];\n\t        data[offset] = (byte) Type.DOUBLE;\n\t        final long bits = Double.doubleToLongBits(((DoubleValue)value).getValue()) ^ 0x8000000000000000L;\n\t        ByteConversion.longToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (value.getType() == Type.FLOAT)\n\t\t{\n\t\t\tfinal byte[] data = new byte[offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 4];\n\t\t\tdata[offset] = (byte) Type.FLOAT;\n\t        final int bits = (int)(Float.floatToIntBits(((FloatValue)value).getValue()) ^ 0x80000000);\n\t        ByteConversion.intToByte(bits, data, offset + ValueIndexFactory.LENGTH_VALUE_TYPE);\n\t        return data;\n\t\t}\t\t\n\t\n\t\t/* xs:boolean */\n\t\telse if(value.getType() == Type.BOOLEAN)\n\t\t{\n\t\t\tfinal byte[] data = new byte[ offset + ValueIndexFactory.LENGTH_VALUE_TYPE + 1];\n\t    \tdata[offset] = Type.BOOLEAN;\n\t        data[offset + ValueIndexFactory.LENGTH_VALUE_TYPE] = (byte)(((BooleanValue)value).getValue() ? 1 : 0);\n\t        return data;\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for serialization: \" + Type.getTypeName(value.getType()));\n\t\t}\t\n\t}","commit_id":"e4d1c7acae6dbe09dfdba66e5ad2486d6b13bc0f","url":"https://github.com/eXist-db/exist"},{"original_method":"public final static Indexable deserialize(byte[] data, int start, int len) throws EXistException {\n\t\t\n\t\tint type = data[start];\n\t\t\n\t\t//TODO : improve deserialization (use static methods in the org.exist.xquery.Value package\n\t\t\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(type, Type.STRING))\n\t\t{\n\t\t\tString s;\n\t\t\ttry {\n\t\t\t\ts = new String(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE),\n\t\t\t\tlen - (ValueIndexFactory.LENGTH_VALUE_TYPE), \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tLOG.error(e);\n\t\t\t\tthrow new EXistException(e);\n\t\t\t}\n\t\t\treturn new StringValue(s);\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(type, Type.DATE_TIME))\t\t{\n\t\t\t//get the dateTime back as a long\n\t\t\tlong value = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE));\n\t\t\t//Create a GregorianCalendar from the long (normalized datetime as milliseconds since the Epoch)\n\t\t\tGregorianCalendar utccal = new GregorianCalendar();\n\t\t\tutccal.setTimeInMillis(value);\n\t\t\t//Create a XMLGregorianCalendar from the GregorianCalendar\n\t\t\ttry\n\t\t\t{\n\t\t\t\tXMLGregorianCalendar xmlutccal = DatatypeFactory.newInstance().newXMLGregorianCalendar(utccal);\n\t\t\t\treturn new DateTimeValue(xmlutccal);\n\t\t\t}\n\t\t\tcatch(DatatypeConfigurationException dtce)\n\t\t\t{\n\t\t\t\tthrow new EXistException(\"Could not deserialize xs:dateTime data type for range index key: \" + Type.getTypeName(type) + \" - \" + dtce.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(type, Type.INTEGER))\n\t\t{\n\t\t\treturn new IntegerValue(ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L);\n\t\t}\n\n\t\t\n\t\t/* xs:double */\n\t\telse if (type == Type.DOUBLE)\n\t\t{\n\t\t\tlong bits = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L;\n\t\t\tdouble d = Double.longBitsToDouble(bits);\n\t\t\treturn new DoubleValue(d);\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (type == Type.FLOAT)\n\t\t{\n\t\t\tint bits = ByteConversion.byteToInt(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x80000000;\n\t\t\tfloat f = Float.intBitsToFloat(bits);\n\t\t\treturn new FloatValue(f);\n\t\t}\t\t\n\t\t\n\t\t/* xs:boolean */\n\t\telse if(type == Type.BOOLEAN)\n\t\t{\n\t\t\treturn new BooleanValue(data[start + (ValueIndexFactory.LENGTH_VALUE_TYPE)] == 1);\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for deserialization: \" + Type.getTypeName(type));\n\t\t}\n\t}","id":287,"modified_method":"public final static Indexable deserialize(byte[] data, int start, int len) throws EXistException {\n\t\t\n\t\tint type = data[start];\n\t\t\n\t\t//TODO : improve deserialization (use static methods in the org.exist.xquery.Value package\n\t\t\n\t\t/* xs:string */\n\t\tif (Type.subTypeOf(type, Type.STRING))\n\t\t{\n\t\t\tString s;\n\t\t\ttry {\n\t\t\t\ts = new String(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE),\n\t\t\t\tlen - (ValueIndexFactory.LENGTH_VALUE_TYPE), \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tLOG.error(e);\n\t\t\t\tthrow new EXistException(e);\n\t\t\t}\n\t\t\treturn new StringValue(s);\n\t\t}\n\t\t\n\t\t/* xs:dateTime */\n\t\telse if(Type.subTypeOf(type, Type.DATE_TIME))\t\t{\n\t\t\t//get the dateTime back as a long\n\t\t\tlong value = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE));\n\t\t\t//Create a GregorianCalendar from the long (normalized datetime as milliseconds since the Epoch)\n\t\t\tGregorianCalendar utccal = new GregorianCalendar();\n\t\t\tutccal.setTimeInMillis(value);\n\t\t\t//Create a XMLGregorianCalendar from the GregorianCalendar\n\t\t\ttry\n\t\t\t{\n\t\t\t\tXMLGregorianCalendar xmlutccal = DatatypeFactory.newInstance().newXMLGregorianCalendar(utccal);\n\t\t\t\treturn new DateTimeValue(xmlutccal);\n\t\t\t}\n\t\t\tcatch(DatatypeConfigurationException dtce)\n\t\t\t{\n\t\t\t\tthrow new EXistException(\"Could not deserialize xs:dateTime data type for range index key: \" + Type.getTypeName(type) + \" - \" + dtce.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n    /* xs:date */\n    else if(Type.subTypeOf(type, Type.DATE))   {\n      //get the date back as a long\n      long value = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE));\n      //Create a GregorianCalendar from the long (normalized datetime as milliseconds since the Epoch)\n      GregorianCalendar utccal = new GregorianCalendar();\n      utccal.setTimeInMillis(value);\n      //Create a XMLGregorianCalendar from the GregorianCalendar\n      try\n      {\n        XMLGregorianCalendar xmlutccal = DatatypeFactory.newInstance().newXMLGregorianCalendar(utccal);\n        return new DateValue(xmlutccal);\n      }\n      catch(DatatypeConfigurationException dtce)\n      {\n        throw new EXistException(\"Could not deserialize xs:date data type for range index key: \" + Type.getTypeName(type) + \" - \" + dtce.getMessage());\n      }\n      catch(XPathException xpe)\n      {\n        throw new EXistException(\"Could not deserialize xs:date data type for range index key: \" + Type.getTypeName(type) + \" - \" + xpe.getMessage());\n      }\n    }\n    \n\t\t/* xs:integer */\n\t\telse if(Type.subTypeOf(type, Type.INTEGER))\n\t\t{\n\t\t\treturn new IntegerValue(ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L);\n\t\t}\n\n\t\t\n\t\t/* xs:double */\n\t\telse if (type == Type.DOUBLE)\n\t\t{\n\t\t\tlong bits = ByteConversion.byteToLong(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x8000000000000000L;\n\t\t\tdouble d = Double.longBitsToDouble(bits);\n\t\t\treturn new DoubleValue(d);\n\t\t}\n\t\t\n\t\t/* xs:float */\n\t\telse if (type == Type.FLOAT)\n\t\t{\n\t\t\tint bits = ByteConversion.byteToInt(data, start + (ValueIndexFactory.LENGTH_VALUE_TYPE)) ^ 0x80000000;\n\t\t\tfloat f = Float.intBitsToFloat(bits);\n\t\t\treturn new FloatValue(f);\n\t\t}\t\t\n\t\t\n\t\t/* xs:boolean */\n\t\telse if(type == Type.BOOLEAN)\n\t\t{\n\t\t\treturn new BooleanValue(data[start + (ValueIndexFactory.LENGTH_VALUE_TYPE)] == 1);\n\t\t}\t\t\n\t\t\n\t\t/* unknown! */\n\t\telse\n\t\t{\n\t\t\tthrow new EXistException(\"Unknown data type for deserialization: \" + Type.getTypeName(type));\n\t\t}\n\t}","commit_id":"e4d1c7acae6dbe09dfdba66e5ad2486d6b13bc0f","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        link = new PushButton(Images.INSTANCE.link().createImage(), this);\n        link.setTitle(Strings.INSTANCE.link());\n        toolBarExtension.addFeature(\"link\", link);\n\n        unlink = new PushButton(Images.INSTANCE.unlink().createImage(), this);\n        unlink.setTitle(Strings.INSTANCE.unlink());\n        toolBarExtension.addFeature(\"unlink\", unlink);\n\n        getUIExtensionList().add(toolBarExtension);\n    }","id":288,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, RichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        if (getTextArea().getCommandManager().isSupported(Command.CREATE_LINK)) {\n            link = new PushButton(Images.INSTANCE.link().createImage(), this);\n            link.setTitle(Strings.INSTANCE.link());\n            toolBarExtension.addFeature(\"link\", link);\n        }\n\n        if (getTextArea().getCommandManager().isSupported(Command.UNLINK)) {\n            unlink = new PushButton(Images.INSTANCE.unlink().createImage(), this);\n            unlink.setTitle(Strings.INSTANCE.unlink());\n            toolBarExtension.addFeature(\"unlink\", unlink);\n        }\n\n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().addClickListener(this);\n            getUIExtensionList().add(toolBarExtension);\n            selectionPreserver = new SelectionPreserver(textArea);\n        }\n    }","commit_id":"1bbd46580d53c9109927b32979383531fb73eef3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        image = new PushButton(Images.INSTANCE.image().createImage(), this);\n        image.setTitle(Strings.INSTANCE.image());\n\n        getTextArea().addClickListener(this);\n        toolBarExtension.addFeature(\"image\", image);\n        getUIExtensionList().add(toolBarExtension);\n\n        textArea.getCommandManager().registerCommand(Command.INSERT_IMAGE, new InsertImageExecutable());\n    }","id":289,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see AbstractPlugin#init(Wysiwyg, XRichTextArea, Config)\n     */\n    public void init(Wysiwyg wysiwyg, RichTextArea textArea, Config config)\n    {\n        super.init(wysiwyg, textArea, config);\n\n        textArea.getCommandManager().registerCommand(Command.INSERT_IMAGE, new InsertImageExecutable());\n        if (getTextArea().getCommandManager().isSupported(Command.INSERT_IMAGE)) {\n            image = new PushButton(Images.INSTANCE.image().createImage(), this);\n            image.setTitle(Strings.INSTANCE.image());\n            toolBarExtension.addFeature(\"image\", image);\n        }\n        \n        if (toolBarExtension.getFeatures().length > 0) {\n            getTextArea().addClickListener(this);\n            getUIExtensionList().add(toolBarExtension);\n            selectionPreserver = new SelectionPreserver(textArea);\n        }\n    }","commit_id":"caefd24ff7b830e33cf143f3d6d83d2e0677f07f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static Object referenceMacro_GetReferent_6164634611271252587(final ReferenceMacroContext _context) {\n    SNode type = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\")));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a1a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a2a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a3a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632137\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a4a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632254\");\n    }\n    return null;\n  }","id":290,"modified_method":"public static Object referenceMacro_GetReferent_6164634611271252587(final ReferenceMacroContext _context) {\n    SNode seqType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\"))), new QueriesGenerated.Pattern_x583g4_a1a0a0a41(), true);\n    if (seqType == null) {\n      return null;\n    }\n    SNode elementType = SLinkOperations.getTarget(seqType, MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a3a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a4a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844631948\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a5a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632137\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a6a41())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"1125969196844632254\");\n    }\n    return null;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_6164634611271252527(final ReferenceMacroContext _context) {\n    SNode type = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\")));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a1a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263258755\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a2a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263262593\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a3a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263265578\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(type, _quotation_createNode_x583g4_b0a4a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263268620\");\n    }\n    return null;\n  }","id":291,"modified_method":"public static Object referenceMacro_GetReferent_6164634611271252527(final ReferenceMacroContext _context) {\n    SNode seqType = TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(_context.getNode(), MetaAdapterFactory.getContainmentLink(0xa5e4de5346a344daL, 0xaab368fdf1c34ed0L, 0x75bb0160f191d79fL, 0x6979f0787b81e875L, \"object\"))), new QueriesGenerated.Pattern_x583g4_a1a0a0a31(), true);\n    if (seqType == null) {\n      return null;\n    }\n    SNode elementType = SLinkOperations.getTarget(seqType, MetaAdapterFactory.getContainmentLink(0x8388864671ce4f1cL, 0x9c53c54016f6ad4fL, 0x10c260e9444L, 0x10c260ee40eL, \"elementType\"));\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a3a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263258755\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a4a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263262593\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a5a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263265578\");\n    }\n    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(elementType, _quotation_createNode_x583g4_b0a6a31())) {\n      return SNodeOperations.getNode(\"r:53684c5c-ca9d-4308-a9d7-6866aa7b486b(jetbrains.mps.lang.smodel.query.runtime)\", \"3501374812263268620\");\n    }\n    return null;\n  }","commit_id":"4014c81ae3b61bc88104012161fae1d39c2fbd1d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.AbstractAction\");\n      }\n    });\n  }","id":292,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.AbstractAction\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.BeanExtensionPoint\");\n      }\n    });\n  }","id":293,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.BeanExtensionPoint\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.ExtensionPoint\");\n      }\n    });\n  }","id":294,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.ExtensionPoint\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.IntefaceExtensionPoint\");\n      }\n    });\n  }","id":295,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.IntefaceExtensionPoint\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(((Iterable<IModule>) operationContext.getScope().getVisibleModules())).<SModelDescriptor>translate(new ITranslator2<IModule, SModelDescriptor>() {\n      public Iterable<SModelDescriptor> translate(IModule m) {\n        return m.getOwnModelDescriptors();\n      }\n    }).where(new IWhereFilter<SModelDescriptor>() {\n      public boolean accept(SModelDescriptor smd) {\n        return !(\"java_stub\".equals(smd.getStereotype()));\n      }\n    }).<SNode>translate(new ITranslator2<SModelDescriptor, SNode>() {\n      public Iterable<SNode> translate(SModelDescriptor smd) {\n        return SModelOperations.getNodes(((SModel) smd.getSModel()), \"jetbrains.mps.platform.conf.structure.Plugin\");\n      }\n    });\n  }","id":296,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    return Sequence.fromIterable(ConfUtil.visibleConfModels(operationContext.getScope())).<SNode>translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel m) {\n        return SModelOperations.getNodes(m, \"jetbrains.mps.platform.conf.structure.Plugin\");\n      }\n    });\n  }","commit_id":"792ae8e09ac0bf54f82c91648deaa2a4a328adb8","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setNames(String name, String... values) {\n        List<CoreValue> cvs = new ArrayList<CoreValue>(values.length);\n        for (String value : values) {\n            cvs.add(factory.createValue(\n                    mapper.getOakName(value), PropertyType.NAME));\n        }\n        tree.setProperty(name, cvs);\n    }","id":297,"modified_method":"public void setNames(String name, String... values) {\n        List<CoreValue> cvs = new ArrayList<CoreValue>(values.length);\n        for (String value : values) {\n            String oakName = mapper.getOakName(value);\n            if (oakName == null) {\n                throw new IllegalArgumentException(\"Invalid name:\" + name);\n            }\n\n            cvs.add(factory.createValue(\n                    oakName, PropertyType.NAME));\n        }\n        tree.setProperty(name, cvs);\n    }","commit_id":"1e7050dcb4423fb9c7876342939f3458c3dda439","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void setName(String name, String value) {\n        tree.setProperty(name, factory.createValue(\n                mapper.getOakName(value), PropertyType.NAME));\n    }","id":298,"modified_method":"public void setName(String name, String value) {\n        String oakName = mapper.getOakName(value);\n        if (oakName == null) {\n            throw new IllegalArgumentException(\"Invalid name:\" + name);\n        }\n\n        tree.setProperty(name, factory.createValue(\n                oakName, PropertyType.NAME));\n    }","commit_id":"1e7050dcb4423fb9c7876342939f3458c3dda439","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Privilege registerPrivilege(String privilegeName, boolean isAbstract,\n                                       String[] declaredAggregateNames) throws RepositoryException {\n        PrivilegeDefinition def = provider.registerDefinition(getOakName(privilegeName), isAbstract, getOakNames(declaredAggregateNames));\n        return new PrivilegeImpl(def);\n    }","id":299,"modified_method":"@Override\n    public Privilege registerPrivilege(String privilegeName, boolean isAbstract,\n                                       String[] declaredAggregateNames) throws RepositoryException {\n        if (privilegeName == null || privilegeName.isEmpty()) {\n            throw new RepositoryException(\"Invalid privilege name \" + privilegeName);\n        }\n        String oakName = getOakName(privilegeName);\n        if (oakName == null) {\n            throw new NamespaceException(\"Invalid privilege name \" + privilegeName);\n        }\n\n        PrivilegeDefinition def = provider.registerDefinition(oakName, isAbstract, getOakNames(declaredAggregateNames));\n        return new PrivilegeImpl(def);\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Set<String> getOakNames(String[] jcrNames) {\n        Set<String> oakNames;\n        if (jcrNames == null || jcrNames.length == 0) {\n            oakNames = Collections.emptySet();\n        } else {\n            oakNames = new HashSet<String>(jcrNames.length);\n            for (String jcrName : jcrNames) {\n                oakNames.add(getOakName(jcrName));\n            }\n        }\n        return oakNames;\n    }","id":300,"modified_method":"private Set<String> getOakNames(String[] jcrNames) throws RepositoryException {\n        Set<String> oakNames;\n        if (jcrNames == null || jcrNames.length == 0) {\n            oakNames = Collections.emptySet();\n        } else {\n            oakNames = new HashSet<String>(jcrNames.length);\n            for (String jcrName : jcrNames) {\n                String oakName = getOakName(jcrName);\n                if (oakName == null) {\n                    throw new RepositoryException(\"Invalid name \" + jcrName);\n                }\n                oakNames.add(oakName);\n            }\n        }\n        return oakNames;\n    }","commit_id":"e9a5db7f28538f6fdd9fe50e25d4bb35d3f84c49","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Variable findClassMember(ClassNode cn, String name) {\n        if (cn == null) return null;\n        if (cn.isScript()) {\n            return new DynamicVariable(name, false);\n        }\n        List l = cn.getFields();\n        for (Iterator iter = l.iterator(); iter.hasNext();) {\n            FieldNode f = (FieldNode) iter.next();\n            if (f.getName().equals(name)) return f;\n        }\n\n        l = cn.getMethods();\n        for (Iterator iter = l.iterator(); iter.hasNext();) {\n            MethodNode f = (MethodNode) iter.next();\n            String methodName = f.getName();\n            String pName = getPropertyName(f);\n            if (pName == null) continue;\n            if (!pName.equals(name)) continue;\n            PropertyNode var = new PropertyNode(pName, f.getModifiers(), getPropertyType(f), cn, null, null, null);\n            return var;\n        }\n\n        l = cn.getProperties();\n        for (Iterator iter = l.iterator(); iter.hasNext();) {\n            PropertyNode f = (PropertyNode) iter.next();\n            if (f.getName().equals(name)) return f;\n        }\n\n        Variable ret = findClassMember(cn.getSuperClass(), name);\n        if (ret != null) return ret;\n        return findClassMember(cn.getOuterClass(), name);\n    }","id":301,"modified_method":"private Variable findClassMember(ClassNode cn, String name) {\n        if (cn == null) return null;\n        if (cn.isScript()) {\n            return new DynamicVariable(name, false);\n        }\n\n        for (FieldNode fn : cn.getFields()) {\n            if (fn.getName().equals(name)) return fn;\n        }\n\n        for (MethodNode mn : cn.getMethods()) {\n            String pName = getPropertyName(mn);\n            if (pName != null && pName.equals(name))\n                return new PropertyNode(pName, mn.getModifiers(), getPropertyType(mn), cn, null, null, null);\n        }\n\n        for (PropertyNode pn : cn.getProperties()) {\n            if (pn.getName().equals(name)) return pn;\n        }\n\n        Variable ret = findClassMember(cn.getSuperClass(), name);\n        if (ret != null) return ret;\n        return findClassMember(cn.getOuterClass(), name);\n    }","commit_id":"73ef63a7c652000afb111919f8d7155d304667cc","url":"https://github.com/apache/groovy"},{"original_method":"private void checkOverloadingPrivateAndPublic(MethodNode node) {\n        if (isConstructor(node)) return;\n        List methods = currentClass.getMethods(node.getName());\n        boolean hasPrivate=false;\n        boolean hasPublic=false;\n        for (Iterator iter = methods.iterator(); iter.hasNext();) {\n            MethodNode element = (MethodNode) iter.next();\n            if (element == node) continue;\n            if (!element.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            int modifiers = element.getModifiers();\n            if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)){\n                hasPublic=true;\n            } else {\n                hasPrivate=true;\n            }\n        }\n        if (hasPrivate && hasPublic) {\n            addError(\"Mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden to avoid surprising behaviour. Renaming the private methods will solve the problem.\",node);\n        }\n    }","id":302,"modified_method":"private void checkOverloadingPrivateAndPublic(MethodNode node) {\n        if (isConstructor(node)) return;\n        boolean hasPrivate = false;\n        boolean hasPublic = false;\n        for (MethodNode method : currentClass.getMethods(node.getName())) {\n            if (method == node) continue;\n            if (!method.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            int modifiers = method.getModifiers();\n            if (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n                hasPublic = true;\n            } else {\n                hasPrivate = true;\n            }\n        }\n        if (hasPrivate && hasPublic) {\n            addError(\"Mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden to avoid surprising behaviour. Renaming the private methods will solve the problem.\", node);\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkMethodsForOverridingFinal(ClassNode cn) {\n        List methods = cn.getMethods();\n        for (Iterator cnIter = methods.iterator(); cnIter.hasNext();) {\n            MethodNode method = (MethodNode) cnIter.next();\n            Parameter[] params = method.getParameters();\n            List superMethods = cn.getSuperClass().getMethods(method.getName());\n            for (Iterator iter = superMethods.iterator(); iter.hasNext();) {\n                MethodNode superMethod = (MethodNode) iter.next();\n                Parameter[] superParams = superMethod.getParameters();\n                if (!hasEqualParameterTypes(params, superParams)) continue;\n                if (!Modifier.isFinal(superMethod.getModifiers())) break;\n                addInvalidUseOfFinalError(method, params, superMethod.getDeclaringClass());\n                return;\n            }\n        }\n    }","id":303,"modified_method":"private void checkMethodsForOverridingFinal(ClassNode cn) {\n        for (MethodNode method : cn.getMethods()) {\n            Parameter[] params = method.getParameters();\n            for (MethodNode superMethod : cn.getSuperClass().getMethods(method.getName())) {\n                Parameter[] superParams = superMethod.getParameters();\n                if (!hasEqualParameterTypes(params, superParams)) continue;\n                if (!Modifier.isFinal(superMethod.getModifiers())) break;\n                addInvalidUseOfFinalError(method, params, superMethod.getDeclaringClass());\n                return;\n            }\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkRepetitiveMethod(MethodNode node) {\n        if (isConstructor(node)) return;\n        List methods = currentClass.getMethods(node.getName());\n        for (Iterator iter = methods.iterator(); iter.hasNext();) {\n            MethodNode element = (MethodNode) iter.next();\n            if (element == node) continue;\n            if (!element.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            Parameter[] p1 = node.getParameters();\n            Parameter[] p2 = element.getParameters();\n            if (p1.length != p2.length) continue;\n            addErrorIfParamsAndReturnTypeEqual(p2, p1, node, element);\n        }\n    }","id":304,"modified_method":"private void checkRepetitiveMethod(MethodNode node) {\n        if (isConstructor(node)) return;\n        for (MethodNode method : currentClass.getMethods(node.getName())) {\n            if (method == node) continue;\n            if (!method.getDeclaringClass().equals(node.getDeclaringClass())) continue;\n            Parameter[] p1 = node.getParameters();\n            Parameter[] p2 = method.getParameters();\n            if (p1.length != p2.length) continue;\n            addErrorIfParamsAndReturnTypeEqual(p2, p1, node, method);\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"private void checkMethodsForIncorrectModifiers(ClassNode cn) {\n        if (!cn.isInterface()) return;\n        List methods = cn.getMethods();\n        for (Iterator cnIter = methods.iterator(); cnIter.hasNext();) {\n            MethodNode method = (MethodNode) cnIter.next();\n            if (Modifier.isFinal(method.getModifiers())) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be final. It is by definition abstract.\", method);\n            }\n            if (Modifier.isStatic(method.getModifiers()) && !isConstructor(method)) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be static. Only fields may be static in an interface.\", method);\n            }\n        }\n    }","id":305,"modified_method":"private void checkMethodsForIncorrectModifiers(ClassNode cn) {\n        if (!cn.isInterface()) return;\n        for (MethodNode method : cn.getMethods()) {\n            if (Modifier.isFinal(method.getModifiers())) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be final. It is by definition abstract.\", method);\n            }\n            if (Modifier.isStatic(method.getModifiers()) && !isConstructor(method)) {\n                addError(\"The \" + getDescription(method) + \" from \" + getDescription(cn) +\n                        \" must not be static. Only fields may be static in an interface.\", method);\n            }\n        }\n    }","commit_id":"2472e7e04d27d1fe63e57a15027371ddb589ab4b","url":"https://github.com/apache/groovy"},{"original_method":"/**\n\t * Update the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  is the input stream of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the company's logo image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(companyId);\n\t\t\n\t\tlong logoId = company.getLogoId();\n\t\t\n\t\tif (logoId <= 0) {\n\t\t\tlogoId = counterLocalService.increment();\n\n\t\t\tcompany.setLogoId(logoId);\n\t\t}\n\n\t\timageLocalService.updateImage(logoId, is);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","id":306,"modified_method":"/**\n\t * Update the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  is the input stream of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the company's logo image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = checkCompanyLogo(companyId);\n\n\t\timageLocalService.updateImage(company.getLogoId(), is);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","commit_id":"a058a760f60e16fd8144f667d23f3d5ac70947d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  file the file of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(companyId);\n\n\t\tlong logoId = company.getLogoId();\n\n\t\tif (logoId <= 0) {\n\t\t\tlogoId = counterLocalService.increment();\n\n\t\t\tcompany.setLogoId(logoId);\n\t\t}\n\n\t\timageLocalService.updateImage(logoId, file);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","id":307,"modified_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  file the file of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = checkCompanyLogo(companyId);\n\n\t\timageLocalService.updateImage(company.getLogoId(), file);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","commit_id":"a058a760f60e16fd8144f667d23f3d5ac70947d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  bytes the bytes of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(companyId);\n\n\t\tlong logoId = company.getLogoId();\n\n\t\tif (logoId <= 0) {\n\t\t\tlogoId = counterLocalService.increment();\n\n\t\t\tcompany.setLogoId(logoId);\n\t\t}\n\n\t\timageLocalService.updateImage(logoId, bytes);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","id":308,"modified_method":"/**\n\t * Updates the company's logo.\n\t *\n\t * @param  companyId the primary key of the company\n\t * @param  bytes the bytes of the company's logo image\n\t * @return the company with the primary key\n\t * @throws PortalException if the company's logo ID could not be found or if\n\t *         the logo's image was corrupted\n\t * @throws SystemException if a system exception occurred\n\t */\n\tpublic Company updateLogo(long companyId, byte[] bytes)\n\t\tthrows PortalException, SystemException {\n\n\t\tCompany company = checkCompanyLogo(companyId);\n\n\t\timageLocalService.updateImage(company.getLogoId(), bytes);\n\n\t\treturn companyPersistence.update(company, false);\n\t}","commit_id":"a058a760f60e16fd8144f667d23f3d5ac70947d4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SocialActivityFeedEntry interpret(\n\t\tSocialActivitySet activitySet, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(\n\t\t\tactivitySet.getClassNameId());\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(className);\n\n\t\tif (activityInterpreter != null) {\n\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\t\tactivityInterpreter.interpret(activitySet, themeDisplay);\n\n\t\t\tif (activityFeedEntry != null) {\n\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\treturn activityFeedEntry;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":309,"modified_method":"public SocialActivityFeedEntry interpret(\n\t\tSocialActivitySet activitySet, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(\n\t\t\t\tactivitySet.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activitySet, themeDisplay);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","commit_id":"d97c64e122d82f9121e5e75a2547d1d9996864e3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @param  themeDisplay the theme display needed by interpreters to create\n\t *         links and get localized text fragments\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tSocialActivity activity, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(activity.getClassNameId());\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(className);\n\n\t\tif (activityInterpreter != null) {\n\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\tactivityInterpreter.interpret(activity, themeDisplay);\n\n\t\t\tif (activityFeedEntry != null) {\n\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\treturn activityFeedEntry;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":310,"modified_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @param  themeDisplay the theme display needed by interpreters to create\n\t *         links and get localized text fragments\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tSocialActivity activity, ThemeDisplay themeDisplay) {\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)_activityInterpreters.get(\n\t\t\t\tactivity.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activity, themeDisplay);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","commit_id":"d97c64e122d82f9121e5e75a2547d1d9996864e3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivitySet activitySet,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tMap<String, SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(\n\t\t\t\tactivitySet.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activitySet, serviceContext);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","id":311,"modified_method":"public SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivitySet activitySet,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activitySet.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tList<SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(\n\t\t\tactivitySet.getClassNameId());\n\n\t\tfor (int i = 0; i < activityInterpreters.size(); i++) {\n\t\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(i);\n\n\t\t\tif (activityInterpreter.hasClassName(className)) {\n\t\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\t\tactivityInterpreter.interpret(activitySet, serviceContext);\n\n\t\t\t\tif (activityFeedEntry != null) {\n\t\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\t\treturn activityFeedEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"3eaabb70b9ad3d70a2fe8d753e9daeb3aae4e3b4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivity activity,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tMap<String, SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(\n\t\t\t\tactivity.getClassName());\n\n\t\tif (activityInterpreter == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\tactivityInterpreter.interpret(activity, serviceContext);\n\n\t\tif (activityFeedEntry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tactivityFeedEntry.setPortletId(activityInterpreter.getPortletId());\n\n\t\treturn activityFeedEntry;\n\t}","id":312,"modified_method":"/**\n\t * Creates a human readable activity feed entry for the activity using an\n\t * available compatible activity interpreter.\n\t *\n\t * <p>\n\t * This method finds the appropriate interpreter for the activity by going\n\t * through the available interpreters and asking them if they can handle the\n\t * asset type of the activity.\n\t * <\/p>\n\t *\n\t * @param  activity the activity to be translated to human readable form\n\t * @return the activity feed that is a human readable form of the activity\n\t *         record or <code>null<\/code> if a compatible interpreter is not\n\t *         found\n\t */\n\tpublic SocialActivityFeedEntry interpret(\n\t\tString selector, SocialActivity activity,\n\t\tServiceContext serviceContext) {\n\n\t\tHttpServletRequest request = serviceContext.getRequest();\n\n\t\tif (request == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\ttry {\n\t\t\tif (activity.getUserId() == themeDisplay.getDefaultUserId()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\tif (activity.getMirrorActivityId() > 0) {\n\t\t\tSocialActivity mirrorActivity = null;\n\n\t\t\ttry {\n\t\t\t\tmirrorActivity = socialActivityLocalService.getActivity(\n\t\t\t\t\tactivity.getMirrorActivityId());\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tif (mirrorActivity != null) {\n\t\t\t\tactivity = mirrorActivity;\n\t\t\t}\n\t\t}\n\n\t\tList<SocialActivityInterpreter> activityInterpreters =\n\t\t\t_activityInterpreters.get(selector);\n\n\t\tif (activityInterpreters == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(activity.getClassNameId());\n\n\t\tfor (int i = 0; i < activityInterpreters.size(); i++) {\n\t\t\tSocialActivityInterpreterImpl activityInterpreter =\n\t\t\t\t(SocialActivityInterpreterImpl)activityInterpreters.get(i);\n\n\t\t\tif (activityInterpreter.hasClassName(className)) {\n\t\t\t\tSocialActivityFeedEntry activityFeedEntry =\n\t\t\t\t\tactivityInterpreter.interpret(activity, serviceContext);\n\n\t\t\t\tif (activityFeedEntry != null) {\n\t\t\t\t\tactivityFeedEntry.setPortletId(\n\t\t\t\t\t\tactivityInterpreter.getPortletId());\n\n\t\t\t\t\treturn activityFeedEntry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"3eaabb70b9ad3d70a2fe8d753e9daeb3aae4e3b4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void disableFeature(DeserializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = new HashSet<String>();\n        }\n        disableFeatures.add(feature.name());\n    }","id":313,"modified_method":"public void disableFeature(DeserializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = feature.name();\n        } else {\n            disableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void disableFeature(SerializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = new HashSet<String>();\n        }\n        disableFeatures.add(feature.name());\n    }","id":314,"modified_method":"public void disableFeature(SerializationFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = feature.name();\n        } else {\n            disableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void disableFeature(MapperFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = new HashSet<String>();\n        }\n        disableFeatures.add(feature.name());\n    }","id":315,"modified_method":"public void disableFeature(MapperFeature feature) {\n        if (disableFeatures == null) {\n            disableFeatures = feature.name();\n        } else {\n            disableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void enableFeature(SerializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = new HashSet<String>();\n        }\n        enableFeatures.add(feature.name());\n    }","id":316,"modified_method":"public void enableFeature(SerializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = feature.name();\n        } else {\n            enableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void enableFeature(MapperFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = new HashSet<String>();\n        }\n        enableFeatures.add(feature.name());\n    }","id":317,"modified_method":"public void enableFeature(MapperFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = feature.name();\n        } else {\n            enableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"public void enableFeature(DeserializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = new HashSet<String>();\n        }\n        enableFeatures.add(feature.name());\n    }","id":318,"modified_method":"public void enableFeature(DeserializationFeature feature) {\n        if (enableFeatures == null) {\n            enableFeatures = feature.name();\n        } else {\n            enableFeatures += \",\" + feature.name();\n        }\n    }","commit_id":"654e03900a513f706fa82060d339926c83cc1ffd","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String getEncryptionKey() {\n        String value = EncryptionKey.value();\n        if (value == null) {\n            _configDepot.set(EncryptionKey, getBase64EncodedRandomKey(128));\n        }\n        return EncryptionKey.value();\n    }","id":319,"modified_method":"@Override\n    public String getEncryptionKey() {\n        String value = EncryptionKey.value();\n        if (value == null) {\n            _configDao.getValueAndInitIfNotExist(EncryptionKey.key(), EncryptionKey.category(), getBase64EncodedRandomKey(128),\n                    EncryptionKey.description());\n        }\n        return EncryptionKey.value();\n    }","commit_id":"b8ddbe8ffa5718c5ab5c9b3438467c284af0de50","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String getHashKey() {\n        String value = HashKey.value();\n        if (value == null) {\n            _configDepot.set(HashKey, getBase64EncodedRandomKey(128));\n        }\n\n        return HashKey.value();\n    }","id":320,"modified_method":"@Override\n    public String getHashKey() {\n        String value = HashKey.value();\n        if (value == null) {\n            _configDao.getValueAndInitIfNotExist(HashKey.key(), HashKey.category(), getBase64EncodedRandomKey(128), HashKey.description());\n        }\n\n        return HashKey.value();\n    }","commit_id":"b8ddbe8ffa5718c5ab5c9b3438467c284af0de50","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public String getEncryptionIV() {\n        String value = EncryptionIV.value();\n        if (value == null) {\n            _configDepot.set(EncryptionIV, getBase64EncodedRandomKey(128));\n        }\n        return EncryptionIV.value();\n    }","id":321,"modified_method":"@Override\n    public String getEncryptionIV() {\n        String value = EncryptionIV.value();\n        if (value == null) {\n            _configDao.getValueAndInitIfNotExist(EncryptionIV.key(), EncryptionIV.category(), getBase64EncodedRandomKey(128),\n                    EncryptionIV.description());\n        }\n        return EncryptionIV.value();\n    }","commit_id":"b8ddbe8ffa5718c5ab5c9b3438467c284af0de50","url":"https://github.com/apache/cloudstack"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtAnnotationEntry> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":322,"modified_method":"@NotNull\n    @Override\n    public Collection<KtAnnotationEntry> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtAnnotationEntry.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":323,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtFile> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":324,"modified_method":"@NotNull\n    @Override\n    public Collection<KtFile> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtFile.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":325,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":326,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":327,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":328,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":329,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":330,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":331,"modified_method":"@NotNull\n    @Override\n    public Collection<KtClassOrObject> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtClassOrObject.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":332,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":333,"modified_method":"@NotNull\n    @Override\n    public Collection<KtNamedFunction> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtNamedFunction.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":334,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String fqName, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, fqName, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return super.get(s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project));\n    }","id":335,"modified_method":"@NotNull\n    @Override\n    public Collection<KtProperty> get(@NotNull String s, @NotNull Project project, @NotNull GlobalSearchScope scope) {\n        return StubIndex.getElements(KEY, s, project, KotlinSourceFilterScope.sourcesAndLibraries(scope, project), KtProperty.class);\n    }","commit_id":"d0a4e542af509f4684358cdb99f21253f24ef5ea","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsMethodImpl clsMethod) {\n        return getJetDeclarationByClsElement(clsMethod);\n    }","id":336,"modified_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsMethodImpl clsMethod) {\n        JetDeclaration jetDeclaration = getJetDeclarationByClsElement(clsMethod);\n        if (jetDeclaration instanceof JetProperty) {\n            JetProperty sourceProperty = JetSourceNavigationHelper.getSourceProperty((JetProperty) jetDeclaration);\n            if (sourceProperty != null) {\n                return sourceProperty;\n            }\n        }\n        return jetDeclaration;\n    }","commit_id":"a86c3a5fa3c5bc09382257b45f2246fced85d8c0","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsClassImpl clsClass) {\n        return getJetDeclarationByClsElement(clsClass);\n    }","id":337,"modified_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsClassImpl clsClass) {\n        JetClass jetClass = (JetClass) getJetDeclarationByClsElement(clsClass);\n        if (jetClass != null) {\n            JetClass sourceClass = JetSourceNavigationHelper.getSourceClass(jetClass);\n            if (sourceClass != null) {\n                return sourceClass;\n            }\n        }\n        return jetClass;\n    }","commit_id":"2b52caf1feefeb8e2af433da91688b437c0cbedb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsFieldImpl clsField) {\n        return getJetDeclarationByClsElement(clsField);\n    }","id":338,"modified_method":"@Override\n    @Nullable\n    public PsiElement getNavigationElement(@NotNull ClsFieldImpl clsField) {\n        JetDeclaration jetDeclaration = getJetDeclarationByClsElement(clsField);\n        if (jetDeclaration instanceof JetProperty) {\n            JetDeclaration sourceProperty = JetSourceNavigationHelper.getSourceProperty((JetProperty) jetDeclaration);\n            if (sourceProperty != null) {\n                return sourceProperty;\n            }\n        }\n        return jetDeclaration;\n    }","commit_id":"d825fb25a0a57574e7a61662d144e5b1993611f1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private Map<String, ModelService> getGlobalServiceMap() {\n        Map<String, ModelService> serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n        if (serviceMap == null) {\n            synchronized (this) {\n                serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n                if (serviceMap == null) {\n                    serviceMap = FastMap.newInstance();\n\n                    Element rootElement;\n\n                    try {\n                        rootElement = ServiceConfigUtil.getXmlRootElement();\n                    } catch (GenericConfigException e) {\n                        Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n                        return null;\n                    }\n\n                    for (Element globalServicesElement: UtilXml.childElementList(rootElement, \"global-services\")) {\n                        ResourceHandler handler = new MainResourceHandler(\n                                ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, globalServicesElement);\n\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(handler, this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n                    \n                    // get all of the component resource model stuff, ie specified in each ofbiz-component.xml file\n                    List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"model\");\n                    Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n                    while (componentResourceInfoIter.hasNext()) {\n                        ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(componentResourceInfo.createResourceHandler(), this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n\n                    if (serviceMap != null) {\n                        modelServiceMapByDispatcher.put(GLOBAL_KEY, serviceMap);\n                        ServiceEcaUtil.reloadConfig();\n                    }\n                }\n            }\n        }\n\n        return serviceMap;\n    }","id":339,"modified_method":"private Map<String, ModelService> getGlobalServiceMap() {\n        Map<String, ModelService> serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n        if (serviceMap == null) {\n            synchronized (this) {\n                serviceMap = modelServiceMapByDispatcher.get(GLOBAL_KEY);\n                if (serviceMap == null) {\n                    serviceMap = FastMap.newInstance();\n\n                    Element rootElement;\n\n                    try {\n                        rootElement = ServiceConfigUtil.getXmlRootElement();\n                    } catch (GenericConfigException e) {\n                        Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n                        return null;\n                    }\n\n                    for (Element globalServicesElement: UtilXml.childElementList(rootElement, \"global-services\")) {\n                        ResourceHandler handler = new MainResourceHandler(\n                                ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, globalServicesElement);\n\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(handler, this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n                    \n                    // get all of the component resource model stuff, ie specified in each ofbiz-component.xml file\n                    for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"model\")) {\n                        Map<String, ModelService> servicesMap = ModelServiceReader.getModelServiceMap(componentResourceInfo.createResourceHandler(), this);\n                        if (servicesMap != null) {\n                            serviceMap.putAll(servicesMap);\n                        }\n                    }\n\n                    if (serviceMap != null) {\n                        modelServiceMapByDispatcher.put(GLOBAL_KEY, serviceMap);\n                        ServiceEcaUtil.reloadConfig();\n                    }\n                }\n            }\n        }\n\n        return serviceMap;\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceEcasElement: UtilXml.childElementList(rootElement, \"service-ecas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceEcasElement);\n            addEcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"eca\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addEcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","id":340,"modified_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceEcasElement: UtilXml.childElementList(rootElement, \"service-ecas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceEcasElement);\n            addEcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"eca\")) {\n            addEcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void readConfig() {\n        Element rootElement = null;\n\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceGroupElement: UtilXml.childElementList(rootElement, \"service-groups\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceGroupElement);\n            addGroupDefinitions(handler);\n        }\n\n        // get all of the component resource group stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"group\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addGroupDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","id":341,"modified_method":"public static void readConfig() {\n        Element rootElement = null;\n\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceGroupElement: UtilXml.childElementList(rootElement, \"service-groups\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceGroupElement);\n            addGroupDefinitions(handler);\n        }\n\n        // get all of the component resource group stuff, ie specified in each ofbiz-component.xml file\n        for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"group\")) {\n            addGroupDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceMcasElement: UtilXml.childElementList(rootElement, \"service-mcas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceMcasElement);\n            addMcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        List componentResourceInfos = ComponentConfig.getAllServiceResourceInfos(\"mca\");\n        Iterator componentResourceInfoIter = componentResourceInfos.iterator();\n        while (componentResourceInfoIter.hasNext()) {\n            ComponentConfig.ServiceResourceInfo componentResourceInfo = (ComponentConfig.ServiceResourceInfo) componentResourceInfoIter.next();\n            addMcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","id":342,"modified_method":"public static void readConfig() {\n        Element rootElement = null;\n        try {\n            rootElement = ServiceConfigUtil.getXmlRootElement();\n        } catch (GenericConfigException e) {\n            Debug.logError(e, \"Error getting Service Engine XML root element\", module);\n            return;\n        }\n\n        for (Element serviceMcasElement: UtilXml.childElementList(rootElement, \"service-mcas\")) {\n            ResourceHandler handler = new MainResourceHandler(ServiceConfigUtil.SERVICE_ENGINE_XML_FILENAME, serviceMcasElement);\n            addMcaDefinitions(handler);\n        }\n\n        // get all of the component resource eca stuff, ie specified in each ofbiz-component.xml file\n        for (ComponentConfig.ServiceResourceInfo componentResourceInfo: ComponentConfig.getAllServiceResourceInfos(\"mca\")) {\n            addMcaDefinitions(componentResourceInfo.createResourceHandler());\n        }\n    }","commit_id":"306cee30743ac841e77c36de5efa3be3f3881e55","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tif(orderAsc) {\n\t\t\t\tcriteria.addOrder(Order.asc(orderBy));\n\t\t\t} else {\n\t\t\t\tcriteria.addOrder(Order.desc(orderBy));\n\t\t\t}\n\t\t}\n\t}","id":343,"modified_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tOrder o;\n\t\t\tif(orderAsc) {\n\t\t\t    o = Order.asc(orderBy);\n\t\t\t} else {\n\t\t\t\to = Order.desc(orderBy);\n\t\t\t}\n\t\t\t// criteria.addOrder(o);\n\t\t\tm_ordering.add(o);\n\t\t}\n\t}","commit_id":"fcd55b82d45af13270915d5757f0652c89c438d5","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tif(orderAsc) {\n\t\t\t\tcriteria.addOrder(Order.asc(orderBy));\n\t\t\t} else {\n\t\t\t\tcriteria.addOrder(Order.desc(orderBy));\n\t\t\t}\n\t\t}\n\t}","id":344,"modified_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tOrder o;\n\t\t\tif(orderAsc) {\n\t\t\t    o = Order.asc(orderBy);\n\t\t\t} else {\n\t\t\t\to = Order.desc(orderBy);\n\t\t\t}\n\t\t\t// criteria.addOrder(o);\n\t\t\tm_ordering.add(o);\n\t\t}\n\t}","commit_id":"3ab9231012ced9e8a286ea11f79921f90de01b75","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tif(orderAsc) {\n\t\t\t\tcriteria.addOrder(Order.asc(orderBy));\n\t\t\t} else {\n\t\t\t\tcriteria.addOrder(Order.desc(orderBy));\n\t\t\t}\n\t\t}\n\t}","id":345,"modified_method":"/**\n\t * Does ordering processing; pulled out to a separate method for visual clarity.  Configures ordering as defined in addFiltersToCriteria\n\t * @param params - set of values to look in for the \"order\" and \"orderBy\" values\n\t * @param criteria - the criteria object which will be updated with ordering configuration\n\t */\n\tprotected void addOrdering(MultivaluedMap<java.lang.String, java.lang.String> params, OnmsCriteria criteria) {\n\t    if(params.containsKey(\"orderBy\")) {\n\t\t\tString orderBy=params.getFirst(\"orderBy\");\n\t\t\tparams.remove(\"orderBy\");\n\t\t\tboolean orderAsc=true;\n\t\t\tif(params.containsKey(\"order\")) {\n\t\t\t\tif(\"desc\".equalsIgnoreCase(params.getFirst(\"order\"))) {\n\t\t\t\t\torderAsc=false;\n\t\t\t\t}\n\t\t\t\tparams.remove(\"order\");\n\t\t\t}\n\t\t\tOrder o;\n\t\t\tif(orderAsc) {\n\t\t\t    o = Order.asc(orderBy);\n\t\t\t} else {\n\t\t\t\to = Order.desc(orderBy);\n\t\t\t}\n\t\t\t// criteria.addOrder(o);\n\t\t\tm_ordering.add(o);\n\t\t}\n\t}","commit_id":"489ad8f73e9ae6c000192a46986c505e41de652e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<AegisType> getDependencies() {\n        Set<AegisType> deps = new HashSet<AegisType>();\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        for (QName name : inf.getAttributes()) {\n            deps.add(inf.getType(name));\n        }\n\n        for (QName name : inf.getElements()) {\n            if (inf.isExtension()\n                && inf.getPropertyDescriptorFromMappedName(name).getReadMethod().getDeclaringClass() != inf\n                    .getTypeClass()) {\n                continue;\n            }\n            deps.add(inf.getType(name));\n        }\n\n        /*\n         * Automagically add chain of superclasses if this is an an extension.\n         */\n        AegisType sooperType = getSuperType();\n        if (sooperType != null) {\n            deps.add(sooperType);\n        }\n\n        return deps;\n    }","id":346,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<AegisType> getDependencies() {\n        Set<AegisType> deps = new HashSet<AegisType>();\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        for (QName name : inf.getAttributes()) {\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n            deps.add(inf.getType(name));\n        }\n\n        for (QName name : inf.getElements()) {\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n            deps.add(inf.getType(name));\n        }\n\n        /*\n         * Automagically add chain of superclasses if this is an an extension.\n         */\n        AegisType sooperType = getSuperType();\n        if (sooperType != null) {\n            deps.add(sooperType);\n        }\n\n        return deps;\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"private void writeObjectInternal(Object object, MessageWriter writer, Context context,\n                                     boolean wroteXsiType) throws DatabindingException {\n        if (object == null) {\n            return;\n        }\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        if (!wroteXsiType && object.getClass() == getTypeClass() && context.isWriteXsiTypes()) {\n            writer.writeXsiType(getSchemaType());\n        }\n\n        for (QName name : inf.getAttributes()) {\n\n            Object value = readProperty(object, name);\n            if (value != null) {\n                AegisType type = getType(inf, name);\n\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                MessageWriter cwriter = writer.getAttributeWriter(name);\n\n                type.writeObject(value, cwriter, context);\n\n                cwriter.close();\n            }\n        }\n\n        if (inf.isExtension()) {\n            AegisType t = getSuperType();\n            if (t != null) {\n                t.writeObject(object, writer, context);\n            }\n        }\n\n        for (QName name : inf.getElements()) {\n\n            if (inf.isExtension()\n                && inf.getPropertyDescriptorFromMappedName(name).getReadMethod().getDeclaringClass() != inf\n                    .getTypeClass()) {\n                continue;\n            }\n            Object value = readProperty(object, name);\n\n            AegisType defaultType = getType(inf, name);\n            AegisType type = TypeUtil.getWriteType(context.getGlobalContext(), value, defaultType);\n\n            // Write the value if it is not null.\n            if (value != null) {\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                writeElement(name, value, type, writer, context);\n            } else if (inf.isNillable(name)) {\n                MessageWriter cwriter = getWriter(writer, name, type);\n\n                // Write the xsi:nil if it is null.\n                cwriter.writeXsiNil();\n\n                cwriter.close();\n            }\n        }\n    }","id":347,"modified_method":"private void writeObjectInternal(Object object, MessageWriter writer, Context context,\n                                     boolean wroteXsiType) throws DatabindingException {\n        if (object == null) {\n            return;\n        }\n\n        BeanTypeInfo inf = getTypeInfo();\n\n        if (!wroteXsiType && object.getClass() == getTypeClass() && context.isWriteXsiTypes()) {\n            writer.writeXsiType(getSchemaType());\n        }\n\n        for (QName name : inf.getAttributes()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            Object value = readProperty(object, name);\n            if (value != null) {\n                AegisType type = getType(inf, name);\n\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                MessageWriter cwriter = writer.getAttributeWriter(name);\n\n                type.writeObject(value, cwriter, context);\n\n                cwriter.close();\n            }\n        }\n\n        if (inf.isExtension()) {\n            AegisType t = getSuperType();\n            if (t != null) {\n                t.writeObject(object, writer, context);\n            }\n        }\n\n        for (QName name : inf.getElements()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            Object value = readProperty(object, name);\n\n            AegisType defaultType = getType(inf, name);\n            AegisType type = TypeUtil.getWriteType(context.getGlobalContext(), value, defaultType);\n\n            // Write the value if it is not null.\n            if (value != null) {\n                if (type == null) {\n                    throw new DatabindingException(\"Couldn't find type for \" + value.getClass()\n                                                   + \" for property \" + name);\n                }\n\n                writeElement(name, value, type, writer, context);\n            } else if (inf.isNillable(name)) {\n                MessageWriter cwriter = getWriter(writer, name, type);\n\n                // Write the xsi:nil if it is null.\n                cwriter.writeXsiNil();\n\n                cwriter.close();\n            }\n        }\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void writeSchema(XmlSchema root) {\n        BeanTypeInfo inf = getTypeInfo();\n        XmlSchemaComplexType complex = new XmlSchemaComplexType(root, true);\n        complex.setName(getSchemaType().getLocalPart());\n\n        AegisType sooperType = getSuperType();\n\n        /*\n         * See Java Virtual Machine specification:\n         * http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#75734\n         */\n        if (((inf.getTypeClass().getModifiers() & Modifier.ABSTRACT) != 0)\n            && !inf.getTypeClass().isInterface()) {\n            complex.setAbstract(true);\n        }\n\n        XmlSchemaSequence sequence = new XmlSchemaSequence();\n        /*\n         * Decide if we're going to extend another type. If we are going to defer, then make sure that we\n         * extend the type for our superclass.\n         */\n        boolean isExtension = inf.isExtension();\n\n        if (isExtension && sooperType != null) {\n            // if sooperType is null, things are confused.\n            XmlSchemaComplexContent content = new XmlSchemaComplexContent();\n            complex.setContentModel(content);\n            XmlSchemaComplexContentExtension extension = new XmlSchemaComplexContentExtension();\n            content.setContent(extension);\n            extension.setBaseTypeName(sooperType.getSchemaType());\n            extension.setParticle(sequence);\n        } else {\n            complex.setParticle(sequence);\n        }\n\n        boolean needXmime = false;\n        boolean needUtilityTypes = false;\n\n        // Write out schema for elements\n        for (QName name : inf.getElements()) {\n\n            if (isExtension) {\n                PropertyDescriptor pd = inf.getPropertyDescriptorFromMappedName(name);\n\n                // assert pd.getReadMethod() != null && pd.getWriteMethod() != null;\n\n                if (pd.getReadMethod().getDeclaringClass() != inf.getTypeClass()) {\n                    continue;\n                }\n            }\n\n            XmlSchemaElement element = new XmlSchemaElement(root, false);\n            element.setName(name.getLocalPart());\n            sequence.getItems().add(element);\n\n            AegisType type = getType(inf, name);\n            if (type.isFlatArray()) {\n                // ok, we need some tricks here\n                element.setMinOccurs(type.getMinOccurs());\n                element.setMaxOccurs(type.getMaxOccurs());\n                // for now, assume ArrayType. Look at lists or more general solutions later.\n                ArrayType aType = (ArrayType)type;\n                type = aType.getComponentType();\n                element.setNillable(type.isNillable());\n            } else {\n                if (AbstractTypeCreator.\n                    HTTP_CXF_APACHE_ORG_ARRAYS.equals(type.getSchemaType().getNamespaceURI())) {\n                    XmlSchemaUtils.addImportIfNeeded(root, AbstractTypeCreator.HTTP_CXF_APACHE_ORG_ARRAYS);\n                }\n            }\n            writeTypeReference(name, element, type, root);\n            needXmime |= type.usesXmime();\n            needUtilityTypes |= type.usesUtilityTypes();\n\n        }\n\n        if (needXmime) {\n            addXmimeToSchema(root);\n        }\n\n        if (needUtilityTypes) {\n            AegisContext.addUtilityTypesToSchema(root);\n        }\n\n        /**\n         * if future proof then add <xsd:any/> element\n         */\n        if (inf.isExtensibleElements()) {\n            XmlSchemaAny any = new XmlSchemaAny();\n            any.setMinOccurs(0);\n            any.setMaxOccurs(Long.MAX_VALUE);\n            sequence.getItems().add(any);\n        }\n\n        // Write out schema for attributes\n        for (QName name : inf.getAttributes()) {\n            XmlSchemaAttribute attribute = new XmlSchemaAttribute(root, false);\n            complex.getAttributes().add(attribute);\n            attribute.setName(name.getLocalPart());\n            AegisType type = getType(inf, name);\n            attribute.setSchemaTypeName(type.getSchemaType());\n            String ns = name.getNamespaceURI();\n            if (!ns.equals(root.getTargetNamespace())) {\n                XmlSchemaUtils.addImportIfNeeded(root, ns);\n            }\n        }\n\n        /**\n         * If extensible attributes then add <xsd:anyAttribute/>\n         */\n        if (inf.isExtensibleAttributes()) {\n            complex.setAnyAttribute(new XmlSchemaAnyAttribute());\n        }\n    }","id":348,"modified_method":"@Override\n    public void writeSchema(XmlSchema root) {\n        BeanTypeInfo inf = getTypeInfo();\n        XmlSchemaComplexType complex = new XmlSchemaComplexType(root, true);\n        complex.setName(getSchemaType().getLocalPart());\n\n        AegisType sooperType = getSuperType();\n\n        /*\n         * See Java Virtual Machine specification:\n         * http://java.sun.com/docs/books/vmspec/2nd-edition/html/ClassFile.doc.html#75734\n         */\n        if (((inf.getTypeClass().getModifiers() & Modifier.ABSTRACT) != 0)\n            && !inf.getTypeClass().isInterface()) {\n            complex.setAbstract(true);\n        }\n\n        XmlSchemaSequence sequence = new XmlSchemaSequence();\n        /*\n         * Decide if we're going to extend another type. If we are going to defer, then make sure that we\n         * extend the type for our superclass.\n         */\n        boolean isExtension = inf.isExtension();\n\n        if (isExtension && sooperType != null) {\n            // if sooperType is null, things are confused.\n            XmlSchemaComplexContent content = new XmlSchemaComplexContent();\n            complex.setContentModel(content);\n            XmlSchemaComplexContentExtension extension = new XmlSchemaComplexContentExtension();\n            content.setContent(extension);\n            extension.setBaseTypeName(sooperType.getSchemaType());\n            extension.setParticle(sequence);\n        } else {\n            complex.setParticle(sequence);\n        }\n\n        boolean needXmime = false;\n        boolean needUtilityTypes = false;\n\n        // Write out schema for elements\n        for (QName name : inf.getElements()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            XmlSchemaElement element = new XmlSchemaElement(root, false);\n            element.setName(name.getLocalPart());\n            sequence.getItems().add(element);\n\n            AegisType type = getType(inf, name);\n            if (type.isFlatArray()) {\n                // ok, we need some tricks here\n                element.setMinOccurs(type.getMinOccurs());\n                element.setMaxOccurs(type.getMaxOccurs());\n                // for now, assume ArrayType. Look at lists or more general solutions later.\n                ArrayType aType = (ArrayType)type;\n                type = aType.getComponentType();\n                element.setNillable(type.isNillable());\n            } else {\n                if (AbstractTypeCreator.\n                    HTTP_CXF_APACHE_ORG_ARRAYS.equals(type.getSchemaType().getNamespaceURI())) {\n                    XmlSchemaUtils.addImportIfNeeded(root, AbstractTypeCreator.HTTP_CXF_APACHE_ORG_ARRAYS);\n                }\n            }\n            writeTypeReference(name, element, type, root);\n            needXmime |= type.usesXmime();\n            needUtilityTypes |= type.usesUtilityTypes();\n\n        }\n\n        if (needXmime) {\n            addXmimeToSchema(root);\n        }\n\n        if (needUtilityTypes) {\n            AegisContext.addUtilityTypesToSchema(root);\n        }\n\n        /**\n         * if future proof then add <xsd:any/> element\n         */\n        if (inf.isExtensibleElements()) {\n            XmlSchemaAny any = new XmlSchemaAny();\n            any.setMinOccurs(0);\n            any.setMaxOccurs(Long.MAX_VALUE);\n            sequence.getItems().add(any);\n        }\n\n        // Write out schema for attributes\n        for (QName name : inf.getAttributes()) {\n\n            if (isInheritedProperty(inf, name)) {\n                continue;\n            }\n\n            XmlSchemaAttribute attribute = new XmlSchemaAttribute(root, false);\n            complex.getAttributes().add(attribute);\n            attribute.setName(name.getLocalPart());\n            AegisType type = getType(inf, name);\n            attribute.setSchemaTypeName(type.getSchemaType());\n            String ns = name.getNamespaceURI();\n            if (!ns.equals(root.getTargetNamespace())) {\n                XmlSchemaUtils.addImportIfNeeded(root, ns);\n            }\n        }\n\n        /**\n         * If extensible attributes then add <xsd:anyAttribute/>\n         */\n        if (inf.isExtensibleAttributes()) {\n            complex.setAnyAttribute(new XmlSchemaAnyAttribute());\n        }\n    }","commit_id":"37fa0f860fb9cea02de8a792567e76ff2dc6627e","url":"https://github.com/apache/cxf"},{"original_method":"@Override public void writeTo(StreamOutput out) throws IOException {\n        out.writeUTF(nodeId);\n        out.writeUTF(index);\n        out.writeVInt(shardId);\n    }","id":349,"modified_method":"@Override public void writeTo(StreamOutput out) throws IOException {\n        if (nodeId == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(nodeId);\n        }\n        out.writeUTF(index);\n        out.writeVInt(shardId);\n    }","commit_id":"ba725f8986463d41d14fd331b82702ab65a2e87e","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void writeTo(DataOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeUTF(type);\n        out.writeUTF(id);\n        out.writeInt(source.length);\n        out.write(source);\n        out.writeByte(opType.id());\n    }","id":350,"modified_method":"@Override public void writeTo(DataOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeUTF(type);\n        if (id == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            out.writeUTF(id);\n        }\n        out.writeInt(source.length);\n        out.write(source);\n        out.writeByte(opType.id());\n    }","commit_id":"948f0ef0da3042d6f98c67e602600f209cf6ae08","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            out.writeUTF(state_id);\n        }","id":351,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            if(state_id == null) {\n                out.writeBoolean(false);\n            }\n            else {\n                out.writeBoolean(true);\n                out.writeUTF(state_id);\n            }\n        }","commit_id":"93efa0ef46c41f8e4ebda2e451782b0aad89f0f5","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            out.writeUTF(state_id);\n        }","id":352,"modified_method":"public void writeExternal(ObjectOutput out) throws IOException {\n            out.writeObject(sender);\n            out.writeLong(id);\n            out.writeByte(type);\n            out.writeObject(my_digest);\n            if(state_id == null) {\n                out.writeBoolean(false);\n            }\n            else {\n                out.writeBoolean(true);\n                out.writeUTF(state_id);\n            }\n        }","commit_id":"82377374eaab68038ac7920b17b1cf235f0b7b10","url":"https://github.com/belaban/JGroups"},{"original_method":"public void processAllFilesWithWord(String word, GlobalSearchScope scope, Processor<PsiFile> processor, final boolean caseSensitively) {\n    PsiFile[] files = myManager.getCacheManager().getFilesWithWord(word, UsageSearchContext.IN_CODE, scope, caseSensitively);\n\n    for (PsiFile file : files) {\n      if (!processor.process(file)) return;\n    }\n  }","id":353,"modified_method":"public void processAllFilesWithWord(String word, GlobalSearchScope scope, Processor<PsiFile> processor, final boolean caseSensitively) {\n    myManager.getCacheManager().processFilesWithWord(processor,word, UsageSearchContext.IN_CODE, scope, caseSensitively);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processAllFilesWithWordInComments(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    PsiFile[] files = myManager.getCacheManager().getFilesWithWord(word, UsageSearchContext.IN_COMMENTS, scope, true);\n\n    for (PsiFile file : files) {\n      if (!processor.process(file)) return;\n    }\n  }","id":354,"modified_method":"public void processAllFilesWithWordInComments(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    myManager.getCacheManager().processFilesWithWord(processor, word, UsageSearchContext.IN_COMMENTS, scope, true);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processAllFilesWithWordInLiterals(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    PsiFile[] files = myManager.getCacheManager().getFilesWithWord(word, UsageSearchContext.IN_STRINGS, scope, true);\n\n    for (PsiFile file : files) {\n      if (!processor.process(file)) return;\n    }\n  }","id":355,"modified_method":"public void processAllFilesWithWordInLiterals(String word, GlobalSearchScope scope, Processor<PsiFile> processor) {\n    myManager.getCacheManager().processFilesWithWord(processor, word, UsageSearchContext.IN_STRINGS, scope, true);\n  }","commit_id":"508cfe6bc74ef46fc1d68b291a19eb12d4f8e815","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateless bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSLSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SLSBImplementingSessionBean slsb = (SLSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SLSBImplementingSessionBean.class.getSimpleName() + \"!\" + SLSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"SessionContext was not injectd in stateless bean\", slsb.wasSessionContextInjected());\n    }","id":356,"modified_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateless bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSLSB() throws Exception {\n        final SLSBImplementingSessionBean slsb = lookup(SLSBImplementingSessionBean.class);\n        Assert.assertTrue(\"SessionContext was not injectd in stateless bean\", slsb.wasSessionContextInjected());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateful bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSFSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SFSBImplementingSessionBean sfsb = (SFSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SFSBImplementingSessionBean.class.getSimpleName() + \"!\" + SFSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"SessionContext was not injectd in stateful bean\", sfsb.wasSessionContextInjected());\n    }","id":357,"modified_method":"/**\n     * Tests that a {@link javax.ejb.SessionContext} is injected into a stateful bean, via the @Resource annotation\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSessionContextInjectionOnSFSB() throws Exception {\n        final SFSBImplementingSessionBean sfsb = lookup(SFSBImplementingSessionBean.class);\n        Assert.assertTrue(\"SessionContext was not injectd in stateful bean\", sfsb.wasSessionContextInjected());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateful\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSFSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SFSBImplementingSessionBean sfsb = (SFSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SFSBImplementingSessionBean.class.getSimpleName() + \"!\" + SFSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateful bean implementing javax.ejb.SessionBean\", sfsb.wasSetSessionContextMethodInvoked());\n    }","id":358,"modified_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateful\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSFSB() throws Exception {\n        final SFSBImplementingSessionBean sfsb = lookup(SFSBImplementingSessionBean.class);\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateful bean implementing javax.ejb.SessionBean\", \n                sfsb.wasSetSessionContextMethodInvoked());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateless\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSLSB() throws Exception {\n        final Context ctx = new InitialContext();\n        final SLSBImplementingSessionBean slsb = (SLSBImplementingSessionBean) ctx.lookup(\"java:module/\" + SLSBImplementingSessionBean.class.getSimpleName() + \"!\" + SLSBImplementingSessionBean.class.getName());\n\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateless bean implementing javax.ejb.SessionBean\", slsb.wasSetSessionContextMethodInvoked());\n    }","id":359,"modified_method":"/**\n     * Tests that {@link javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)} was invoked on a stateless\n     * session bean, implementing the {@link javax.ejb.SessionBean} interface\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSetSessionContextOnSLSB() throws Exception {\n        final SLSBImplementingSessionBean slsb = lookup(SLSBImplementingSessionBean.class);\n        Assert.assertTrue(\"setSessionContext(SessionContext) method was not invoked on a stateless bean implementing javax.ejb.SessionBean\", \n                slsb.wasSetSessionContextMethodInvoked());\n    }","commit_id":"82cd1acb76a45b6d0e05e42e5824ce50db27e77c","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"concept\", false) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_24().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n    }\n  }","id":360,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_24().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"concept\", false) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_27().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n    }\n  }","id":361,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_27().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n  }","commit_id":"8cc10b5cb1dd413669a0a0f3fd1d739dffc7df05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(SNode argument) {\n    RulesFunctions.fun_check_isAppliedTo_Node(argument);\n    if(!((SLinkOperations.getTarget(argument, \"concept\", false) == null))) {\n      TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_23().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n    }\n  }","id":362,"modified_method":"public void applyRule(SNode argument) {\n    RulesUtil.checkAppliedCorrectly_generic(argument);\n    TypeChecker.getInstance().getRuntimeSupport().givetype(new QuotationClass_23().createNode(SLinkOperations.getTarget(argument, \"concept\", false)), argument);\n  }","commit_id":"de417424c372d0c98b52ceaee072bf257ec3c43a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().first().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","id":363,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            Pair<Master, Machine> master = broker.getMaster();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch\n                IdAllocation allocation = master.first().allocateIds( idType );\n                allocationMaster = master.other().getMachineId();\n                nextId = storeLocally( allocation );\n            }\n            else\n            {\n                assert master.other().getMachineId() == allocationMaster;\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"497b437d0d5f76ad815a74c78bb4c07f8b80bdaf","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().first().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","id":364,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            Pair<Master, Machine> master = broker.getMaster();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch\n                IdAllocation allocation = master.first().allocateIds( idType );\n                allocationMaster = master.other().getMachineId();\n                nextId = storeLocally( allocation );\n            }\n            else\n            {\n                assert master.other().getMachineId() == allocationMaster;\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"e2fadd1d388c19b991c017c1bdbe6781328ffd19","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch \n                IdAllocation allocation = broker.getMaster().first().allocateIds( idType );\n                nextId = storeLocally( allocation );\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","id":365,"modified_method":"public synchronized long nextId()\n    {\n        try\n        {\n            long nextId = nextLocalId();\n            Pair<Master, Machine> master = broker.getMaster();\n            if ( nextId == VALUE_REPRESENTING_NULL )\n            {\n                // If we dont have anymore grabbed ids from master, grab a bunch\n                IdAllocation allocation = master.first().allocateIds( idType );\n                allocationMaster = master.other().getMachineId();\n                nextId = storeLocally( allocation );\n            }\n            else\n            {\n                assert master.other().getMachineId() == allocationMaster;\n            }\n            return nextId;\n        }\n        catch ( ZooKeeperException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n        catch ( HaCommunicationException e )\n        {\n            receiver.newMaster( null, e );\n            throw e;\n        }\n    }","commit_id":"1e850c9fd0abe0b3185d31fb350f9f7ed027e7da","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n\t * Resolve the constructor arguments for this bean into the resolvedValues object.\n\t * This may involve looking up other beans.\n\t * <p>This method is also used for handling invocations of static factory methods.\n\t */\n\tprivate int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,\n\t\t\tConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {\n\n\t\tTypeConverter converter = (this.beanFactory.getCustomTypeConverter() != null ?\n\t\t\t\tthis.beanFactory.getCustomTypeConverter() : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\n\t\tint minNrOfArgs = cargs.getArgumentCount();\n\n\t\tfor (Map.Entry<Integer, ConstructorArgumentValues.ValueHolder> entry : cargs.getIndexedArgumentValues().entrySet()) {\n\t\t\tint index = entry.getKey();\n\t\t\tif (index < 0) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid constructor argument index: \" + index);\n\t\t\t}\n\t\t\tif (index > minNrOfArgs) {\n\t\t\t\tminNrOfArgs = index + 1;\n\t\t\t}\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder = entry.getValue();\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\tfor (ConstructorArgumentValues.ValueHolder valueHolder : cargs.getGenericArgumentValues()) {\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addGenericArgumentValue(resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\treturn minNrOfArgs;\n\t}","id":366,"modified_method":"/**\n\t * Resolve the constructor arguments for this bean into the resolvedValues object.\n\t * This may involve looking up other beans.\n\t * <p>This method is also used for handling invocations of static factory methods.\n\t */\n\tprivate int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,\n\t\t\tConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {\n\n\t\tTypeConverter customConverter = this.beanFactory.getCustomTypeConverter();\n\t\tTypeConverter converter = (customConverter != null ? customConverter : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\n\t\tint minNrOfArgs = cargs.getArgumentCount();\n\n\t\tfor (Map.Entry<Integer, ConstructorArgumentValues.ValueHolder> entry : cargs.getIndexedArgumentValues().entrySet()) {\n\t\t\tint index = entry.getKey();\n\t\t\tif (index < 0) {\n\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Invalid constructor argument index: \" + index);\n\t\t\t}\n\t\t\tif (index > minNrOfArgs) {\n\t\t\t\tminNrOfArgs = index + 1;\n\t\t\t}\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder = entry.getValue();\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addIndexedArgumentValue(index, resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\tfor (ConstructorArgumentValues.ValueHolder valueHolder : cargs.getGenericArgumentValues()) {\n\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\tresolvedValues.addGenericArgumentValue(valueHolder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject resolvedValue =\n\t\t\t\t\t\tvalueResolver.resolveValueIfNecessary(\"constructor argument\", valueHolder.getValue());\n\t\t\t\tConstructorArgumentValues.ValueHolder resolvedValueHolder =\n\t\t\t\t\t\tnew ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());\n\t\t\t\tresolvedValueHolder.setSource(valueHolder);\n\t\t\t\tresolvedValues.addGenericArgumentValue(resolvedValueHolder);\n\t\t\t}\n\t\t}\n\n\t\treturn minNrOfArgs;\n\t}","commit_id":"725fb3219f7480182f220848aa8d72d464d8b801","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Resolve the prepared arguments stored in the given bean definition.\n\t */\n\tprivate Object[] resolvePreparedArguments(\n\t\t\tString beanName, RootBeanDefinition mbd, BeanWrapper bw, Executable executable, Object[] argsToResolve) {\n\n\t\tClass<?>[] paramTypes = executable.getParameterTypes();\n\t\tTypeConverter converter = (this.beanFactory.getCustomTypeConverter() != null ?\n\t\t\t\tthis.beanFactory.getCustomTypeConverter() : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\tObject[] resolvedArgs = new Object[argsToResolve.length];\n\t\tfor (int argIndex = 0; argIndex < argsToResolve.length; argIndex++) {\n\t\t\tObject argValue = argsToResolve[argIndex];\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, argIndex);\n\t\t\tGenericTypeResolver.resolveParameterType(methodParam, executable.getDeclaringClass());\n\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t}\n\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"constructor argument\", argValue);\n\t\t\t}\n\t\t\telse if (argValue instanceof String) {\n\t\t\t\targValue = this.beanFactory.evaluateBeanDefinitionString((String) argValue, mbd);\n\t\t\t}\n\t\t\tClass<?> paramType = paramTypes[argIndex];\n\t\t\ttry {\n\t\t\t\tresolvedArgs[argIndex] = converter.convertIfNecessary(argValue, paramType, methodParam);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\"Could not convert argument value of type [\" + ObjectUtils.nullSafeClassName(argValue) +\n\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs;\n\t}","id":367,"modified_method":"/**\n\t * Resolve the prepared arguments stored in the given bean definition.\n\t */\n\tprivate Object[] resolvePreparedArguments(\n\t\t\tString beanName, RootBeanDefinition mbd, BeanWrapper bw, Executable executable, Object[] argsToResolve) {\n\n\t\tTypeConverter customConverter = this.beanFactory.getCustomTypeConverter();\n\t\tTypeConverter converter = (customConverter != null ? customConverter : bw);\n\t\tBeanDefinitionValueResolver valueResolver =\n\t\t\t\tnew BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n\t\tClass<?>[] paramTypes = executable.getParameterTypes();\n\n\t\tObject[] resolvedArgs = new Object[argsToResolve.length];\n\t\tfor (int argIndex = 0; argIndex < argsToResolve.length; argIndex++) {\n\t\t\tObject argValue = argsToResolve[argIndex];\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, argIndex);\n\t\t\tGenericTypeResolver.resolveParameterType(methodParam, executable.getDeclaringClass());\n\t\t\tif (argValue instanceof AutowiredArgumentMarker) {\n\t\t\t\targValue = resolveAutowiredArgument(methodParam, beanName, null, converter);\n\t\t\t}\n\t\t\telse if (argValue instanceof BeanMetadataElement) {\n\t\t\t\targValue = valueResolver.resolveValueIfNecessary(\"constructor argument\", argValue);\n\t\t\t}\n\t\t\telse if (argValue instanceof String) {\n\t\t\t\targValue = this.beanFactory.evaluateBeanDefinitionString((String) argValue, mbd);\n\t\t\t}\n\t\t\tClass<?> paramType = paramTypes[argIndex];\n\t\t\ttry {\n\t\t\t\tresolvedArgs[argIndex] = converter.convertIfNecessary(argValue, paramType, methodParam);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\"Could not convert argument value of type [\" + ObjectUtils.nullSafeClassName(argValue) +\n\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn resolvedArgs;\n\t}","commit_id":"725fb3219f7480182f220848aa8d72d464d8b801","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create an array of arguments to invoke a constructor or factory method,\n\t * given the resolved constructor argument values.\n\t */\n\tprivate ArgumentsHolder createArgumentArray(\n\t\t\tString beanName, RootBeanDefinition mbd, ConstructorArgumentValues resolvedValues,\n\t\t\tBeanWrapper bw, Class<?>[] paramTypes, String[] paramNames, Executable executable,\n\t\t\tboolean autowiring) throws UnsatisfiedDependencyException {\n\n\t\tTypeConverter converter = (this.beanFactory.getCustomTypeConverter() != null ?\n\t\t\t\tthis.beanFactory.getCustomTypeConverter() : bw);\n\n\t\tArgumentsHolder args = new ArgumentsHolder(paramTypes.length);\n\t\tSet<ConstructorArgumentValues.ValueHolder> usedValueHolders =\n\t\t\t\tnew HashSet<>(paramTypes.length);\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\n\t\tfor (int paramIndex = 0; paramIndex < paramTypes.length; paramIndex++) {\n\t\t\tClass<?> paramType = paramTypes[paramIndex];\n\t\t\tString paramName = (paramNames != null ? paramNames[paramIndex] : \"\");\n\t\t\t// Try to find matching constructor argument value, either indexed or generic.\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder =\n\t\t\t\t\tresolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);\n\t\t\t// If we couldn't find a direct match and are not supposed to autowire,\n\t\t\t// let's try the next generic, untyped argument value as fallback:\n\t\t\t// it could match after type conversion (for example, String -> int).\n\t\t\tif (valueHolder == null && (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) {\n\t\t\t\tvalueHolder = resolvedValues.getGenericArgumentValue(null, null, usedValueHolders);\n\t\t\t}\n\t\t\tif (valueHolder != null) {\n\t\t\t\t// We found a potential match - let's give it a try.\n\t\t\t\t// Do not consider the same value definition multiple times!\n\t\t\t\tusedValueHolders.add(valueHolder);\n\t\t\t\tObject originalValue = valueHolder.getValue();\n\t\t\t\tObject convertedValue;\n\t\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\t\tconvertedValue = valueHolder.getConvertedValue();\n\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tConstructorArgumentValues.ValueHolder sourceHolder =\n\t\t\t\t\t\t\t(ConstructorArgumentValues.ValueHolder) valueHolder.getSource();\n\t\t\t\t\tObject sourceValue = sourceHolder.getValue();\n\t\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconvertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);\n\t\t\t\t\t\t// TODO re-enable once race condition has been found (SPR-7423)\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif (originalValue == sourceValue || sourceValue instanceof TypedStringValue) {\n\t\t\t\t\t\t\t// Either a converted value or still the original one: store converted value.\n\t\t\t\t\t\t\tsourceHolder.setConvertedValue(convertedValue);\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = sourceValue;\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\t\"Could not convert argument value of type [\" +\n\t\t\t\t\t\t\t\tObjectUtils.nullSafeClassName(valueHolder.getValue()) +\n\t\t\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.arguments[paramIndex] = convertedValue;\n\t\t\t\targs.rawArguments[paramIndex] = originalValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t// No explicit match found: we're either supposed to autowire or\n\t\t\t\t// have to fail creating an argument array for the given constructor.\n\t\t\t\tif (!autowiring) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\"Ambiguous argument values for parameter of type [\" + paramType.getName() +\n\t\t\t\t\t\t\t\"] - did you specify the correct bean references as arguments?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject autowiredArgument =\n\t\t\t\t\t\t\tresolveAutowiredArgument(methodParam, beanName, autowiredBeanNames, converter);\n\t\t\t\t\targs.rawArguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.arguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.preparedArguments[paramIndex] = new AutowiredArgumentMarker();\n\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, beanName);\n\t\t\tif (this.beanFactory.logger.isDebugEnabled()) {\n\t\t\t\tthis.beanFactory.logger.debug(\"Autowiring by type from bean name '\" + beanName +\n\t\t\t\t\t\t\"' via \" + (executable instanceof Constructor ? \"constructor\" : \"factory method\") +\n\t\t\t\t\t\t\" to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t}\n\t\t}\n\n\t\treturn args;\n\t}","id":368,"modified_method":"/**\n\t * Create an array of arguments to invoke a constructor or factory method,\n\t * given the resolved constructor argument values.\n\t */\n\tprivate ArgumentsHolder createArgumentArray(\n\t\t\tString beanName, RootBeanDefinition mbd, ConstructorArgumentValues resolvedValues,\n\t\t\tBeanWrapper bw, Class<?>[] paramTypes, String[] paramNames, Executable executable,\n\t\t\tboolean autowiring) throws UnsatisfiedDependencyException {\n\n\t\tTypeConverter customConverter = this.beanFactory.getCustomTypeConverter();\n\t\tTypeConverter converter = (customConverter != null ? customConverter : bw);\n\n\t\tArgumentsHolder args = new ArgumentsHolder(paramTypes.length);\n\t\tSet<ConstructorArgumentValues.ValueHolder> usedValueHolders =\n\t\t\t\tnew HashSet<>(paramTypes.length);\n\t\tSet<String> autowiredBeanNames = new LinkedHashSet<>(4);\n\n\t\tfor (int paramIndex = 0; paramIndex < paramTypes.length; paramIndex++) {\n\t\t\tClass<?> paramType = paramTypes[paramIndex];\n\t\t\tString paramName = (paramNames != null ? paramNames[paramIndex] : \"\");\n\t\t\t// Try to find matching constructor argument value, either indexed or generic.\n\t\t\tConstructorArgumentValues.ValueHolder valueHolder =\n\t\t\t\t\tresolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);\n\t\t\t// If we couldn't find a direct match and are not supposed to autowire,\n\t\t\t// let's try the next generic, untyped argument value as fallback:\n\t\t\t// it could match after type conversion (for example, String -> int).\n\t\t\tif (valueHolder == null && (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) {\n\t\t\t\tvalueHolder = resolvedValues.getGenericArgumentValue(null, null, usedValueHolders);\n\t\t\t}\n\t\t\tif (valueHolder != null) {\n\t\t\t\t// We found a potential match - let's give it a try.\n\t\t\t\t// Do not consider the same value definition multiple times!\n\t\t\t\tusedValueHolders.add(valueHolder);\n\t\t\t\tObject originalValue = valueHolder.getValue();\n\t\t\t\tObject convertedValue;\n\t\t\t\tif (valueHolder.isConverted()) {\n\t\t\t\t\tconvertedValue = valueHolder.getConvertedValue();\n\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tConstructorArgumentValues.ValueHolder sourceHolder =\n\t\t\t\t\t\t\t(ConstructorArgumentValues.ValueHolder) valueHolder.getSource();\n\t\t\t\t\tObject sourceValue = sourceHolder.getValue();\n\t\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconvertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);\n\t\t\t\t\t\t// TODO re-enable once race condition has been found (SPR-7423)\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif (originalValue == sourceValue || sourceValue instanceof TypedStringValue) {\n\t\t\t\t\t\t\t// Either a converted value or still the original one: store converted value.\n\t\t\t\t\t\t\tsourceHolder.setConvertedValue(convertedValue);\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = convertedValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t\t\t\targs.preparedArguments[paramIndex] = sourceValue;\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\t\"Could not convert argument value of type [\" +\n\t\t\t\t\t\t\t\tObjectUtils.nullSafeClassName(valueHolder.getValue()) +\n\t\t\t\t\t\t\t\t\"] to required type [\" + paramType.getName() + \"]: \" + ex.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.arguments[paramIndex] = convertedValue;\n\t\t\t\targs.rawArguments[paramIndex] = originalValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);\n\t\t\t\t// No explicit match found: we're either supposed to autowire or\n\t\t\t\t// have to fail creating an argument array for the given constructor.\n\t\t\t\tif (!autowiring) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam),\n\t\t\t\t\t\t\t\"Ambiguous argument values for parameter of type [\" + paramType.getName() +\n\t\t\t\t\t\t\t\"] - did you specify the correct bean references as arguments?\");\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tObject autowiredArgument =\n\t\t\t\t\t\t\tresolveAutowiredArgument(methodParam, beanName, autowiredBeanNames, converter);\n\t\t\t\t\targs.rawArguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.arguments[paramIndex] = autowiredArgument;\n\t\t\t\t\targs.preparedArguments[paramIndex] = new AutowiredArgumentMarker();\n\t\t\t\t\targs.resolveNecessary = true;\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(\n\t\t\t\t\t\t\tmbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (String autowiredBeanName : autowiredBeanNames) {\n\t\t\tthis.beanFactory.registerDependentBean(autowiredBeanName, beanName);\n\t\t\tif (this.beanFactory.logger.isDebugEnabled()) {\n\t\t\t\tthis.beanFactory.logger.debug(\"Autowiring by type from bean name '\" + beanName +\n\t\t\t\t\t\t\"' via \" + (executable instanceof Constructor ? \"constructor\" : \"factory method\") +\n\t\t\t\t\t\t\" to bean named '\" + autowiredBeanName + \"'\");\n\t\t\t}\n\t\t}\n\n\t\treturn args;\n\t}","commit_id":"725fb3219f7480182f220848aa8d72d464d8b801","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(msg.getReceivedDate());\n        ack.setAckUser(((InternetAddress)msg.getFrom()[0]).getAddress());\n        return ack;\n    }","id":369,"modified_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        String ackUser = ((InternetAddress)msg.getFrom()[0]).getAddress();\n        Date ackTime = msg.getReceivedDate();\n        Acknowledgment ack = new Acknowledgment(ackTime, ackUser);\n        return ack;\n    }","commit_id":"f1381bf7ea18900fd9ae385603e97dca91d1bcbb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(msg.getReceivedDate());\n        ack.setAckUser(((InternetAddress)msg.getFrom()[0]).getAddress());\n        return ack;\n    }","id":370,"modified_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        String ackUser = ((InternetAddress)msg.getFrom()[0]).getAddress();\n        Date ackTime = msg.getReceivedDate();\n        Acknowledgment ack = new Acknowledgment(ackTime, ackUser);\n        return ack;\n    }","commit_id":"e623681f082ec3e01457c30a8b8bfdfd3dc1e18b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        Acknowledgment ack = new Acknowledgment();\n        ack.setAckTime(msg.getReceivedDate());\n        ack.setAckUser(((InternetAddress)msg.getFrom()[0]).getAddress());\n        return ack;\n    }","id":371,"modified_method":"private Acknowledgment createAcknowledgment(Message msg) throws MessagingException {\n        String ackUser = ((InternetAddress)msg.getFrom()[0]).getAddress();\n        Date ackTime = msg.getReceivedDate();\n        Acknowledgment ack = new Acknowledgment(ackTime, ackUser);\n        return ack;\n    }","commit_id":"f0136e3432b17a7ff666af23c058356443c4b7d4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":372,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            long firstEntryPosition = getFirstStartEntry( endPosition );\n            fileChannel.position( firstEntryPosition );\n            msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                    firstEntryPosition );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"8a9ffd2a076bcbc7b4d05a20e609b3f5421747ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":373,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            long firstEntryPosition = getFirstStartEntry( endPosition );\n            fileChannel.position( firstEntryPosition );\n            msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                    firstEntryPosition );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"9c20936d3903fbb51c7fe811e9ce178f6fe74121","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","id":374,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = getLog2FileName();\n        String currentLogFile = getLog1FileName();\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = getFileName( currentVersion );\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = getLog1FileName();\n            currentLogFile = getLog2FileName();\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        assertFileDoesntExist( newLogFile, \"New log file\" );\n        assertFileDoesntExist( oldCopy, \"Copy log file\" );\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        msgLog.logMessage( \"Rotating [\" + currentLogFile + \"] @ version=\" + \n                currentVersion + \" to \" +  newLogFile + \"from position \" + \n                writeBuffer.getFileChannelPosition() );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        readAndAssertLogHeader( buffer, fileChannel, currentVersion );\n        if ( xidIdentMap.size() > 0 )\n        {\n            long firstEntryPosition = getFirstStartEntry( endPosition );\n            fileChannel.position( firstEntryPosition );\n            msgLog.logMessage( \"Rotate log first start entry @ pos=\" + \n                    firstEntryPosition );\n        }\n        LogEntry entry;\n        // Set<Integer> startEntriesWritten = new HashSet<Integer>();\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    LogEntry.Start startEntry = (LogEntry.Start) entry;\n                    startEntry.setStartPosition( newLog.position() );\n                    // overwrite old start entry with new that has updated position\n                    xidIdentMap.put( startEntry.getIdentifier(), startEntry );\n                    // startEntriesWritten.add( entry.getIdentifier() );\n                }\n                else if ( entry instanceof LogEntry.Commit )\n                {\n                    LogEntry.Start startEntry = xidIdentMap.get( entry.getIdentifier() );\n                    LogEntry.Commit commitEntry = (LogEntry.Commit) entry;\n                    cacheTxStartPosition( commitEntry.getTxId(), commitEntry.getMasterId(), startEntry );\n                    msgLog.logMessage( \"Updated tx \" + ((LogEntry.Commit) entry ).getTxId() +\n                            \" with \" + startEntry.getStartPosition() );\n                }\n//                if ( !startEntriesWritten.contains( entry.getIdentifier() ) )\n//                {\n//                    throw new IOException( \"Unable to rotate log since start entry for identifier[\" +\n//                            entry.getIdentifier() + \"] not written\" );\n//                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        msgLog.logMessage( \"Rotate: old log scanned, newLog @ pos=\" + \n                newLog.position() );\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        this.logVersion = xaTf.getCurrentVersion();\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        instantiateCorrectWriteBuffer();\n        msgLog.logMessage( \"Log rotated, newLog @ pos=\" + \n                writeBuffer.getFileChannelPosition() + \" and version \" + logVersion ); \n    }","commit_id":"ab85710f461d9f24be6433b55b65dca2b921110b","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","id":375,"modified_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","id":376,"modified_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","commit_id":"6eb18714b27d862228a4f4d580dc707d1f03d5d6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","id":377,"modified_method":"@Override\n        protected List<HProject> fetchRecords(int start, int max,\n                String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getProjectsForMaintainer(\n                    authenticatedAccount.getPerson(), start, max);\n        }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ProjectDAO projectDAO =\n                    (ProjectDAO)Component.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    (HAccount) Component\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","id":378,"modified_method":"@Override\n        protected long fetchTotalRecords(String filter) {\n            ServiceLocator serviceLocator = ServiceLocator.instance();\n            ProjectDAO projectDAO =\n                    serviceLocator.getInstance(ProjectDAO.class);\n            HAccount authenticatedAccount =\n                    serviceLocator\n                            .getInstance(JpaIdentityStore.AUTHENTICATED_USER,\n                                    HAccount.class);\n            return projectDAO.getMaintainedProjectCount(\n                    authenticatedAccount.getPerson());\n        }","commit_id":"5a05dfab86c7d8c540700e6909a0f6969aeaf7ab","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", null);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", ManagementConstants.DEFAULT_DOMAIN_NAME);\n            usePlatformMBeanServer = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", null));\n            createMBServerConnectorFactory = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", null));\n            daemon = Boolean.valueOf(getBusProperty(b, \"bus.jmx.daemon\", null));\n            threaded = Boolean.valueOf(getBusProperty(b, \"bus.jmx.threaded\", null));\n            enabled = Boolean.valueOf(getBusProperty(b, \"bus.jmx.enabled\", null));\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", null);\n        }\n    }","id":379,"modified_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", persistentBusId);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", mbeanServerName);\n            usePlatformMBeanServer = \n                getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", usePlatformMBeanServer);\n            createMBServerConnectorFactory = \n                getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", createMBServerConnectorFactory);\n            daemon = getBusProperty(b, \"bus.jmx.daemon\", daemon);\n            threaded = getBusProperty(b, \"bus.jmx.threaded\", threaded);\n            enabled = getBusProperty(b, \"bus.jmx.enabled\", enabled);\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", jmxServiceURL);\n        }\n    }","commit_id":"40083b6612cd9c6bef05fe0b42f8816bbcbe2acb","url":"https://github.com/apache/cxf"},{"original_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", null);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", ManagementConstants.DEFAULT_DOMAIN_NAME);\n            usePlatformMBeanServer = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", null));\n            createMBServerConnectorFactory = \n                Boolean.valueOf(getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", null));\n            daemon = Boolean.valueOf(getBusProperty(b, \"bus.jmx.daemon\", null));\n            threaded = Boolean.valueOf(getBusProperty(b, \"bus.jmx.threaded\", null));\n            enabled = Boolean.valueOf(getBusProperty(b, \"bus.jmx.enabled\", null));\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", null);\n        }\n    }","id":380,"modified_method":"private void readJMXProperties(Bus b) {\n        if (b != null) {\n            persistentBusId = getBusProperty(b, \"bus.jmx.persistentBusId\", persistentBusId);\n            mbeanServerName = \n                getBusProperty(b, \"bus.jmx.serverName\", mbeanServerName);\n            usePlatformMBeanServer = \n                getBusProperty(b, \"bus.jmx.usePlatformMBeanServer\", usePlatformMBeanServer);\n            createMBServerConnectorFactory = \n                getBusProperty(b, \"bus.jmx.createMBServerConnectorFactory\", createMBServerConnectorFactory);\n            daemon = getBusProperty(b, \"bus.jmx.daemon\", daemon);\n            threaded = getBusProperty(b, \"bus.jmx.threaded\", threaded);\n            enabled = getBusProperty(b, \"bus.jmx.enabled\", enabled);\n            jmxServiceURL = getBusProperty(b, \"bus.jmx.JMXServiceURL\", jmxServiceURL);\n        }\n    }","commit_id":"db82d889523ce1627ea748353f501d1dad11e6ca","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"round\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    FileUtil.copyDir(currentTestRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":381,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"round\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    final VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"eml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    FileUtil.copyDir(currentTestRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":382,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"eml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData/iml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    FileUtil.copyDir(currentTestRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":383,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData/iml\");\n    assertTrue(testRoot.getAbsolutePath(), testRoot.isDirectory());\n\n    final File currentTestRoot = new File(testRoot, getTestName(true));\n    assertTrue(currentTestRoot.getAbsolutePath(), currentTestRoot.isDirectory());\n\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void copyTestData() throws IOException {\n    final File testRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"import\");\n    FileUtil.copyDir(testRoot, new File(getProject().getBaseDir().getPath()));\n  }","id":384,"modified_method":"private void copyTestData() throws IOException {\n    final File currentTestRoot = new File(PluginPathManager.getPluginHomePath(\"eclipse\") + \"/testData\", \"import\");\n    VirtualFile vTestRoot = LocalFileSystem.getInstance().findFileByIoFile(currentTestRoot);\n    copyDirContentsTo(vTestRoot, getProject().getBaseDir());\n  }","commit_id":"72c926d6d0c53d62489a1c156ad2286cba141a37","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void notifyExchangeSent(CamelContext context, Exchange exchange, Endpoint endpoint, long timeTaken) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSentEvent(exchange, endpoint, timeTaken);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":385,"modified_method":"public static void notifyExchangeSent(CamelContext context, Exchange exchange, Endpoint endpoint, long timeTaken) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSentEvent(exchange, endpoint, timeTaken);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStarting(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":386,"modified_method":"public static void notifyCamelContextStarting(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextResumeFailed(CamelContext context, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumeFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":387,"modified_method":"public static void notifyCamelContextResumeFailed(CamelContext context, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumeFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStarted(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":388,"modified_method":"public static void notifyCamelContextStarted(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStopping(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":389,"modified_method":"public static void notifyCamelContextStopping(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeCreated(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCreatedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCreatedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":390,"modified_method":"public static void notifyExchangeCreated(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCreatedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCreatedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeSending(CamelContext context, Exchange exchange, Endpoint endpoint) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSendingEvent(exchange, endpoint);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":391,"modified_method":"public static void notifyExchangeSending(CamelContext context, Exchange exchange, Endpoint endpoint) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeSentEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeSendingEvent(exchange, endpoint);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyRouteStopped(CamelContext context, Route route) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStoppedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":392,"modified_method":"public static void notifyRouteStopped(CamelContext context, Route route) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStoppedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextSuspending(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":393,"modified_method":"public static void notifyCamelContextSuspending(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextSuspended(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":394,"modified_method":"public static void notifyCamelContextSuspended(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextSuspendedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeFailureHandled(CamelContext context, Exchange exchange, Processor failureHandler,\n                                                    boolean deadLetterChannel) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailureHandledEvent(exchange, failureHandler, deadLetterChannel);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":395,"modified_method":"public static void notifyExchangeFailureHandled(CamelContext context, Exchange exchange, Processor failureHandler,\n                                                    boolean deadLetterChannel) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailureHandledEvent(exchange, failureHandler, deadLetterChannel);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStartupFailed(CamelContext context, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartupFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":396,"modified_method":"public static void notifyCamelContextStartupFailed(CamelContext context, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStartupFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyServiceStopFailure(CamelContext context, Object service, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStopFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":397,"modified_method":"public static void notifyServiceStopFailure(CamelContext context, Object service, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStopFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextResumed(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":398,"modified_method":"public static void notifyCamelContextResumed(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeRedelivery(CamelContext context, Exchange exchange, int attempt) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeRedeliveryEvent(exchange, attempt);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":399,"modified_method":"public static void notifyExchangeRedelivery(CamelContext context, Exchange exchange, int attempt) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeRedeliveryEvent(exchange, attempt);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStopFailed(CamelContext context, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStopFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":400,"modified_method":"public static void notifyCamelContextStopFailed(CamelContext context, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStopFailureEvent(context, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeFailed(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":401,"modified_method":"public static void notifyExchangeFailed(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeFailedEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeFailedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyExchangeDone(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCompletedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCompletedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":402,"modified_method":"public static void notifyExchangeDone(CamelContext context, Exchange exchange) {\n        if (exchange.getProperty(Exchange.NOTIFY_EVENT, false, Boolean.class)) {\n            // do not generate events for an notify event\n            return;\n        }\n\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreExchangeEvents() || notifier.isIgnoreExchangeCompletedEvent()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createExchangeCompletedEvent(exchange);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextResuming(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":403,"modified_method":"public static void notifyCamelContextResuming(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextResumingEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyCamelContextStopped(CamelContext context) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":404,"modified_method":"public static void notifyCamelContextStopped(CamelContext context) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreCamelContextEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createCamelContextStoppedEvent(context);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyRouteStarted(CamelContext context, Route route) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStartedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":405,"modified_method":"public static void notifyRouteStarted(CamelContext context, Route route) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreRouteEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createRouteStartedEvent(route);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"public static void notifyServiceStartupFailure(CamelContext context, Object service, Throwable cause) {\n        List<EventNotifier> notifiers = context.getManagementStrategy().getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = context.getManagementStrategy().getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStartupFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","id":406,"modified_method":"public static void notifyServiceStartupFailure(CamelContext context, Object service, Throwable cause) {\n        ManagementStrategy management = context.getManagementStrategy();\n        if (management == null) {\n            return;\n        }\n\n        List<EventNotifier> notifiers = management.getEventNotifiers();\n        if (notifiers == null || notifiers.isEmpty()) {\n            return;\n        }\n\n        for (EventNotifier notifier : notifiers) {\n            if (notifier.isIgnoreServiceEvents()) {\n                continue;\n            }\n\n            EventFactory factory = management.getEventFactory();\n            if (factory == null) {\n                return;\n            }\n            EventObject event = factory.createServiceStartupFailureEvent(context, service, cause);\n            if (event == null) {\n                return;\n            }\n            doNotifyEvent(notifier, event);\n        }\n    }","commit_id":"18f8d29f985746e5b5afa7f7b26564c5be564d5c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":407,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"8bb71c04573179dbca6cb479bed0aa5d479148a4","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":408,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"8bb71c04573179dbca6cb479bed0aa5d479148a4","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":409,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"455b8a10b1790a53f8f6b0c9ba808769c885302c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":410,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"455b8a10b1790a53f8f6b0c9ba808769c885302c","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":411,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        final String name = call.getMethodAsString();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            return;\n        }\n\n        final Expression objectExpression = call.getObjectExpression();\n\n        objectExpression.visit(this);\n        call.getMethod().visit(this);\n\n        // if the call expression is a spread operator call, then we must make sure that\n        // the call is made on a collection type\n        if (call.isSpreadSafe()) {\n            ClassNode expressionType = getType(objectExpression);\n            if (!(expressionType.equals(Collection_TYPE)||expressionType.implementsInterface(Collection_TYPE))) {\n                addStaticTypeError(\"Spread operator can only be used on collection types\", expressionType);\n                return;\n            } else {\n                // type check call as if it was made on component type\n                ClassNode componentType = inferComponentType(expressionType);\n                MethodCallExpression subcall = new MethodCallExpression(\n                        new CastExpression(componentType, EmptyExpression.INSTANCE),\n                        name,\n                        call.getArguments()\n                );\n                subcall.setLineNumber(call.getLineNumber());\n                subcall.setColumnNumber(call.getColumnNumber());\n                visitMethodCallExpression(subcall);\n                // the inferred type here should be a list of what the subcall returns\n                ClassNode subcallReturnType = getType(subcall);\n                ClassNode listNode = new ClassNode(List.class);\n                listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});\n                storeType(call, listNode);\n                return;\n            }\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final boolean isCallOnClosure = isClosureCall(name, objectExpression);\n        final ClassNode receiver = getType(objectExpression);\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n            if (isCallOnClosure) {\n                // this is a closure.call() call\n                if (objectExpression==VariableExpression.THIS_EXPRESSION) {\n                    // isClosureCall() check verified earlier that a field exists\n                    FieldNode field = classNode.getDeclaredField(name);\n                    ClassNode closureReturnType = field.getType().getGenericsTypes()[0].getType();\n                    Object data = field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                    if (data != null) {\n                        Parameter[] parameters = (Parameter[]) data;\n                        typeCheckClosureCall(callArguments, args, parameters);\n                    }\n                    storeType(call, closureReturnType);\n                } else if (objectExpression instanceof VariableExpression) {\n                    Variable variable = findTargetVariable((VariableExpression) objectExpression);\n                    if (variable instanceof Expression) {\n                        Object data = ((Expression) variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);\n                        if (data != null) {\n                            Parameter[] parameters = (Parameter[]) data;\n                            typeCheckClosureCall(callArguments, args, parameters);\n                        }\n                        Object type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                        if (type == null) {\n                            // if variable was declared as a closure and inferred type is unknown, we\n                            // may face a recursive call. In that case, we will use the type of the\n                            // generic return type of the closure declaration\n                            if (variable.getType().equals(CLOSURE_TYPE)) {\n                                type = variable.getType().getGenericsTypes()[0].getType();\n                            }\n                        }\n                        if (type != null) {\n                            storeType(call, (ClassNode) type);\n                        }\n                    }\n                } else if (objectExpression instanceof ClosureExpression) {\n                    // we can get actual parameters directly\n                    Parameter[] parameters = ((ClosureExpression) objectExpression).getParameters();\n                    typeCheckClosureCall(callArguments, args, parameters);\n                    Object data = objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);\n                    if (data != null) {\n                        storeType(call, (ClassNode) data);\n                    }\n                }\n                int nbOfArgs = 0;\n                if (callArguments instanceof ArgumentListExpression) {\n                    ArgumentListExpression list = (ArgumentListExpression) callArguments;\n                    nbOfArgs = list.getExpressions().size();\n                } else {\n                    // todo : other cases\n                    nbOfArgs = 0;\n                }\n                storeTargetMethod(call,\n                        nbOfArgs==0?CLOSURE_CALL_NO_ARG:\n                        nbOfArgs==1?CLOSURE_CALL_ONE_ARG:\n                                    CLOSURE_CALL_VARGS);\n            } else {\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                if (objectExpression instanceof ClassExpression) {\n                    receivers.add(CLASS_Type);\n                }\n                if (!temporaryIfBranchTypeInformation.empty()) {\n                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);\n                    if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);\n                }\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        // todo: if no visit was done, we should try to obtain type information in a different\n                        // manner, for example creating a dedicated visitor. But this is not necessarily trivial:\n                        // choose the correct visitor type, make use AST doesn't get polluted with type info or\n                        // even transformed... Deal with precompiled classes...\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                        // if the object expression is a closure shared variable, we will have to perform a second pass\n                        if (objectExpression instanceof VariableExpression) {\n                            VariableExpression var = (VariableExpression) objectExpression;\n                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);\n                        }\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n            }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"afb4882718642ae27ed187d4ae1016a6986ca840","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        visitMethod(directMethodCallCandidate);\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","id":412,"modified_method":"@Override\n    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {\n        final String name = call.getMethod();\n        if (name == null) {\n            addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call);\n            return;\n        }\n\n        final ClassNode rememberLastItType = lastImplicitItType;\n        Expression callArguments = call.getArguments();\n\n        boolean isWithCall = isWithCall(name, callArguments);\n\n        if (!isWithCall) {\n            // if it is not a \"with\" call, arguments should be visited first\n            callArguments.visit(this);\n        }\n\n        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));\n        final ClassNode receiver = call.getOwnerType();\n\n        if (isWithCall) {\n            withReceiverList.add(0, receiver); // must be added first in the list\n            lastImplicitItType = receiver;\n            // if the provided closure uses an explicit parameter definition, we can\n            // also check that the provided type is correct\n            if (callArguments instanceof ArgumentListExpression) {\n                ArgumentListExpression argList = (ArgumentListExpression) callArguments;\n                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);\n                Parameter[] parameters = closure.getParameters();\n                if (parameters.length > 1) {\n                    addStaticTypeError(\"Unexpected number of parameters for a with call\", argList);\n                } else if (parameters.length == 1) {\n                    Parameter param = parameters[0];\n                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {\n                        addStaticTypeError(\"Expected parameter type: \" + receiver.toString(false) + \" but was: \" + param.getType().redirect().toString(false), param);\n                    }\n                }\n            }\n        }\n\n        try {\n            if (isWithCall) {\n                // in case of a with call, arguments (the closure) should be visited now that we checked\n                // the arguments\n                callArguments.visit(this);\n            }\n\n                // method call receivers are :\n                //   - possible \"with\" receivers\n                //   - the actual receiver as found in the method call expression\n                //   - any of the potential receivers found in the instanceof temporary table\n                // in that order\n                List<ClassNode> receivers = new LinkedList<ClassNode>();\n                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);\n                receivers.add(receiver);\n                List<MethodNode> mn = null;\n                ClassNode chosenReceiver = null;\n                for (ClassNode currentReceiver : receivers) {\n                    mn = findMethod(currentReceiver, name, args);\n                    if (!mn.isEmpty()) {\n                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);\n                        chosenReceiver = currentReceiver;\n                        break;\n                    }\n                }\n                if (mn.isEmpty()) {\n                    addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                } else {\n                    if (mn.size() == 1) {\n                        MethodNode directMethodCallCandidate = mn.get(0);\n                        // visit the method to obtain inferred return type\n                        ClassNode currentClassNode = classNode;\n                        classNode = directMethodCallCandidate.getDeclaringClass();\n                        for (ClassNode node: source.getAST().getClasses()) {\n                            if (isClassInnerClassOrEqualTo(classNode, node)) {\n                                // visit is authorized because the classnode belongs to the same source unit\n                                visitMethod(directMethodCallCandidate);\n                                break;\n                            }\n                        }\n                        classNode = currentClassNode;\n                        ClassNode returnType = getType(directMethodCallCandidate);\n                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {\n                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);\n                        }\n                        storeType(call, returnType);\n                        storeTargetMethod(call, directMethodCallCandidate);\n\n                    } else {\n                        addStaticTypeError(\"Reference to method is ambiguous. Cannot choose between \" + mn, call);\n                    }\n                }\n        } finally {\n            if (isWithCall) {\n                lastImplicitItType = rememberLastItType;\n                withReceiverList.removeFirst();\n            }\n        }\n    }","commit_id":"afb4882718642ae27ed187d4ae1016a6986ca840","url":"https://github.com/apache/groovy"},{"original_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if (origText.charAt(i) != '\\n' && (Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))\n              || Character.isWhitespace(origText.charAt(i)))) {\n        seg = true;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","id":413,"modified_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if ((Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))) &&\n          ! (origText.charAt(i) == '\\n' || origText.charAt(i) == '\\r')) {\n        seg = true;\n      } else if (Character.isISOControl(origText.charAt(i))) {\n        // skip it but don't set seg\n        seg = false;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","commit_id":"e026674a16aafeedbdd9112a30402f20ba2c4e50","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if (origText.charAt(i) != '\\n' && (Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))\n              || Character.isWhitespace(origText.charAt(i)))) {\n        seg = true;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","id":414,"modified_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if ((Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))) &&\n          ! (origText.charAt(i) == '\\n' || origText.charAt(i) == '\\r')) {\n        seg = true;\n      } else if (Character.isISOControl(origText.charAt(i))) {\n        // skip it but don't set seg\n        seg = false;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","commit_id":"a8ba716be130eb80622b718a67411c4998958e54","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if (origText.charAt(i) != '\\n' && (Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))\n              || Character.isWhitespace(origText.charAt(i)))) {\n        seg = true;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","id":415,"modified_method":"private static void splitCharacters(CoreMap annotation) {\n    String origText = annotation.get(CoreAnnotations.TextAnnotation.class);\n\n    boolean seg = true;\n    List<CoreLabel> words = new ArrayList<>();\n\n    for (int i = 0; i < origText.length(); i++) {\n      CoreLabel wi = new CoreLabel();\n      char[] ca = {origText.charAt(i)};\n      String wordString = new String(ca);\n\n      // if this word is a whitespace or a control character, set 'seg' to true for next word, and break\n      if ((Character.isSpaceChar(origText.charAt(i)) || Character.isISOControl(origText.charAt(i))) &&\n          ! (origText.charAt(i) == '\\n' || origText.charAt(i) == '\\r')) {\n        seg = true;\n      } else if (Character.isISOControl(origText.charAt(i))) {\n        // skip it but don't set seg\n        seg = false;\n      } else {\n        // if this word is a word, put it as a feature label and set seg to false for next word\n        wi.set(CoreAnnotations.ChineseCharAnnotation.class, wordString);\n        if (seg) {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"1\");\n        } else {\n          wi.set(CoreAnnotations.ChineseSegAnnotation.class, \"0\");\n        }\n        wi.set(CoreAnnotations.CharacterOffsetBeginAnnotation.class, i);\n        wi.set(CoreAnnotations.CharacterOffsetEndAnnotation.class, (i + 1));\n        words.add(wi);\n        seg = false;\n      }\n    }\n\n    annotation.set(SegmenterCoreAnnotations.CharactersAnnotation.class, words);\n  }","commit_id":"7a45c28faa9f1d0bcc8f1142f811bb95110e297d","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorException() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n    try {\n      hadoop.execute(\"u\", TestHdfsHelper.getHdfsConf(), new FileSystemAccess.FileSystemExecutor<Void>() {\n        @Override\n        public Void execute(FileSystem fs) throws IOException {\n          fsa[0] = fs;\n          throw new IOException();\n        }\n      });\n      Assert.fail();\n    } catch (FileSystemAccessException ex) {\n      Assert.assertEquals(ex.getError(), FileSystemAccessException.ERROR.H03);\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","id":416,"modified_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorException() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n    try {\n      hadoop.execute(\"u\", hadoop.getFileSystemConfiguration(), new FileSystemAccess.FileSystemExecutor<Void>() {\n        @Override\n        public Void execute(FileSystem fs) throws IOException {\n          fsa[0] = fs;\n          throw new IOException();\n        }\n      });\n      Assert.fail();\n    } catch (FileSystemAccessException ex) {\n      Assert.assertEquals(ex.getError(), FileSystemAccessException.ERROR.H03);\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void createFileSystem() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n    FileSystem fs = hadoop.createFileSystem(\"u\", TestHdfsHelper.getHdfsConf());\n    Assert.assertNotNull(fs);\n    fs.mkdirs(new Path(\"/tmp/foo\"));\n    hadoop.releaseFileSystem(fs);\n    try {\n      fs.mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","id":417,"modified_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void createFileSystem() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n    FileSystem fs = hadoop.createFileSystem(\"u\", hadoop.getFileSystemConfiguration());\n    Assert.assertNotNull(fs);\n    fs.mkdirs(new Path(\"/tmp/foo\"));\n    hadoop.releaseFileSystem(fs);\n    try {\n      fs.mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutor() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n\n    hadoop.execute(\"u\", TestHdfsHelper.getHdfsConf(), new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        fs.mkdirs(new Path(\"/tmp/foo\"));\n        fsa[0] = fs;\n        return null;\n      }\n    });\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","id":418,"modified_method":"@Test\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutor() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess hadoop = server.get(FileSystemAccess.class);\n\n    final FileSystem fsa[] = new FileSystem[1];\n\n    hadoop.execute(\"u\", hadoop.getFileSystemConfiguration(), new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        fs.mkdirs(new Path(\"/tmp/foo\"));\n        fsa[0] = fs;\n        return null;\n      }\n    });\n    try {\n      fsa[0].mkdirs(new Path(\"/tmp/foo\"));\n      Assert.fail();\n    } catch (IOException ex) {\n    } catch (Exception ex) {\n      Assert.fail();\n    }\n    server.destroy();\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  @TestException(exception = FileSystemAccessException.class, msgRegExp = \"H06.*\")\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorNoNameNode() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess fsAccess = server.get(FileSystemAccess.class);\n\n    Configuration hdfsConf = TestHdfsHelper.getHdfsConf();\n    hdfsConf.set(\"fs.default.name\", \"\");\n    fsAccess.execute(\"u\", hdfsConf, new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        return null;\n      }\n    });\n  }","id":419,"modified_method":"@Test\n  @TestException(exception = FileSystemAccessException.class, msgRegExp = \"H06.*\")\n  @TestDir\n  @TestHdfs\n  public void fileSystemExecutorNoNameNode() throws Exception {\n    String dir = TestDirHelper.getTestDir().getAbsolutePath();\n    String services = StringUtils.join(\",\", Arrays.asList(InstrumentationService.class.getName(),\n                                                          FileSystemAccessService.class.getName()));\n    Configuration hadoopConf = new Configuration(false);\n    hadoopConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, TestHdfsHelper.getHdfsConf().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));\n    createHadoopConf(hadoopConf);\n\n    Configuration conf = new Configuration(false);\n    conf.set(\"server.services\", services);\n    Server server = new Server(\"server\", dir, dir, dir, dir, conf);\n    server.init();\n    FileSystemAccess fsAccess = server.get(FileSystemAccess.class);\n\n    Configuration hdfsConf = fsAccess.getFileSystemConfiguration();\n    hdfsConf.set(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY, \"\");\n    fsAccess.execute(\"u\", hdfsConf, new FileSystemAccess.FileSystemExecutor<Void>() {\n      @Override\n      public Void execute(FileSystem fs) throws IOException {\n        return null;\n      }\n    });\n  }","commit_id":"8bda086d046b12e8efed834f39a775e710ca0962","url":"https://github.com/apache/hadoop"},{"original_method":"protected void unscheduleStaging(Group group) {\n\t\ttry {\n\n\t\t\t// Remote publishing\n\n\t\t\tString groupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\tDestinationNames.LAYOUTS_REMOTE_PUBLISHER, group.getGroupId());\n\n\t\t\tList<SchedulerRequest> schedulerRequests =\n\t\t\t\tSchedulerEngineUtil.getScheduledJobs(groupName);\n\n\t\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\t\tschedulerRequest.getJobName(),\n\t\t\t\t\tschedulerRequest.getGroupName());\n\t\t\t}\n\n\t\t\tlong liveGroupId = 0;\n\t\t\tlong stagingGroupId = 0;\n\n\t\t\tif (group.isStagingGroup()) {\n\t\t\t\tliveGroupId = group.getLiveGroupId();\n\n\t\t\t\tstagingGroupId = group.getGroupId();\n\t\t\t}\n\t\t\telse if (group.hasStagingGroup()) {\n\t\t\t\tliveGroupId = group.getGroupId();\n\n\t\t\t\tstagingGroupId = group.getStagingGroup().getGroupId();\n\t\t\t}\n\n\t\t\tif ((liveGroupId != 0) && (stagingGroupId != 0)) {\n\n\t\t\t\t// Publish to live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, liveGroupId);\n\n\t\t\t\tschedulerRequests = SchedulerEngineUtil.getScheduledJobs(\n\t\t\t\t\tgroupName);\n\n\t\t\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\t\t\tTrigger trigger = schedulerRequest.getTrigger();\n\n\t\t\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\t\t\ttrigger.getJobName(), trigger.getGroupName());\n\t\t\t\t}\n\n\t\t\t\t// Copy from live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, stagingGroupId);\n\n\t\t\t\tschedulerRequests = SchedulerEngineUtil.getScheduledJobs(\n\t\t\t\t\tgroupName);\n\n\t\t\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\t\t\tTrigger trigger = schedulerRequest.getTrigger();\n\n\t\t\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\t\t\ttrigger.getJobName(), trigger.getGroupName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to unschedule events for group: \" + group.getGroupId());\n\t\t}\n\t}","id":420,"modified_method":"protected void unscheduleStaging(Group group) {\n\t\ttry {\n\n\t\t\t// Remote publishing\n\n\t\t\tString groupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\tDestinationNames.LAYOUTS_REMOTE_PUBLISHER, group.getGroupId());\n\n\t\t\tSchedulerEngineUtil.unschedule(groupName);\n\n\t\t\tlong liveGroupId = 0;\n\t\t\tlong stagingGroupId = 0;\n\n\t\t\tif (group.isStagingGroup()) {\n\t\t\t\tliveGroupId = group.getLiveGroupId();\n\n\t\t\t\tstagingGroupId = group.getGroupId();\n\t\t\t}\n\t\t\telse if (group.hasStagingGroup()) {\n\t\t\t\tliveGroupId = group.getGroupId();\n\n\t\t\t\tstagingGroupId = group.getStagingGroup().getGroupId();\n\t\t\t}\n\n\t\t\tif ((liveGroupId != 0) && (stagingGroupId != 0)) {\n\n\t\t\t\t// Publish to live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, liveGroupId);\n\n\t\t\t\tSchedulerEngineUtil.unschedule(groupName);\n\n\t\t\t\t// Copy from live\n\n\t\t\t\tgroupName = StagingUtil.getSchedulerGroupName(\n\t\t\t\t\tDestinationNames.LAYOUTS_LOCAL_PUBLISHER, stagingGroupId);\n\n\t\t\t\tSchedulerEngineUtil.unschedule(groupName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\n\t\t\t\t\"Unable to unschedule events for group: \" + group.getGroupId());\n\t\t}\n\t}","commit_id":"e65ace830f7bab19e1880a60afaa01a2c225ba23","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void unscheduleMailingList(MBMailingList mailingList)\n\t\tthrows PortalException {\n\n\t\tString groupName = getSchedulerGroupName(mailingList);\n\n\t\tList<SchedulerRequest> schedulerRequests =\n\t\t\tSchedulerEngineUtil.getScheduledJobs(groupName);\n\n\t\tfor (SchedulerRequest schedulerRequest : schedulerRequests) {\n\t\t\tTrigger trigger = schedulerRequest.getTrigger();\n\n\t\t\tSchedulerEngineUtil.unschedule(\n\t\t\t\ttrigger.getJobName(), trigger.getGroupName());\n\t\t}\n\t}","id":421,"modified_method":"protected void unscheduleMailingList(MBMailingList mailingList)\n\t\tthrows PortalException {\n\n\t\tString groupName = getSchedulerGroupName(mailingList);\n\n\t\tSchedulerEngineUtil.unschedule(groupName);\n\t}","commit_id":"e65ace830f7bab19e1880a60afaa01a2c225ba23","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          int newIndex = index2Item.size();\n          item2Index.put(o, newIndex);\n          index2Item.put(newIndex, o);\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","id":422,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","commit_id":"4d2da8266cbbbc45dcb232eff4dbf3ec91f13d19","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  public int indexOf(E o, boolean add) {\n    if (add) {\n      // TODO(spenceg) The Index interface contract states that indices must be\n      // non-negative and continuous. We tried to satisfy this requirement without\n      // a lock (e.g., by using AtomicInteger) but couldn't make it work.\n      synchronized(this) {\n        if ( ! item2Index.containsKey(o)) {\n          int newIndex = index2Item.size();\n          item2Index.put(o, newIndex);\n          index2Item.put(newIndex, o);\n        }\n      }\n      return item2Index.get(o);\n\n    } else {\n      return indexOf(o);\n    }\n  }","id":423,"modified_method":"@Override\n  public int indexOf(E o, boolean add) {\n    Integer atomic = item2Index.get(o);\n    if (atomic == null) {\n      if (add) {\n        final int newIndex = indexCounter.getAndIncrement();\n        atomic = item2Index.putIfAbsent(o, newIndex);\n        if (atomic == null) {\n          index2Item.put(newIndex, o);\n          return newIndex;\n        } else {\n          return item2Index.get(o);\n        }\n      } else {\n        return UNKNOWN_ID;\n      }\n    } else {\n      return atomic;\n    }\n  }","commit_id":"a5a24db34233df15a8e128a9636cec4eaabcdbad","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * default number of fragments of 5.\n     *\n     * @param name         The field to highlight\n     * @param fragmentSize The size of a fragment in characters\n     */\n    public HighlightBuilder field(String name, int fragmentSize) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name).fragmentSize(fragmentSize));\n        return this;\n    }","id":424,"modified_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * default number of fragments of 5.\n     *\n     * @param name         The field to highlight\n     * @param fragmentSize The size of a fragment in characters\n     */\n    public HighlightBuilder field(String name, int fragmentSize) {\n        return field(new Field(name).fragmentSize(fragmentSize));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Adds a field to be highlighted with default fragment size of 100 characters, and\n     * default number of fragments of 5 using the default encoder\n     *\n     * @param name The field to highlight\n     */\n    public HighlightBuilder field(String name) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name));\n        return this;\n    }","id":425,"modified_method":"/**\n     * Adds a field to be highlighted with default fragment size of 100 characters, and\n     * default number of fragments of 5 using the default encoder\n     *\n     * @param name The field to highlight\n     */\n    public HighlightBuilder field(String name) {\n        return field(new Field(name));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     * @param fragmentOffset    The offset from the start of the fragment to the start of the highlight\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments, int fragmentOffset) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments)\n                .fragmentOffset(fragmentOffset));\n        return this;\n    }","id":426,"modified_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     * @param fragmentOffset    The offset from the start of the fragment to the start of the highlight\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments, int fragmentOffset) {\n        return field(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments)\n                .fragmentOffset(fragmentOffset));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments) {\n        if (fields == null) {\n            fields = new ArrayList<>();\n        }\n        fields.add(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments));\n        return this;\n    }","id":427,"modified_method":"/**\n     * Adds a field to be highlighted with a provided fragment size (in characters), and\n     * a provided (maximum) number of fragments.\n     *\n     * @param name              The field to highlight\n     * @param fragmentSize      The size of a fragment in characters\n     * @param numberOfFragments The (maximum) number of fragments\n     */\n    public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments) {\n        return field(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments));\n    }","commit_id":"027a9b18448cf79a026598795dfe1b30cb1fe523","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public JRDataSource createDatasource() throws JRException {\n        try {\n            return new RrdXportCmd().executeCommand(getQueryString());\n        } catch (Throwable e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","id":428,"modified_method":"@Override\n    public JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic JRDataSource createDatasource() throws JRException {\n\t\ttry {\n\t\t\treturn new RrdtoolXportCmd().executeCommand(getQueryString());\n\t\t} catch (Exception e) {\n\t\t\tthrow new JRException(\"Error creating RrdtoolDataSource\", e);\n\t\t}\n\t}","id":429,"modified_method":"@Override\n\tpublic JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdtoolXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating RrdtoolDataSource with command: \" + getQueryString(), e);\n        }\n\t}","commit_id":"46ebd47ba618380ed7f21984d48589b904db6b9e","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public JRDataSource createDatasource() throws JRException {\n        try {\n            return new RrdXportCmd().executeCommand(getQueryString());\n        } catch (Throwable e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","id":430,"modified_method":"@Override\n    public JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating JRobinDataSource with command: \" + getQueryString(), e);\n        }\n    }","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic JRDataSource createDatasource() throws JRException {\n\t\ttry {\n\t\t\treturn new RrdtoolXportCmd().executeCommand(getQueryString());\n\t\t} catch (Exception e) {\n\t\t\tthrow new JRException(\"Error creating RrdtoolDataSource\", e);\n\t\t}\n\t}","id":431,"modified_method":"@Override\n\tpublic JRRewindableDataSource createDatasource() throws JRException {\n        RrdDataSourceFilter dse = new RrdDataSourceFilter(getQueryString());\n        try {\n            JRRewindableDataSource ds = new RrdtoolXportCmd().executeCommand(dse.getRrdQueryString());\n            return dse.filter(ds);\n        } catch (Exception e) {\n            throw new JRException(\"Error creating RrdtoolDataSource with command: \" + getQueryString(), e);\n        }\n\t}","commit_id":"660332763dddf2be0b735812b73cd32d0a345f81","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static boolean isWriteReplaceMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeReplace\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":432,"modified_method":"private static boolean isWriteReplaceMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeReplace\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadObjectNoDataMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObjectNoData\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":433,"modified_method":"private static boolean isReadObjectNoDataMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObjectNoData\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadResolveMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readResolve\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":434,"modified_method":"private static boolean isReadResolveMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readResolve\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 0) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiType returnType = method.getReturnType();\n    if (returnType == null || !returnType.equalsToText(\"java.lang.Object\")) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isWriteObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeObject\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":435,"modified_method":"private static boolean isWriteObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"writeObject\")) return false;\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectOutputStream\")) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isReadObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObject\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")) return false;\n\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    if (aClass != null && !isSerializable(aClass)) return false;\n    return true;\n  }","id":436,"modified_method":"private static boolean isReadObjectMethod(PsiMethod method) {\n    if (!method.getName().equals(\"readObject\")) return false;\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    if (parameters.length != 1) return false;\n\n    if (!parameters[0].getType().equalsToText(\"java.io.ObjectInputStream\")) return false;\n\n    PsiType returnType = method.getReturnType();\n    if (!TypeConversionUtil.isVoidType(returnType)) return false;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    PsiClass aClass = method.getContainingClass();\n    return aClass == null || isSerializable(aClass);\n  }","commit_id":"b34516c63c280d749709c74b8669dbdd4016b694","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#after()\n   */\n  public void after( final P parent ) {\n    this.fireListeners( Phases.after, new Predicate<TransitionListener<P>>( ) {\n      @Override\n      public boolean apply( TransitionListener<P> listener ) {\n        listener.after( parent );\n        return true;\n      }\n    }, parent );\n  }","id":437,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#after()\n   */\n  public void after( final P parent ) {\n    if ( this.action == null ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      this.fireListeners( Phases.after, new Predicate<TransitionListener<P>>( ) {\n        @Override\n        public boolean apply( TransitionListener<P> listener ) {\n          listener.after( parent );\n          return true;\n        }\n      }, parent );\n      this.action.after( parent );\n    }\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#leave()\n   */\n  @Override\n  public void leave( final P parent, final Completion transitionCallback ) {\n    this.fireListeners( Phases.leave, new Predicate<TransitionListener<P>>( ) {\n      @Override\n      public boolean apply( TransitionListener<P> listener ) {\n        listener.leave( parent, transitionCallback );\n        return true;\n      }\n    }, parent );\n  }","id":438,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#leave()\n   */\n  @Override\n  public void leave( final P parent, final Completion transitionCallback ) {\n    if ( this.action == null ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      this.fireListeners( Phases.leave, new Predicate<TransitionListener<P>>( ) {\n        @Override\n        public boolean apply( TransitionListener<P> listener ) {\n          listener.leave( parent, transitionCallback );\n          return true;\n        }\n      }, parent );\n      this.action.leave( parent, transitionCallback );\n    }\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#enter()\n   */\n  public void enter( final P parent ) {\n    this.fireListeners( Phases.enter, new Predicate<TransitionListener<P>>( ) {\n      @Override\n      public boolean apply( TransitionListener<P> listener ) {\n        listener.enter( parent );\n        return true;\n      }\n    }, parent );\n  }","id":439,"modified_method":"/**\n   * @see com.eucalyptus.util.fsm.TransitionListener#enter()\n   */\n  public void enter( final P parent ) {\n    if ( this.action == null ) {\n      throw new IllegalStateException( \"Attempt to apply delegated transition before it is defined.\" );\n    } else {\n      this.fireListeners( Phases.enter, new Predicate<TransitionListener<P>>( ) {\n        @Override\n        public boolean apply( TransitionListener<P> listener ) {\n          listener.enter( parent );\n          return true;\n        }\n      }, parent );\n      this.action.enter( parent );\n    }\n  }","commit_id":"d29cd4e49143bc59d989100a8753655aa65293ef","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected int remoteDeploy(\n\t\t\tString url, URL urlObj, ActionRequest actionRequest,\n\t\t\tboolean failOnError)\n\t\tthrows Exception {\n\n\t\tint responseCode = HttpServletResponse.SC_OK;\n\n\t\tGetMethod getMethod = null;\n\n\t\tString deploymentContext = ParamUtil.getString(\n\t\t\tactionRequest, \"deploymentContext\");\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = (HttpImpl)HttpUtil.getHttp();\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\turl);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tgetMethod = new GetMethod(url);\n\n\t\t\tString fileName = null;\n\n\t\t\tif (Validator.isNotNull(deploymentContext)) {\n\t\t\t\tfileName =\n\t\t\t\t\tBaseDeployer.DEPLOY_TO_PREFIX + deploymentContext + \".war\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileName = url.substring(url.lastIndexOf(CharPool.SLASH) + 1);\n\n\t\t\t\tint pos = fileName.lastIndexOf(CharPool.PERIOD);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tdeploymentContext = fileName.substring(0, pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPluginPackageUtil.registerPluginPackageInstallation(\n\t\t\t\tdeploymentContext);\n\n\t\t\tresponseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, \"errorConnectingToUrl\",\n\t\t\t\t\t\tnew Object[] {String.valueOf(responseCode)});\n\t\t\t\t}\n\n\t\t\t\treturn responseCode;\n\t\t\t}\n\n\t\t\tlong contentLength = getMethod.getResponseContentLength();\n\n\t\t\tString progressId = ParamUtil.getString(\n\t\t\t\tactionRequest, Constants.PROGRESS_ID);\n\n\t\t\tProgressInputStream pis = new ProgressInputStream(\n\t\t\t\tactionRequest, getMethod.getResponseBodyAsStream(),\n\t\t\t\tcontentLength, progressId);\n\n\t\t\tString deployDir = PrefsPropsUtil.getString(\n\t\t\t\tPropsKeys.AUTO_DEPLOY_DEPLOY_DIR,\n\t\t\t\tPropsValues.AUTO_DEPLOY_DEPLOY_DIR);\n\n\t\t\tString tmpFilePath =\n\t\t\t\tdeployDir + StringPool.SLASH + _DOWNLOAD_DIR +\n\t\t\t\t\tStringPool.SLASH + fileName;\n\n\t\t\tFile tmpFile = new File(tmpFilePath);\n\n\t\t\tif (!tmpFile.getParentFile().exists()) {\n\t\t\t\ttmpFile.getParentFile().mkdirs();\n\t\t\t}\n\n\t\t\tFileOutputStream fos = new FileOutputStream(tmpFile);\n\n\t\t\ttry {\n\t\t\t\tpis.readAll(fos);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Downloaded plugin from \" + urlObj + \" has \" +\n\t\t\t\t\t\t\tpis.getTotalRead() + \" bytes\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tpis.clearProgress();\n\t\t\t}\n\n\t\t\tgetMethod.releaseConnection();\n\n\t\t\tif (pis.getTotalRead() > 0) {\n\t\t\t\tString destination = deployDir + StringPool.SLASH + fileName;\n\n\t\t\t\tFile destinationFile = new File(destination);\n\n\t\t\t\tboolean moved = FileUtil.move(tmpFile, destinationFile);\n\n\t\t\t\tif (!moved) {\n\t\t\t\t\tFileUtil.copyFile(tmpFile, destinationFile);\n\t\t\t\t\tFileUtil.delete(tmpFile);\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(actionRequest, \"pluginDownloaded\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, UploadException.class.getName());\n\t\t\t\t}\n\n\t\t\t\tresponseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException murle) {\n\t\t\tSessionErrors.add(actionRequest, \"invalidUrl\", murle);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tSessionErrors.add(actionRequest, \"errorConnectingToUrl\", ioe);\n\t\t}\n\t\tfinally {\n\t\t\tif (getMethod != null) {\n\t\t\t\tgetMethod.releaseConnection();\n\t\t\t}\n\n\t\t\tPluginPackageUtil.endPluginPackageInstallation(deploymentContext);\n\t\t}\n\n\t\treturn responseCode;\n\t}","id":440,"modified_method":"protected int remoteDeploy(\n\t\t\tString url, URL urlObj, ActionRequest actionRequest,\n\t\t\tboolean failOnError)\n\t\tthrows Exception {\n\n\t\tint responseCode = HttpServletResponse.SC_OK;\n\n\t\tGetMethod getMethod = null;\n\n\t\tString deploymentContext = ParamUtil.getString(\n\t\t\tactionRequest, \"deploymentContext\");\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = null;\n\n\t\t\tObject httpObject = HttpUtil.getHttp();\n\n\t\t\tif (httpObject instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)httpObject;\n\n\t\t\t\thttpImpl = (HttpImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpImpl = (HttpImpl)httpObject;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\turl);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tgetMethod = new GetMethod(url);\n\n\t\t\tString fileName = null;\n\n\t\t\tif (Validator.isNotNull(deploymentContext)) {\n\t\t\t\tfileName =\n\t\t\t\t\tBaseDeployer.DEPLOY_TO_PREFIX + deploymentContext + \".war\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileName = url.substring(url.lastIndexOf(CharPool.SLASH) + 1);\n\n\t\t\t\tint pos = fileName.lastIndexOf(CharPool.PERIOD);\n\n\t\t\t\tif (pos != -1) {\n\t\t\t\t\tdeploymentContext = fileName.substring(0, pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPluginPackageUtil.registerPluginPackageInstallation(\n\t\t\t\tdeploymentContext);\n\n\t\t\tresponseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, \"errorConnectingToUrl\",\n\t\t\t\t\t\tnew Object[] {String.valueOf(responseCode)});\n\t\t\t\t}\n\n\t\t\t\treturn responseCode;\n\t\t\t}\n\n\t\t\tlong contentLength = getMethod.getResponseContentLength();\n\n\t\t\tString progressId = ParamUtil.getString(\n\t\t\t\tactionRequest, Constants.PROGRESS_ID);\n\n\t\t\tProgressInputStream pis = new ProgressInputStream(\n\t\t\t\tactionRequest, getMethod.getResponseBodyAsStream(),\n\t\t\t\tcontentLength, progressId);\n\n\t\t\tString deployDir = PrefsPropsUtil.getString(\n\t\t\t\tPropsKeys.AUTO_DEPLOY_DEPLOY_DIR,\n\t\t\t\tPropsValues.AUTO_DEPLOY_DEPLOY_DIR);\n\n\t\t\tString tmpFilePath =\n\t\t\t\tdeployDir + StringPool.SLASH + _DOWNLOAD_DIR +\n\t\t\t\t\tStringPool.SLASH + fileName;\n\n\t\t\tFile tmpFile = new File(tmpFilePath);\n\n\t\t\tif (!tmpFile.getParentFile().exists()) {\n\t\t\t\ttmpFile.getParentFile().mkdirs();\n\t\t\t}\n\n\t\t\tFileOutputStream fos = new FileOutputStream(tmpFile);\n\n\t\t\ttry {\n\t\t\t\tpis.readAll(fos);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Downloaded plugin from \" + urlObj + \" has \" +\n\t\t\t\t\t\t\tpis.getTotalRead() + \" bytes\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tpis.clearProgress();\n\t\t\t}\n\n\t\t\tgetMethod.releaseConnection();\n\n\t\t\tif (pis.getTotalRead() > 0) {\n\t\t\t\tString destination = deployDir + StringPool.SLASH + fileName;\n\n\t\t\t\tFile destinationFile = new File(destination);\n\n\t\t\t\tboolean moved = FileUtil.move(tmpFile, destinationFile);\n\n\t\t\t\tif (!moved) {\n\t\t\t\t\tFileUtil.copyFile(tmpFile, destinationFile);\n\t\t\t\t\tFileUtil.delete(tmpFile);\n\t\t\t\t}\n\n\t\t\t\tSessionMessages.add(actionRequest, \"pluginDownloaded\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (failOnError) {\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, UploadException.class.getName());\n\t\t\t\t}\n\n\t\t\t\tresponseCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException murle) {\n\t\t\tSessionErrors.add(actionRequest, \"invalidUrl\", murle);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tSessionErrors.add(actionRequest, \"errorConnectingToUrl\", ioe);\n\t\t}\n\t\tfinally {\n\t\t\tif (getMethod != null) {\n\t\t\t\tgetMethod.releaseConnection();\n\t\t\t}\n\n\t\t\tPluginPackageUtil.endPluginPackageInstallation(deploymentContext);\n\t\t}\n\n\t\treturn responseCode;\n\t}","commit_id":"f085bd2e7fc11e5ffc93d1ad2e5c78faf969b3ae","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void testDirectDownloadURL(String directDownloadURL)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = (HttpImpl)HttpUtil.getHttp();\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\tdirectDownloadURL);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tGetMethod getFileMethod = new GetMethod(directDownloadURL);\n\n\t\t\tint responseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getFileMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t}\n\t}","id":441,"modified_method":"protected void testDirectDownloadURL(String directDownloadURL)\n\t\tthrows PortalException {\n\n\t\ttry {\n\t\t\tHttpImpl httpImpl = null;\n\n\t\t\tObject httpObject = HttpUtil.getHttp();\n\n\t\t\tif (httpObject instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)httpObject;\n\n\t\t\t\thttpImpl = (HttpImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpImpl = (HttpImpl)httpObject;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\tdirectDownloadURL);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\tGetMethod getFileMethod = new GetMethod(directDownloadURL);\n\n\t\t\tint responseCode = httpClient.executeMethod(\n\t\t\t\thostConfiguration, getFileMethod);\n\n\t\t\tif (responseCode != HttpServletResponse.SC_OK) {\n\t\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new UnavailableProductVersionDirectDownloadURLException();\n\t\t}\n\t}","commit_id":"f085bd2e7fc11e5ffc93d1ad2e5c78faf969b3ae","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object convert(String key) throws WebCacheException {\n\t\tSyndFeed feed = null;\n\n\t\ttry {\n\n\t\t\t// com.liferay.portal.kernel.util.HttpUtil will break the connection\n\t\t\t// if it spends more than 5 seconds looking up a location. However,\n\t\t\t// German umlauts do not get encoded correctly. This may be a bug\n\t\t\t// with commons-httpclient or with how FeedParser uses\n\t\t\t// java.io.Reader.\n\n\t\t\t// Use http://xml.newsisfree.com/feeds/29/629.xml and\n\t\t\t// http://test.domosoft.com/up/RSS to test if German umlauts show up\n\t\t\t// correctly.\n\n\t\t\t/*Reader reader = new StringReader(\n\t\t\t\tnew String(HttpUtil.URLtoByteArray(_url)));\n\n\t\t\tchannel = FeedParser.parse(builder, reader);*/\n\n\t\t\tHttpImpl httpImpl = (HttpImpl)HttpUtil.getHttp();\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\t_url);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\thttpImpl.proxifyState(httpClient.getState(), hostConfiguration);\n\n\t\t\tHttpClientParams httpClientParams = httpClient.getParams();\n\n\t\t\thttpClientParams.setConnectionManagerTimeout(\n\t\t\t\tPropsValues.RSS_CONNECTION_TIMEOUT);\n\t\t\thttpClientParams.setSoTimeout(PropsValues.RSS_CONNECTION_TIMEOUT);\n\n\t\t\tGetMethod getMethod = new GetMethod(_url);\n\n\t\t\thttpClient.executeMethod(hostConfiguration, getMethod);\n\n\t\t\tSyndFeedInput input = new SyndFeedInput();\n\n\t\t\tfeed = input.build(\n\t\t\t\tnew XmlReader(getMethod.getResponseBodyAsStream()));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebCacheException(_url + \" \" + e.toString());\n\t\t}\n\n\t\treturn feed;\n\t}","id":442,"modified_method":"public Object convert(String key) throws WebCacheException {\n\t\tSyndFeed feed = null;\n\n\t\ttry {\n\n\t\t\t// com.liferay.portal.kernel.util.HttpUtil will break the connection\n\t\t\t// if it spends more than 5 seconds looking up a location. However,\n\t\t\t// German umlauts do not get encoded correctly. This may be a bug\n\t\t\t// with commons-httpclient or with how FeedParser uses\n\t\t\t// java.io.Reader.\n\n\t\t\t// Use http://xml.newsisfree.com/feeds/29/629.xml and\n\t\t\t// http://test.domosoft.com/up/RSS to test if German umlauts show up\n\t\t\t// correctly.\n\n\t\t\t/*Reader reader = new StringReader(\n\t\t\t\tnew String(HttpUtil.URLtoByteArray(_url)));\n\n\t\t\tchannel = FeedParser.parse(builder, reader);*/\n\n\t\t\tHttpImpl httpImpl = null;\n\n\t\t\tObject httpObject = HttpUtil.getHttp();\n\n\t\t\tif (httpObject instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)httpObject;\n\n\t\t\t\thttpImpl = (HttpImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\thttpImpl = (HttpImpl)httpObject;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfiguration = httpImpl.getHostConfiguration(\n\t\t\t\t_url);\n\n\t\t\tHttpClient httpClient = httpImpl.getClient(hostConfiguration);\n\n\t\t\thttpImpl.proxifyState(httpClient.getState(), hostConfiguration);\n\n\t\t\tHttpClientParams httpClientParams = httpClient.getParams();\n\n\t\t\thttpClientParams.setConnectionManagerTimeout(\n\t\t\t\tPropsValues.RSS_CONNECTION_TIMEOUT);\n\t\t\thttpClientParams.setSoTimeout(PropsValues.RSS_CONNECTION_TIMEOUT);\n\n\t\t\tGetMethod getMethod = new GetMethod(_url);\n\n\t\t\thttpClient.executeMethod(hostConfiguration, getMethod);\n\n\t\t\tSyndFeedInput input = new SyndFeedInput();\n\n\t\t\tfeed = input.build(\n\t\t\t\tnew XmlReader(getMethod.getResponseBodyAsStream()));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebCacheException(_url + \" \" + e.toString());\n\t\t}\n\n\t\treturn feed;\n\t}","commit_id":"70019864fcce7acc14932b6b8e718b6e5a3356ec","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deletePage(String companyId, String nodeId, String title)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, nodeId, title)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":443,"modified_method":"public static void deletePage(String companyId, String nodeId, String title)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(PORTLET_ID, nodeId, title)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteEntry(String companyId, long entryId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, entryId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":444,"modified_method":"public static void deleteEntry(String companyId, long entryId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, entryId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteProductEntry(String companyId, long productEntryId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, productEntryId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":445,"modified_method":"public static void deleteProductEntry(String companyId, long productEntryId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(PORTLET_ID, productEntryId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteArticle(String companyId, String articleId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, articleId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":446,"modified_method":"public static void deleteArticle(String companyId, String articleId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, articleId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteFile(\n\t\t\tString companyId, String portletId, String repositoryId,\n\t\t\tString fileName)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":447,"modified_method":"public static void deleteFile(\n\t\t\tString companyId, String portletId, String repositoryId,\n\t\t\tString fileName)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID,\n\t\t\t\tLuceneFields.getUID(portletId, repositoryId, fileName)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void deleteMessage(String companyId, String messageId)\n\t\tthrows IOException {\n\n\t\tsynchronized (IndexWriter.class) {\n\t\t\tIndexReader reader = LuceneUtil.getReader(companyId);\n\n\t\t\treader.deleteDocuments(\n\t\t\t\tnew Term(\n\t\t\t\t\tLuceneFields.UID,\n\t\t\t\t\tLuceneFields.getUID(PORTLET_ID, messageId)));\n\n\t\t\treader.close();\n\t\t}\n\t}","id":448,"modified_method":"public static void deleteMessage(String companyId, String messageId)\n\t\tthrows IOException {\n\n\t\tLuceneUtil.deleteDocuments(\n\t\t\tcompanyId,\n\t\t\tnew Term(\n\t\t\t\tLuceneFields.UID, LuceneFields.getUID(PORTLET_ID, messageId)));\n\t}","commit_id":"54640318d046a1ffac9341621550d1390530f242","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void visitLocalVariable(@NotNull PsiLocalVariable variable) {\n      super.visitLocalVariable(variable);\n      if (m_ignoreStaticMethods) {\n        final PsiMethod aMethod =\n          PsiTreeUtil.getParentOfType(variable,\n                                      PsiMethod.class);\n        if (aMethod == null) {\n          return;\n        }\n        if (aMethod.hasModifierProperty(PsiModifier.STATIC)) {\n          return;\n        }\n      }\n      final PsiClass aClass =\n        ClassUtils.getContainingClass(variable);\n      if (aClass == null) {\n        return;\n      }\n      final String variableName = variable.getName();\n      final PsiField[] fields = aClass.getAllFields();\n      for (final PsiField field : fields) {\n        if (checkFieldName(field, variableName, aClass)) {\n          registerVariableError(variable);\n        }\n      }\n    }","id":449,"modified_method":"@Override\n    public void visitLocalVariable(@NotNull PsiLocalVariable variable) {\n      super.visitLocalVariable(variable);\n      if (m_ignoreStaticMethods) {\n        final PsiMember member = PsiTreeUtil.getParentOfType(variable, PsiMethod.class, PsiClassInitializer.class);\n        if (member != null && member.hasModifierProperty(PsiModifier.STATIC)) {\n          return;\n        }\n      }\n      final PsiClass aClass = checkFieldNames(variable);\n      if (aClass == null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      if (!(variable.getDeclarationScope() instanceof PsiCatchSection)) {\n        return;\n      }\n      final PsiClass aClass =\n        ClassUtils.getContainingClass(variable);\n      if (aClass == null) {\n        return;\n      }\n      final String variableName = variable.getName();\n      final PsiField[] fields = aClass.getAllFields();\n      for (final PsiField field : fields) {\n        if (checkFieldName(field, variableName, aClass)) {\n          registerVariableError(variable);\n        }\n      }\n    }","id":450,"modified_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      final PsiElement declarationScope = variable.getDeclarationScope();\n      if (!(declarationScope instanceof PsiCatchSection) && !(declarationScope instanceof PsiForeachStatement)) {\n        return;\n      }\n      if (m_ignoreStaticMethods) {\n        final PsiMember member = PsiTreeUtil.getParentOfType(variable, PsiMethod.class, PsiClassInitializer.class);\n        if (member != null && member.hasModifierProperty(PsiModifier.STATIC)) {\n          return;\n        }\n      }\n      final PsiClass aClass = checkFieldNames(variable);\n      if (aClass == null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      if (variable.getDeclarationScope() instanceof PsiCatchSection) {\n        return;\n      }\n      final PsiMethod method =\n        PsiTreeUtil.getParentOfType(variable,\n                                    PsiMethod.class);\n      if (method == null) {\n        return;\n      }\n      if (m_ignoreForConstructors && method.isConstructor()) {\n        return;\n      }\n      if (m_ignoreForAbstractMethods) {\n        if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n          return;\n        }\n        final PsiClass containingClass = method.getContainingClass();\n        if (containingClass.isInterface()) {\n          return;\n        }\n      }\n      if (m_ignoreForPropertySetters) {\n        final String methodName = method.getName();\n        final PsiType returnType = method.getReturnType();\n        if (methodName.startsWith(HardcodedMethodConstants.SET) &&\n            PsiType.VOID.equals(returnType)) {\n          return;\n        }\n      }\n      final PsiClass aClass =\n        ClassUtils.getContainingClass(variable);\n      if (aClass == null) {\n        return;\n      }\n      final String variableName = variable.getName();\n      final PsiField[] fields = aClass.getAllFields();\n      for (final PsiField field : fields) {\n        if (checkFieldName(field, variableName, aClass)) {\n          if (m_ignoreStaticMethodParametersHidingInstanceFields &&\n              !field.hasModifierProperty(PsiModifier.STATIC) &&\n              method.hasModifierProperty(PsiModifier.STATIC)) {\n            continue;\n          }\n          registerVariableError(variable);\n        }\n      }\n    }","id":451,"modified_method":"@Override\n    public void visitParameter(@NotNull PsiParameter variable) {\n      super.visitParameter(variable);\n      final PsiElement declarationScope = variable.getDeclarationScope();\n      if (!(declarationScope instanceof PsiMethod)) {\n        return;\n      }\n      final PsiMethod method = (PsiMethod)declarationScope;\n      if (m_ignoreForConstructors && method.isConstructor()) {\n        return;\n      }\n      if (m_ignoreForAbstractMethods) {\n        if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n          return;\n        }\n        final PsiClass containingClass = method.getContainingClass();\n        if (containingClass != null && containingClass.isInterface()) {\n          return;\n        }\n      }\n      if (m_ignoreForPropertySetters) {\n        final String methodName = method.getName();\n        final PsiType returnType = method.getReturnType();\n        if (methodName.startsWith(HardcodedMethodConstants.SET) && PsiType.VOID.equals(returnType)) {\n          return;\n        }\n      }\n      final PsiClass aClass = checkFieldName(variable, method);\n      if (aClass ==  null) {\n        return;\n      }\n      registerVariableError(variable, aClass);\n    }","commit_id":"3ebb42da85a43104bef42c20b5078ca420eb42c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            if (status.getResponseTime() >= 0) {\n            \treturn status.getResponseTime() + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","id":452,"modified_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            Double responseTime = status.getResponseTime();\n            if (responseTime != null && responseTime >= 0) {\n            \treturn responseTime + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","commit_id":"9f699f9717bd9e99b1a0bc8a29b55289c97b8279","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            if (status.getResponseTime() >= 0) {\n            \treturn status.getResponseTime() + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","id":453,"modified_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            Double responseTime = status.getResponseTime();\n            if (responseTime != null && responseTime >= 0) {\n            \treturn responseTime + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","commit_id":"7ca5ad548f4feeb10e467cd90d3253b5aa51cd41","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            if (status.getResponseTime() >= 0) {\n            \treturn status.getResponseTime() + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","id":454,"modified_method":"private String getResponseText(PollStatus status) {\n        if (status.isAvailable()) {\n            Double responseTime = status.getResponseTime();\n            if (responseTime != null && responseTime >= 0) {\n            \treturn responseTime + \"ms\";\n            } else {\n                return \"\";\n            }\n        } else {\n            return status.getReason(); \n        }\n    }","commit_id":"0d2b5c4503f6626a80407dda96195a4ec7b8fe8d","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Returns the html for the head navigation row.<p>\n     * \n     * This method only creates the head row part, be sure to add the\n     * dhtml menu entries by calling the method buildNavigationHeadMenus(java.lang.String).<p>\n     * \n     * @param homeLabel the label of the \"home\" link\n     * @param styleLink the CSS class name of the link node\n     * @param styleSeparator the CSS class name of the spearator node\n     * @return the html for the head navigation row\n     */\n    public String buildNavigationHead(String homeLabel, String styleLink, String styleSeparator) {\n\n        boolean firstItem = true;\n        StringBuffer result = new StringBuffer(1024);\n        result.append(\"<div class=\\\"\");\n        result.append(styleLink);\n        result.append(\"\\\">\\n\");\n        result.append(\"\\t<!-- Start Topnavigation -->\\n\");\n\n        List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n        boolean showHomeLink = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.show\", \"true\")).booleanValue();\n        if (showHomeLink && !showHeadNavImages()) {\n            // create the \"home\" link at first position\n            boolean onlyIndex = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.onlyindex\", \"false\")).booleanValue();\n            String url = getStartFolder();\n            String target = \"_self\";\n            if ((onlyIndex && isDefaultFile(getStartFolder(), getRequestContext().getUri())) || (! onlyIndex)) {\n                // settings only valid for start page of microsite or for all subpages\n                url = getConfigurationValue(\"headnav.homelink/link.url\", getStartFolder());\n                homeLabel = getConfigurationValue(\"headnav.homelink/link.text\", homeLabel);\n                target = getConfigurationValue(\"headnav.homelink/link.target\", \"_self\");\n            }\n            \n            if (url.startsWith(\"/\")) {\n                // internal link\n                url = link(url);\n            }\n            homeLabel = homeLabel.toUpperCase();\n\n            result.append(\"<a class=\\\"\");\n            result.append(styleLink);\n            result.append(\"\\\" href=\\\"\");\n            result.append(url);\n            result.append(\"\\\" title=\\\"\");\n            result.append(homeLabel);\n            result.append(\"\\\" target=\\\"\");\n            result.append(target);\n            result.append(\"\\\">\");\n            result.append(homeLabel);\n            result.append(\"<\/a>\\n\");\n            firstItem = false;\n        } else {\n            // create a table to allow vertical alignment of images\n            result.append(\"<table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\"><tr>\");\n        }\n\n        int count = -1;\n        String showItemProperty;\n        for (int i = 0; i < navElements.size(); i++) {\n            CmsJspNavElement nav = (CmsJspNavElement)navElements.get(i);\n            showItemProperty = property(\n                PROPERTY_HEADNAV_USE,\n                nav.getResourceName(),\n                getHeadNavItemDefaultStringValue());\n            boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n            if (nav.isFolderLink() && showItem) {\n                // create an entry for every folder\n                count++;\n                String navText = CmsEncoder.escapeXml(nav.getNavText().toUpperCase());\n                if (showHeadNavImages()) {\n                    // build row with images\n                    result.append(\"<td style= \\\"vertical-align: middle\\\">\");\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    result.append(\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link(nav.getResourceName()));\n                    result.append(\"\\\">\");\n                    result.append(\"<img src=\\\"\");\n                    result.append(link(nav.getNavImage()));\n                    result.append(\"\\\" border=\\\"0\\\" alt=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\">\");\n                    result.append(\"<\/a><\/td>\\n\");\n                } else {\n                    // build row with text links\n                    if (!firstItem) {\n                        result.append(\"<span class=\\\"\");\n                        result.append(styleSeparator);\n                        result.append(\"\\\">|<\/span>\\n\");\n                    }\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    if (getHeadNavMarkCurrent() && getRequestContext().getUri().startsWith(nav.getResourceName())) {\n                        // mark currently active top folder with bold font\n                        result.append(\" style=\\\"font-weight: bold;\\\"\");\n                    }\n                    result.append(\" class=\\\"\");\n                    result.append(styleLink);\n                    result.append(\"\\\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link(nav.getResourceName()));\n                    result.append(\"\\\">\");\n                    result.append(navText);\n                    result.append(\"<\/a>\\n\");\n                }\n                firstItem = false;\n            }\n        }\n\n        if (showHeadNavImages()) {\n            // close table\n            result.append(\"<\/tr><\/table>\");\n        }\n\n        result.append(\"\\t<!-- End Topnavigation -->\\n\");\n        result.append(\"<\/div>\\n\");\n        return result.toString();\n    }","id":455,"modified_method":"/**\n     * Returns the html for the head navigation row.<p>\n     * \n     * This method only creates the head row part, be sure to add the\n     * dhtml menu entries by calling the method buildNavigationHeadMenus(java.lang.String).<p>\n     * \n     * @param homeLabel the label of the \"home\" link\n     * @param styleLink the CSS class name of the link node\n     * @param styleSeparator the CSS class name of the spearator node\n     * @return the html for the head navigation row\n     */\n    public String buildNavigationHead(String homeLabel, String styleLink, String styleSeparator) {\n\n        boolean firstItem = true;\n        StringBuffer result = new StringBuffer(1024);\n        result.append(\"<div class=\\\"\");\n        result.append(styleLink);\n        result.append(\"\\\">\\n\");\n        result.append(\"\\t<!-- Start Topnavigation -->\\n\");\n        \n        boolean showHomeLink = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.show\", \"true\")).booleanValue();\n        if (showHomeLink && !showHeadNavImages()) {\n            // create the \"home\" link at first position\n            boolean onlyIndex = Boolean.valueOf(getConfigurationValue(\"headnav.homelink/link.onlyindex\", \"false\")).booleanValue();\n            String url = getStartFolder();\n            String target = \"_self\";\n            if ((onlyIndex && isDefaultFile(getStartFolder(), getRequestContext().getUri())) || (! onlyIndex)) {\n                // settings only valid for start page of microsite or for all subpages\n                url = getConfigurationValue(\"headnav.homelink/link.url\", getStartFolder());\n                homeLabel = getConfigurationValue(\"headnav.homelink/link.text\", homeLabel);\n                target = getConfigurationValue(\"headnav.homelink/link.target\", \"_self\");\n            }\n            \n            if (url.startsWith(\"/\")) {\n                // internal link\n                url = link(url);\n            }\n            homeLabel = homeLabel.toUpperCase();\n\n            result.append(\"<a class=\\\"\");\n            result.append(styleLink);\n            result.append(\"\\\" href=\\\"\");\n            result.append(url);\n            result.append(\"\\\" title=\\\"\");\n            result.append(homeLabel);\n            result.append(\"\\\" target=\\\"\");\n            result.append(target);\n            result.append(\"\\\">\");\n            result.append(homeLabel);\n            result.append(\"<\/a>\\n\");\n            firstItem = false;\n        } else {\n            // create a table to allow vertical alignment of images\n            result.append(\"<table border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\"><tr>\");\n        }\n\n        int count = -1;\n        String showItemProperty;\n        \n        // check if head navigation has to be created manually from config file\n        boolean manualHeadConfig = isHeadNavManual();\n        \n        List navElements = new ArrayList();\n        if (manualHeadConfig) {\n            // manual configuration, get List of nav items from config file\n            navElements = getHeadNavItemsFromConfig(0, \"0\");\n        } else {\n            // automatic, get folder navigation\n            navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n        }\n        for (int i = 0; i < navElements.size(); i++) {\n            CmsJspNavElement nav = (CmsJspNavElement)navElements.get(i);\n            String link = nav.getResourceName();\n            if (link.startsWith(\"/\")) {\n                link = link(link);\n            }\n            showItemProperty = property(\n                PROPERTY_HEADNAV_USE,\n                nav.getResourceName(),\n                getHeadNavItemDefaultStringValue());\n            boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n            if (manualHeadConfig || (nav.isFolderLink() && showItem)) {\n                // create an entry for every folder\n                count++;\n                String navText = CmsEncoder.escapeXml(nav.getNavText().toUpperCase());\n                String target = nav.getInfo();\n                if (CmsStringUtil.isEmpty(target)) {\n                    target = \"_self\";\n                }\n                if (showHeadNavImages()) {\n                    // build row with images\n                    result.append(\"<td style= \\\"vertical-align: middle\\\">\");\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    result.append(\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link);\n                    result.append(\"\\\" target=\\\"\");\n                    result.append(target);\n                    result.append(\"\\\">\");\n                    result.append(\"<img src=\\\"\");\n                    result.append(link(nav.getNavImage()));\n                    result.append(\"\\\" border=\\\"0\\\" alt=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\">\");\n                    result.append(\"<\/a><\/td>\\n\");\n                } else {\n                    // build row with text links\n                    if (!firstItem) {\n                        result.append(\"<span class=\\\"\");\n                        result.append(styleSeparator);\n                        result.append(\"\\\">|<\/span>\\n\");\n                    }\n                    result.append(\"<a\");\n                    if (showMenus()) {\n                        result.append(\" onmouseover=\\\"buttonMouseover(event, 'menu\");\n                        result.append(count);\n                        result.append(\"');\\\"\");\n                        if (getHeadNavMenuClick()) {\n                            // only show menus on mouse click\n                            result.append(\" onclick=\\\"return buttonClick(event, 'menu\");\n                            result.append(count);\n                            result.append(\"');\\\"\");\n                        }\n                    }\n                    if (getHeadNavMarkCurrent() && getRequestContext().getUri().startsWith(nav.getResourceName())) {\n                        // mark currently active top folder with bold font\n                        result.append(\" style=\\\"font-weight: bold;\\\"\");\n                    }\n                    result.append(\" class=\\\"\");\n                    result.append(styleLink);\n                    result.append(\"\\\" title=\\\"\");\n                    result.append(navText);\n                    result.append(\"\\\" href=\\\"\");\n                    result.append(link);\n                    result.append(\"\\\" target=\\\"\");\n                    result.append(target);\n                    result.append(\"\\\">\");\n                    result.append(navText);\n                    result.append(\"<\/a>\\n\");\n                }\n                firstItem = false;\n            }\n        }\n\n        if (showHeadNavImages()) {\n            // close table\n            result.append(\"<\/tr><\/table>\");\n        }\n\n        result.append(\"\\t<!-- End Topnavigation -->\\n\");\n        result.append(\"<\/div>\\n\");\n        return result.toString();\n    }","commit_id":"f6b029bf132e4b2f69ed7460186565e2fb999cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the html for the head navigation menus.<p>\n     * \n     * This method only creates the menu entries, be sure to\n     * build the head row calling the menus, too.<p>\n     * \n     * @param styleClass the CSS class name of the &lt;div&gt; nodes\n     * @return the html for the head navigation menus\n     */\n    public String buildNavigationHeadMenus(String styleClass) {\n\n        CmsTemplateParts parts = null;\n        boolean cacheNavEnabled = !getRequestContext().currentProject().isOnlineProject();\n        String cacheKey = null;\n        if (cacheNavEnabled) {\n            // cache naviagtion in offline project to avoid performance issues\n            parts = CmsTemplateParts.getInstance(this);\n            // create unique cache key with: site, head nav folder, area folder, menu depth, show submenus flag\n            StringBuffer key = new StringBuffer(8);\n            key.append(getRequestContext().getSiteRoot());\n            key.append(\"_\");\n            key.append(getHeadNavFolder().hashCode());\n            key.append(\"_\");\n            key.append(getStartFolder().hashCode());\n            key.append(\"_\");\n            key.append(getMenuDepth());\n            key.append(\"_\");\n            key.append(showMenus());\n            key.append(\"_\");\n            key.append(showAccessibleVersion());\n            key.append(\"_\");\n            key.append(getLocale());\n            cacheKey = key.toString();\n            String cachedNav = (String)parts.getPart(cacheKey);\n            if (CmsStringUtil.isNotEmpty(cachedNav)) {\n                // found previously cached navigation menu structure, return it\n                return cachedNav;\n            }\n        }\n\n        StringBuffer result = new StringBuffer(4096);\n\n        if (showMenus()) {\n            // only create navigation if the template is configured to show it\n            List navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n\n            int count = -1;\n            String showItemProperty;\n            for (int i = 0; i < navElements.size(); i++) {\n                CmsJspNavElement foldernav = (CmsJspNavElement)navElements.get(i);\n                showItemProperty = property(\n                    PROPERTY_HEADNAV_USE,\n                    foldernav.getResourceName(),\n                    getHeadNavItemDefaultStringValue());\n                boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n                if (foldernav.isFolderLink() && showItem) {\n                    // create a menu entry for every found folder\n                    count++;\n                    String subfolder = foldernav.getResourceName();\n\n                    // get all navigation elements of the sub folder\n                    List subNav = getNavigation().getNavigationForFolder(subfolder);\n                    result.append(getMenuNavigation(subNav, styleClass, \"menu\" + count, 1));\n                }\n            }\n\n            if (cacheNavEnabled) {\n                // cache the generated navigation submenu output\n                parts.setPart(cacheKey, result.toString());\n            }\n        }\n        return result.toString();\n    }","id":456,"modified_method":"/**\n     * Returns the html for the head navigation menus.<p>\n     * \n     * This method only creates the menu entries, be sure to\n     * build the head row calling the menus, too.<p>\n     * \n     * @param styleClass the CSS class name of the &lt;div&gt; nodes\n     * @return the html for the head navigation menus\n     */\n    public String buildNavigationHeadMenus(String styleClass) {\n\n        CmsTemplateParts parts = null;\n        boolean cacheNavEnabled = !getRequestContext().currentProject().isOnlineProject();\n        String cacheKey = null;\n        if (cacheNavEnabled) {\n            // cache naviagtion in offline project to avoid performance issues\n            parts = CmsTemplateParts.getInstance(this);\n            // create unique cache key with: site, head nav folder, area folder, menu depth, show submenus flag\n            StringBuffer key = new StringBuffer(8);\n            key.append(getRequestContext().getSiteRoot());\n            key.append(\"_\");\n            key.append(getHeadNavFolder().hashCode());\n            key.append(\"_\");\n            key.append(getStartFolder().hashCode());\n            key.append(\"_\");\n            key.append(getMenuDepth());\n            key.append(\"_\");\n            key.append(showMenus());\n            key.append(\"_\");\n            key.append(showAccessibleVersion());\n            key.append(\"_\");\n            key.append(getLocale());\n            if (isHeadNavManual()) {\n                // for manual head nav configuration, append config path to cache key\n                key.append(\"_\");\n                key.append(getConfigPath().hashCode());\n            }\n            cacheKey = key.toString();\n            String cachedNav = (String)parts.getPart(cacheKey);\n            if (CmsStringUtil.isNotEmpty(cachedNav)) {\n                // found previously cached navigation menu structure, return it\n                return cachedNav;\n            }\n        }\n\n        StringBuffer result = new StringBuffer(4096);\n\n        if (showMenus()) {\n            // only create navigation if the template is configured to show it\n            \n            // check if head navigation has to be created manually from config file\n            boolean manualHeadConfig = isHeadNavManual();\n            \n            List navElements = new ArrayList();\n            if (manualHeadConfig) {\n                // manual configuration, get List of nav items from config file\n                navElements = getHeadNavItemsFromConfig(0, \"0\");\n            } else {\n                // automatic, get folder navigation\n                navElements = getNavigation().getNavigationForFolder(getHeadNavFolder());\n            }\n\n            int count = -1;\n            String showItemProperty;\n            for (int i = 0; i < navElements.size(); i++) {\n                CmsJspNavElement foldernav = (CmsJspNavElement)navElements.get(i);\n                showItemProperty = property(\n                    PROPERTY_HEADNAV_USE,\n                    foldernav.getResourceName(),\n                    getHeadNavItemDefaultStringValue());\n                boolean showItem = Boolean.valueOf(showItemProperty).booleanValue();\n                if (manualHeadConfig || (foldernav.isFolderLink() && showItem)) {\n                    // create a menu entry for every found folder\n                    count++;\n                    String subfolder = foldernav.getResourceName();\n                    \n                    List subNav = new ArrayList();\n                    String menuIndexes = null;\n                    if (manualHeadConfig) {\n                        menuIndexes = String.valueOf(i);\n                        subNav = getHeadNavItemsFromConfig(1, menuIndexes);\n                    } else {\n                        // get all navigation elements of the sub folder\n                        subNav = getNavigation().getNavigationForFolder(subfolder);\n                    }\n                    result.append(getMenuNavigation(subNav, styleClass, \"menu\" + count, 1, menuIndexes));\n                }\n            }\n\n            if (cacheNavEnabled) {\n                // cache the generated navigation submenu output\n                parts.setPart(cacheKey, result.toString());\n            }\n        }\n        return result.toString();\n    }","commit_id":"f6b029bf132e4b2f69ed7460186565e2fb999cad","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\r\n\tpublic void create () {\r\n\t\tbatch = new SpriteBatch();\r\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\r\n\t\tfont = new BitmapFont();\r\n\t\tstage = new Stage(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);\r\n\t\tGdx.input.setInputProcessor(stage);\r\n\r\n\t\t{\r\n\t\t\tstatusLabel = new Label(\"\", skin);\r\n\t\t\tstatusLabel.setWrap(true);\r\n\t\t\tstatusLabel.setWidth(Gdx.graphics.getWidth() * 0.96f);\r\n\t\t\tstatusLabel.setAlignment(Align.center);\r\n\t\t\tstatusLabel.setPosition(Gdx.graphics.getWidth() * 0.5f - statusLabel.getWidth() * 0.5f, 30f);\r\n\t\t\tstatusLabel.setColor(Color.CYAN);\r\n\t\t\tstage.addActor(statusLabel);\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tClickListener clickListener = new ClickListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void clicked (InputEvent event, float x, float y) {\r\n\t\t\t\t\tsuper.clicked(event, x, y);\r\n\r\n\t\t\t\t\tdoImageDownload = event.getListenerActor() == textButton;\r\n\r\n\t\t\t\t\ttextButton.setDisabled(true);\r\n\t\t\t\t\ttextButton.setTouchable(Touchable.disabled);\r\n\r\n\t\t\t\t\ttextButtonTxt.setDisabled(true);\r\n\t\t\t\t\ttextButtonTxt.setTouchable(Touchable.disabled);\r\n\r\n\t\t\t\t\tif (texture != null) texture.dispose();\r\n\t\t\t\t\ttexture = null;\r\n\t\t\t\t\ttext = null;\r\n\r\n\t\t\t\t\tHttpRequest httpRequest = new HttpRequest(Net.HttpMethods.GET);\r\n\t\t\t\t\tif (doImageDownload)\r\n\t\t\t\t\t\thttpRequest.setUrl(\"http://i.imgur.com/vxomF.jpg\");\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\thttpRequest.setUrl(\"http://www.apache.org/licenses/LICENSE-2.0.txt\");\r\n\r\n\t\t\t\t\tGdx.net.sendHttpRequest(httpRequest, NetAPITest.this);\r\n\r\n\t\t\t\t\tstatusLabel.setText(\"Downloading data from \" + httpRequest.getUrl());\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\ttextButton = new TextButton(\"Download image\", skin);\r\n\t\t\ttextButton.setPosition(Gdx.graphics.getWidth() * 0.5f - textButton.getWidth(), 60f);\r\n\t\t\ttextButton.addListener(clickListener);\r\n\t\t\tstage.addActor(textButton);\r\n\r\n\t\t\ttextButtonTxt = new TextButton(\"Download text\", skin);\r\n\t\t\ttextButtonTxt.setPosition(Gdx.graphics.getWidth() * 0.5f, 60f);\r\n\t\t\ttextButtonTxt.addListener(clickListener);\r\n\t\t\tstage.addActor(textButtonTxt);\r\n\t\t}\r\n\r\n\t}","id":457,"modified_method":"@Override\r\n\tpublic void create () {\r\n\t\tbatch = new SpriteBatch();\r\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\r\n\t\tfont = new BitmapFont();\r\n\t\tstage = new Stage(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);\r\n\t\tGdx.input.setInputProcessor(stage);\r\n\r\n\t\t{\r\n\t\t\tstatusLabel = new Label(\"\", skin);\r\n\t\t\tstatusLabel.setWrap(true);\r\n\t\t\tstatusLabel.setWidth(Gdx.graphics.getWidth() * 0.96f);\r\n\t\t\tstatusLabel.setAlignment(Align.center);\r\n\t\t\tstatusLabel.setPosition(Gdx.graphics.getWidth() * 0.5f - statusLabel.getWidth() * 0.5f, 30f);\r\n\t\t\tstatusLabel.setColor(Color.CYAN);\r\n\t\t\tstage.addActor(statusLabel);\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tClickListener clickListener = new ClickListener() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void clicked (InputEvent event, float x, float y) {\r\n\t\t\t\t\tsuper.clicked(event, x, y);\r\n\r\n\t\t\t\t\tclickedButton = event.getListenerActor();\r\n\t\t\t\t\tsetButtonDisabled(true);\r\n\t\t\t\t\tif (texture != null) texture.dispose();\r\n\t\t\t\t\ttexture = null;\r\n\t\t\t\t\ttext = null;\r\n\r\n\t\t\t\t\tString url;\r\n\t\t\t\t\tString httpMethod = Net.HttpMethods.GET;\r\n\t\t\t\t\tString requestContent = null;\r\n\t\t\t\t\tif (clickedButton == btnDownloadImage)\r\n\t\t\t\t\t\turl = \"http://i.imgur.com/vxomF.jpg\";\r\n\t\t\t\t\telse if (clickedButton == btnDownloadText)\r\n\t\t\t\t\t\turl = \"http://www.apache.org/licenses/LICENSE-2.0.txt\";\r\n\t\t\t\t\telse if (clickedButton == btnDownloadError)\r\n\t\t\t\t\t\turl = \"http://www.badlogicgames.com/doesnotexist\";\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\turl = \"http://posttestserver.com/post.php?dump\";\r\n\t\t\t\t\t\thttpMethod = Net.HttpMethods.POST;\r\n\t\t\t\t\t\trequestContent = \"name1=value1&name2=value2\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tHttpRequest httpRequest = new HttpRequest(httpMethod);\r\n\t\t\t\t\thttpRequest.setUrl(url);\r\n\t\t\t\t\thttpRequest.setContent(requestContent);\r\n\t\t\t\t\tGdx.net.sendHttpRequest(httpRequest, NetAPITest.this);\r\n\r\n\t\t\t\t\tstatusLabel.setText(\"Downloading data from \" + httpRequest.getUrl());\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tbtnDownloadImage = new TextButton(\"GET Image\", skin);\r\n\t\t\tbtnDownloadImage.setPosition(Gdx.graphics.getWidth() * 0.5f - btnDownloadImage.getWidth() * 1.5f, 60f);\r\n\t\t\tbtnDownloadImage.addListener(clickListener);\r\n\t\t\tstage.addActor(btnDownloadImage);\r\n\r\n\t\t\tbtnDownloadText = new TextButton(\"GET Text\", skin);\r\n\t\t\tbtnDownloadText.setPosition(btnDownloadImage.getX() + btnDownloadImage.getWidth() + 10, 60f);\r\n\t\t\tbtnDownloadText.addListener(clickListener);\r\n\t\t\tstage.addActor(btnDownloadText);\r\n\r\n\t\t\tbtnDownloadError = new TextButton(\"GET Error\", skin);\r\n\t\t\tbtnDownloadError.setPosition(btnDownloadText.getX() + btnDownloadText.getWidth() + 10, 60f);\r\n\t\t\tbtnDownloadError.addListener(clickListener);\r\n\t\t\tstage.addActor(btnDownloadError);\r\n\r\n\t\t\tbtnPost = new TextButton(\"POST\", skin);\r\n\t\t\tbtnPost.setPosition(btnDownloadError.getX() + btnDownloadError.getWidth() + 10, 60f);\r\n\t\t\tbtnPost.addListener(clickListener);\r\n\t\t\tstage.addActor(btnPost);\r\n\t\t}\r\n\r\n\t}","commit_id":"634715f5fcedf47e29e2fe1cce4571150f0dfc8b","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void createHUD() {\n\t\thud = new Stage();\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\n\t\tmodelsWindow = new CollapsableWindow(\"Models\", skin);\n\t\tfinal List list = new List(models, skin);\n\t\tlist.addListener(new ClickListener() {\n\t\t\t@Override\n\t\t\tpublic void clicked (InputEvent event, float x, float y) {\n\t\t\t\tif (!modelsWindow.isCollapsed() && getTapCount() == 2) {\n\t\t\t\t\tonModelClicked(list.getSelection());\n\t\t\t\t\tmodelsWindow.collapse();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tmodelsWindow.row();\n\t\tmodelsWindow.add(list);\n\t\tmodelsWindow.pack();\n\t\tmodelsWindow.pack();\n\t\tmodelsWindow.setY(Gdx.graphics.getHeight()-modelsWindow.getHeight());\n\t\tmodelsWindow.collapse();\n\t\thud.addActor(modelsWindow);\n\t\tfpsLabel = new Label(\"FPS: 999\", skin);\n\t\thud.addActor(fpsLabel);\n\t}","id":458,"modified_method":"protected void createHUD() {\n\t\thud = new Stage(PREF_HUDWIDTH, PREF_HUDHEIGHT, true);\n\t\thudWidth = hud.getWidth();\n\t\thudHeight = hud.getHeight();\n\t\tskin = new Skin(Gdx.files.internal(\"data/uiskin.json\"));\n\n\t\tfinal List modelsList = new List(models, skin);\n\t\tmodelsList.addListener(new ClickListener() {\n\t\t\t@Override\n\t\t\tpublic void clicked (InputEvent event, float x, float y) {\n\t\t\t\tif (!modelsWindow.isCollapsed() && getTapCount() == 2) {\n\t\t\t\t\tonModelClicked(modelsList.getSelection());\n\t\t\t\t\tmodelsWindow.collapse();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tmodelsWindow = addListWindow(\"Models\", modelsList, 0, -1);\n\t\t\n\t\tfpsLabel = new Label(\"FPS: 999\", skin);\n\t\thud.addActor(fpsLabel);\n\t\tgridCheckBox = new CheckBox(\"Show grid\", skin);\n\t\tgridCheckBox.setChecked(showAxes);\n\t\tgridCheckBox.addListener(new ChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void changed (ChangeEvent event, Actor actor) {\n\t\t\t\tshowAxes = gridCheckBox.isChecked();\n\t\t\t}\n\t\t});\n\t\tgridCheckBox.setPosition(hudWidth - gridCheckBox.getWidth(), 0);\n\t\thud.addActor(gridCheckBox);\n\t\t\n\t\trotateCheckBox = new CheckBox(\"Rotate\", skin);\n\t\trotateCheckBox.setChecked(true);\n\t\trotateCheckBox.setPosition(hudWidth - rotateCheckBox.getWidth(), gridCheckBox.getHeight());\n\t\thud.addActor(rotateCheckBox);\n\t\t\n\t\tmoveCheckBox = new CheckBox(\"Move\", skin);\n\t\tmoveCheckBox.setChecked(false);\n\t\tmoveCheckBox.setPosition(hudWidth - moveCheckBox.getWidth(), rotateCheckBox.getTop());\n\t\thud.addActor(moveCheckBox);\n\t}","commit_id":"2d338e822a0b13af470021dab65bfc34ba8c9d91","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tprotected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMStructure structure,\n\t\t\tString redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletURLImpl portletURL = new PortletURLImpl(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/copy_structure\");\n\n\t\tlong classNameId = PortalUtil.getClassNameId(DDMStructure.class);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classNameId\", String.valueOf(classNameId), false);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classPK\", String.valueOf(structure.getStructureId()), false);\n\t\tportletURL.setParameter(\n\t\t\t\"copyFormTemplates\",\n\t\t\tParamUtil.getString(actionRequest, \"copyFormTemplates\"), false);\n\t\tportletURL.setParameter(\n\t\t\t\"copyDisplayTemplates\",\n\t\t\tParamUtil.getString(actionRequest, \"copyDisplayTemplates\"), false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","id":459,"modified_method":"@Override\n\tprotected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMStructure structure,\n\t\t\tString redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tLiferayPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/copy_structure\");\n\n\t\tlong classNameId = PortalUtil.getClassNameId(DDMStructure.class);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classNameId\", String.valueOf(classNameId), false);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classPK\", String.valueOf(structure.getStructureId()), false);\n\t\tportletURL.setParameter(\n\t\t\t\"copyFormTemplates\",\n\t\t\tParamUtil.getString(actionRequest, \"copyFormTemplates\"), false);\n\t\tportletURL.setParameter(\n\t\t\t\"copyDisplayTemplates\",\n\t\t\tParamUtil.getString(actionRequest, \"copyDisplayTemplates\"), false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"53ed6c3e81f247e6c06f0419e119e1338168d205","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMTemplate template, String redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletURLImpl portletURL = new PortletURLImpl(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/copy_template\");\n\t\tportletURL.setParameter(\n\t\t\t\"templateId\", String.valueOf(template.getTemplateId()), false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","id":460,"modified_method":"@Override\n\tprotected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMTemplate template, String redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tLiferayPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/copy_template\");\n\t\tportletURL.setParameter(\n\t\t\t\"templateId\", String.valueOf(template.getTemplateId()), false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"53ed6c3e81f247e6c06f0419e119e1338168d205","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMTemplate template, String redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString portletResourceNamespace = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResourceNamespace\");\n\t\tlong classNameId = ParamUtil.getLong(actionRequest, \"classNameId\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString structureAvailableFields = ParamUtil.getString(\n\t\t\tactionRequest, \"structureAvailableFields\");\n\n\t\tPortletURLImpl portletURL = new PortletURLImpl(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/edit_template.jsp\");\n\t\tportletURL.setParameter(\"redirect\", redirect, false);\n\t\tportletURL.setParameter(\n\t\t\t\"portletResourceNamespace\", portletResourceNamespace, false);\n\t\tportletURL.setParameter(\n\t\t\t\"templateId\", String.valueOf(template.getTemplateId()), false);\n\t\tportletURL.setParameter(\n\t\t\t\"groupId\", String.valueOf(template.getGroupId()), false);\n\t\tportletURL.setParameter(\n\t\t\t\"classNameId\", String.valueOf(classNameId), false);\n\t\tportletURL.setParameter(\"classPK\", String.valueOf(classPK), false);\n\t\tportletURL.setParameter(\"type\", template.getType(), false);\n\t\tportletURL.setParameter(\n\t\t\t\"structureAvailableFields\", structureAvailableFields, false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","id":461,"modified_method":"protected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMTemplate template, String redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString portletResourceNamespace = ParamUtil.getString(\n\t\t\tactionRequest, \"portletResourceNamespace\");\n\t\tlong classNameId = ParamUtil.getLong(actionRequest, \"classNameId\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString structureAvailableFields = ParamUtil.getString(\n\t\t\tactionRequest, \"structureAvailableFields\");\n\n\t\tLiferayPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/edit_template.jsp\");\n\t\tportletURL.setParameter(\"redirect\", redirect, false);\n\t\tportletURL.setParameter(\n\t\t\t\"portletResourceNamespace\", portletResourceNamespace, false);\n\t\tportletURL.setParameter(\n\t\t\t\"templateId\", String.valueOf(template.getTemplateId()), false);\n\t\tportletURL.setParameter(\n\t\t\t\"groupId\", String.valueOf(template.getGroupId()), false);\n\t\tportletURL.setParameter(\n\t\t\t\"classNameId\", String.valueOf(classNameId), false);\n\t\tportletURL.setParameter(\"classPK\", String.valueOf(classPK), false);\n\t\tportletURL.setParameter(\"type\", template.getType(), false);\n\t\tportletURL.setParameter(\n\t\t\t\"structureAvailableFields\", structureAvailableFields, false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"53ed6c3e81f247e6c06f0419e119e1338168d205","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMStructure structure,\n\t\t\tString redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString availableFields = ParamUtil.getString(\n\t\t\tactionRequest, \"availableFields\");\n\t\tString eventName = ParamUtil.getString(actionRequest, \"eventName\");\n\n\t\tPortletURLImpl portletURL = new PortletURLImpl(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/edit_structure.jsp\");\n\t\tportletURL.setParameter(\"redirect\", redirect, false);\n\t\tportletURL.setParameter(\n\t\t\t\"groupId\", String.valueOf(structure.getGroupId()), false);\n\n\t\tlong classNameId = PortalUtil.getClassNameId(DDMStructure.class);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classNameId\", String.valueOf(classNameId), false);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classPK\", String.valueOf(structure.getStructureId()), false);\n\t\tportletURL.setParameter(\"availableFields\", availableFields, false);\n\t\tportletURL.setParameter(\"eventName\", eventName, false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","id":462,"modified_method":"protected String getSaveAndContinueRedirect(\n\t\t\tActionRequest actionRequest, DDMStructure structure,\n\t\t\tString redirect)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString availableFields = ParamUtil.getString(\n\t\t\tactionRequest, \"availableFields\");\n\t\tString eventName = ParamUtil.getString(actionRequest, \"eventName\");\n\n\t\tLiferayPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\tactionRequest, themeDisplay.getPpid(), themeDisplay.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setParameter(\"mvcPath\", \"/edit_structure.jsp\");\n\t\tportletURL.setParameter(\"redirect\", redirect, false);\n\t\tportletURL.setParameter(\n\t\t\t\"groupId\", String.valueOf(structure.getGroupId()), false);\n\n\t\tlong classNameId = PortalUtil.getClassNameId(DDMStructure.class);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classNameId\", String.valueOf(classNameId), false);\n\n\t\tportletURL.setParameter(\n\t\t\t\"classPK\", String.valueOf(structure.getStructureId()), false);\n\t\tportletURL.setParameter(\"availableFields\", availableFields, false);\n\t\tportletURL.setParameter(\"eventName\", eventName, false);\n\t\tportletURL.setWindowState(actionRequest.getWindowState());\n\n\t\treturn portletURL.toString();\n\t}","commit_id":"53ed6c3e81f247e6c06f0419e119e1338168d205","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void buildSerializationMethods(ClassWriter cw, ClassDefinition classDef) {\n        MethodVisitor mv;\n        {\n            mv = cw.visitMethod(ACC_PUBLIC, \"writeExternal\", \"(Ljava/io/ObjectOutput;)V\", null, new String[]{\"java/io/IOException\"});\n            mv.visitCode();\n\n            for (  FieldDefinition field : classDef.getFieldsDefinitions() ) {\n\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                visitFieldOrGetter( mv, classDef, field );\n                mv.visitMethodInsn( INVOKEINTERFACE, \n                                    \"java/io/ObjectOutput\", \n                                    BuildUtils.serializationWriterName( field.getTypeName() ),\n                                    \"(\" + ( BuildUtils.isPrimitive( field.getTypeName() ) ?\n                                            BuildUtils.getTypeDescriptor( BuildUtils.serializationType( field.getTypeName() ) ) :\n                                            \"Ljava/lang/Object;\" ) + \")V\");\n                               \n            }\n\n            if ( classDef.isTraitable() ) {\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( Opcodes.GETFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.MAP_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectOutput\",\n                                    \"writeObject\",\n                                    \"(Ljava/lang/Object;)V\" );\n\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( Opcodes.GETFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.TRAITSET_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectOutput\",\n                                    \"writeObject\",\n                                    \"(Ljava/lang/Object;)V\" );\n\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( Opcodes.GETFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.FIELDTMS_FIELD_NAME,\n                                   Type.getDescriptor( TraitFieldTMS.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectOutput\",\n                                    \"writeObject\",\n                                    \"(Ljava/lang/Object;)V\" );\n            }\n\n            mv.visitInsn(RETURN);\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n        {\n            mv = cw.visitMethod(ACC_PUBLIC, \"readExternal\", \"(Ljava/io/ObjectInput;)V\", null, new String[]{\"java/io/IOException\", \"java/lang/ClassNotFoundException\"});\n            mv.visitCode();\n\n            for (  FieldDefinition field : classDef.getFieldsDefinitions() ) {\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectInput\",\n                                    BuildUtils.serializationReaderName( field.getTypeName() ),\n                                    \"()\" + ( BuildUtils.isPrimitive( field.getTypeName() ) ?\n                                             BuildUtils.getTypeDescriptor( field.getTypeName() ) :\n                                             \"Ljava/lang/Object;\" ) );\n                if  ( !  BuildUtils.isPrimitive( field.getTypeName() ) ) {\n                    mv.visitTypeInsn( CHECKCAST, BuildUtils.getInternalType( field.getTypeName() ) );\n                }\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                                    BuildUtils.getInternalType( classDef.getName() ),\n                                    BuildUtils.setterName( field.getName(), field.getTypeName() ),\n                                    \"(\" + BuildUtils.getTypeDescriptor( field.getTypeName() )+ \")V\");\n            }\n\n            if ( classDef.isTraitable() ) {\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectInput\",\n                                    \"readObject\",\n                                    \"()Ljava/lang/Object;\");\n                mv.visitTypeInsn( CHECKCAST, \"java/util/Map\" );\n                mv.visitFieldInsn( Opcodes.PUTFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.MAP_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n//\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectInput\",\n                                    \"readObject\",\n                                    \"()Ljava/lang/Object;\");\n                mv.visitTypeInsn( CHECKCAST, \"java/util/Map\" );\n                mv.visitFieldInsn( Opcodes.PUTFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.TRAITSET_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectInput\",\n                                    \"readObject\",\n                                    \"()Ljava/lang/Object;\");\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitFieldTMS.class ) );\n                mv.visitFieldInsn( Opcodes.PUTFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.FIELDTMS_FIELD_NAME,\n                                   Type.getDescriptor( TraitFieldTMS.class ) );\n            }\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n    }","id":463,"modified_method":"private void buildSerializationMethods(ClassWriter cw, ClassDefinition classDef) {\n        MethodVisitor mv;\n        {\n            mv = cw.visitMethod(ACC_PUBLIC, \"writeExternal\", \"(Ljava/io/ObjectOutput;)V\", null, new String[]{\"java/io/IOException\"});\n            mv.visitCode();\n\n            for (  FieldDefinition field : classDef.getFieldsDefinitions() ) {\n\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                visitFieldOrGetter( mv, classDef, field );\n                mv.visitMethodInsn( INVOKEINTERFACE, \n                                    \"java/io/ObjectOutput\", \n                                    BuildUtils.serializationWriterName( field.getTypeName() ),\n                                    \"(\" + ( BuildUtils.isPrimitive( field.getTypeName() ) ?\n                                            BuildUtils.getTypeDescriptor( BuildUtils.serializationType( field.getTypeName() ) ) :\n                                            \"Ljava/lang/Object;\" ) + \")V\");\n                               \n            }\n\n            if ( classDef.isTraitable() ) {\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( Opcodes.GETFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.MAP_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectOutput\",\n                                    \"writeObject\",\n                                    \"(Ljava/lang/Object;)V\" );\n\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( Opcodes.GETFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.TRAITSET_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectOutput\",\n                                    \"writeObject\",\n                                    \"(Ljava/lang/Object;)V\" );\n\n                if ( classDef.isFullTraiting() ) {\n                    mv.visitVarInsn( ALOAD, 1 );\n                    mv.visitVarInsn( ALOAD, 0 );\n                    mv.visitFieldInsn( Opcodes.GETFIELD,\n                                       BuildUtils.getInternalType( classDef.getClassName() ),\n                                       TraitableBean.FIELDTMS_FIELD_NAME,\n                                       Type.getDescriptor( TraitFieldTMS.class ) );\n                    mv.visitMethodInsn( INVOKEINTERFACE,\n                                        \"java/io/ObjectOutput\",\n                                        \"writeObject\",\n                                        \"(Ljava/lang/Object;)V\" );\n                }\n            }\n\n            mv.visitInsn(RETURN);\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n        {\n            mv = cw.visitMethod(ACC_PUBLIC, \"readExternal\", \"(Ljava/io/ObjectInput;)V\", null, new String[]{\"java/io/IOException\", \"java/lang/ClassNotFoundException\"});\n            mv.visitCode();\n\n            for (  FieldDefinition field : classDef.getFieldsDefinitions() ) {\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectInput\",\n                                    BuildUtils.serializationReaderName( field.getTypeName() ),\n                                    \"()\" + ( BuildUtils.isPrimitive( field.getTypeName() ) ?\n                                             BuildUtils.getTypeDescriptor( field.getTypeName() ) :\n                                             \"Ljava/lang/Object;\" ) );\n                if  ( !  BuildUtils.isPrimitive( field.getTypeName() ) ) {\n                    mv.visitTypeInsn( CHECKCAST, BuildUtils.getInternalType( field.getTypeName() ) );\n                }\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                                    BuildUtils.getInternalType( classDef.getName() ),\n                                    BuildUtils.setterName( field.getName(), field.getTypeName() ),\n                                    \"(\" + BuildUtils.getTypeDescriptor( field.getTypeName() )+ \")V\");\n            }\n\n            if ( classDef.isTraitable() ) {\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectInput\",\n                                    \"readObject\",\n                                    \"()Ljava/lang/Object;\");\n                mv.visitTypeInsn( CHECKCAST, \"java/util/Map\" );\n                mv.visitFieldInsn( Opcodes.PUTFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.MAP_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n//\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE,\n                                    \"java/io/ObjectInput\",\n                                    \"readObject\",\n                                    \"()Ljava/lang/Object;\");\n                mv.visitTypeInsn( CHECKCAST, \"java/util/Map\" );\n                mv.visitFieldInsn( Opcodes.PUTFIELD,\n                                   BuildUtils.getInternalType( classDef.getClassName() ),\n                                   TraitableBean.TRAITSET_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n\n                if ( classDef.isFullTraiting() ) {\n                    mv.visitVarInsn( ALOAD, 0 );\n                    mv.visitVarInsn( ALOAD, 1 );\n                    mv.visitMethodInsn( INVOKEINTERFACE,\n                                        \"java/io/ObjectInput\",\n                                        \"readObject\",\n                                        \"()Ljava/lang/Object;\");\n                    mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitFieldTMS.class ) );\n                    mv.visitFieldInsn( Opcodes.PUTFIELD,\n                                       BuildUtils.getInternalType( classDef.getClassName() ),\n                                       TraitableBean.FIELDTMS_FIELD_NAME,\n                                       Type.getDescriptor( TraitFieldTMS.class ) );\n                }\n            }\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n    }","commit_id":"b7393433dec4769cfaa49bada2d3bc71eb4bf192","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public byte[] buildClass( ClassDefinition core ) throws IOException,\n            IntrospectionException,\n            SecurityException,\n            IllegalArgumentException,\n            ClassNotFoundException,\n            NoSuchMethodException,\n            IllegalAccessException,\n            InvocationTargetException,\n            InstantiationException,\n            NoSuchFieldException {\n\n\n        Class coreKlazz = core.getDefinedClass();\n        String coreName = coreKlazz.getName();\n        String wrapperName = coreName + \"Wrapper\";\n\n        ClassWriter cw = new ClassWriter( ClassWriter.COMPUTE_MAXS );\n        FieldVisitor fv;\n        MethodVisitor mv;\n\n        cw.visit( ClassGenerator.JAVA_VERSION, ACC_PUBLIC + ACC_SUPER,\n                BuildUtils.getInternalType( wrapperName ),\n                BuildUtils.getTypeDescriptor( coreName ) +\n                        \"Lorg/drools/factmodel/traits/CoreWrapper<\" + BuildUtils.getTypeDescriptor( coreName ) + \">;\",\n                BuildUtils.getInternalType( coreName ),\n                new String[] { Type.getInternalName( CoreWrapper.class ), Type.getInternalName( Externalizable.class ) } );\n\n        {\n            AnnotationVisitor av0 = cw.visitAnnotation( Type.getDescriptor( Traitable.class ), true );\n            av0.visit( \"logical\", core.isFullTraiting() );\n        }\n\n        {\n            fv = cw.visitField( ACC_PRIVATE, \"core\", BuildUtils.getTypeDescriptor( coreName ), null, null);\n            fv.visitEnd();\n        }\n        {\n            fv = cw.visitField( ACC_PRIVATE, TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ), \"Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;\", null );\n            fv.visitEnd();\n        }\n        {\n            fv = cw.visitField( ACC_PRIVATE, TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ), \"Ljava/util/Map<Ljava/lang/String;Lorg/drools/factmodel/traits/Thing;>;\", null );\n            fv.visitEnd();\n        }\n        {\n            fv = cw.visitField( ACC_PRIVATE, TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ), null, null );\n            fv.visitEnd();\n        }\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"<init>\", \"()V\", null, null );\n            mv.visitCode();\n\n            try {\n                coreKlazz.getConstructor();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKESPECIAL, BuildUtils.getInternalType( coreName ), \"<init>\", \"()V\" );\n            } catch ( NoSuchMethodException nsme ) {\n                Constructor con = coreKlazz.getConstructors()[ 0 ];\n                Class[] params = con.getParameterTypes();\n\n                mv.visitVarInsn( ALOAD, 0 );\n                for ( Class param : params ) {\n                    mv.visitInsn( BuildUtils.zero( param.getName() ) );\n                }\n                mv.visitMethodInsn( INVOKESPECIAL,\n                                    BuildUtils.getInternalType( coreName ),\n                                    \"<init>\",\n                                    Type.getConstructorDescriptor( con ) );\n            }\n\n\n//            mv.visitVarInsn( ALOAD, 0 );\n//            mv.visitTypeInsn( NEW, Type.getInternalName( HashMap.class ) );\n//            mv.visitInsn( DUP );\n//            mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( HashMap.class ), \"<init>\", \"()V\" );\n//            mv.visitFieldInsn( PUTFIELD,\n//                    BuildUtils.getInternalType( wrapperName ),\n//                    TraitableBean.MAP_FIELD_NAME,\n//                    Type.getDescriptor( Map.class ) );\n\n//            mv.visitVarInsn( ALOAD, 0 );\n//            mv.visitTypeInsn( NEW, Type.getInternalName( VetoableTypedMap.class ) );\n//            mv.visitInsn( DUP );\n//            mv.visitTypeInsn( NEW, Type.getInternalName( HashMap.class ) );\n//            mv.visitInsn( DUP );\n//            mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( HashMap.class ), \"<init>\", \"()V\" );\n//            mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( VetoableTypedMap.class ), \"<init>\", \"(\" + Type.getDescriptor( Map.class ) + \")V\" );\n//            mv.visitFieldInsn( PUTFIELD,\n//                    BuildUtils.getInternalType( wrapperName ),\n//                    TraitableBean.TRAITSET_FIELD_NAME,\n//                    Type.getDescriptor( Map.class ) );\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getCore\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getCore\", \"()\" + Type.getDescriptor( Object.class ), \"()\"+BuildUtils.getTypeDescriptor( coreName ), null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                        BuildUtils.getInternalType( wrapperName ),\n                        \"core\",\n                        BuildUtils.getTypeDescriptor( coreName ));\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_getDynamicProperties\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"_getDynamicProperties\", \"()\" + Type.getDescriptor( Map.class ), \"()Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;\", null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                        BuildUtils.getInternalType( wrapperName ),\n                        TraitableBean.MAP_FIELD_NAME,\n                        Type.getDescriptor( Map.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n                mv = cw.visitMethod( ACC_PUBLIC,\n                        \"_setDynamicProperties\",\n                        \"(\" + Type.getDescriptor( Map.class ) + \")V\",\n                        \"(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;)V\",\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_getTraitMap\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ),\n                        \"()Ljava/util/Map<Ljava/lang/String;Lorg/drools/factmodel/traits/Thing;>;\", null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                Label l0 = new Label();\n                mv.visitJumpInsn( IFNULL, l0 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitFieldInsn( GETSTATIC, Type.getInternalName( Collections.class ), \"EMPTY_MAP\", Type.getDescriptor( Map.class ) );\n                Label l1 = new Label();\n                mv.visitJumpInsn( IF_ACMPNE, l1 );\n                mv.visitLabel( l0 );\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitTypeInsn( NEW, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitInsn( DUP );\n                mv.visitTypeInsn( NEW, Type.getInternalName( HashMap.class ) );\n                mv.visitInsn( DUP );\n                mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( HashMap.class ), \"<init>\", \"()V\" );\n                mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( TraitTypeMap.class ), \"<init>\", \"(\" + Type.getDescriptor( Map.class ) + \")V\" );\n                mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitLabel( l1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"setTraitMap\", Map.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"setTraitMap\", \"(Ljava/util/Map;)V\", null, null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitTypeInsn( NEW, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitInsn( DUP );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( TraitTypeMap.class ), \"<init>\", \"(\" + Type.getDescriptor( Map.class ) + \")V\" );\n                mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"addTrait\", String.class, Thing.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"addTrait\",\n                        \"(\" + Type.getDescriptor( String.class ) + Type.getDescriptor( Thing.class ) + \")V\",\n                        \"(\" + Type.getDescriptor( String.class ) + Type.getDescriptor( Thing.class ) + \")V\",\n                        null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 2 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"putSafe\",\n                        \"(\" + Type.getDescriptor( String.class ) + Type.getDescriptor( Thing.class ) + \")\" + Type.getDescriptor( Thing.class ) );\n                mv.visitInsn( POP );\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getTrait\", String.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getTrait\",\n                        \"(\" + Type.getDescriptor( String.class ) + \")\" + Type.getDescriptor( Thing.class ),\n                        \"(\" + Type.getDescriptor( String.class ) + \")\" + Type.getDescriptor( Thing.class ),\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn(ALOAD, 0);\n                mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(wrapperName), \"_getTraitMap\", \"()\" + Type.getDescriptor(Map.class));\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(Map.class), \"get\",\n                        \"(\" + Type.getDescriptor(Object.class) + \")\" + Type.getDescriptor(Object.class));\n                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Thing.class));\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"hasTraits\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                                     \"hasTraits\",\n                                     Type.getMethodDescriptor( Type.getType( boolean.class ), new Type[] {} ),\n                                     null,\n                                     null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(wrapperName), \"_getTraitMap\", \"()\" + Type.getDescriptor(Map.class));\n                Label l5 = new Label();\n                mv.visitJumpInsn( IFNULL, l5 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(wrapperName), \"_getTraitMap\", \"()\" + Type.getDescriptor(Map.class));\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( Map.class ), \"isEmpty\", Type.getMethodDescriptor( Type.BOOLEAN_TYPE, new Type[] {} ) );\n                mv.visitJumpInsn( IFNE, l5 );\n                mv.visitInsn( ICONST_1 );\n                Label l4 = new Label();\n                mv.visitJumpInsn( GOTO, l4 );\n                mv.visitLabel( l5 );\n                mv.visitInsn( ICONST_0 );\n                mv.visitLabel( l4 );\n                mv.visitInsn( IRETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"hasTrait\", String.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"hasTrait\", \"(\" + Type.getDescriptor( String.class )+ \")Z\", null, null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ) );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( Map.class ), \"containsKey\", \"(\" + Type.getDescriptor( Object.class ) + \")Z\" );\n                mv.visitInsn( IRETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"removeTrait\", String.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"removeTrait\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( String.class ) } ),\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( String.class ) } ),\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", Type.getMethodDescriptor( Type.getType( Map.class ), new Type[] {} ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"removeCascade\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( String.class )} ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n                mv = cw.visitMethod( ACC_PUBLIC, \"removeTrait\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( BitSet.class ) } ),\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( BitSet.class ) } ),\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", Type.getMethodDescriptor( Type.getType( Map.class ), new Type[] {} ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"removeCascade\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( BitSet.class )} ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getTraits\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getTraits\", \"()\" + Type.getDescriptor( Collection.class ), \"()Ljava/util/Collection<Ljava/lang/String;>;\", null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( Map.class ), \"keySet\", \"()\" + Type.getDescriptor( Set.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_setBottomTypeCode\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"_setBottomTypeCode\", \"(\" + Type.getDescriptor( BitSet.class )+ \")V\", null, null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME , Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"setBottomCode\", \"(\" + Type.getDescriptor( BitSet.class ) + \")V\");\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0,0 );\n                mv.visitEnd();\n            }\n        }\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getCurrentTypeCode\" ) ) {\n\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getCurrentTypeCode\", \"()\" + Type.getDescriptor( BitSet.class ), null, null );\n                mv.visitCode();\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                                   BuildUtils.getInternalType( wrapperName ),\n                                   TraitableBean.TRAITSET_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n                Label l3 = new Label();\n                mv.visitJumpInsn( IFNONNULL, l3 );\n                mv.visitInsn( ACONST_NULL );\n                mv.visitInsn( ARETURN );\n                mv.visitLabel( l3 );\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                        BuildUtils.getInternalType( wrapperName ),\n                        TraitableBean.TRAITSET_FIELD_NAME,\n                        Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST,\n                        Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                        Type.getInternalName( TraitTypeMap.class ),\n                        \"getCurrentTypeCode\",\n                        \"()\" + Type.getDescriptor( BitSet.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getMostSpecificTraits\" ) ) {\n\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                        \"getMostSpecificTraits\",\n                        \"()\" + Type.getDescriptor( Collection.class ),\n                        \"()Ljava/util/Collection<Lorg/drools/factmodel/traits/Thing;>;\",\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ),\n                        TraitableBean.TRAITSET_FIELD_NAME ,\n                        Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                        Type.getInternalName( TraitTypeMap.class ),\n                        \"getMostSpecificTraits\",\n                        \"()\" + Type.getDescriptor( Collection.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n            }\n        }\n\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_getFieldTMS\", TraitFieldTMS.class ) ) {\n            {\n                mv = cw.visitMethod( Opcodes.ACC_PUBLIC,\n                                     \"_getFieldTMS\",\n                                     Type.getMethodDescriptor( Type.getType( TraitFieldTMS.class ), new Type[] {} ),\n                                     null,\n                                     null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n            }\n        }\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_setFieldTMS\", TraitFieldTMS.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                                     \"_setFieldTMS\",\n                                     Type.getMethodDescriptor( Type.VOID_TYPE, new Type[] { Type.getType( TraitFieldTMS.class ) } ),\n                                     null,\n                                     null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitFieldInsn ( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ) );\n                mv.visitInsn( RETURN) ;\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n\n\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"writeExternal\", \"(\" + Type.getDescriptor( ObjectOutput.class ) + \")V\", null, new String[] { Type.getInternalName( IOException.class ) } );\n            mv.visitCode();\n\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"getCore\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n\n\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ) );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( Map.class ) );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"readExternal\", \"(\" + Type.getDescriptor( ObjectInput.class ) + \")V\", null,\n                    new String[] { Type.getInternalName( IOException.class ), Type.getInternalName( ClassNotFoundException.class ) } );\n            mv.visitCode();\n\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitTypeInsn( CHECKCAST, BuildUtils.getInternalType( coreName ) );\n            mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), \"core\", BuildUtils.getTypeDescriptor( coreName ) );\n\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitTypeInsn( CHECKCAST, Type.getInternalName( Map.class ) );\n            mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ) );\n\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitTypeInsn( CHECKCAST, Type.getInternalName( Map.class ) );\n            mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitFieldTMS.class ) );\n            mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ) );\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"init\", \"(\"+ BuildUtils.getTypeDescriptor( coreName ) +\")V\", null, null );\n            mv.visitCode();\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitFieldInsn( PUTFIELD,\n                    BuildUtils.getInternalType( wrapperName ),\n                    \"core\",\n                    BuildUtils.getTypeDescriptor( coreName ) );\n\n            initializeDynamicTypeStructures( mv, wrapperName, core );\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n\n        Method[] ms = coreKlazz.getMethods();\n        for ( Method method : ms ) {\n            if ( Modifier.isFinal( method.getModifiers() ) ) {\n                continue;\n            }\n\n            String signature = TraitFactory.buildSignature( method );\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                        method.getName(),\n                        signature,\n                        null,\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), \"core\", BuildUtils.getTypeDescriptor( coreName ) );\n\n                Label l0 = new Label();\n                    mv.visitJumpInsn( IFNONNULL, l0 );\n                    if ( method.getReturnType() == void.class ) {\n                        mv.visitInsn( RETURN );\n                    } else {\n                        mv.visitInsn( BuildUtils.zero( method.getReturnType().getName() ) );\n                        mv.visitInsn( BuildUtils.returnType( method.getReturnType().getName() ) );\n                    }\n                mv.visitLabel( l0 );\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), \"core\", BuildUtils.getTypeDescriptor( coreName ) );\n\n                int j = 1;\n                for ( Class arg : method.getParameterTypes() ) {\n                    mv.visitVarInsn( BuildUtils.varType( arg.getName() ), j++ );\n                }\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                        BuildUtils.getInternalType( coreName ),\n                        method.getName(),\n                        signature );\n\n                mv.visitInsn( BuildUtils.returnType( method.getReturnType().getName() ) );\n                int stack = TraitFactory.getStackSize( method );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n\n        }\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC + ACC_BRIDGE + ACC_SYNTHETIC, \"init\", \"(\" + Type.getDescriptor( Object.class ) + \")V\", null, null );\n            mv.visitCode();\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitTypeInsn( CHECKCAST, BuildUtils.getInternalType( coreName ) );\n            mv.visitMethodInsn( INVOKEVIRTUAL,\n                    BuildUtils.getInternalType( wrapperName ),\n                    \"init\",\n                    \"(\" + BuildUtils.getTypeDescriptor( coreName ) + \")V\" );\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n        cw.visitEnd();\n\n        return cw.toByteArray();\n    }","id":464,"modified_method":"public byte[] buildClass( ClassDefinition core ) throws IOException,\n            IntrospectionException,\n            SecurityException,\n            IllegalArgumentException,\n            ClassNotFoundException,\n            NoSuchMethodException,\n            IllegalAccessException,\n            InvocationTargetException,\n            InstantiationException,\n            NoSuchFieldException {\n\n\n        Class coreKlazz = core.getDefinedClass();\n        String coreName = coreKlazz.getName();\n        String wrapperName = coreName + \"Wrapper\";\n\n        ClassWriter cw = new ClassWriter( ClassWriter.COMPUTE_MAXS );\n        FieldVisitor fv;\n        MethodVisitor mv;\n\n        cw.visit( ClassGenerator.JAVA_VERSION, ACC_PUBLIC + ACC_SUPER,\n                BuildUtils.getInternalType( wrapperName ),\n                BuildUtils.getTypeDescriptor( coreName ) +\n                        \"Lorg/drools/factmodel/traits/CoreWrapper<\" + BuildUtils.getTypeDescriptor( coreName ) + \">;\",\n                BuildUtils.getInternalType( coreName ),\n                new String[] { Type.getInternalName( CoreWrapper.class ), Type.getInternalName( Externalizable.class ) } );\n\n        {\n            AnnotationVisitor av0 = cw.visitAnnotation( Type.getDescriptor( Traitable.class ), true );\n            av0.visit( \"logical\", core.isFullTraiting() );\n        }\n\n        {\n            fv = cw.visitField( ACC_PRIVATE, \"core\", BuildUtils.getTypeDescriptor( coreName ), null, null);\n            fv.visitEnd();\n        }\n        {\n            fv = cw.visitField( ACC_PRIVATE, TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ), \"Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;\", null );\n            fv.visitEnd();\n        }\n        {\n            fv = cw.visitField( ACC_PRIVATE, TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ), \"Ljava/util/Map<Ljava/lang/String;Lorg/drools/factmodel/traits/Thing;>;\", null );\n            fv.visitEnd();\n        }\n        {\n            fv = cw.visitField( ACC_PRIVATE, TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ), null, null );\n            fv.visitEnd();\n        }\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"<init>\", \"()V\", null, null );\n            mv.visitCode();\n\n            try {\n                coreKlazz.getConstructor();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKESPECIAL, BuildUtils.getInternalType( coreName ), \"<init>\", \"()V\" );\n            } catch ( NoSuchMethodException nsme ) {\n                Constructor con = coreKlazz.getConstructors()[ 0 ];\n                Class[] params = con.getParameterTypes();\n\n                mv.visitVarInsn( ALOAD, 0 );\n                for ( Class param : params ) {\n                    mv.visitInsn( BuildUtils.zero( param.getName() ) );\n                }\n                mv.visitMethodInsn( INVOKESPECIAL,\n                                    BuildUtils.getInternalType( coreName ),\n                                    \"<init>\",\n                                    Type.getConstructorDescriptor( con ) );\n            }\n\n\n//            mv.visitVarInsn( ALOAD, 0 );\n//            mv.visitTypeInsn( NEW, Type.getInternalName( HashMap.class ) );\n//            mv.visitInsn( DUP );\n//            mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( HashMap.class ), \"<init>\", \"()V\" );\n//            mv.visitFieldInsn( PUTFIELD,\n//                    BuildUtils.getInternalType( wrapperName ),\n//                    TraitableBean.MAP_FIELD_NAME,\n//                    Type.getDescriptor( Map.class ) );\n\n//            mv.visitVarInsn( ALOAD, 0 );\n//            mv.visitTypeInsn( NEW, Type.getInternalName( VetoableTypedMap.class ) );\n//            mv.visitInsn( DUP );\n//            mv.visitTypeInsn( NEW, Type.getInternalName( HashMap.class ) );\n//            mv.visitInsn( DUP );\n//            mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( HashMap.class ), \"<init>\", \"()V\" );\n//            mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( VetoableTypedMap.class ), \"<init>\", \"(\" + Type.getDescriptor( Map.class ) + \")V\" );\n//            mv.visitFieldInsn( PUTFIELD,\n//                    BuildUtils.getInternalType( wrapperName ),\n//                    TraitableBean.TRAITSET_FIELD_NAME,\n//                    Type.getDescriptor( Map.class ) );\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getCore\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getCore\", \"()\" + Type.getDescriptor( Object.class ), \"()\"+BuildUtils.getTypeDescriptor( coreName ), null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                        BuildUtils.getInternalType( wrapperName ),\n                        \"core\",\n                        BuildUtils.getTypeDescriptor( coreName ));\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_getDynamicProperties\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"_getDynamicProperties\", \"()\" + Type.getDescriptor( Map.class ), \"()Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;\", null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                        BuildUtils.getInternalType( wrapperName ),\n                        TraitableBean.MAP_FIELD_NAME,\n                        Type.getDescriptor( Map.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n                mv = cw.visitMethod( ACC_PUBLIC,\n                        \"_setDynamicProperties\",\n                        \"(\" + Type.getDescriptor( Map.class ) + \")V\",\n                        \"(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;)V\",\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_getTraitMap\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ),\n                        \"()Ljava/util/Map<Ljava/lang/String;Lorg/drools/factmodel/traits/Thing;>;\", null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                Label l0 = new Label();\n                mv.visitJumpInsn( IFNULL, l0 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitFieldInsn( GETSTATIC, Type.getInternalName( Collections.class ), \"EMPTY_MAP\", Type.getDescriptor( Map.class ) );\n                Label l1 = new Label();\n                mv.visitJumpInsn( IF_ACMPNE, l1 );\n                mv.visitLabel( l0 );\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitTypeInsn( NEW, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitInsn( DUP );\n                mv.visitTypeInsn( NEW, Type.getInternalName( HashMap.class ) );\n                mv.visitInsn( DUP );\n                mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( HashMap.class ), \"<init>\", \"()V\" );\n                mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( TraitTypeMap.class ), \"<init>\", \"(\" + Type.getDescriptor( Map.class ) + \")V\" );\n                mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitLabel( l1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"setTraitMap\", Map.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"setTraitMap\", \"(Ljava/util/Map;)V\", null, null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitTypeInsn( NEW, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitInsn( DUP );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKESPECIAL, Type.getInternalName( TraitTypeMap.class ), \"<init>\", \"(\" + Type.getDescriptor( Map.class ) + \")V\" );\n                mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"addTrait\", String.class, Thing.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"addTrait\",\n                        \"(\" + Type.getDescriptor( String.class ) + Type.getDescriptor( Thing.class ) + \")V\",\n                        \"(\" + Type.getDescriptor( String.class ) + Type.getDescriptor( Thing.class ) + \")V\",\n                        null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 2 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"putSafe\",\n                        \"(\" + Type.getDescriptor( String.class ) + Type.getDescriptor( Thing.class ) + \")\" + Type.getDescriptor( Thing.class ) );\n                mv.visitInsn( POP );\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getTrait\", String.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getTrait\",\n                        \"(\" + Type.getDescriptor( String.class ) + \")\" + Type.getDescriptor( Thing.class ),\n                        \"(\" + Type.getDescriptor( String.class ) + \")\" + Type.getDescriptor( Thing.class ),\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn(ALOAD, 0);\n                mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(wrapperName), \"_getTraitMap\", \"()\" + Type.getDescriptor(Map.class));\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(Map.class), \"get\",\n                        \"(\" + Type.getDescriptor(Object.class) + \")\" + Type.getDescriptor(Object.class));\n                mv.visitTypeInsn(CHECKCAST, Type.getInternalName(Thing.class));\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"hasTraits\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                                     \"hasTraits\",\n                                     Type.getMethodDescriptor( Type.getType( boolean.class ), new Type[] {} ),\n                                     null,\n                                     null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(wrapperName), \"_getTraitMap\", \"()\" + Type.getDescriptor(Map.class));\n                Label l5 = new Label();\n                mv.visitJumpInsn( IFNULL, l5 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn(INVOKEVIRTUAL, BuildUtils.getInternalType(wrapperName), \"_getTraitMap\", \"()\" + Type.getDescriptor(Map.class));\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( Map.class ), \"isEmpty\", Type.getMethodDescriptor( Type.BOOLEAN_TYPE, new Type[] {} ) );\n                mv.visitJumpInsn( IFNE, l5 );\n                mv.visitInsn( ICONST_1 );\n                Label l4 = new Label();\n                mv.visitJumpInsn( GOTO, l4 );\n                mv.visitLabel( l5 );\n                mv.visitInsn( ICONST_0 );\n                mv.visitLabel( l4 );\n                mv.visitInsn( IRETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"hasTrait\", String.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"hasTrait\", \"(\" + Type.getDescriptor( String.class )+ \")Z\", null, null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ) );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( Map.class ), \"containsKey\", \"(\" + Type.getDescriptor( Object.class ) + \")Z\" );\n                mv.visitInsn( IRETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"removeTrait\", String.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"removeTrait\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( String.class ) } ),\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( String.class ) } ),\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", Type.getMethodDescriptor( Type.getType( Map.class ), new Type[] {} ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"removeCascade\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( String.class )} ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n                mv = cw.visitMethod( ACC_PUBLIC, \"removeTrait\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( BitSet.class ) } ),\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( BitSet.class ) } ),\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", Type.getMethodDescriptor( Type.getType( Map.class ), new Type[] {} ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn(ALOAD, 1);\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"removeCascade\",\n                        Type.getMethodDescriptor( Type.getType( Collection.class ), new Type[] { Type.getType( BitSet.class )} ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getTraits\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getTraits\", \"()\" + Type.getDescriptor( Collection.class ), \"()Ljava/util/Collection<Ljava/lang/String;>;\", null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"_getTraitMap\", \"()\" + Type.getDescriptor( Map.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( Map.class ), \"keySet\", \"()\" + Type.getDescriptor( Set.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_setBottomTypeCode\" ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"_setBottomTypeCode\", \"(\" + Type.getDescriptor( BitSet.class )+ \")V\", null, null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME , Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEVIRTUAL, Type.getInternalName( TraitTypeMap.class ), \"setBottomCode\", \"(\" + Type.getDescriptor( BitSet.class ) + \")V\");\n                mv.visitInsn( RETURN );\n                mv.visitMaxs( 0,0 );\n                mv.visitEnd();\n            }\n        }\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getCurrentTypeCode\" ) ) {\n\n            {\n                mv = cw.visitMethod( ACC_PUBLIC, \"getCurrentTypeCode\", \"()\" + Type.getDescriptor( BitSet.class ), null, null );\n                mv.visitCode();\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                                   BuildUtils.getInternalType( wrapperName ),\n                                   TraitableBean.TRAITSET_FIELD_NAME,\n                                   Type.getDescriptor( Map.class ) );\n                Label l3 = new Label();\n                mv.visitJumpInsn( IFNONNULL, l3 );\n                mv.visitInsn( ACONST_NULL );\n                mv.visitInsn( ARETURN );\n                mv.visitLabel( l3 );\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD,\n                        BuildUtils.getInternalType( wrapperName ),\n                        TraitableBean.TRAITSET_FIELD_NAME,\n                        Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST,\n                        Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                        Type.getInternalName( TraitTypeMap.class ),\n                        \"getCurrentTypeCode\",\n                        \"()\" + Type.getDescriptor( BitSet.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"getMostSpecificTraits\" ) ) {\n\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                        \"getMostSpecificTraits\",\n                        \"()\" + Type.getDescriptor( Collection.class ),\n                        \"()Ljava/util/Collection<Lorg/drools/factmodel/traits/Thing;>;\",\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ),\n                        TraitableBean.TRAITSET_FIELD_NAME ,\n                        Type.getDescriptor( Map.class ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitTypeMap.class ) );\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                        Type.getInternalName( TraitTypeMap.class ),\n                        \"getMostSpecificTraits\",\n                        \"()\" + Type.getDescriptor( Collection.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n            }\n        }\n\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_getFieldTMS\", TraitFieldTMS.class ) ) {\n            {\n                mv = cw.visitMethod( Opcodes.ACC_PUBLIC,\n                                     \"_getFieldTMS\",\n                                     Type.getMethodDescriptor( Type.getType( TraitFieldTMS.class ), new Type[] {} ),\n                                     null,\n                                     null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ) );\n                mv.visitInsn( ARETURN );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n\n            }\n        }\n\n        if ( coreKlazz == null || needsMethod( coreKlazz, \"_setFieldTMS\", TraitFieldTMS.class ) ) {\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                                     \"_setFieldTMS\",\n                                     Type.getMethodDescriptor( Type.VOID_TYPE, new Type[] { Type.getType( TraitFieldTMS.class ) } ),\n                                     null,\n                                     null);\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitFieldInsn ( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ) );\n                mv.visitInsn( RETURN) ;\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n        }\n\n\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"writeExternal\", \"(\" + Type.getDescriptor( ObjectOutput.class ) + \")V\", null, new String[] { Type.getInternalName( IOException.class ) } );\n            mv.visitCode();\n\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitMethodInsn( INVOKEVIRTUAL, BuildUtils.getInternalType( wrapperName ), \"getCore\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n\n\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ) );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n\n            if ( core.isFullTraiting() ) {\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( Map.class ) );\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectOutput.class ), \"writeObject\", \"(\" + Type.getDescriptor( Object.class ) + \")V\" );\n            }\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"readExternal\", \"(\" + Type.getDescriptor( ObjectInput.class ) + \")V\", null,\n                    new String[] { Type.getInternalName( IOException.class ), Type.getInternalName( ClassNotFoundException.class ) } );\n            mv.visitCode();\n\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitTypeInsn( CHECKCAST, BuildUtils.getInternalType( coreName ) );\n            mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), \"core\", BuildUtils.getTypeDescriptor( coreName ) );\n\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitTypeInsn( CHECKCAST, Type.getInternalName( Map.class ) );\n            mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.MAP_FIELD_NAME, Type.getDescriptor( Map.class ) );\n\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n            mv.visitTypeInsn( CHECKCAST, Type.getInternalName( Map.class ) );\n            mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.TRAITSET_FIELD_NAME, Type.getDescriptor( Map.class ) );\n\n            if ( core.isFullTraiting() ) {\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitVarInsn( ALOAD, 1 );\n                mv.visitMethodInsn( INVOKEINTERFACE, Type.getInternalName( ObjectInput.class ), \"readObject\", \"()\" + Type.getDescriptor( Object.class ) );\n                mv.visitTypeInsn( CHECKCAST, Type.getInternalName( TraitFieldTMS.class ) );\n                mv.visitFieldInsn( PUTFIELD, BuildUtils.getInternalType( wrapperName ), TraitableBean.FIELDTMS_FIELD_NAME, Type.getDescriptor( TraitFieldTMS.class ) );\n            }\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC, \"init\", \"(\"+ BuildUtils.getTypeDescriptor( coreName ) +\")V\", null, null );\n            mv.visitCode();\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitFieldInsn( PUTFIELD,\n                    BuildUtils.getInternalType( wrapperName ),\n                    \"core\",\n                    BuildUtils.getTypeDescriptor( coreName ) );\n\n            initializeDynamicTypeStructures( mv, wrapperName, core );\n\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n\n        Method[] ms = coreKlazz.getMethods();\n        for ( Method method : ms ) {\n            if ( Modifier.isFinal( method.getModifiers() ) ) {\n                continue;\n            }\n\n            String signature = TraitFactory.buildSignature( method );\n            {\n                mv = cw.visitMethod( ACC_PUBLIC,\n                        method.getName(),\n                        signature,\n                        null,\n                        null );\n                mv.visitCode();\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), \"core\", BuildUtils.getTypeDescriptor( coreName ) );\n\n                Label l0 = new Label();\n                    mv.visitJumpInsn( IFNONNULL, l0 );\n                    if ( method.getReturnType() == void.class ) {\n                        mv.visitInsn( RETURN );\n                    } else {\n                        mv.visitInsn( BuildUtils.zero( method.getReturnType().getName() ) );\n                        mv.visitInsn( BuildUtils.returnType( method.getReturnType().getName() ) );\n                    }\n                mv.visitLabel( l0 );\n\n                mv.visitVarInsn( ALOAD, 0 );\n                mv.visitFieldInsn( GETFIELD, BuildUtils.getInternalType( wrapperName ), \"core\", BuildUtils.getTypeDescriptor( coreName ) );\n\n                int j = 1;\n                for ( Class arg : method.getParameterTypes() ) {\n                    mv.visitVarInsn( BuildUtils.varType( arg.getName() ), j++ );\n                }\n                mv.visitMethodInsn( INVOKEVIRTUAL,\n                        BuildUtils.getInternalType( coreName ),\n                        method.getName(),\n                        signature );\n\n                mv.visitInsn( BuildUtils.returnType( method.getReturnType().getName() ) );\n                int stack = TraitFactory.getStackSize( method );\n                mv.visitMaxs( 0, 0 );\n                mv.visitEnd();\n            }\n\n        }\n\n        {\n            mv = cw.visitMethod( ACC_PUBLIC + ACC_BRIDGE + ACC_SYNTHETIC, \"init\", \"(\" + Type.getDescriptor( Object.class ) + \")V\", null, null );\n            mv.visitCode();\n            mv.visitVarInsn( ALOAD, 0 );\n            mv.visitVarInsn( ALOAD, 1 );\n            mv.visitTypeInsn( CHECKCAST, BuildUtils.getInternalType( coreName ) );\n            mv.visitMethodInsn( INVOKEVIRTUAL,\n                    BuildUtils.getInternalType( wrapperName ),\n                    \"init\",\n                    \"(\" + BuildUtils.getTypeDescriptor( coreName ) + \")V\" );\n            mv.visitInsn( RETURN );\n            mv.visitMaxs( 0, 0 );\n            mv.visitEnd();\n        }\n\n        cw.visitEnd();\n\n        return cw.toByteArray();\n    }","commit_id":"b7393433dec4769cfaa49bada2d3bc71eb4bf192","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Override\n    public ResponseProcessor buildNextPdu(PduBuilder pduBuilder) {\n        if (pduBuilder.getMaxVarsPerPdu() < 1) {\n            throw new IllegalArgumentException(\"maxVarsPerPdu < 1\");\n        }\n\n        pduBuilder.addOid(m_lastOid[m_nextColumnIndex]);\n        pduBuilder.setNonRepeaters(0);\n        pduBuilder.setMaxRepetitions(getMaxRepetitions());\n        \n        ResponseProcessor rp = new TableResponseProcessor(m_nextColumnIndex);\n        System.err.println(\"got response processor\");\n\n        m_nextColumnIndex++;\n        return rp;\n    }","id":465,"modified_method":"@Override\n    public ResponseProcessor buildNextPdu(PduBuilder pduBuilder) {\n        if (pduBuilder.getMaxVarsPerPdu() < 1) {\n            throw new IllegalArgumentException(\"maxVarsPerPdu < 1\");\n        }\n\n        for (int i = 0; i < pduBuilder.getMaxVarsPerPdu(); i++) {\n            pduBuilder.addOid(m_lastOid[m_nextColumnIndex + i]);\n        }\n        pduBuilder.setNonRepeaters(0);\n        pduBuilder.setMaxRepetitions(getMaxRepetitions());\n        \n        ResponseProcessor rp = new TableResponseProcessor(m_nextColumnIndex, pduBuilder.getMaxVarsPerPdu());\n        System.err.println(\"got response processor\");\n\n        m_nextColumnIndex++;\n        return rp;\n    }","commit_id":"7d3c75092c46e104d01e6d55989757320268d22b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public ResponseProcessor buildNextPdu(PduBuilder pduBuilder) {\n        if (pduBuilder.getMaxVarsPerPdu() < 1) {\n            throw new IllegalArgumentException(\"maxVarsPerPdu < 1\");\n        }\n\n        pduBuilder.addOid(m_lastOid[m_nextColumnIndex]);\n        pduBuilder.setNonRepeaters(0);\n        pduBuilder.setMaxRepetitions(getMaxRepetitions());\n        \n        ResponseProcessor rp = new TableResponseProcessor(m_nextColumnIndex);\n        System.err.println(\"got response processor\");\n\n        m_nextColumnIndex++;\n        return rp;\n    }","id":466,"modified_method":"@Override\n    public ResponseProcessor buildNextPdu(PduBuilder pduBuilder) {\n        if (pduBuilder.getMaxVarsPerPdu() < 1) {\n            throw new IllegalArgumentException(\"maxVarsPerPdu < 1\");\n        }\n\n        for (int i = 0; i < pduBuilder.getMaxVarsPerPdu(); i++) {\n            pduBuilder.addOid(m_lastOid[m_nextColumnIndex + i]);\n        }\n        pduBuilder.setNonRepeaters(0);\n        pduBuilder.setMaxRepetitions(getMaxRepetitions());\n        \n        ResponseProcessor rp = new TableResponseProcessor(m_nextColumnIndex, pduBuilder.getMaxVarsPerPdu());\n        System.err.println(\"got response processor\");\n\n        m_nextColumnIndex++;\n        return rp;\n    }","commit_id":"3e74031c0744864c4b5994b6e97ac885f0335ee4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public ResponseProcessor buildNextPdu(PduBuilder pduBuilder) {\n        if (pduBuilder.getMaxVarsPerPdu() < 1) {\n            throw new IllegalArgumentException(\"maxVarsPerPdu < 1\");\n        }\n\n        pduBuilder.addOid(m_lastOid[m_nextColumnIndex]);\n        pduBuilder.setNonRepeaters(0);\n        pduBuilder.setMaxRepetitions(getMaxRepetitions());\n        \n        ResponseProcessor rp = new TableResponseProcessor(m_nextColumnIndex);\n        System.err.println(\"got response processor\");\n\n        m_nextColumnIndex++;\n        return rp;\n    }","id":467,"modified_method":"@Override\n    public ResponseProcessor buildNextPdu(PduBuilder pduBuilder) {\n        if (pduBuilder.getMaxVarsPerPdu() < 1) {\n            throw new IllegalArgumentException(\"maxVarsPerPdu < 1\");\n        }\n\n        for (int i = 0; i < pduBuilder.getMaxVarsPerPdu(); i++) {\n            pduBuilder.addOid(m_lastOid[m_nextColumnIndex + i]);\n        }\n        pduBuilder.setNonRepeaters(0);\n        pduBuilder.setMaxRepetitions(getMaxRepetitions());\n        \n        ResponseProcessor rp = new TableResponseProcessor(m_nextColumnIndex, pduBuilder.getMaxVarsPerPdu());\n        System.err.println(\"got response processor\");\n\n        m_nextColumnIndex++;\n        return rp;\n    }","commit_id":"221a84c52f169dd8727312c0db0d3eb198f72788","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * {@inheritDoc}\n     */    \n    @Override\n    public Collection getRemovedKeys() {\n        return CollectionUtils.subtract(set, getPreSelected());\n    }","id":468,"modified_method":"/** {@inheritDoc} */\n    public Collection getRemovedKeys() {\n        Set preSelected = getPreSelected();\n        Collection result = CollectionUtils.subtract(set, preSelected);\n        return result;\n    }","commit_id":"83c67218217b5653fc60684678dc030636203016","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Collection getAddedKeys() {\n        return CollectionUtils.subtract(getPreSelected(), set);\n    }","id":469,"modified_method":"/** {@inheritDoc} */\n    public Collection getAddedKeys() {\n        Set preSelected = getPreSelected();\n        Collection result = CollectionUtils.subtract(preSelected, set);\n        return result;\n    }","commit_id":"83c67218217b5653fc60684678dc030636203016","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Collection getAddedKeys() {\n        return CollectionUtils.subtract(getPreSelected(), set.getElementValues());\n    }","id":470,"modified_method":"/** {@inheritDoc} */\n    public Collection getAddedKeys() {\n        Set preSelectedValues = getPreSelected();\n        Set setValues = set.getElementValues();\n        Collection result = CollectionUtils.subtract(preSelectedValues, setValues);\n        return result;\n    }","commit_id":"3466909ff9eca28ef7425fea5eef6498e543606c","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Collection getRemovedKeys() {\n        return CollectionUtils.subtract(set.getElementValues(), getPreSelected());\n    }","id":471,"modified_method":"/** {@inheritDoc} */\n    public Collection getRemovedKeys() {\n        Set setValues = set.getElementValues();\n        Set preSelectedValues = getPreSelected();\n        Collection result = CollectionUtils.subtract(setValues, preSelectedValues);\n        return result;\n    }","commit_id":"3466909ff9eca28ef7425fea5eef6498e543606c","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"protected void updateCaptcha(\n\t\t\tActionRequest actionRequest, PortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tboolean reCaptchaEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"reCaptchaEnabled\");\n\t\tString reCaptchaPrivateKey = ParamUtil.getString(\n\t\t\tactionRequest, \"reCaptchaPrivateKey\");\n\t\tString reCaptchaPublicKey = ParamUtil.getString(\n\t\t\tactionRequest, \"reCaptchaPublicKey\");\n\n\t\tCaptcha captcha = null;\n\n\t\tif (reCaptchaEnabled) {\n\t\t\tcaptcha = new ReCaptchaImpl();\n\t\t}\n\t\telse {\n\t\t\tcaptcha = new SimpleCaptchaImpl();\n\t\t}\n\n\t\tvalidateCaptcha(actionRequest);\n\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_IMPL, captcha.getClass().getName());\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_RECAPTCHA_KEY_PRIVATE,\n\t\t\t\treCaptchaPrivateKey);\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_RECAPTCHA_KEY_PUBLIC,\n\t\t\t\treCaptchaPublicKey);\n\n\t\t\tportletPreferences.store();\n\n\t\t\tCaptchaImpl captchaImpl = (CaptchaImpl)CaptchaUtil.getCaptcha();\n\n\t\t\tcaptchaImpl.setCaptcha(captcha);\n\t\t}\n\t}","id":472,"modified_method":"protected void updateCaptcha(\n\t\t\tActionRequest actionRequest, PortletPreferences portletPreferences)\n\t\tthrows Exception {\n\n\t\tboolean reCaptchaEnabled = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"reCaptchaEnabled\");\n\t\tString reCaptchaPrivateKey = ParamUtil.getString(\n\t\t\tactionRequest, \"reCaptchaPrivateKey\");\n\t\tString reCaptchaPublicKey = ParamUtil.getString(\n\t\t\tactionRequest, \"reCaptchaPublicKey\");\n\n\t\tCaptcha captcha = null;\n\n\t\tif (reCaptchaEnabled) {\n\t\t\tcaptcha = new ReCaptchaImpl();\n\t\t}\n\t\telse {\n\t\t\tcaptcha = new SimpleCaptchaImpl();\n\t\t}\n\n\t\tvalidateCaptcha(actionRequest);\n\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_IMPL, captcha.getClass().getName());\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_RECAPTCHA_KEY_PRIVATE,\n\t\t\t\treCaptchaPrivateKey);\n\t\t\tportletPreferences.setValue(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_RECAPTCHA_KEY_PUBLIC,\n\t\t\t\treCaptchaPublicKey);\n\n\t\t\tportletPreferences.store();\n\n\t\t\tCaptcha currentCaptcha = CaptchaUtil.getCaptcha();\n\n\t\t\tCaptchaImpl captchaImpl;\n\n\t\t\tif (currentCaptcha instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)currentCaptcha;\n\n\t\t\t\tcaptchaImpl = (CaptchaImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcaptchaImpl = (CaptchaImpl)currentCaptcha;\n\t\t\t}\n\n\t\t\tcaptchaImpl.setCaptcha(captcha);\n\t\t}\n\t}","commit_id":"350e0557824e0b404764da481214ec30211adb21","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void destroyPortalProperties(\n\t\t\tString servletContextName, Properties portalProperties)\n\t\tthrows Exception {\n\n\t\tPropsUtil.removeProperties(portalProperties);\n\n\t\tif (_log.isDebugEnabled() && portalProperties.containsKey(LOCALES)) {\n\t\t\t_log.debug(\n\t\t\t\t\"Portlet locales \" + portalProperties.getProperty(LOCALES));\n\t\t\t_log.debug(\"Original locales \" + PropsUtil.get(LOCALES));\n\t\t\t_log.debug(\n\t\t\t\t\"Original locales array length \" +\n\t\t\t\t\tPropsUtil.getArray(LOCALES).length);\n\t\t}\n\n\t\tresetPortalProperties(servletContextName, portalProperties, false);\n\n\t\tif (portalProperties.containsKey(PropsKeys.AUTH_TOKEN_IMPL)) {\n\t\t\tAuthTokenWrapper authTokenWrapper =\n\t\t\t\t(AuthTokenWrapper)AuthTokenUtil.getAuthToken();\n\n\t\t\tauthTokenWrapper.setAuthToken(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.CAPTCHA_ENGINE_IMPL)) {\n\t\t\tCaptchaImpl captchaImpl = (CaptchaImpl)CaptchaUtil.getCaptcha();\n\n\t\t\tcaptchaImpl.setCaptcha(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.CONTROL_PANEL_DEFAULT_ENTRY_CLASS)) {\n\n\t\t\tDefaultControlPanelEntryFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_FILE_ENTRY_PROCESSORS)) {\n\t\t\tDLFileEntryProcessorContainer dlFileEntryProcessorContainer =\n\t\t\t\t_dlFileEntryProcessorContainerMap.remove(servletContextName);\n\n\t\t\tdlFileEntryProcessorContainer.unregisterDLProcessors();\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_REPOSITORY_IMPL)) {\n\t\t\tDLRepositoryContainer dlRepositoryContainer =\n\t\t\t\t_dlRepositoryContainerMap.remove(servletContextName);\n\n\t\t\tdlRepositoryContainer.unregisterRepositoryFactories();\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_ANTIVIRUS_IMPL)) {\n\t\t\tAntivirusScannerWrapper antivirusScannerWrapper =\n\t\t\t\t(AntivirusScannerWrapper)\n\t\t\t\t\tAntivirusScannerUtil.getAntivirusScanner();\n\n\t\t\tantivirusScannerWrapper.setAntivirusScanner(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_IMPL)) {\n\t\t\tStoreFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.LDAP_ATTRS_TRANSFORMER_IMPL)) {\n\n\t\t\tAttributesTransformerFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(LOCK_LISTENERS)) {\n\t\t\tLockListenerContainer lockListenerContainer =\n\t\t\t\t_lockListenerContainerMap.remove(servletContextName);\n\n\t\t\tif (lockListenerContainer != null) {\n\t\t\t\tlockListenerContainer.unregisterLockListeners();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MAIL_HOOK_IMPL)) {\n\t\t\tcom.liferay.mail.util.HookFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ORGANIZATIONS)) {\n\n\t\t\tOrganizationMembershipPolicyFactoryImpl\n\t\t\t\torganizationMembershipPolicyFactoryImpl =\n\t\t\t\t\t(OrganizationMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tOrganizationMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetOrganizationMembershipPolicyFactory();\n\n\t\t\torganizationMembershipPolicyFactoryImpl.\n\t\t\t\tsetOrganizationMembershipPolicy(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_ROLES)) {\n\t\t\tRoleMembershipPolicyFactoryImpl roleMembershipPolicyFactoryImpl =\n\t\t\t\t(RoleMembershipPolicyFactoryImpl)\n\t\t\t\t\tRoleMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetRoleMembershipPolicyFactory();\n\n\t\t\troleMembershipPolicyFactoryImpl.setRoleMembershipPolicy(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_SITES)) {\n\t\t\tSiteMembershipPolicyFactoryImpl siteMembershipPolicyFactoryImpl =\n\t\t\t\t(SiteMembershipPolicyFactoryImpl)\n\t\t\t\t\tSiteMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetSiteMembershipPolicyFactory();\n\n\t\t\tsiteMembershipPolicyFactoryImpl.setSiteMembershipPolicy(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_USER_GROUPS)) {\n\n\t\t\tUserGroupMembershipPolicyFactoryImpl\n\t\t\t\tuserGroupMembershipPolicyFactoryImpl =\n\t\t\t\t\t(UserGroupMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tUserGroupMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetUserGroupMembershipPolicyFactory();\n\n\t\t\tuserGroupMembershipPolicyFactoryImpl.setUserGroupMembershipPolicy(\n\t\t\t\tnull);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PASSWORDS_TOOLKIT)) {\n\t\t\tToolkitWrapper toolkitWrapper =\n\t\t\t\t(ToolkitWrapper)PwdToolkitUtil.getToolkit();\n\n\t\t\ttoolkitWrapper.setToolkit(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PHONE_NUMBER_FORMAT_IMPL)) {\n\t\t\tPhoneNumberFormatWrapper phoneNumberFormatWrapper =\n\t\t\t\t(PhoneNumberFormatWrapper)\n\t\t\t\t\tPhoneNumberFormatUtil.getPhoneNumberFormat();\n\n\t\t\tphoneNumberFormatWrapper.setPhoneNumberFormat(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.SANITIZER_IMPL)) {\n\t\t\tSanitizerContainer sanitizerContainer =\n\t\t\t\t_sanitizerContainerMap.remove(servletContextName);\n\n\t\t\tif (sanitizerContainer != null) {\n\t\t\t\tsanitizerContainer.unregisterSanitizers();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_GENERATOR)) {\n\n\t\t\tEmailAddressGeneratorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_VALIDATOR)) {\n\n\t\t\tEmailAddressValidatorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_GENERATOR)) {\n\t\t\tFullNameGeneratorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_VALIDATOR)) {\n\t\t\tFullNameValidatorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_GENERATOR)) {\n\n\t\t\tScreenNameGeneratorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_VALIDATOR)) {\n\n\t\t\tScreenNameValidatorFactory.setInstance(null);\n\t\t}\n\n\t\tSet<String> liferayFilterClassNames =\n\t\t\tLiferayFilterTracker.getClassNames();\n\n\t\tfor (String liferayFilterClassName : liferayFilterClassNames) {\n\t\t\tif (!portalProperties.containsKey(liferayFilterClassName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean filterEnabled = GetterUtil.getBoolean(\n\t\t\t\tPropsUtil.get(liferayFilterClassName));\n\n\t\t\tSet<LiferayFilter> liferayFilters =\n\t\t\t\tLiferayFilterTracker.getLiferayFilters(liferayFilterClassName);\n\n\t\t\tfor (LiferayFilter liferayFilter : liferayFilters) {\n\t\t\t\tliferayFilter.setFilterEnabled(filterEnabled);\n\t\t\t}\n\t\t}\n\t}","id":473,"modified_method":"protected void destroyPortalProperties(\n\t\t\tString servletContextName, Properties portalProperties)\n\t\tthrows Exception {\n\n\t\tPropsUtil.removeProperties(portalProperties);\n\n\t\tif (_log.isDebugEnabled() && portalProperties.containsKey(LOCALES)) {\n\t\t\t_log.debug(\n\t\t\t\t\"Portlet locales \" + portalProperties.getProperty(LOCALES));\n\t\t\t_log.debug(\"Original locales \" + PropsUtil.get(LOCALES));\n\t\t\t_log.debug(\n\t\t\t\t\"Original locales array length \" +\n\t\t\t\t\tPropsUtil.getArray(LOCALES).length);\n\t\t}\n\n\t\tresetPortalProperties(servletContextName, portalProperties, false);\n\n\t\tif (portalProperties.containsKey(PropsKeys.AUTH_TOKEN_IMPL)) {\n\t\t\tAuthTokenWrapper authTokenWrapper =\n\t\t\t\t(AuthTokenWrapper)AuthTokenUtil.getAuthToken();\n\n\t\t\tauthTokenWrapper.setAuthToken(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.CAPTCHA_ENGINE_IMPL)) {\n\t\t\tCaptcha captcha = CaptchaUtil.getCaptcha();\n\n\t\t\tCaptchaImpl captchaImpl;\n\n\t\t\tif (captcha instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean = (DoPrivilegedBean)captcha;\n\n\t\t\t\tcaptchaImpl = (CaptchaImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcaptchaImpl = (CaptchaImpl)captcha;\n\t\t\t}\n\n\t\t\tcaptchaImpl.setCaptcha(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.CONTROL_PANEL_DEFAULT_ENTRY_CLASS)) {\n\n\t\t\tDefaultControlPanelEntryFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_FILE_ENTRY_PROCESSORS)) {\n\t\t\tDLFileEntryProcessorContainer dlFileEntryProcessorContainer =\n\t\t\t\t_dlFileEntryProcessorContainerMap.remove(servletContextName);\n\n\t\t\tdlFileEntryProcessorContainer.unregisterDLProcessors();\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_REPOSITORY_IMPL)) {\n\t\t\tDLRepositoryContainer dlRepositoryContainer =\n\t\t\t\t_dlRepositoryContainerMap.remove(servletContextName);\n\n\t\t\tdlRepositoryContainer.unregisterRepositoryFactories();\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_ANTIVIRUS_IMPL)) {\n\t\t\tAntivirusScannerWrapper antivirusScannerWrapper =\n\t\t\t\t(AntivirusScannerWrapper)\n\t\t\t\t\tAntivirusScannerUtil.getAntivirusScanner();\n\n\t\t\tantivirusScannerWrapper.setAntivirusScanner(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_IMPL)) {\n\t\t\tStoreFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.LDAP_ATTRS_TRANSFORMER_IMPL)) {\n\n\t\t\tAttributesTransformerFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(LOCK_LISTENERS)) {\n\t\t\tLockListenerContainer lockListenerContainer =\n\t\t\t\t_lockListenerContainerMap.remove(servletContextName);\n\n\t\t\tif (lockListenerContainer != null) {\n\t\t\t\tlockListenerContainer.unregisterLockListeners();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MAIL_HOOK_IMPL)) {\n\t\t\tcom.liferay.mail.util.HookFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ORGANIZATIONS)) {\n\n\t\t\tOrganizationMembershipPolicyFactoryImpl\n\t\t\t\torganizationMembershipPolicyFactoryImpl =\n\t\t\t\t\t(OrganizationMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tOrganizationMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetOrganizationMembershipPolicyFactory();\n\n\t\t\torganizationMembershipPolicyFactoryImpl.\n\t\t\t\tsetOrganizationMembershipPolicy(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_ROLES)) {\n\t\t\tRoleMembershipPolicyFactoryImpl roleMembershipPolicyFactoryImpl =\n\t\t\t\t(RoleMembershipPolicyFactoryImpl)\n\t\t\t\t\tRoleMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetRoleMembershipPolicyFactory();\n\n\t\t\troleMembershipPolicyFactoryImpl.setRoleMembershipPolicy(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_SITES)) {\n\t\t\tSiteMembershipPolicyFactoryImpl siteMembershipPolicyFactoryImpl =\n\t\t\t\t(SiteMembershipPolicyFactoryImpl)\n\t\t\t\t\tSiteMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetSiteMembershipPolicyFactory();\n\n\t\t\tsiteMembershipPolicyFactoryImpl.setSiteMembershipPolicy(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_USER_GROUPS)) {\n\n\t\t\tUserGroupMembershipPolicyFactoryImpl\n\t\t\t\tuserGroupMembershipPolicyFactoryImpl =\n\t\t\t\t\t(UserGroupMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tUserGroupMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetUserGroupMembershipPolicyFactory();\n\n\t\t\tuserGroupMembershipPolicyFactoryImpl.setUserGroupMembershipPolicy(\n\t\t\t\tnull);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PASSWORDS_TOOLKIT)) {\n\t\t\tToolkitWrapper toolkitWrapper =\n\t\t\t\t(ToolkitWrapper)PwdToolkitUtil.getToolkit();\n\n\t\t\ttoolkitWrapper.setToolkit(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PHONE_NUMBER_FORMAT_IMPL)) {\n\t\t\tPhoneNumberFormatWrapper phoneNumberFormatWrapper =\n\t\t\t\t(PhoneNumberFormatWrapper)\n\t\t\t\t\tPhoneNumberFormatUtil.getPhoneNumberFormat();\n\n\t\t\tphoneNumberFormatWrapper.setPhoneNumberFormat(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.SANITIZER_IMPL)) {\n\t\t\tSanitizerContainer sanitizerContainer =\n\t\t\t\t_sanitizerContainerMap.remove(servletContextName);\n\n\t\t\tif (sanitizerContainer != null) {\n\t\t\t\tsanitizerContainer.unregisterSanitizers();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_GENERATOR)) {\n\n\t\t\tEmailAddressGeneratorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_VALIDATOR)) {\n\n\t\t\tEmailAddressValidatorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_GENERATOR)) {\n\t\t\tFullNameGeneratorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_VALIDATOR)) {\n\t\t\tFullNameValidatorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_GENERATOR)) {\n\n\t\t\tScreenNameGeneratorFactory.setInstance(null);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_VALIDATOR)) {\n\n\t\t\tScreenNameValidatorFactory.setInstance(null);\n\t\t}\n\n\t\tSet<String> liferayFilterClassNames =\n\t\t\tLiferayFilterTracker.getClassNames();\n\n\t\tfor (String liferayFilterClassName : liferayFilterClassNames) {\n\t\t\tif (!portalProperties.containsKey(liferayFilterClassName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean filterEnabled = GetterUtil.getBoolean(\n\t\t\t\tPropsUtil.get(liferayFilterClassName));\n\n\t\t\tSet<LiferayFilter> liferayFilters =\n\t\t\t\tLiferayFilterTracker.getLiferayFilters(liferayFilterClassName);\n\n\t\t\tfor (LiferayFilter liferayFilter : liferayFilters) {\n\t\t\t\tliferayFilter.setFilterEnabled(filterEnabled);\n\t\t\t}\n\t\t}\n\t}","commit_id":"47b75b1518805488621050d7ede23b6a09e868e1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initPortalProperties(\n\t\t\tString servletContextName, ClassLoader portletClassLoader,\n\t\t\tProperties portalProperties, Properties unfilteredPortalProperties)\n\t\tthrows Exception {\n\n\t\tPropsUtil.addProperties(portalProperties);\n\n\t\tif (_log.isDebugEnabled() && portalProperties.containsKey(LOCALES)) {\n\t\t\t_log.debug(\n\t\t\t\t\"Portlet locales \" + portalProperties.getProperty(LOCALES));\n\t\t\t_log.debug(\"Merged locales \" + PropsUtil.get(LOCALES));\n\t\t\t_log.debug(\n\t\t\t\t\"Merged locales array length \" +\n\t\t\t\t\tPropsUtil.getArray(LOCALES).length);\n\t\t}\n\n\t\tfor (String key : _PROPS_VALUES_OBSOLETE) {\n\t\t\tif (_log.isInfoEnabled() && portalProperties.contains(key)) {\n\t\t\t\t_log.info(\"Portal property \\\"\" + key + \"\\\" is obsolete\");\n\t\t\t}\n\t\t}\n\n\t\tresetPortalProperties(servletContextName, portalProperties, true);\n\n\t\tif (portalProperties.containsKey(PropsKeys.AUTH_PUBLIC_PATHS)) {\n\t\t\tinitAuthPublicPaths(servletContextName, portalProperties);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.AUTH_TOKEN_IMPL)) {\n\t\t\tString authTokenClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.AUTH_TOKEN_IMPL);\n\n\t\t\tAuthToken authToken = (AuthToken)newInstance(\n\t\t\t\tportletClassLoader, AuthToken.class, authTokenClassName);\n\n\t\t\tAuthTokenWrapper authTokenWrapper =\n\t\t\t\t(AuthTokenWrapper)AuthTokenUtil.getAuthToken();\n\n\t\t\tauthTokenWrapper.setAuthToken(authToken);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.CAPTCHA_ENGINE_IMPL)) {\n\t\t\tString captchaClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_IMPL);\n\n\t\t\tCaptcha captcha = (Captcha)newInstance(\n\t\t\t\tportletClassLoader, Captcha.class, captchaClassName);\n\n\t\t\tCaptchaImpl captchaImpl = (CaptchaImpl)CaptchaUtil.getCaptcha();\n\n\t\t\tcaptchaImpl.setCaptcha(captcha);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.CONTROL_PANEL_DEFAULT_ENTRY_CLASS)) {\n\n\t\t\tString controlPanelEntryClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\n\t\t\tControlPanelEntry controlPanelEntry =\n\t\t\t\t(ControlPanelEntry)newInstance(\n\t\t\t\t\tportletClassLoader, ControlPanelEntry.class,\n\t\t\t\t\tcontrolPanelEntryClassName);\n\n\t\t\tDefaultControlPanelEntryFactory.setInstance(controlPanelEntry);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_FILE_ENTRY_PROCESSORS)) {\n\t\t\tString[] dlProcessorClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.DL_FILE_ENTRY_PROCESSORS));\n\n\t\t\tDLFileEntryProcessorContainer dlFileEntryProcessorContainer =\n\t\t\t\tnew DLFileEntryProcessorContainer();\n\n\t\t\t_dlFileEntryProcessorContainerMap.put(\n\t\t\t\tservletContextName, dlFileEntryProcessorContainer);\n\n\t\t\tfor (String dlProcessorClassName : dlProcessorClassNames) {\n\t\t\t\tDLProcessor dlProcessor = (DLProcessor)newInstance(\n\t\t\t\t\tportletClassLoader, DLProcessor.class,\n\t\t\t\t\tdlProcessorClassName);\n\n\t\t\t\tdlFileEntryProcessorContainer.registerDLProcessor(dlProcessor);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_REPOSITORY_IMPL)) {\n\t\t\tString[] dlRepositoryClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(PropsKeys.DL_REPOSITORY_IMPL));\n\n\t\t\tDLRepositoryContainer dlRepositoryContainer =\n\t\t\t\tnew DLRepositoryContainer();\n\n\t\t\t_dlRepositoryContainerMap.put(\n\t\t\t\tservletContextName, dlRepositoryContainer);\n\n\t\t\tfor (String dlRepositoryClassName : dlRepositoryClassNames) {\n\t\t\t\tRepositoryFactory repositoryFactory = new RepositoryFactoryImpl(\n\t\t\t\t\tdlRepositoryClassName, portletClassLoader);\n\n\t\t\t\tdlRepositoryContainer.registerRepositoryFactory(\n\t\t\t\t\tdlRepositoryClassName, repositoryFactory);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_ANTIVIRUS_IMPL)) {\n\t\t\tString antivirusScannerClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.DL_STORE_ANTIVIRUS_IMPL);\n\n\t\t\tAntivirusScanner antivirusScanner = (AntivirusScanner)newInstance(\n\t\t\t\tportletClassLoader, AntivirusScanner.class,\n\t\t\t\tantivirusScannerClassName);\n\n\t\t\tAntivirusScannerWrapper antivirusScannerWrapper =\n\t\t\t\t(AntivirusScannerWrapper)\n\t\t\t\t\tAntivirusScannerUtil.getAntivirusScanner();\n\n\t\t\tantivirusScannerWrapper.setAntivirusScanner(antivirusScanner);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_IMPL)) {\n\t\t\tString storeClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.DL_STORE_IMPL);\n\n\t\t\tStore store = (Store)newInstance(\n\t\t\t\tportletClassLoader, Store.class, storeClassName);\n\n\t\t\tStoreFactory.setInstance(store);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.LDAP_ATTRS_TRANSFORMER_IMPL)) {\n\n\t\t\tString attributesTransformerClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.LDAP_ATTRS_TRANSFORMER_IMPL);\n\n\t\t\tAttributesTransformer attributesTransformer =\n\t\t\t\t(AttributesTransformer)newInstance(\n\t\t\t\t\tportletClassLoader, AttributesTransformer.class,\n\t\t\t\t\tattributesTransformerClassName);\n\n\t\t\tAttributesTransformerFactory.setInstance(attributesTransformer);\n\t\t}\n\n\t\tif (portalProperties.containsKey(LOCK_LISTENERS)) {\n\t\t\tLockListenerContainer lockListenerContainer =\n\t\t\t\t_lockListenerContainerMap.get(servletContextName);\n\n\t\t\tif (lockListenerContainer == null) {\n\t\t\t\tlockListenerContainer = new LockListenerContainer();\n\n\t\t\t\t_lockListenerContainerMap.put(\n\t\t\t\t\tservletContextName, lockListenerContainer);\n\t\t\t}\n\n\t\t\tString[] lockListenerClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(LOCK_LISTENERS));\n\n\t\t\tfor (String lockListenerClassName : lockListenerClassNames) {\n\t\t\t\tLockListener lockListener = (LockListener)newInstance(\n\t\t\t\t\tportletClassLoader, LockListener.class,\n\t\t\t\t\tlockListenerClassName);\n\n\t\t\t\tlockListenerContainer.registerLockListener(lockListener);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MAIL_HOOK_IMPL)) {\n\t\t\tString mailHookClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.MAIL_HOOK_IMPL);\n\n\t\t\tcom.liferay.mail.util.Hook mailHook =\n\t\t\t\t(com.liferay.mail.util.Hook)newInstance(\n\t\t\t\t\tportletClassLoader, com.liferay.mail.util.Hook.class,\n\t\t\t\t\tmailHookClassName);\n\n\t\t\tcom.liferay.mail.util.HookFactory.setInstance(mailHook);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ORGANIZATIONS)) {\n\n\t\t\tString organizationMembershipPolicyClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ORGANIZATIONS);\n\n\t\t\tOrganizationMembershipPolicyFactoryImpl\n\t\t\t\torganizationMembershipPolicyFactoryImpl =\n\t\t\t\t\t(OrganizationMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tOrganizationMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetOrganizationMembershipPolicyFactory();\n\n\t\t\tOrganizationMembershipPolicy organizationMembershipPolicy =\n\t\t\t\t(OrganizationMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, OrganizationMembershipPolicy.class,\n\t\t\t\t\torganizationMembershipPolicyClassName);\n\n\t\t\torganizationMembershipPolicyFactoryImpl.\n\t\t\t\tsetOrganizationMembershipPolicy(organizationMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\torganizationMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_ROLES)) {\n\t\t\tString roleMembershipPolicyClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ROLES);\n\n\t\t\tRoleMembershipPolicyFactoryImpl roleMembershipPolicyFactoryImpl =\n\t\t\t\t(RoleMembershipPolicyFactoryImpl)\n\t\t\t\t\tRoleMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetRoleMembershipPolicyFactory();\n\n\t\t\tRoleMembershipPolicy roleMembershipPolicy =\n\t\t\t\t(RoleMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, RoleMembershipPolicy.class,\n\t\t\t\t\troleMembershipPolicyClassName);\n\n\t\t\troleMembershipPolicyFactoryImpl.setRoleMembershipPolicy(\n\t\t\t\troleMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\troleMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_SITES)) {\n\t\t\tString siteMembershipPolicyClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_SITES);\n\n\t\t\tSiteMembershipPolicyFactoryImpl siteMembershipPolicyFactoryImpl =\n\t\t\t\t(SiteMembershipPolicyFactoryImpl)\n\t\t\t\t\tSiteMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetSiteMembershipPolicyFactory();\n\n\t\t\tSiteMembershipPolicy siteMembershipPolicy =\n\t\t\t\t(SiteMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, SiteMembershipPolicy.class,\n\t\t\t\t\tsiteMembershipPolicyClassName);\n\n\t\t\tsiteMembershipPolicyFactoryImpl.setSiteMembershipPolicy(\n\t\t\t\tsiteMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\tsiteMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_USER_GROUPS)) {\n\n\t\t\tString userGroupMembershipPolicyClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_USER_GROUPS);\n\n\t\t\tUserGroupMembershipPolicyFactoryImpl\n\t\t\t\tuserGroupMembershipPolicyFactoryImpl =\n\t\t\t\t\t(UserGroupMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tUserGroupMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetUserGroupMembershipPolicyFactory();\n\n\t\t\tUserGroupMembershipPolicy userGroupMembershipPolicy =\n\t\t\t\t(UserGroupMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, UserGroupMembershipPolicy.class,\n\t\t\t\t\tuserGroupMembershipPolicyClassName);\n\n\t\t\tuserGroupMembershipPolicyFactoryImpl.setUserGroupMembershipPolicy(\n\t\t\t\tuserGroupMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\tuserGroupMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PASSWORDS_TOOLKIT)) {\n\t\t\tString toolkitClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.PASSWORDS_TOOLKIT);\n\n\t\t\tToolkit toolkit = (Toolkit)newInstance(\n\t\t\t\tportletClassLoader, Sanitizer.class, toolkitClassName);\n\n\t\t\tToolkitWrapper toolkitWrapper =\n\t\t\t\t(ToolkitWrapper)PwdToolkitUtil.getToolkit();\n\n\t\t\ttoolkitWrapper.setToolkit(toolkit);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PHONE_NUMBER_FORMAT_IMPL)) {\n\t\t\tString phoneNumberFormatClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.PHONE_NUMBER_FORMAT_IMPL);\n\n\t\t\tPhoneNumberFormat phoneNumberFormat =\n\t\t\t\t(PhoneNumberFormat)newInstance(\n\t\t\t\t\tportletClassLoader, PhoneNumberFormat.class,\n\t\t\t\t\tphoneNumberFormatClassName);\n\n\t\t\tPhoneNumberFormatWrapper phoneNumberFormatWrapper =\n\t\t\t\t(PhoneNumberFormatWrapper)\n\t\t\t\t\tPhoneNumberFormatUtil.getPhoneNumberFormat();\n\n\t\t\tphoneNumberFormatWrapper.setPhoneNumberFormat(phoneNumberFormat);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.SANITIZER_IMPL)) {\n\t\t\tString[] sanitizerClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(PropsKeys.SANITIZER_IMPL));\n\n\t\t\tSanitizerContainer sanitizerContainer = new SanitizerContainer();\n\n\t\t\t_sanitizerContainerMap.put(servletContextName, sanitizerContainer);\n\n\t\t\tfor (String sanitizerClassName : sanitizerClassNames) {\n\t\t\t\tSanitizer sanitizer = (Sanitizer)newInstance(\n\t\t\t\t\tportletClassLoader, Sanitizer.class, sanitizerClassName);\n\n\t\t\t\tsanitizerContainer.registerSanitizer(sanitizer);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_GENERATOR)) {\n\n\t\t\tString emailAddressGeneratorClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_GENERATOR);\n\n\t\t\tEmailAddressGenerator emailAddressGenerator =\n\t\t\t\t(EmailAddressGenerator)newInstance(\n\t\t\t\t\tportletClassLoader, EmailAddressGenerator.class,\n\t\t\t\t\temailAddressGeneratorClassName);\n\n\t\t\tEmailAddressGeneratorFactory.setInstance(emailAddressGenerator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_VALIDATOR)) {\n\n\t\t\tString emailAddressValidatorClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_VALIDATOR);\n\n\t\t\tEmailAddressValidator emailAddressValidator =\n\t\t\t\t(EmailAddressValidator)newInstance(\n\t\t\t\t\tportletClassLoader, EmailAddressValidator.class,\n\t\t\t\t\temailAddressValidatorClassName);\n\n\t\t\tEmailAddressValidatorFactory.setInstance(emailAddressValidator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_GENERATOR)) {\n\t\t\tString fullNameGeneratorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_FULL_NAME_GENERATOR);\n\n\t\t\tFullNameGenerator fullNameGenerator =\n\t\t\t\t(FullNameGenerator)newInstance(\n\t\t\t\t\tportletClassLoader, FullNameGenerator.class,\n\t\t\t\t\tfullNameGeneratorClassName);\n\n\t\t\tFullNameGeneratorFactory.setInstance(fullNameGenerator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_VALIDATOR)) {\n\t\t\tString fullNameValidatorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_FULL_NAME_VALIDATOR);\n\n\t\t\tFullNameValidator fullNameValidator =\n\t\t\t\t(FullNameValidator)newInstance(\n\t\t\t\t\tportletClassLoader, FullNameValidator.class,\n\t\t\t\t\tfullNameValidatorClassName);\n\n\t\t\tFullNameValidatorFactory.setInstance(fullNameValidator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_GENERATOR)) {\n\n\t\t\tString screenNameGeneratorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_GENERATOR);\n\n\t\t\tScreenNameGenerator screenNameGenerator =\n\t\t\t\t(ScreenNameGenerator)newInstance(\n\t\t\t\t\tportletClassLoader, ScreenNameGenerator.class,\n\t\t\t\t\tscreenNameGeneratorClassName);\n\n\t\t\tScreenNameGeneratorFactory.setInstance(screenNameGenerator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_VALIDATOR)) {\n\n\t\t\tString screenNameValidatorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_VALIDATOR);\n\n\t\t\tScreenNameValidator screenNameValidator =\n\t\t\t\t(ScreenNameValidator)newInstance(\n\t\t\t\t\tportletClassLoader, ScreenNameValidator.class,\n\t\t\t\t\tscreenNameValidatorClassName);\n\n\t\t\tScreenNameValidatorFactory.setInstance(screenNameValidator);\n\t\t}\n\n\t\tSet<String> liferayFilterClassNames =\n\t\t\tLiferayFilterTracker.getClassNames();\n\n\t\tfor (String liferayFilterClassName : liferayFilterClassNames) {\n\t\t\tif (!portalProperties.containsKey(liferayFilterClassName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean filterEnabled = GetterUtil.getBoolean(\n\t\t\t\tportalProperties.getProperty(liferayFilterClassName));\n\n\t\t\tSet<LiferayFilter> liferayFilters =\n\t\t\t\tLiferayFilterTracker.getLiferayFilters(liferayFilterClassName);\n\n\t\t\tfor (LiferayFilter liferayFilter : liferayFilters) {\n\t\t\t\tliferayFilter.setFilterEnabled(filterEnabled);\n\t\t\t}\n\t\t}\n\n\t\tif (unfilteredPortalProperties.containsKey(\n\t\t\t\tPropsKeys.RELEASE_INFO_BUILD_NUMBER) ||\n\t\t\tunfilteredPortalProperties.containsKey(\n\t\t\t\tPropsKeys.UPGRADE_PROCESSES)) {\n\n\t\t\tupdateRelease(\n\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\tunfilteredPortalProperties);\n\t\t}\n\t}","id":474,"modified_method":"protected void initPortalProperties(\n\t\t\tString servletContextName, ClassLoader portletClassLoader,\n\t\t\tProperties portalProperties, Properties unfilteredPortalProperties)\n\t\tthrows Exception {\n\n\t\tPropsUtil.addProperties(portalProperties);\n\n\t\tif (_log.isDebugEnabled() && portalProperties.containsKey(LOCALES)) {\n\t\t\t_log.debug(\n\t\t\t\t\"Portlet locales \" + portalProperties.getProperty(LOCALES));\n\t\t\t_log.debug(\"Merged locales \" + PropsUtil.get(LOCALES));\n\t\t\t_log.debug(\n\t\t\t\t\"Merged locales array length \" +\n\t\t\t\t\tPropsUtil.getArray(LOCALES).length);\n\t\t}\n\n\t\tfor (String key : _PROPS_VALUES_OBSOLETE) {\n\t\t\tif (_log.isInfoEnabled() && portalProperties.contains(key)) {\n\t\t\t\t_log.info(\"Portal property \\\"\" + key + \"\\\" is obsolete\");\n\t\t\t}\n\t\t}\n\n\t\tresetPortalProperties(servletContextName, portalProperties, true);\n\n\t\tif (portalProperties.containsKey(PropsKeys.AUTH_PUBLIC_PATHS)) {\n\t\t\tinitAuthPublicPaths(servletContextName, portalProperties);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.AUTH_TOKEN_IMPL)) {\n\t\t\tString authTokenClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.AUTH_TOKEN_IMPL);\n\n\t\t\tAuthToken authToken = (AuthToken)newInstance(\n\t\t\t\tportletClassLoader, AuthToken.class, authTokenClassName);\n\n\t\t\tAuthTokenWrapper authTokenWrapper =\n\t\t\t\t(AuthTokenWrapper)AuthTokenUtil.getAuthToken();\n\n\t\t\tauthTokenWrapper.setAuthToken(authToken);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.CAPTCHA_ENGINE_IMPL)) {\n\t\t\tString captchaClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.CAPTCHA_ENGINE_IMPL);\n\n\t\t\tCaptcha captcha = (Captcha)newInstance(\n\t\t\t\tportletClassLoader, Captcha.class, captchaClassName);\n\n\t\t\tCaptcha currentCaptcha = CaptchaUtil.getCaptcha();\n\n\t\t\tCaptchaImpl captchaImpl;\n\n\t\t\tif (currentCaptcha instanceof DoPrivilegedBean) {\n\t\t\t\tDoPrivilegedBean doPrivilegedBean =\n\t\t\t\t\t(DoPrivilegedBean)currentCaptcha;\n\n\t\t\t\tcaptchaImpl = (CaptchaImpl)doPrivilegedBean.getActualBean();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcaptchaImpl = (CaptchaImpl)currentCaptcha;\n\t\t\t}\n\n\t\t\tcaptchaImpl.setCaptcha(captcha);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.CONTROL_PANEL_DEFAULT_ENTRY_CLASS)) {\n\n\t\t\tString controlPanelEntryClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\n\t\t\tControlPanelEntry controlPanelEntry =\n\t\t\t\t(ControlPanelEntry)newInstance(\n\t\t\t\t\tportletClassLoader, ControlPanelEntry.class,\n\t\t\t\t\tcontrolPanelEntryClassName);\n\n\t\t\tDefaultControlPanelEntryFactory.setInstance(controlPanelEntry);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_FILE_ENTRY_PROCESSORS)) {\n\t\t\tString[] dlProcessorClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.DL_FILE_ENTRY_PROCESSORS));\n\n\t\t\tDLFileEntryProcessorContainer dlFileEntryProcessorContainer =\n\t\t\t\tnew DLFileEntryProcessorContainer();\n\n\t\t\t_dlFileEntryProcessorContainerMap.put(\n\t\t\t\tservletContextName, dlFileEntryProcessorContainer);\n\n\t\t\tfor (String dlProcessorClassName : dlProcessorClassNames) {\n\t\t\t\tDLProcessor dlProcessor = (DLProcessor)newInstance(\n\t\t\t\t\tportletClassLoader, DLProcessor.class,\n\t\t\t\t\tdlProcessorClassName);\n\n\t\t\t\tdlFileEntryProcessorContainer.registerDLProcessor(dlProcessor);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_REPOSITORY_IMPL)) {\n\t\t\tString[] dlRepositoryClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(PropsKeys.DL_REPOSITORY_IMPL));\n\n\t\t\tDLRepositoryContainer dlRepositoryContainer =\n\t\t\t\tnew DLRepositoryContainer();\n\n\t\t\t_dlRepositoryContainerMap.put(\n\t\t\t\tservletContextName, dlRepositoryContainer);\n\n\t\t\tfor (String dlRepositoryClassName : dlRepositoryClassNames) {\n\t\t\t\tRepositoryFactory repositoryFactory = new RepositoryFactoryImpl(\n\t\t\t\t\tdlRepositoryClassName, portletClassLoader);\n\n\t\t\t\tdlRepositoryContainer.registerRepositoryFactory(\n\t\t\t\t\tdlRepositoryClassName, repositoryFactory);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_ANTIVIRUS_IMPL)) {\n\t\t\tString antivirusScannerClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.DL_STORE_ANTIVIRUS_IMPL);\n\n\t\t\tAntivirusScanner antivirusScanner = (AntivirusScanner)newInstance(\n\t\t\t\tportletClassLoader, AntivirusScanner.class,\n\t\t\t\tantivirusScannerClassName);\n\n\t\t\tAntivirusScannerWrapper antivirusScannerWrapper =\n\t\t\t\t(AntivirusScannerWrapper)\n\t\t\t\t\tAntivirusScannerUtil.getAntivirusScanner();\n\n\t\t\tantivirusScannerWrapper.setAntivirusScanner(antivirusScanner);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.DL_STORE_IMPL)) {\n\t\t\tString storeClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.DL_STORE_IMPL);\n\n\t\t\tStore store = (Store)newInstance(\n\t\t\t\tportletClassLoader, Store.class, storeClassName);\n\n\t\t\tStoreFactory.setInstance(store);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.LDAP_ATTRS_TRANSFORMER_IMPL)) {\n\n\t\t\tString attributesTransformerClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.LDAP_ATTRS_TRANSFORMER_IMPL);\n\n\t\t\tAttributesTransformer attributesTransformer =\n\t\t\t\t(AttributesTransformer)newInstance(\n\t\t\t\t\tportletClassLoader, AttributesTransformer.class,\n\t\t\t\t\tattributesTransformerClassName);\n\n\t\t\tAttributesTransformerFactory.setInstance(attributesTransformer);\n\t\t}\n\n\t\tif (portalProperties.containsKey(LOCK_LISTENERS)) {\n\t\t\tLockListenerContainer lockListenerContainer =\n\t\t\t\t_lockListenerContainerMap.get(servletContextName);\n\n\t\t\tif (lockListenerContainer == null) {\n\t\t\t\tlockListenerContainer = new LockListenerContainer();\n\n\t\t\t\t_lockListenerContainerMap.put(\n\t\t\t\t\tservletContextName, lockListenerContainer);\n\t\t\t}\n\n\t\t\tString[] lockListenerClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(LOCK_LISTENERS));\n\n\t\t\tfor (String lockListenerClassName : lockListenerClassNames) {\n\t\t\t\tLockListener lockListener = (LockListener)newInstance(\n\t\t\t\t\tportletClassLoader, LockListener.class,\n\t\t\t\t\tlockListenerClassName);\n\n\t\t\t\tlockListenerContainer.registerLockListener(lockListener);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MAIL_HOOK_IMPL)) {\n\t\t\tString mailHookClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.MAIL_HOOK_IMPL);\n\n\t\t\tcom.liferay.mail.util.Hook mailHook =\n\t\t\t\t(com.liferay.mail.util.Hook)newInstance(\n\t\t\t\t\tportletClassLoader, com.liferay.mail.util.Hook.class,\n\t\t\t\t\tmailHookClassName);\n\n\t\t\tcom.liferay.mail.util.HookFactory.setInstance(mailHook);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ORGANIZATIONS)) {\n\n\t\t\tString organizationMembershipPolicyClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ORGANIZATIONS);\n\n\t\t\tOrganizationMembershipPolicyFactoryImpl\n\t\t\t\torganizationMembershipPolicyFactoryImpl =\n\t\t\t\t\t(OrganizationMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tOrganizationMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetOrganizationMembershipPolicyFactory();\n\n\t\t\tOrganizationMembershipPolicy organizationMembershipPolicy =\n\t\t\t\t(OrganizationMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, OrganizationMembershipPolicy.class,\n\t\t\t\t\torganizationMembershipPolicyClassName);\n\n\t\t\torganizationMembershipPolicyFactoryImpl.\n\t\t\t\tsetOrganizationMembershipPolicy(organizationMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\torganizationMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_ROLES)) {\n\t\t\tString roleMembershipPolicyClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_ROLES);\n\n\t\t\tRoleMembershipPolicyFactoryImpl roleMembershipPolicyFactoryImpl =\n\t\t\t\t(RoleMembershipPolicyFactoryImpl)\n\t\t\t\t\tRoleMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetRoleMembershipPolicyFactory();\n\n\t\t\tRoleMembershipPolicy roleMembershipPolicy =\n\t\t\t\t(RoleMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, RoleMembershipPolicy.class,\n\t\t\t\t\troleMembershipPolicyClassName);\n\n\t\t\troleMembershipPolicyFactoryImpl.setRoleMembershipPolicy(\n\t\t\t\troleMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\troleMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.MEMBERSHIP_POLICY_SITES)) {\n\t\t\tString siteMembershipPolicyClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_SITES);\n\n\t\t\tSiteMembershipPolicyFactoryImpl siteMembershipPolicyFactoryImpl =\n\t\t\t\t(SiteMembershipPolicyFactoryImpl)\n\t\t\t\t\tSiteMembershipPolicyFactoryUtil.\n\t\t\t\t\t\tgetSiteMembershipPolicyFactory();\n\n\t\t\tSiteMembershipPolicy siteMembershipPolicy =\n\t\t\t\t(SiteMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, SiteMembershipPolicy.class,\n\t\t\t\t\tsiteMembershipPolicyClassName);\n\n\t\t\tsiteMembershipPolicyFactoryImpl.setSiteMembershipPolicy(\n\t\t\t\tsiteMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\tsiteMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_USER_GROUPS)) {\n\n\t\t\tString userGroupMembershipPolicyClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.MEMBERSHIP_POLICY_USER_GROUPS);\n\n\t\t\tUserGroupMembershipPolicyFactoryImpl\n\t\t\t\tuserGroupMembershipPolicyFactoryImpl =\n\t\t\t\t\t(UserGroupMembershipPolicyFactoryImpl)\n\t\t\t\t\t\tUserGroupMembershipPolicyFactoryUtil.\n\t\t\t\t\t\t\tgetUserGroupMembershipPolicyFactory();\n\n\t\t\tUserGroupMembershipPolicy userGroupMembershipPolicy =\n\t\t\t\t(UserGroupMembershipPolicy)newInstance(\n\t\t\t\t\tportletClassLoader, UserGroupMembershipPolicy.class,\n\t\t\t\t\tuserGroupMembershipPolicyClassName);\n\n\t\t\tuserGroupMembershipPolicyFactoryImpl.setUserGroupMembershipPolicy(\n\t\t\t\tuserGroupMembershipPolicy);\n\n\t\t\tif (PropsValues.MEMBERSHIP_POLICY_AUTO_VERIFY) {\n\t\t\t\tuserGroupMembershipPolicy.verifyPolicy();\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PASSWORDS_TOOLKIT)) {\n\t\t\tString toolkitClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.PASSWORDS_TOOLKIT);\n\n\t\t\tToolkit toolkit = (Toolkit)newInstance(\n\t\t\t\tportletClassLoader, Sanitizer.class, toolkitClassName);\n\n\t\t\tToolkitWrapper toolkitWrapper =\n\t\t\t\t(ToolkitWrapper)PwdToolkitUtil.getToolkit();\n\n\t\t\ttoolkitWrapper.setToolkit(toolkit);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.PHONE_NUMBER_FORMAT_IMPL)) {\n\t\t\tString phoneNumberFormatClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.PHONE_NUMBER_FORMAT_IMPL);\n\n\t\t\tPhoneNumberFormat phoneNumberFormat =\n\t\t\t\t(PhoneNumberFormat)newInstance(\n\t\t\t\t\tportletClassLoader, PhoneNumberFormat.class,\n\t\t\t\t\tphoneNumberFormatClassName);\n\n\t\t\tPhoneNumberFormatWrapper phoneNumberFormatWrapper =\n\t\t\t\t(PhoneNumberFormatWrapper)\n\t\t\t\t\tPhoneNumberFormatUtil.getPhoneNumberFormat();\n\n\t\t\tphoneNumberFormatWrapper.setPhoneNumberFormat(phoneNumberFormat);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.SANITIZER_IMPL)) {\n\t\t\tString[] sanitizerClassNames = StringUtil.split(\n\t\t\t\tportalProperties.getProperty(PropsKeys.SANITIZER_IMPL));\n\n\t\t\tSanitizerContainer sanitizerContainer = new SanitizerContainer();\n\n\t\t\t_sanitizerContainerMap.put(servletContextName, sanitizerContainer);\n\n\t\t\tfor (String sanitizerClassName : sanitizerClassNames) {\n\t\t\t\tSanitizer sanitizer = (Sanitizer)newInstance(\n\t\t\t\t\tportletClassLoader, Sanitizer.class, sanitizerClassName);\n\n\t\t\t\tsanitizerContainer.registerSanitizer(sanitizer);\n\t\t\t}\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_GENERATOR)) {\n\n\t\t\tString emailAddressGeneratorClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_GENERATOR);\n\n\t\t\tEmailAddressGenerator emailAddressGenerator =\n\t\t\t\t(EmailAddressGenerator)newInstance(\n\t\t\t\t\tportletClassLoader, EmailAddressGenerator.class,\n\t\t\t\t\temailAddressGeneratorClassName);\n\n\t\t\tEmailAddressGeneratorFactory.setInstance(emailAddressGenerator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_VALIDATOR)) {\n\n\t\t\tString emailAddressValidatorClassName =\n\t\t\t\tportalProperties.getProperty(\n\t\t\t\t\tPropsKeys.USERS_EMAIL_ADDRESS_VALIDATOR);\n\n\t\t\tEmailAddressValidator emailAddressValidator =\n\t\t\t\t(EmailAddressValidator)newInstance(\n\t\t\t\t\tportletClassLoader, EmailAddressValidator.class,\n\t\t\t\t\temailAddressValidatorClassName);\n\n\t\t\tEmailAddressValidatorFactory.setInstance(emailAddressValidator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_GENERATOR)) {\n\t\t\tString fullNameGeneratorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_FULL_NAME_GENERATOR);\n\n\t\t\tFullNameGenerator fullNameGenerator =\n\t\t\t\t(FullNameGenerator)newInstance(\n\t\t\t\t\tportletClassLoader, FullNameGenerator.class,\n\t\t\t\t\tfullNameGeneratorClassName);\n\n\t\t\tFullNameGeneratorFactory.setInstance(fullNameGenerator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(PropsKeys.USERS_FULL_NAME_VALIDATOR)) {\n\t\t\tString fullNameValidatorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_FULL_NAME_VALIDATOR);\n\n\t\t\tFullNameValidator fullNameValidator =\n\t\t\t\t(FullNameValidator)newInstance(\n\t\t\t\t\tportletClassLoader, FullNameValidator.class,\n\t\t\t\t\tfullNameValidatorClassName);\n\n\t\t\tFullNameValidatorFactory.setInstance(fullNameValidator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_GENERATOR)) {\n\n\t\t\tString screenNameGeneratorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_GENERATOR);\n\n\t\t\tScreenNameGenerator screenNameGenerator =\n\t\t\t\t(ScreenNameGenerator)newInstance(\n\t\t\t\t\tportletClassLoader, ScreenNameGenerator.class,\n\t\t\t\t\tscreenNameGeneratorClassName);\n\n\t\t\tScreenNameGeneratorFactory.setInstance(screenNameGenerator);\n\t\t}\n\n\t\tif (portalProperties.containsKey(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_VALIDATOR)) {\n\n\t\t\tString screenNameValidatorClassName = portalProperties.getProperty(\n\t\t\t\tPropsKeys.USERS_SCREEN_NAME_VALIDATOR);\n\n\t\t\tScreenNameValidator screenNameValidator =\n\t\t\t\t(ScreenNameValidator)newInstance(\n\t\t\t\t\tportletClassLoader, ScreenNameValidator.class,\n\t\t\t\t\tscreenNameValidatorClassName);\n\n\t\t\tScreenNameValidatorFactory.setInstance(screenNameValidator);\n\t\t}\n\n\t\tSet<String> liferayFilterClassNames =\n\t\t\tLiferayFilterTracker.getClassNames();\n\n\t\tfor (String liferayFilterClassName : liferayFilterClassNames) {\n\t\t\tif (!portalProperties.containsKey(liferayFilterClassName)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean filterEnabled = GetterUtil.getBoolean(\n\t\t\t\tportalProperties.getProperty(liferayFilterClassName));\n\n\t\t\tSet<LiferayFilter> liferayFilters =\n\t\t\t\tLiferayFilterTracker.getLiferayFilters(liferayFilterClassName);\n\n\t\t\tfor (LiferayFilter liferayFilter : liferayFilters) {\n\t\t\t\tliferayFilter.setFilterEnabled(filterEnabled);\n\t\t\t}\n\t\t}\n\n\t\tif (unfilteredPortalProperties.containsKey(\n\t\t\t\tPropsKeys.RELEASE_INFO_BUILD_NUMBER) ||\n\t\t\tunfilteredPortalProperties.containsKey(\n\t\t\t\tPropsKeys.UPGRADE_PROCESSES)) {\n\n\t\t\tupdateRelease(\n\t\t\t\tservletContextName, portletClassLoader,\n\t\t\t\tunfilteredPortalProperties);\n\t\t}\n\t}","commit_id":"47b75b1518805488621050d7ede23b6a09e868e1","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            mping.setMcastPort(8888);\n            mping.setBindAddr(InetAddress.getLocalHost());\n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            System.out.println(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","id":475,"modified_method":"private static void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            InetAddress bindAddress=Util.getBindAddress(new Properties());\n            mping.setBindAddr(bindAddress);\n            mping.setMulticastAddress(\"230.1.2.3\");\n            mping.setMcastPort(8888);            \n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            System.out.println(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","commit_id":"96b81fb870b5dda288836629bb40686be650600c","url":"https://github.com/belaban/JGroups"},{"original_method":"private void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            mping.setMcastPort(7777);\n            mping.setBindAddr(InetAddress.getLocalHost());\n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            log.info(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","id":476,"modified_method":"private void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            InetAddress bindAddress=Util.getBindAddress(new Properties());\n            mping.setBindAddr(bindAddress);\n            mping.setMulticastAddress(\"230.3.3.3\");\n            mping.setMcastPort(7777);            \n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            log.info(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","commit_id":"96b81fb870b5dda288836629bb40686be650600c","url":"https://github.com/belaban/JGroups"},{"original_method":"private static void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            mping.setMcastPort(8888);\n            mping.setBindAddr(InetAddress.getLocalHost());\n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            System.out.println(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","id":477,"modified_method":"private static void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            InetAddress bindAddress=Util.getBindAddress(new Properties());\n            mping.setBindAddr(bindAddress);\n            mping.setMulticastAddress(\"230.1.2.3\");\n            mping.setMcastPort(8888);            \n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            System.out.println(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","commit_id":"bbca7c6c1c40139e8f1d994b0a7a3f7cc3e31b7b","url":"https://github.com/belaban/JGroups"},{"original_method":"private void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            mping.setMcastPort(7777);\n            mping.setBindAddr(InetAddress.getLocalHost());\n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            log.info(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","id":478,"modified_method":"private void replaceDiscoveryProtocol(JChannel ch) throws Exception {\n        ProtocolStack stack=ch.getProtocolStack();\n        Protocol discovery=stack.removeProtocol(\"TCPPING\");\n        if(discovery != null){\n            Protocol transport = stack.getTransport();\n            MPING mping=new MPING();\n            InetAddress bindAddress=Util.getBindAddress(new Properties());\n            mping.setBindAddr(bindAddress);\n            mping.setMulticastAddress(\"230.3.3.3\");\n            mping.setMcastPort(7777);            \n            stack.insertProtocol(mping, ProtocolStack.ABOVE, transport.getName());\n            mping.setProtocolStack(ch.getProtocolStack());\n            mping.init();\n            mping.start();            \n            log.info(\"Replaced TCPPING with MPING. See http://wiki.jboss.org/wiki/Wiki.jsp?page=JGroupsMERGE2\");            \n        }        \n    }","commit_id":"bbca7c6c1c40139e8f1d994b0a7a3f7cc3e31b7b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void unlockLayout(String meetingID) {\n\t\tLayoutRoom r = getRoom(meetingID);\n\t\tif (r != null) {\n\t\t\tr.unlockLayout();\n\t\t\tsender.updateLayout(r.getMeetingID(), r.isLocked(), r.getSetByUserID(), r.getCurrentLayout());\n\t\t} \n\t}","id":479,"modified_method":"public void unlockLayout(String meetingID) {\n\t\tLayoutRoom r = getRoom(meetingID);\n\t\tif (r != null) {\n\t\t\tr.unlockLayout();\n\t\t\tUpdateLayoutMessage msg = new UpdateLayoutMessage(r.getMeetingID(), r.isRecorded(), r.isLocked(), r.getSetByUserID(), r.getCurrentLayout());\n\t\t\toutMessageGateway.send(msg);\t\t\t\n\t\t} \n\t}","commit_id":"e347942134408fd6f0342d8e743a097e208ea8c5","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void getCurrentLayout(String meetingID, String requesterID) {\n\t\tLayoutRoom r = getRoom(meetingID);\n\t\tif (r != null) {\n\t\t\tsender.sendGetCurrentLayoutResponse(r.getMeetingID(), requesterID, r.isLocked(), r.getSetByUserID(), r.getCurrentLayout());\n\t\t}\n\t}","id":480,"modified_method":"public void getCurrentLayout(String meetingID, String requesterID) {\n\t\tLayoutRoom r = getRoom(meetingID);\n\t\tif (r != null) {\n\t\t\tGetCurrentLayoutResponseMessage msg = new GetCurrentLayoutResponseMessage(meetingID, r.isRecorded(), requesterID, r.isLocked(), r.getSetByUserID(), r.getCurrentLayout());\n\t\t\toutMessageGateway.send(msg);\n\t\t}\n\t}","commit_id":"e347942134408fd6f0342d8e743a097e208ea8c5","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void lockLayout(String meetingID, String userId, String layout) {\n\t\tLayoutRoom r = getRoom(meetingID);\n\t\tif (r != null) {\n\t\t\tr.lockLayout(userId, layout);\n\t\t\tsender.updateLayout(r.getMeetingID(), r.isLocked(), r.getSetByUserID(), r.getCurrentLayout());\n\t\t} \n\t}","id":481,"modified_method":"public void lockLayout(String meetingID, String userId, String layout) {\n\t\tLayoutRoom r = getRoom(meetingID);\n\t\tif (r != null) {\n\t\t\tr.lockLayout(userId, layout);\n\t\t\tUpdateLayoutMessage msg = new UpdateLayoutMessage(r.getMeetingID(), r.isRecorded(), r.isLocked(), r.getSetByUserID(), r.getCurrentLayout());\n\t\t\toutMessageGateway.send(msg);\n\t\t} \n\t}","commit_id":"e347942134408fd6f0342d8e743a097e208ea8c5","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Nonnull\n    @Override\n    public String startBlobGC() {\n        if (gcOp != null && !gcOp.isDone()) {\n            return \"Garbage collection already running\";\n        } else {\n            gcOp = new FutureTask<Long>(new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = System.nanoTime();\n                    blobGarbageCollector.collectGarbage();\n                    return System.nanoTime() - t0;\n                }\n            });\n            executor.execute(gcOp);\n            return getBlobGCStatus();\n        }\n    }","id":482,"modified_method":"@Nonnull\n    @Override\n    public CompositeData startBlobGC() {\n        if (gcOp.isDone()) {\n            gcOp = new ManagementOperation(OP_NAME, new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = nanoTime();\n                    blobGarbageCollector.collectGarbage();\n                    return nanoTime() - t0;\n                }\n            });\n            executor.execute(gcOp);\n        }\n        return getBlobGCStatus();\n    }","commit_id":"a7cca09310c97271e989871c761d663e3a175071","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public synchronized String startRestore() {\n        if (restoreOp != null && !restoreOp.isDone()) {\n            return \"Restore already running\";\n        } else {\n            restoreOp = new FutureTask<Long>(new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = System.nanoTime();\n                    FileStoreRestore.restore(file, store);\n                    return System.nanoTime() - t0;\n                }\n            });\n            executor.execute(restoreOp);\n            return getRestoreStatus();\n        }\n    }","id":483,"modified_method":"@Override\n    public synchronized CompositeData startRestore() {\n        if (restoreOp.isDone()) {\n            restoreOp = new ManagementOperation(\"Restore\", new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = nanoTime();\n                    restore(file, store);\n                    return nanoTime() - t0;\n                }\n            });\n            executor.execute(restoreOp);\n        }\n        return getRestoreStatus();\n    }","commit_id":"a7cca09310c97271e989871c761d663e3a175071","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public synchronized String startBackup() {\n        if (backupOp != null && !backupOp.isDone()) {\n            return \"Backup already running\";\n        } else {\n            backupOp = new FutureTask<Long>(new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = System.nanoTime();\n                    FileStoreBackup.backup(store, file);\n                    return System.nanoTime() - t0;\n                }\n            });\n            executor.execute(backupOp);\n            return getBackupStatus();\n        }\n    }","id":484,"modified_method":"@Override\n    public synchronized CompositeData startBackup() {\n        if (backupOp.isDone()) {\n            backupOp = new ManagementOperation(\"Backup\", new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = nanoTime();\n                    backup(store, file);\n                    return nanoTime() - t0;\n                }\n            });\n            executor.execute(backupOp);\n        }\n        return getBackupStatus();\n    }","commit_id":"a7cca09310c97271e989871c761d663e3a175071","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public String startRevisionGC() {\n        if (gcOp != null && !gcOp.isDone()) {\n            return \"Garbage collection already running\";\n        } else {\n            gcOp = new FutureTask<Long>(new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = System.nanoTime();\n                    gc.run();\n                    return System.nanoTime() - t0;\n                }\n            });\n            executor.execute(gcOp);\n            return getRevisionGCStatus();\n        }\n    }","id":485,"modified_method":"@Nonnull\n    @Override\n    public CompositeData startRevisionGC() {\n        if (gcOp.isDone()) {\n            gcOp = new ManagementOperation(OP_NAME, new Callable<Long>() {\n                @Override\n                public Long call() throws Exception {\n                    long t0 = nanoTime();\n                    gc.run();\n                    return nanoTime() - t0;\n                }\n            });\n            executor.execute(gcOp);\n        }\n        return getRevisionGCStatus();\n    }","commit_id":"a7cca09310c97271e989871c761d663e3a175071","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tclassContext.getJavaClass().accept(this);\n\t\t\n\t}","id":486,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif  (!FindUnreleasedLock.preTiger(javaClass)) javaClass.accept(this);\n\t\t\n\t}","commit_id":"4d5b38c4c3a94ad99c42eff7b758519e5b042ad6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tif (LOAD_TRAINING != null && !checkLoad) {\n\t\t\tloadTraining();\n\t\t\tcheckLoad = true;\n\t\t}\n\t\tclassContext.getJavaClass().accept(this);\n\t}","id":487,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tif (LOAD_TRAINING != null && !checkLoad) {\n\t\t\tloadTraining();\n\t\t\tcheckLoad = true;\n\t\t}\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif  (!FindUnreleasedLock.preTiger(javaClass)) javaClass.accept(this);\n\t}","commit_id":"4d5b38c4c3a94ad99c42eff7b758519e5b042ad6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\t\n\t\tclassContext.getJavaClass().accept(this);\n\t}","id":488,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\t\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif  (!FindUnreleasedLock.preTiger(javaClass)) javaClass.accept(this);\n\t}","commit_id":"4d5b38c4c3a94ad99c42eff7b758519e5b042ad6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tclassContext.getJavaClass().accept(this);\n\n\t}","id":489,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif  (!FindUnreleasedLock.preTiger(javaClass)) javaClass.accept(this);\n\n\t}","commit_id":"4d5b38c4c3a94ad99c42eff7b758519e5b042ad6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\t\n\t\tclassContext.getJavaClass().accept(this);\n\t}","id":490,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\t\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif  (!FindUnreleasedLock.preTiger(javaClass)) javaClass.accept(this);\n\t}","commit_id":"4d5b38c4c3a94ad99c42eff7b758519e5b042ad6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tclassContext.getJavaClass().accept(this);\n\t}","id":491,"modified_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tif  (!FindUnreleasedLock.preTiger(javaClass)) javaClass.accept(this);\n\t}","commit_id":"4d5b38c4c3a94ad99c42eff7b758519e5b042ad6","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public TestSequenceModel(CRFCliqueTree<String> cliqueTree,\n      LabelDictionary labelDictionary, List<? extends CoreMap> document) {\n    // this.factorTables = factorTables;\n    this.cliqueTree = cliqueTree;\n    // this.window = factorTables[0].windowSize();\n    this.window = cliqueTree.window();\n    // this.numClasses = factorTables[0].numClasses();\n    this.numClasses = cliqueTree.getNumClasses();\n\n    this.backgroundTag = new int[] { cliqueTree.backgroundIndex() };\n    allTags = new int[numClasses];\n    for (int i = 0; i < allTags.length; i++) {\n      allTags[i] = i;\n    }\n    if (labelDictionary != null) {\n      // Constrained\n      allowedTagsAtPosition = new int[document.size()][];\n      for (int i = 0; i < allowedTagsAtPosition.length; ++i) {\n        CoreMap token  = document.get(i);\n        String observation = token.get(CoreAnnotations.TextAnnotation.class);\n        if (labelDictionary.isConstrained(observation)) {\n          Set<Integer> allowedLabels = labelDictionary.getConstrainedSet(observation);\n          allowedTagsAtPosition[i] = new int[allowedLabels.size()];\n          int j = 0;\n          for (int labelIdx : allowedLabels) {\n            allowedTagsAtPosition[i][j++] = labelIdx;\n          }\n        } else {\n          allowedTagsAtPosition[i] = allTags;\n        }\n      }\n    }\n  }","id":492,"modified_method":"public TestSequenceModel(CRFCliqueTree<String> cliqueTree,\n      LabelDictionary labelDictionary, List<? extends CoreMap> document) {\n    // this.factorTables = factorTables;\n    this.cliqueTree = cliqueTree;\n    // this.window = factorTables[0].windowSize();\n    this.window = cliqueTree.window();\n    // this.numClasses = factorTables[0].numClasses();\n    this.numClasses = cliqueTree.getNumClasses();\n\n    this.backgroundTag = new int[] { cliqueTree.backgroundIndex() };\n    allTags = new int[numClasses];\n    for (int i = 0; i < allTags.length; i++) {\n      allTags[i] = i;\n    }\n    if (labelDictionary != null) {\n      // Constrained\n      allowedTagsAtPosition = new int[document.size()][];\n      for (int i = 0; i < allowedTagsAtPosition.length; ++i) {\n        CoreMap token  = document.get(i);\n        String observation = token.get(CoreAnnotations.TextAnnotation.class);\n        allowedTagsAtPosition[i] = labelDictionary.isConstrained(observation) ?\n            labelDictionary.getConstrainedSet(observation) : allTags;\n      }\n    }\n  }","commit_id":"857b96a9ab9b29ebdbd55ecc3a6bc6ac6bd1b384","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TestSequenceModel(CRFCliqueTree<String> cliqueTree,\n      LabelDictionary labelDictionary, List<? extends CoreMap> document) {\n    // this.factorTables = factorTables;\n    this.cliqueTree = cliqueTree;\n    // this.window = factorTables[0].windowSize();\n    this.window = cliqueTree.window();\n    // this.numClasses = factorTables[0].numClasses();\n    this.numClasses = cliqueTree.getNumClasses();\n\n    this.backgroundTag = new int[] { cliqueTree.backgroundIndex() };\n    allTags = new int[numClasses];\n    for (int i = 0; i < allTags.length; i++) {\n      allTags[i] = i;\n    }\n    if (labelDictionary != null) {\n      // Constrained\n      allowedTagsAtPosition = new int[document.size()][];\n      for (int i = 0; i < allowedTagsAtPosition.length; ++i) {\n        CoreMap token  = document.get(i);\n        String observation = token.get(CoreAnnotations.TextAnnotation.class);\n        if (labelDictionary.isConstrained(observation)) {\n          Set<Integer> allowedLabels = labelDictionary.getConstrainedSet(observation);\n          allowedTagsAtPosition[i] = new int[allowedLabels.size()];\n          int j = 0;\n          for (int labelIdx : allowedLabels) {\n            allowedTagsAtPosition[i][j++] = labelIdx;\n          }\n        } else {\n          allowedTagsAtPosition[i] = allTags;\n        }\n      }\n    }\n  }","id":493,"modified_method":"public TestSequenceModel(CRFCliqueTree<String> cliqueTree,\n      LabelDictionary labelDictionary, List<? extends CoreMap> document) {\n    // this.factorTables = factorTables;\n    this.cliqueTree = cliqueTree;\n    // this.window = factorTables[0].windowSize();\n    this.window = cliqueTree.window();\n    // this.numClasses = factorTables[0].numClasses();\n    this.numClasses = cliqueTree.getNumClasses();\n\n    this.backgroundTag = new int[] { cliqueTree.backgroundIndex() };\n    allTags = new int[numClasses];\n    for (int i = 0; i < allTags.length; i++) {\n      allTags[i] = i;\n    }\n    if (labelDictionary != null) {\n      // Constrained\n      allowedTagsAtPosition = new int[document.size()][];\n      for (int i = 0; i < allowedTagsAtPosition.length; ++i) {\n        CoreMap token  = document.get(i);\n        String observation = token.get(CoreAnnotations.TextAnnotation.class);\n        allowedTagsAtPosition[i] = labelDictionary.isConstrained(observation) ?\n            labelDictionary.getConstrainedSet(observation) : allTags;\n      }\n    }\n  }","commit_id":"60e60c84c53aa2b364442a7ecda63c51349ffc83","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TestSequenceModel(CRFCliqueTree<String> cliqueTree,\n      LabelDictionary labelDictionary, List<? extends CoreMap> document) {\n    // this.factorTables = factorTables;\n    this.cliqueTree = cliqueTree;\n    // this.window = factorTables[0].windowSize();\n    this.window = cliqueTree.window();\n    // this.numClasses = factorTables[0].numClasses();\n    this.numClasses = cliqueTree.getNumClasses();\n\n    this.backgroundTag = new int[] { cliqueTree.backgroundIndex() };\n    allTags = new int[numClasses];\n    for (int i = 0; i < allTags.length; i++) {\n      allTags[i] = i;\n    }\n    if (labelDictionary != null) {\n      // Constrained\n      allowedTagsAtPosition = new int[document.size()][];\n      for (int i = 0; i < allowedTagsAtPosition.length; ++i) {\n        CoreMap token  = document.get(i);\n        String observation = token.get(CoreAnnotations.TextAnnotation.class);\n        if (labelDictionary.isConstrained(observation)) {\n          Set<Integer> allowedLabels = labelDictionary.getConstrainedSet(observation);\n          allowedTagsAtPosition[i] = new int[allowedLabels.size()];\n          int j = 0;\n          for (int labelIdx : allowedLabels) {\n            allowedTagsAtPosition[i][j++] = labelIdx;\n          }\n        } else {\n          allowedTagsAtPosition[i] = allTags;\n        }\n      }\n    }\n  }","id":494,"modified_method":"public TestSequenceModel(CRFCliqueTree<String> cliqueTree,\n      LabelDictionary labelDictionary, List<? extends CoreMap> document) {\n    // this.factorTables = factorTables;\n    this.cliqueTree = cliqueTree;\n    // this.window = factorTables[0].windowSize();\n    this.window = cliqueTree.window();\n    // this.numClasses = factorTables[0].numClasses();\n    this.numClasses = cliqueTree.getNumClasses();\n\n    this.backgroundTag = new int[] { cliqueTree.backgroundIndex() };\n    allTags = new int[numClasses];\n    for (int i = 0; i < allTags.length; i++) {\n      allTags[i] = i;\n    }\n    if (labelDictionary != null) {\n      // Constrained\n      allowedTagsAtPosition = new int[document.size()][];\n      for (int i = 0; i < allowedTagsAtPosition.length; ++i) {\n        CoreMap token  = document.get(i);\n        String observation = token.get(CoreAnnotations.TextAnnotation.class);\n        allowedTagsAtPosition[i] = labelDictionary.isConstrained(observation) ?\n            labelDictionary.getConstrainedSet(observation) : allTags;\n      }\n    }\n  }","commit_id":"86dde1e409b97a71fac8ed5505dc1f1cf04f3634","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Returns the Style of checkbox label\n\t *\n\t * <p>Default: \"z-chkbox\"\n\t * <p>Since 3.5.1\n\t * \n\t */\n\tpublic String getZclass() {\n\t\tString scls = super.getZclass();\n\t\tif (scls == null)\n\t\t\tscls = \"z-chkbox\";\n\t\treturn scls;\n\t}","id":495,"modified_method":"/** Returns the Style of checkbox label\n\t *\n\t * <p>Default: \"z-chkbox\"\n\t * <p>Since 3.5.1\n\t * \n\t */\n\tpublic String getZclass() {\n\t\treturn _zclass == null ? \"z-chkbox\" : super.getZclass();\n\t}","commit_id":"3ffed6afd6435d40edd7dd1c26724a5abbae7ada","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the Style of label\n\t *\n\t * <p>Default: \"z-label\"\n\t */\n\tpublic String getZclass() {\n\t\tString scls = super.getZclass();\n\t\tif (scls == null)\n\t\t\tscls = \"z-label\";\n\t\treturn scls;\n\t}","id":496,"modified_method":"/** Returns the Style of label\n\t *\n\t * <p>Default: \"z-label\"\n\t */\n\tpublic String getZclass() {\n\t\treturn _zclass == null ? \"z-label\" : super.getZclass();\n\t}","commit_id":"3ffed6afd6435d40edd7dd1c26724a5abbae7ada","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the Style of radio label\n\t *\n\t * <p>Default: \"z-radio\"\n\t * <p>Since 3.5.1\n\t * \n\t */\n\tpublic String getZclass() {\n\t\tString scls = super.getZclass();\n\t\tif (scls == null)\n\t\t\tscls = \"z-radio\";\n\t\treturn scls;\n\t}","id":497,"modified_method":"/** Returns the Style of radio label\n\t *\n\t * <p>Default: \"z-radio\"\n\t * <p>Since 3.5.1\n\t * \n\t */\n\tpublic String getZclass() {\n\t\treturn _zclass == null ? \"z-radio\" : super.getZclass();\n\t}","commit_id":"3ffed6afd6435d40edd7dd1c26724a5abbae7ada","url":"https://github.com/zkoss/zk"},{"original_method":"public String getZclass(){\t\t\t\t\n\t\tString scls = super.getZclass();\n\t\tif (scls == null)\n\t\t\tscls = \"z-tab\";\n\t\treturn scls;\n\t}","id":498,"modified_method":"public String getZclass() {\n\t\treturn _zclass == null ? \"z-tab\" : super.getZclass();\n\t}","commit_id":"3ffed6afd6435d40edd7dd1c26724a5abbae7ada","url":"https://github.com/zkoss/zk"},{"original_method":"public static AttributesTransformer getInstance() {\n\t\tif (_attributesTransformer == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_attributesTransformer =\n\t\t\t\t\t(AttributesTransformer)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.LDAP_ATTRS_TRANSFORMER_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _attributesTransformer.getClass().getName());\n\t\t}\n\n\t\treturn _attributesTransformer;\n\t}","id":499,"modified_method":"public static AttributesTransformer getInstance() {\n\t\tif (_originalAttributesTransformer == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalAttributesTransformer =\n\t\t\t\t\t(AttributesTransformer)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader, PropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_attributesTransformer == null) {\n\t\t\t_attributesTransformer = _originalAttributesTransformer;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _attributesTransformer.getClass().getName());\n\t\t}\n\n\t\treturn _attributesTransformer;\n\t}","commit_id":"14c6958c6b9aace451d2f3018de307588dc88833","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ControlPanelEntry getInstance() {\n\t\tif (_controlPanelEntry == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" +\n\t\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_controlPanelEntry = (ControlPanelEntry)classLoader.loadClass(\n\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS).\n\t\t\t\t\t\tnewInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + ClassUtil.getClassName(_controlPanelEntry));\n\t\t}\n\n\t\treturn _controlPanelEntry;\n\t}","id":500,"modified_method":"public static ControlPanelEntry getInstance() {\n\t\tif (_originalControlPanelEntry == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" +\n\t\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalControlPanelEntry =\n\t\t\t\t\t(ControlPanelEntry)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader,\n\t\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_controlPanelEntry == null) {\n\t\t\t_controlPanelEntry = _originalControlPanelEntry;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + ClassUtil.getClassName(_controlPanelEntry));\n\t\t}\n\n\t\treturn _controlPanelEntry;\n\t}","commit_id":"14c6958c6b9aace451d2f3018de307588dc88833","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_hook = (Hook)classLoader.loadClass(\n\t\t\t\t\tPropsValues.MAIL_HOOK_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","id":501,"modified_method":"public static Hook getInstance() {\n\t\tif (_originalHook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalHook = (Hook)InstanceFactory.newInstance(\n\t\t\t\t\tclassLoader, PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_hook == null) {\n\t\t\t_hook = _originalHook;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","commit_id":"14c6958c6b9aace451d2f3018de307588dc88833","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ScreenNameGenerator getInstance() {\n\t\tif (_screenNameGenerator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_screenNameGenerator =\n\t\t\t\t\t(ScreenNameGenerator)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.USERS_SCREEN_NAME_GENERATOR).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameGenerator));\n\t\t}\n\n\t\treturn _screenNameGenerator;\n\t}","id":502,"modified_method":"public static ScreenNameGenerator getInstance() {\n\t\tif (_originalScreenNameGenerator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalScreenNameGenerator =\n\t\t\t\t\t(ScreenNameGenerator)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader, PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_screenNameGenerator == null) {\n\t\t\t_screenNameGenerator = _originalScreenNameGenerator;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameGenerator));\n\t\t}\n\n\t\treturn _screenNameGenerator;\n\t}","commit_id":"14c6958c6b9aace451d2f3018de307588dc88833","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ScreenNameValidator getInstance() {\n\t\tif (_screenNameValidator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_screenNameValidator =\n\t\t\t\t\t(ScreenNameValidator)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.USERS_SCREEN_NAME_VALIDATOR).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameValidator));\n\t\t}\n\n\t\treturn _screenNameValidator;\n\t}","id":503,"modified_method":"public static ScreenNameValidator getInstance() {\n\t\tif (_originalScreenNameValidator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalScreenNameValidator =\n\t\t\t\t\t(ScreenNameValidator)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader, PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_screenNameValidator == null) {\n\t\t\t_screenNameValidator = _originalScreenNameValidator;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameValidator));\n\t\t}\n\n\t\treturn _screenNameValidator;\n\t}","commit_id":"14c6958c6b9aace451d2f3018de307588dc88833","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void fillBothIds() {\n    if (myRoleId != null && role != null) {\n      return;\n    }\n    if (myRoleId == null) {\n      SNode concept = SModelUtil.findConceptDeclaration(conceptName);\n      SConceptId cid = IdHelper.getConceptId((jetbrains.mps.smodel.SNode) concept);\n      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);\n      SNode linkNode = scope.getLinkDeclarationByRole(role);\n      myRoleId = new SContainmentLinkId(cid, IdHelper.getNodeId((jetbrains.mps.smodel.SNode) linkNode));\n    } else {\n      SAbstractConceptAdapter adapter = new SAbstractConceptAdapter(myRoleId.getConceptId());\n      conceptName = adapter.getQualifiedName();\n      SModel model = adapter.getConceptDeclarationNode().getModel();\n      role = model.getNode(new SNodeId.Regular(myRoleId.getContainmentLinkId())).getProperty(\"role\");\n    }\n  }","id":504,"modified_method":"public boolean fillBothIds() {\n    if (myRoleId != null && role != null) {\n      return true;\n    }\n    if (myRoleId == null) {\n      SNode concept = SModelUtil.findConceptDeclaration(conceptName);\n      SConceptId cid = IdHelper.getConceptId((jetbrains.mps.smodel.SNode) concept);\n      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);\n      SNode linkNode = scope.getLinkDeclarationByRole(role);\n      myRoleId = new SContainmentLinkId(cid, IdHelper.getNodeId((jetbrains.mps.smodel.SNode) linkNode));\n    } else {\n      SAbstractConceptAdapter adapter = new SAbstractConceptAdapter(myRoleId.getConceptId());\n      conceptName = adapter.getQualifiedName();\n      SNode node = adapter.getConceptDeclarationNode();\n      if (node==null) return false;\n      role = node.getModel().getNode(new SNodeId.Regular(myRoleId.getContainmentLinkId())).getProperty(\"role\");\n    }\n    return true;\n  }","commit_id":"b9fe64a126c5ff44ca5e9fdcbbde43a024b71df7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void fillBothIds() {\n    if (myRoleId != null && role != null) {\n      return;\n    }\n    if (myRoleId == null) {\n      SNode concept = SModelUtil.findConceptDeclaration(conceptName);\n      SConceptId cid = IdHelper.getConceptId((jetbrains.mps.smodel.SNode) concept);\n      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);\n      SNode linkNode = scope.getLinkDeclarationByRole(role);\n      myRoleId = new SReferenceLinkId(cid, IdHelper.getNodeId((jetbrains.mps.smodel.SNode) linkNode));\n    } else {\n      SAbstractConceptAdapter adapter = new SAbstractConceptAdapter(myRoleId.getConceptId());\n      conceptName = adapter.getQualifiedName();\n      SModel model = adapter.getConceptDeclarationNode().getModel();\n      role = model.getNode(new SNodeId.Regular(myRoleId.getReferenceLinkId())).getProperty(\"role\");\n    }\n  }","id":505,"modified_method":"public boolean fillBothIds() {\n    if (myRoleId != null && role != null) {\n      return true;\n    }\n    if (myRoleId == null) {\n      SNode concept = SModelUtil.findConceptDeclaration(conceptName);\n      SConceptId cid = IdHelper.getConceptId((jetbrains.mps.smodel.SNode) concept);\n      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);\n      SNode linkNode = scope.getLinkDeclarationByRole(role);\n      myRoleId = new SReferenceLinkId(cid, IdHelper.getNodeId((jetbrains.mps.smodel.SNode) linkNode));\n    } else {\n      SAbstractConceptAdapter adapter = new SAbstractConceptAdapter(myRoleId.getConceptId());\n      conceptName = adapter.getQualifiedName();\n      SNode node = adapter.getConceptDeclarationNode();\n      if (node==null) return false;\n      role = node.getModel().getNode(new SNodeId.Regular(myRoleId.getReferenceLinkId())).getProperty(\"role\");\n    }\n    return true;\n  }","commit_id":"b9fe64a126c5ff44ca5e9fdcbbde43a024b71df7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void fillBothIds() {\n    if (myPropertyId != null && propertyName != null) {\n      return;\n    }\n    if (myPropertyId == null) {\n      SNode concept = SModelUtil.findConceptDeclaration(conceptName);\n      SConceptId cid = IdHelper.getConceptId((jetbrains.mps.smodel.SNode) concept);\n      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);\n      SNode propNode = scope.getPropertyDeclarationByName(propertyName);\n      myPropertyId = new SPropertyId(cid, IdHelper.getNodeId((jetbrains.mps.smodel.SNode) propNode));\n    } else {\n      SAbstractConceptAdapter adapter = new SAbstractConceptAdapter(myPropertyId.getConceptId());\n      conceptName = adapter.getQualifiedName();\n      SModel model = adapter.getConceptDeclarationNode().getModel();\n      propertyName = model.getNode(new SNodeId.Regular(myPropertyId.getPropertyId())).getName();\n    }\n  }","id":506,"modified_method":"public boolean fillBothIds() {\n    if (myPropertyId != null && propertyName != null) {\n      return true;\n    }\n    if (myPropertyId == null) {\n      SNode concept = SModelUtil.findConceptDeclaration(conceptName);\n      SConceptId cid = IdHelper.getConceptId((jetbrains.mps.smodel.SNode) concept);\n      final ConceptAndSuperConceptsScope scope = new ConceptAndSuperConceptsScope(concept);\n      SNode propNode = scope.getPropertyDeclarationByName(propertyName);\n      myPropertyId = new SPropertyId(cid, IdHelper.getNodeId((jetbrains.mps.smodel.SNode) propNode));\n    } else {\n      SAbstractConceptAdapter adapter = new SAbstractConceptAdapter(myPropertyId.getConceptId());\n      conceptName = adapter.getQualifiedName();\n      SNode node = adapter.getConceptDeclarationNode();\n      if (node == null) {\n        return false;\n      }\n      propertyName = node.getModel().getNode(new SNodeId.Regular(myPropertyId.getPropertyId())).getName();\n    }\n    return true;\n  }","commit_id":"a06df1e6f0dc449e36206a8d86218f54ed02e217","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map customValues) {\n        pluginRegistry.apply(JavaPlugin.class, project, pluginRegistry, customValues);\n        GroovyPluginConvention groovyPluginConvention = new GroovyPluginConvention(project, customValues);\n        project.getConvention().getPlugins().put(\"groovy\", groovyPluginConvention);\n\n        configureCompile(project);\n\n        configureTestCompile(project);\n\n        ((Test) project.task(TEST)).getOptions().getForkOptions().setForkMode(ForkMode.ONCE);\n\n        configureJavadoc(project);\n\n        configureGroovydoc(project);\n\n        project.getDependencies().addConfiguration(new Configuration(GROOVY, Visibility.PRIVATE, null, null, false, null));\n        project.getDependencies().addConfiguration(new Configuration(JavaPlugin.COMPILE, Visibility.PRIVATE, null, WrapUtil.toArray(GROOVY), false, null));\n    }","id":507,"modified_method":"public void apply(Project project, PluginRegistry pluginRegistry, Map customValues) {\n        pluginRegistry.apply(JavaPlugin.class, project, pluginRegistry, customValues);\n        GroovyPluginConvention groovyPluginConvention = new GroovyPluginConvention(project, customValues);\n        project.getConvention().getPlugins().put(\"groovy\", groovyPluginConvention);\n\n        configureCompile(project);\n\n        configureTestCompile(project);\n\n        ((Test) project.task(TEST)).getOptions().getForkOptions().setForkMode(ForkMode.ONCE);\n\n        configureJavadoc(project);\n\n        configureGroovydoc(project);\n\n        project.getDependencies().addConfiguration(new Configuration(GROOVY, Visibility.PRIVATE, null, null, false, null));\n        project.getDependencies().configuration(JavaPlugin.COMPILE).extendsConfiguration(WrapUtil.toArray(GROOVY));\n    }","commit_id":"34a64a63773d098ed5ca9410e6080b88f2c0fff6","url":"https://github.com/gradle/gradle"},{"original_method":"public void configureDependencyManager(DependencyManager dependencyManager) {\n        dependencyManager.addConfiguration(\n                new Configuration(PROVIDED_COMPILE, Configuration.Visibility.PRIVATE, null, null, true, null));\n        dependencyManager.addConfiguration(\n                new Configuration(PROVIDED_RUNTIME, Configuration.Visibility.PRIVATE, null, new String[]{PROVIDED_COMPILE}, true, null));\n        dependencyManager.addConfiguration(new Configuration(JavaPlugin.COMPILE, Configuration.Visibility.PRIVATE, null, new String[]\n                {PROVIDED_COMPILE}, false, null));\n        dependencyManager.addConfiguration(new Configuration(JavaPlugin.RUNTIME, Configuration.Visibility.PRIVATE, null, new String[]\n                {JavaPlugin.COMPILE, PROVIDED_RUNTIME}, true, null));\n        configureMavenScopeMappings(dependencyManager.getMaven());\n    }","id":508,"modified_method":"public void configureDependencyManager(DependencyManager dependencyManager) {\n        dependencyManager.addConfiguration(\n                new Configuration(PROVIDED_COMPILE, Configuration.Visibility.PRIVATE, null, null, true, null));\n        dependencyManager.addConfiguration(\n                new Configuration(PROVIDED_RUNTIME, Configuration.Visibility.PRIVATE, null, new String[]{PROVIDED_COMPILE}, true, null));\n        dependencyManager.configuration(JavaPlugin.COMPILE).extendsConfiguration(new String[]{PROVIDED_COMPILE});\n        dependencyManager.configuration(JavaPlugin.RUNTIME).extendsConfiguration(new String[]{PROVIDED_RUNTIME});\n        configureMavenScopeMappings(dependencyManager.getMaven());\n    }","commit_id":"34a64a63773d098ed5ca9410e6080b88f2c0fff6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public boolean childNodeChanged(\n                String name, NodeState before, NodeState after) {\n            if (beforeEvent()) {\n                return addChildDiff(name, before, after);\n            } else {\n                return true;\n            }\n        }","id":509,"modified_method":"@Override\n        public boolean childNodeChanged(\n                String name, NodeState before, NodeState after) {\n            if (fullQueue()) {\n                return false;\n            } else if (beforeEvent()) {\n                addChildDiff(name, before, after);\n                return afterEvent();\n            } else {\n                return true;\n            }\n        }","commit_id":"97b2a36af5139ebe673eb86fa6218bc34365fe84","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean childNodeDeleted(String name, NodeState before) {\n            if (beforeEvent()) {\n                handler.nodeDeleted(name, before);\n                return addChildDiff(name, before, MISSING_NODE);\n            } else {\n                return true;\n            }\n        }","id":510,"modified_method":"@Override\n        public boolean childNodeDeleted(String name, NodeState before) {\n            if (fullQueue()) {\n                return false;\n            } else if (beforeEvent()) {\n                handler.nodeDeleted(name, before);\n                addChildDiff(name, before, MISSING_NODE);\n                return afterEvent();\n            } else {\n                return true;\n            }\n        }","commit_id":"97b2a36af5139ebe673eb86fa6218bc34365fe84","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n        public boolean childNodeAdded(String name, NodeState after) {\n            if (beforeEvent()) {\n                PropertyState sourceProperty = after.getProperty(SOURCE_PATH);\n                if (sourceProperty != null) {\n                    String sourcePath = sourceProperty.getValue(STRING);\n                    handler.nodeMoved(sourcePath, name, after);\n                }\n\n                handler.nodeAdded(name, after);\n                return addChildDiff(name, MISSING_NODE, after);\n            } else {\n                return true;\n            }\n        }","id":511,"modified_method":"@Override\n        public boolean childNodeAdded(String name, NodeState after) {\n            if (fullQueue()) {\n                return false;\n            } else if (beforeEvent()) {\n                PropertyState sourceProperty = after.getProperty(SOURCE_PATH);\n                if (sourceProperty != null) {\n                    String sourcePath = sourceProperty.getValue(STRING);\n                    handler.nodeMoved(sourcePath, name, after);\n                }\n\n                handler.nodeAdded(name, after);\n                addChildDiff(name, MISSING_NODE, after);\n                return afterEvent();\n            } else {\n                return true;\n            }\n        }","commit_id":"97b2a36af5139ebe673eb86fa6218bc34365fe84","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected MethodNode addClassUnderTestMethod(ClassNode classNode, ClassExpression targetClass, String type) {\n\n        String methodName = \"setup\" + type + \"UnderTest\";\n        String fieldName = GrailsNameUtils.getPropertyName(type);\n\n        if (classNode.getField(fieldName) == null) {\n            classNode.addField(fieldName, Modifier.PRIVATE, targetClass.getType(),null);\n        }\n\n        MethodNode methodNode = classNode.getMethod(methodName,GrailsArtefactClassInjector.ZERO_PARAMETERS);\n\n        if (methodNode == null) {\n            BlockStatement methodBody = new BlockStatement();\n            VariableExpression fieldExpression = new VariableExpression(fieldName);\n            addMockCollaborator(type, targetClass, methodBody);\n            BinaryExpression testTargetAssignment = new BinaryExpression(fieldExpression, ASSIGN, new ConstructorCallExpression(targetClass.getType(), GrailsArtefactClassInjector.ZERO_ARGS));\n            methodBody.addStatement(new ExpressionStatement(testTargetAssignment));\n            VariableExpression appCtxVar = new VariableExpression(\"applicationContext\");\n            BooleanExpression applicationContextCheck = new BooleanExpression(new BinaryExpression(appCtxVar, GrailsASTUtils.NOT_EQUALS_OPERATOR, GrailsASTUtils.NULL_EXPRESSION));\n            BlockStatement performAutowireBlock = new BlockStatement();\n            ArgumentListExpression arguments = new ArgumentListExpression();\n            arguments.addExpression(fieldExpression);\n            arguments.addExpression(new ConstantExpression(1));\n            arguments.addExpression(new ConstantExpression(false));\n            performAutowireBlock.addStatement(new ExpressionStatement(new MethodCallExpression(new PropertyExpression(appCtxVar,\"autowireCapableBeanFactory\"), \"autowireBeanProperties\", arguments)));\n            methodBody.addStatement(new IfStatement(applicationContextCheck, performAutowireBlock,new BlockStatement()));\n            methodNode = new MethodNode(methodName, Modifier.PUBLIC, ClassHelper.VOID_TYPE, GrailsArtefactClassInjector.ZERO_PARAMETERS,null, methodBody);\n            methodNode.addAnnotation(BEFORE_ANNOTATION);\n            methodNode.addAnnotation(MIXIN_METHOD_ANNOTATION);\n            classNode.addMethod(methodNode);\n        }\n\n        return methodNode;\n    }","id":512,"modified_method":"protected MethodNode addClassUnderTestMethod(ClassNode classNode, ClassExpression targetClass, String type) {\n\n        String methodName = \"setup\" + type + \"UnderTest\";\n        String fieldName = GrailsNameUtils.getPropertyName(type);\n        String getterName = GrailsNameUtils.getGetterName(fieldName);\n        fieldName = '$' +fieldName;\n\n        if (classNode.getField(fieldName) == null) {\n            classNode.addField(fieldName, Modifier.PRIVATE, targetClass.getType(),null);\n        }\n\n        MethodNode methodNode = classNode.getMethod(methodName,GrailsArtefactClassInjector.ZERO_PARAMETERS);\n\n        VariableExpression fieldExpression = new VariableExpression(fieldName);\n        if (methodNode == null) {\n            BlockStatement setupMethodBody = new BlockStatement();\n            addMockCollaborator(type, targetClass, setupMethodBody);\n\n\n            methodNode = new MethodNode(methodName, Modifier.PUBLIC, ClassHelper.VOID_TYPE, GrailsArtefactClassInjector.ZERO_PARAMETERS,null, setupMethodBody);\n            methodNode.addAnnotation(BEFORE_ANNOTATION);\n            methodNode.addAnnotation(MIXIN_METHOD_ANNOTATION);\n            classNode.addMethod(methodNode);\n        }\n\n        MethodNode getter = classNode.getMethod(getterName, GrailsArtefactClassInjector.ZERO_PARAMETERS);\n        if(getter == null) {\n            BlockStatement getterBody = new BlockStatement();\n            getter = new MethodNode(getterName, Modifier.PUBLIC, targetClass.getType().getPlainNodeReference(),GrailsArtefactClassInjector.ZERO_PARAMETERS,null, getterBody);\n\n            BinaryExpression testTargetAssignment = new BinaryExpression(fieldExpression, ASSIGN, new ConstructorCallExpression(targetClass.getType(), GrailsArtefactClassInjector.ZERO_ARGS));\n            getterBody.addStatement(new IfStatement(new BooleanExpression(new BinaryExpression(fieldExpression, GrailsASTUtils.EQUALS_OPERATOR, GrailsASTUtils.NULL_EXPRESSION)), new ExpressionStatement(testTargetAssignment), new BlockStatement()));\n\n            IfStatement autowiringIfStatement = getAutowiringIfStatement(fieldExpression);\n            getterBody.addStatement(autowiringIfStatement);\n\n            getterBody.addStatement(new ReturnStatement(fieldExpression));\n            classNode.addMethod(getter);\n        }\n\n        return methodNode;\n    }","commit_id":"b6adf4fc4d0bba2ff99ef355d1bf56a3bc56a701","url":"https://github.com/grails/grails-core"},{"original_method":"protected MethodNode addClassUnderTestMethod(ClassNode classNode, ClassExpression targetClass, String type) {\n\n        String methodName = \"setup\" + type + \"UnderTest\";\n        String fieldName = GrailsNameUtils.getPropertyName(type);\n\n        if (classNode.getField(fieldName) == null) {\n            classNode.addField(fieldName, Modifier.PRIVATE, targetClass.getType(),null);\n        }\n\n        MethodNode methodNode = classNode.getMethod(methodName,GrailsArtefactClassInjector.ZERO_PARAMETERS);\n\n        if (methodNode == null) {\n            BlockStatement methodBody = new BlockStatement();\n            VariableExpression fieldExpression = new VariableExpression(fieldName);\n            addMockCollaborator(type, targetClass, methodBody);\n            BinaryExpression testTargetAssignment = new BinaryExpression(fieldExpression, ASSIGN, new ConstructorCallExpression(targetClass.getType(), GrailsArtefactClassInjector.ZERO_ARGS));\n            methodBody.addStatement(new ExpressionStatement(testTargetAssignment));\n            VariableExpression appCtxVar = new VariableExpression(\"applicationContext\");\n            BooleanExpression applicationContextCheck = new BooleanExpression(new BinaryExpression(appCtxVar, GrailsASTUtils.NOT_EQUALS_OPERATOR, GrailsASTUtils.NULL_EXPRESSION));\n            BlockStatement performAutowireBlock = new BlockStatement();\n            ArgumentListExpression arguments = new ArgumentListExpression();\n            arguments.addExpression(fieldExpression);\n            arguments.addExpression(new ConstantExpression(1));\n            arguments.addExpression(new ConstantExpression(false));\n            performAutowireBlock.addStatement(new ExpressionStatement(new MethodCallExpression(new PropertyExpression(appCtxVar,\"autowireCapableBeanFactory\"), \"autowireBeanProperties\", arguments)));\n            methodBody.addStatement(new IfStatement(applicationContextCheck, performAutowireBlock,new BlockStatement()));\n            methodNode = new MethodNode(methodName, Modifier.PUBLIC, ClassHelper.VOID_TYPE, GrailsArtefactClassInjector.ZERO_PARAMETERS,null, methodBody);\n            methodNode.addAnnotation(BEFORE_ANNOTATION);\n            methodNode.addAnnotation(MIXIN_METHOD_ANNOTATION);\n            classNode.addMethod(methodNode);\n        }\n\n        return methodNode;\n    }","id":513,"modified_method":"protected MethodNode addClassUnderTestMethod(ClassNode classNode, ClassExpression targetClass, String type) {\n\n        String methodName = \"setup\" + type + \"UnderTest\";\n        String fieldName = GrailsNameUtils.getPropertyName(type);\n        String getterName = GrailsNameUtils.getGetterName(fieldName);\n        fieldName = '$' +fieldName;\n\n        if (classNode.getField(fieldName) == null) {\n            classNode.addField(fieldName, Modifier.PRIVATE, targetClass.getType(),null);\n        }\n\n        MethodNode methodNode = classNode.getMethod(methodName,GrailsArtefactClassInjector.ZERO_PARAMETERS);\n\n        VariableExpression fieldExpression = new VariableExpression(fieldName);\n        if (methodNode == null) {\n            BlockStatement setupMethodBody = new BlockStatement();\n            addMockCollaborator(type, targetClass, setupMethodBody);\n\n\n            methodNode = new MethodNode(methodName, Modifier.PUBLIC, ClassHelper.VOID_TYPE, GrailsArtefactClassInjector.ZERO_PARAMETERS,null, setupMethodBody);\n            methodNode.addAnnotation(BEFORE_ANNOTATION);\n            methodNode.addAnnotation(MIXIN_METHOD_ANNOTATION);\n            classNode.addMethod(methodNode);\n        }\n\n        MethodNode getter = classNode.getMethod(getterName, GrailsArtefactClassInjector.ZERO_PARAMETERS);\n        if(getter == null) {\n            BlockStatement getterBody = new BlockStatement();\n            getter = new MethodNode(getterName, Modifier.PUBLIC, targetClass.getType().getPlainNodeReference(),GrailsArtefactClassInjector.ZERO_PARAMETERS,null, getterBody);\n\n            BinaryExpression testTargetAssignment = new BinaryExpression(fieldExpression, ASSIGN, new ConstructorCallExpression(targetClass.getType(), GrailsArtefactClassInjector.ZERO_ARGS));\n            getterBody.addStatement(new IfStatement(new BooleanExpression(new BinaryExpression(fieldExpression, GrailsASTUtils.EQUALS_OPERATOR, GrailsASTUtils.NULL_EXPRESSION)), new ExpressionStatement(testTargetAssignment), new BlockStatement()));\n\n            IfStatement autowiringIfStatement = getAutowiringIfStatement(fieldExpression);\n            getterBody.addStatement(autowiringIfStatement);\n\n            getterBody.addStatement(new ReturnStatement(fieldExpression));\n            classNode.addMethod(getter);\n        }\n\n        return methodNode;\n    }","commit_id":"48443bc77d2946ce988137981bcad2d006e94e0f","url":"https://github.com/grails/grails-core"},{"original_method":"public void launchSpoon(JobEntryTrans entry)\n\t{\n\t\t// Load from repository?\n\t\tif ( (entry.getFileName()==null || entry.getFileName().length()==0) &&\n\t\t     (entry.getTransname()!=null && entry.getTransname().length()>0)\n\t\t   )\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSpoon sp = new Spoon(log, chef.disp, chef.rep);\n\t\t\t\t// New transformation?\n\t\t\t\t//\n\t\t\t\tlong id = sp.rep.getTransformationID(entry.getTransname(), entry.getDirectory().getID());\n\t\t\t\tif (id<0) // New\n\t\t\t\t{\n\t\t\t\t\tsp.setTransMeta( new TransMeta(null, entry.getTransname(), entry.arguments) );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsp.setTransMeta( new TransMeta(sp.rep, entry.getTransname(), entry.getDirectory()) );\n\t\t\t\t}\n\t\t\t\tsp.getTransMeta().clearChanged();\n\t\t\t\tsp.open();\n\t\t\t}\n\t\t\tcatch(Throwable ke)\n\t\t\t{\n\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\t\tmb.setMessage(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformation.Message\")+Const.CR+ke.getMessage()); //$NON-NLS-1$\n\t\t\t\tmb.setText(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformation.Title\")); //$NON-NLS-1$\n\t\t\t\tmb.open();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Read from file...\n\t\t\t\tSpoon sp = new Spoon(log, chef.disp, null);\n\t\t\t\tsp.setTransMeta( new TransMeta(entry.getFileName()) );\n\t\t\t\tsp.getTransMeta().clearChanged();\n\t\t\t\tsp.setFilename(entry.getFileName());\n\t\t\t\tsp.open();\n\t\t\t}\n\t\t\tcatch(Throwable xe)\n\t\t\t{\n\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\t\tmb.setMessage(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformationFromXML.Message\")+Const.CR+xe.getMessage()); //$NON-NLS-1$\n\t\t\t\tmb.setText(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformationFromXML.Title\")); //$NON-NLS-1$\n\t\t\t\tmb.open();\n\t\t\t}\n\n\t\t}\n\t}","id":514,"modified_method":"public void launchSpoon(JobEntryTrans entry)\n\t{\n\t\t// Load from repository?\n\t\tif ( Const.isEmpty(entry.getFileName()) && !Const.isEmpty(entry.getTransname()) )\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSpoon sp = new Spoon(log, chef.disp, chef.rep);\n\t\t\t\t// New transformation?\n\t\t\t\t//\n\t\t\t\tlong id = sp.rep.getTransformationID(StringUtil.environmentSubstitute(entry.getTransname()), entry.getDirectory().getID());\n\t\t\t\tif (id<0) // New\n\t\t\t\t{\n\t\t\t\t\tsp.setTransMeta( new TransMeta(null, StringUtil.environmentSubstitute(entry.getTransname()), entry.arguments) );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsp.setTransMeta( new TransMeta(sp.rep, StringUtil.environmentSubstitute(entry.getTransname()), entry.getDirectory()) );\n\t\t\t\t}\n\t\t\t\tsp.getTransMeta().clearChanged();\n\t\t\t\tsp.open();\n\t\t\t}\n\t\t\tcatch(Throwable ke)\n\t\t\t{\n\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\t\tmb.setMessage(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformation.Message\")+Const.CR+ke.getMessage()); //$NON-NLS-1$\n\t\t\t\tmb.setText(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformation.Title\")); //$NON-NLS-1$\n\t\t\t\tmb.open();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Read from file...\n\t\t\t\tSpoon sp = new Spoon(log, chef.disp, null);\n\t\t\t\tsp.setTransMeta( new TransMeta( StringUtil.environmentSubstitute(entry.getFileName() )) );\n\t\t\t\tsp.getTransMeta().clearChanged();\n\t\t\t\tsp.setFilename(entry.getFileName());\n\t\t\t\tsp.open();\n\t\t\t}\n\t\t\tcatch(Throwable xe)\n\t\t\t{\n\t\t\t\tMessageBox mb = new MessageBox(shell, SWT.OK | SWT.ICON_ERROR );\n\t\t\t\tmb.setMessage(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformationFromXML.Message\")+Const.CR+xe.getMessage()); //$NON-NLS-1$\n\t\t\t\tmb.setText(Messages.getString(\"ChefGraph.Dialog.ErrorLaunchingSpoonCanNotLoadTransformationFromXML.Title\")); //$NON-NLS-1$\n\t\t\t\tmb.open();\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"87eead458b90a7a063b13e77bcfa0d479ce9719e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private TransMeta getTransMeta(Repository rep) throws KettleException\n    {\n        TransMeta transMeta = null;\n        if (getTransname() != null && getTransname().length() > 0 && // Load from the repository\n                getDirectory() != null)\n        {\n            transMeta = new TransMeta(rep, getTransname(), getDirectory());\n        }\n        else\n            if (getFileName() != null && getFileName().length() > 0) // Load from an XML file\n            {\n\n                transMeta = new TransMeta(getFileName());\n            }\n            else\n            {\n                throw new KettleJobException(\"The transformation to execute is not specified!\");\n            }\n\n        // Set the arguments...\n        transMeta.setArguments(arguments);\n\n        return transMeta;\n    }","id":515,"modified_method":"private TransMeta getTransMeta(Repository rep) throws KettleException\n    {\n        TransMeta transMeta = null;\n        if (!Const.isEmpty(getTransname()) && // Load from the repository\n                getDirectory() != null)\n        {\n            transMeta = new TransMeta(rep, StringUtil.environmentSubstitute(getTransname()), getDirectory());\n        }\n        else\n            if (getFileName() != null && getFileName().length() > 0) // Load from an XML file\n            {\n\n                transMeta = new TransMeta(StringUtil.environmentSubstitute(getFileName()));\n            }\n            else\n            {\n                throw new KettleJobException(\"The transformation to execute is not specified!\");\n            }\n\n        // Set the arguments...\n        transMeta.setArguments(arguments);\n\n        return transMeta;\n    }","commit_id":"40468d5f19d2ee0c0d013620d1c9deeb6f0834ff","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public MBThread moveThread(long groupId, long categoryId, long threadId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tthreadId);\n\n\t\tlong oldCategoryId = thread.getCategoryId();\n\n\t\tMBCategory oldCategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\toldCategoryId);\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\n\t\t// Messages\n\n\t\tList<MBMessage> messages = mbMessagePersistence.findByG_C_T(\n\t\t\tgroupId, oldCategoryId, thread.getThreadId());\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tmessage.setCategoryId(category.getCategoryId());\n\n\t\t\tmbMessagePersistence.update(message, false);\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tMBMessage.class);\n\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tthread.setCategoryId(category.getCategoryId());\n\n\t\tmbThreadPersistence.update(thread, false);\n\n\t\t// Category\n\n\t\toldCategory.setThreadCount(oldCategory.getThreadCount() - 1);\n\t\toldCategory.setMessageCount(\n\t\t\toldCategory.getMessageCount() - messages.size());\n\n\t\tmbCategoryPersistence.update(oldCategory, false);\n\n\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\t\tcategory.setMessageCount(category.getMessageCount() + messages.size());\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\treturn thread;\n\t}","id":516,"modified_method":"public MBThread moveThread(long groupId, long categoryId, long threadId)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tthreadId);\n\n\t\tlong oldCategoryId = thread.getCategoryId();\n\n\t\tMBCategory oldCategory = null;\n\n\t\tif (oldCategoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\t\t\toldCategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\toldCategoryId);\n\t\t}\n\n\t\tMBCategory category = null;\n\n\t\tif (categoryId != MBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tcategoryId);\n\t\t}\n\n\t\t// Messages\n\n\t\tList<MBMessage> messages = mbMessagePersistence.findByG_C_T(\n\t\t\tgroupId, oldCategoryId, thread.getThreadId());\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tmessage.setCategoryId(categoryId);\n\n\t\t\tmbMessagePersistence.update(message, false);\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tMBMessage.class);\n\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tthread.setCategoryId(categoryId);\n\n\t\tmbThreadPersistence.update(thread, false);\n\n\t\t// Category\n\n\t\tif (oldCategory != null) {\n\t\t\toldCategory.setThreadCount(oldCategory.getThreadCount() - 1);\n\t\t\toldCategory.setMessageCount(\n\t\t\t\toldCategory.getMessageCount() - messages.size());\n\n\t\t\tmbCategoryPersistence.update(oldCategory, false);\n\t\t}\n\n\t\tif (category != null) {\n\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\t\t\tcategory.setMessageCount(\n\t\t\t\tcategory.getMessageCount() + messages.size());\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\treturn thread;\n\t}","commit_id":"418dc3d913ec1a1c0443ab6f594696ddbe9b8796","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected BackgroundTask addBackgroundTask(\n\t\t\tlong userId, long groupId, String name,\n\t\t\tString[] servletContextNames, String taskExecutorClassName,\n\t\t\tMap<String, Serializable> taskContextMap,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tfinal long backgroundTaskId = counterLocalService.increment();\n\n\t\tBackgroundTask backgroundTask = backgroundTaskPersistence.create(\n\t\t\tbackgroundTaskId);\n\n\t\tbackgroundTask.setCompanyId(user.getCompanyId());\n\t\tbackgroundTask.setGroupId(groupId);\n\t\tbackgroundTask.setUserId(userId);\n\t\tbackgroundTask.setUserName(user.getFullName());\n\t\tbackgroundTask.setName(name);\n\n\t\tif (ArrayUtil.isNotEmpty(servletContextNames)) {\n\t\t\tbackgroundTask.setServletContextNames(\n\t\t\t\tStringUtil.merge(servletContextNames));\n\t\t}\n\n\t\tbackgroundTask.setTaskExecutorClassName(taskExecutorClassName);\n\n\t\tif (taskContextMap == null) {\n\t\t\ttaskContextMap = new HashMap<>();\n\t\t}\n\n\t\t_backgroundTaskThreadLocalManager.serializeThreadLocals(taskContextMap);\n\n\t\tbackgroundTask.setTaskContextMap(taskContextMap);\n\n\t\tbackgroundTask.setStatus(BackgroundTaskConstants.STATUS_NEW);\n\n\t\tbackgroundTaskPersistence.update(backgroundTask);\n\n\t\tTransactionCommitCallbackUtil.registerCallback(\n\t\t\tnew Callable<Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\tbackgroundTaskLocalService.triggerBackgroundTask(\n\t\t\t\t\t\tbackgroundTaskId);\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\treturn backgroundTask;\n\t}","id":517,"modified_method":"protected BackgroundTask addBackgroundTask(\n\t\t\tlong userId, long groupId, String name,\n\t\t\tString[] servletContextNames, String taskExecutorClassName,\n\t\t\tMap<String, Serializable> taskContextMap,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tUser user = null;\n\n\t\tif (userId != UserConstants.USER_ID_DEFAULT) {\n\t\t\tuser = userPersistence.findByPrimaryKey(userId);\n\t\t}\n\n\t\tfinal long backgroundTaskId = counterLocalService.increment();\n\n\t\tBackgroundTask backgroundTask = backgroundTaskPersistence.create(\n\t\t\tbackgroundTaskId);\n\n\t\tif (user != null) {\n\t\t\tbackgroundTask.setCompanyId(user.getCompanyId());\n\t\t\tbackgroundTask.setUserName(user.getFullName());\n\t\t}\n\t\telse {\n\t\t\tbackgroundTask.setCompanyId(CompanyConstants.SYSTEM);\n\t\t\tbackgroundTask.setUserName(StringPool.BLANK);\n\t\t}\n\n\t\tbackgroundTask.setGroupId(groupId);\n\t\tbackgroundTask.setUserId(userId);\n\n\t\tbackgroundTask.setName(name);\n\n\t\tif (ArrayUtil.isNotEmpty(servletContextNames)) {\n\t\t\tbackgroundTask.setServletContextNames(\n\t\t\t\tStringUtil.merge(servletContextNames));\n\t\t}\n\n\t\tbackgroundTask.setTaskExecutorClassName(taskExecutorClassName);\n\n\t\tif (taskContextMap == null) {\n\t\t\ttaskContextMap = new HashMap<>();\n\t\t}\n\n\t\t_backgroundTaskThreadLocalManager.serializeThreadLocals(taskContextMap);\n\n\t\tbackgroundTask.setTaskContextMap(taskContextMap);\n\n\t\tbackgroundTask.setStatus(BackgroundTaskConstants.STATUS_NEW);\n\n\t\tbackgroundTaskPersistence.update(backgroundTask);\n\n\t\tTransactionCommitCallbackUtil.registerCallback(\n\t\t\tnew Callable<Void>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\tbackgroundTaskLocalService.triggerBackgroundTask(\n\t\t\t\t\t\tbackgroundTaskId);\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t});\n\n\t\treturn backgroundTask;\n\t}","commit_id":"b62653c12cd21c2b33d1a59f70452aa6fcd7f87e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String timestampFormat() {\n\t\treturn ERXProperties.stringForKeyWithDefault(\"er.rest.timestampFormat\", \"%Y-%m-%dT%H:%M:%SZ\");\n\t}","id":518,"modified_method":"protected static String timestampFormat(boolean spaces) {\n\t\tString dateFormat = ERXProperties.stringForKey(\"er.rest.timestampFormat\");\n\t\tif (dateFormat == null) {\n\t\t\tif (spaces) {\n\t\t\t\tdateFormat = ERXProperties.stringForKeyWithDefault(\"er.rest.timestampFormat.secondary\", \"%Y-%m-%d %H:%M:%S %Z\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdateFormat = ERXProperties.stringForKeyWithDefault(\"er.rest.timestampFormat.primary\", \"%Y-%m-%dT%H:%M:%SZ\");\n\t\t\t}\n\t\t}\n\t\treturn dateFormat;\n\t}","commit_id":"56bd717d1cfa971cfbf6382c9328c6bdd1907484","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected static String dateFormat(boolean spaces) {\n\t\tif (spaces) {\n\t\t\treturn ERXProperties.stringForKeyWithDefault(\"er.rest.dateFormat\", \"YYYY-MM-dd HH:mm:ss z\");\n\t\t}\n\t\telse {\n\t\t\treturn ERXProperties.stringForKeyWithDefault(\"er.rest.dateFormat\", \"YYYY-MM-dd\\\\THH:mm:ss\\\\Z\");\n\t\t}\n\t}","id":519,"modified_method":"protected static String dateFormat(boolean spaces) {\n\t\tString timestampFormat = ERXProperties.stringForKey(\"er.rest.dateFormat\");\n\t\tif (timestampFormat == null) {\n\t\t\tif (spaces) {\n\t\t\t\ttimestampFormat = ERXProperties.stringForKeyWithDefault(\"er.rest.dateFormat.secondary\", \"YYYY-MM-dd HH:mm:ss z\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttimestampFormat = ERXProperties.stringForKeyWithDefault(\"er.rest.dateFormat.primary\", \"YYYY-MM-dd\\\\THH:mm:ss\\\\Z\");\n\t\t\t}\n\t\t}\n\t\treturn timestampFormat;\n\t}","commit_id":"56bd717d1cfa971cfbf6382c9328c6bdd1907484","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void calculateActions(Game game) {\n\t\tcurrentScore = GameStateEvaluator.evaluate(playerId, game);\n\t\tif (!getNextAction(game)) {\n\t\t\tGame sim = createSimulation(game);\n\t\t\tSimulationNode.resetCount();\n\t\t\troot = new SimulationNode(null, sim, playerId);\n\t\t\tlogger.debug(\"simulating actions\");\n\t\t\taddActionsTimed(new FilterAbility());\n\t\t\tif (root.children.size() > 0) {\n\t\t\t\troot = root.children.get(0);\n\t\t\t\tactions = new LinkedList<Ability>(root.abilities);\n\t\t\t\tcombat = root.combat;\n\t\t\t\tif (logger.isDebugEnabled())\n\t\t\t\t\tlogger.debug(\"adding actions:\" + actions);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlogger.debug(\"no actions added\");\n\t\t}\n\t}","id":520,"modified_method":"protected void calculateActions(Game game) {\n\t\tcurrentScore = GameStateEvaluator.evaluate(playerId, game);\n\t\tif (!getNextAction(game)) {\n\t\t\tGame sim = createSimulation(game);\n\t\t\tSimulationNode.resetCount();\n\t\t\troot = new SimulationNode(null, sim, playerId);\n\t\t\tlogger.debug(\"simulating actions\");\n\t\t\tif (!isTestMode)\n\t\t\t\taddActionsTimed(new FilterAbility());\n\t\t\telse\n\t\t\t\taddActions(root, new FilterAbility(), Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t\t\tif (root.children.size() > 0) {\n\t\t\t\troot = root.children.get(0);\n\t\t\t\tactions = new LinkedList<Ability>(root.abilities);\n\t\t\t\tcombat = root.combat;\n\t\t\t\tif (logger.isDebugEnabled())\n\t\t\t\t\tlogger.debug(\"adding actions:\" + actions);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlogger.debug(\"no actions added\");\n\t\t}\n\t}","commit_id":"0668548f4fbca4bd91a663af7a1cd82b495174aa","url":"https://github.com/magefree/mage"},{"original_method":"protected void calculatePostCombatActions(Game game) {\n\t\tif (!getNextAction(game)) {\n\t\t\tcurrentScore = GameStateEvaluator.evaluate(playerId, game);\n\t\t\tGame sim = createSimulation(game);\n\t\t\tSimulationNode.resetCount();\n\t\t\troot = new SimulationNode(null, sim, playerId);\n\t\t\tlogger.debug(\"simulating post combat actions ----------------------------------------------------------------------------------------\");\n\t\t\taddActionsTimed(new FilterAbility());\n//\t\t\taddActions(root, new FilterAbility(), maxDepth, Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t\t\tif (root.children.size() > 0) {\n\t\t\t\troot = root.children.get(0);\n\t\t\t\tactions = new LinkedList<Ability>(root.abilities);\n\t\t\t\tcombat = root.combat;\n\t\t\t\tif (logger.isDebugEnabled())\n\t\t\t\t\tlogger.debug(\"adding post-combat actions:\" + actions);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlogger.debug(\"no post-combat actions added\");\n\t\t}\n\t}","id":521,"modified_method":"protected void calculatePostCombatActions(Game game) {\n\t\tif (!getNextAction(game)) {\n\t\t\tcurrentScore = GameStateEvaluator.evaluate(playerId, game);\n\t\t\tGame sim = createSimulation(game);\n\t\t\tSimulationNode.resetCount();\n\t\t\troot = new SimulationNode(null, sim, playerId);\n\t\t\tlogger.debug(\"simulating post combat actions ----------------------------------------------------------------------------------------\");\n\t\t\tif (!isTestMode)\n\t\t\t\taddActionsTimed(new FilterAbility());\n\t\t\telse\n\t\t\t\taddActions(root, new FilterAbility(), Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t\t\tif (root.children.size() > 0) {\n\t\t\t\troot = root.children.get(0);\n\t\t\t\tactions = new LinkedList<Ability>(root.abilities);\n\t\t\t\tcombat = root.combat;\n\t\t\t\tif (logger.isDebugEnabled())\n\t\t\t\t\tlogger.debug(\"adding post-combat actions:\" + actions);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlogger.debug(\"no post-combat actions added\");\n\t\t}\n\t}","commit_id":"0668548f4fbca4bd91a663af7a1cd82b495174aa","url":"https://github.com/magefree/mage"},{"original_method":"protected void calculatePreCombatActions(Game game) {\n\t\tif (!getNextAction(game)) {\n\t\t\tcurrentScore = GameStateEvaluator.evaluate(playerId, game);\n\t\t\tGame sim = createSimulation(game);\n\t\t\tSimulationNode.resetCount();\n\t\t\troot = new SimulationNode(null, sim, playerId);\n\t\t\tlogger.debug(\"simulating pre combat actions -----------------------------------------------------------------------------------------\");\n\n\t\t\taddActionsTimed(new FilterAbility());\n//\t\t\taddActions(root, new FilterAbility(), maxDepth, Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t\t\tif (root.children.size() > 0) {\n\t\t\t\troot = root.children.get(0);\n\t\t\t\tactions = new LinkedList<Ability>(root.abilities);\n\t\t\t\tcombat = root.combat;\n\t\t\t\tif (logger.isDebugEnabled())\n\t\t\t\t\tlogger.debug(\"adding pre-combat actions:\" + actions);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlogger.debug(\"no pre-combat actions added\");\n\t\t}\n\t}","id":522,"modified_method":"protected void calculatePreCombatActions(Game game) {\n\t\tif (!getNextAction(game)) {\n\t\t\tcurrentScore = GameStateEvaluator.evaluate(playerId, game);\n\t\t\tGame sim = createSimulation(game);\n\t\t\tSimulationNode.resetCount();\n\t\t\troot = new SimulationNode(null, sim, playerId);\n\t\t\tlogger.debug(\"simulating pre combat actions -----------------------------------------------------------------------------------------\");\n\n\t\t\tif (!isTestMode)\n\t\t\t\taddActionsTimed(new FilterAbility());\n\t\t\telse\n\t\t\t\taddActions(root, new FilterAbility(), Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t\t\tif (root.children.size() > 0) {\n\t\t\t\troot = root.children.get(0);\n\t\t\t\tactions = new LinkedList<Ability>(root.abilities);\n\t\t\t\tcombat = root.combat;\n\t\t\t\tif (logger.isDebugEnabled())\n\t\t\t\t\tlogger.debug(\"adding pre-combat actions:\" + actions);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlogger.debug(\"no pre-combat actions added\");\n\t\t}\n\t}","commit_id":"0668548f4fbca4bd91a663af7a1cd82b495174aa","url":"https://github.com/magefree/mage"},{"original_method":"static void buildTransformation(ModelVersion version, ResourceTransformationDescriptionBuilder parent) {\n        ResourceTransformationDescriptionBuilder builder = InfinispanModel.VERSION_4_0_0.requiresTransformation(version) ? parent.addChildResource(PATH) : parent.addChildRedirection(PATH, LEGACY_PATH);\n\n        JDBCStoreResourceDefinition.buildTransformation(version, builder);\n\n        BinaryTableResourceDefinition.buildTransformation(version, builder);\n    }","id":523,"modified_method":"static void buildTransformation(ModelVersion version, ResourceTransformationDescriptionBuilder parent) {\n        ResourceTransformationDescriptionBuilder builder = InfinispanModel.VERSION_4_0_0.requiresTransformation(version) ? parent.addChildRedirection(PATH, LEGACY_PATH) : parent.addChildResource(PATH);\n\n        if (InfinispanModel.VERSION_4_0_0.requiresTransformation(version)) {\n            builder.setCustomResourceTransformer(new ResourceTransformer() {\n                @Override\n                public void transformResource(ResourceTransformationContext context, PathAddress address, Resource resource) throws OperationFailedException {\n                    final ModelNode model = resource.getModel();\n\n                    final ModelNode binaryTableModel = Resource.Tools.readModel(resource.removeChild(BinaryTableResourceDefinition.PATH));\n                    if (binaryTableModel != null && binaryTableModel.isDefined()) {\n                        model.get(DeprecatedAttribute.TABLE.getDefinition().getName()).set(binaryTableModel);\n                    }\n\n                    context.addTransformedResource(PathAddress.EMPTY_ADDRESS, resource);\n                    context.processChildren(resource);\n                }\n            });\n        }\n\n        BinaryTableResourceDefinition.buildTransformation(version, builder);\n\n        JDBCStoreResourceDefinition.buildTransformation(version, builder);\n    }","commit_id":"0cac67f44beea3e24cee230870d1d75082fbf4df","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void buildTransformation(ModelVersion version, ResourceTransformationDescriptionBuilder parent) {\n        ResourceTransformationDescriptionBuilder builder = InfinispanModel.VERSION_4_0_0.requiresTransformation(version) ? parent.addChildRedirection(PATH, LEGACY_PATH) : parent.addChildResource(PATH);\n\n        JDBCStoreResourceDefinition.buildTransformation(version, builder);\n\n        BinaryTableResourceDefinition.buildTransformation(version, builder);\n        StringTableResourceDefinition.buildTransformation(version, builder);\n    }","id":524,"modified_method":"@SuppressWarnings(\"deprecation\")\n    static void buildTransformation(ModelVersion version, ResourceTransformationDescriptionBuilder parent) {\n        ResourceTransformationDescriptionBuilder builder = InfinispanModel.VERSION_4_0_0.requiresTransformation(version) ? parent.addChildRedirection(PATH, LEGACY_PATH) : parent.addChildResource(PATH);\n\n        if (InfinispanModel.VERSION_4_0_0.requiresTransformation(version)) {\n            builder.setCustomResourceTransformer(new ResourceTransformer() {\n                @Override\n                public void transformResource(ResourceTransformationContext context, PathAddress address, Resource resource) throws OperationFailedException {\n                    final ModelNode model = resource.getModel();\n\n                    final ModelNode binaryTableModel = Resource.Tools.readModel(resource.removeChild(BinaryTableResourceDefinition.PATH));\n                    if (binaryTableModel != null && binaryTableModel.isDefined()) {\n                        model.get(DeprecatedAttribute.BINARY_TABLE.getDefinition().getName()).set(binaryTableModel);\n                    }\n\n                    final ModelNode stringTableModel = Resource.Tools.readModel(resource.removeChild(StringTableResourceDefinition.PATH));\n                    if (stringTableModel != null && stringTableModel.isDefined()) {\n                        model.get(DeprecatedAttribute.STRING_TABLE.getDefinition().getName()).set(stringTableModel);\n                    }\n\n                    context.addTransformedResource(PathAddress.EMPTY_ADDRESS, resource);\n                    context.processChildren(resource);\n                }\n            });\n        }\n\n        BinaryTableResourceDefinition.buildTransformation(version, builder);\n        StringTableResourceDefinition.buildTransformation(version, builder);\n\n        JDBCStoreResourceDefinition.buildTransformation(version, builder);\n    }","commit_id":"0cac67f44beea3e24cee230870d1d75082fbf4df","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void buildTransformation(ModelVersion version, ResourceTransformationDescriptionBuilder parent) {\n        ResourceTransformationDescriptionBuilder builder = parent.addChildResource(PATH);\n\n        JDBCStoreResourceDefinition.buildTransformation(version, builder);\n\n        StringTableResourceDefinition.buildTransformation(version, builder);\n    }","id":525,"modified_method":"static void buildTransformation(ModelVersion version, ResourceTransformationDescriptionBuilder parent) {\n        ResourceTransformationDescriptionBuilder builder = InfinispanModel.VERSION_4_0_0.requiresTransformation(version) ? parent.addChildRedirection(PATH, LEGACY_PATH) : parent.addChildResource(PATH);\n\n        if (InfinispanModel.VERSION_4_0_0.requiresTransformation(version)) {\n            builder.setCustomResourceTransformer(new ResourceTransformer() {\n                @Override\n                public void transformResource(ResourceTransformationContext context, PathAddress address, Resource resource) throws OperationFailedException {\n                    final ModelNode model = resource.getModel();\n\n                    final ModelNode stringTableModel = Resource.Tools.readModel(resource.removeChild(StringTableResourceDefinition.PATH));\n                    if (stringTableModel != null && stringTableModel.isDefined()) {\n                        model.get(DeprecatedAttribute.TABLE.getDefinition().getName()).set(stringTableModel);\n                    }\n\n                    context.addTransformedResource(PathAddress.EMPTY_ADDRESS, resource);\n                    context.processChildren(resource);\n                }\n            });\n        }\n\n        StringTableResourceDefinition.buildTransformation(version, builder);\n\n        JDBCStoreResourceDefinition.buildTransformation(version, builder);\n    }","commit_id":"0cac67f44beea3e24cee230870d1d75082fbf4df","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static boolean isDocTestFunction(PyFunction pyFunction) {\n    if (pyFunction.getDocStringExpression() == null) return false;\n    PythonDocStringParser parser = new PythonDocStringParser(pyFunction.getDocStringExpression().getStringValue());\n    if (!parser.hasExample()) return false;\n    return true;\n  }","id":526,"modified_method":"public static boolean isDocTestFunction(PyFunction pyFunction) {\n    if (pyFunction.getDocStringExpression() == null) return false;\n    PyStringLiteralExpression docString = pyFunction.getDocStringExpression();\n    if (docString != null && !hasExample(docString.getStringValue())) return false;\n    return true;\n  }","commit_id":"70b860a8a3031a020bafb38bf0e5383ed1ec6c94","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isDocTestClass(PyClass pyClass) {\n    List<PyStatement> result = Lists.newArrayList();\n    for (PyFunction cls : pyClass.getMethods()) {\n      if (isDocTestFunction(cls)) {\n        result.add(cls);\n      }\n    }\n    if (pyClass.getDocStringExpression() != null) {\n      PythonDocStringParser parser = new PythonDocStringParser(pyClass.getDocStringExpression().getStringValue());\n      if (parser.hasExample()) {\n        result.add(pyClass);\n      }\n    }\n    if (result.isEmpty()) return false;\n    return true; \n  }","id":527,"modified_method":"public static boolean isDocTestClass(PyClass pyClass) {\n    List<PyStatement> result = Lists.newArrayList();\n    for (PyFunction cls : pyClass.getMethods()) {\n      if (isDocTestFunction(cls)) {\n        result.add(cls);\n      }\n    }\n    if (pyClass.getDocStringExpression() != null) {\n      PyStringLiteralExpression docString = pyClass.getDocStringExpression();\n      if (docString != null && hasExample(docString.getStringValue())) {\n        result.add(pyClass);\n      }\n    }\n    if (result.isEmpty()) return false;\n    return true; \n  }","commit_id":"70b860a8a3031a020bafb38bf0e5383ed1ec6c94","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<PyElement> getDocTestCasesFromFile(PyFile file) {\n    List<PyElement> result = Lists.newArrayList();\n    for (PyClass cls : file.getTopLevelClasses()) {\n      if (isDocTestClass(cls)) {\n        result.add(cls);\n      }\n    }\n    for (PyFunction cls : file.getTopLevelFunctions()) {\n      if (isDocTestFunction(cls)) {\n        result.add(cls);\n      }\n    }\n    if (file.getDocStringExpression() != null) {\n      PythonDocStringParser parser = new PythonDocStringParser(file.getDocStringExpression().getStringValue());\n      if (!parser.hasExample()) {\n        result.add(file);\n      }\n    }\n    return result;\n  }","id":528,"modified_method":"public static List<PyElement> getDocTestCasesFromFile(PyFile file) {\n    List<PyElement> result = Lists.newArrayList();\n    for (PyClass cls : file.getTopLevelClasses()) {\n      if (isDocTestClass(cls)) {\n        result.add(cls);\n      }\n    }\n    for (PyFunction cls : file.getTopLevelFunctions()) {\n      if (isDocTestFunction(cls)) {\n        result.add(cls);\n      }\n    }\n    if (file.getDocStringExpression() != null) {\n      PyStringLiteralExpression docString = file.getDocStringExpression();\n      if (docString != null && hasExample(docString.getStringValue())) {\n        result.add(file);\n      }\n    }\n    return result;\n  }","commit_id":"70b860a8a3031a020bafb38bf0e5383ed1ec6c94","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public BinarizerAnnotator(String annotatorName, Properties props) {\n    this.tlppClass = props.getProperty(annotatorName + \".tlppClass\", DEFAULT_TLPP_CLASS);\n    TreebankLangParserParams tlpp = ReflectionLoading.loadByReflection(tlppClass);\n    this.binarizer = new TreeBinarizer(tlpp.headFinder(), tlpp.treebankLanguagePack(),\n                                       false, false, 0, false, false, 0.0, false, true, true);\n  }","id":529,"modified_method":"public BinarizerAnnotator(String annotatorName, Properties props) {\n    this.tlppClass = props.getProperty(annotatorName + \".tlppClass\", DEFAULT_TLPP_CLASS);\n    TreebankLangParserParams tlpp = ReflectionLoading.loadByReflection(tlppClass);\n    this.binarizer = TreeBinarizer.simpleTreeBinarizer(tlpp.headFinder(), tlpp.treebankLanguagePack());\n  }","commit_id":"4ce4177fb062380901b653d0c324bad7ef38516e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Turns a text file into trees for use in a RNTN classifier such as\n   * the treebank used in the Sentiment project.\n   * <br>\n   * The expected input file is one sentence per line, with sentences\n   * separated by blank lines. The first line has the main label of the sentence together with the full sentence. \n   * Lines after the first sentence line but before\n   * the blank line will be treated as labeled subphrases.  The\n   * labels should start with the label and then contain a list of\n   * tokens the label applies to. All phrases that do not have their own label will take on the main sentence label!\n   *  For example:\n   * <br>\n   * <code>\n   * 1 Today is not a good day.<br>\n   * 3 good<br>\n   * 3 good day <br>\n   * 3 a good day <br>\n   * <br>\n   * (next block starts here) <br>\n   * <\/code>\n   * By default the englishPCFG parser is used.  This can be changed\n   * with the <code>-parserModel<\/code> flag.  Specify an input file\n   * with <code>-input<\/code>.\n   * <br>\n   * If a sentiment model is provided with -sentimentModel, that model\n   * will be used to prelabel the sentences.  Any spans with given\n   * labels will then be used to adjust those labels.\n   */\n  public static void main(String[] args) {\n    CollapseUnaryTransformer transformer = new CollapseUnaryTransformer();\n\n    String parserModel = \"edu/stanford/nlp/models/lexparser/englishPCFG.ser.gz\";\n\n    String inputPath = null;\n\n    String sentimentModelPath = null;\n    SentimentModel sentimentModel = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputPath = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModelPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex]);\n        System.exit(2);\n      }\n    }\n\n    if (inputPath == null) {\n      throw new IllegalArgumentException(\"Must specify input file with -input\");\n    }\n\n    LexicalizedParser parser = LexicalizedParser.loadModel(parserModel);\n    TreeBinarizer binarizer = new TreeBinarizer(parser.getTLPParams().headFinder(), parser.treebankLanguagePack(), \n                                                false, false, 0, false, false, 0.0, false, true, true);\n\n    if (sentimentModelPath != null) {\n      sentimentModel = SentimentModel.loadSerialized(sentimentModelPath);\n    }\n\n    String text = IOUtils.slurpFileNoExceptions(inputPath);\n    String[] chunks = text.split(\"\\\\n\\\\s*\\\\n+\"); // need blank line to make a new chunk\n\n    for (String chunk : chunks) {\n      if (chunk.trim() == \"\") {\n        continue;\n      }\n      // The expected format is that line 0 will be the text of the\n      // sentence, and each subsequence line, if any, will be a value\n      // followed by the sequence of tokens that get that value.\n\n      // Here we take the first line and tokenize it as one sentence.\n      String[] lines = chunk.trim().split(\"\\\\n\");\n      String sentence = lines[0];\n      StringReader sin = new StringReader(sentence);\n      DocumentPreprocessor document = new DocumentPreprocessor(sin);\n      document.setSentenceFinalPuncWords(new String[] {\"\\n\"});\n      List<HasWord> tokens = document.iterator().next();\n      Integer mainLabel = new Integer(tokens.get(0).word());\n      //System.out.print(\"Main Sentence Label: \" + mainLabel.toString() + \"; \");\n      tokens = tokens.subList(1, tokens.size());\n      //System.err.println(tokens);\n\n      Map<Pair<Integer, Integer>, String> spanToLabels = Generics.newHashMap();\n      for (int i = 1; i < lines.length; ++i) {\n        extractLabels(spanToLabels, tokens, lines[i]);\n      }\n\n      // TODO: add an option which treats the spans as constraints when parsing\n\n      Tree tree = parser.apply(tokens);\n      Tree binarized = binarizer.transformTree(tree);\n      Tree collapsedUnary = transformer.transformTree(binarized);\n\n      // if there is a sentiment model for use in prelabeling, we\n      // label here and then use the user given labels to adjust\n      if (sentimentModel != null) {\n        Trees.convertToCoreLabels(collapsedUnary);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(sentimentModel, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        setPredictedLabels(collapsedUnary);\n      } else {\n        setUnknownLabels(collapsedUnary, mainLabel);\n      }\n\n      Trees.convertToCoreLabels(collapsedUnary);\n      collapsedUnary.indexSpans();\n\n      for (Pair<Integer, Integer> span : spanToLabels.keySet()) {\n        setSpanLabel(collapsedUnary, span, spanToLabels.get(span));\n      }\n\n      System.out.println(collapsedUnary);\n      //System.out.println();\n    }\n  }","id":530,"modified_method":"/**\n   * Turns a text file into trees for use in a RNTN classifier such as\n   * the treebank used in the Sentiment project.\n   * <br>\n   * The expected input file is one sentence per line, with sentences\n   * separated by blank lines. The first line has the main label of the sentence together with the full sentence. \n   * Lines after the first sentence line but before\n   * the blank line will be treated as labeled subphrases.  The\n   * labels should start with the label and then contain a list of\n   * tokens the label applies to. All phrases that do not have their own label will take on the main sentence label!\n   *  For example:\n   * <br>\n   * <code>\n   * 1 Today is not a good day.<br>\n   * 3 good<br>\n   * 3 good day <br>\n   * 3 a good day <br>\n   * <br>\n   * (next block starts here) <br>\n   * <\/code>\n   * By default the englishPCFG parser is used.  This can be changed\n   * with the <code>-parserModel<\/code> flag.  Specify an input file\n   * with <code>-input<\/code>.\n   * <br>\n   * If a sentiment model is provided with -sentimentModel, that model\n   * will be used to prelabel the sentences.  Any spans with given\n   * labels will then be used to adjust those labels.\n   */\n  public static void main(String[] args) {\n    CollapseUnaryTransformer transformer = new CollapseUnaryTransformer();\n\n    String parserModel = \"edu/stanford/nlp/models/lexparser/englishPCFG.ser.gz\";\n\n    String inputPath = null;\n\n    String sentimentModelPath = null;\n    SentimentModel sentimentModel = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-input\")) {\n        inputPath = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-parserModel\")) {\n        parserModel = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-sentimentModel\")) {\n        sentimentModelPath = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        System.err.println(\"Unknown argument \" + args[argIndex]);\n        System.exit(2);\n      }\n    }\n\n    if (inputPath == null) {\n      throw new IllegalArgumentException(\"Must specify input file with -input\");\n    }\n\n    LexicalizedParser parser = LexicalizedParser.loadModel(parserModel);\n    TreeBinarizer binarizer = TreeBinarizer.simpleTreeBinarizer(parser.getTLPParams().headFinder(), parser.treebankLanguagePack());\n\n    if (sentimentModelPath != null) {\n      sentimentModel = SentimentModel.loadSerialized(sentimentModelPath);\n    }\n\n    String text = IOUtils.slurpFileNoExceptions(inputPath);\n    String[] chunks = text.split(\"\\\\n\\\\s*\\\\n+\"); // need blank line to make a new chunk\n\n    for (String chunk : chunks) {\n      if (chunk.trim() == \"\") {\n        continue;\n      }\n      // The expected format is that line 0 will be the text of the\n      // sentence, and each subsequence line, if any, will be a value\n      // followed by the sequence of tokens that get that value.\n\n      // Here we take the first line and tokenize it as one sentence.\n      String[] lines = chunk.trim().split(\"\\\\n\");\n      String sentence = lines[0];\n      StringReader sin = new StringReader(sentence);\n      DocumentPreprocessor document = new DocumentPreprocessor(sin);\n      document.setSentenceFinalPuncWords(new String[] {\"\\n\"});\n      List<HasWord> tokens = document.iterator().next();\n      Integer mainLabel = new Integer(tokens.get(0).word());\n      //System.out.print(\"Main Sentence Label: \" + mainLabel.toString() + \"; \");\n      tokens = tokens.subList(1, tokens.size());\n      //System.err.println(tokens);\n\n      Map<Pair<Integer, Integer>, String> spanToLabels = Generics.newHashMap();\n      for (int i = 1; i < lines.length; ++i) {\n        extractLabels(spanToLabels, tokens, lines[i]);\n      }\n\n      // TODO: add an option which treats the spans as constraints when parsing\n\n      Tree tree = parser.apply(tokens);\n      Tree binarized = binarizer.transformTree(tree);\n      Tree collapsedUnary = transformer.transformTree(binarized);\n\n      // if there is a sentiment model for use in prelabeling, we\n      // label here and then use the user given labels to adjust\n      if (sentimentModel != null) {\n        Trees.convertToCoreLabels(collapsedUnary);\n        SentimentCostAndGradient scorer = new SentimentCostAndGradient(sentimentModel, null);\n        scorer.forwardPropagateTree(collapsedUnary);\n        setPredictedLabels(collapsedUnary);\n      } else {\n        setUnknownLabels(collapsedUnary, mainLabel);\n      }\n\n      Trees.convertToCoreLabels(collapsedUnary);\n      collapsedUnary.indexSpans();\n\n      for (Pair<Integer, Integer> span : spanToLabels.keySet()) {\n        setSpanLabel(collapsedUnary, span, spanToLabels.get(span));\n      }\n\n      System.out.println(collapsedUnary);\n      //System.out.println();\n    }\n  }","commit_id":"4ce4177fb062380901b653d0c324bad7ef38516e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void finishSentence(CoreMap sentence, Tree tree) {\n    if (treeMap != null) {\n      tree = treeMap.apply(tree);\n    }\n\n    ParserAnnotatorUtils.fillInParseAnnotations(VERBOSE, BUILD_GRAPHS, gsf, sentence, tree);\n\n    if (saveBinaryTrees) {\n      TreeBinarizer binarizer = new TreeBinarizer(parser.getTLPParams().headFinder(), parser.treebankLanguagePack(),\n                                                  false, false, 0, false, false, 0.0, false, true, true);\n      Tree binarized = binarizer.transformTree(tree);\n      Trees.convertToCoreLabels(binarized);\n      sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, binarized);\n    }\n  }","id":531,"modified_method":"private void finishSentence(CoreMap sentence, Tree tree) {\n    if (treeMap != null) {\n      tree = treeMap.apply(tree);\n    }\n\n    ParserAnnotatorUtils.fillInParseAnnotations(VERBOSE, BUILD_GRAPHS, gsf, sentence, tree);\n\n    if (saveBinaryTrees) {\n      TreeBinarizer binarizer = TreeBinarizer.simpleTreeBinarizer(parser.getTLPParams().headFinder(), parser.treebankLanguagePack());\n      Tree binarized = binarizer.transformTree(tree);\n      Trees.convertToCoreLabels(binarized);\n      sentence.set(TreeCoreAnnotations.BinarizedTreeAnnotation.class, binarized);\n    }\n  }","commit_id":"4ce4177fb062380901b653d0c324bad7ef38516e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static List<Tree> binarizeTreebank(Treebank treebank, Options op) {\n    TreeBinarizer binarizer = new TreeBinarizer(op.tlpParams.headFinder(), op.tlpParams.treebankLanguagePack(), false, false, 0, false, false, 0.0, false, true, true);\n    BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n    CompositeTreeTransformer transformer = new CompositeTreeTransformer();\n    transformer.addTransformer(binarizer);\n    transformer.addTransformer(basicTransformer);\n\n    treebank = treebank.transform(transformer);\n\n    HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n    List<Tree> binarizedTrees = Generics.newArrayList();\n    for (Tree tree : treebank) {\n      Trees.convertToCoreLabels(tree);\n      tree.percolateHeadAnnotations(binaryHeadFinder);\n      // Index from 1.  Tools downstream expect index from 1, so for\n      // uses internal to the srparser we have to renormalize the\n      // indices, with the result that here we have to index from 1\n      tree.indexLeaves(1, true);\n      binarizedTrees.add(tree);\n    }\n    return binarizedTrees;\n  }","id":532,"modified_method":"public static List<Tree> binarizeTreebank(Treebank treebank, Options op) {\n    TreeBinarizer binarizer = TreeBinarizer.simpleTreeBinarizer(op.tlpParams.headFinder(), op.tlpParams.treebankLanguagePack());\n    BasicCategoryTreeTransformer basicTransformer = new BasicCategoryTreeTransformer(op.langpack());\n    CompositeTreeTransformer transformer = new CompositeTreeTransformer();\n    transformer.addTransformer(binarizer);\n    transformer.addTransformer(basicTransformer);\n\n    treebank = treebank.transform(transformer);\n\n    HeadFinder binaryHeadFinder = new BinaryHeadFinder(op.tlpParams.headFinder());\n    List<Tree> binarizedTrees = Generics.newArrayList();\n    for (Tree tree : treebank) {\n      Trees.convertToCoreLabels(tree);\n      tree.percolateHeadAnnotations(binaryHeadFinder);\n      // Index from 1.  Tools downstream expect index from 1, so for\n      // uses internal to the srparser we have to renormalize the\n      // indices, with the result that here we have to index from 1\n      tree.indexLeaves(1, true);\n      binarizedTrees.add(tree);\n    }\n    return binarizedTrees;\n  }","commit_id":"4ce4177fb062380901b653d0c324bad7ef38516e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n    public void execute() {\n        if (accountName == null && email == null) {\n            throw new InvalidParameterValueException(\"Either accountName or email is required\");\n        }\n\n        CallContext.current().setEventDetails(\"Project id: \" + projectId + \"; accountName \" + accountName);\n        Project project = _projectService.addAccountToProject(getProjectId(), getAccountName(), getEmail());\n        if (project != null) {\n            ProjectResponse response = _responseGenerator.createProjectResponse(project);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to add account to the project\");\n        }\n    }","id":533,"modified_method":"@Override\n    public void execute() {\n        if (accountName == null && email == null) {\n            throw new InvalidParameterValueException(\"Either accountName or email is required\");\n        }\n\n        CallContext.current().setEventDetails(\"Project id: \" + projectId + \"; accountName \" + accountName);\n        boolean result = _projectService.addAccountToProject(getProjectId(), getAccountName(), getEmail());\n        if (result) {\n            SuccessResponse response = new SuccessResponse(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to add account to the project\");\n        }\n    }","commit_id":"fd43cf151663c48fe29f97323490d53a7c0f9d5b","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute() {\n        CallContext.current().setEventDetails(\"Project id: \" + projectId + \"; accountName \" + accountName);\n        Project project = _projectService.deleteAccountFromProject(projectId, accountName);\n        if (project != null) {\n            ProjectResponse response = _responseGenerator.createProjectResponse(project);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to delete account from the project\");\n        }\n    }","id":534,"modified_method":"@Override\n    public void execute() {\n        CallContext.current().setEventDetails(\"Project id: \" + projectId + \"; accountName \" + accountName);\n        boolean result = _projectService.deleteAccountFromProject(projectId, accountName);\n        if (result) {\n            SuccessResponse response = new SuccessResponse(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to delete account from the project\");\n        }\n    }","commit_id":"fd43cf151663c48fe29f97323490d53a7c0f9d5b","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public void execute() {\n        CallContext.current().setEventDetails(\"Project id: \" + projectId + \"; accountName \" + accountName + \"; accept \" + getAccept());\n        Project project = _projectService.updateInvitation(projectId, accountName, token, getAccept());\n        if (project != null) {\n            ProjectResponse response = _responseGenerator.createProjectResponse(project);\n            response.setResponseName(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to join the project\");\n        }\n    }","id":535,"modified_method":"@Override\n    public void execute() {\n        CallContext.current().setEventDetails(\"Project id: \" + projectId + \"; accountName \" + accountName + \"; accept \" + getAccept());\n        boolean result = _projectService.updateInvitation(projectId, accountName, token, getAccept());\n        if (result) {\n            SuccessResponse response = new SuccessResponse(getCommandName());\n            this.setResponseObject(response);\n        } else {\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to join the project\");\n        }\n    }","commit_id":"fd43cf151663c48fe29f97323490d53a7c0f9d5b","url":"https://github.com/apache/cloudstack"},{"original_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.info( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Active transactions: \" + xidIdentMap.size() );\n            log.info( \"Closing dirty log: \" + fileName + \".\" + currentLog );\n            if ( writeBuffer != null )\n            {\n                writeBuffer.force();\n            }\n            writeBuffer = null;\n            fileChannel.close();\n            return;\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            deleteCurrentLogFile( fileName + \".\" + currentLog );\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                currentLog, endPosition );\n        }\n        setActiveLog( CLEAN );\n    }","id":536,"modified_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.info( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Active transactions: \" + xidIdentMap.size() );\n            log.info( \"Closing dirty log: \" + fileName + \".\" + currentLog );\n            if ( writeBuffer != null )\n            {\n                writeBuffer.force();\n            }\n            writeBuffer = null;\n            fileChannel.close();\n            return;\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( currentLog == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + currentLog );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                currentLog, endPosition );\n        }\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n    }","commit_id":"b0bb07c7602b488a4290126508fd278695f55672","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.info( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Active transactions: \" + xidIdentMap.size() );\n            log.info( \"Closing dirty log: \" + fileName + \".\" + currentLog );\n            if ( writeBuffer != null )\n            {\n                writeBuffer.force();\n            }\n            writeBuffer = null;\n            fileChannel.close();\n            return;\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            deleteCurrentLogFile( fileName + \".\" + currentLog );\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                currentLog, endPosition );\n        }\n        setActiveLog( CLEAN );\n    }","id":537,"modified_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.info( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Active transactions: \" + xidIdentMap.size() );\n            log.info( \"Closing dirty log: \" + fileName + \".\" + currentLog );\n            if ( writeBuffer != null )\n            {\n                writeBuffer.force();\n            }\n            writeBuffer = null;\n            fileChannel.close();\n            return;\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( currentLog == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + currentLog );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                currentLog, endPosition );\n        }\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n    }","commit_id":"c2e0cbd176dd46c5af979faac007c645cca1ef4f","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.info( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Active transactions: \" + xidIdentMap.size() );\n            log.info( \"Closing dirty log: \" + fileName + \".\" + currentLog );\n            if ( writeBuffer != null )\n            {\n                writeBuffer.force();\n            }\n            writeBuffer = null;\n            fileChannel.close();\n            return;\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            deleteCurrentLogFile( fileName + \".\" + currentLog );\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                currentLog, endPosition );\n        }\n        setActiveLog( CLEAN );\n    }","id":538,"modified_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.info( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Active transactions: \" + xidIdentMap.size() );\n            log.info( \"Closing dirty log: \" + fileName + \".\" + currentLog );\n            if ( writeBuffer != null )\n            {\n                writeBuffer.force();\n            }\n            writeBuffer = null;\n            fileChannel.close();\n            return;\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( currentLog == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + currentLog );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                currentLog, endPosition );\n        }\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n    }","commit_id":"a1fb921999bb07bf0fe30734fa97115f7bc8d092","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void readPortletDataPermissions(\n\t\t\tPortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/portlet-data-permissions.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> portletDataElements = rootElement.elements(\n\t\t\t\"portlet-data\");\n\n\t\tfor (Element portletDataElement : portletDataElements) {\n\t\t\tString resourceName = portletDataElement.attributeValue(\n\t\t\t\t\"resource-name\");\n\t\t\tlong resourcePK = GetterUtil.getLong(\n\t\t\t\tportletDataElement.attributeValue(\"resource-pk\"));\n\n\t\t\tList<KeyValuePair> permissions = new ArrayList<KeyValuePair>();\n\n\t\t\tList<Element> permissionsElements = portletDataElement.elements(\n\t\t\t\t\"permissions\");\n\n\t\t\tfor (Element permissionsElement : permissionsElements) {\n\t\t\t\tString roleName = permissionsElement.attributeValue(\n\t\t\t\t\t\"role-name\");\n\t\t\t\tString actions = permissionsElement.attributeValue(\"actions\");\n\n\t\t\t\tKeyValuePair permission = new KeyValuePair(roleName, actions);\n\n\t\t\t\tpermissions.add(permission);\n\t\t\t}\n\n\t\t\tportletDataContext.addPermissions(\n\t\t\t\tresourceName, resourcePK, permissions);\n\t\t}\n\t}","id":539,"modified_method":"protected void readPortletDataPermissions(\n\t\t\tPortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/portlet-data-permissions.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> portletDataElements = rootElement.elements(\n\t\t\t\"portlet-data\");\n\n\t\tfor (Element portletDataElement : portletDataElements) {\n\t\t\tString resourceName = portletDataElement.attributeValue(\n\t\t\t\t\"resource-name\");\n\t\t\tlong resourcePK = GetterUtil.getLong(\n\t\t\t\tportletDataElement.attributeValue(\"resource-pk\"));\n\n\t\t\tList<KeyValuePair> permissions = new ArrayList<KeyValuePair>();\n\n\t\t\tList<Element> permissionsElements = portletDataElement.elements(\n\t\t\t\t\"permissions\");\n\n\t\t\tfor (Element permissionsElement : permissionsElements) {\n\t\t\t\tString roleName = permissionsElement.attributeValue(\n\t\t\t\t\t\"role-name\");\n\t\t\t\tString actions = permissionsElement.attributeValue(\"actions\");\n\n\t\t\t\tKeyValuePair permission = new KeyValuePair(roleName, actions);\n\n\t\t\t\tpermissions.add(permission);\n\t\t\t}\n\n\t\t\tportletDataContext.addPermissions(\n\t\t\t\tresourceName, resourcePK, permissions);\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readAssetTags(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/tags.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetTagElements = rootElement.elements(\"tag\");\n\n\t\tfor (Element assetTagElement : assetTagElements) {\n\t\t\tString path = assetTagElement.attributeValue(\"path\");\n\n\t\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tAssetTag assetTag =\n\t\t\t\t(AssetTag)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\tMap<Long, Long> assetTagPKs =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tAssetTag.class);\n\n\t\t\timportAssetTag(\n\t\t\t\tportletDataContext, assetTagPKs, assetTagElement, assetTag);\n\t\t}\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString className = GetterUtil.getString(\n\t\t\t\tassetElement.attributeValue(\"class-name\"));\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\t\t\tString assetTagNames = GetterUtil.getString(\n\t\t\t\tassetElement.attributeValue(\"tags\"));\n\n\t\t\tportletDataContext.addAssetTags(\n\t\t\t\tclassName, classPK, StringUtil.split(assetTagNames));\n\t\t}\n\t}","id":540,"modified_method":"protected void readAssetTags(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/tags.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetTagElements = rootElement.elements(\"tag\");\n\n\t\tfor (Element assetTagElement : assetTagElements) {\n\t\t\tString path = assetTagElement.attributeValue(\"path\");\n\n\t\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tAssetTag assetTag =\n\t\t\t\t(AssetTag)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\tMap<Long, Long> assetTagPKs =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tAssetTag.class);\n\n\t\t\timportAssetTag(\n\t\t\t\tportletDataContext, assetTagPKs, assetTagElement, assetTag);\n\t\t}\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString className = GetterUtil.getString(\n\t\t\t\tassetElement.attributeValue(\"class-name\"));\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\t\t\tString assetTagNames = GetterUtil.getString(\n\t\t\t\tassetElement.attributeValue(\"tags\"));\n\n\t\t\tportletDataContext.addAssetTags(\n\t\t\t\tclassName, classPK, StringUtil.split(assetTagNames));\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readComments(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/comments.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString path = assetElement.attributeValue(\"path\");\n\t\t\tString className = assetElement.attributeValue(\"class-name\");\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\n\t\t\tList<String> zipFolderEntries =\n\t\t\t\tportletDataContext.getZipFolderEntries(path);\n\n\t\t\tList<MBMessage> mbMessages = new ArrayList<MBMessage>();\n\n\t\t\tfor (String zipFolderEntry : zipFolderEntries) {\n\t\t\t\tMBMessage mbMessage =\n\t\t\t\t\t(MBMessage)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\t\tzipFolderEntry);\n\n\t\t\t\tif (mbMessage != null) {\n\t\t\t\t\tmbMessages.add(mbMessage);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addComments(className, classPK, mbMessages);\n\t\t}\n\t}","id":541,"modified_method":"protected void readComments(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/comments.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString path = assetElement.attributeValue(\"path\");\n\t\t\tString className = assetElement.attributeValue(\"class-name\");\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\n\t\t\tList<String> zipFolderEntries =\n\t\t\t\tportletDataContext.getZipFolderEntries(path);\n\n\t\t\tList<MBMessage> mbMessages = new ArrayList<MBMessage>();\n\n\t\t\tfor (String zipFolderEntry : zipFolderEntries) {\n\t\t\t\tMBMessage mbMessage =\n\t\t\t\t\t(MBMessage)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\t\tzipFolderEntry);\n\n\t\t\t\tif (mbMessage != null) {\n\t\t\t\t\tmbMessages.add(mbMessage);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addComments(className, classPK, mbMessages);\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readAssetLinks(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/links.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetLinkElements = rootElement.elements(\"asset-link\");\n\n\t\tfor (Element assetLinkElement : assetLinkElements) {\n\t\t\tString sourceUuid = GetterUtil.getString(\n\t\t\t\tassetLinkElement.attributeValue(\"source-uuid\"));\n\t\t\tString[] assetEntryUuidArray = StringUtil.split(\n\t\t\t\tGetterUtil.getString(\n\t\t\t\t\tassetLinkElement.attributeValue(\"target-uuids\")));\n\t\t\tint assetLinkType = GetterUtil.getInteger(\n\t\t\t\tassetLinkElement.attributeValue(\"type\"));\n\n\t\t\tList<Long> assetEntryIds = new ArrayList<Long>();\n\n\t\t\tfor (String assetEntryUuid : assetEntryUuidArray) {\n\t\t\t\ttry {\n\t\t\t\t\tAssetEntry assetEntry = AssetEntryLocalServiceUtil.getEntry(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), assetEntryUuid);\n\n\t\t\t\t\tassetEntryIds.add(assetEntry.getEntryId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (assetEntryIds.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong[] assetEntryIdsArray = ArrayUtil.toArray(\n\t\t\t\tassetEntryIds.toArray(new Long[assetEntryIds.size()]));\n\n\t\t\ttry {\n\t\t\t\tAssetEntry assetEntry = AssetEntryLocalServiceUtil.getEntry(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), sourceUuid);\n\n\t\t\t\tAssetLinkLocalServiceUtil.updateLinks(\n\t\t\t\t\tassetEntry.getUserId(), assetEntry.getEntryId(),\n\t\t\t\t\tassetEntryIdsArray, assetLinkType);\n\t\t\t}\n\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t}\n\t\t}\n\t}","id":542,"modified_method":"protected void readAssetLinks(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/links.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetLinkElements = rootElement.elements(\"asset-link\");\n\n\t\tfor (Element assetLinkElement : assetLinkElements) {\n\t\t\tString sourceUuid = GetterUtil.getString(\n\t\t\t\tassetLinkElement.attributeValue(\"source-uuid\"));\n\t\t\tString[] assetEntryUuidArray = StringUtil.split(\n\t\t\t\tGetterUtil.getString(\n\t\t\t\t\tassetLinkElement.attributeValue(\"target-uuids\")));\n\t\t\tint assetLinkType = GetterUtil.getInteger(\n\t\t\t\tassetLinkElement.attributeValue(\"type\"));\n\n\t\t\tList<Long> assetEntryIds = new ArrayList<Long>();\n\n\t\t\tfor (String assetEntryUuid : assetEntryUuidArray) {\n\t\t\t\ttry {\n\t\t\t\t\tAssetEntry assetEntry = AssetEntryLocalServiceUtil.getEntry(\n\t\t\t\t\t\tportletDataContext.getScopeGroupId(), assetEntryUuid);\n\n\t\t\t\t\tassetEntryIds.add(assetEntry.getEntryId());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (assetEntryIds.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong[] assetEntryIdsArray = ArrayUtil.toArray(\n\t\t\t\tassetEntryIds.toArray(new Long[assetEntryIds.size()]));\n\n\t\t\ttry {\n\t\t\t\tAssetEntry assetEntry = AssetEntryLocalServiceUtil.getEntry(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), sourceUuid);\n\n\t\t\t\tAssetLinkLocalServiceUtil.updateLinks(\n\t\t\t\t\tassetEntry.getUserId(), assetEntry.getEntryId(),\n\t\t\t\t\tassetEntryIdsArray, assetLinkType);\n\t\t\t}\n\t\t\tcatch (NoSuchEntryException nsee) {\n\t\t\t}\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readExpandoTables(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/expando-tables.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> expandoTableElements = rootElement.elements(\n\t\t\t\"expando-table\");\n\n\t\tfor (Element expandoTableElement : expandoTableElements) {\n\t\t\tString className = expandoTableElement.attributeValue(\"class-name\");\n\n\t\t\tExpandoTable expandoTable = null;\n\n\t\t\ttry {\n\t\t\t\texpandoTable = ExpandoTableLocalServiceUtil.getDefaultTable(\n\t\t\t\t\tportletDataContext.getCompanyId(), className);\n\t\t\t}\n\t\t\tcatch (NoSuchTableException nste) {\n\t\t\t\texpandoTable = ExpandoTableLocalServiceUtil.addDefaultTable(\n\t\t\t\t\tportletDataContext.getCompanyId(), className);\n\t\t\t}\n\n\t\t\tList<Element> expandoColumnElements = expandoTableElement.elements(\n\t\t\t\t\"expando-column\");\n\n\t\t\tfor (Element expandoColumnElement : expandoColumnElements) {\n\t\t\t\tlong columnId = GetterUtil.getLong(\n\t\t\t\t\texpandoColumnElement.attributeValue(\"column-id\"));\n\t\t\t\tString name = expandoColumnElement.attributeValue(\"name\");\n\t\t\t\tint type = GetterUtil.getInteger(\n\t\t\t\t\texpandoColumnElement.attributeValue(\"type\"));\n\t\t\t\tString defaultData = expandoColumnElement.elementText(\n\t\t\t\t\t\"default-data\");\n\t\t\t\tString typeSettings = expandoColumnElement.elementText(\n\t\t\t\t\t\"type-settings\");\n\n\t\t\t\tSerializable defaultDataObject =\n\t\t\t\t\tExpandoConverterUtil.getAttributeFromString(\n\t\t\t\t\t\ttype, defaultData);\n\n\t\t\t\tExpandoColumn expandoColumn =\n\t\t\t\t\tExpandoColumnLocalServiceUtil.getColumn(\n\t\t\t\t\t\texpandoTable.getTableId(), name);\n\n\t\t\t\tif (expandoColumn != null) {\n\t\t\t\t\tExpandoColumnLocalServiceUtil.updateColumn(\n\t\t\t\t\t\texpandoColumn.getColumnId(), name, type,\n\t\t\t\t\t\tdefaultDataObject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texpandoColumn = ExpandoColumnLocalServiceUtil.addColumn(\n\t\t\t\t\t\texpandoTable.getTableId(), name, type,\n\t\t\t\t\t\tdefaultDataObject);\n\t\t\t\t}\n\n\t\t\t\tExpandoColumnLocalServiceUtil.updateTypeSettings(\n\t\t\t\t\texpandoColumn.getColumnId(), typeSettings);\n\n\t\t\t\tportletDataContext.importPermissions(\n\t\t\t\t\tExpandoColumn.class, columnId, expandoColumn.getColumnId());\n\t\t\t}\n\t\t}\n\t}","id":543,"modified_method":"protected void readExpandoTables(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/expando-tables.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> expandoTableElements = rootElement.elements(\n\t\t\t\"expando-table\");\n\n\t\tfor (Element expandoTableElement : expandoTableElements) {\n\t\t\tString className = expandoTableElement.attributeValue(\"class-name\");\n\n\t\t\tExpandoTable expandoTable = null;\n\n\t\t\ttry {\n\t\t\t\texpandoTable = ExpandoTableLocalServiceUtil.getDefaultTable(\n\t\t\t\t\tportletDataContext.getCompanyId(), className);\n\t\t\t}\n\t\t\tcatch (NoSuchTableException nste) {\n\t\t\t\texpandoTable = ExpandoTableLocalServiceUtil.addDefaultTable(\n\t\t\t\t\tportletDataContext.getCompanyId(), className);\n\t\t\t}\n\n\t\t\tList<Element> expandoColumnElements = expandoTableElement.elements(\n\t\t\t\t\"expando-column\");\n\n\t\t\tfor (Element expandoColumnElement : expandoColumnElements) {\n\t\t\t\tlong columnId = GetterUtil.getLong(\n\t\t\t\t\texpandoColumnElement.attributeValue(\"column-id\"));\n\t\t\t\tString name = expandoColumnElement.attributeValue(\"name\");\n\t\t\t\tint type = GetterUtil.getInteger(\n\t\t\t\t\texpandoColumnElement.attributeValue(\"type\"));\n\t\t\t\tString defaultData = expandoColumnElement.elementText(\n\t\t\t\t\t\"default-data\");\n\t\t\t\tString typeSettings = expandoColumnElement.elementText(\n\t\t\t\t\t\"type-settings\");\n\n\t\t\t\tSerializable defaultDataObject =\n\t\t\t\t\tExpandoConverterUtil.getAttributeFromString(\n\t\t\t\t\t\ttype, defaultData);\n\n\t\t\t\tExpandoColumn expandoColumn =\n\t\t\t\t\tExpandoColumnLocalServiceUtil.getColumn(\n\t\t\t\t\t\texpandoTable.getTableId(), name);\n\n\t\t\t\tif (expandoColumn != null) {\n\t\t\t\t\tExpandoColumnLocalServiceUtil.updateColumn(\n\t\t\t\t\t\texpandoColumn.getColumnId(), name, type,\n\t\t\t\t\t\tdefaultDataObject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texpandoColumn = ExpandoColumnLocalServiceUtil.addColumn(\n\t\t\t\t\t\texpandoTable.getTableId(), name, type,\n\t\t\t\t\t\tdefaultDataObject);\n\t\t\t\t}\n\n\t\t\t\tExpandoColumnLocalServiceUtil.updateTypeSettings(\n\t\t\t\t\texpandoColumn.getColumnId(), typeSettings);\n\n\t\t\t\tportletDataContext.importPermissions(\n\t\t\t\t\tExpandoColumn.class, columnId, expandoColumn.getColumnId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readAssetCategories(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/categories-hierarchy.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tElement assetVocabulariesElement = rootElement.element(\"vocabularies\");\n\n\t\tList<Element> assetVocabularyElements =\n\t\t\tassetVocabulariesElement.elements(\"vocabulary\");\n\n\t\tMap<Long, Long> assetVocabularyPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetVocabulary.class);\n\n\t\tfor (Element assetVocabularyElement : assetVocabularyElements) {\n\t\t\tString path = assetVocabularyElement.attributeValue(\"path\");\n\n\t\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tAssetVocabulary assetVocabulary =\n\t\t\t\t(AssetVocabulary)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\timportAssetVocabulary(\n\t\t\t\tportletDataContext, assetVocabularyPKs, assetVocabularyElement,\n\t\t\t\tassetVocabulary);\n\t\t}\n\n\t\tElement assetCategoriesElement = rootElement.element(\"categories\");\n\n\t\tList<Element> assetCategoryElements = assetCategoriesElement.elements(\n\t\t\t\"category\");\n\n\t\tMap<Long, Long> assetCategoryPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetCategory.class);\n\n\t\tMap<String, String> assetCategoryUuids =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetCategory.class.getName() + \"uuid\");\n\n\t\tfor (Element assetCategoryElement : assetCategoryElements) {\n\t\t\tString path = assetCategoryElement.attributeValue(\"path\");\n\n\t\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tAssetCategory assetCategory =\n\t\t\t\t(AssetCategory)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\timportAssetCategory(\n\t\t\t\tportletDataContext, assetVocabularyPKs, assetCategoryPKs,\n\t\t\t\tassetCategoryUuids, assetCategoryElement, assetCategory);\n\t\t}\n\n\t\tElement assetsElement = rootElement.element(\"assets\");\n\n\t\tList<Element> assetElements = assetsElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString className = GetterUtil.getString(\n\t\t\t\tassetElement.attributeValue(\"class-name\"));\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\t\t\tString[] assetCategoryUuidArray = StringUtil.split(\n\t\t\t\tGetterUtil.getString(\n\t\t\t\t\tassetElement.attributeValue(\"category-uuids\")));\n\n\t\t\tlong[] assetCategoryIds = new long[0];\n\n\t\t\tfor (String assetCategoryUuid : assetCategoryUuidArray) {\n\t\t\t\tassetCategoryUuid = MapUtil.getString(\n\t\t\t\t\tassetCategoryUuids, assetCategoryUuid, assetCategoryUuid);\n\n\t\t\t\tAssetCategory assetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\t\t\tassetCategoryUuid, portletDataContext.getScopeGroupId());\n\n\t\t\t\tif (assetCategory == null) {\n\t\t\t\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\t\t\tassetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\t\t\t\tassetCategoryUuid, companyGroup.getGroupId());\n\t\t\t\t}\n\n\t\t\t\tif (assetCategory != null) {\n\t\t\t\t\tassetCategoryIds = ArrayUtil.append(\n\t\t\t\t\t\tassetCategoryIds, assetCategory.getCategoryId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\tclassName, classPK, assetCategoryIds);\n\t\t}\n\t}","id":544,"modified_method":"protected void readAssetCategories(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/categories-hierarchy.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tElement assetVocabulariesElement = rootElement.element(\"vocabularies\");\n\n\t\tList<Element> assetVocabularyElements =\n\t\t\tassetVocabulariesElement.elements(\"vocabulary\");\n\n\t\tMap<Long, Long> assetVocabularyPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetVocabulary.class);\n\n\t\tfor (Element assetVocabularyElement : assetVocabularyElements) {\n\t\t\tString path = assetVocabularyElement.attributeValue(\"path\");\n\n\t\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tAssetVocabulary assetVocabulary =\n\t\t\t\t(AssetVocabulary)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\timportAssetVocabulary(\n\t\t\t\tportletDataContext, assetVocabularyPKs, assetVocabularyElement,\n\t\t\t\tassetVocabulary);\n\t\t}\n\n\t\tElement assetCategoriesElement = rootElement.element(\"categories\");\n\n\t\tList<Element> assetCategoryElements = assetCategoriesElement.elements(\n\t\t\t\"category\");\n\n\t\tMap<Long, Long> assetCategoryPKs =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetCategory.class);\n\n\t\tMap<String, String> assetCategoryUuids =\n\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tAssetCategory.class.getName() + \"uuid\");\n\n\t\tfor (Element assetCategoryElement : assetCategoryElements) {\n\t\t\tString path = assetCategoryElement.attributeValue(\"path\");\n\n\t\t\tif (!portletDataContext.isPathNotProcessed(path)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tAssetCategory assetCategory =\n\t\t\t\t(AssetCategory)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\timportAssetCategory(\n\t\t\t\tportletDataContext, assetVocabularyPKs, assetCategoryPKs,\n\t\t\t\tassetCategoryUuids, assetCategoryElement, assetCategory);\n\t\t}\n\n\t\tElement assetsElement = rootElement.element(\"assets\");\n\n\t\tList<Element> assetElements = assetsElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString className = GetterUtil.getString(\n\t\t\t\tassetElement.attributeValue(\"class-name\"));\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\t\t\tString[] assetCategoryUuidArray = StringUtil.split(\n\t\t\t\tGetterUtil.getString(\n\t\t\t\t\tassetElement.attributeValue(\"category-uuids\")));\n\n\t\t\tlong[] assetCategoryIds = new long[0];\n\n\t\t\tfor (String assetCategoryUuid : assetCategoryUuidArray) {\n\t\t\t\tassetCategoryUuid = MapUtil.getString(\n\t\t\t\t\tassetCategoryUuids, assetCategoryUuid, assetCategoryUuid);\n\n\t\t\t\tAssetCategory assetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\t\t\tassetCategoryUuid, portletDataContext.getScopeGroupId());\n\n\t\t\t\tif (assetCategory == null) {\n\t\t\t\t\tGroup companyGroup = GroupLocalServiceUtil.getCompanyGroup(\n\t\t\t\t\t\tportletDataContext.getCompanyId());\n\n\t\t\t\t\tassetCategory = AssetCategoryUtil.fetchByUUID_G(\n\t\t\t\t\t\tassetCategoryUuid, companyGroup.getGroupId());\n\t\t\t\t}\n\n\t\t\t\tif (assetCategory != null) {\n\t\t\t\t\tassetCategoryIds = ArrayUtil.append(\n\t\t\t\t\t\tassetCategoryIds, assetCategory.getCategoryId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addAssetCategories(\n\t\t\t\tclassName, classPK, assetCategoryIds);\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readRatingsEntries(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/ratings.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString path = assetElement.attributeValue(\"path\");\n\t\t\tString className = assetElement.attributeValue(\"class-name\");\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\n\t\t\tList<String> zipFolderEntries =\n\t\t\t\tportletDataContext.getZipFolderEntries(path);\n\n\t\t\tList<RatingsEntry> ratingsEntries = new ArrayList<RatingsEntry>();\n\n\t\t\tfor (String zipFolderEntry : zipFolderEntries) {\n\t\t\t\tRatingsEntry ratingsEntry =\n\t\t\t\t\t(RatingsEntry)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\t\tzipFolderEntry);\n\n\t\t\t\tif (ratingsEntry != null) {\n\t\t\t\t\tratingsEntries.add(ratingsEntry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\tclassName, classPK, ratingsEntries);\n\t\t}\n\t}","id":545,"modified_method":"protected void readRatingsEntries(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/ratings.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString path = assetElement.attributeValue(\"path\");\n\t\t\tString className = assetElement.attributeValue(\"class-name\");\n\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\tassetElement.attributeValue(\"class-pk\"));\n\n\t\t\tList<String> zipFolderEntries =\n\t\t\t\tportletDataContext.getZipFolderEntries(path);\n\n\t\t\tList<RatingsEntry> ratingsEntries = new ArrayList<RatingsEntry>();\n\n\t\t\tfor (String zipFolderEntry : zipFolderEntries) {\n\t\t\t\tRatingsEntry ratingsEntry =\n\t\t\t\t\t(RatingsEntry)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\t\tzipFolderEntry);\n\n\t\t\t\tif (ratingsEntry != null) {\n\t\t\t\t\tratingsEntries.add(ratingsEntry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tportletDataContext.addRatingsEntries(\n\t\t\t\tclassName, classPK, ratingsEntries);\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void readLocks(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tExportImportPathUtil.getSourceRootPath(portletDataContext) +\n\t\t\t\t\"/locks.xml\");\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString path = assetElement.attributeValue(\"path\");\n\t\t\tString className = assetElement.attributeValue(\"class-name\");\n\t\t\tString key = assetElement.attributeValue(\"key\");\n\n\t\t\tLock lock = (Lock)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\tif (lock != null) {\n\t\t\t\tportletDataContext.addLocks(className, key, lock);\n\t\t\t}\n\t\t}\n\t}","id":546,"modified_method":"protected void readLocks(PortletDataContext portletDataContext)\n\t\tthrows Exception {\n\n\t\tString sourceRootPath = ExportImportPathUtil.getSourceRootPath(\n\t\t\tportletDataContext);\n\n\t\tString xml = portletDataContext.getZipEntryAsString(\n\t\t\tsourceRootPath.concat(\"/locks.xml\"));\n\n\t\tif (xml == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tList<Element> assetElements = rootElement.elements(\"asset\");\n\n\t\tfor (Element assetElement : assetElements) {\n\t\t\tString path = assetElement.attributeValue(\"path\");\n\t\t\tString className = assetElement.attributeValue(\"class-name\");\n\t\t\tString key = assetElement.attributeValue(\"key\");\n\n\t\t\tLock lock = (Lock)portletDataContext.getZipEntryAsObject(path);\n\n\t\t\tif (lock != null) {\n\t\t\t\tportletDataContext.addLocks(className, key, lock);\n\t\t\t}\n\t\t}\n\t}","commit_id":"16f209f3eef8d081eeea67c64a813358aa0a5693","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private <T> Response<T> packResponse( SlaveContext context, T response,\n            Predicate<Long> filter )\n    {\n        try\n        {\n            TransactionStreams streams = new TransactionStreams();\n            for ( Map.Entry<String, Long> slaveEntry :\n                    context.lastAppliedTransactions().entrySet() )\n            {\n                String resourceName = slaveEntry.getKey();\n                XaDataSource dataSource = getConfig().getTxModule()\n                        .getXaDataSourceManager().getXaDataSource( resourceName );\n                long masterLastTx = dataSource.getLastCommittedTxId();\n                long slaveLastTx = slaveEntry.getValue();\n                Collection<ReadableByteChannel> channels = new ArrayList<ReadableByteChannel>();\n                for ( long txId = slaveLastTx+1; txId <= masterLastTx; txId++ )\n                {\n                    if ( filter.accept( txId ) )\n                    {\n                        channels.add( dataSource.getCommittedTransaction( txId ) );\n                    }\n                }\n                streams.add( slaveEntry.getKey(), new TransactionStream( channels ) );\n            }\n            return new Response<T>( response, streams );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<T>();\n        }\n    }","id":547,"modified_method":"private <T> Response<T> packResponse( SlaveContext context, T response,\n            Predicate<Long> filter )\n    {\n        try\n        {\n            TransactionStreams streams = new TransactionStreams();\n            for ( Pair<String, Long> txEntry : context.lastAppliedTransactions() )\n            {\n                String resourceName = txEntry.first();\n                XaDataSource dataSource = graphDbConfig.getTxModule().getXaDataSourceManager()\n                        .getXaDataSource( resourceName );\n                long masterLastTx = dataSource.getLastCommittedTxId();\n                Collection<ReadableByteChannel> channels = new ArrayList<ReadableByteChannel>();\n                for ( long txId = txEntry.other()+1; txId <= masterLastTx; txId++ )\n                {\n                    if ( filter.accept( txId ) )\n                    {\n                        channels.add( dataSource.getCommittedTransaction( txId ) );\n                    }\n                }\n                streams.add( resourceName, new TransactionStream( channels ) );\n            }\n            return new Response<T>( response, streams );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<T>();\n        }\n    }","commit_id":"584a168f05ed7fedfe323f2cb1c5b695134d18b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> packResponse( SlaveContext context, T response,\n            Predicate<Long> filter )\n    {\n        try\n        {\n            TransactionStreams streams = new TransactionStreams();\n            for ( Map.Entry<String, Long> slaveEntry :\n                    context.lastAppliedTransactions().entrySet() )\n            {\n                String resourceName = slaveEntry.getKey();\n                XaDataSource dataSource = getConfig().getTxModule()\n                        .getXaDataSourceManager().getXaDataSource( resourceName );\n                long masterLastTx = dataSource.getLastCommittedTxId();\n                long slaveLastTx = slaveEntry.getValue();\n                Collection<ReadableByteChannel> channels = new ArrayList<ReadableByteChannel>();\n                for ( long txId = slaveLastTx+1; txId <= masterLastTx; txId++ )\n                {\n                    if ( filter.accept( txId ) )\n                    {\n                        channels.add( dataSource.getCommittedTransaction( txId ) );\n                    }\n                }\n                streams.add( slaveEntry.getKey(), new TransactionStream( channels ) );\n            }\n            return new Response<T>( response, streams );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<T>();\n        }\n    }","id":548,"modified_method":"private <T> Response<T> packResponse( SlaveContext context, T response,\n            Predicate<Long> filter )\n    {\n        try\n        {\n            TransactionStreams streams = new TransactionStreams();\n            for ( Pair<String, Long> txEntry : context.lastAppliedTransactions() )\n            {\n                String resourceName = txEntry.first();\n                XaDataSource dataSource = graphDbConfig.getTxModule().getXaDataSourceManager()\n                        .getXaDataSource( resourceName );\n                long masterLastTx = dataSource.getLastCommittedTxId();\n                Collection<ReadableByteChannel> channels = new ArrayList<ReadableByteChannel>();\n                for ( long txId = txEntry.other()+1; txId <= masterLastTx; txId++ )\n                {\n                    if ( filter.accept( txId ) )\n                    {\n                        channels.add( dataSource.getCommittedTransaction( txId ) );\n                    }\n                }\n                streams.add( resourceName, new TransactionStream( channels ) );\n            }\n            return new Response<T>( response, streams );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<T>();\n        }\n    }","commit_id":"c3c969213cd59916576df656b91bbb9499428283","url":"https://github.com/neo4j/neo4j"},{"original_method":"private <T> Response<T> packResponse( SlaveContext context, T response,\n            Predicate<Long> filter )\n    {\n        try\n        {\n            TransactionStreams streams = new TransactionStreams();\n            for ( Map.Entry<String, Long> slaveEntry :\n                    context.lastAppliedTransactions().entrySet() )\n            {\n                String resourceName = slaveEntry.getKey();\n                XaDataSource dataSource = getConfig().getTxModule()\n                        .getXaDataSourceManager().getXaDataSource( resourceName );\n                long masterLastTx = dataSource.getLastCommittedTxId();\n                long slaveLastTx = slaveEntry.getValue();\n                Collection<ReadableByteChannel> channels = new ArrayList<ReadableByteChannel>();\n                for ( long txId = slaveLastTx+1; txId <= masterLastTx; txId++ )\n                {\n                    if ( filter.accept( txId ) )\n                    {\n                        channels.add( dataSource.getCommittedTransaction( txId ) );\n                    }\n                }\n                streams.add( slaveEntry.getKey(), new TransactionStream( channels ) );\n            }\n            return new Response<T>( response, streams );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<T>();\n        }\n    }","id":549,"modified_method":"private <T> Response<T> packResponse( SlaveContext context, T response,\n            Predicate<Long> filter )\n    {\n        try\n        {\n            TransactionStreams streams = new TransactionStreams();\n            for ( Pair<String, Long> txEntry : context.lastAppliedTransactions() )\n            {\n                String resourceName = txEntry.first();\n                XaDataSource dataSource = graphDbConfig.getTxModule().getXaDataSourceManager()\n                        .getXaDataSource( resourceName );\n                long masterLastTx = dataSource.getLastCommittedTxId();\n                Collection<ReadableByteChannel> channels = new ArrayList<ReadableByteChannel>();\n                for ( long txId = txEntry.other()+1; txId <= masterLastTx; txId++ )\n                {\n                    if ( filter.accept( txId ) )\n                    {\n                        channels.add( dataSource.getCommittedTransaction( txId ) );\n                    }\n                }\n                streams.add( resourceName, new TransactionStream( channels ) );\n            }\n            return new Response<T>( response, streams );\n        }\n        catch ( IOException e )\n        {\n            e.printStackTrace();\n            return new FailedResponse<T>();\n        }\n    }","commit_id":"46aa0b2c822fc19b6e1c2e4208d71d1acae6eeb9","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected Answer execute(final DeleteIpAliasCommand cmd) {\n        cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);\n        List<IpAliasTO> revokedIpAliasTOs = cmd.getDeleteIpAliasTos();\n        List<IpAliasTO> activeIpAliasTOs = cmd.getCreateIpAliasTos();\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing deleteIpAlias command: \" + s_gson.toJson(cmd));\n        }\n        String args = \"\";\n        for (IpAliasTO ipAliasTO : revokedIpAliasTOs) {\n            args = args + ipAliasTO.getAlias_count() + \":\" + ipAliasTO.getRouterip() + \":\" + ipAliasTO.getNetmask() + \"-\";\n        }\n        args = args + \"- \";\n        for (IpAliasTO ipAliasTO : activeIpAliasTOs) {\n            args = args + ipAliasTO.getAlias_count() + \":\" + ipAliasTO.getRouterip() + \":\" + ipAliasTO.getNetmask() + \"-\";\n        }\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Run command on domR \" + cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP) + \", /root/deleteIpAlias \" + args);\n        }\n\n        try {\n            String controlIp = getRouterSshControlIp(cmd);\n            Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, \"root\", getSystemVMKeyFile(), null,\n                    \"/root/deleteIpAlias.sh \" + args);\n\n            if (!result.first()) {\n                s_logger.error(\"deleteIpAlias command on domr \" + controlIp + \" failed, message: \" + result.second());\n\n                return new Answer(cmd, false, \"deleteIpAlias failed due to \" + result.second());\n            }\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"deleteIpAlias command on domain router \" + controlIp + \" completed\");\n            }\n\n        } catch (Throwable e) {\n            String msg = \"deleteIpAlias failed due to \" + e.getMessage();\n            s_logger.error(msg, e);\n            return new Answer(cmd, false, msg);\n        }\n\n        return new Answer(cmd);\n    }","id":550,"modified_method":"protected Answer execute(final DeleteIpAliasCommand cmd) {\n        cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);\n        List<IpAliasTO> revokedIpAliasTOs = cmd.getDeleteIpAliasTos();\n        List<IpAliasTO> activeIpAliasTOs = cmd.getCreateIpAliasTos();\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing deleteIpAlias command: \" + s_gson.toJson(cmd));\n        }\n        StringBuilder args = new StringBuilder();\n        for (IpAliasTO ipAliasTO : revokedIpAliasTOs) {\n            args.append(ipAliasTO.getAlias_count());\n            args.append(\":\");\n            args.append(ipAliasTO.getRouterip());\n            args.append(\":\");\n            args.append(ipAliasTO.getNetmask());\n            args.append(\"-\");\n        }\n        args.append(\"- \");\n        for (IpAliasTO ipAliasTO : activeIpAliasTOs) {\n            args.append(ipAliasTO.getAlias_count());\n            args.append(\":\");\n            args.append(ipAliasTO.getRouterip());\n            args.append(\":\");\n            args.append(ipAliasTO.getNetmask());\n            args.append(\"-\");\n        }\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Run command on domR \" + cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP) + \", /root/deleteIpAlias \" + args);\n        }\n\n        try {\n            String controlIp = getRouterSshControlIp(cmd);\n            Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, \"root\", getSystemVMKeyFile(), null,\n                    \"/root/deleteIpAlias.sh \" + args);\n\n            if (!result.first()) {\n                s_logger.error(\"deleteIpAlias command on domr \" + controlIp + \" failed, message: \" + result.second());\n\n                return new Answer(cmd, false, \"deleteIpAlias failed due to \" + result.second());\n            }\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"deleteIpAlias command on domain router \" + controlIp + \" completed\");\n            }\n\n        } catch (Throwable e) {\n            String msg = \"deleteIpAlias failed due to \" + e.getMessage();\n            s_logger.error(msg, e);\n            return new Answer(cmd, false, msg);\n        }\n\n        return new Answer(cmd);\n    }","commit_id":"ad0d7f882f001ed6421e4aa40070a215ffb1fd3b","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Answer execute(final CreateIpAliasCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing createIpAlias command: \" + s_gson.toJson(cmd));\n        }\n        cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);\n        List<IpAliasTO> ipAliasTOs = cmd.getIpAliasList();\n        String args=\"\";\n        for (IpAliasTO ipaliasto : ipAliasTOs) {\n            args = args + ipaliasto.getAlias_count()+\":\"+ipaliasto.getRouterip()+\":\"+ipaliasto.getNetmask()+\"-\";\n        }\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Run command on domR \" + cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP) + \", /root/createIpAlias \" + args);\n        }\n\n        try {\n            String controlIp = getRouterSshControlIp(cmd);\n            Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, \"root\", getSystemVMKeyFile(), null,\n                    \"/root/createIpAlias.sh \" + args);\n\n            if (!result.first()) {\n                s_logger.error(\"CreateIpAlias command on domr \" + controlIp + \" failed, message: \" + result.second());\n\n                return new Answer(cmd, false, \"createipAlias failed due to \" + result.second());\n            }\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"createIpAlias command on domain router \" + controlIp + \" completed\");\n            }\n\n        } catch (Throwable e) {\n            String msg = \"createIpAlias failed due to \" + e;\n            s_logger.error(msg, e);\n            return new Answer(cmd, false, msg);\n        }\n\n        return new Answer(cmd);\n    }","id":551,"modified_method":"protected Answer execute(final CreateIpAliasCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing createIpAlias command: \" + s_gson.toJson(cmd));\n        }\n        cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);\n        List<IpAliasTO> ipAliasTOs = cmd.getIpAliasList();\n        StringBuilder args = new StringBuilder();\n        for (IpAliasTO ipaliasto : ipAliasTOs) {\n            args.append(ipaliasto.getAlias_count());\n            args.append(\":\");\n            args.append(ipaliasto.getRouterip());\n            args.append(\":\");\n            args.append(ipaliasto.getNetmask());\n            args.append(\"-\");\n        }\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Run command on domR \" + cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP) + \", /root/createIpAlias \" + args);\n        }\n\n        try {\n            String controlIp = getRouterSshControlIp(cmd);\n            Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, \"root\", getSystemVMKeyFile(), null,\n                    \"/root/createIpAlias.sh \" + args);\n\n            if (!result.first()) {\n                s_logger.error(\"CreateIpAlias command on domr \" + controlIp + \" failed, message: \" + result.second());\n\n                return new Answer(cmd, false, \"createipAlias failed due to \" + result.second());\n            }\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"createIpAlias command on domain router \" + controlIp + \" completed\");\n            }\n\n        } catch (Throwable e) {\n            String msg = \"createIpAlias failed due to \" + e;\n            s_logger.error(msg, e);\n            return new Answer(cmd, false, msg);\n        }\n\n        return new Answer(cmd);\n    }","commit_id":"ad0d7f882f001ed6421e4aa40070a215ffb1fd3b","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Answer execute(final DnsMasqConfigCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing dnsmasqConfig command: \" + s_gson.toJson(cmd));\n        }\n        String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);\n        String controlIp = getRouterSshControlIp(cmd);\n\n        assert(controlIp != null);\n\n        List<DhcpTO> dhcpTos = cmd.getIps();\n        String args =\"\";\n        for(DhcpTO dhcpTo : dhcpTos) {\n            args = args + dhcpTo.getRouterIp()+\":\"+dhcpTo.getGateway()+\":\"+dhcpTo.getNetmask()+\":\"+dhcpTo.getStartIpOfSubnet()+\"-\";\n        }\n\n        try {\n            Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, \"root\", getSystemVMKeyFile(), null, \"/root/dnsmasq.sh \" + args);\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Run command on domain router \" + routerIp + \",  /root/dnsmasq.sh\");\n            }\n\n            if (!result.first()) {\n                s_logger.error(\"Unable update dnsmasq config file\");\n                return new Answer(cmd, false, \"dnsmasq config update failed due to: \" + result.second());\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"dnsmasq config command on domain router \" + routerIp + \" completed\");\n            }\n        }catch (Throwable e) {\n            String msg = \"Dnsmasqconfig command failed due to \" + e.getMessage();\n            s_logger.error(msg, e);\n            return new Answer(cmd, false, msg);\n        }\n\n        return new Answer(cmd);\n    }","id":552,"modified_method":"protected Answer execute(final DnsMasqConfigCommand cmd) {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"Executing dnsmasqConfig command: \" + s_gson.toJson(cmd));\n        }\n        String routerIp = cmd.getAccessDetail(NetworkElementCommand.ROUTER_IP);\n        String controlIp = getRouterSshControlIp(cmd);\n\n        assert(controlIp != null);\n\n        List<DhcpTO> dhcpTos = cmd.getIps();\n        StringBuilder args = new StringBuilder();\n        for(DhcpTO dhcpTo : dhcpTos) {\n            args.append(dhcpTo.getRouterIp());\n            args.append(\":\");\n            args.append(dhcpTo.getGateway());\n            args.append(\":\");\n            args.append(dhcpTo.getNetmask());\n            args.append(\":\");\n            args.append(dhcpTo.getStartIpOfSubnet());\n            args.append(\"-\");\n        }\n\n        try {\n            Pair<Boolean, String> result = SshHelper.sshExecute(controlIp, DEFAULT_DOMR_SSHPORT, \"root\", getSystemVMKeyFile(), null, \"/root/dnsmasq.sh \" + args);\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Run command on domain router \" + routerIp + \",  /root/dnsmasq.sh\");\n            }\n\n            if (!result.first()) {\n                s_logger.error(\"Unable update dnsmasq config file\");\n                return new Answer(cmd, false, \"dnsmasq config update failed due to: \" + result.second());\n            }\n\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"dnsmasq config command on domain router \" + routerIp + \" completed\");\n            }\n        }catch (Throwable e) {\n            String msg = \"Dnsmasqconfig command failed due to \" + e.getMessage();\n            s_logger.error(msg, e);\n            return new Answer(cmd, false, msg);\n        }\n\n        return new Answer(cmd);\n    }","commit_id":"ad0d7f882f001ed6421e4aa40070a215ffb1fd3b","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testPoolingConfig()\n    {\n//        //TODO RM* test config\n//        PoolingProfile pp = muleContext.getConfiguration().getPoolingProfile();\n//        assertEquals(10, pp.getMaxActive());\n//        assertEquals(5, pp.getMaxIdle());\n//        assertEquals(10001, pp.getMaxWait());\n//        assertEquals(ObjectPool.WHEN_EXHAUSTED_WAIT, pp.getExhaustedAction());\n//        assertEquals(PoolingProfile.INITIALISE_ONE, pp.getInitialisationPolicy());\n//        assertTrue(pp.getPoolFactory() instanceof CommonsPoolFactory);\n\n        // test per-descriptor overrides\n        Service service = muleContext.getRegistry().lookupService(\"appleComponent2\");\n        PoolingProfile pp = ((PooledJavaComponent)service.getComponent()).getPoolingProfile();\n\n        assertEquals(9, pp.getMaxActive());\n        assertEquals(6, pp.getMaxIdle());\n        assertEquals(4002, pp.getMaxWait());\n        assertEquals(PoolingProfile.WHEN_EXHAUSTED_FAIL, pp.getExhaustedAction());\n        assertEquals(PoolingProfile.INITIALISE_ALL, pp.getInitialisationPolicy());\n    }","id":553,"modified_method":"@Test\n    public void testPoolingConfig()\n    {\n        // test per-descriptor overrides\n        Flow service = (Flow) muleContext.getRegistry().lookupFlowConstruct(\"appleComponent2\");\n        PoolingProfile pp = ((PooledJavaComponent) service.getMessageProcessors().get(0)).getPoolingProfile();\n\n        assertEquals(9, pp.getMaxActive());\n        assertEquals(6, pp.getMaxIdle());\n        assertEquals(4002, pp.getMaxWait());\n        assertEquals(PoolingProfile.WHEN_EXHAUSTED_FAIL, pp.getExhaustedAction());\n        assertEquals(PoolingProfile.INITIALISE_ALL, pp.getInitialisationPolicy());\n    }","commit_id":"90877508ab5acdd627b2f8f54337d0cc6a4f5175","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testInterceptors()\n    {\n        Service service = muleContext.getRegistry().lookupService(\"orangeComponent\");\n        AbstractComponent component = (AbstractComponent) service.getComponent();\n        assertEquals(3, component.getInterceptors().size());\n        assertEquals(LoggingInterceptor.class, component.getInterceptors().get(0).getClass());\n        assertEquals(InterceptorStack.class, component.getInterceptors().get(1).getClass());\n        assertEquals(TimerInterceptor.class, component.getInterceptors().get(2).getClass());\n    }","id":554,"modified_method":"@Test\n    public void testInterceptors()\n    {\n        Flow service = (Flow) muleContext.getRegistry().lookupFlowConstruct(\"orangeComponent\");\n        AbstractComponent component = (AbstractComponent) service.getMessageProcessors().get(0);\n        assertEquals(3, component.getInterceptors().size());\n        assertEquals(LoggingInterceptor.class, component.getInterceptors().get(0).getClass());\n        assertEquals(InterceptorStack.class, component.getInterceptors().get(1).getClass());\n        assertEquals(TimerInterceptor.class, component.getInterceptors().get(2).getClass());\n    }","commit_id":"90877508ab5acdd627b2f8f54337d0cc6a4f5175","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testBindingConfig()\n    {\n        // test outbound message router\n        Service service = muleContext.getRegistry().lookupService(\"orangeComponent\");\n        assertNotNull(service.getComponent());\n        assertTrue(service.getComponent() instanceof JavaComponent);\n        List<InterfaceBinding> bindings= ((JavaComponent) service.getComponent()).getInterfaceBindings();\n        assertNotNull(bindings);\n\n        assertEquals(2, bindings.size());\n        // check first Router\n        InterfaceBinding route1 = bindings.get(0);\n        assertEquals(FruitCleaner.class, route1.getInterface());\n        assertEquals(\"wash\", route1.getMethod());\n        assertNotNull(route1.getEndpoint());\n        // check second Router\n        InterfaceBinding route2 = bindings.get(1);\n        assertEquals(FruitCleaner.class, route2.getInterface());\n        assertEquals(\"polish\", route2.getMethod());\n        assertNotNull(route1.getEndpoint());\n    }","id":555,"modified_method":"@Test\n    public void testBindingConfig()\n    {\n        // test outbound message router\n        Flow service = (Flow) muleContext.getRegistry().lookupFlowConstruct(\"orangeComponent\");\n        assertNotNull(service.getMessageProcessors().get(0));\n        assertTrue((service.getMessageProcessors().get(0) instanceof JavaComponent));\n        List<InterfaceBinding> bindings= ((JavaComponent) service.getMessageProcessors().get(0)).getInterfaceBindings();\n        assertNotNull(bindings);\n\n        assertEquals(2, bindings.size());\n        // check first Router\n        InterfaceBinding route1 = bindings.get(0);\n        assertEquals(FruitCleaner.class, route1.getInterface());\n        assertEquals(\"wash\", route1.getMethod());\n        assertNotNull(route1.getEndpoint());\n        // check second Router\n        InterfaceBinding route2 = bindings.get(1);\n        assertEquals(FruitCleaner.class, route2.getInterface());\n        assertEquals(\"polish\", route2.getMethod());\n        assertNotNull(route1.getEndpoint());\n    }","commit_id":"90877508ab5acdd627b2f8f54337d0cc6a4f5175","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void setUpgradeTransactionMustBeAtomic() throws Throwable\n    {\n        try ( MetaDataStore store = newMetaDataStore() )\n        {\n            PagedFile pf = store.storeFile;\n            store.setUpgradeTransaction( 0, 0, 0 );\n            AtomicLong writeCount = new AtomicLong();\n            AtomicLong fileReadCount = new AtomicLong();\n            AtomicLong apiReadCount = new AtomicLong();\n            int upperLimit = 10_000;\n            int lowerLimit = 100;\n            long endTime = currentTimeMillis() + SECONDS.toMillis( 10 );\n\n            Race race = new Race();\n            BooleanSupplier end = () ->\n            {\n                boolean upperBoundReached = writeCount.get() >= upperLimit &&\n                        fileReadCount.get() >= upperLimit && apiReadCount.get() >= upperLimit;\n                boolean lowerBoundReached = writeCount.get() >= lowerLimit &&\n                        fileReadCount.get() >= lowerLimit && apiReadCount.get() >= lowerLimit;\n                return !upperBoundReached || (currentTimeMillis() >= endTime && lowerBoundReached);\n            };\n            // writers\n            race.addContestants( 3, until( end, () -> {\n                long count = writeCount.incrementAndGet();\n                store.setUpgradeTransaction( count, count, count );\n            } ) );\n\n            // file readers\n            race.addContestants( 3, until( end, throwing( () -> {\n                try ( PageCursor cursor = pf.io( 0, PagedFile.PF_SHARED_READ_LOCK ) )\n                {\n                    assertTrue( cursor.next() );\n                    long id, checksum;\n                    do\n                    {\n                        id = store.getRecordValue( cursor, MetaDataStore.Position.UPGRADE_TRANSACTION_ID );\n                        checksum = store.getRecordValue( cursor, MetaDataStore.Position.UPGRADE_TRANSACTION_CHECKSUM );\n                    }\n                    while ( cursor.shouldRetry() );\n                    assertIdEqualsChecksum( id, checksum, \"file\" );\n                    fileReadCount.incrementAndGet();\n                }\n            } ) ) );\n\n            race.addContestants( 3, until( end, () -> {\n                TransactionId transaction = store.getUpgradeTransaction();\n                assertIdEqualsChecksum( transaction.transactionId(), transaction.checksum(), \"API\" );\n                apiReadCount.incrementAndGet();\n            } ) );\n            race.go();\n        }\n    }","id":556,"modified_method":"@Test\n    public void setUpgradeTransactionMustBeAtomic() throws Throwable\n    {\n        try ( MetaDataStore store = newMetaDataStore() )\n        {\n            PagedFile pf = store.storeFile;\n            store.setUpgradeTransaction( 0, 0, 0 );\n            AtomicLong writeCount = new AtomicLong();\n            AtomicLong fileReadCount = new AtomicLong();\n            AtomicLong apiReadCount = new AtomicLong();\n            int upperLimit = 10_000;\n            int lowerLimit = 100;\n            long endTime = currentTimeMillis() + SECONDS.toMillis( 10 );\n\n            Race race = new Race();\n            race.withEndCondition( () -> writeCount.get() >= upperLimit &&\n                    fileReadCount.get() >= upperLimit && apiReadCount.get() >= upperLimit );\n            race.withEndCondition( () -> writeCount.get() >= lowerLimit &&\n                    fileReadCount.get() >= lowerLimit && apiReadCount.get() >= lowerLimit &&\n                    currentTimeMillis() >= endTime );\n            // writers\n            race.addContestants( 3, () -> {\n                long count = writeCount.incrementAndGet();\n                store.setUpgradeTransaction( count, count, count );\n            } );\n\n            // file readers\n            race.addContestants( 3, throwing( () -> {\n                try ( PageCursor cursor = pf.io( 0, PagedFile.PF_SHARED_READ_LOCK ) )\n                {\n                    assertTrue( cursor.next() );\n                    long id, checksum;\n                    do\n                    {\n                        id = store.getRecordValue( cursor, MetaDataStore.Position.UPGRADE_TRANSACTION_ID );\n                        checksum = store.getRecordValue( cursor, MetaDataStore.Position.UPGRADE_TRANSACTION_CHECKSUM );\n                    }\n                    while ( cursor.shouldRetry() );\n                    assertIdEqualsChecksum( id, checksum, \"file\" );\n                    fileReadCount.incrementAndGet();\n                }\n            } ) );\n\n            race.addContestants( 3, () -> {\n                TransactionId transaction = store.getUpgradeTransaction();\n                assertIdEqualsChecksum( transaction.transactionId(), transaction.checksum(), \"API\" );\n                apiReadCount.incrementAndGet();\n            } );\n            race.go();\n        }\n    }","commit_id":"321846e9c1416ab29b7d37dcb7024f2ebd2a8562","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void transactionCommittedMustBeAtomic() throws Throwable\n    {\n        try ( MetaDataStore store = newMetaDataStore() )\n        {\n            PagedFile pf = store.storeFile;\n            store.transactionCommitted( 2, 2, 2 );\n            AtomicLong writeCount = new AtomicLong();\n            AtomicLong fileReadCount = new AtomicLong();\n            AtomicLong apiReadCount = new AtomicLong();\n            int upperLimit = 10_000;\n            int lowerLimit = 100;\n            long endTime = currentTimeMillis() + SECONDS.toMillis( 10 );\n\n            BooleanSupplier end = () ->\n            {\n                boolean upperBoundReached = writeCount.get() >= upperLimit &&\n                        fileReadCount.get() >= upperLimit && apiReadCount.get() >= upperLimit;\n                boolean lowerBoundReached = writeCount.get() >= lowerLimit &&\n                        fileReadCount.get() >= lowerLimit && apiReadCount.get() >= lowerLimit;\n                return !upperBoundReached || (currentTimeMillis() >= endTime && lowerBoundReached);\n            };\n            Race race = new Race();\n            race.addContestants( 3, until( end, () ->\n            {\n                long count = writeCount.incrementAndGet();\n                store.transactionCommitted( count, count, count );\n            } ) );\n\n            race.addContestants( 3, until( end, throwing( () -> {\n                try ( PageCursor cursor = pf.io( 0, PagedFile.PF_SHARED_READ_LOCK ) )\n                {\n                    assertTrue( cursor.next() );\n                    long id, checksum;\n                    do\n                    {\n                        id = store.getRecordValue( cursor, MetaDataStore.Position.LAST_TRANSACTION_ID );\n                        checksum = store.getRecordValue( cursor, MetaDataStore.Position.LAST_TRANSACTION_CHECKSUM );\n                    }\n                    while ( cursor.shouldRetry() );\n                    assertIdEqualsChecksum( id, checksum, \"file\" );\n                    fileReadCount.incrementAndGet();\n                }\n            } ) ) );\n\n            race.addContestants( 3, until( end, () ->\n            {\n                TransactionId transaction = store.getLastCommittedTransaction();\n                assertIdEqualsChecksum( transaction.transactionId(), transaction.checksum(), \"API\" );\n                apiReadCount.incrementAndGet();\n            } ) );\n\n            race.go();\n        }\n    }","id":557,"modified_method":"@Test\n    public void transactionCommittedMustBeAtomic() throws Throwable\n    {\n        try ( MetaDataStore store = newMetaDataStore() )\n        {\n            PagedFile pf = store.storeFile;\n            store.transactionCommitted( 2, 2, 2 );\n            AtomicLong writeCount = new AtomicLong();\n            AtomicLong fileReadCount = new AtomicLong();\n            AtomicLong apiReadCount = new AtomicLong();\n            int upperLimit = 10_000;\n            int lowerLimit = 100;\n            long endTime = currentTimeMillis() + SECONDS.toMillis( 10 );\n\n            Race race = new Race();\n            race.withEndCondition( () -> writeCount.get() >= upperLimit &&\n                    fileReadCount.get() >= upperLimit && apiReadCount.get() >= upperLimit );\n            race.withEndCondition( () -> writeCount.get() >= lowerLimit &&\n                    fileReadCount.get() >= lowerLimit && apiReadCount.get() >= lowerLimit &&\n                    currentTimeMillis() >= endTime );\n            race.addContestants( 3, () ->\n            {\n                long count = writeCount.incrementAndGet();\n                store.transactionCommitted( count, count, count );\n            } );\n\n            race.addContestants( 3, throwing( () -> {\n                try ( PageCursor cursor = pf.io( 0, PagedFile.PF_SHARED_READ_LOCK ) )\n                {\n                    assertTrue( cursor.next() );\n                    long id, checksum;\n                    do\n                    {\n                        id = store.getRecordValue( cursor, MetaDataStore.Position.LAST_TRANSACTION_ID );\n                        checksum = store.getRecordValue( cursor, MetaDataStore.Position.LAST_TRANSACTION_CHECKSUM );\n                    }\n                    while ( cursor.shouldRetry() );\n                    assertIdEqualsChecksum( id, checksum, \"file\" );\n                    fileReadCount.incrementAndGet();\n                }\n            } ) );\n\n            race.addContestants( 3, () ->\n            {\n                TransactionId transaction = store.getLastCommittedTransaction();\n                assertIdEqualsChecksum( transaction.transactionId(), transaction.checksum(), \"API\" );\n                apiReadCount.incrementAndGet();\n            } );\n\n            race.go();\n        }\n    }","commit_id":"321846e9c1416ab29b7d37dcb7024f2ebd2a8562","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void transactionClosedMustBeAtomic() throws Throwable\n    {\n        try ( MetaDataStore store = newMetaDataStore() )\n        {\n            PagedFile pf = store.storeFile;\n            int initialValue = 2;\n            store.transactionClosed( initialValue, initialValue, initialValue );\n            AtomicLong writeCount = new AtomicLong();\n            AtomicLong fileReadCount = new AtomicLong();\n            AtomicLong apiReadCount = new AtomicLong();\n            int upperLimit = 10_000;\n            int lowerLimit = 100;\n            long endTime = currentTimeMillis() + SECONDS.toMillis( 10 );\n\n            BooleanSupplier end = () ->\n            {\n                boolean upperBoundReached = writeCount.get() >= upperLimit &&\n                        fileReadCount.get() >= upperLimit && apiReadCount.get() >= upperLimit;\n                boolean lowerBoundReached = writeCount.get() >= lowerLimit &&\n                        fileReadCount.get() >= lowerLimit && apiReadCount.get() >= lowerLimit;\n                return !upperBoundReached || (currentTimeMillis() >= endTime && lowerBoundReached);\n            };\n            Race race = new Race();\n            race.addContestants( 3, until( end, () -> {\n                long count = writeCount.incrementAndGet();\n                store.transactionCommitted( count, count, count );\n            } ) );\n\n            race.addContestants( 3, until( end, throwing( () -> {\n                try ( PageCursor cursor = pf.io( 0, PagedFile.PF_SHARED_READ_LOCK ) )\n                {\n                    assertTrue( cursor.next() );\n                    long logVersion, byteOffset;\n                    do\n                    {\n                        logVersion = store.getRecordValue( cursor,\n                                MetaDataStore.Position.LAST_CLOSED_TRANSACTION_LOG_VERSION );\n                        byteOffset = store.getRecordValue( cursor,\n                                MetaDataStore.Position.LAST_CLOSED_TRANSACTION_LOG_BYTE_OFFSET );\n                    }\n                    while ( cursor.shouldRetry() );\n                    assertLogVersionEqualsByteOffset( logVersion, byteOffset, \"file\" );\n                    fileReadCount.incrementAndGet();\n                }\n            } ) ) );\n\n            race.addContestants( 3, until( end, () -> {\n                long[] transaction = store.getLastClosedTransaction();\n                assertLogVersionEqualsByteOffset( transaction[0], transaction[1], \"API\" );\n                apiReadCount.incrementAndGet();\n            } ) );\n            race.go();\n        }\n    }","id":558,"modified_method":"@Test\n    public void transactionClosedMustBeAtomic() throws Throwable\n    {\n        try ( MetaDataStore store = newMetaDataStore() )\n        {\n            PagedFile pf = store.storeFile;\n            int initialValue = 2;\n            store.transactionClosed( initialValue, initialValue, initialValue );\n            AtomicLong writeCount = new AtomicLong();\n            AtomicLong fileReadCount = new AtomicLong();\n            AtomicLong apiReadCount = new AtomicLong();\n            int upperLimit = 10_000;\n            int lowerLimit = 100;\n            long endTime = currentTimeMillis() + SECONDS.toMillis( 10 );\n\n            Race race = new Race();\n            race.withEndCondition( () -> writeCount.get() >= upperLimit &&\n                    fileReadCount.get() >= upperLimit && apiReadCount.get() >= upperLimit );\n            race.withEndCondition( () -> writeCount.get() >= lowerLimit &&\n                    fileReadCount.get() >= lowerLimit && apiReadCount.get() >= lowerLimit &&\n                    currentTimeMillis() >= endTime );\n            race.addContestants( 3, () -> {\n                long count = writeCount.incrementAndGet();\n                store.transactionCommitted( count, count, count );\n            } );\n\n            race.addContestants( 3, throwing( () -> {\n                try ( PageCursor cursor = pf.io( 0, PagedFile.PF_SHARED_READ_LOCK ) )\n                {\n                    assertTrue( cursor.next() );\n                    long logVersion, byteOffset;\n                    do\n                    {\n                        logVersion = store.getRecordValue( cursor,\n                                MetaDataStore.Position.LAST_CLOSED_TRANSACTION_LOG_VERSION );\n                        byteOffset = store.getRecordValue( cursor,\n                                MetaDataStore.Position.LAST_CLOSED_TRANSACTION_LOG_BYTE_OFFSET );\n                    }\n                    while ( cursor.shouldRetry() );\n                    assertLogVersionEqualsByteOffset( logVersion, byteOffset, \"file\" );\n                    fileReadCount.incrementAndGet();\n                }\n            } ) );\n\n            race.addContestants( 3, () -> {\n                long[] transaction = store.getLastClosedTransaction();\n                assertLogVersionEqualsByteOffset( transaction[0], transaction[1], \"API\" );\n                apiReadCount.incrementAndGet();\n            } );\n            race.go();\n        }\n    }","commit_id":"321846e9c1416ab29b7d37dcb7024f2ebd2a8562","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Creates a new result list item with a main widget.<p>\n     * \n     * @param resultItem the result item\n     * @param dndHandler the drag and drop handler\n     */\n    public CmsResultListItem(CmsResultItemBean resultItem, CmsDNDHandler dndHandler) {\n\n        resultItem.addAdditionalInfo(Messages.get().key(Messages.GUI_PREVIEW_LABEL_PATH_0), resultItem.getPath());\n        CmsResultItemWidget resultItemWidget = new CmsResultItemWidget(resultItem);\n        initContent(resultItemWidget);\n        if (dndHandler != null) {\n            setId(resultItem.getClientId());\n            if (resultItem.getTitle() != null) {\n                setName(resultItem.getTitle().toLowerCase().replace(\"/\", \"-\").replace(\" \", \"_\"));\n            } else {\n                // TODO: check if another name makes more sense\n                setName(resultItem.getClientId());\n            }\n            initMoveHandle(dndHandler);\n        } else {\n            if (resultItemWidget.hasTileView()) {\n                addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().tilingItem());\n            }\n        }\n        // add delete button\n        m_deleteButton = createDeleteButton();\n        if (!resultItem.isEditable()) {\n            m_deleteButton.disable(resultItem.getNoEditReson());\n        }\n        resultItemWidget.addButton(m_deleteButton);\n\n        // add  preview button\n        m_previewButton = new CmsPushButton();\n        m_previewButton.setImageClass(I_CmsImageBundle.INSTANCE.style().searchIcon());\n        m_previewButton.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n        m_previewButton.setTitle(Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SHOW_0));\n        resultItemWidget.addButton(m_previewButton);\n\n        m_selectButton = new CmsPushButton();\n        // TODO: use different icon\n        m_selectButton.setImageClass(I_CmsImageBundle.INSTANCE.style().addIcon());\n        m_selectButton.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n        m_selectButton.setTitle(Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SELECT_0));\n        m_selectButton.setVisible(false);\n        resultItemWidget.addButton(m_selectButton);\n\n        // add file icon\n        resultItemWidget.setIcon(CmsIconUtil.getResourceIconClasses(resultItem.getType(), resultItem.getPath(), false));\n        if (!resultItem.isReleasedAndNotExpired()) {\n            addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().expired());\n        }\n    }","id":559,"modified_method":"/**\n     * Creates a new result list item with a main widget.<p>\n     * \n     * @param resultItem the result item\n     * @param dndHandler the drag and drop handler\n     */\n    public CmsResultListItem(CmsResultItemBean resultItem, CmsDNDHandler dndHandler) {\n\n        resultItem.addAdditionalInfo(Messages.get().key(Messages.GUI_PREVIEW_LABEL_PATH_0), resultItem.getPath());\n        CmsResultItemWidget resultItemWidget = new CmsResultItemWidget(resultItem);\n        initContent(resultItemWidget);\n        if (dndHandler != null) {\n            setId(resultItem.getClientId());\n            if (resultItem.getTitle() != null) {\n                setName(resultItem.getTitle().toLowerCase().replace(\"/\", \"-\").replace(\" \", \"_\"));\n            } else {\n                // TODO: check if another name makes more sense\n                setName(resultItem.getClientId());\n            }\n            initMoveHandle(dndHandler);\n        } else {\n            if (resultItemWidget.hasTileView()) {\n                addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().tilingItem());\n            }\n        }\n        // add delete button\n        m_deleteButton = createDeleteButton();\n        if (!resultItem.isEditable()) {\n            m_deleteButton.disable(resultItem.getNoEditReson());\n        }\n        resultItemWidget.addButton(m_deleteButton);\n\n        // add  preview button\n        m_previewButton = createButton(\n            I_CmsImageBundle.INSTANCE.style().searchIcon(),\n            Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SHOW_0));\n        resultItemWidget.addButton(m_previewButton);\n\n        m_selectButton = createButton(\n            I_CmsImageBundle.INSTANCE.style().addIcon(),\n            Messages.get().key(Messages.GUI_PREVIEW_BUTTON_SELECT_0));\n        m_selectButton.setVisible(false);\n        resultItemWidget.addButton(m_selectButton);\n\n        // add file icon\n        resultItemWidget.setIcon(CmsIconUtil.getResourceIconClasses(resultItem.getType(), resultItem.getPath(), false));\n        if (!resultItem.isReleasedAndNotExpired()) {\n            addStyleName(I_CmsLayoutBundle.INSTANCE.galleryResultItemCss().expired());\n        }\n    }","commit_id":"2614485d15430b4a23142a7e2cd36d3016cc4b4b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates the delete button for this item.<p>\n     * \n     * @return the delete button\n     */\n    public static CmsPushButton createDeleteButton() {\n\n        CmsPushButton result = new CmsPushButton();\n        result.setImageClass(I_CmsImageBundle.INSTANCE.style().deleteIcon());\n        result.setButtonStyle(ButtonStyle.TRANSPARENT, null);\n        result.setTitle(Messages.get().key(Messages.GUI_RESULT_BUTTON_DELETE_0));\n        return result;\n    }","id":560,"modified_method":"/**\n     * Creates the delete button for this item.<p>\n     * \n     * @return the delete button\n     */\n    public static CmsPushButton createDeleteButton() {\n\n        return createButton(\n            I_CmsImageBundle.INSTANCE.style().deleteIcon(),\n            Messages.get().key(Messages.GUI_RESULT_BUTTON_DELETE_0));\n    }","commit_id":"2614485d15430b4a23142a7e2cd36d3016cc4b4b","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Test\n\tpublic void testPortalAuthenticationToken() throws Exception {\n\t\ttestPortlet = new TestPortlet() {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = resourceResponse.createActionURL();\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portalAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_auth\");\n\n\t\t\t\tprintWriter.write(portalAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tsetUpPortlet(\n\t\t\ttestPortlet, new HashMapDictionary<String, Object>(),\n\t\t\tTEST_PORTLET_ID);\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tResponse response = PortletContainerTestUtil.getPortalAuthentication(\n\t\t\thttpServletRequest, layout, TEST_PORTLET_ID);\n\n\t\ttestPortlet.reset();\n\n\t\t// Make an action request using the portal authentication token\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(url, \"p_auth\", response.getBody());\n\n\t\tMap<String, List<String>> headers = new HashMap<>();\n\n\t\theaders.put(\"Cookie\", response.getCookies());\n\n\t\tresponse = PortletContainerTestUtil.request(url, headers);\n\n\t\tAssert.assertEquals(200, response.getCode());\n\t\tAssert.assertTrue(testPortlet.isActionCalled());\n\t}","id":561,"modified_method":"@Test\n\tpublic void testPortalAuthenticationToken() throws Exception {\n\t\ttestPortlet = new TestPortlet() {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = resourceResponse.createActionURL();\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portalAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_auth\");\n\n\t\t\t\tprintWriter.write(portalAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tsetUpPortlet(\n\t\t\ttestPortlet, new HashMapDictionary<String, Object>(),\n\t\t\tTEST_PORTLET_ID);\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tResponse response = PortletContainerTestUtil.getPortalAuthentication(\n\t\t\thttpServletRequest, layout, TEST_PORTLET_ID);\n\n\t\ttestPortlet.reset();\n\n\t\t// Make an action request using the portal authentication token\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.ACTION_PHASE);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(url, \"p_auth\", response.getBody());\n\n\t\tresponse = PortletContainerTestUtil.request(\n\t\t\turl, Collections.singletonMap(\"Cookie\", response.getCookies()));\n\n\t\tAssert.assertEquals(200, response.getCode());\n\t\tAssert.assertTrue(testPortlet.isActionCalled());\n\t}","commit_id":"15c306ec0633d2c35887f333ac6b21d15689d403","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testIsAccessGrantedByPortletAuthenticationToken()\n\t\tthrows Exception {\n\n\t\tfinal String testTargetPortletId = \"testTargetPortletId\";\n\n\t\tDictionary<String, Object> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\t\"com.liferay.portlet.add-default-resource\", Boolean.TRUE);\n\t\tproperties.put(\"com.liferay.portlet.system\", Boolean.TRUE);\n\n\t\tTestPortlet testTargetPortlet = new TestPortlet();\n\n\t\tsetUpPortlet(testTargetPortlet, properties, testTargetPortletId, false);\n\n\t\ttestPortlet = new TestPortlet() {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tresourceRequest, testTargetPortletId, layout.getPlid(),\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portletAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_p_auth\");\n\n\t\t\t\tprintWriter.write(portletAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tproperties = new HashMapDictionary<>();\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\t// Get the portlet authentication token by making a resource request\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tResponse response = PortletContainerTestUtil.request(\n\t\t\tportletURL.toString());\n\n\t\ttestTargetPortlet.reset();\n\n\t\t// Make a render request to the target portlet using the portlet\n\t\t// authentication token\n\n\t\tportletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, testTargetPortletId, layout.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(url, \"p_p_auth\", response.getBody());\n\n\t\tMap<String, List<String>> headers = new HashMap<>();\n\n\t\theaders.put(\"Cookie\", response.getCookies());\n\n\t\tresponse = PortletContainerTestUtil.request(url, headers);\n\n\t\tAssert.assertEquals(200, response.getCode());\n\t\tAssert.assertTrue(testTargetPortlet.isRenderCalled());\n\t}","id":562,"modified_method":"@Test\n\tpublic void testIsAccessGrantedByPortletAuthenticationToken()\n\t\tthrows Exception {\n\n\t\tfinal String testTargetPortletId = \"testTargetPortletId\";\n\n\t\tDictionary<String, Object> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\t\"com.liferay.portlet.add-default-resource\", Boolean.TRUE);\n\t\tproperties.put(\"com.liferay.portlet.system\", Boolean.TRUE);\n\n\t\tTestPortlet testTargetPortlet = new TestPortlet();\n\n\t\tsetUpPortlet(testTargetPortlet, properties, testTargetPortletId, false);\n\n\t\ttestPortlet = new TestPortlet() {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tresourceRequest, testTargetPortletId, layout.getPlid(),\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portletAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_p_auth\");\n\n\t\t\t\tprintWriter.write(portletAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tproperties = new HashMapDictionary<>();\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\t// Get the portlet authentication token by making a resource request\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tResponse response = PortletContainerTestUtil.request(\n\t\t\tportletURL.toString());\n\n\t\ttestTargetPortlet.reset();\n\n\t\t// Make a render request to the target portlet using the portlet\n\t\t// authentication token\n\n\t\tportletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, testTargetPortletId, layout.getPlid(),\n\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(url, \"p_p_auth\", response.getBody());\n\n\t\tresponse = PortletContainerTestUtil.request(\n\t\t\turl, Collections.singletonMap(\"Cookie\", response.getCookies()));\n\n\t\tAssert.assertEquals(200, response.getCode());\n\t\tAssert.assertTrue(testTargetPortlet.isRenderCalled());\n\t}","commit_id":"15c306ec0633d2c35887f333ac6b21d15689d403","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testIsAccessGrantedByPortletAuthenticationToken()\n\t\tthrows Exception {\n\n\t\tfinal String testTargetPortletId = \"testTargetPortletId\";\n\n\t\tDictionary<String, Object> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\t\"com.liferay.portlet.add-default-resource\", Boolean.TRUE);\n\t\tproperties.put(\"com.liferay.portlet.system\", Boolean.TRUE);\n\n\t\tTestPortlet testTargetPortlet = new TestPortlet();\n\n\t\tsetUpPortlet(testTargetPortlet, properties, testTargetPortletId, false);\n\n\t\ttestPortlet = new TestPortlet() {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tresourceRequest, testTargetPortletId, layout.getPlid(),\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portletAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_p_auth\");\n\n\t\t\t\tprintWriter.write(portletAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tproperties = new HashMapDictionary<>();\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\t// Get the portlet authentication token by making a resource request\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tResponse response = PortletContainerTestUtil.request(\n\t\t\tportletURL.toString());\n\n\t\ttestTargetPortlet.reset();\n\n\t\t// Make a resource request to the target portlet using the portlet\n\t\t// authentication token\n\n\t\tportletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, testTargetPortletId, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(url, \"p_p_auth\", response.getBody());\n\n\t\tMap<String, List<String>> headers = new HashMap<>();\n\n\t\theaders.put(\"Cookie\", response.getCookies());\n\n\t\tresponse = PortletContainerTestUtil.request(url, headers);\n\n\t\tAssert.assertEquals(200, response.getCode());\n\t\tAssert.assertTrue(testTargetPortlet.isResourceCalled());\n\t}","id":563,"modified_method":"@Test\n\tpublic void testIsAccessGrantedByPortletAuthenticationToken()\n\t\tthrows Exception {\n\n\t\tfinal String testTargetPortletId = \"testTargetPortletId\";\n\n\t\tDictionary<String, Object> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\t\"com.liferay.portlet.add-default-resource\", Boolean.TRUE);\n\t\tproperties.put(\"com.liferay.portlet.system\", Boolean.TRUE);\n\n\t\tTestPortlet testTargetPortlet = new TestPortlet();\n\n\t\tsetUpPortlet(testTargetPortlet, properties, testTargetPortletId, false);\n\n\t\ttestPortlet = new TestPortlet() {\n\n\t\t\t@Override\n\t\t\tpublic void serveResource(\n\t\t\t\t\tResourceRequest resourceRequest,\n\t\t\t\t\tResourceResponse resourceResponse)\n\t\t\t\tthrows IOException {\n\n\t\t\t\tPrintWriter printWriter = resourceResponse.getWriter();\n\n\t\t\t\tPortletURL portletURL = PortletURLFactoryUtil.create(\n\t\t\t\t\tresourceRequest, testTargetPortletId, layout.getPlid(),\n\t\t\t\t\tPortletRequest.RENDER_PHASE);\n\n\t\t\t\tString queryString = HttpUtil.getQueryString(\n\t\t\t\t\tportletURL.toString());\n\n\t\t\t\tMap<String, String[]> parameterMap = HttpUtil.getParameterMap(\n\t\t\t\t\tqueryString);\n\n\t\t\t\tString portletAuthenticationToken = MapUtil.getString(\n\t\t\t\t\tparameterMap, \"p_p_auth\");\n\n\t\t\t\tprintWriter.write(portletAuthenticationToken);\n\t\t\t}\n\n\t\t};\n\n\t\tproperties = new HashMapDictionary<>();\n\n\t\tsetUpPortlet(testPortlet, properties, TEST_PORTLET_ID);\n\n\t\t// Get the portlet authentication token by making a resource request\n\n\t\tHttpServletRequest httpServletRequest =\n\t\t\tPortletContainerTestUtil.getHttpServletRequest(group, layout);\n\n\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, TEST_PORTLET_ID, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tResponse response = PortletContainerTestUtil.request(\n\t\t\tportletURL.toString());\n\n\t\ttestTargetPortlet.reset();\n\n\t\t// Make a resource request to the target portlet using the portlet\n\t\t// authentication token\n\n\t\tportletURL = new PortletURLImpl(\n\t\t\thttpServletRequest, testTargetPortletId, layout.getPlid(),\n\t\t\tPortletRequest.RESOURCE_PHASE);\n\n\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\tString url = portletURL.toString();\n\n\t\turl = HttpUtil.setParameter(url, \"p_p_auth\", response.getBody());\n\n\t\tresponse = PortletContainerTestUtil.request(\n\t\t\turl, Collections.singletonMap(\"Cookie\", response.getCookies()));\n\n\t\tAssert.assertEquals(200, response.getCode());\n\t\tAssert.assertTrue(testTargetPortlet.isResourceCalled());\n\t}","commit_id":"15c306ec0633d2c35887f333ac6b21d15689d403","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doReIndex(int delay) {\n\t\tif (SearchEngineUtil.isIndexReadOnly()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Reindexing Lucene started\");\n\t\t}\n\n\t\tif (delay < 0) {\n\t\t\tdelay = 0;\n\t\t}\n\n\t\ttry {\n\t\t\tif (delay > 0) {\n\t\t\t\tThread.sleep(Time.SECOND * delay);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\n\t\tStopWatch stopWatch1 = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch1 = new StopWatch();\n\n\t\t\tstopWatch1.start();\n\t\t}\n\n\t\tLuceneUtil.delete(_companyId);\n\n\t\ttry {\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(_companyId, true);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(ioe.getMessage(), ioe);\n\t\t}\n\n\t\tString[] indexIds = new String[] {String.valueOf(_companyId)};\n\n\t\ttry {\n\t\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets(\n\t\t\t\t_companyId);\n\n\t\t\tportlets = ListUtil.sort(portlets, new PortletLuceneComparator());\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (!portlet.isActive()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\t\tif (indexer == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString indexerClass = portlet.getIndexerClass();\n\n\t\t\t\tStopWatch stopWatch2 = null;\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tstopWatch2 = new StopWatch();\n\n\t\t\t\t\tstopWatch2.start();\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Reindexing with \" + indexerClass + \" started\");\n\t\t\t\t}\n\n\t\t\t\tindexer.reIndex(indexIds);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Reindexing with \" + indexerClass + \" completed in \" +\n\t\t\t\t\t\t\t(stopWatch2.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Reindexing Lucene completed in \" +\n\t\t\t\t\t\t(stopWatch1.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error encountered while reindexing\", e);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Reindexing Lucene failed\");\n\t\t\t}\n\t\t}\n\n\t\t_finished = true;\n\t}","id":564,"modified_method":"protected void doReIndex(int delay) {\n\t\tif (SearchEngineUtil.isIndexReadOnly()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Reindexing Lucene started\");\n\t\t}\n\n\t\tif (delay < 0) {\n\t\t\tdelay = 0;\n\t\t}\n\n\t\ttry {\n\t\t\tif (delay > 0) {\n\t\t\t\tThread.sleep(Time.SECOND * delay);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\n\t\tStopWatch stopWatch1 = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch1 = new StopWatch();\n\n\t\t\tstopWatch1.start();\n\t\t}\n\n\t\tString[] indexIds = new String[] {String.valueOf(_companyId)};\n\n\t\ttry {\n\t\t\tLuceneUtil.delete(_companyId);\n\t\t\tLuceneUtil.checkLuceneDir(_companyId);\n\n\t\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets(\n\t\t\t\t_companyId);\n\n\t\t\tportlets = ListUtil.sort(portlets, new PortletLuceneComparator());\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (!portlet.isActive()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\t\tif (indexer == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString indexerClass = portlet.getIndexerClass();\n\n\t\t\t\tStopWatch stopWatch2 = null;\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tstopWatch2 = new StopWatch();\n\n\t\t\t\t\tstopWatch2.start();\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Reindexing with \" + indexerClass + \" started\");\n\t\t\t\t}\n\n\t\t\t\tindexer.reIndex(indexIds);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Reindexing with \" + indexerClass + \" completed in \" +\n\t\t\t\t\t\t\t(stopWatch2.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Reindexing Lucene completed in \" +\n\t\t\t\t\t\t(stopWatch1.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error encountered while reindexing\", e);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Reindexing Lucene failed\");\n\t\t\t}\n\t\t}\n\n\t\t_finished = true;\n\t}","commit_id":"c78fffd7744b50b09eeb4a533022173806ba277a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doReIndex(int delay) {\n\t\tif (SearchEngineUtil.isIndexReadOnly()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Reindexing Lucene started\");\n\t\t}\n\n\t\tif (delay < 0) {\n\t\t\tdelay = 0;\n\t\t}\n\n\t\ttry {\n\t\t\tif (delay > 0) {\n\t\t\t\tThread.sleep(Time.SECOND * delay);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\n\t\tStopWatch stopWatch1 = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch1 = new StopWatch();\n\n\t\t\tstopWatch1.start();\n\t\t}\n\n\t\tString[] indexIds = new String[] {String.valueOf(_companyId)};\n\n\t\ttry {\n\t\t\tLuceneUtil.delete(_companyId);\n\t\t\tLuceneUtil.checkLuceneDir(_companyId);\n\n\t\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets(\n\t\t\t\t_companyId);\n\n\t\t\tportlets = ListUtil.sort(portlets, new PortletLuceneComparator());\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (!portlet.isActive()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\t\tif (indexer == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString indexerClass = portlet.getIndexerClass();\n\n\t\t\t\tStopWatch stopWatch2 = null;\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tstopWatch2 = new StopWatch();\n\n\t\t\t\t\tstopWatch2.start();\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Reindexing with \" + indexerClass + \" started\");\n\t\t\t\t}\n\n\t\t\t\tindexer.reIndex(indexIds);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Reindexing with \" + indexerClass + \" completed in \" +\n\t\t\t\t\t\t\t(stopWatch2.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Reindexing Lucene completed in \" +\n\t\t\t\t\t\t(stopWatch1.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error encountered while reindexing\", e);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Reindexing Lucene failed\");\n\t\t\t}\n\t\t}\n\n\t\t_finished = true;\n\t}","id":565,"modified_method":"protected void doReIndex(int delay) {\n\t\tif (SearchEngineUtil.isIndexReadOnly()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Reindexing Lucene started\");\n\t\t}\n\n\t\tif (delay < 0) {\n\t\t\tdelay = 0;\n\t\t}\n\n\t\ttry {\n\t\t\tif (delay > 0) {\n\t\t\t\tThread.sleep(Time.SECOND * delay);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\n\t\tStopWatch stopWatch1 = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch1 = new StopWatch();\n\n\t\t\tstopWatch1.start();\n\t\t}\n\n\t\tLuceneUtil.delete(_companyId);\n\n\t\ttry {\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(_companyId, true);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(ioe.getMessage(), ioe);\n\t\t}\n\n\t\tString[] indexIds = new String[] {String.valueOf(_companyId)};\n\n\t\ttry {\n\t\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets(\n\t\t\t\t_companyId);\n\n\t\t\tportlets = ListUtil.sort(portlets, new PortletLuceneComparator());\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (!portlet.isActive()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\t\tif (indexer == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString indexerClass = portlet.getIndexerClass();\n\n\t\t\t\tStopWatch stopWatch2 = null;\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tstopWatch2 = new StopWatch();\n\n\t\t\t\t\tstopWatch2.start();\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Reindexing with \" + indexerClass + \" started\");\n\t\t\t\t}\n\n\t\t\t\tindexer.reIndex(indexIds);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Reindexing with \" + indexerClass + \" completed in \" +\n\t\t\t\t\t\t\t(stopWatch2.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Reindexing Lucene completed in \" +\n\t\t\t\t\t\t(stopWatch1.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error encountered while reindexing\", e);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Reindexing Lucene failed\");\n\t\t\t}\n\t\t}\n\n\t\t_finished = true;\n\t}","commit_id":"353e18d91756f2b6146bc97f6b4fc3015e52a988","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doReIndex(int delay) {\n\t\tif (SearchEngineUtil.isIndexReadOnly()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Reindexing Lucene started\");\n\t\t}\n\n\t\tif (delay < 0) {\n\t\t\tdelay = 0;\n\t\t}\n\n\t\ttry {\n\t\t\tif (delay > 0) {\n\t\t\t\tThread.sleep(Time.SECOND * delay);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\n\t\tStopWatch stopWatch1 = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch1 = new StopWatch();\n\n\t\t\tstopWatch1.start();\n\t\t}\n\n\t\tLuceneUtil.delete(_companyId);\n\n\t\ttry {\n\t\t\tIndexWriter writer = LuceneUtil.getWriter(_companyId, true);\n\n\t\t\tLuceneUtil.write(writer);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\t_log.error(ioe.getMessage(), ioe);\n\t\t}\n\n\t\tString[] indexIds = new String[] {String.valueOf(_companyId)};\n\n\t\ttry {\n\t\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets(\n\t\t\t\t_companyId);\n\n\t\t\tportlets = ListUtil.sort(portlets, new PortletLuceneComparator());\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (!portlet.isActive()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\t\tif (indexer == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString indexerClass = portlet.getIndexerClass();\n\n\t\t\t\tStopWatch stopWatch2 = null;\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tstopWatch2 = new StopWatch();\n\n\t\t\t\t\tstopWatch2.start();\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Reindexing with \" + indexerClass + \" started\");\n\t\t\t\t}\n\n\t\t\t\tindexer.reIndex(indexIds);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Reindexing with \" + indexerClass + \" completed in \" +\n\t\t\t\t\t\t\t(stopWatch2.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Reindexing Lucene completed in \" +\n\t\t\t\t\t\t(stopWatch1.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error encountered while reindexing\", e);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Reindexing Lucene failed\");\n\t\t\t}\n\t\t}\n\n\t\t_finished = true;\n\t}","id":566,"modified_method":"protected void doReIndex(int delay) {\n\t\tif (SearchEngineUtil.isIndexReadOnly()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Reindexing Lucene started\");\n\t\t}\n\n\t\tif (delay < 0) {\n\t\t\tdelay = 0;\n\t\t}\n\n\t\ttry {\n\t\t\tif (delay > 0) {\n\t\t\t\tThread.sleep(Time.SECOND * delay);\n\t\t\t}\n\t\t}\n\t\tcatch (InterruptedException ie) {\n\t\t}\n\n\t\tStopWatch stopWatch1 = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch1 = new StopWatch();\n\n\t\t\tstopWatch1.start();\n\t\t}\n\n\t\ttry {\n\t\t\tLuceneHelperUtil.delete(_companyId);\n\t\t\tLuceneHelperUtil.checkLuceneDir(_companyId);\n\n\t\t\tList<Portlet> portlets = PortletLocalServiceUtil.getPortlets(\n\t\t\t\t_companyId);\n\n\t\t\tportlets = ListUtil.sort(portlets, new PortletLuceneComparator());\n\n\t\t\tfor (Portlet portlet : portlets) {\n\t\t\t\tif (!portlet.isActive()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\t\tif (indexer == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString indexerClass = portlet.getIndexerClass();\n\n\t\t\t\tStopWatch stopWatch2 = null;\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tstopWatch2 = new StopWatch();\n\n\t\t\t\t\tstopWatch2.start();\n\t\t\t\t}\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Reindexing with \" + indexerClass + \" started\");\n\t\t\t\t}\n\n\t\t\t\tindexer.reIndex(new String[] {String.valueOf(_companyId)});\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Reindexing with \" + indexerClass + \" completed in \" +\n\t\t\t\t\t\t\t(stopWatch2.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Reindexing Lucene completed in \" +\n\t\t\t\t\t\t(stopWatch1.getTime() / Time.SECOND) + \" seconds\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Error encountered while reindexing\", e);\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"Reindexing Lucene failed\");\n\t\t\t}\n\t\t}\n\n\t\t_finished = true;\n\t}","commit_id":"d10a7d0afefe34b875268dc97597fb8238252319","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Check out.\n     *\n     * @param lengthToWrite\n     *            the length\n     * @throws IOException\n     *             Signals that an I/O exception has occurred.\n     */\n    private void checkOut(int lengthToWrite) throws IOException\n    {\n        if (_closed)\n            throw new IOException(\"CLOSED\");\n\n        if (_out == null)\n        {\n            long length=_wrapper.getContentLength();\n            if (_response.isCommitted() || (length >= 0 && length < _wrapper.getMinCompressSize()))\n                doNotCompress(false);\n            else if (lengthToWrite > _wrapper.getMinCompressSize())\n                doCompress();\n            else\n                _out = _bOut = new ByteArrayOutputStream2(_wrapper.getBufferSize());\n        }\n        else if (_bOut != null)\n        {\n            long length=_wrapper.getContentLength();\n            if (_response.isCommitted() || (length >= 0 && length < _wrapper.getMinCompressSize()))\n                doNotCompress(false);\n            else if (lengthToWrite >= (_bOut.getBuf().length - _bOut.getCount()))\n                doCompress();\n        }\n    }","id":567,"modified_method":"/**\n     * Check out.\n     *\n     * @param lengthToWrite\n     *            the length\n     * @throws IOException\n     *             Signals that an I/O exception has occurred.\n     */\n    private void checkOut(int lengthToWrite) throws IOException\n    {\n        if (_closed)\n            throw new IOException(\"CLOSED\");\n\n        if (_out == null)\n        {            \n            // If this first write is larger than buffer size, then we are committing now\n            if (lengthToWrite>_wrapper.getBufferSize())\n            {\n                // if we know this is all the content and it is less than minimum, then do not compress, otherwise do compress\n                long length=_wrapper.getContentLength();\n                if (length>=0 && length<_wrapper.getMinCompressSize())\n                    doNotCompress(false);  // Not compressing by size, so no vary on request headers\n                else\n                    doCompress();\n            }\n            else\n            {\n                // start aggregating writes into a buffered output stream\n                _out = _bOut = new ByteArrayOutputStream2(_wrapper.getBufferSize());\n            }\n        }\n        // else are we aggregating writes?\n        else if (_bOut !=null)\n        {\n            // We are aggregating into the buffered output stream.  \n\n            // If this write fills the buffer, then we are committing\n            if (lengthToWrite>=(_bOut.getBuf().length - _bOut.getCount()))\n            {\n                // if we know this is all the content and it is less than minimum, then do not compress, otherwise do compress\n                long length=_wrapper.getContentLength();\n                if (length>=0 && length<_wrapper.getMinCompressSize())\n                    doNotCompress(false);  // Not compressing by size, so no vary on request headers\n                else\n                    doCompress();\n            }\n        }\n    }","commit_id":"3a46498a27e249e3674a0f7d3441362221c27034","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Check out.\n     * \n     * @param lengthToWrite\n     *            the length\n     * @throws IOException\n     *             Signals that an I/O exception has occurred.\n     */\n    private void checkOut(int lengthToWrite) throws IOException\n    {\n        if (_closed)\n            throw new IOException(\"CLOSED\");\n\n        if (_out == null)\n        {\n            long length=_wrapper.getContentLength();\n            if (_response.isCommitted() || (length >= 0 && length < _wrapper.getMinCompressSize()))\n                doNotCompress(false);\n            else if (lengthToWrite > _wrapper.getMinCompressSize())\n                doCompress();\n            else\n                _out = _bOut = new ByteArrayOutputStream2(_wrapper.getBufferSize());\n        }\n        else if (_bOut != null)\n        {\n            long length=_wrapper.getContentLength();\n            if (_response.isCommitted() || (length >= 0 && length < _wrapper.getMinCompressSize()))\n                doNotCompress(false);\n            else if (lengthToWrite >= (_bOut.getBuf().length - _bOut.getCount()))\n                doCompress();\n        }\n    }","id":568,"modified_method":"/**\n     * Check out.\n     * \n     * @param lengthToWrite\n     *            the length\n     * @throws IOException\n     *             Signals that an I/O exception has occurred.\n     */\n    private void checkOut(int lengthToWrite) throws IOException\n    {\n        if (_closed)\n            throw new IOException(\"CLOSED\");\n\n        if (_out == null)\n        {            \n            // If this first write is larger than buffer size, then we are committing now\n            if (lengthToWrite>_wrapper.getBufferSize())\n            {\n                // if we know this is all the content and it is less than minimum, then do not compress, otherwise do compress\n                long length=_wrapper.getContentLength();\n                if (length>=0 && length<_wrapper.getMinCompressSize())\n                    doNotCompress(false);  // Not compressing by size, so no vary on request headers\n                else\n                    doCompress();\n            }\n            else\n            {\n                // start aggregating writes into a buffered output stream\n                _out = _bOut = new ByteArrayOutputStream2(_wrapper.getBufferSize());\n            }\n        }\n        // else are we aggregating writes?\n        else if (_bOut !=null)\n        {\n            // We are aggregating into the buffered output stream.  \n\n            // If this write fills the buffer, then we are committing\n            if (lengthToWrite>=(_bOut.getBuf().length - _bOut.getCount()))\n            {\n                // if we know this is all the content and it is less than minimum, then do not compress, otherwise do compress\n                long length=_wrapper.getContentLength();\n                if (length>=0 && length<_wrapper.getMinCompressSize())\n                    doNotCompress(false);  // Not compressing by size, so no vary on request headers\n                else\n                    doCompress();\n            }\n        }\n    }","commit_id":"ecbb5328972b68da4a16c9af5650bb53adf726b9","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n  public void fireEvent( @Nonnull final ResourceAvailabilityEvent event ) {\n    Preconditions.checkNotNull(event, \"Event is required\");\n\n    final Function<ReportingComputeZoneDomainModel,Function<Long,Void>> zoneSetter = zoneSetters.get( event.getType() );\n    final Function<ReportingComputeDomainModel,Function<Long,Void>> globalSetter = globalSetters.get( event.getType() );\n    for ( final Availability availability : event.getAvailability() ) {\n      if ( zoneSetter != null ) {\n        final ReportingComputeZoneDomainModel zoneModel = getZoneModelForTags( availability.getTags() );\n        if ( zoneModel == null ) continue;\n        zoneSetter.apply( zoneModel ).apply( availability.getAvailable() );\n      }\n      if ( globalSetter != null ) {\n        final ReportingComputeDomainModel globalModel = getReportingComputeDomainModel();\n        globalSetter.apply( globalModel ).apply( availability.getAvailable() );\n      }\n    }\n  }","id":569,"modified_method":"@Override\n  public void fireEvent( @Nonnull final ResourceAvailabilityEvent event ) {\n    Preconditions.checkNotNull(event, \"Event is required\");\n\n    final ModelComputeUpdater<ReportingComputeZoneDomainModel> zoneSetter = zoneSetters.get( event.getType() );\n    final ModelComputeUpdater<ReportingComputeDomainModel> globalSetter = globalSetters.get( event.getType() );\n    for ( final Availability availability : event.getAvailability() ) {\n      if ( zoneSetter != null ) {\n        final ReportingComputeZoneDomainModel zoneModel = getZoneModelForTags( availability.getTags() );\n        if ( zoneModel == null ) continue;\n        zoneSetter.update( zoneModel, availability.getTags(), availability.getAvailable(), availability.getTotal() );\n      }\n      if ( globalSetter != null ) {\n        final ReportingComputeDomainModel globalModel = getReportingComputeDomainModel();\n        globalSetter.update( globalModel, availability.getTags(), availability.getAvailable(), availability.getTotal() );\n      }\n    }\n  }","commit_id":"f8ffadfa95438384e6f152dc7331141ca15d191e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void fireEvent( @Nonnull final ResourceAvailabilityEvent event ) {\n    Preconditions.checkNotNull(event, \"Event is required\");\n\n    final Function<ReportingComputeZoneDomainModel,Function<Long,Void>> zoneSetter = zoneSetters.get( event.getType() );\n    final Function<ReportingComputeDomainModel,Function<Long,Void>> globalSetter = globalSetters.get( event.getType() );\n    for ( final Availability availability : event.getAvailability() ) {\n      if ( zoneSetter != null ) {\n        final ReportingComputeZoneDomainModel zoneModel = getZoneModelForTags( availability.getTags() );\n        if ( zoneModel == null ) continue;\n        zoneSetter.apply( zoneModel ).apply( availability.getAvailable() );\n      }\n      if ( globalSetter != null ) {\n        final ReportingComputeDomainModel globalModel = getReportingComputeDomainModel();\n        globalSetter.apply( globalModel ).apply( availability.getAvailable() );\n      }\n    }\n  }","id":570,"modified_method":"@Override\n  public void fireEvent( @Nonnull final ResourceAvailabilityEvent event ) {\n    Preconditions.checkNotNull(event, \"Event is required\");\n\n    final ModelComputeUpdater<ReportingComputeZoneDomainModel> zoneSetter = zoneSetters.get( event.getType() );\n    final ModelComputeUpdater<ReportingComputeDomainModel> globalSetter = globalSetters.get( event.getType() );\n    for ( final Availability availability : event.getAvailability() ) {\n      if ( zoneSetter != null ) {\n        final ReportingComputeZoneDomainModel zoneModel = getZoneModelForTags( availability.getTags() );\n        if ( zoneModel == null ) continue;\n        zoneSetter.update( zoneModel, availability.getAvailable(), availability.getTotal() );\n      }\n      if ( globalSetter != null ) {\n        final ReportingComputeDomainModel globalModel = getReportingComputeDomainModel();\n        globalSetter.update( globalModel, availability.getAvailable(), availability.getTotal() );\n      }\n    }\n  }","commit_id":"c7f2ccdadbfe4d2b4aef5578d186c68b6e6860ad","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeByte(searchType.id());\n\n        out.writeVInt(indices.length);\n        for (String index : indices) {\n            out.writeString(index);\n        }\n\n        out.writeOptionalString(routing);\n        out.writeOptionalString(preference);\n\n        if (scroll == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            scroll.writeTo(out);\n        }\n        source.writeTo(out);\n        out.writeStringArray(types);\n        indicesOptions.writeIndicesOptions(out);\n        out.writeOptionalBoolean(requestCache);\n        out.writeOptionalStreamable(template);\n    }","id":571,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeByte(searchType.id());\n\n        out.writeVInt(indices.length);\n        for (String index : indices) {\n            out.writeString(index);\n        }\n\n        out.writeOptionalString(routing);\n        out.writeOptionalString(preference);\n\n        if (scroll == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            scroll.writeTo(out);\n        }\n        if (source == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            source.writeTo(out);\n        }\n        out.writeStringArray(types);\n        indicesOptions.writeIndicesOptions(out);\n        out.writeOptionalBoolean(requestCache);\n        out.writeOptionalStreamable(template);\n    }","commit_id":"ef5fc721e53da3e6ac69e9ae8160b13a4ebf5787","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeByte(searchType.id());\n\n        out.writeVInt(indices.length);\n        for (String index : indices) {\n            out.writeString(index);\n        }\n\n        out.writeOptionalString(routing);\n        out.writeOptionalString(preference);\n\n        if (scroll == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            scroll.writeTo(out);\n        }\n        source.writeTo(out);\n        out.writeStringArray(types);\n        indicesOptions.writeIndicesOptions(out);\n        out.writeOptionalBoolean(requestCache);\n        out.writeOptionalStreamable(template);\n    }","id":572,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeByte(searchType.id());\n\n        out.writeVInt(indices.length);\n        for (String index : indices) {\n            out.writeString(index);\n        }\n\n        out.writeOptionalString(routing);\n        out.writeOptionalString(preference);\n\n        if (scroll == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            scroll.writeTo(out);\n        }\n        if (source == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            source.writeTo(out);\n        }\n        out.writeStringArray(types);\n        indicesOptions.writeIndicesOptions(out);\n        out.writeOptionalBoolean(requestCache);\n        out.writeOptionalStreamable(template);\n    }","commit_id":"63da68e48067dc0388414deed1be4f78ddcc0f69","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doWriteTo(StreamOutput out) throws IOException {\n        out.writeString(fieldName);\n        boolean hasShapeBytes = shapeBytes != null;\n        out.writeBoolean(hasShapeBytes);\n        if (hasShapeBytes) {\n            out.writeBytesReference(shapeBytes);\n        } else {\n            out.writeOptionalString(indexedShapeId);\n            out.writeOptionalString(indexedShapeType);\n            out.writeOptionalString(indexedShapeIndex);\n            out.writeOptionalString(indexedShapePath);\n        }\n        relation.writeTo(out);\n        strategy.writeTo(out);\n    }","id":573,"modified_method":"@Override\n    protected void doWriteTo(StreamOutput out) throws IOException {\n        out.writeString(fieldName);\n        boolean hasShapeBytes = shapeBytes != null;\n        out.writeBoolean(hasShapeBytes);\n        if (hasShapeBytes) {\n            out.writeBytesReference(shapeBytes);\n        } else {\n            out.writeOptionalString(indexedShapeId);\n            out.writeOptionalString(indexedShapeType);\n            out.writeOptionalString(indexedShapeIndex);\n            out.writeOptionalString(indexedShapePath);\n        }\n        relation.writeTo(out);\n        if (strategy == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            strategy.writeTo(out);\n        }\n    }","commit_id":"7e840532c1f7211ebc631ba60d4b4e2ccc73b45b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void innerWriteTo(StreamOutput out, boolean asKey) throws IOException {\n        out.writeString(index);\n        out.writeVInt(shardId);\n        out.writeByte(searchType.id());\n        if (!asKey) {\n            out.writeVInt(numberOfShards);\n        }\n        if (scroll == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            scroll.writeTo(out);\n        }\n        source.writeTo(out);\n        out.writeStringArray(types);\n        out.writeStringArrayNullable(filteringAliases);\n        if (!asKey) {\n            out.writeVLong(nowInMillis);\n        }\n\n        out.writeOptionalStreamable(template);\n        out.writeOptionalBoolean(requestCache);\n    }","id":574,"modified_method":"protected void innerWriteTo(StreamOutput out, boolean asKey) throws IOException {\n        out.writeString(index);\n        out.writeVInt(shardId);\n        out.writeByte(searchType.id());\n        if (!asKey) {\n            out.writeVInt(numberOfShards);\n        }\n        if (scroll == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            scroll.writeTo(out);\n        }\n        if (source == null) {\n            out.writeBoolean(false);\n        } else {\n            out.writeBoolean(true);\n            source.writeTo(out);\n\n        }\n        out.writeStringArray(types);\n        out.writeStringArrayNullable(filteringAliases);\n        if (!asKey) {\n            out.writeVLong(nowInMillis);\n        }\n\n        out.writeOptionalStreamable(template);\n        out.writeOptionalBoolean(requestCache);\n    }","commit_id":"585ed07c5bb279ef4fa59035924739f6e560c15b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public String getNodeRoleIndex(@NotNull SContainmentLinkId linkId) {\n    // return fqName prefixed with \".\" if we can't find model or name of concept\n    String index = getConceptIndex(linkId.getConceptId());\n    if (index == null) {\n      return MODEL_SEPARATOR_CHAR + linkId.serialize();\n    }\n    return index + MODEL_SEPARATOR_CHAR + linkId.getContainmentLinkId();\n  }","id":575,"modified_method":"public String getNodeRoleIndex(@NotNull SContainmentLinkId linkId) {\n    return getConceptIndex(linkId.getConceptId()) + MODEL_SEPARATOR_CHAR + linkId.getContainmentLinkId();\n  }","commit_id":"530c1c348308c38d26e5ece3f68fc8f807e8624d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getReferenceRoleIndex(@NotNull SReferenceLinkId linkId) {\n    // return fqName prefixed with \".\" if we can't find model or name of concept\n    String index = getConceptIndex(linkId.getConceptId());\n    if (index == null) {\n      return MODEL_SEPARATOR_CHAR + linkId.serialize();\n    }\n    return index + MODEL_SEPARATOR_CHAR + linkId.getReferenceLinkId();\n  }","id":576,"modified_method":"public String getReferenceRoleIndex(@NotNull SReferenceLinkId linkId) {\n    return getConceptIndex(linkId.getConceptId()) + MODEL_SEPARATOR_CHAR + linkId.getReferenceLinkId();\n  }","commit_id":"530c1c348308c38d26e5ece3f68fc8f807e8624d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getPropertyIndex(@NotNull SPropertyId prop) {\n    // return fqName prefixed with \".\" if we can't find model or name of concept\n    String index = getConceptIndex(prop.getConceptId());\n    if (index == null) {\n      return MODEL_SEPARATOR_CHAR + prop.serialize();\n    }\n    return index + MODEL_SEPARATOR_CHAR + prop.getPropertyId();\n  }","id":577,"modified_method":"public String getPropertyIndex(@NotNull SPropertyId prop) {\n    return getConceptIndex(prop.getConceptId()) + MODEL_SEPARATOR_CHAR + prop.getPropertyId();\n  }","commit_id":"530c1c348308c38d26e5ece3f68fc8f807e8624d","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Tests if the Comet connection is closed if the Tomcat connector is\n     * stopped.\n     */\n    @Test\n    public void testCometConnectorStop() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        SimpleCometServlet servlet = new SimpleCometServlet();\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", servlet);\n        root.addServletMapping(\"/\", \"comet\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(10000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/ HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        PingWriterThread writeThread = new PingWriterThread(100, os);\n        writeThread.start();\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Allow the first couple of PING messages to be written\n        Thread.sleep(3000);\n\n        tomcat.getConnector().stop();\n\n        int count = 0;\n        // Wait for the read thread to stop\n        while (readThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Wait for the write thread to stop\n        count = 0;\n        while (writeThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Destroy the connector once the executor has sent the end event\n        tomcat.getConnector().destroy();\n\n        String[] response = readThread.getResponse().split(\"\\r\\n\");\n        String lastMessage = \"\";\n        String lastResponseLine = \"\";\n        for (int i = response.length; --i >= 0;) {\n            lastMessage = response[i];\n            if (lastMessage.startsWith(\"Client:\")) {\n                break;\n            }\n        }\n        for (int i = response.length; --i >= 0;) {\n            lastResponseLine = response[i];\n            if (lastResponseLine.length() > 0) {\n                break;\n            }\n        }\n        StringBuilder status = new StringBuilder();\n        // Expected, but is not 100% reliable:\n        // WriteThread exception: java.net.SocketException\n        // ReaderThread exception: null\n        // Last message: [Client: END]\n        // Last response line: [0] (empty chunk)\n        // Last comet event: [END]\n        // END event occurred: [true]\n        status.append(\"Status:\");\n        status.append(\"\\nWriterThread exception: \" + writeThread.getException());\n        status.append(\"\\nReaderThread exception: \" + readThread.getException());\n        status.append(\"\\nLast message: [\" + lastMessage + \"]\");\n        status.append(\"\\nLast response line: [\" + lastResponseLine + \"]\");\n        status.append(\"\\nLast comet event: [\" + servlet.getLastEvent() + \"]\");\n        status.append(\"\\nEND event occurred: [\" + servlet.getEndEventOccurred() + \"]\");\n        if (writeThread.getException() == null\n                || !lastMessage.contains(\"Client: END\")\n                || !EventType.END.equals(servlet.getLastEvent())) {\n            log.error(status);\n        } else {\n            log.info(status);\n        }\n        assertTrue(\"Comet END event not received\",\n                EventType.END.equals(servlet.getLastEvent()));\n    }","id":578,"modified_method":"/**\n     * Tests if the Comet connection is closed if the Tomcat connector is\n     * stopped.\n     */\n    @Test\n    public void testCometConnectorStop() throws Exception {\n        Assume.assumeTrue(\n                \"This test is skipped, because this connector does not support Comet.\",\n                isCometSupported());\n\n        // Setup Tomcat instance\n        SimpleCometServlet servlet = new SimpleCometServlet();\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", servlet);\n        root.addServletMapping(\"/\", \"comet\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(10000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/ HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        PingWriterThread writeThread = new PingWriterThread(100, os);\n        writeThread.start();\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Allow the first couple of PING messages to be written\n        Thread.sleep(3000);\n\n        tomcat.getConnector().stop();\n\n        int count = 0;\n        // Wait for the read thread to stop\n        while (readThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Wait for the write thread to stop\n        count = 0;\n        while (writeThread.isAlive() && count < 50) {\n            Thread.sleep(100);\n            count ++;\n        }\n\n        // Destroy the connector once the executor has sent the end event\n        tomcat.getConnector().destroy();\n\n        String[] response = readThread.getResponse().split(\"\\r\\n\");\n        String lastMessage = \"\";\n        String lastResponseLine = \"\";\n        for (int i = response.length; --i >= 0;) {\n            lastMessage = response[i];\n            if (lastMessage.startsWith(\"Client:\")) {\n                break;\n            }\n        }\n        for (int i = response.length; --i >= 0;) {\n            lastResponseLine = response[i];\n            if (lastResponseLine.length() > 0) {\n                break;\n            }\n        }\n        StringBuilder status = new StringBuilder();\n        // Expected, but is not 100% reliable:\n        // WriteThread exception: java.net.SocketException\n        // ReaderThread exception: null\n        // Last message: [Client: END]\n        // Last response line: [0] (empty chunk)\n        // Last comet event: [END]\n        // END event occurred: [true]\n        status.append(\"Status:\");\n        status.append(\"\\nWriterThread exception: \" + writeThread.getException());\n        status.append(\"\\nReaderThread exception: \" + readThread.getException());\n        status.append(\"\\nLast message: [\" + lastMessage + \"]\");\n        status.append(\"\\nLast response line: [\" + lastResponseLine + \"]\");\n        status.append(\"\\nLast comet event: [\" + servlet.getLastEvent() + \"]\");\n        status.append(\"\\nEND event occurred: [\" + servlet.getEndEventOccurred() + \"]\");\n        if (writeThread.getException() == null\n                || !lastMessage.contains(\"Client: END\")\n                || !EventType.END.equals(servlet.getLastEvent())) {\n            log.error(status);\n        } else {\n            log.info(status);\n        }\n        assertTrue(\"Comet END event not received\",\n                EventType.END.equals(servlet.getLastEvent()));\n    }","commit_id":"9a05595001bde5f82873c8dd637387b315f867ee","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testAsyncClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new SimpleCometServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        root.getPipeline().addValve(new AsyncCometCloseValve());\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }","id":579,"modified_method":"@Test\n    public void testAsyncClose() throws Exception {\n        Assume.assumeTrue(\n                \"This test is skipped, because this connector does not support Comet.\",\n                isCometSupported());\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new SimpleCometServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        root.getPipeline().addValve(new AsyncCometCloseValve());\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }","commit_id":"9a05595001bde5f82873c8dd637387b315f867ee","url":"https://github.com/apache/tomcat"},{"original_method":"private void doSimpleCometTest(String initParam) throws Exception {\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Wrapper w = Tomcat.addServlet(root, \"comet\", new SimpleCometServlet());\n        if (initParam != null) {\n            w.addInitParameter(initParam, \"true\");\n        }\n        root.addServletMapping(\"/\", \"comet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        root.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(60000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/ HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        PingWriterThread writeThread = new PingWriterThread(4, os);\n        writeThread.start();\n\n        socket.setSoTimeout(25000);\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n        readThread.join();\n        os.close();\n        is.close();\n\n        String[] response = readThread.getResponse().split(\"\\r\\n\");\n        if (initParam == null) {\n            // Normal response expected\n            // Validate response\n            assertEquals(\"HTTP/1.1 200 OK\", response[0]);\n            assertEquals(\"Server: Apache-Coyote/1.1\", response[1]);\n            assertTrue(response[2].startsWith(\"Set-Cookie: JSESSIONID=\"));\n            assertEquals(\"Content-Type: text/plain;charset=ISO-8859-1\", response[3]);\n            assertEquals(\"Transfer-Encoding: chunked\", response[4]);\n            assertTrue(response[5].startsWith(\"Date: \"));\n            assertEquals(\"\", response[6]);\n            assertEquals(\"7\", response[7]);\n            assertEquals(\"BEGIN\", response[8]);\n            assertEquals(\"\", response[9]);\n            assertEquals(\"17\", response[10]);\n            assertEquals(\"Client: READ: 4 bytes\", response[11]);\n            assertEquals(\"\", response[12]);\n            assertEquals(\"17\", response[13]);\n            assertEquals(\"Client: READ: 4 bytes\", response[14]);\n            assertEquals(\"\", response[15]);\n            assertEquals(\"17\", response[16]);\n            assertEquals(\"Client: READ: 4 bytes\", response[17]);\n            assertEquals(\"\", response[18]);\n            assertEquals(\"17\", response[19]);\n            assertEquals(\"Client: READ: 4 bytes\", response[20]);\n            assertEquals(\"\", response[21]);\n            assertEquals(\"d\", response[22]);\n            assertEquals(\"Client: END\", response[23]);\n            assertEquals(\"\", response[24]);\n            assertEquals(\"0\", response[25]);\n            // Expect 26 lines\n            assertEquals(26, response.length);\n        } else {\n            // Failure expected only expected for the fail on begin\n            // Failure at any later stage and the response headers (including\n            // the 200 response code will already have been sent to the client\n            if (SimpleCometServlet.FAIL_ON_BEGIN.equals(initParam)) {\n                assertEquals(\"HTTP/1.1 500 Internal Server Error\", response[0]);\n                alv.validateAccessLog(1, 500, 0, 1000);\n            } else {\n                assertEquals(\"HTTP/1.1 200 OK\", response[0]);\n                alv.validateAccessLog(1, 200, 0, 5000);\n            }\n\n        }\n    }","id":580,"modified_method":"private void doSimpleCometTest(String initParam) throws Exception {\n        Assume.assumeTrue(\n                \"This test is skipped, because this connector does not support Comet.\",\n                isCometSupported());\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Wrapper w = Tomcat.addServlet(root, \"comet\", new SimpleCometServlet());\n        if (initParam != null) {\n            w.addInitParameter(initParam, \"true\");\n        }\n        root.addServletMapping(\"/\", \"comet\");\n\n        TesterAccessLogValve alv = new TesterAccessLogValve();\n        root.getPipeline().addValve(alv);\n\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(60000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/ HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        PingWriterThread writeThread = new PingWriterThread(4, os);\n        writeThread.start();\n\n        socket.setSoTimeout(25000);\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n        readThread.join();\n        os.close();\n        is.close();\n\n        String[] response = readThread.getResponse().split(\"\\r\\n\");\n        if (initParam == null) {\n            // Normal response expected\n            // Validate response\n            assertEquals(\"HTTP/1.1 200 OK\", response[0]);\n            assertEquals(\"Server: Apache-Coyote/1.1\", response[1]);\n            assertTrue(response[2].startsWith(\"Set-Cookie: JSESSIONID=\"));\n            assertEquals(\"Content-Type: text/plain;charset=ISO-8859-1\", response[3]);\n            assertEquals(\"Transfer-Encoding: chunked\", response[4]);\n            assertTrue(response[5].startsWith(\"Date: \"));\n            assertEquals(\"\", response[6]);\n            assertEquals(\"7\", response[7]);\n            assertEquals(\"BEGIN\", response[8]);\n            assertEquals(\"\", response[9]);\n            assertEquals(\"17\", response[10]);\n            assertEquals(\"Client: READ: 4 bytes\", response[11]);\n            assertEquals(\"\", response[12]);\n            assertEquals(\"17\", response[13]);\n            assertEquals(\"Client: READ: 4 bytes\", response[14]);\n            assertEquals(\"\", response[15]);\n            assertEquals(\"17\", response[16]);\n            assertEquals(\"Client: READ: 4 bytes\", response[17]);\n            assertEquals(\"\", response[18]);\n            assertEquals(\"17\", response[19]);\n            assertEquals(\"Client: READ: 4 bytes\", response[20]);\n            assertEquals(\"\", response[21]);\n            assertEquals(\"d\", response[22]);\n            assertEquals(\"Client: END\", response[23]);\n            assertEquals(\"\", response[24]);\n            assertEquals(\"0\", response[25]);\n            // Expect 26 lines\n            assertEquals(26, response.length);\n        } else {\n            // Failure expected only expected for the fail on begin\n            // Failure at any later stage and the response headers (including\n            // the 200 response code will already have been sent to the client\n            if (SimpleCometServlet.FAIL_ON_BEGIN.equals(initParam)) {\n                assertEquals(\"HTTP/1.1 500 Internal Server Error\", response[0]);\n                alv.validateAccessLog(1, 500, 0, 1000);\n            } else {\n                assertEquals(\"HTTP/1.1 200 OK\", response[0]);\n                alv.validateAccessLog(1, 200, 0, 5000);\n            }\n\n        }\n    }","commit_id":"9a05595001bde5f82873c8dd637387b315f867ee","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testSyncClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new CometCloseServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        // Don't send any data\n        os.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        Assert.assertTrue(readThread.getResponse().contains(\"2\\r\\nOK\"));\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"connection: close\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }","id":581,"modified_method":"@Test\n    public void testSyncClose() throws Exception {\n        Assume.assumeTrue(\n                \"This test is skipped, because this connector does not support Comet.\",\n                isCometSupported());\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new CometCloseServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        // Don't send any data\n        os.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"0\\r\\n\\r\\n\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        Assert.assertTrue(readThread.getResponse().contains(\"2\\r\\nOK\"));\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Send a standard HTTP request on the same connection\n        requestLine = \"GET http://localhost:\" + getPort() +\n                \"/hello HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"connection: close\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n\n        // Check for the expected response\n        count = 0;\n        while (count < 10 && !readThread.getResponse().contains(\n                HelloWorldServlet.RESPONSE_TEXT)) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Non-comet request did not complete\");\n        }\n\n        readThread.join();\n        os.close();\n        is.close();\n    }","commit_id":"9a05595001bde5f82873c8dd637387b315f867ee","url":"https://github.com/apache/tomcat"},{"original_method":"@Test\n    public void testConnectionClose() throws Exception {\n\n        if (!isCometSupported()) {\n            log.info(\"This test is skipped, because this connector does not support Comet.\");\n            return;\n        }\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new ConnectionCloseServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        // Don't send any data\n        os.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"OK\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Read thread should have terminated cleanly when the server closed the\n        // socket\n        Assert.assertFalse(readThread.isAlive());\n        Assert.assertNull(readThread.getException());\n\n        os.close();\n        is.close();\n    }","id":582,"modified_method":"@Test\n    public void testConnectionClose() throws Exception {\n        Assume.assumeTrue(\n                \"This test is skipped, because this connector does not support Comet.\",\n                isCometSupported());\n\n        // Setup Tomcat instance\n        Tomcat tomcat = getTomcatInstance();\n        Context root = tomcat.addContext(\"\", TEMP_DIR);\n        Tomcat.addServlet(root, \"comet\", new ConnectionCloseServlet());\n        root.addServletMapping(\"/comet\", \"comet\");\n        Tomcat.addServlet(root, \"hello\", new HelloWorldServlet());\n        root.addServletMapping(\"/hello\", \"hello\");\n        tomcat.getConnector().setProperty(\"connectionTimeout\", \"5000\");\n        tomcat.start();\n\n        // Create connection to Comet servlet\n        final Socket socket =\n            SocketFactory.getDefault().createSocket(\"localhost\", getPort());\n        socket.setSoTimeout(5000);\n\n        final OutputStream os = socket.getOutputStream();\n        String requestLine = \"POST http://localhost:\" + getPort() +\n                \"/comet HTTP/1.1\\r\\n\";\n        os.write(requestLine.getBytes());\n        os.write(\"transfer-encoding: chunked\\r\\n\".getBytes());\n        os.write(\"\\r\\n\".getBytes());\n        // Don't send any data\n        os.write(\"0\\r\\n\\r\\n\".getBytes());\n\n        InputStream is = socket.getInputStream();\n        ResponseReaderThread readThread = new ResponseReaderThread(is);\n        readThread.start();\n\n        // Wait for the comet request/response to finish\n        int count = 0;\n        while (count < 10 && !readThread.getResponse().endsWith(\"OK\")) {\n            Thread.sleep(500);\n            count++;\n        }\n\n        if (count == 10) {\n            fail(\"Comet request did not complete\");\n        }\n\n        // Read thread should have terminated cleanly when the server closed the\n        // socket\n        Assert.assertFalse(readThread.isAlive());\n        Assert.assertNull(readThread.getException());\n\n        os.close();\n        is.close();\n    }","commit_id":"9a05595001bde5f82873c8dd637387b315f867ee","url":"https://github.com/apache/tomcat"},{"original_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"': \" + e, e);\n        }\n    \n        V config;\n        try {\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","id":583,"modified_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        V config = translateConfig(CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, resource));\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","commit_id":"46d4b020d61bdb6d182b6387bebf9924b47b94a9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"': \" + e, e);\n        }\n    \n        V config;\n        try {\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","id":584,"modified_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        V config = translateConfig(CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, resource));\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","commit_id":"fdf401252988db33ec6652719bdd81453d371f6a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        Reader reader;\n        try {\n            reader = new InputStreamReader(resource.getInputStream());\n        } catch (IOException e) {\n            throw CASTOR_EXCEPTION_TRANSLATOR.translate(\"opening XML configuration file for resource '\" + resource + \"': \" + e, e);\n        }\n    \n        V config;\n        try {\n            K castorConfig = CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, reader);\n            config = translateConfig(castorConfig);\n        } finally {\n            IOUtils.closeQuietly(reader);\n        }\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","id":585,"modified_method":"protected V loadConfig(Resource resource) {\n        long startTime = System.currentTimeMillis();\n        \n        if (log().isDebugEnabled()) {\n            log().debug(\"Loading \" + m_description + \" configuration from \" + resource);\n        }\n\n        V config = translateConfig(CastorUtils.unmarshalWithTranslatedExceptions(m_castorClass, resource));\n        \n        long endTime = System.currentTimeMillis();\n        log().info(createLoadedLogMessage(config, (endTime - startTime)));\n        \n        return config;\n    }","commit_id":"1f670f4dad3407cd30d6ac30032ea200e742ee96","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void computeConcordance(RefMetaDataTracker tracker, ReferenceContext ref) {\n        Variation call1 = (Variation)tracker.lookup(\"callset1\", null);\n        Variation call2 = (Variation)tracker.lookup(\"callset2\", null);\n\n        // the only reason they would be null is a lack of coverage\n        if ( call1 == null || call2 == null ) {\n            if ( call1 != null && call1.isSNP() && call1.getNegLog10PError() >= LOD )\n                printVariant(coverageVar1Writer, call1);\n            else if ( call2 != null && call2.isSNP() && call2.getNegLog10PError() >= LOD )\n                printVariant(coverageVar2Writer, call2);\n            return;\n        }\n        if (!(call1 instanceof VariantBackedByGenotype) || !(call2 instanceof VariantBackedByGenotype))\n                    throw new StingException(\"Both parents ROD tracks must be backed by genotype data. Ensure that your rod(s) contain genotyping information\");\n\n        double bestVsRef1 = call1.getNegLog10PError();\n        double bestVsRef2 = call2.getNegLog10PError();\n        //double bestVsNext1 = call1.getConsensusConfidence();\n        //double bestVsNext2 = call2.getConsensusConfidence();\n        String genotype1 = ((VariantBackedByGenotype)call1).getCalledGenotype().getBases();\n        String genotype2 = ((VariantBackedByGenotype)call2).getCalledGenotype().getBases();\n\n        // are they both variant SNPs?\n        if ( call1.isSNP() && call2.isSNP() ) {\n\n            // are they both confident calls?\n            if ( bestVsRef1 >= LOD && bestVsRef2 >= LOD ) {\n                // same genotype\n                if ( genotype1.equals(genotype2) )\n                    printVariant(sameVarWriter, call1);\n\n                // same allele, different genotype\n                else if ( sameVariantAllele(genotype1, genotype2, ref.getBase()) )\n                    printVariant(sameAlleleWriter, call1);\n\n                // different variant allele\n                else\n                    printVariant(diffAlleleWriter, call1);\n            }\n\n            // confident only when combined\n            else if ( bestVsRef1 < LOD && bestVsRef2 < LOD && bestVsRef1 + bestVsRef2 >= LOD ) {\n                printVariant(comboVarWriter, call1);\n            }\n\n            // only one is confident variant\n            else if ( (bestVsRef1 < LOD && bestVsRef2 >= LOD) || (bestVsRef1 >= LOD && bestVsRef2 < LOD) ) {\n                printVariant(oneVarWriter, call1);                \n            }\n        }\n\n        // one is variant and the other is ref\n        else if ( call1.isSNP() && call2.isReference() && bestVsRef1 >= LOD )\n             printVariant(refVsVar1Writer, call1);\n        else if ( call2.isSNP() && call1.isReference() && bestVsRef2 >= LOD )\n            printVariant(refVsVar2Writer, call2);\n    }","id":586,"modified_method":"public void computeConcordance(RefMetaDataTracker tracker, ReferenceContext ref) {\n        RODRecordList<ReferenceOrderedDatum> call1List = tracker.getTrackData(\"callset1\", null);\n        RODRecordList<ReferenceOrderedDatum> call2List = tracker.getTrackData(\"callset2\", null);\n        Variation call1 = (call1List == null ? null : (Variation)call1List.getRecords().get(0));\n        Variation call2 = (call2List == null ? null : (Variation)call2List.getRecords().get(0));\n\n        // the only reason they would be null is a lack of coverage\n        if ( call1 == null || call2 == null ) {\n            if ( call1 != null && call1.isSNP() && call1.getNegLog10PError() >= LOD )\n                printVariant(coverageVar1Writer, call1);\n            else if ( call2 != null && call2.isSNP() && call2.getNegLog10PError() >= LOD )\n                printVariant(coverageVar2Writer, call2);\n            return;\n        }\n        if (!(call1 instanceof VariantBackedByGenotype) || !(call2 instanceof VariantBackedByGenotype))\n                    throw new StingException(\"Both parents ROD tracks must be backed by genotype data. Ensure that your rod(s) contain genotyping information\");\n\n        double bestVsRef1 = call1.getNegLog10PError();\n        double bestVsRef2 = call2.getNegLog10PError();\n        //double bestVsNext1 = call1.getConsensusConfidence();\n        //double bestVsNext2 = call2.getConsensusConfidence();\n        String genotype1 = ((VariantBackedByGenotype)call1).getCalledGenotype().getBases();\n        String genotype2 = ((VariantBackedByGenotype)call2).getCalledGenotype().getBases();\n\n        // are they both variant SNPs?\n        if ( call1.isSNP() && call2.isSNP() ) {\n\n            // are they both confident calls?\n            if ( bestVsRef1 >= LOD && bestVsRef2 >= LOD ) {\n                // same genotype\n                if ( genotype1.equals(genotype2) )\n                    printVariant(sameVarWriter, call1);\n\n                // same allele, different genotype\n                else if ( sameVariantAllele(genotype1, genotype2, ref.getBase()) )\n                    printVariant(sameAlleleWriter, call1);\n\n                // different variant allele\n                else\n                    printVariant(diffAlleleWriter, call1);\n            }\n\n            // confident only when combined\n            else if ( bestVsRef1 < LOD && bestVsRef2 < LOD && bestVsRef1 + bestVsRef2 >= LOD ) {\n                printVariant(comboVarWriter, call1);\n            }\n\n            // only one is confident variant\n            else if ( (bestVsRef1 < LOD && bestVsRef2 >= LOD) || (bestVsRef1 >= LOD && bestVsRef2 < LOD) ) {\n                printVariant(oneVarWriter, call1);                \n            }\n        }\n\n        // one is variant and the other is ref\n        else if ( call1.isSNP() && call2.isReference() && bestVsRef1 >= LOD )\n             printVariant(refVsVar1Writer, call1);\n        else if ( call2.isSNP() && call1.isReference() && bestVsRef2 >= LOD )\n            printVariant(refVsVar2Writer, call2);\n    }","commit_id":"e96b1791abd3b65c939b214730cd6999cb2464f8","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void computeConcordance(RefMetaDataTracker tracker, ReferenceContext ref) {\n        Variation call1 = (Variation)tracker.lookup(\"callset1\", null);\n        Variation call2 = (Variation)tracker.lookup(\"callset2\", null);\n\n        if ( call1 == null && call2 == null )\n            return;\n\n        // union\n        printVariant(union_writer, call1 != null ? call1 : call2);\n\n        // set 1 only\n        if ( call2 == null )\n            printVariant(set1_writer, call1);\n\n        // set 2 only\n        else if ( call1 == null )\n            printVariant(set2_writer, call2);\n\n        // intersection (concordant)\n        else if ( call1.getAlternativeBaseForSNP() == call2.getAlternativeBaseForSNP())\n            printVariant(intersect_writer, call1);\n\n        // intersection (discordant)\n        else\n            printVariant(discord_writer, call1);\n    }","id":587,"modified_method":"public void computeConcordance(RefMetaDataTracker tracker, ReferenceContext ref) {\n        RODRecordList<ReferenceOrderedDatum> call1List = tracker.getTrackData(\"callset1\", null);\n        RODRecordList<ReferenceOrderedDatum> call2List = tracker.getTrackData(\"callset2\", null);\n        Variation call1 = (call1List == null ? null : (Variation)call1List.getRecords().get(0));\n        Variation call2 = (call2List == null ? null : (Variation)call2List.getRecords().get(0));\n\n        if ( call1 == null && call2 == null )\n            return;\n\n        // union\n        printVariant(union_writer, call1 != null ? call1 : call2);\n\n        // set 1 only\n        if ( call2 == null )\n            printVariant(set1_writer, call1);\n\n        // set 2 only\n        else if ( call1 == null )\n            printVariant(set2_writer, call2);\n\n        // we can't really deal with multi-allelic variants\n        else if ( call1.isBiallelic() && call2.isBiallelic() ) {\n            // intersection (concordant)\n            if ( call1.getAlternativeBaseForSNP() == call2.getAlternativeBaseForSNP() )\n                printVariant(intersect_writer, call1);\n            // intersection (discordant)\n            else\n                printVariant(discord_writer, call1);\n        }\n    }","commit_id":"e96b1791abd3b65c939b214730cd6999cb2464f8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public void visitForLoop(final ForStatement forLoop) {\n        // collect every variable expression used in the loop body\n        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();\n        forLoop.getLoopBlock().visit(new VariableExpressionTypeMemoizer(varOrigType));\n        \n        // visit body\n        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();\n        final ClassNode collectionType = getType(forLoop.getCollectionExpression());\n        ClassNode componentType = collectionType.getComponentType();\n        if (componentType == null) {\n            if (collectionType.implementsInterface(ITERABLE_TYPE)) {\n                ClassNode intf = GenericsUtils.parameterizeInterfaceGenerics(collectionType, ITERABLE_TYPE);\n                GenericsType[] genericsTypes = intf.getGenericsTypes();\n                componentType = genericsTypes[0].getType();\n            } else if (collectionType == ClassHelper.STRING_TYPE) {\n                componentType = ClassHelper.Character_TYPE;\n            } else {\n                componentType = ClassHelper.OBJECT_TYPE;\n            }\n        }\n        forLoopVariableTypes.put(forLoop.getVariable(), componentType);\n        if (!checkCompatibleAssignmentTypes(forLoop.getVariableType(), componentType)) {\n            addStaticTypeError(\"Cannot loop with element of type \" + forLoop.getVariableType() + \" with collection of type \" + collectionType, forLoop);\n        }\n        try {\n            super.visitForLoop(forLoop);\n        } finally {\n            forLoopVariableTypes.remove(forLoop.getVariable());\n        }\n        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);\n        if (typeChanged) visitForLoop(forLoop);\n    }","id":588,"modified_method":"@Override\n    public void visitForLoop(final ForStatement forLoop) {\n        // collect every variable expression used in the loop body\n        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();\n        forLoop.getLoopBlock().visit(new VariableExpressionTypeMemoizer(varOrigType));\n\n        // visit body\n        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();\n        Expression collectionExpression = forLoop.getCollectionExpression();\n        if (collectionExpression instanceof ClosureListExpression) {\n            // for (int i=0; i<...; i++) style loop\n            super.visitForLoop(forLoop);\n        } else {\n            final ClassNode collectionType = getType(collectionExpression);\n            ClassNode componentType = collectionType.getComponentType();\n            if (componentType == null) {\n                if (collectionType.implementsInterface(ITERABLE_TYPE)) {\n                    ClassNode intf = GenericsUtils.parameterizeInterfaceGenerics(collectionType, ITERABLE_TYPE);\n                    GenericsType[] genericsTypes = intf.getGenericsTypes();\n                    componentType = genericsTypes[0].getType();\n                } else if (collectionType == ClassHelper.STRING_TYPE) {\n                    componentType = ClassHelper.Character_TYPE;\n                } else {\n                    componentType = ClassHelper.OBJECT_TYPE;\n                }\n            }\n            forLoopVariableTypes.put(forLoop.getVariable(), componentType);\n            if (!checkCompatibleAssignmentTypes(forLoop.getVariableType(), componentType)) {\n                addStaticTypeError(\"Cannot loop with element of type \" + forLoop.getVariableType() + \" with collection of type \" + collectionType, forLoop);\n            }\n            try {\n                super.visitForLoop(forLoop);\n            } finally {\n                forLoopVariableTypes.remove(forLoop.getVariable());\n            }\n        }\n        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);\n        if (typeChanged) visitForLoop(forLoop);\n    }","commit_id":"d2e07a35608324b155c91853a8cc20b9a1f0ca40","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitForLoop(final ForStatement forLoop) {\n        // collect every variable expression used in the loop body\n        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();\n        forLoop.getLoopBlock().visit(new VariableExpressionTypeMemoizer(varOrigType));\n        \n        // visit body\n        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();\n        final ClassNode collectionType = getType(forLoop.getCollectionExpression());\n        ClassNode componentType = collectionType.getComponentType();\n        if (componentType == null) {\n            if (collectionType.implementsInterface(ITERABLE_TYPE)) {\n                ClassNode intf = GenericsUtils.parameterizeInterfaceGenerics(collectionType, ITERABLE_TYPE);\n                GenericsType[] genericsTypes = intf.getGenericsTypes();\n                componentType = genericsTypes[0].getType();\n            } else if (collectionType == ClassHelper.STRING_TYPE) {\n                componentType = ClassHelper.Character_TYPE;\n            } else {\n                componentType = ClassHelper.OBJECT_TYPE;\n            }\n        }\n        forLoopVariableTypes.put(forLoop.getVariable(), componentType);\n        if (!checkCompatibleAssignmentTypes(forLoop.getVariableType(), componentType)) {\n            addStaticTypeError(\"Cannot loop with element of type \" + forLoop.getVariableType() + \" with collection of type \" + collectionType, forLoop);\n        }\n        try {\n            super.visitForLoop(forLoop);\n        } finally {\n            forLoopVariableTypes.remove(forLoop.getVariable());\n        }\n        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);\n        if (typeChanged) visitForLoop(forLoop);\n    }","id":589,"modified_method":"@Override\n    public void visitForLoop(final ForStatement forLoop) {\n        // collect every variable expression used in the loop body\n        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();\n        forLoop.getLoopBlock().visit(new VariableExpressionTypeMemoizer(varOrigType));\n\n        // visit body\n        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();\n        Expression collectionExpression = forLoop.getCollectionExpression();\n        if (collectionExpression instanceof ClosureListExpression) {\n            // for (int i=0; i<...; i++) style loop\n            super.visitForLoop(forLoop);\n        } else {\n            final ClassNode collectionType = getType(collectionExpression);\n            ClassNode componentType = collectionType.getComponentType();\n            if (componentType == null) {\n                if (collectionType.implementsInterface(ITERABLE_TYPE)) {\n                    ClassNode intf = GenericsUtils.parameterizeInterfaceGenerics(collectionType, ITERABLE_TYPE);\n                    GenericsType[] genericsTypes = intf.getGenericsTypes();\n                    componentType = genericsTypes[0].getType();\n                } else if (collectionType == ClassHelper.STRING_TYPE) {\n                    componentType = ClassHelper.Character_TYPE;\n                } else {\n                    componentType = ClassHelper.OBJECT_TYPE;\n                }\n            }\n            forLoopVariableTypes.put(forLoop.getVariable(), componentType);\n            if (!checkCompatibleAssignmentTypes(forLoop.getVariableType(), componentType)) {\n                addStaticTypeError(\"Cannot loop with element of type \" + forLoop.getVariableType() + \" with collection of type \" + collectionType, forLoop);\n            }\n            try {\n                super.visitForLoop(forLoop);\n            } finally {\n                forLoopVariableTypes.remove(forLoop.getVariable());\n            }\n        }\n        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);\n        if (typeChanged) visitForLoop(forLoop);\n    }","commit_id":"528ccceb943e20a515808933ff44fab5821a2497","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void visitForLoop(final ForStatement forLoop) {\n        // collect every variable expression used in the loop body\n        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();\n        forLoop.getLoopBlock().visit(new VariableExpressionTypeMemoizer(varOrigType));\n        \n        // visit body\n        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();\n        final ClassNode collectionType = getType(forLoop.getCollectionExpression());\n        ClassNode componentType = inferLoopElementType(collectionType);\n        forLoopVariableTypes.put(forLoop.getVariable(), componentType);\n        if (!checkCompatibleAssignmentTypes(forLoop.getVariableType(), componentType)) {\n            addStaticTypeError(\"Cannot loop with element of type \" + forLoop.getVariableType() + \" with collection of type \" + collectionType, forLoop);\n        }\n        try {\n            super.visitForLoop(forLoop);\n        } finally {\n            forLoopVariableTypes.remove(forLoop.getVariable());\n        }\n        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);\n        if (typeChanged) visitForLoop(forLoop);\n    }","id":590,"modified_method":"@Override\n    public void visitForLoop(final ForStatement forLoop) {\n        // collect every variable expression used in the loop body\n        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();\n        forLoop.getLoopBlock().visit(new VariableExpressionTypeMemoizer(varOrigType));\n        \n        // visit body\n        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();\n        Expression collectionExpression = forLoop.getCollectionExpression();\n        if (collectionExpression instanceof ClosureListExpression) {\n            // for (int i=0; i<...; i++) style loop\n            super.visitForLoop(forLoop);\n        } else {\n            final ClassNode collectionType = getType(collectionExpression);\n            ClassNode componentType = inferLoopElementType(collectionType);\n            forLoopVariableTypes.put(forLoop.getVariable(), componentType);\n            if (!checkCompatibleAssignmentTypes(forLoop.getVariableType(), componentType)) {\n                addStaticTypeError(\"Cannot loop with element of type \" + forLoop.getVariableType() + \" with collection of type \" + collectionType, forLoop);\n            }\n            try {\n                super.visitForLoop(forLoop);\n            } finally {\n                forLoopVariableTypes.remove(forLoop.getVariable());\n            }\n        }\n        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);\n        if (typeChanged) visitForLoop(forLoop);\n    }","commit_id":"1f81d386299b723e536a57d48b4b2fdd0788fb13","url":"https://github.com/apache/groovy"},{"original_method":"public static AttributesTransformer getInstance() {\n\t\tif (_originalAttributesTransformer == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalAttributesTransformer =\n\t\t\t\t\t(AttributesTransformer)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader, PropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_attributesTransformer == null) {\n\t\t\t_attributesTransformer = _originalAttributesTransformer;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _attributesTransformer.getClass().getName());\n\t\t}\n\n\t\treturn _attributesTransformer;\n\t}","id":591,"modified_method":"public static AttributesTransformer getInstance() {\n\t\tif (_attributesTransformer == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.LDAP_ATTRS_TRANSFORMER_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_attributesTransformer =\n\t\t\t\t\t(AttributesTransformer)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.LDAP_ATTRS_TRANSFORMER_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _attributesTransformer.getClass().getName());\n\t\t}\n\n\t\treturn _attributesTransformer;\n\t}","commit_id":"b45f32ba028f0fcd14761a481065ece826bc6852","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ControlPanelEntry getInstance() {\n\t\tif (_originalControlPanelEntry == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" +\n\t\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalControlPanelEntry =\n\t\t\t\t\t(ControlPanelEntry)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader,\n\t\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_controlPanelEntry == null) {\n\t\t\t_controlPanelEntry = _originalControlPanelEntry;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + ClassUtil.getClassName(_controlPanelEntry));\n\t\t}\n\n\t\treturn _controlPanelEntry;\n\t}","id":592,"modified_method":"public static ControlPanelEntry getInstance() {\n\t\tif (_controlPanelEntry == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" +\n\t\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_controlPanelEntry = (ControlPanelEntry)classLoader.loadClass(\n\t\t\t\t\tPropsValues.CONTROL_PANEL_DEFAULT_ENTRY_CLASS).\n\t\t\t\t\t\tnewInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + ClassUtil.getClassName(_controlPanelEntry));\n\t\t}\n\n\t\treturn _controlPanelEntry;\n\t}","commit_id":"b45f32ba028f0fcd14761a481065ece826bc6852","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Hook getInstance() {\n\t\tif (_originalHook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalHook = (Hook)InstanceFactory.newInstance(\n\t\t\t\t\tclassLoader, PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_hook == null) {\n\t\t\t_hook = _originalHook;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","id":593,"modified_method":"public static Hook getInstance() {\n\t\tif (_hook == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Instantiate \" + PropsValues.MAIL_HOOK_IMPL);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_hook = (Hook)classLoader.loadClass(\n\t\t\t\t\tPropsValues.MAIL_HOOK_IMPL).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Return \" + _hook.getClass().getName());\n\t\t}\n\n\t\treturn _hook;\n\t}","commit_id":"b45f32ba028f0fcd14761a481065ece826bc6852","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ScreenNameGenerator getInstance() {\n\t\tif (_originalScreenNameGenerator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalScreenNameGenerator =\n\t\t\t\t\t(ScreenNameGenerator)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader, PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_screenNameGenerator == null) {\n\t\t\t_screenNameGenerator = _originalScreenNameGenerator;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameGenerator));\n\t\t}\n\n\t\treturn _screenNameGenerator;\n\t}","id":594,"modified_method":"public static ScreenNameGenerator getInstance() {\n\t\tif (_screenNameGenerator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_GENERATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_screenNameGenerator =\n\t\t\t\t\t(ScreenNameGenerator)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.USERS_SCREEN_NAME_GENERATOR).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameGenerator));\n\t\t}\n\n\t\treturn _screenNameGenerator;\n\t}","commit_id":"b45f32ba028f0fcd14761a481065ece826bc6852","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ScreenNameValidator getInstance() {\n\t\tif (_originalScreenNameValidator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_originalScreenNameValidator =\n\t\t\t\t\t(ScreenNameValidator)InstanceFactory.newInstance(\n\t\t\t\t\t\tclassLoader, PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_screenNameValidator == null) {\n\t\t\t_screenNameValidator = _originalScreenNameValidator;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameValidator));\n\t\t}\n\n\t\treturn _screenNameValidator;\n\t}","id":595,"modified_method":"public static ScreenNameValidator getInstance() {\n\t\tif (_screenNameValidator == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Instantiate \" + PropsValues.USERS_SCREEN_NAME_VALIDATOR);\n\t\t\t}\n\n\t\t\tClassLoader classLoader =\n\t\t\t\tPACLClassLoaderUtil.getPortalClassLoader();\n\n\t\t\ttry {\n\t\t\t\t_screenNameValidator =\n\t\t\t\t\t(ScreenNameValidator)classLoader.loadClass(\n\t\t\t\t\t\tPropsValues.USERS_SCREEN_NAME_VALIDATOR).newInstance();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Return \" + ClassUtil.getClassName(_screenNameValidator));\n\t\t}\n\n\t\treturn _screenNameValidator;\n\t}","commit_id":"b45f32ba028f0fcd14761a481065ece826bc6852","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                msgLog.logMessage( \"Did setup, seq=\" + sequenceNr );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e );\n            e.printStackTrace();\n            throw e;\n        }\n    }","id":596,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                msgLog.logMessage( \"Did setup, seq=\" + sequenceNr );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n//                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n//                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n//                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e );\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"ca27c23662255af20ae1ed72f765fa252db953ad","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                msgLog.logMessage( \"Did setup, seq=\" + sequenceNr );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e );\n            e.printStackTrace();\n            throw e;\n        }\n    }","id":597,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                msgLog.logMessage( \"Did setup, seq=\" + sequenceNr );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n//                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n//                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n//                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e );\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"907a43e7da4d6d958b10812aea79c972bc82376b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                msgLog.logMessage( \"Did setup, seq=\" + sequenceNr );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e );\n            e.printStackTrace();\n            throw e;\n        }\n    }","id":598,"modified_method":"public void process( WatchedEvent event )\n    {\n        try\n        {\n            String path = event.getPath();\n            msgLog.logMessage( this + \", \" + new Date() + \" Got event: \" + event + \"(path=\" + path + \")\" );\n            if ( path == null && event.getState() == Watcher.Event.KeeperState.Expired )\n            {\n                keeperState = KeeperState.Expired;\n                zooKeeper = instantiateZooKeeper();\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.SyncConnected )\n            {\n                Pair<Master, Machine> masterBeforeIWrite = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master before write:\" + masterBeforeIWrite );\n                sequenceNr = setup();\n                msgLog.logMessage( \"Did setup, seq=\" + sequenceNr );\n                keeperState = KeeperState.SyncConnected;\n                Pair<Master, Machine> masterAfterIWrote = getMasterFromZooKeeper( false );\n                msgLog.logMessage( \"Get master after write:\" + masterAfterIWrote );\n                int masterId = masterAfterIWrote.other().getMachineId();\n//                if ( masterBeforeIWrite.other().getMachineId() != masterId && masterId != machineId )\n//                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, masterId );\n//                }\n                receiver.newMaster( masterAfterIWrote, new Exception() );\n            }\n            else if ( path == null && event.getState() == Watcher.Event.KeeperState.Disconnected )\n            {\n                keeperState = KeeperState.Disconnected;\n            }\n            else if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )\n            {\n                Pair<Master, Machine> currentMaster = getMasterFromZooKeeper( true );\n                if ( path.contains( MASTER_NOTIFY_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_NOTIFY_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() == machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else if ( path.contains( MASTER_REBOUND_CHILD ) )\n                {\n                    setDataChangeWatcher( MASTER_REBOUND_CHILD, -1 );\n                    if ( currentMaster.other().getMachineId() != machineId )\n                    {\n                        receiver.newMaster( currentMaster, new Exception() );\n                    }\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unrecognized data change \" + path );\n                }\n            }\n        }\n        catch ( RuntimeException e )\n        {\n            msgLog.logMessage( \"Error in ZooClient.process\", e );\n            e.printStackTrace();\n            throw e;\n        }\n    }","commit_id":"38c770ba7c1e7994b1af70c7ff35b75da4b75a04","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object end(final String uri,\r\n                      final String localName) throws SAXException {\r\n        final Configuration config = this.xmlPackageReader.endConfiguration();\r\n\r\n        final LiteralRestrictionDescr literalDescr = (LiteralRestrictionDescr) this.xmlPackageReader.getCurrent();\r\n\r\n        final LinkedList parents = this.xmlPackageReader.getParents();\r\n        final ListIterator it = parents.listIterator( parents.size() );\r\n        it.previous();\r\n        final FieldConstraintDescr fieldConstriantDescr = (FieldConstraintDescr) it.previous();\r\n\r\n        fieldConstriantDescr.addRestriction( literalDescr );\r\n\r\n        return null;\r\n    }","id":599,"modified_method":"public Object end(final String uri,\n                      final String localName) throws SAXException {\n        final Configuration config = this.xmlPackageReader.endConfiguration();\n\n        final LiteralRestrictionDescr literalDescr = (LiteralRestrictionDescr) this.xmlPackageReader.getCurrent();\n\n        final LinkedList parents = this.xmlPackageReader.getParents();\n        final ListIterator it = parents.listIterator( parents.size() );\n        it.previous();\n\n        //TODO: correct classcastexception in AndDescr.\n        \n        Object parent = it.previous();\n        \n        if (parent instanceof FieldConstraintDescr) {\n            final FieldConstraintDescr fieldConstriantDescr = (FieldConstraintDescr) parent;\n            fieldConstriantDescr.addRestriction( literalDescr );\n        } else if ( parent instanceof ConditionalElementDescr )  { \n            final ConditionalElementDescr conditionDescr = (ConditionalElementDescr) parent;\n            \n            \n            \n//            System.out.println(\"LiteralRestriction\");\n        }\n        return null;\n    }","commit_id":"83e74549d080b6249a26b38383bb3c75447f5449","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Object end(final String uri,\r\n                      final String localName) throws SAXException {\r\n        final Configuration config = this.xmlPackageReader.endConfiguration();\r\n\r\n        final ReturnValueRestrictionDescr returnValueDescr = (ReturnValueRestrictionDescr) this.xmlPackageReader.getCurrent();\r\n\r\n        final String expression = config.getText();\r\n\r\n        if ( expression == null || expression.trim().equals( \"\" ) ) {\r\n            throw new SAXParseException( \"<return-value-restriction> must have some content\",\r\n                                         this.xmlPackageReader.getLocator() );\r\n        }\r\n\r\n        returnValueDescr.setContent( expression );\r\n\r\n        final LinkedList parents = this.xmlPackageReader.getParents();\r\n        final ListIterator it = parents.listIterator( parents.size() );\r\n        it.previous();\r\n        final FieldConstraintDescr fieldConstraintDescr = (FieldConstraintDescr) it.previous();\r\n\r\n        fieldConstraintDescr.addRestriction( returnValueDescr );\r\n\r\n        return null;\r\n    }","id":600,"modified_method":"public Object end(final String uri,\n                      final String localName) throws SAXException {\n        final Configuration config = this.xmlPackageReader.endConfiguration();\n\n        final ReturnValueRestrictionDescr returnValueDescr = (ReturnValueRestrictionDescr) this.xmlPackageReader.getCurrent();\n\n        final String expression = config.getText();\n\n        if ( expression == null || expression.trim().equals( \"\" ) ) {\n            throw new SAXParseException( \"<return-value-restriction> must have some content\",\n                                         this.xmlPackageReader.getLocator() );\n        }\n\n        returnValueDescr.setContent( expression );\n\n        final LinkedList parents = this.xmlPackageReader.getParents();\n        final ListIterator it = parents.listIterator( parents.size() );\n        it.previous();\n        \n        Object parent = it.previous();\n        \n        //TODO: Again same problem with these parent shit\n        \n        if (parent instanceof FieldConstraintDescr) {\n\t        final FieldConstraintDescr fieldConstraintDescr = (FieldConstraintDescr) parent;\n\t        fieldConstraintDescr.addRestriction( returnValueDescr );\n        } else {\n            System.out.println(\"ReturnValueRestriction\");\n        }\n\n        return null;\n    }","commit_id":"83e74549d080b6249a26b38383bb3c75447f5449","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Object end(final String uri,\r\n                      final String localName) throws SAXException {\r\n        final Configuration config = this.xmlPackageReader.endConfiguration();\r\n\r\n        final VariableRestrictionDescr variableDescr = (VariableRestrictionDescr) this.xmlPackageReader.getCurrent();\r\n\r\n        final LinkedList parents = this.xmlPackageReader.getParents();\r\n        final ListIterator it = parents.listIterator( parents.size() );\r\n        it.previous();\r\n        final FieldConstraintDescr fieldConstraintDescr = (FieldConstraintDescr) it.previous();\r\n\r\n        fieldConstraintDescr.addRestriction( variableDescr );\r\n\r\n        return null;\r\n    }","id":601,"modified_method":"public Object end(final String uri,\n                      final String localName) throws SAXException {\n        final Configuration config = this.xmlPackageReader.endConfiguration();\n\n        final VariableRestrictionDescr variableDescr = (VariableRestrictionDescr) this.xmlPackageReader.getCurrent();\n\n        final LinkedList parents = this.xmlPackageReader.getParents();\n        final ListIterator it = parents.listIterator( parents.size() );\n        it.previous();\n        \n        Object parent = it.previous();\n        \n        if ( parent instanceof FieldConstraintDescr ) {\n        \tfinal FieldConstraintDescr fieldConstraintDescr = (FieldConstraintDescr) parent;\n        \tfieldConstraintDescr.addRestriction( variableDescr );\n        } else {\n            System.out.println(\"variableRestriction class\");\n        }\n\n        return null;\n    }","commit_id":"83e74549d080b6249a26b38383bb3c75447f5449","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static boolean baseMappingRule_Condition_7060824959896205081(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:b567205c-7e17-4168-b413-945a6e17f37d(jetbrains.mps.samples.Kaja.structure)\", \"LookingDirection\"), \"east\")).equals(SPropertyOperations.getString_def(_context.getNode(), \"direction\", null));\n  }","id":602,"modified_method":"public static boolean baseMappingRule_Condition_7060824959896205081(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SPropertyOperations.hasValue(_context.getNode(), \"direction\", \"east\", null);\n  }","commit_id":"e0f28275b68c677a82aa25a1c864ac5f97c202e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_7060824959896330163(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:b567205c-7e17-4168-b413-945a6e17f37d(jetbrains.mps.samples.Kaja.structure)\", \"LookingDirection\"), \"north\")).equals(SPropertyOperations.getString_def(_context.getNode(), \"direction\", null));\n  }","id":603,"modified_method":"public static boolean baseMappingRule_Condition_7060824959896330163(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SPropertyOperations.hasValue(_context.getNode(), \"direction\", \"north\", null);\n  }","commit_id":"e0f28275b68c677a82aa25a1c864ac5f97c202e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_7060824959896333440(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:b567205c-7e17-4168-b413-945a6e17f37d(jetbrains.mps.samples.Kaja.structure)\", \"LookingDirection\"), \"south\")).equals(SPropertyOperations.getString_def(_context.getNode(), \"direction\", null));\n  }","id":604,"modified_method":"public static boolean baseMappingRule_Condition_7060824959896333440(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SPropertyOperations.hasValue(_context.getNode(), \"direction\", \"south\", null);\n  }","commit_id":"e0f28275b68c677a82aa25a1c864ac5f97c202e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean baseMappingRule_Condition_7060824959896333392(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SEnumOperations.getEnumMemberValue(SEnumOperations.getEnumMember(SEnumOperations.getEnum(\"r:b567205c-7e17-4168-b413-945a6e17f37d(jetbrains.mps.samples.Kaja.structure)\", \"LookingDirection\"), \"west\")).equals(SPropertyOperations.getString_def(_context.getNode(), \"direction\", null));\n  }","id":605,"modified_method":"public static boolean baseMappingRule_Condition_7060824959896333392(final IOperationContext operationContext, final BaseMappingRuleContext _context) {\n    return SPropertyOperations.hasValue(_context.getNode(), \"direction\", \"west\", null);\n  }","commit_id":"e0f28275b68c677a82aa25a1c864ac5f97c202e2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n    public void makeSureCoreClusterCanBeRestoredFromABackup() throws Throwable\n    {\n        // given\n        CoreGraphDatabase db = createSomeData( cluster );\n        DbRepresentation beforeBackup = DbRepresentation.of( db );\n        String[] args = backupArguments(backupAddress(db), backupPath.getPath() );\n        assertEquals( 0, runBackupToolFromOtherJvmToGetExitCode( args ) );\n\n        // when we shutdown the cluster we lose the number of core servers so we won't go through the for loop unless\n        // we capture the count beforehand\n        List<File> dbPaths = cluster.coreServers().stream().map( CoreServer::storeDir ).collect( toList() );\n        int numberOfCoreServers = dbPaths.size();\n\n        cluster.shutdown();\n        assertAllStoresHaveTheSameStoreId( dbPaths, fs );\n        TestStoreId storeId = TestStoreId.readStoreId( dbPaths.get( 0 ), fs );\n\n        // when\n\n        StringBuilder output = new StringBuilder();\n        PrintStream sysout = new PrintStream( new RestoreClusterUtils.MyOutputStream( output ) );\n\n        File homeDir = cluster.getCoreServerById( 0 ).homeDir();\n        new RestoreNewClusterCli( sysout ).run(toArray( args().homeDir( homeDir ).config( homeDir ).from( backupPath )\n                .database( \"graph.db\" ).force().build() ));\n\n        String seed = RestoreClusterCliTest.extractSeed( output.toString() );\n\n        for ( int i = 1; i < numberOfCoreServers; i++ )\n        {\n            homeDir = cluster.getCoreServerById( i ).homeDir();\n            new RestoreExistingClusterCli(  ).run( toArray( args().homeDir( homeDir )\n                    .config( homeDir ).from( backupPath ).database( \"graph.db\" ).seed( seed ).force().build() ) );\n        }\n\n        cluster.start();\n\n        // then\n        Collection<CoreServer> coreGraphDatabases = cluster.coreServers();\n        Stream<DbRepresentation> dbRepresentations = coreGraphDatabases.stream().map( x -> DbRepresentation.of(x.database()) );\n        dbRepresentations.forEach( afterReSeed -> assertEquals( beforeBackup, afterReSeed ) );\n\n        List<File> afterRestoreDbPaths = coreGraphDatabases.stream().map( CoreServer::storeDir ).collect( toList() );\n        cluster.shutdown();\n\n        assertAllStoresHaveTheSameStoreId( afterRestoreDbPaths, fs );\n        TestStoreId afterRestoreStoreId = TestStoreId.readStoreId( afterRestoreDbPaths.get( 0 ), fs );\n        assertNotEquals( storeId, afterRestoreStoreId );\n    }","id":606,"modified_method":"@Test\n    public void makeSureCoreClusterCanBeRestoredFromABackup() throws Throwable\n    {\n        // given\n        CoreGraphDatabase db = createSomeData( cluster );\n        DbRepresentation beforeBackup = DbRepresentation.of( db );\n        String[] args = backupArguments(backupAddress(db), backupPath.getPath() );\n        assertEquals( 0, runBackupToolFromOtherJvmToGetExitCode( args ) );\n\n        // when we shutdown the cluster we lose the number of core servers so we won't go through the for loop unless\n        // we capture the count beforehand\n        List<File> dbPaths = cluster.coreServers().stream().map( CoreServer::storeDir ).collect( toList() );\n        int numberOfCoreServers = dbPaths.size();\n\n        cluster.shutdown();\n        assertAllStoresHaveTheSameStoreId( dbPaths, fs );\n        TestStoreId storeId = TestStoreId.readStoreId( dbPaths.get( 0 ), fs );\n\n        // when\n\n        StringBuilder output = new StringBuilder();\n        PrintStream sysout = new PrintStream( new RestoreClusterUtils.MyOutputStream( output ) );\n\n        Path homeDir = Paths.get(cluster.getCoreServerById( 0 ).homeDir().getPath());\n        new RestoreNewClusterCli( homeDir, homeDir, sysout ).execute(toArray( args().from( backupPath )\n                .database( \"graph.db\" ).force().build() ));\n\n        String seed = RestoreClusterCliTest.extractSeed( output.toString() );\n\n        for ( int i = 1; i < numberOfCoreServers; i++ )\n        {\n            homeDir = Paths.get(cluster.getCoreServerById( i ).homeDir().getPath());\n            new RestoreExistingClusterCli( homeDir, homeDir  ).execute(\n                    toArray( args().from( backupPath ).database( \"graph.db\" ).seed( seed ).force().build() ) );\n        }\n\n        cluster.start();\n\n        // then\n        Collection<CoreServer> coreGraphDatabases = cluster.coreServers();\n        Stream<DbRepresentation> dbRepresentations = coreGraphDatabases.stream().map( x -> DbRepresentation.of(x.database()) );\n        dbRepresentations.forEach( afterReSeed -> assertEquals( beforeBackup, afterReSeed ) );\n\n        List<File> afterRestoreDbPaths = coreGraphDatabases.stream().map( CoreServer::storeDir ).collect( toList() );\n        cluster.shutdown();\n\n        assertAllStoresHaveTheSameStoreId( afterRestoreDbPaths, fs );\n        TestStoreId afterRestoreStoreId = TestStoreId.readStoreId( afterRestoreDbPaths.get( 0 ), fs );\n        assertNotEquals( storeId, afterRestoreStoreId );\n    }","commit_id":"77a5e62f9d5a56a48f82b6bdd8519b18275bef1d","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldReplicateTransactionToCoreServers() throws Throwable\n    {\n        // given\n        File dbDir = clusterRule.testDirectory().cleanDirectory( \"classic-db\" );\n        File classicNeo4jStore = createClassicNeo4jStore( dbDir, 10, recordFormat );\n\n        Cluster cluster = this.clusterRule.withRecordFormat( recordFormat ).createCluster();\n\n        File homeDir = cluster.getCoreServerById( 0 ).homeDir();\n\n        StringBuilder output = new StringBuilder();\n        PrintStream sysout = new PrintStream( new RestoreClusterUtils.MyOutputStream( output ) );\n\n        new RestoreNewClusterCli( sysout ).run(  toArray( args().homeDir( homeDir ).config( homeDir )\n                .from( classicNeo4jStore ).database( \"graph.db\" ).force().build() )  );\n\n        String seed = RestoreClusterCliTest.extractSeed( output.toString() );\n\n        for ( int serverId = 1; serverId < CLUSTER_SIZE; serverId++ )\n        {\n            File destination = cluster.getCoreServerById( serverId ).homeDir();\n\n            new RestoreExistingClusterCli(  ).run(  toArray( args().homeDir( destination ).config( destination )\n                    .from( classicNeo4jStore ).database( \"graph.db\" ).seed( seed ).force().build() )  );\n        }\n\n        cluster.start();\n\n        // when\n        CoreGraphDatabase coreDB = cluster.awaitLeader( 5000 ).database();\n\n        try ( Transaction tx = coreDB.beginTx() )\n        {\n            Node node = coreDB.createNode( label( \"boo\" ) );\n            node.setProperty( \"foobar\", \"baz_bat\" );\n            tx.success();\n        }\n\n        cluster.addEdgeServerWithIdAndRecordFormat( 4, recordFormat ).start();\n\n        // then\n        for ( final CoreServer server : cluster.coreServers() )\n        {\n            CoreGraphDatabase db = server.database();\n\n            try ( Transaction tx = db.beginTx() )\n            {\n                ThrowingSupplier<Long, Exception> nodeCount = () -> count( db.getAllNodes() );\n\n                Config config = db.getDependencyResolver().resolveDependency( Config.class );\n\n                assertEventually( \"node to appear on core server \" + config.get( raft_advertised_address ), nodeCount,\n                        greaterThan( 0L ), 15, SECONDS );\n\n                assertEquals( 11, count( db.getAllNodes() ) );\n\n                tx.success();\n            }\n        }\n    }","id":607,"modified_method":"@Test\n    public void shouldReplicateTransactionToCoreServers() throws Throwable\n    {\n        // given\n        File dbDir = clusterRule.testDirectory().cleanDirectory( \"classic-db\" );\n        File classicNeo4jStore = createClassicNeo4jStore( dbDir, 10, recordFormat );\n\n        Cluster cluster = this.clusterRule.withRecordFormat( recordFormat ).createCluster();\n\n        Path homeDir = Paths.get(cluster.getCoreServerById( 0 ).homeDir().getPath());\n\n        StringBuilder output = new StringBuilder();\n        PrintStream sysout = new PrintStream( new RestoreClusterUtils.MyOutputStream( output ) );\n\n        new RestoreNewClusterCli( homeDir, homeDir, sysout ).execute(\n                toArray( args().from( classicNeo4jStore ).database( \"graph.db\" ).force().build() )  );\n\n        String seed = RestoreClusterCliTest.extractSeed( output.toString() );\n\n        for ( int serverId = 1; serverId < CLUSTER_SIZE; serverId++ )\n        {\n            Path destination = Paths.get(cluster.getCoreServerById( serverId ).homeDir().getPath());\n\n            new RestoreExistingClusterCli( destination, destination ).execute(\n                    toArray( args().from( classicNeo4jStore ).database( \"graph.db\" ).seed( seed ).force().build() )  );\n        }\n\n        cluster.start();\n\n        // when\n        CoreGraphDatabase coreDB = cluster.awaitLeader( 5000 ).database();\n\n        try ( Transaction tx = coreDB.beginTx() )\n        {\n            Node node = coreDB.createNode( label( \"boo\" ) );\n            node.setProperty( \"foobar\", \"baz_bat\" );\n            tx.success();\n        }\n\n        cluster.addEdgeServerWithIdAndRecordFormat( 4, recordFormat ).start();\n\n        // then\n        for ( final CoreServer server : cluster.coreServers() )\n        {\n            CoreGraphDatabase db = server.database();\n\n            try ( Transaction tx = db.beginTx() )\n            {\n                ThrowingSupplier<Long, Exception> nodeCount = () -> count( db.getAllNodes() );\n\n                Config config = db.getDependencyResolver().resolveDependency( Config.class );\n\n                assertEventually( \"node to appear on core server \" + config.get( raft_advertised_address ), nodeCount,\n                        greaterThan( 0L ), 15, SECONDS );\n\n                assertEquals( 11, count( db.getAllNodes() ) );\n\n                tx.success();\n            }\n        }\n    }","commit_id":"77a5e62f9d5a56a48f82b6bdd8519b18275bef1d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static GroovyElementType parse(PsiBuilder builder) {\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      GroovyElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n\n\n    PsiBuilder.Marker varDefMarker = builder.mark();\n\n    //typized var definition\n    //todo: check for upper case type specification \n    if (WRONGWAY.equals(TypeSpec.parse(builder))) {\n      varDefMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    GroovyElementType varDef = VariableDefinitions.parse(builder, true);\n    if (!WRONGWAY.equals(varDef)) {\n      varDefMarker.done(varDef);\n      return varDef;\n    }\n    varDefMarker.rollbackTo();\n\n    return WRONGWAY;\n  }","id":608,"modified_method":"public static GroovyElementType parse(PsiBuilder builder) {\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    GroovyElementType typeDef = TypeDefinition.parse(builder);\n\n    if (!WRONGWAY.equals(typeDef)) {\n      typeDeclStartMarker.drop();\n      return typeDef;\n    } else {\n      typeDeclStartMarker.rollbackTo();\n    }\n\n    PsiBuilder.Marker declMarker = builder.mark();\n\n    //typized var definition\n    GroovyElementType declaration = Declaration.parse(builder, true, true);\n    if (!WRONGWAY.equals(declaration)) {\n      declMarker.drop();\n      return declaration;\n    } else {\n      declMarker.rollbackTo();\n    }\n\n    return WRONGWAY;\n  }","commit_id":"584e52b60cb0b3e59adfd85d0b548fdabef92acc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parse(PsiBuilder builder) {\n\n    //constructor\n    PsiBuilder.Marker constructorMarker = builder.mark();\n    ModifiersOptional.parse(builder);\n\n    GroovyElementType constructorDef = ConstructorDefinition.parse(builder);\n\n    if (WRONGWAY.equals(constructorDef)) {\n      constructorMarker.rollbackTo();\n    } else {\n      constructorMarker.done(constructorDef);\n      return constructorDef;\n    }\n\n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    if (DeclarationStart.parse(builder)) {\n      declMarker.rollbackTo();\n      return Declaration.parse(builder);\n    }\n\n    declMarker.rollbackTo();\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n\n    //static compound statement\n    if (ParserUtils.getToken(builder, kSTATIC)) {\n      if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n        return STATIC_COMPOUND_STATEMENT;\n      } else {\n        builder.error(GroovyBundle.message(\"compound.statemenet.expected\"));\n        return WRONGWAY;\n      }\n    }\n\n    if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n      return COMPOUND_STATEMENT;\n    }\n\n    return WRONGWAY;\n  }","id":609,"modified_method":"public static IElementType parse(PsiBuilder builder) {\n\n    //constructor\n    PsiBuilder.Marker constructorMarker = builder.mark();\n    ModifiersOptional.parse(builder);\n\n    GroovyElementType constructorDef = ConstructorDefinition.parse(builder);\n\n    if (WRONGWAY.equals(constructorDef)) {\n      constructorMarker.rollbackTo();\n    } else {\n      constructorMarker.done(constructorDef);\n      return constructorDef;\n    }\n\n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    GroovyElementType declType = Declaration.parse(builder);\n    if (WRONGWAY.equals(declType)) {\n      declMarker.rollbackTo();\n    } else {\n      declMarker.drop();\n      return declType;\n    }\n//    if (DeclarationStart.parse(builder)) {\n//      declMarker.rollbackTo();\n//      return Declaration.parse(builder);\n//    }\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n\n    //static compound statement\n    if (ParserUtils.getToken(builder, kSTATIC)) {\n      if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n        return STATIC_COMPOUND_STATEMENT;\n      } else {\n        builder.error(GroovyBundle.message(\"compound.statemenet.expected\"));\n        return WRONGWAY;\n      }\n    }\n\n    if (!WRONGWAY.equals(OpenOrClosableBlock.parseOpenBlock(builder))) {\n      return COMPOUND_STATEMENT;\n    }\n\n    return WRONGWAY;\n  }","commit_id":"0b90f50066baba0b779bb3d1e0b5b534f408700f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IElementType parse(PsiBuilder builder) {\n\n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    if (DeclarationStart.parse(builder)) {\n      declMarker.rollbackTo();\n      return Declaration.parse(builder);\n    }\n    declMarker.rollbackTo();\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n    \n    return WRONGWAY;\n  }","id":610,"modified_method":"public static IElementType parse(PsiBuilder builder) {\n\n    //declaration\n    PsiBuilder.Marker declMarker = builder.mark();\n    GroovyElementType declType = Declaration.parse(builder);\n    if (WRONGWAY.equals(declType)) {\n      declMarker.rollbackTo();\n    } else {\n      declMarker.drop();\n      return declType;\n    }\n\n    //declaration\n//    PsiBuilder.Marker declMarker = builder.mark();\n//    if (DeclarationStart.parse(builder)) {\n//      declMarker.rollbackTo();\n//      return Declaration.parse(builder);\n//    }\n//    declMarker.rollbackTo();\n\n    //type definition\n    PsiBuilder.Marker typeDeclStartMarker = builder.mark();\n    if (TypeDeclarationStart.parse(builder)) {\n      typeDeclStartMarker.rollbackTo();\n\n      IElementType typeDef = TypeDefinition.parse(builder);\n      if (WRONGWAY.equals(typeDef)) {\n        return WRONGWAY;\n      }\n      return typeDef;\n    }\n    typeDeclStartMarker.rollbackTo();\n    \n    return WRONGWAY;\n  }","commit_id":"0b90f50066baba0b779bb3d1e0b5b534f408700f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void restoreDependentFromTrash(\n\t\t\tUser user, List<Object> categoriesAndThreads, long trashEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : categoriesAndThreads) {\n\t\t\tif (object instanceof MBThread) {\n\t\t\t\tMBThread thread = (MBThread)object;\n\n\t\t\t\tTrashEntry trashEntry = trashEntryLocalService.fetchEntry(\n\t\t\t\t\tMBThread.class.getName(), thread.getThreadId());\n\n\t\t\t\tif (trashEntry != null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tTrashVersion trashVersion =\n\t\t\t\t\ttrashVersionLocalService.fetchVersion(\n\t\t\t\t\t\ttrashEntryId, MBThread.class.getName(),\n\t\t\t\t\t\tthread.getThreadId());\n\n\t\t\t\tthread.setStatus(trashVersion.getStatus());\n\n\t\t\t\tmbThreadPersistence.update(thread);\n\n\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\n\t\t\t\tmbThreadLocalService.restoreDependentsFromTrash(\n\t\t\t\t\tuser.getUserId(), thread.getThreadId(), trashEntryId);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\tMBThread.class);\n\n\t\t\t\tindexer.reindex(thread);\n\t\t\t}\n\t\t\telse if (object instanceof MBCategory) {\n\t\t\t\tMBCategory category = (MBCategory)object;\n\n\t\t\t\tTrashEntry trashEntry = trashEntryLocalService.fetchEntry(\n\t\t\t\t\tMBCategory.class.getName(), category.getCategoryId());\n\n\t\t\t\tif (trashEntry != null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tTrashVersion trashVersion =\n\t\t\t\t\ttrashVersionLocalService.fetchVersion(\n\t\t\t\t\t\ttrashEntryId, MBCategory.class.getName(),\n\t\t\t\t\t\tcategory.getCategoryId());\n\n\t\t\t\tcategory.setStatus(trashVersion.getStatus());\n\n\t\t\t\tmbCategoryPersistence.update(category);\n\n\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\n\t\t\t\trestoreDependentFromTrash(\n\t\t\t\t\tuser,\n\t\t\t\t\tgetCategoriesAndThreads(\n\t\t\t\t\t\tcategory.getGroupId(), category.getCategoryId()),\n\t\t\t\t\ttrashEntryId);\n\t\t\t}\n\t\t}\n\t}","id":611,"modified_method":"protected void restoreDependentFromTrash(\n\t\t\tUser user, List<Object> categoriesAndThreads, long trashEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tfor (Object object : categoriesAndThreads) {\n\t\t\tif (object instanceof MBThread) {\n\t\t\t\tMBThread thread = (MBThread)object;\n\n\t\t\t\tTrashEntry trashEntry = trashEntryLocalService.fetchEntry(\n\t\t\t\t\tMBThread.class.getName(), thread.getThreadId());\n\n\t\t\t\tif (trashEntry != null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tTrashVersion trashVersion =\n\t\t\t\t\ttrashVersionLocalService.fetchVersion(\n\t\t\t\t\t\ttrashEntryId, MBThread.class.getName(),\n\t\t\t\t\t\tthread.getThreadId());\n\n\t\t\t\tint oldStatus = WorkflowConstants.STATUS_APPROVED;\n\n\t\t\t\tif (trashVersion != null) {\n\t\t\t\t\toldStatus = trashVersion.getStatus();\n\t\t\t\t}\n\n\t\t\t\tthread.setStatus(oldStatus);\n\n\t\t\t\tmbThreadPersistence.update(thread);\n\n\t\t\t\tif (trashVersion != null) {\n\t\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\t\t\t\t}\n\n\t\t\t\tmbThreadLocalService.restoreDependentsFromTrash(\n\t\t\t\t\tuser.getUserId(), thread.getThreadId(), trashEntryId);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\t\tMBThread.class);\n\n\t\t\t\tindexer.reindex(thread);\n\t\t\t}\n\t\t\telse if (object instanceof MBCategory) {\n\t\t\t\tMBCategory category = (MBCategory)object;\n\n\t\t\t\tTrashEntry trashEntry = trashEntryLocalService.fetchEntry(\n\t\t\t\t\tMBCategory.class.getName(), category.getCategoryId());\n\n\t\t\t\tif (trashEntry != null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tTrashVersion trashVersion =\n\t\t\t\t\ttrashVersionLocalService.fetchVersion(\n\t\t\t\t\t\ttrashEntryId, MBCategory.class.getName(),\n\t\t\t\t\t\tcategory.getCategoryId());\n\n\t\t\t\tint oldStatus = WorkflowConstants.STATUS_APPROVED;\n\n\t\t\t\tif (trashVersion != null) {\n\t\t\t\t\toldStatus = trashVersion.getStatus();\n\t\t\t\t}\n\n\t\t\t\tcategory.setStatus(oldStatus);\n\n\t\t\t\tmbCategoryPersistence.update(category);\n\n\t\t\t\tif (trashVersion != null) {\n\t\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\t\t\t\t}\n\n\t\t\t\trestoreDependentFromTrash(\n\t\t\t\t\tuser,\n\t\t\t\t\tgetCategoriesAndThreads(\n\t\t\t\t\t\tcategory.getGroupId(), category.getCategoryId()),\n\t\t\t\t\ttrashEntryId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"a3593faf765eb89cc7cb41d1e6fbb5bb8c12a7bf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void restoreDependentsFromTrash(\n\t\t\tlong groupId, long threadId, long trashEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tSet<Long> userIds = new HashSet<Long>();\n\n\t\tList<MBMessage> messages = mbMessageLocalService.getThreadMessages(\n\t\t\tthreadId, WorkflowConstants.STATUS_ANY);\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tif (message.isDiscussion()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTrashVersion trashVersion = trashVersionLocalService.fetchVersion(\n\t\t\t\ttrashEntryId, MBMessage.class.getName(),\n\t\t\t\tmessage.getMessageId());\n\n\t\t\tint oldStatus = trashVersion.getStatus();\n\n\t\t\tmessage.setStatus(oldStatus);\n\n\t\t\tmbMessagePersistence.update(message);\n\n\t\t\tuserIds.add(message.getUserId());\n\n\t\t\t// Asset\n\n\t\t\tif (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\t\t\t}\n\n\t\t\t// Trash\n\n\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\tMBMessage.class);\n\n\t\t\tindexer.reindex(message);\n\t\t}\n\n\t\t// Statistics\n\n\t\tfor (long userId : userIds) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(groupId, userId);\n\t\t}\n\t}","id":612,"modified_method":"@Override\n\tpublic void restoreDependentsFromTrash(\n\t\t\tlong groupId, long threadId, long trashEntryId)\n\t\tthrows PortalException, SystemException {\n\n\t\tSet<Long> userIds = new HashSet<Long>();\n\n\t\tList<MBMessage> messages = mbMessageLocalService.getThreadMessages(\n\t\t\tthreadId, WorkflowConstants.STATUS_ANY);\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tif (message.isDiscussion()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTrashVersion trashVersion = trashVersionLocalService.fetchVersion(\n\t\t\t\ttrashEntryId, MBMessage.class.getName(),\n\t\t\t\tmessage.getMessageId());\n\n\t\t\tint oldStatus = WorkflowConstants.STATUS_APPROVED;\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\toldStatus = trashVersion.getStatus();\n\t\t\t}\n\n\t\t\tmessage.setStatus(oldStatus);\n\n\t\t\tmbMessagePersistence.update(message);\n\n\t\t\tuserIds.add(message.getUserId());\n\n\t\t\t// Asset\n\n\t\t\tif (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\t\t\t}\n\n\t\t\t// Trash\n\n\t\t\tif (trashVersion != null) {\n\t\t\t\ttrashVersionLocalService.deleteTrashVersion(trashVersion);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tIndexer indexer = IndexerRegistryUtil.nullSafeGetIndexer(\n\t\t\t\tMBMessage.class);\n\n\t\t\tindexer.reindex(message);\n\t\t}\n\n\t\t// Statistics\n\n\t\tfor (long userId : userIds) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(groupId, userId);\n\t\t}\n\t}","commit_id":"a3593faf765eb89cc7cb41d1e6fbb5bb8c12a7bf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<CloudStackImageStoreDriverImpl, DownloadAnswer> callback,\n    \t\tCreateContext<CreateCmdResult> context) {\n    \tDownloadAnswer answer = callback.getResult();\n    \tDataObject obj = context.data;\n    \tDataStore store = obj.getDataStore();\n\n    \tTemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n    \tupdateBuilder.setDownloadPercent(answer.getDownloadPct());\n    \tupdateBuilder.setDownloadState(answer.getDownloadStatus());\n    \tupdateBuilder.setLastUpdated(new Date());\n    \tupdateBuilder.setErrorString(answer.getErrorString());\n    \tupdateBuilder.setJobId(answer.getJobId());\n    \tupdateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n    \tupdateBuilder.setInstallPath(answer.getInstallPath());\n    \tupdateBuilder.setSize(answer.getTemplateSize());\n    \tupdateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n    \t_templateStoreDao.update(store.getId(), updateBuilder);\n\n    \tAsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n    \tif (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR ||\n    \t\t\tanswer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED ||\n    \t\t\tanswer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n    \t\tCreateCmdResult result = new CreateCmdResult(null, null);\n    \t\tresult.setSucess(false);\n    \t\tresult.setResult(answer.getErrorString());\n    \t\tcaller.complete(result);\n    \t} else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n    \t\tif (answer.getCheckSum() != null) {\n    \t\t\tVMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n    \t\t\ttemplateDaoBuilder.setChecksum(answer.getCheckSum());\n    \t\t\ttemplateDao.update(obj.getId(), templateDaoBuilder);\n    \t\t}\n\n\n    \t\tCreateCmdResult result = new CreateCmdResult(null, null);\n    \t\tcaller.complete(result);\n    \t}\n    \treturn null;\n    }","id":613,"modified_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<CloudStackImageStoreDriverImpl, DownloadAnswer> callback,\n    \t\tCreateContext<CreateCmdResult> context) {\n    \tDownloadAnswer answer = callback.getResult();\n    \tDataObject obj = context.data;\n    \tDataStore store = obj.getDataStore();\n\n    \tTemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(),obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n        }\n\n    \tAsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n    \tif (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR ||\n    \t\t\tanswer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED ||\n    \t\t\tanswer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n    \t\tCreateCmdResult result = new CreateCmdResult(null, null);\n    \t\tresult.setSucess(false);\n    \t\tresult.setResult(answer.getErrorString());\n    \t\tcaller.complete(result);\n    \t} else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n    \t\tif (answer.getCheckSum() != null) {\n    \t\t\tVMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n    \t\t\ttemplateDaoBuilder.setChecksum(answer.getCheckSum());\n    \t\t\ttemplateDao.update(obj.getId(), templateDaoBuilder);\n    \t\t}\n\n\n    \t\tCreateCmdResult result = new CreateCmdResult(null, null);\n    \t\tcaller.complete(result);\n    \t}\n    \treturn null;\n    }","commit_id":"70f866156ffda99d5e769219bfaa46734842fcd7","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<S3ImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n        updateBuilder.setDownloadPercent(answer.getDownloadPct());\n        updateBuilder.setDownloadState(answer.getDownloadStatus());\n        updateBuilder.setLastUpdated(new Date());\n        updateBuilder.setErrorString(answer.getErrorString());\n        updateBuilder.setJobId(answer.getJobId());\n        updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n        updateBuilder.setInstallPath(answer.getInstallPath());\n        updateBuilder.setSize(answer.getTemplateSize());\n        updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n        _templateStoreDao.update(store.getId(), updateBuilder);\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSucess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","id":614,"modified_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<S3ImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(),obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSucess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","commit_id":"70f866156ffda99d5e769219bfaa46734842fcd7","url":"https://github.com/apache/cloudstack"},{"original_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<SwiftImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n        updateBuilder.setDownloadPercent(answer.getDownloadPct());\n        updateBuilder.setDownloadState(answer.getDownloadStatus());\n        updateBuilder.setLastUpdated(new Date());\n        updateBuilder.setErrorString(answer.getErrorString());\n        updateBuilder.setJobId(answer.getJobId());\n        updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n        updateBuilder.setInstallPath(answer.getInstallPath());\n        updateBuilder.setSize(answer.getTemplateSize());\n        updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n        _templateStoreDao.update(store.getId(), updateBuilder);\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSucess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","id":615,"modified_method":"protected Void createAsyncCallback(AsyncCallbackDispatcher<SwiftImageStoreDriverImpl, DownloadAnswer> callback,\n            CreateContext<CreateCmdResult> context) {\n        DownloadAnswer answer = callback.getResult();\n        DataObject obj = context.data;\n        DataStore store = obj.getDataStore();\n\n        TemplateDataStoreVO tmpltStoreVO = _templateStoreDao.findByStoreTemplate(store.getId(),obj.getId());\n        if (tmpltStoreVO != null) {\n            TemplateDataStoreVO updateBuilder = _templateStoreDao.createForUpdate();\n            updateBuilder.setDownloadPercent(answer.getDownloadPct());\n            updateBuilder.setDownloadState(answer.getDownloadStatus());\n            updateBuilder.setLastUpdated(new Date());\n            updateBuilder.setErrorString(answer.getErrorString());\n            updateBuilder.setJobId(answer.getJobId());\n            updateBuilder.setLocalDownloadPath(answer.getDownloadPath());\n            updateBuilder.setInstallPath(answer.getInstallPath());\n            updateBuilder.setSize(answer.getTemplateSize());\n            updateBuilder.setPhysicalSize(answer.getTemplatePhySicalSize());\n            _templateStoreDao.update(tmpltStoreVO.getId(), updateBuilder);\n        }\n\n        AsyncCompletionCallback<CreateCmdResult> caller = context.getParentCallback();\n\n        if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOAD_ERROR ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.ABANDONED ||\n                answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.UNKNOWN) {\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            result.setSucess(false);\n            result.setResult(answer.getErrorString());\n            caller.complete(result);\n        } else if (answer.getDownloadStatus() == VMTemplateStorageResourceAssoc.Status.DOWNLOADED) {\n            if (answer.getCheckSum() != null) {\n                VMTemplateVO templateDaoBuilder = templateDao.createForUpdate();\n                templateDaoBuilder.setChecksum(answer.getCheckSum());\n                templateDao.update(obj.getId(), templateDaoBuilder);\n            }\n\n\n            CreateCmdResult result = new CreateCmdResult(null, null);\n            caller.complete(result);\n        }\n        return null;\n    }","commit_id":"70f866156ffda99d5e769219bfaa46734842fcd7","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n\tpublic BackgroundTaskResult execute(BackgroundTask backgroundTask)\n\t\tthrows Exception {\n\n\t\tMap<String, Serializable> taskContextMap =\n\t\t\tbackgroundTask.getTaskContextMap();\n\n\t\tlong userId = MapUtil.getLong(taskContextMap, \"userId\");\n\t\tString fileName = MapUtil.getString(taskContextMap, \"fileName\");\n\n\t\tlong groupId = MapUtil.getLong(taskContextMap, \"groupId\");\n\t\tboolean privateLayout = MapUtil.getBoolean(\n\t\t\ttaskContextMap, \"privateLayout\");\n\t\tlong[] layoutIds = GetterUtil.getLongValues(\n\t\t\ttaskContextMap.get(\"layoutIds\"));\n\t\tMap<String, String[]> parameterMap =\n\t\t\t(Map<String, String[]>)taskContextMap.get(\"parameterMap\");\n\t\tDate startDate = (Date)taskContextMap.get(\"startDate\");\n\t\tDate endDate = (Date)taskContextMap.get(\"endDate\");\n\n\t\tDate lastPublishDate = new Date();\n\n\t\tif (endDate != null) {\n\t\t\tlastPublishDate = endDate;\n\t\t}\n\n\t\tFile larFile = LayoutLocalServiceUtil.exportLayoutsAsFile(\n\t\t\tgroupId, privateLayout, layoutIds, parameterMap, startDate,\n\t\t\tendDate);\n\n\t\tBackgroundTaskLocalServiceUtil.addBackgroundTaskAttachment(\n\t\t\tuserId, backgroundTask.getBackgroundTaskId(), fileName, larFile);\n\n\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\tif (updateLastPublishDate) {\n\t\t\tStagingUtil.updateLastPublishDate(\n\t\t\t\tgroupId, privateLayout, lastPublishDate);\n\t\t}\n\n\t\treturn BackgroundTaskResult.SUCCESS;\n\t}","id":616,"modified_method":"@Override\n\tpublic BackgroundTaskResult execute(BackgroundTask backgroundTask)\n\t\tthrows Exception {\n\n\t\tMap<String, Serializable> taskContextMap =\n\t\t\tbackgroundTask.getTaskContextMap();\n\n\t\tlong userId = MapUtil.getLong(taskContextMap, \"userId\");\n\t\tString fileName = MapUtil.getString(taskContextMap, \"fileName\");\n\n\t\tlong groupId = MapUtil.getLong(taskContextMap, \"groupId\");\n\t\tboolean privateLayout = MapUtil.getBoolean(\n\t\t\ttaskContextMap, \"privateLayout\");\n\t\tlong[] layoutIds = GetterUtil.getLongValues(\n\t\t\ttaskContextMap.get(\"layoutIds\"));\n\t\tMap<String, String[]> parameterMap =\n\t\t\t(Map<String, String[]>)taskContextMap.get(\"parameterMap\");\n\t\tDate startDate = (Date)taskContextMap.get(\"startDate\");\n\t\tDate endDate = (Date)taskContextMap.get(\"endDate\");\n\n\t\tFile larFile = LayoutLocalServiceUtil.exportLayoutsAsFile(\n\t\t\tgroupId, privateLayout, layoutIds, parameterMap, startDate,\n\t\t\tendDate);\n\n\t\tBackgroundTaskLocalServiceUtil.addBackgroundTaskAttachment(\n\t\t\tuserId, backgroundTask.getBackgroundTaskId(), fileName, larFile);\n\n\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\tif (updateLastPublishDate) {\n\t\t\tDate lastPublishDate = endDate;\n\n\t\t\tif (lastPublishDate == null) {\n\t\t\t\tlastPublishDate = new Date();\n\t\t\t}\n\n\t\t\tStagingUtil.updateLastPublishDate(\n\t\t\t\tgroupId, privateLayout, lastPublishDate);\n\t\t}\n\n\t\treturn BackgroundTaskResult.SUCCESS;\n\t}","commit_id":"a749c94e54dfbe43ae66ec86f318b8266a36acb5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic BackgroundTaskResult execute(BackgroundTask backgroundTask)\n\t\tthrows Exception {\n\n\t\tMap<String, Serializable> taskContextMap =\n\t\t\tbackgroundTask.getTaskContextMap();\n\n\t\tlong sourceGroupId = MapUtil.getLong(taskContextMap, \"groupId\");\n\t\tboolean privateLayout = MapUtil.getBoolean(\n\t\t\ttaskContextMap, \"privateLayout\");\n\t\tMap<Long, Boolean> layoutIdMap = (Map<Long, Boolean>)taskContextMap.get(\n\t\t\t\"layoutIdMap\");\n\t\tMap<String, String[]> parameterMap =\n\t\t\t(Map<String, String[]>)taskContextMap.get(\"parameterMap\");\n\t\tlong remoteGroupId = MapUtil.getLong(taskContextMap, \"remoteGroupId\");\n\t\tDate startDate = (Date)taskContextMap.get(\"startDate\");\n\t\tDate endDate = (Date)taskContextMap.get(\"endDate\");\n\t\tHttpPrincipal httpPrincipal = (HttpPrincipal)taskContextMap.get(\n\t\t\t\"httpPrincipal\");\n\n\t\tclearBackgroundTaskStatus(backgroundTask);\n\n\t\tlong stagingRequestId = 0;\n\n\t\tFile file = null;\n\t\tFileInputStream fileInputStream = null;\n\t\tMissingReferences missingReferences = null;\n\n\t\ttry {\n\t\t\tDate lastPublishDate = new Date();\n\n\t\t\tif (endDate != null) {\n\t\t\t\tlastPublishDate = endDate;\n\t\t\t}\n\n\t\t\tfile = exportLayoutsAsFile(\n\t\t\t\tsourceGroupId, privateLayout, layoutIdMap, parameterMap,\n\t\t\t\tremoteGroupId, startDate, endDate, httpPrincipal);\n\n\t\t\tString checksum = FileUtil.getMD5Checksum(file);\n\n\t\t\tfileInputStream = new FileInputStream(file);\n\n\t\t\tstagingRequestId = StagingServiceHttp.createStagingRequest(\n\t\t\t\thttpPrincipal, remoteGroupId, checksum);\n\n\t\t\tbyte[] bytes =\n\t\t\t\tnew byte[PropsValues.STAGING_REMOTE_TRANSFER_BUFFER_SIZE];\n\n\t\t\tint i = 0;\n\n\t\t\twhile ((i = fileInputStream.read(bytes)) >= 0) {\n\t\t\t\tif (i < PropsValues.STAGING_REMOTE_TRANSFER_BUFFER_SIZE) {\n\t\t\t\t\tbyte[] tempBytes = new byte[i];\n\n\t\t\t\t\tSystem.arraycopy(bytes, 0, tempBytes, 0, i);\n\n\t\t\t\t\tStagingServiceHttp.updateStagingRequest(\n\t\t\t\t\t\thttpPrincipal, stagingRequestId, file.getName(),\n\t\t\t\t\t\ttempBytes);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStagingServiceHttp.updateStagingRequest(\n\t\t\t\t\t\thttpPrincipal, stagingRequestId, file.getName(), bytes);\n\t\t\t\t}\n\n\t\t\t\tbytes =\n\t\t\t\t\tnew byte[PropsValues.STAGING_REMOTE_TRANSFER_BUFFER_SIZE];\n\t\t\t}\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"exported\");\n\n\t\t\tmissingReferences = StagingServiceHttp.validateStagingRequest(\n\t\t\t\thttpPrincipal, stagingRequestId, privateLayout, parameterMap);\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"validated\");\n\n\t\t\tStagingServiceHttp.publishStagingRequest(\n\t\t\t\thttpPrincipal, stagingRequestId, privateLayout, parameterMap);\n\n\t\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\t\tif (updateLastPublishDate) {\n\t\t\t\tStagingUtil.updateLastPublishDate(\n\t\t\t\t\tsourceGroupId, privateLayout, lastPublishDate);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\n\t\t\tFileUtil.delete(file);\n\n\t\t\tif (stagingRequestId > 0) {\n\t\t\t\tStagingServiceHttp.cleanUpStagingRequest(\n\t\t\t\t\thttpPrincipal, stagingRequestId);\n\t\t\t}\n\t\t}\n\n\t\treturn processMissingReferences(backgroundTask, missingReferences);\n\t}","id":617,"modified_method":"@Override\n\tpublic BackgroundTaskResult execute(BackgroundTask backgroundTask)\n\t\tthrows Exception {\n\n\t\tMap<String, Serializable> taskContextMap =\n\t\t\tbackgroundTask.getTaskContextMap();\n\n\t\tlong sourceGroupId = MapUtil.getLong(taskContextMap, \"groupId\");\n\t\tboolean privateLayout = MapUtil.getBoolean(\n\t\t\ttaskContextMap, \"privateLayout\");\n\t\tMap<Long, Boolean> layoutIdMap = (Map<Long, Boolean>)taskContextMap.get(\n\t\t\t\"layoutIdMap\");\n\t\tMap<String, String[]> parameterMap =\n\t\t\t(Map<String, String[]>)taskContextMap.get(\"parameterMap\");\n\t\tlong remoteGroupId = MapUtil.getLong(taskContextMap, \"remoteGroupId\");\n\t\tDate startDate = (Date)taskContextMap.get(\"startDate\");\n\t\tDate endDate = (Date)taskContextMap.get(\"endDate\");\n\t\tHttpPrincipal httpPrincipal = (HttpPrincipal)taskContextMap.get(\n\t\t\t\"httpPrincipal\");\n\n\t\tclearBackgroundTaskStatus(backgroundTask);\n\n\t\tlong stagingRequestId = 0;\n\n\t\tFile file = null;\n\t\tFileInputStream fileInputStream = null;\n\t\tMissingReferences missingReferences = null;\n\n\t\ttry {\n\t\t\tfile = exportLayoutsAsFile(\n\t\t\t\tsourceGroupId, privateLayout, layoutIdMap, parameterMap,\n\t\t\t\tremoteGroupId, startDate, endDate, httpPrincipal);\n\n\t\t\tString checksum = FileUtil.getMD5Checksum(file);\n\n\t\t\tfileInputStream = new FileInputStream(file);\n\n\t\t\tstagingRequestId = StagingServiceHttp.createStagingRequest(\n\t\t\t\thttpPrincipal, remoteGroupId, checksum);\n\n\t\t\tbyte[] bytes =\n\t\t\t\tnew byte[PropsValues.STAGING_REMOTE_TRANSFER_BUFFER_SIZE];\n\n\t\t\tint i = 0;\n\n\t\t\twhile ((i = fileInputStream.read(bytes)) >= 0) {\n\t\t\t\tif (i < PropsValues.STAGING_REMOTE_TRANSFER_BUFFER_SIZE) {\n\t\t\t\t\tbyte[] tempBytes = new byte[i];\n\n\t\t\t\t\tSystem.arraycopy(bytes, 0, tempBytes, 0, i);\n\n\t\t\t\t\tStagingServiceHttp.updateStagingRequest(\n\t\t\t\t\t\thttpPrincipal, stagingRequestId, file.getName(),\n\t\t\t\t\t\ttempBytes);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStagingServiceHttp.updateStagingRequest(\n\t\t\t\t\t\thttpPrincipal, stagingRequestId, file.getName(), bytes);\n\t\t\t\t}\n\n\t\t\t\tbytes =\n\t\t\t\t\tnew byte[PropsValues.STAGING_REMOTE_TRANSFER_BUFFER_SIZE];\n\t\t\t}\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"exported\");\n\n\t\t\tmissingReferences = StagingServiceHttp.validateStagingRequest(\n\t\t\t\thttpPrincipal, stagingRequestId, privateLayout, parameterMap);\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"validated\");\n\n\t\t\tStagingServiceHttp.publishStagingRequest(\n\t\t\t\thttpPrincipal, stagingRequestId, privateLayout, parameterMap);\n\n\t\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\t\tif (updateLastPublishDate) {\n\t\t\t\tDate lastPublishDate = endDate;\n\n\t\t\t\tif (lastPublishDate == null) {\n\t\t\t\t\tlastPublishDate = new Date();\n\t\t\t\t}\n\n\t\t\t\tStagingUtil.updateLastPublishDate(\n\t\t\t\t\tsourceGroupId, privateLayout, lastPublishDate);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(fileInputStream);\n\n\t\t\tFileUtil.delete(file);\n\n\t\t\tif (stagingRequestId > 0) {\n\t\t\t\tStagingServiceHttp.cleanUpStagingRequest(\n\t\t\t\t\thttpPrincipal, stagingRequestId);\n\t\t\t}\n\t\t}\n\n\t\treturn processMissingReferences(backgroundTask, missingReferences);\n\t}","commit_id":"a749c94e54dfbe43ae66ec86f318b8266a36acb5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic BackgroundTaskResult execute(BackgroundTask backgroundTask)\n\t\tthrows Exception {\n\n\t\tMap<String, Serializable> taskContextMap =\n\t\t\tbackgroundTask.getTaskContextMap();\n\n\t\tlong userId = MapUtil.getLong(taskContextMap, \"userId\");\n\t\tlong targetGroupId = MapUtil.getLong(taskContextMap, \"targetGroupId\");\n\n\t\tStagingUtil.lockGroup(userId, targetGroupId);\n\n\t\tlong sourceGroupId = MapUtil.getLong(taskContextMap, \"sourceGroupId\");\n\t\tboolean privateLayout = MapUtil.getBoolean(\n\t\t\ttaskContextMap, \"privateLayout\");\n\t\tlong[] layoutIds = GetterUtil.getLongValues(\n\t\t\ttaskContextMap.get(\"layoutIds\"));\n\t\tMap<String, String[]> parameterMap =\n\t\t\t(Map<String, String[]>)taskContextMap.get(\"parameterMap\");\n\t\tDate startDate = (Date)taskContextMap.get(\"startDate\");\n\t\tDate endDate = (Date)taskContextMap.get(\"endDate\");\n\n\t\tclearBackgroundTaskStatus(backgroundTask);\n\n\t\tFile file = null;\n\t\tMissingReferences missingReferences = null;\n\n\t\ttry {\n\t\t\tDate lastPublishDate = new Date();\n\n\t\t\tif (endDate != null) {\n\t\t\t\tlastPublishDate = endDate;\n\t\t\t}\n\n\t\t\tfile = LayoutLocalServiceUtil.exportLayoutsAsFile(\n\t\t\t\tsourceGroupId, privateLayout, layoutIds, parameterMap,\n\t\t\t\tstartDate, endDate);\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"exported\");\n\n\t\t\tmissingReferences =\n\t\t\t\tLayoutLocalServiceUtil.validateImportLayoutsFile(\n\t\t\t\t\tuserId, targetGroupId, privateLayout, parameterMap, file);\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"validated\");\n\n\t\t\tLayoutLocalServiceUtil.importLayouts(\n\t\t\t\tuserId, targetGroupId, privateLayout, parameterMap, file);\n\n\t\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\t\tif (updateLastPublishDate) {\n\t\t\t\tStagingUtil.updateLastPublishDate(\n\t\t\t\t\tsourceGroupId, privateLayout, lastPublishDate);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\n\t\t\tStagingUtil.unlockGroup(targetGroupId);\n\t\t}\n\n\t\treturn processMissingReferences(backgroundTask, missingReferences);\n\t}","id":618,"modified_method":"@Override\n\tpublic BackgroundTaskResult execute(BackgroundTask backgroundTask)\n\t\tthrows Exception {\n\n\t\tMap<String, Serializable> taskContextMap =\n\t\t\tbackgroundTask.getTaskContextMap();\n\n\t\tlong userId = MapUtil.getLong(taskContextMap, \"userId\");\n\t\tlong targetGroupId = MapUtil.getLong(taskContextMap, \"targetGroupId\");\n\n\t\tStagingUtil.lockGroup(userId, targetGroupId);\n\n\t\tlong sourceGroupId = MapUtil.getLong(taskContextMap, \"sourceGroupId\");\n\t\tboolean privateLayout = MapUtil.getBoolean(\n\t\t\ttaskContextMap, \"privateLayout\");\n\t\tlong[] layoutIds = GetterUtil.getLongValues(\n\t\t\ttaskContextMap.get(\"layoutIds\"));\n\t\tMap<String, String[]> parameterMap =\n\t\t\t(Map<String, String[]>)taskContextMap.get(\"parameterMap\");\n\t\tDate startDate = (Date)taskContextMap.get(\"startDate\");\n\t\tDate endDate = (Date)taskContextMap.get(\"endDate\");\n\n\t\tclearBackgroundTaskStatus(backgroundTask);\n\n\t\tFile file = null;\n\t\tMissingReferences missingReferences = null;\n\n\t\ttry {\n\t\t\tfile = LayoutLocalServiceUtil.exportLayoutsAsFile(\n\t\t\t\tsourceGroupId, privateLayout, layoutIds, parameterMap,\n\t\t\t\tstartDate, endDate);\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"exported\");\n\n\t\t\tmissingReferences =\n\t\t\t\tLayoutLocalServiceUtil.validateImportLayoutsFile(\n\t\t\t\t\tuserId, targetGroupId, privateLayout, parameterMap, file);\n\n\t\t\tbackgroundTask = markBackgroundTask(backgroundTask, \"validated\");\n\n\t\t\tLayoutLocalServiceUtil.importLayouts(\n\t\t\t\tuserId, targetGroupId, privateLayout, parameterMap, file);\n\n\t\t\tboolean updateLastPublishDate = MapUtil.getBoolean(\n\t\t\t\tparameterMap, PortletDataHandlerKeys.UPDATE_LAST_PUBLISH_DATE);\n\n\t\t\tif (updateLastPublishDate) {\n\t\t\t\tDate lastPublishDate = endDate;\n\n\t\t\t\tif (lastPublishDate == null) {\n\t\t\t\t\tlastPublishDate = new Date();\n\t\t\t\t}\n\n\t\t\t\tStagingUtil.updateLastPublishDate(\n\t\t\t\t\tsourceGroupId, privateLayout, lastPublishDate);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\n\t\t\tStagingUtil.unlockGroup(targetGroupId);\n\t\t}\n\n\t\treturn processMissingReferences(backgroundTask, missingReferences);\n\t}","commit_id":"a749c94e54dfbe43ae66ec86f318b8266a36acb5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _discoverPingbackServer(String targetUri) {\n\t\tString serverUri = null;\n\n\t\ttry {\n\t\t\tHttp.Options options = new Http.Options();\n\n\t\t\toptions.addHeader(\n\t\t\t\tHttpHeaders.USER_AGENT, ReleaseInfo.getServerInfo());\n\t\t\toptions.setLocation(targetUri);\n\t\t\toptions.setHead(true);\n\n\t\t\tHttpUtil.URLtoByteArray(options);\n\n\t\t\tHttp.Response response = options.getResponse();\n\n\t\t\tserverUri = response.getHeader(\"X-Pingback\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to call HEAD of \" + targetUri, e);\n\t\t}\n\n\t\tif (Validator.isNull(serverUri)) {\n\t\t\ttry {\n\t\t\t\tSource clientSource = new Source(\n\t\t\t\t\tHttpUtil.URLtoString(targetUri));\n\n\t\t\t\tList<StartTag> startTags = clientSource.getAllStartTags(\"link\");\n\n\t\t\t\tfor (StartTag startTag : startTags) {\n\t\t\t\t\tString rel = startTag.getAttributeValue(\"rel\");\n\n\t\t\t\t\tif (rel.equalsIgnoreCase(\"pingback\")) {\n\t\t\t\t\t\tString href = startTag.getAttributeValue(\"href\");\n\n\t\t\t\t\t\tserverUri = HtmlUtil.escape(href);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to call GET of \" + targetUri, e);\n\t\t\t}\n\t\t}\n\n\t\treturn serverUri;\n\t}","id":619,"modified_method":"private static String _discoverPingbackServer(String targetUri) {\n\t\tString serverUri = null;\n\n\t\ttry {\n\t\t\tHttp.Options options = new Http.Options();\n\n\t\t\tif (_HTTP_HEADER_VERSION_VERBOSITY_DEFAULT) {\n\t\t\t}\n\t\t\telse if (_HTTP_HEADER_VERSION_VERBOSITY_PARTIAL) {\n\t\t\t\toptions.addHeader(\n\t\t\t\t\tHttpHeaders.USER_AGENT, ReleaseInfo.getName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\toptions.addHeader(\n\t\t\t\t\tHttpHeaders.USER_AGENT, ReleaseInfo.getServerInfo());\n\t\t\t}\n\n\t\t\toptions.setLocation(targetUri);\n\t\t\toptions.setHead(true);\n\n\t\t\tHttpUtil.URLtoByteArray(options);\n\n\t\t\tHttp.Response response = options.getResponse();\n\n\t\t\tserverUri = response.getHeader(\"X-Pingback\");\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(\"Unable to call HEAD of \" + targetUri, e);\n\t\t}\n\n\t\tif (Validator.isNull(serverUri)) {\n\t\t\ttry {\n\t\t\t\tSource clientSource = new Source(\n\t\t\t\t\tHttpUtil.URLtoString(targetUri));\n\n\t\t\t\tList<StartTag> startTags = clientSource.getAllStartTags(\"link\");\n\n\t\t\t\tfor (StartTag startTag : startTags) {\n\t\t\t\t\tString rel = startTag.getAttributeValue(\"rel\");\n\n\t\t\t\t\tif (rel.equalsIgnoreCase(\"pingback\")) {\n\t\t\t\t\t\tString href = startTag.getAttributeValue(\"href\");\n\n\t\t\t\t\t\tserverUri = HtmlUtil.escape(href);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to call GET of \" + targetUri, e);\n\t\t\t}\n\t\t}\n\n\t\treturn serverUri;\n\t}","commit_id":"d01af6da6443be28effc8f8ff56f5634a36125ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean sendTrackback(\n\t\t\tString trackback, Map<String, String> parts)\n\t\tthrows Exception {\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Pinging trackback \" + trackback);\n\t\t}\n\n\t\tHttp.Options options = new Http.Options();\n\n\t\toptions.addHeader(HttpHeaders.USER_AGENT, ReleaseInfo.getServerInfo());\n\t\toptions.setLocation(trackback);\n\t\toptions.setParts(parts);\n\t\toptions.setPost(true);\n\n\t\tString xml = HttpUtil.URLtoString(options);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(xml);\n\t\t}\n\n\t\tString error = xml;\n\n\t\tXMLStreamReader xmlStreamReader = null;\n\n\t\ttry {\n\t\t\tXMLInputFactory xmlInputFactory =\n\t\t\t\tStAXReaderUtil.getXMLInputFactory();\n\n\t\t\txmlStreamReader = xmlInputFactory.createXMLStreamReader(\n\t\t\t\tnew UnsyncStringReader(xml));\n\n\t\t\txmlStreamReader.nextTag();\n\t\t\txmlStreamReader.nextTag();\n\n\t\t\tString name = xmlStreamReader.getLocalName();\n\n\t\t\tif (name.equals(\"error\")) {\n\t\t\t\tint status = GetterUtil.getInteger(\n\t\t\t\t\txmlStreamReader.getElementText(), 1);\n\n\t\t\t\tif (status == 0) {\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"Trackback accepted\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\txmlStreamReader.nextTag();\n\n\t\t\t\tname = xmlStreamReader.getLocalName();\n\n\t\t\t\tif (name.equals(\"message\")) {\n\t\t\t\t\terror = xmlStreamReader.getElementText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (xmlStreamReader != null) {\n\t\t\t\ttry {\n\t\t\t\t\txmlStreamReader.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_log.error(\n\t\t\t\"Error while pinging trackback at \" + trackback + \": \" + error);\n\n\t\treturn false;\n\t}","id":620,"modified_method":"public static boolean sendTrackback(\n\t\t\tString trackback, Map<String, String> parts)\n\t\tthrows Exception {\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Pinging trackback \" + trackback);\n\t\t}\n\n\t\tHttp.Options options = new Http.Options();\n\n\t\tif (_HTTP_HEADER_VERSION_VERBOSITY_DEFAULT) {\n\t\t}\n\t\telse if (_HTTP_HEADER_VERSION_VERBOSITY_PARTIAL) {\n\t\t\toptions.addHeader(HttpHeaders.USER_AGENT, ReleaseInfo.getName());\n\t\t}\n\t\telse {\n\t\t\toptions.addHeader(\n\t\t\t\tHttpHeaders.USER_AGENT, ReleaseInfo.getServerInfo());\n\t\t}\n\t\toptions.setLocation(trackback);\n\t\toptions.setParts(parts);\n\t\toptions.setPost(true);\n\n\t\tString xml = HttpUtil.URLtoString(options);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(xml);\n\t\t}\n\n\t\tString error = xml;\n\n\t\tXMLStreamReader xmlStreamReader = null;\n\n\t\ttry {\n\t\t\tXMLInputFactory xmlInputFactory =\n\t\t\t\tStAXReaderUtil.getXMLInputFactory();\n\n\t\t\txmlStreamReader = xmlInputFactory.createXMLStreamReader(\n\t\t\t\tnew UnsyncStringReader(xml));\n\n\t\t\txmlStreamReader.nextTag();\n\t\t\txmlStreamReader.nextTag();\n\n\t\t\tString name = xmlStreamReader.getLocalName();\n\n\t\t\tif (name.equals(\"error\")) {\n\t\t\t\tint status = GetterUtil.getInteger(\n\t\t\t\t\txmlStreamReader.getElementText(), 1);\n\n\t\t\t\tif (status == 0) {\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"Trackback accepted\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\txmlStreamReader.nextTag();\n\n\t\t\t\tname = xmlStreamReader.getLocalName();\n\n\t\t\t\tif (name.equals(\"message\")) {\n\t\t\t\t\terror = xmlStreamReader.getElementText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif (xmlStreamReader != null) {\n\t\t\t\ttry {\n\t\t\t\t\txmlStreamReader.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_log.error(\n\t\t\t\"Error while pinging trackback at \" + trackback + \": \" + error);\n\n\t\treturn false;\n\t}","commit_id":"d01af6da6443be28effc8f8ff56f5634a36125ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Response doExecuteMethod(\n\t\t\tString url, String methodName, Object[] arguments)\n\t\tthrows Exception {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(\"XML-RPC invoking \" + methodName + \" \");\n\n\t\t\tif (arguments != null) {\n\t\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\t\tsb.append(arguments[i]);\n\n\t\t\t\t\tif (i < arguments.length - 1) {\n\t\t\t\t\t\tsb.append(\", \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_log.debug(sb.toString());\n\t\t}\n\n\t\tString requestXML = XmlRpcParser.buildMethod(methodName, arguments);\n\n\t\tHttp.Options options = new Http.Options();\n\n\t\toptions.addHeader(HttpHeaders.USER_AGENT, ReleaseInfo.getServerInfo());\n\t\toptions.setBody(requestXML, ContentTypes.TEXT_XML, StringPool.UTF8);\n\t\toptions.setLocation(url);\n\t\toptions.setPost(true);\n\n\t\tString responseXML = HttpUtil.URLtoString(options);\n\n\t\treturn XmlRpcParser.parseResponse(responseXML);\n\t}","id":621,"modified_method":"protected Response doExecuteMethod(\n\t\t\tString url, String methodName, Object[] arguments)\n\t\tthrows Exception {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(\"XML-RPC invoking \" + methodName + \" \");\n\n\t\t\tif (arguments != null) {\n\t\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\t\tsb.append(arguments[i]);\n\n\t\t\t\t\tif (i < arguments.length - 1) {\n\t\t\t\t\t\tsb.append(\", \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_log.debug(sb.toString());\n\t\t}\n\n\t\tString requestXML = XmlRpcParser.buildMethod(methodName, arguments);\n\n\t\tHttp.Options options = new Http.Options();\n\n\t\tif (_HTTP_HEADER_VERSION_VERBOSITY_DEFAULT) {\n\t\t}\n\t\telse if (_HTTP_HEADER_VERSION_VERBOSITY_PARTIAL) {\n\t\t\toptions.addHeader(HttpHeaders.USER_AGENT, ReleaseInfo.getName());\n\t\t}\n\t\telse {\n\t\t\toptions.addHeader(\n\t\t\t\tHttpHeaders.USER_AGENT, ReleaseInfo.getServerInfo());\n\t\t}\n\n\t\toptions.setBody(requestXML, ContentTypes.TEXT_XML, StringPool.UTF8);\n\t\toptions.setLocation(url);\n\t\toptions.setPost(true);\n\n\t\tString responseXML = HttpUtil.URLtoString(options);\n\n\t\treturn XmlRpcParser.parseResponse(responseXML);\n\t}","commit_id":"d01af6da6443be28effc8f8ff56f5634a36125ee","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PdeTextAreaDefaults() {\n\n    inputHandler = new DefaultInputHandler();\n    inputHandler.addDefaultKeyBindings();\n\n    // use option on mac for things that are ctrl on windows/linux\n    String mod = Base.isMacOS() ? \"A\" : \"C\";\n\n    inputHandler.addKeyBinding(\"S+BACK_SPACE\", InputHandler.BACKSPACE);\n    inputHandler.addKeyBinding(\"S+DELETE\", InputHandler.DELETE);\n\n    inputHandler.addKeyBinding(\"BACK_SPACE\", InputHandler.BACKSPACE);\n    inputHandler.addKeyBinding(\"C+BACK_SPACE\", InputHandler.BACKSPACE_WORD);\n    inputHandler.addKeyBinding(\"DELETE\", InputHandler.DELETE);\n    inputHandler.addKeyBinding(\"C+DELETE\", InputHandler.DELETE_WORD);\n\n    inputHandler.addKeyBinding(\"ENTER\", InputHandler.INSERT_BREAK);\n    inputHandler.addKeyBinding(\"TAB\", InputHandler.INSERT_TAB);\n\n    inputHandler.addKeyBinding(\"INSERT\", InputHandler.OVERWRITE);\n    inputHandler.addKeyBinding(\"C+\\\\\", InputHandler.TOGGLE_RECT);\n\n    // beginning and ending of the current line\n    inputHandler.addKeyBinding(\"HOME\", InputHandler.HOME);\n    inputHandler.addKeyBinding(\"END\", InputHandler.END);\n\n    if (Base.isMacOS()) {\n      inputHandler.addKeyBinding(\"M+LEFT\", InputHandler.HOME);\n      inputHandler.addKeyBinding(\"M+RIGHT\", InputHandler.END);\n    }\n\n    inputHandler.addKeyBinding(\"S+HOME\", InputHandler.SELECT_HOME);\n    inputHandler.addKeyBinding(\"S+END\", InputHandler.SELECT_END);\n    inputHandler.addKeyBinding(mod + \"+HOME\", InputHandler.DOCUMENT_HOME);\n    inputHandler.addKeyBinding(mod + \"+END\", InputHandler.DOCUMENT_END);\n    inputHandler.addKeyBinding(mod + \"S+HOME\", InputHandler.SELECT_DOC_HOME);\n    inputHandler.addKeyBinding(mod + \"S+END\", InputHandler.SELECT_DOC_END);\n\n    inputHandler.addKeyBinding(\"PAGE_UP\", InputHandler.PREV_PAGE);\n    inputHandler.addKeyBinding(\"PAGE_DOWN\", InputHandler.NEXT_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_UP\", InputHandler.SELECT_PREV_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_DOWN\", InputHandler.SELECT_NEXT_PAGE);\n\n    inputHandler.addKeyBinding(\"LEFT\", InputHandler.PREV_CHAR);\n    inputHandler.addKeyBinding(\"S+LEFT\", InputHandler.SELECT_PREV_CHAR);\n    inputHandler.addKeyBinding(mod + \"+LEFT\", InputHandler.PREV_WORD);\n    inputHandler.addKeyBinding(mod + \"S+LEFT\", InputHandler.SELECT_PREV_WORD);\n    inputHandler.addKeyBinding(\"RIGHT\", InputHandler.NEXT_CHAR);\n    inputHandler.addKeyBinding(\"S+RIGHT\", InputHandler.SELECT_NEXT_CHAR);\n    inputHandler.addKeyBinding(mod + \"+RIGHT\", InputHandler.NEXT_WORD);\n    inputHandler.addKeyBinding(mod + \"S+RIGHT\", InputHandler.SELECT_NEXT_WORD);\n    inputHandler.addKeyBinding(\"UP\", InputHandler.PREV_LINE);\n    inputHandler.addKeyBinding(mod + \"+UP\", InputHandler.PREV_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+UP\", InputHandler.SELECT_PREV_LINE);\n    inputHandler.addKeyBinding(\"DOWN\", InputHandler.NEXT_LINE);\n    inputHandler.addKeyBinding(mod + \"+DOWN\", InputHandler.NEXT_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+DOWN\", InputHandler.SELECT_NEXT_LINE);\n\n    inputHandler.addKeyBinding(mod + \"+ENTER\", InputHandler.REPEAT);\n\n    document = new SyntaxDocument();\n    editable = true;\n    electricScroll = 3;\n\n    cols = 80;\n    rows = 15;\n\n\n    // moved from SyntaxUtilities\n    //DEFAULTS.styles = SyntaxUtilities.getDefaultSyntaxStyles();\n\n    styles = new SyntaxStyle[Token.ID_COUNT];\n\n    // comments\n    styles[Token.COMMENT1] = Preferences.getStyle(\"comment1\");\n    styles[Token.COMMENT2] = Preferences.getStyle(\"comment2\");\n\n    // abstract, final, private\n    styles[Token.KEYWORD1] = Preferences.getStyle(\"keyword1\");\n\n    // beginShape, point, line\n    styles[Token.KEYWORD2] = Preferences.getStyle(\"keyword2\");\n\n    // byte, char, short, color\n    styles[Token.KEYWORD3] = Preferences.getStyle(\"keyword3\");\n\n    // constants: null, true, this, RGB, TWO_PI\n    styles[Token.LITERAL1] = Preferences.getStyle(\"literal1\");\n\n    // p5 built in variables: mouseX, width, pixels\n    styles[Token.LITERAL2] = Preferences.getStyle(\"literal2\");\n\n    // ??\n    styles[Token.LABEL] = Preferences.getStyle(\"label\");\n\n    // + - = /\n    styles[Token.OPERATOR] = Preferences.getStyle(\"operator\");\n\n    // area that's not in use by the text (replaced with tildes)\n    styles[Token.INVALID] = Preferences.getStyle(\"invalid\");\n\n\n    // moved from TextAreaPainter\n\n    font = Preferences.getFont(\"editor.font\");\n\n    fgcolor = Preferences.getColor(\"editor.fgcolor\");\n    bgcolor = Preferences.getColor(\"editor.bgcolor\");\n\n    caretVisible = true;\n    caretBlinks = Preferences.getBoolean(\"editor.caret.blink\");\n    caretColor = Preferences.getColor(\"editor.caret.color\");\n\n    selectionColor = Preferences.getColor(\"editor.selection.color\");\n\n    lineHighlight =\n      Preferences.getBoolean(\"editor.linehighlight\");\n    lineHighlightColor =\n      Preferences.getColor(\"editor.linehighlight.color\");\n\n    bracketHighlight =\n      Preferences.getBoolean(\"editor.brackethighlight\");\n    bracketHighlightColor =\n      Preferences.getColor(\"editor.brackethighlight.color\");\n\n    eolMarkers = Preferences.getBoolean(\"editor.eolmarkers\");\n    eolMarkerColor = Preferences.getColor(\"editor.eolmarkers.color\");\n\n    paintInvalid = Preferences.getBoolean(\"editor.invalid\");\n  }","id":622,"modified_method":"public PdeTextAreaDefaults() {\n\n    inputHandler = new DefaultInputHandler();\n    inputHandler.addDefaultKeyBindings();\n\n    // use option on mac for things that are ctrl on windows/linux\n    String mod = Base.isMacOS() ? \"A\" : \"C\";\n\n    inputHandler.addKeyBinding(\"S+BACK_SPACE\", InputHandler.BACKSPACE);\n    inputHandler.addKeyBinding(\"S+DELETE\", InputHandler.DELETE);\n\n    inputHandler.addKeyBinding(\"BACK_SPACE\", InputHandler.BACKSPACE);\n    inputHandler.addKeyBinding(\"DELETE\", InputHandler.DELETE);\n    // the following two were changing for 0122 for better mac/pc compatability\n    inputHandler.addKeyBinding(mod+\"+BACK_SPACE\", InputHandler.BACKSPACE_WORD);\n    inputHandler.addKeyBinding(mod+\"+DELETE\", InputHandler.DELETE_WORD);\n\n    inputHandler.addKeyBinding(\"ENTER\", InputHandler.INSERT_BREAK);\n    inputHandler.addKeyBinding(\"TAB\", InputHandler.INSERT_TAB);\n\n    inputHandler.addKeyBinding(\"INSERT\", InputHandler.OVERWRITE);\n    inputHandler.addKeyBinding(\"C+\\\\\", InputHandler.TOGGLE_RECT);\n\n    // beginning and ending of the current line\n    /*\n    inputHandler.addKeyBinding(\"HOME\", InputHandler.HOME);\n    inputHandler.addKeyBinding(\"END\", InputHandler.END);\n    inputHandler.addKeyBinding(\"S+HOME\", InputHandler.SELECT_HOME);\n    inputHandler.addKeyBinding(\"S+END\", InputHandler.SELECT_END);\n    */\n\n    // for 0122, these have been changed for better compatability\n    // HOME and END now mean the beginning/end of the document\n    inputHandler.addKeyBinding(\"HOME\", InputHandler.DOCUMENT_HOME);\n    inputHandler.addKeyBinding(\"END\", InputHandler.DOCUMENT_END);\n    inputHandler.addKeyBinding(\"S+HOME\", InputHandler.SELECT_DOC_HOME);\n    inputHandler.addKeyBinding(\"S+END\", InputHandler.SELECT_DOC_END);\n\n    if (Base.isMacOS()) {\n      inputHandler.addKeyBinding(\"M+LEFT\", InputHandler.HOME);\n      inputHandler.addKeyBinding(\"M+RIGHT\", InputHandler.END);\n      inputHandler.addKeyBinding(\"M+S+LEFT\", InputHandler.SELECT_HOME); // 0122\n      inputHandler.addKeyBinding(\"M+S+RIGHT\", InputHandler.SELECT_END);  // 0122\n    } else {\n      inputHandler.addKeyBinding(\"C+LEFT\", InputHandler.HOME);  // 0122\n      inputHandler.addKeyBinding(\"C+RIGHT\", InputHandler.END);  // 0122\n      inputHandler.addKeyBinding(\"C+S+HOME\", InputHandler.SELECT_HOME); // 0122\n      inputHandler.addKeyBinding(\"C+S+END\", InputHandler.SELECT_END);  // 0122\n    }\n\n    inputHandler.addKeyBinding(\"PAGE_UP\", InputHandler.PREV_PAGE);\n    inputHandler.addKeyBinding(\"PAGE_DOWN\", InputHandler.NEXT_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_UP\", InputHandler.SELECT_PREV_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_DOWN\", InputHandler.SELECT_NEXT_PAGE);\n\n    inputHandler.addKeyBinding(\"LEFT\", InputHandler.PREV_CHAR);\n    inputHandler.addKeyBinding(\"S+LEFT\", InputHandler.SELECT_PREV_CHAR);\n    inputHandler.addKeyBinding(mod + \"+LEFT\", InputHandler.PREV_WORD);\n    inputHandler.addKeyBinding(mod + \"S+LEFT\", InputHandler.SELECT_PREV_WORD);\n    inputHandler.addKeyBinding(\"RIGHT\", InputHandler.NEXT_CHAR);\n    inputHandler.addKeyBinding(\"S+RIGHT\", InputHandler.SELECT_NEXT_CHAR);\n    inputHandler.addKeyBinding(mod + \"+RIGHT\", InputHandler.NEXT_WORD);\n    inputHandler.addKeyBinding(mod + \"S+RIGHT\", InputHandler.SELECT_NEXT_WORD);\n    inputHandler.addKeyBinding(\"UP\", InputHandler.PREV_LINE);\n    inputHandler.addKeyBinding(mod + \"+UP\", InputHandler.PREV_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+UP\", InputHandler.SELECT_PREV_LINE);\n    inputHandler.addKeyBinding(\"DOWN\", InputHandler.NEXT_LINE);\n    inputHandler.addKeyBinding(mod + \"+DOWN\", InputHandler.NEXT_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+DOWN\", InputHandler.SELECT_NEXT_LINE);\n\n    inputHandler.addKeyBinding(mod + \"+ENTER\", InputHandler.REPEAT);\n\n    document = new SyntaxDocument();\n    editable = true;\n    electricScroll = 3;\n\n    cols = 80;\n    rows = 15;\n\n\n    // moved from SyntaxUtilities\n    //DEFAULTS.styles = SyntaxUtilities.getDefaultSyntaxStyles();\n\n    styles = new SyntaxStyle[Token.ID_COUNT];\n\n    // comments\n    styles[Token.COMMENT1] = Preferences.getStyle(\"comment1\");\n    styles[Token.COMMENT2] = Preferences.getStyle(\"comment2\");\n\n    // abstract, final, private\n    styles[Token.KEYWORD1] = Preferences.getStyle(\"keyword1\");\n\n    // beginShape, point, line\n    styles[Token.KEYWORD2] = Preferences.getStyle(\"keyword2\");\n\n    // byte, char, short, color\n    styles[Token.KEYWORD3] = Preferences.getStyle(\"keyword3\");\n\n    // constants: null, true, this, RGB, TWO_PI\n    styles[Token.LITERAL1] = Preferences.getStyle(\"literal1\");\n\n    // p5 built in variables: mouseX, width, pixels\n    styles[Token.LITERAL2] = Preferences.getStyle(\"literal2\");\n\n    // ??\n    styles[Token.LABEL] = Preferences.getStyle(\"label\");\n\n    // + - = /\n    styles[Token.OPERATOR] = Preferences.getStyle(\"operator\");\n\n    // area that's not in use by the text (replaced with tildes)\n    styles[Token.INVALID] = Preferences.getStyle(\"invalid\");\n\n\n    // moved from TextAreaPainter\n\n    font = Preferences.getFont(\"editor.font\");\n\n    fgcolor = Preferences.getColor(\"editor.fgcolor\");\n    bgcolor = Preferences.getColor(\"editor.bgcolor\");\n\n    caretVisible = true;\n    caretBlinks = Preferences.getBoolean(\"editor.caret.blink\");\n    caretColor = Preferences.getColor(\"editor.caret.color\");\n\n    selectionColor = Preferences.getColor(\"editor.selection.color\");\n\n    lineHighlight =\n      Preferences.getBoolean(\"editor.linehighlight\");\n    lineHighlightColor =\n      Preferences.getColor(\"editor.linehighlight.color\");\n\n    bracketHighlight =\n      Preferences.getBoolean(\"editor.brackethighlight\");\n    bracketHighlightColor =\n      Preferences.getColor(\"editor.brackethighlight.color\");\n\n    eolMarkers = Preferences.getBoolean(\"editor.eolmarkers\");\n    eolMarkerColor = Preferences.getColor(\"editor.eolmarkers.color\");\n\n    paintInvalid = Preferences.getBoolean(\"editor.invalid\");\n  }","commit_id":"c7059278fb3341cbe0a4582480947ad11b4eae52","url":"https://github.com/processing/processing"},{"original_method":"public PdeTextAreaDefaults() {\n\n    inputHandler = new DefaultInputHandler();\n    //inputHandler.addDefaultKeyBindings();  // 0122\n\n    // use option on mac for things that are ctrl on windows/linux\n    String mod = Base.isMacOS() ? \"A\" : \"C\";\n\n    // right now, ctrl-up/down is select up/down, but mod should be\n    // used instead, because the mac expects it to be option(alt)\n\n    inputHandler.addKeyBinding(\"BACK_SPACE\", InputHandler.BACKSPACE);\n    inputHandler.addKeyBinding(\"DELETE\", InputHandler.DELETE);\n\n    //inputHandler.addKeyBinding(\"S+BACK_SPACE\", InputHandler.BACKSPACE);\n    // for 0122, shift-backspace is delete\n    inputHandler.addKeyBinding(\"S+BACK_SPACE\", InputHandler.DELETE);\n    inputHandler.addKeyBinding(\"S+DELETE\", InputHandler.DELETE);\n\n    // the following two were changing for 0122 for better mac/pc compatability\n    inputHandler.addKeyBinding(mod+\"+BACK_SPACE\", InputHandler.BACKSPACE_WORD);\n    inputHandler.addKeyBinding(mod+\"+DELETE\", InputHandler.DELETE_WORD);\n\n    // handled by listener, don't bother here\n    //inputHandler.addKeyBinding(\"ENTER\", InputHandler.INSERT_BREAK);\n    //inputHandler.addKeyBinding(\"TAB\", InputHandler.INSERT_TAB);\n\n    inputHandler.addKeyBinding(\"INSERT\", InputHandler.OVERWRITE);\n    // disabling for 0122, not sure what this does\n    //inputHandler.addKeyBinding(\"C+\\\\\", InputHandler.TOGGLE_RECT);\n\n    // for 0122, these have been changed for better compatability\n    // HOME and END now mean the beginning/end of the document\n    inputHandler.addKeyBinding(\"HOME\", InputHandler.DOCUMENT_HOME);\n    inputHandler.addKeyBinding(\"END\", InputHandler.DOCUMENT_END);\n    inputHandler.addKeyBinding(\"S+HOME\", InputHandler.SELECT_DOC_HOME);\n    inputHandler.addKeyBinding(\"S+END\", InputHandler.SELECT_DOC_END);\n\n    if (Base.isMacOS()) {\n      inputHandler.addKeyBinding(\"M+LEFT\", InputHandler.HOME);\n      inputHandler.addKeyBinding(\"M+RIGHT\", InputHandler.END);\n      inputHandler.addKeyBinding(\"MS+LEFT\", InputHandler.SELECT_HOME); // 0122\n      inputHandler.addKeyBinding(\"MS+RIGHT\", InputHandler.SELECT_END);  // 0122\n    } else {\n      inputHandler.addKeyBinding(\"C+LEFT\", InputHandler.HOME);  // 0122\n      inputHandler.addKeyBinding(\"C+RIGHT\", InputHandler.END);  // 0122\n      inputHandler.addKeyBinding(\"CS+HOME\", InputHandler.SELECT_HOME); // 0122\n      inputHandler.addKeyBinding(\"CS+END\", InputHandler.SELECT_END);  // 0122\n    }\n\n    inputHandler.addKeyBinding(\"PAGE_UP\", InputHandler.PREV_PAGE);\n    inputHandler.addKeyBinding(\"PAGE_DOWN\", InputHandler.NEXT_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_UP\", InputHandler.SELECT_PREV_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_DOWN\", InputHandler.SELECT_NEXT_PAGE);\n\n    inputHandler.addKeyBinding(\"LEFT\", InputHandler.PREV_CHAR);\n    inputHandler.addKeyBinding(\"S+LEFT\", InputHandler.SELECT_PREV_CHAR);\n    inputHandler.addKeyBinding(mod + \"+LEFT\", InputHandler.PREV_WORD);\n    inputHandler.addKeyBinding(mod + \"S+LEFT\", InputHandler.SELECT_PREV_WORD);\n    inputHandler.addKeyBinding(\"RIGHT\", InputHandler.NEXT_CHAR);\n    inputHandler.addKeyBinding(\"S+RIGHT\", InputHandler.SELECT_NEXT_CHAR);\n    inputHandler.addKeyBinding(mod + \"+RIGHT\", InputHandler.NEXT_WORD);\n    inputHandler.addKeyBinding(mod + \"S+RIGHT\", InputHandler.SELECT_NEXT_WORD);\n\n    inputHandler.addKeyBinding(\"UP\", InputHandler.PREV_LINE);\n    inputHandler.addKeyBinding(mod + \"+UP\", InputHandler.PREV_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+UP\", InputHandler.SELECT_PREV_LINE);\n    inputHandler.addKeyBinding(\"DOWN\", InputHandler.NEXT_LINE);\n    inputHandler.addKeyBinding(mod + \"+DOWN\", InputHandler.NEXT_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+DOWN\", InputHandler.SELECT_NEXT_LINE);\n\n    inputHandler.addKeyBinding(\"MS+UP\", InputHandler.SELECT_DOC_HOME);\n    inputHandler.addKeyBinding(\"CS+UP\", InputHandler.SELECT_DOC_HOME);\n    inputHandler.addKeyBinding(\"MS+DOWN\", InputHandler.SELECT_DOC_END);\n    inputHandler.addKeyBinding(\"CS+DOWN\", InputHandler.SELECT_DOC_END);\n\n    inputHandler.addKeyBinding(mod + \"+ENTER\", InputHandler.REPEAT);\n\n    document = new SyntaxDocument();\n    editable = true;\n    electricScroll = 3;\n\n    cols = 80;\n    rows = 15;\n\n\n    // moved from SyntaxUtilities\n    //DEFAULTS.styles = SyntaxUtilities.getDefaultSyntaxStyles();\n\n    styles = new SyntaxStyle[Token.ID_COUNT];\n\n    // comments\n    styles[Token.COMMENT1] = Preferences.getStyle(\"comment1\");\n    styles[Token.COMMENT2] = Preferences.getStyle(\"comment2\");\n\n    // abstract, final, private\n    styles[Token.KEYWORD1] = Preferences.getStyle(\"keyword1\");\n\n    // beginShape, point, line\n    styles[Token.KEYWORD2] = Preferences.getStyle(\"keyword2\");\n\n    // byte, char, short, color\n    styles[Token.KEYWORD3] = Preferences.getStyle(\"keyword3\");\n\n    // constants: null, true, this, RGB, TWO_PI\n    styles[Token.LITERAL1] = Preferences.getStyle(\"literal1\");\n\n    // p5 built in variables: mouseX, width, pixels\n    styles[Token.LITERAL2] = Preferences.getStyle(\"literal2\");\n\n    // ??\n    styles[Token.LABEL] = Preferences.getStyle(\"label\");\n\n    // + - = /\n    styles[Token.OPERATOR] = Preferences.getStyle(\"operator\");\n\n    // area that's not in use by the text (replaced with tildes)\n    styles[Token.INVALID] = Preferences.getStyle(\"invalid\");\n\n\n    // moved from TextAreaPainter\n\n    font = Preferences.getFont(\"editor.font\");\n\n    fgcolor = Preferences.getColor(\"editor.fgcolor\");\n    bgcolor = Preferences.getColor(\"editor.bgcolor\");\n\n    caretVisible = true;\n    caretBlinks = Preferences.getBoolean(\"editor.caret.blink\");\n    caretColor = Preferences.getColor(\"editor.caret.color\");\n\n    selectionColor = Preferences.getColor(\"editor.selection.color\");\n\n    lineHighlight =\n      Preferences.getBoolean(\"editor.linehighlight\");\n    lineHighlightColor =\n      Preferences.getColor(\"editor.linehighlight.color\");\n\n    bracketHighlight =\n      Preferences.getBoolean(\"editor.brackethighlight\");\n    bracketHighlightColor =\n      Preferences.getColor(\"editor.brackethighlight.color\");\n\n    eolMarkers = Preferences.getBoolean(\"editor.eolmarkers\");\n    eolMarkerColor = Preferences.getColor(\"editor.eolmarkers.color\");\n\n    paintInvalid = Preferences.getBoolean(\"editor.invalid\");\n  }","id":623,"modified_method":"public PdeTextAreaDefaults() {\n\n    inputHandler = new DefaultInputHandler();\n    //inputHandler.addDefaultKeyBindings();  // 0122\n\n    // use option on mac for things that are ctrl on windows/linux\n    String mod = Base.isMacOS() ? \"A\" : \"C\";\n\n    // right now, ctrl-up/down is select up/down, but mod should be\n    // used instead, because the mac expects it to be option(alt)\n\n    inputHandler.addKeyBinding(\"BACK_SPACE\", InputHandler.BACKSPACE);\n    inputHandler.addKeyBinding(\"DELETE\", InputHandler.DELETE);\n\n    //inputHandler.addKeyBinding(\"S+BACK_SPACE\", InputHandler.BACKSPACE);\n    // for 0122, shift-backspace is delete\n    inputHandler.addKeyBinding(\"S+BACK_SPACE\", InputHandler.DELETE);\n    inputHandler.addKeyBinding(\"S+DELETE\", InputHandler.DELETE);\n\n    // the following two were changing for 0122 for better mac/pc compatability\n    inputHandler.addKeyBinding(mod+\"+BACK_SPACE\", InputHandler.BACKSPACE_WORD);\n    inputHandler.addKeyBinding(mod+\"+DELETE\", InputHandler.DELETE_WORD);\n\n    // handled by listener, don't bother here\n    //inputHandler.addKeyBinding(\"ENTER\", InputHandler.INSERT_BREAK);\n    //inputHandler.addKeyBinding(\"TAB\", InputHandler.INSERT_TAB);\n\n    inputHandler.addKeyBinding(\"INSERT\", InputHandler.OVERWRITE);\n    // disabling for 0122, not sure what this does\n    //inputHandler.addKeyBinding(\"C+\\\\\", InputHandler.TOGGLE_RECT);\n\n    // for 0122, these have been changed for better compatability\n    // HOME and END now mean the beginning/end of the document\n    if (Base.isMacOS()) {\n      inputHandler.addKeyBinding(\"HOME\", InputHandler.DOCUMENT_HOME);\n      inputHandler.addKeyBinding(\"END\", InputHandler.DOCUMENT_END);\n      inputHandler.addKeyBinding(\"S+HOME\", InputHandler.SELECT_DOC_HOME);\n      inputHandler.addKeyBinding(\"S+END\", InputHandler.SELECT_DOC_END);\n    } else {\n      // for 0123 added the proper windows defaults\n      inputHandler.addKeyBinding(\"HOME\", InputHandler.HOME);\n      inputHandler.addKeyBinding(\"END\", InputHandler.END);\n      inputHandler.addKeyBinding(\"S+HOME\", InputHandler.SELECT_HOME);\n      inputHandler.addKeyBinding(\"S+END\", InputHandler.SELECT_END);\n      inputHandler.addKeyBinding(\"C+HOME\", InputHandler.DOCUMENT_HOME);\n      inputHandler.addKeyBinding(\"C+END\", InputHandler.DOCUMENT_END);\n      inputHandler.addKeyBinding(\"CS+HOME\", InputHandler.SELECT_DOC_HOME);\n      inputHandler.addKeyBinding(\"CS+END\", InputHandler.SELECT_DOC_END);\n    }\n\n    if (Base.isMacOS()) {\n      inputHandler.addKeyBinding(\"M+LEFT\", InputHandler.HOME);\n      inputHandler.addKeyBinding(\"M+RIGHT\", InputHandler.END);\n      inputHandler.addKeyBinding(\"MS+LEFT\", InputHandler.SELECT_HOME); // 0122\n      inputHandler.addKeyBinding(\"MS+RIGHT\", InputHandler.SELECT_END);  // 0122\n    } else {\n      inputHandler.addKeyBinding(\"C+LEFT\", InputHandler.HOME);  // 0122\n      inputHandler.addKeyBinding(\"C+RIGHT\", InputHandler.END);  // 0122\n      inputHandler.addKeyBinding(\"CS+HOME\", InputHandler.SELECT_HOME); // 0122\n      inputHandler.addKeyBinding(\"CS+END\", InputHandler.SELECT_END);  // 0122\n    }\n\n    inputHandler.addKeyBinding(\"PAGE_UP\", InputHandler.PREV_PAGE);\n    inputHandler.addKeyBinding(\"PAGE_DOWN\", InputHandler.NEXT_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_UP\", InputHandler.SELECT_PREV_PAGE);\n    inputHandler.addKeyBinding(\"S+PAGE_DOWN\", InputHandler.SELECT_NEXT_PAGE);\n\n    inputHandler.addKeyBinding(\"LEFT\", InputHandler.PREV_CHAR);\n    inputHandler.addKeyBinding(\"S+LEFT\", InputHandler.SELECT_PREV_CHAR);\n    inputHandler.addKeyBinding(mod + \"+LEFT\", InputHandler.PREV_WORD);\n    inputHandler.addKeyBinding(mod + \"S+LEFT\", InputHandler.SELECT_PREV_WORD);\n    inputHandler.addKeyBinding(\"RIGHT\", InputHandler.NEXT_CHAR);\n    inputHandler.addKeyBinding(\"S+RIGHT\", InputHandler.SELECT_NEXT_CHAR);\n    inputHandler.addKeyBinding(mod + \"+RIGHT\", InputHandler.NEXT_WORD);\n    inputHandler.addKeyBinding(mod + \"S+RIGHT\", InputHandler.SELECT_NEXT_WORD);\n\n    inputHandler.addKeyBinding(\"UP\", InputHandler.PREV_LINE);\n    inputHandler.addKeyBinding(mod + \"+UP\", InputHandler.PREV_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+UP\", InputHandler.SELECT_PREV_LINE);\n    inputHandler.addKeyBinding(\"DOWN\", InputHandler.NEXT_LINE);\n    inputHandler.addKeyBinding(mod + \"+DOWN\", InputHandler.NEXT_LINE);  // p5\n    inputHandler.addKeyBinding(\"S+DOWN\", InputHandler.SELECT_NEXT_LINE);\n\n    inputHandler.addKeyBinding(\"MS+UP\", InputHandler.SELECT_DOC_HOME);\n    inputHandler.addKeyBinding(\"CS+UP\", InputHandler.SELECT_DOC_HOME);\n    inputHandler.addKeyBinding(\"MS+DOWN\", InputHandler.SELECT_DOC_END);\n    inputHandler.addKeyBinding(\"CS+DOWN\", InputHandler.SELECT_DOC_END);\n\n    inputHandler.addKeyBinding(mod + \"+ENTER\", InputHandler.REPEAT);\n\n    document = new SyntaxDocument();\n    editable = true;\n    electricScroll = 3;\n\n    cols = 80;\n    rows = 15;\n\n\n    // moved from SyntaxUtilities\n    //DEFAULTS.styles = SyntaxUtilities.getDefaultSyntaxStyles();\n\n    styles = new SyntaxStyle[Token.ID_COUNT];\n\n    // comments\n    styles[Token.COMMENT1] = Preferences.getStyle(\"comment1\");\n    styles[Token.COMMENT2] = Preferences.getStyle(\"comment2\");\n\n    // abstract, final, private\n    styles[Token.KEYWORD1] = Preferences.getStyle(\"keyword1\");\n\n    // beginShape, point, line\n    styles[Token.KEYWORD2] = Preferences.getStyle(\"keyword2\");\n\n    // byte, char, short, color\n    styles[Token.KEYWORD3] = Preferences.getStyle(\"keyword3\");\n\n    // constants: null, true, this, RGB, TWO_PI\n    styles[Token.LITERAL1] = Preferences.getStyle(\"literal1\");\n\n    // p5 built in variables: mouseX, width, pixels\n    styles[Token.LITERAL2] = Preferences.getStyle(\"literal2\");\n\n    // ??\n    styles[Token.LABEL] = Preferences.getStyle(\"label\");\n\n    // + - = /\n    styles[Token.OPERATOR] = Preferences.getStyle(\"operator\");\n\n    // area that's not in use by the text (replaced with tildes)\n    styles[Token.INVALID] = Preferences.getStyle(\"invalid\");\n\n\n    // moved from TextAreaPainter\n\n    font = Preferences.getFont(\"editor.font\");\n\n    fgcolor = Preferences.getColor(\"editor.fgcolor\");\n    bgcolor = Preferences.getColor(\"editor.bgcolor\");\n\n    caretVisible = true;\n    caretBlinks = Preferences.getBoolean(\"editor.caret.blink\");\n    caretColor = Preferences.getColor(\"editor.caret.color\");\n\n    selectionColor = Preferences.getColor(\"editor.selection.color\");\n\n    lineHighlight =\n      Preferences.getBoolean(\"editor.linehighlight\");\n    lineHighlightColor =\n      Preferences.getColor(\"editor.linehighlight.color\");\n\n    bracketHighlight =\n      Preferences.getBoolean(\"editor.brackethighlight\");\n    bracketHighlightColor =\n      Preferences.getColor(\"editor.brackethighlight.color\");\n\n    eolMarkers = Preferences.getBoolean(\"editor.eolmarkers\");\n    eolMarkerColor = Preferences.getColor(\"editor.eolmarkers.color\");\n\n    paintInvalid = Preferences.getBoolean(\"editor.invalid\");\n  }","commit_id":"c1eb22ab04512c7bff810aeec8a0bbfd1b0ebd58","url":"https://github.com/processing/processing"},{"original_method":"public static boolean isImportedWithKotlinDefault(ImportPath importPath) {\n        for (ImportPath defaultJetImport : DefaultModuleConfiguration.DEFAULT_JET_IMPORTS) {\n            if (QualifiedNamesUtil.isImported(defaultJetImport, importPath)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":624,"modified_method":"public static boolean isImportedWithKotlinDefault(ImportPath importPath) {\n        return QualifiedNamesUtil.isImported(DefaultModuleConfiguration.DEFAULT_JET_IMPORTS, importPath);\n    }","commit_id":"ddb7b54eee4a43c3f033e2ebade06d366ce4d3f6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean isImportedWithJavaDefault(ImportPath importPath) {\n        for (ImportPath defaultJavaImport : JavaBridgeConfiguration.DEFAULT_JAVA_IMPORTS) {\n            if (QualifiedNamesUtil.isImported(defaultJavaImport, importPath)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":625,"modified_method":"public static boolean isImportedWithJavaDefault(ImportPath importPath) {\n        return QualifiedNamesUtil.isImported(JavaBridgeConfiguration.DEFAULT_JAVA_IMPORTS, importPath);\n    }","commit_id":"ddb7b54eee4a43c3f033e2ebade06d366ce4d3f6","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean isImportedWithKotlinDefault(ImportPath importPath) {\n        for (ImportPath defaultJetImport : DefaultModuleConfiguration.DEFAULT_JET_IMPORTS) {\n            if (QualifiedNamesUtil.isImported(defaultJetImport, importPath)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":626,"modified_method":"public static boolean isImportedWithKotlinDefault(ImportPath importPath) {\n        return QualifiedNamesUtil.isImported(DefaultModuleConfiguration.DEFAULT_JET_IMPORTS, importPath);\n    }","commit_id":"dc3d3952146bee4082b48ec87f5fd6e57a0534c9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean isImportedWithJavaDefault(ImportPath importPath) {\n        for (ImportPath defaultJavaImport : JavaBridgeConfiguration.DEFAULT_JAVA_IMPORTS) {\n            if (QualifiedNamesUtil.isImported(defaultJavaImport, importPath)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":627,"modified_method":"public static boolean isImportedWithJavaDefault(ImportPath importPath) {\n        return QualifiedNamesUtil.isImported(JavaBridgeConfiguration.DEFAULT_JAVA_IMPORTS, importPath);\n    }","commit_id":"dc3d3952146bee4082b48ec87f5fd6e57a0534c9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    return processElementsWithWord(adaptProcessor(single, consumer), single.searchScope, single.word, single.searchContext, single.caseSensitive);\n  }","id":628,"modified_method":"private boolean processSingleRequest(PsiSearchRequest single, Processor<PsiReference> consumer) {\n    return AsyncUtil.get(processSingleRequestAsync(single, consumer));\n  }","commit_id":"f0228498c27ac862cc6558bec2917a759f3e857b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    return processElementsWithWord(adaptProcessor(single, consumer), single.searchScope, single.word, single.searchContext, single.caseSensitive);\n  }","id":629,"modified_method":"private boolean processSingleRequest(PsiSearchRequest single, Processor<PsiReference> consumer) {\n    return AsyncUtil.get(processSingleRequestAsync(single, consumer));\n  }","commit_id":"8f5bde24d5fabad4917fcf38f7fbd6e3920fc535","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor<PsiReference> consumer) {\n    return processElementsWithWord(adaptProcessor(single, consumer), single.searchScope, single.word, single.searchContext, single.caseSensitive);\n  }","id":630,"modified_method":"private boolean processSingleRequest(PsiSearchRequest single, Processor<PsiReference> consumer) {\n    return AsyncUtil.get(processSingleRequestAsync(single, consumer));\n  }","commit_id":"ed4d538b8fa002648b7c2ee3908a47ff822ec4cf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void handleBatchReceived(Address sender, Map<Short,List<Message>> map) {\n        for(Map.Entry<Short,List<Message>> element: map.entrySet()) {\n            final List<Message> msg_list=element.getValue();\n            if(log.isTraceEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": \" + printMessageList(msg_list)).append(')');\n                log.trace(sb);\n            }\n\n            short          conn_id=element.getKey();\n            ReceiverEntry  entry=null;\n            Table<Message> win=null;\n            boolean        added=false; // set to true when at least 1 message was added\n            int            total_len=0;\n            for(Message msg: msg_list) {\n                Unicast2Header hdr=(Unicast2Header)msg.getHeader(id);\n                entry=getReceiverEntry(sender, hdr.seqno, hdr.first, conn_id);\n                if(entry == null)\n                    continue;\n                win=entry.received_msgs;\n                boolean msg_added=win.add(hdr.seqno, msg); // win is guaranteed to be non-null if we get here\n                added|=msg_added;\n                num_messages_received++;\n                total_len+=msg.getLength();\n\n                if(hdr.first && msg_added)\n                    sendAck(sender, hdr.seqno, hdr.conn_id);\n\n                // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n                // http://jira.jboss.com/jira/browse/JGRP-377\n                if(msg.isFlagSet(Message.OOB) && msg_added) {\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver OOB message \" + msg, t);\n                    }\n                }\n            }\n            if(entry != null && conn_expiry_timeout > 0)\n                entry.update();\n            if(added && total_len > 0 && entry.incrementStable(total_len))\n                sendStableMessage(sender, entry.recv_conn_id, win.getHighestDelivered(), win.getHighestReceived());\n        }\n\n        ReceiverEntry tmp=recv_table.get(sender);\n        Table<Message> win=tmp != null? tmp.received_msgs : null;\n        if(win != null)\n            removeAndPassUp(win);\n    }","id":631,"modified_method":"protected void handleBatchReceived(Address sender, Map<Short,List<Message>> map) {\n        for(Map.Entry<Short,List<Message>> element: map.entrySet()) {\n            final List<Message> msg_list=element.getValue();\n            if(log.isTraceEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": \" + printMessageList(msg_list)).append(')');\n                log.trace(sb);\n            }\n\n            short          conn_id=element.getKey();\n            ReceiverEntry  entry=null;\n            Table<Message> win=null;\n            boolean        added=false; // set to true when at least 1 message was added\n            int            total_len=0;\n            for(Message msg: msg_list) {\n                Unicast2Header hdr=(Unicast2Header)msg.getHeader(id);\n                entry=getReceiverEntry(sender, hdr.seqno, hdr.first, conn_id);\n                if(entry == null)\n                    continue;\n                win=entry.received_msgs;\n                boolean msg_added=win.add(hdr.seqno, msg); // win is guaranteed to be non-null if we get here\n                added|=msg_added;\n                num_messages_received++;\n                total_len+=msg.getLength();\n\n                if(hdr.first && msg_added)\n                    sendAck(sender, hdr.seqno, hdr.conn_id);\n\n                // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n                // http://jira.jboss.com/jira/browse/JGRP-377\n                if(msg.isFlagSet(Message.OOB) && msg_added) {\n                    try {\n                        up_prot.up(new Event(Event.MSG, msg));\n                    }\n                    catch(Throwable t) {\n                        log.error(\"couldn't deliver OOB message \" + msg, t);\n                    }\n                }\n            }\n            if(entry != null && conn_expiry_timeout > 0)\n                entry.update();\n            if(added && total_len > 0 && entry.incrementStable(total_len) && win != null) {\n                long[] digest=win.getDigest();\n                sendStableMessage(sender, entry.recv_conn_id, digest[0], digest[1]);\n            }\n        }\n\n        ReceiverEntry tmp=recv_table.get(sender);\n        Table<Message> win=tmp != null? tmp.received_msgs : null;\n        if(win != null)\n            removeAndPassUp(win);\n    }","commit_id":"f673345d84949b42a7bb167a86f8eb3fb5340719","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Check whether the hashmap contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    protected boolean handleDataReceived(Address sender, long seqno, short conn_id, boolean first, Message msg, Event evt) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n        \n        ReceiverEntry entry=getReceiverEntry(sender, seqno, first, conn_id);\n        if(entry == null)\n            return false;\n        if(conn_expiry_timeout > 0)\n            entry.update();\n        Table<Message> win=entry.received_msgs;\n        boolean added=win.add(seqno, msg); // win is guaranteed to be non-null if we get here\n        num_messages_received++;\n\n        if(added) {\n            int len=msg.getLength();\n            if(len > 0 &&  entry.incrementStable(len))\n                sendStableMessage(sender, entry.recv_conn_id, win.getHighestDelivered(), win.getHighestReceived());\n        }\n\n        // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB) && added) {\n            try {\n                up_prot.up(evt);\n            }\n            catch(Throwable t) {\n                log.error(\"couldn't deliver OOB message \" + msg, t);\n            }\n        }\n\n        removeAndPassUp(win);\n        return true;\n    }","id":632,"modified_method":"/**\n     * Check whether the hashmap contains an entry e for <code>sender<\/code> (create if not). If\n     * e.received_msgs is null and <code>first<\/code> is true: create a new AckReceiverWindow(seqno) and\n     * add message. Set e.received_msgs to the new window. Else just add the message.\n     */\n    protected boolean handleDataReceived(Address sender, long seqno, short conn_id, boolean first, Message msg, Event evt) {\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\" <-- DATA(\").append(sender).append(\": #\").append(seqno);\n            if(conn_id != 0) sb.append(\", conn_id=\").append(conn_id);\n            if(first) sb.append(\", first\");\n            sb.append(')');\n            log.trace(sb);\n        }\n        \n        ReceiverEntry entry=getReceiverEntry(sender, seqno, first, conn_id);\n        if(entry == null)\n            return false;\n        if(conn_expiry_timeout > 0)\n            entry.update();\n        Table<Message> win=entry.received_msgs;\n        boolean added=win.add(seqno, msg); // win is guaranteed to be non-null if we get here\n        num_messages_received++;\n\n        if(added) {\n            int len=msg.getLength();\n            if(len > 0 &&  entry.incrementStable(len)) {\n                long[] digest=win.getDigest();\n                sendStableMessage(sender, entry.recv_conn_id, digest[0], digest[1]);\n            }\n        }\n\n        // An OOB message is passed up immediately. Later, when remove() is called, we discard it. This affects ordering !\n        // http://jira.jboss.com/jira/browse/JGRP-377\n        if(msg.isFlagSet(Message.OOB) && added) {\n            try {\n                up_prot.up(evt);\n            }\n            catch(Throwable t) {\n                log.error(\"couldn't deliver OOB message \" + msg, t);\n            }\n        }\n\n        removeAndPassUp(win);\n        return true;\n    }","commit_id":"f673345d84949b42a7bb167a86f8eb3fb5340719","url":"https://github.com/belaban/JGroups"},{"original_method":"public void removeReceiveConnection(Address mbr) {\n        ReceiverEntry entry2=recv_table.remove(mbr);\n        if(entry2 != null) {\n            Table<Message> win=entry2.received_msgs;\n            if(win != null)\n                sendStableMessage(mbr, entry2.recv_conn_id, win.getHighestDelivered(), win.getHighestReceived());\n            entry2.reset();\n        }\n    }","id":633,"modified_method":"public void removeReceiveConnection(Address mbr) {\n        ReceiverEntry entry2=recv_table.remove(mbr);\n        if(entry2 != null) {\n            Table<Message> win=entry2.received_msgs;\n            if(win != null) {\n                long[] digest=win.getDigest();\n                sendStableMessage(mbr, entry2.recv_conn_id, digest[0], digest[1]);\n            }\n            entry2.reset();\n        }\n    }","commit_id":"f673345d84949b42a7bb167a86f8eb3fb5340719","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    public CompileTimeConstant<?> visitUnaryExpression(@NotNull JetUnaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getBaseExpression();\n        if (leftExpression == null) {\n            return null;\n        }\n        return getCallConstant(expression.getOperationReference(), leftExpression);\n    }","id":634,"modified_method":"@Override\n    public CompileTimeConstant<?> visitUnaryExpression(@NotNull JetUnaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getBaseExpression();\n        if (leftExpression == null) {\n            return null;\n        }\n        Object result = evaluateCall(expression.getOperationReference(), leftExpression);\n        if (result == null) {\n            return null;\n        }\n        return createCompileTimeConstant(result, expectedType);\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public CompileTimeConstant<?> visitQualifiedExpression(@NotNull JetQualifiedExpression expression, Void data) {\n        CompileTimeConstant wholeExpressionValue = trace.getBindingContext().get(BindingContext.COMPILE_TIME_VALUE, expression);\n        if (wholeExpressionValue != null) {\n            return wholeExpressionValue;\n        }\n\n        JetExpression receiverExpression = expression.getReceiverExpression();\n        JetExpression selectorExpression = expression.getSelectorExpression();\n\n\n        if (selectorExpression instanceof JetCallExpression) {\n            JetExpression calleeExpression = ((JetCallExpression) selectorExpression).getCalleeExpression();\n            if (!(calleeExpression instanceof JetSimpleNameExpression)) {\n                return null;\n            }\n\n            if (((JetCallExpression) selectorExpression).getValueArguments().size() < 2) {\n                return getCallConstant(calleeExpression, receiverExpression);\n            }\n        }\n\n        if (selectorExpression != null) {\n            return selectorExpression.accept(this, null);\n        }\n        return super.visitQualifiedExpression(expression, data);\n    }","id":635,"modified_method":"@Override\n    public CompileTimeConstant<?> visitQualifiedExpression(@NotNull JetQualifiedExpression expression, Void data) {\n        CompileTimeConstant wholeExpressionValue = trace.getBindingContext().get(BindingContext.COMPILE_TIME_VALUE, expression);\n        if (wholeExpressionValue != null) {\n            return wholeExpressionValue;\n        }\n\n        JetExpression receiverExpression = expression.getReceiverExpression();\n        JetExpression selectorExpression = expression.getSelectorExpression();\n\n\n        if (selectorExpression instanceof JetCallExpression) {\n            JetExpression calleeExpression = ((JetCallExpression) selectorExpression).getCalleeExpression();\n            if (!(calleeExpression instanceof JetSimpleNameExpression)) {\n                return null;\n            }\n\n            if (((JetCallExpression) selectorExpression).getValueArguments().size() < 2) {\n                Object result = evaluateCall(calleeExpression, receiverExpression);\n                if (result == null) {\n                    return null;\n                }\n                return createCompileTimeConstant(result, expectedType);\n            }\n        }\n\n        if (selectorExpression != null) {\n            return selectorExpression.accept(this, null);\n        }\n        return super.visitQualifiedExpression(expression, data);\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public CompileTimeConstant<?> visitBinaryExpression(@NotNull JetBinaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getLeft();\n        if (leftExpression == null) {\n            return null;\n        }\n\n        IElementType operationToken = expression.getOperationToken();\n        if (OperatorConventions.BOOLEAN_OPERATIONS.containsKey(operationToken)) {\n            JetType booleanType = KotlinBuiltIns.getInstance().getBooleanType();\n            CompileTimeConstant<?> leftConstant = leftExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (leftConstant == null) {\n                return null;\n            }\n            JetExpression rightExpression = expression.getRight();\n            if (rightExpression == null) {\n                return null;\n            }\n            CompileTimeConstant<?> rightConstant = rightExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (rightConstant == null) {\n                return null;\n            }\n\n            Name operationName = operationToken == JetTokens.ANDAND ? Name.identifier(\"andand\") : Name.identifier(\"oror\");\n            Object result = EvaluatePackage.evaluateBinaryExpression(leftConstant, rightConstant, operationName);\n            if (result == null) {\n                return null;\n            }\n            return createCompileTimeConstant(result, expectedType);\n        }\n        else {\n            return getCallConstant(expression.getOperationReference(), leftExpression);\n        }\n\n    }","id":636,"modified_method":"@Override\n    public CompileTimeConstant<?> visitBinaryExpression(@NotNull JetBinaryExpression expression, Void data) {\n        JetExpression leftExpression = expression.getLeft();\n        if (leftExpression == null) {\n            return null;\n        }\n\n        IElementType operationToken = expression.getOperationToken();\n        if (OperatorConventions.BOOLEAN_OPERATIONS.containsKey(operationToken)) {\n            JetType booleanType = KotlinBuiltIns.getInstance().getBooleanType();\n            CompileTimeConstant<?> leftConstant = leftExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (leftConstant == null) {\n                return null;\n            }\n            JetExpression rightExpression = expression.getRight();\n            if (rightExpression == null) {\n                return null;\n            }\n            CompileTimeConstant<?> rightConstant = rightExpression.accept(new ConstantExpressionEvaluator(trace, booleanType), null);\n            if (rightConstant == null) {\n                return null;\n            }\n\n            Name operationName = operationToken == JetTokens.ANDAND ? Name.identifier(\"andand\") : Name.identifier(\"oror\");\n            Object result = EvaluatePackage.evaluateBinaryExpression(leftConstant, rightConstant, operationName);\n            if (result == null) {\n                return null;\n            }\n            return createCompileTimeConstant(result, expectedType);\n        }\n        else {\n            Object result = evaluateCall(expression.getOperationReference(), leftExpression);\n            if (result == null) {\n                return null;\n            }\n            if (OperatorConventions.COMPARISON_OPERATIONS.contains(operationToken)) {\n                return createCompileTimeConstantForCompareTo(result, operationToken);\n            }\n            else if (OperatorConventions.EQUALS_OPERATIONS.contains(operationToken)) {\n                return createCompileTimeConstantForEquals(result, operationToken);\n            }\n            else {\n                return createCompileTimeConstant(result, expectedType);\n            }\n        }\n    }","commit_id":"1bd63fefa49dcf547f41f36e54be90e5ce3e05fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void sendNow(Log eventLog) {\n        Events events = eventLog.getEvents();\n        for (int i = 0; i < events.getEventCount(); i++) {\n            Event event = events.getEvent(i);\n            sendNow(event);\n        }\n    }","id":637,"modified_method":"public void sendNow(Log eventLog) {\n        for (Event event : eventLog.getEvents().getEventCollection()) {\n            sendNow(event);\n        }\n    }","commit_id":"1eff155173f5141ee5bc81b3b99432a91ca8f131","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sendNow(Log eventLog) {\n        Events events = eventLog.getEvents();\n        for (int i = 0; i < events.getEventCount(); i++) {\n            Event event = events.getEvent(i);\n            sendNow(event);\n        }\n    }","id":638,"modified_method":"public void sendNow(Log eventLog) {\n        for (Event event : eventLog.getEvents().getEventCollection()) {\n            sendNow(event);\n        }\n    }","commit_id":"b2105509803cda157e707ded21c842e03847b1d1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void sendNow(Log eventLog) {\n        Events events = eventLog.getEvents();\n        for (int i = 0; i < events.getEventCount(); i++) {\n            Event event = events.getEvent(i);\n            sendNow(event);\n        }\n    }","id":639,"modified_method":"public void sendNow(Log eventLog) {\n        for (Event event : eventLog.getEvents().getEventCollection()) {\n            sendNow(event);\n        }\n    }","commit_id":"46ca9e5085255eba25dad067f37c3cca803b7925","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        MarkupText.SubText t = text.findToken(Pattern.compile(\"^[^:]+(?=:)\"));\n        if (t!=null)\n            t.addMarkup(0,t.length(),\"<span class=error-inline>\",\"<\/span>\");\n        return null;\n    }","id":640,"modified_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        text.addMarkup(0,text.length(),\"<span class=error-inline>\",\"<\/span>\");\n        return null;\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        MarkupText.SubText t = text.findToken(Pattern.compile(\"^[^:]+(?=:)\"));\n        if (t!=null)\n            t.addMarkup(7,t.length(),\"<b class=maven-mojo>\",\"<\/b>\");\n        return null;\n    }","id":641,"modified_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        text.addMarkup(7,text.length(),\"<b class=maven-mojo>\",\"<\/b>\");\n        return null;\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        MarkupText.SubText t = text.findToken(Pattern.compile(\"^[^:]+(?=:)\"));\n        if (t!=null)\n            t.addMarkup(0,t.length(),\"<span class=warning-inline>\",\"<\/span>\");\n        return null;\n    }","id":642,"modified_method":"@Override\n    public ConsoleAnnotator annotate(Object context, MarkupText text, int charPos) {\n        text.addMarkup(0,text.length(),\"<span class=warning-inline>\",\"<\/span>\");\n        return null;\n    }","commit_id":"05dd7f8d4f77049f9763371eab3c925b2a08adce","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateEmailAddress() throws Exception {\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\");\n\n\t\t\tObject value = field.get(null);\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tfield.set(null, Boolean.FALSE);\n\n\t\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tString emailAddress =\n\t\t\t\t\t\"UserServiceTest.\" + RandomTestUtil.nextLong() +\n\t\t\t\t\t\t\"@liferay.com\";\n\n\t\t\t\tUserServiceUtil.updateEmailAddress(\n\t\t\t\t\tuser.getUserId(), user.getPassword(), emailAddress,\n\t\t\t\t\temailAddress, new ServiceContext());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tfield.set(null, value);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","id":643,"modified_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateEmailAddress() throws Exception {\n\t\t\tboolean companySecurityStrangersWithMx =\n\t\t\t\tPropsValues.COMPANY_SECURITY_STRANGERS_WITH_MX;\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tfalse);\n\n\t\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tString emailAddress =\n\t\t\t\t\t\"UserServiceTest.\" + RandomTestUtil.nextLong() +\n\t\t\t\t\t\t\"@liferay.com\";\n\n\t\t\t\tUserServiceUtil.updateEmailAddress(\n\t\t\t\t\tuser.getUserId(), user.getPassword(), emailAddress,\n\t\t\t\t\temailAddress, new ServiceContext());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tcompanySecurityStrangersWithMx);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotAddUser() throws Exception {\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\");\n\n\t\t\tObject value = field.get(null);\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tfield.set(null, Boolean.FALSE);\n\n\t\t\t\tPrincipalThreadLocal.setName(0);\n\n\t\t\t\tUserTestUtil.addUser(true);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tfield.set(null, value);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","id":644,"modified_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotAddUser() throws Exception {\n\t\t\tboolean companySecurityStrangersWithMx =\n\t\t\t\tPropsValues.COMPANY_SECURITY_STRANGERS_WITH_MX;\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tfalse);\n\n\t\t\t\tPrincipalThreadLocal.setName(0);\n\n\t\t\t\tUserTestUtil.addUser(true);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tcompanySecurityStrangersWithMx);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateUser() throws Exception {\n\t\t\tField field = ReflectionUtil.getDeclaredField(\n\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\");\n\n\t\t\tObject value = field.get(null);\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\ttry {\n\t\t\t\tfield.set(null, Boolean.FALSE);\n\n\t\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tUserTestUtil.updateUser(user);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tfield.set(null, value);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\t\t\t}\n\t\t}","id":645,"modified_method":"@Test(expected = ReservedUserEmailAddressException.class)\n\t\tpublic void shouldNotUpdateUser() throws Exception {\n\t\t\tboolean companySecurityStrangersWithMx =\n\t\t\t\tPropsValues.COMPANY_SECURITY_STRANGERS_WITH_MX;\n\n\t\t\tString name = PrincipalThreadLocal.getName();\n\n\t\t\tUser user = UserTestUtil.addUser(false);\n\n\t\t\ttry {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tfalse);\n\n\t\t\t\tPrincipalThreadLocal.setName(user.getUserId());\n\n\t\t\t\tUserTestUtil.updateUser(user);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tReflectionTestUtil.setFieldValue(\n\t\t\t\t\tPropsValues.class, \"COMPANY_SECURITY_STRANGERS_WITH_MX\",\n\t\t\t\t\tcompanySecurityStrangersWithMx);\n\n\t\t\t\tPrincipalThreadLocal.setName(name);\n\n\t\t\t\tUserLocalServiceUtil.deleteUser(user);\n\t\t\t}\n\t\t}","commit_id":"5f68e827ec60fcb0fc062b165433aa3284f54501","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = game.getPermanentEntering(source.getSourceId());\r\n        }\r\n        if (controller != null) {\r\n            Choice choice = new ChoiceImpl(true);\r\n            choice.setMessage(choiceMessage);\r\n            choice.getChoices().addAll(modes);\r\n            while (!choice.isChosen()) {\r\n                if (!controller.canRespond()) {\r\n                    return false;\r\n                }\r\n                controller.choose(Outcome.Neutral, choice, game);\r\n            }\r\n            if (choice.isChosen()) {\r\n                if (!game.isSimulation()) {\r\n                    game.informPlayers(new StringBuilder(sourcePermanent.getLogName()).append(\": \").append(controller.getLogName()).append(\" has chosen \").append(choice.getChoice()).toString());\r\n                }\r\n                game.getState().setValue(source.getSourceId() + \"_modeChoice\", choice.getChoice());\r\n                sourcePermanent.addInfo(\"_modeChoice\", \"<font color = 'blue'>Chosen mode: \" + choice.getChoice() + \"<\/font>\", game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":646,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n        if (sourcePermanent == null) {\r\n            sourcePermanent = game.getPermanentEntering(source.getSourceId());\r\n        }\r\n        if (controller != null) {\r\n            Choice choice = new ChoiceImpl(true);\r\n            choice.setMessage(choiceMessage);\r\n            choice.getChoices().addAll(modes);\r\n            while (!choice.isChosen()) {\r\n                if (!controller.canRespond()) {\r\n                    return false;\r\n                }\r\n                controller.choose(Outcome.Neutral, choice, game);\r\n            }\r\n            if (choice.isChosen()) {\r\n                if (!game.isSimulation()) {\r\n                    game.informPlayers(sourcePermanent.getLogName() + \": \" + controller.getLogName() + \" has chosen \" + choice.getChoice());\r\n                }\r\n                game.getState().setValue(source.getSourceId() + \"_modeChoice\", choice.getChoice());\r\n                sourcePermanent.addInfo(\"_modeChoice\", \"<font color = 'blue'>Chosen mode: \" + choice.getChoice() + \"<\/font>\", game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"ae69986aef21f38fc434664e731292c49e7b31f0","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && sourceObject != null) {\n            int affectedTargets = 0;\n            for (UUID uuid : targetPointer.getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(uuid);\n                if (permanent != null) {\n                    if (counter != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        int before = permanent.getCounters().getCount(counter.getName());\n                        permanent.addCounters(newCounter, game);\n                        int numberAdded = permanent.getCounters().getCount(counter.getName()) - before;\n                        affectedTargets ++;\n                        if (!game.isSimulation()) {\n                            game.informPlayers(sourceObject.getLogName() +\": \"+ controller.getLogName()+ \" puts \" +\n                                numberAdded + \" \" + counter.getName().toLowerCase() + \" counter on \" + permanent.getLogName());\n                        }\n                    }\n                } else {\n                    Player player = game.getPlayer(uuid);\n                    if (player != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        player.addCounters(newCounter, game);\n                        affectedTargets ++;\n                        if (!game.isSimulation())\n                            game.informPlayers(new StringBuilder(sourceObject.getLogName()).append(\": \")\n                                .append(controller.getLogName()).append(\" puts \")\n                                .append(counter.getCount()).append(\" \").append(counter.getName().toLowerCase())\n                                .append(\" counter on \").append(player.getLogName()).toString());                        \n                    }\n                }\n            }  \n            return affectedTargets > 0;\n        }\n        return false;\n    }","id":647,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        MageObject sourceObject = game.getObject(source.getSourceId());\n        if (controller != null && sourceObject != null) {\n            int affectedTargets = 0;\n            for (UUID uuid : targetPointer.getTargets(game, source)) {\n                Permanent permanent = game.getPermanent(uuid);\n                if (permanent != null) {\n                    if (counter != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        int before = permanent.getCounters().getCount(counter.getName());\n                        permanent.addCounters(newCounter, game);\n                        int numberAdded = permanent.getCounters().getCount(counter.getName()) - before;\n                        affectedTargets ++;\n                        if (!game.isSimulation()) {\n                            game.informPlayers(sourceObject.getLogName() +\": \"+ controller.getLogName()+ \" puts \" +\n                                numberAdded + \" \" + counter.getName().toLowerCase() + \" counter on \" + permanent.getLogName());\n                        }\n                    }\n                } else {\n                    Player player = game.getPlayer(uuid);\n                    if (player != null) {\n                        Counter newCounter = counter.copy();\n                        newCounter.add(amount.calculate(game, source, this));\n                        player.addCounters(newCounter, game);\n                        affectedTargets ++;\n                        if (!game.isSimulation()) {\n                            game.informPlayers(sourceObject.getLogName() +\": \" + controller.getLogName() + \" puts \" +\n                                    counter.getCount() + \" \" + counter.getName().toLowerCase() + \" counter on \" + player.getLogName());\n                        }                        \n                    }\n                }\n            }  \n            return affectedTargets > 0;\n        }\n        return false;\n    }","commit_id":"7bc8ff9955bb5fcc04d1d09b64247d195f09c7d5","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent permanent = game.getPermanent(source.getSourceId());\n        if (controller != null && permanent != null) {\n            ChoiceColor choice = new ChoiceColor();\n            while (!choice.isChosen()) {\n                controller.choose(outcome, choice, game);\n                if (!controller.isInGame()) {\n                    return false;\n                }\n            }\n            if (!game.isSimulation()) {\n                game.informPlayers(new StringBuilder(permanent.getLogName()).append(\": \").append(controller.getLogName()).append(\" has chosen \").append(choice.getChoice()).toString());\n            }\n            game.getState().setValue(source.getSourceId() + \"_color\", choice.getColor());\n            permanent.addInfo(\"chosen color\", \"<font color = 'blue'>Chosen color: \" + choice.getColor().getDescription() + \"<\/font>\", game);\n            return true;\n        }\n        return false;\n    }","id":648,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent permanent = game.getPermanent(source.getSourceId());\n        if (controller != null && permanent != null) {\n            ChoiceColor choice = new ChoiceColor();\n            while (!choice.isChosen()) {\n                controller.choose(outcome, choice, game);\n                if (!controller.isInGame()) {\n                    return false;\n                }\n            }\n            if (!game.isSimulation()) {\n                game.informPlayers(permanent.getLogName()+\": \"+controller.getLogName()+\" has chosen \"+choice.getChoice());\n            }\n            game.getState().setValue(source.getSourceId() + \"_color\", choice.getColor());\n            permanent.addInfo(\"chosen color\", CardUtil.addToolTipMarkTags(\"Chosen color: \" + choice.getChoice()), game);\n            return true;\n        }\n        return false;\n    }","commit_id":"8f39a0ba1db7fd009d309ec2e64967410c8a8cc9","url":"https://github.com/magefree/mage"},{"original_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    queue.put( next, currentAggregatedValue + calculateValue( next ) );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, Double> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","id":649,"modified_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    P newPriority = addPriority( next, currentAggregatedValue,\n                            calculateValue( next ) );\n                    queue.put( next, newPriority );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, P> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","commit_id":"d39f8afad93d11e26e1475779c84b8fa00a45fc6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    queue.put( next, currentAggregatedValue + calculateValue( next ) );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, Double> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","id":650,"modified_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    P newPriority = addPriority( next, currentAggregatedValue,\n                            calculateValue( next ) );\n                    queue.put( next, newPriority );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, P> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","commit_id":"285eb0b2426ecaf4a31380b3888bba1b05938bc2","url":"https://github.com/neo4j/neo4j"},{"original_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    queue.put( next, currentAggregatedValue + calculateValue( next ) );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, Double> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","id":651,"modified_method":"public ExpansionSource nextPosition()\n        {\n            // Exhaust current if not already exhausted\n            while ( true )\n            {\n                ExpansionSource next = current.next();\n                if ( next != null )\n                {\n                    P newPriority = addPriority( next, currentAggregatedValue,\n                            calculateValue( next ) );\n                    queue.put( next, newPriority );\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            // Pop the top from priorityMap\n            Entry<ExpansionSource, P> entry = queue.pop();\n            if ( entry != null )\n            {\n                current = entry.getEntity();\n                currentAggregatedValue = entry.getPriority();\n                return current;\n            }\n            return null;\n        }","commit_id":"c4dfea1bccd1085eabdb0ba450d509018324c4f6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void checkCondition(@Nullable PsiExpression condition,\n                                    @NotNull PsiStatement context) {\n            if (condition == null) {\n                return;\n            }\n            if (condition instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)condition;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                checkCondition(operand, context);\n            } else if (condition instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)condition;\n                PsiExpression lhs = binaryExpression.getLOperand();\n                PsiExpression rhs = binaryExpression.getROperand();\n                if (rhs == null) {\n                    return;\n                }\n                lhs = ParenthesesUtils.stripParentheses(lhs);\n                rhs = ParenthesesUtils.stripParentheses(rhs);\n                if (ComparisonUtils.isComparison(binaryExpression)) {\n                    if (lhs instanceof PsiLiteralExpression) {\n                        checkCondition(rhs, context);\n                    } else if (rhs instanceof PsiLiteralExpression) {\n                        checkCondition(lhs, context);\n                    }\n                }\n            } else if (condition instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)condition;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        registerError(condition);\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        registerError(condition);\n                    }\n                }\n            } else if (condition instanceof PsiPrefixExpression) {\n                final PsiPrefixExpression prefixExpression =\n                        (PsiPrefixExpression)condition;\n                final PsiJavaToken sign = prefixExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (JavaTokenType.EXCL.equals(tokenType)) {\n                    final PsiExpression operand = prefixExpression.getOperand();\n                    checkCondition(operand, context);\n                }\n            }\n        }","id":652,"modified_method":"private boolean checkCondition(@Nullable PsiExpression condition,\n                                    @NotNull PsiStatement context) {\n            if (condition == null) {\n                return false;\n            }\n            if (condition instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)condition;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                if (checkCondition(operand, context)) {\n                    registerError(operand);\n                }\n                return false;\n            } else if (condition instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)condition;\n                PsiExpression lhs = binaryExpression.getLOperand();\n                PsiExpression rhs = binaryExpression.getROperand();\n                if (rhs == null) {\n                    return false;\n                }\n                lhs = ParenthesesUtils.stripParentheses(lhs);\n                rhs = ParenthesesUtils.stripParentheses(rhs);\n                if (ComparisonUtils.isComparison(binaryExpression)) {\n                    if (PsiUtil.isConstantExpression(lhs)) {\n                        if (checkCondition(rhs, context)) {\n                            registerError(rhs);\n                        }\n                        return false;\n                    } else if (PsiUtil.isConstantExpression(rhs)) {\n                        if (checkCondition(lhs, context)) {\n                            registerError(lhs);\n                        }\n                        return false;\n                    } else if (lhs instanceof PsiReferenceExpression &&\n                            rhs instanceof PsiReferenceExpression){\n                        if (checkCondition(lhs, context) &&\n                                checkCondition(rhs, context)) {\n                            registerError(lhs);\n                            registerError(rhs);\n                        }\n                        return false;\n                    }\n                }\n            } else if (condition instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)condition;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        return true;\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        return true;\n                    }\n                }\n            } else if (condition instanceof PsiPrefixExpression) {\n                final PsiPrefixExpression prefixExpression =\n                        (PsiPrefixExpression)condition;\n                final PsiJavaToken sign = prefixExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (JavaTokenType.EXCL.equals(tokenType) ||\n                        JavaTokenType.MINUS.equals(tokenType) ||\n                        JavaTokenType.PLUS.equals(tokenType)) {\n                    final PsiExpression operand = prefixExpression.getOperand();\n                    if (checkCondition(operand, context)) {\n                        registerError(operand);\n                    }\n                    return false;\n                }\n            }\n            return false;\n        }","commit_id":"3b2c2c227fd2d328bd089d025ebe9c6758a0afec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkCondition(\n                PsiExpression expression, PsiStatement context) {\n            if (expression instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)expression;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                checkCondition(operand, context);\n            } else if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)expression;\n                final PsiExpression lhs = binaryExpression.getLOperand();\n                final PsiExpression rhs = binaryExpression.getROperand();\n                checkCondition(lhs, context);\n                checkCondition(rhs, context);\n            } else if (expression instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)expression;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        registerError(expression);\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        registerError(expression);\n                    }\n                }\n            }\n        }","id":653,"modified_method":"private void checkCondition(\n                PsiExpression expression, PsiStatement context) {\n            if (expression instanceof PsiInstanceOfExpression) {\n                final PsiInstanceOfExpression instanceOfExpression =\n                        (PsiInstanceOfExpression)expression;\n                final PsiExpression operand = instanceOfExpression.getOperand();\n                checkCondition(operand, context);\n            } else if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)expression;\n                PsiExpression lhs = binaryExpression.getLOperand();\n                PsiExpression rhs = binaryExpression.getROperand();\n                if (rhs == null) {\n                    return;\n                }\n                lhs = ParenthesesUtils.stripParentheses(lhs);\n                rhs = ParenthesesUtils.stripParentheses(rhs);\n                if (ComparisonUtils.isComparison(binaryExpression)) {\n                    if (lhs instanceof PsiLiteralExpression) {\n                        checkCondition(rhs, context);\n                    } else if (rhs instanceof PsiLiteralExpression) {\n                        checkCondition(lhs, context);\n                    }\n                } else {\n                    checkCondition(rhs, context);\n                    checkCondition(lhs, context);\n                }\n            } else if (expression instanceof PsiReferenceExpression) {\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)expression;\n                final PsiElement element = referenceExpression.resolve();\n                if (element instanceof PsiLocalVariable) {\n                    final PsiLocalVariable variable = (PsiLocalVariable)element;\n                    if (!VariableAccessUtils.variableIsAssigned(variable,\n                            context)) {\n                        registerError(expression);\n                    }\n                } else if (element instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)element;\n                    if (!VariableAccessUtils.variableIsAssigned(parameter,\n                            context)) {\n                        registerError(expression);\n                    }\n                }\n            } else if (expression instanceof PsiPrefixExpression) {\n                final PsiPrefixExpression prefixExpression =\n                        (PsiPrefixExpression)expression;\n                final PsiJavaToken sign = prefixExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (JavaTokenType.EXCL.equals(tokenType)) {\n                    final PsiExpression operand = prefixExpression.getOperand();\n                    checkCondition(operand, context);\n                }\n            }\n        }","commit_id":"de6fe2273310915b2e8cf426106f8cef87e0c230","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n    if(item1.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()) && !item2.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()))\n      return -1;\n    if(!item1.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()) && item2.getLookupString().toLowerCase().startsWith(myPrefix.toLowerCase()))\n      return 1;\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if(o1 instanceof String || o1 instanceof PsiKeyword){\n      if(!(o2 instanceof String || o2 instanceof PsiKeyword))\n        return 1;\n      else{\n        return o1.toString().compareTo(o2.toString());\n      }\n    }\n    else if(o2 instanceof String || o2 instanceof PsiKeyword)\n      return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if(!(o1 instanceof PsiLocalVariable ||\n           o1 instanceof PsiParameter)) return 1;\n      if(!(o2 instanceof PsiLocalVariable ||\n           o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1).intValue() - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2).intValue() - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      boolean equalsName2 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = ((PsiNamedElement)o1).getName().equals(myPrefix);\n      }\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = ((PsiNamedElement)o2).getName().equals(myPrefix);\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1, myNormalizedItems);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2, myNormalizedItems);\n        return count2 - count1;\n      }\n    }\n\n    return 0;\n  }","id":654,"modified_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n    String item1String = item1.getLookupString();\n    String item2String = item2.getLookupString();\n\n    item1String = item1String.toLowerCase();\n    item2String = item2String.toLowerCase();\n\n    if(item1String.startsWith(myPrefixLowered) && !item2String.startsWith(myPrefixLowered))\n      return -1;\n    if(!item1String.startsWith(myPrefixLowered) && item2String.startsWith(myPrefixLowered))\n      return 1;\n\n    // Check equality in case\n    item1String = item1.getLookupString();\n    item2String = item2.getLookupString();\n\n    if(item1String.startsWith(myPrefix) && !item2String.startsWith(myPrefix))\n      return -1;\n    if(!item1String.startsWith(myPrefix) && item2String.startsWith(myPrefix))\n      return 1;\n\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if(o1 instanceof String || o1 instanceof PsiKeyword){\n      if(!(o2 instanceof String || o2 instanceof PsiKeyword))\n        return 1;\n      else{\n        return o1.toString().compareTo(o2.toString());\n      }\n    }\n    else if(o2 instanceof String || o2 instanceof PsiKeyword)\n      return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if(!(o1 instanceof PsiLocalVariable ||\n           o1 instanceof PsiParameter)) return 1;\n      if(!(o2 instanceof PsiLocalVariable ||\n           o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1).intValue() - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2).intValue() - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      boolean equalsName2 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = ((PsiNamedElement)o1).getName().equals(myPrefix);\n      }\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = ((PsiNamedElement)o2).getName().equals(myPrefix);\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1, myNormalizedItems);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2, myNormalizedItems);\n        return count2 - count1;\n      }\n    }\n\n    return 0;\n  }","commit_id":"f84bc41b3786b25253ccaabc09074efebc1eb60b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n    String item1String = item1.getLookupString();\n    String item2String = item2.getLookupString();\n\n    item1String = item1String.toLowerCase();\n    item2String = item2String.toLowerCase();\n\n    if (item1String.startsWith(myPrefixLowered) && !item2String.startsWith(myPrefixLowered)) return -1;\n    if (!item1String.startsWith(myPrefixLowered) && item2String.startsWith(myPrefixLowered)) return 1;\n\n    // Check equality in case\n    item1String = item1.getLookupString();\n    item2String = item2.getLookupString();\n\n    if (item1String.startsWith(myPrefix) && !item2String.startsWith(myPrefix)) return -1;\n    if (!item1String.startsWith(myPrefix) && item2String.startsWith(myPrefix)) return 1;\n\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if (o1 instanceof String || o1 instanceof PsiKeyword) {\n      if (o2 instanceof String || o2 instanceof PsiKeyword) {\n        return o1.toString().compareTo(o2.toString());\n      }\n      else {\n        return 1;\n      }\n    }\n    if (o2 instanceof String || o2 instanceof PsiKeyword) return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if (!(o1 instanceof PsiLocalVariable || o1 instanceof PsiParameter)) return 1;\n      if (!(o2 instanceof PsiLocalVariable || o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1) - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2) - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = myPrefix.equals(((PsiNamedElement)o1).getName());\n      }\n      boolean equalsName2 = false;\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = myPrefix.equals(((PsiNamedElement)o2).getName());\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2);\n        if (count2 != count1) {\n          return count2 - count1;\n        }\n      }\n    }\n    return 0;\n  }","id":655,"modified_method":"public int compare(final LookupItem item1, final LookupItem item2) {\n    if (item1 == item2) return 0;\n\n    String item1StringCap = capitalsOnly(item1.getLookupString());\n    String item2StringCap = capitalsOnly(item2.getLookupString());\n\n    if (item1StringCap.startsWith(myPrefixCapitals) && !item2StringCap.startsWith(myPrefixCapitals)) return -1;\n    if (!item1StringCap.startsWith(myPrefixCapitals) && item2StringCap.startsWith(myPrefixCapitals)) return 1;\n\n    // Check equality in case\n    String item1String = item1.getLookupString();\n    String item2String = item2.getLookupString();\n\n    if (item1String.startsWith(myPrefix) && !item2String.startsWith(myPrefix)) return -1;\n    if (!item1String.startsWith(myPrefix) && item2String.startsWith(myPrefix)) return 1;\n\n\n    String item1StringLowered = item1.getLookupString().toLowerCase();\n    String item2StringLowered = item2.getLookupString().toLowerCase();\n\n    if (item1StringLowered.startsWith(myPrefixLowered) && !item2StringLowered.startsWith(myPrefixLowered)) return -1;\n    if (!item1StringLowered.startsWith(myPrefixLowered) && item2StringLowered.startsWith(myPrefixLowered)) return 1;\n\n\n    Object o1 = item1.getObject();\n    Object o2 = item2.getObject();\n\n    if (myExpectedInfos != null) {\n      int matchSize1 = getMatchedWordCount(o1);\n      int matchSize2 = getMatchedWordCount(o2);\n      if (matchSize1 != matchSize2){\n        return matchSize2 - matchSize1;\n      }\n    }\n\n    if (o1 instanceof String || o1 instanceof PsiKeyword) {\n      if (o2 instanceof String || o2 instanceof PsiKeyword) {\n        return o1.toString().compareTo(o2.toString());\n      }\n      else {\n        return 1;\n      }\n    }\n    if (o2 instanceof String || o2 instanceof PsiKeyword) return -1;\n\n    if (o1 instanceof PsiLocalVariable ||\n        o2 instanceof PsiLocalVariable ||\n        o1 instanceof PsiParameter ||\n        o2 instanceof PsiParameter\n    ){\n      if (!(o1 instanceof PsiLocalVariable || o1 instanceof PsiParameter)) return 1;\n      if (!(o2 instanceof PsiLocalVariable || o2 instanceof PsiParameter)) return -1;\n      synchronized(myItemToIndexMap){\n        int index1 = myItemToIndexMap.get(item1) - 1;\n        if (index1 < 0){\n          LOG.error(\"index1 < 0 : \" + item1);\n        }\n        int index2 = myItemToIndexMap.get(item2) - 1;\n        if (index2 < 0){\n          LOG.error(\"index2 < 0 : \" + item2);\n        }\n        return index1 - index2;\n      }\n    }\n    if (o1 instanceof PsiMember && o2 instanceof PsiMember){\n      boolean equalsName1 = false;\n      if(o1 instanceof PsiNamedElement){\n        equalsName1 = myPrefix.equals(((PsiNamedElement)o1).getName());\n      }\n      boolean equalsName2 = false;\n      if(o2 instanceof PsiNamedElement){\n        equalsName2 = myPrefix.equals(((PsiNamedElement)o2).getName());\n      }\n\n      if(equalsName2){\n        if(!equalsName1) return 1;\n      }\n      else if(equalsName1) return -1;\n\n      PsiType qualifierType1 = CompletionUtil.getQualifierType(item1);\n      PsiType qualifierType2 = CompletionUtil.getQualifierType(item2);\n      if (qualifierType1 != null && qualifierType2 != null){\n        int count1 = StatisticsManager.getInstance().getMemberUseCount(qualifierType1, (PsiMember)o1);\n        int count2 = StatisticsManager.getInstance().getMemberUseCount(qualifierType2, (PsiMember)o2);\n        if (count2 != count1) {\n          return count2 - count1;\n        }\n      }\n    }\n    return 0;\n  }","commit_id":"ac80c842b4b45e65f0c2ed1261ca49740f72c2c7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void propertyAdded(PropertyState after) {\n        if (trackChanges && propertyNames.contains(after.getName())) {\n            addValueKeys(afterKeys, after);\n        }\n    }","id":656,"modified_method":"@Override\n    public void propertyAdded(PropertyState after) {\n        String name = after.getName();\n        typeChanged = typeChanged || isTypeProperty(name);\n        if (propertyNames.contains(name)) {\n            afterKeys = addValueKeys(afterKeys, after);\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyDeleted(PropertyState before) {\n        if (trackChanges && propertyNames.contains(before.getName())) {\n            addValueKeys(beforeKeys, before);\n        }\n    }","id":657,"modified_method":"@Override\n    public void propertyDeleted(PropertyState before) {\n        String name = before.getName();\n        typeChanged = typeChanged || isTypeProperty(name);\n        if (propertyNames.contains(name)) {\n            beforeKeys = addValueKeys(beforeKeys, before);\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) {\n        if (trackChanges && propertyNames.contains(after.getName())) {\n            addValueKeys(beforeKeys, before);\n            addValueKeys(afterKeys, after);\n        }\n    }","id":658,"modified_method":"@Override\n    public void propertyChanged(PropertyState before, PropertyState after) {\n        String name = after.getName();\n        typeChanged = typeChanged || isTypeProperty(name);\n        if (propertyNames.contains(name)) {\n            beforeKeys = addValueKeys(beforeKeys, before);\n            afterKeys = addValueKeys(afterKeys, after);\n        }\n    }","commit_id":"ac469ed5ebd20af356eeda16e327fb2a3385bed4","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventClassNames(\n\t\t\tKBArticle.class.getName(), KBComment.class.getName(),\n\t\t\tKBTemplate.class.getName());\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-articles\", true, true),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-templates-and-kb-comments\", true, true));\n\t}","id":659,"modified_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(KBArticle.class),\n\t\t\tnew StagedModelType(KBComment.class),\n\t\t\tnew StagedModelType(KBTemplate.class));\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-articles\", true, true),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"kb-templates-and-kb-comments\", true, true));\n\t}","commit_id":"6a27c8e890b694536ed3f78d1b0b17781d213968","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public CalendarPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDataLocalized(true);\n\t\tsetDeletionSystemEventClassNames(\n\t\t\tCalendar.class.getName(), CalendarBooking.class.getName(),\n\t\t\tCalendarResource.class.getName());\n\t\tsetDataPortletPreferences(\n\t\t\t\"calendarNotificationBodyEmailInvite\",\n\t\t\t\"calendarNotificationBodyEmailReminder\",\n\t\t\t\"calendarNotificationSubjectEmailInvite\",\n\t\t\t\"calendarNotificationSubjectEmailReminder\", \"defaultDuration\",\n\t\t\t\"defaultView\", \"emailFromAddress\", \"emailFromName\", \"isoTimeFormat\",\n\t\t\t\"timeZoneId\", \"usePortalTimeZone\", \"weekStartsOn\");\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"bookings\", true, false));\n\t\tsetImportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(true);\n\t}","id":660,"modified_method":"public CalendarPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDataLocalized(true);\n\t\tsetDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(Calendar.class),\n\t\t\tnew StagedModelType(CalendarBooking.class),\n\t\t\tnew StagedModelType(CalendarResource.class));\n\t\tsetDataPortletPreferences(\n\t\t\t\"calendarNotificationBodyEmailInvite\",\n\t\t\t\"calendarNotificationBodyEmailReminder\",\n\t\t\t\"calendarNotificationSubjectEmailInvite\",\n\t\t\t\"calendarNotificationSubjectEmailReminder\", \"defaultDuration\",\n\t\t\t\"defaultView\", \"emailFromAddress\", \"emailFromName\", \"isoTimeFormat\",\n\t\t\t\"timeZoneId\", \"usePortalTimeZone\", \"weekStartsOn\");\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"bookings\", true, false));\n\t\tsetImportControls(new PortletDataHandlerControl[0]);\n\t\tsetPublishToLiveByDefault(true);\n\t}","commit_id":"4dc72813fafc5b4390227d8ed8979a7794c56d2c","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventClassNames(\n\t\t\tWSRPConsumer.class.getName(), WSRPConsumerPortlet.class.getName(),\n\t\t\tWSRPProducer.class.getName());\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"wsrp-producers\", false),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"wsrp-consumers\", true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"wsrp-consumer-portlets\")\n\t\t\t\t}));\n\t\tsetPublishToLiveByDefault(true);\n\t}","id":661,"modified_method":"public AdminPortletDataHandler() {\n\t\tsetDataLevel(DataLevel.SITE);\n\t\tsetDeletionSystemEventStagedModelTypes(\n\t\t\tnew StagedModelType(WSRPConsumer.class),\n\t\t\tnew StagedModelType(WSRPConsumerPortlet.class),\n\t\t\tnew StagedModelType(WSRPProducer.class));\n\t\tsetExportControls(\n\t\t\tnew PortletDataHandlerBoolean(NAMESPACE, \"wsrp-producers\", false),\n\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\tNAMESPACE, \"wsrp-consumers\", true,\n\t\t\t\tnew PortletDataHandlerControl[] {\n\t\t\t\t\tnew PortletDataHandlerBoolean(\n\t\t\t\t\t\tNAMESPACE, \"wsrp-consumer-portlets\")\n\t\t\t\t}));\n\t\tsetPublishToLiveByDefault(true);\n\t}","commit_id":"da5e8b73dadc792c76b20c590baad9d2ba670f47","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addSubcomponent(final String type, final String foreignSource, final String foreignId, final NCSComponent subComponent, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentIdentifier subComponentId = getIdentifier(subComponent);\n\t\t\n\t\tLogUtils.debugf(this, \"addSubcomponent(%s, %s, %s, %s, %s)\", type, foreignSource, foreignId, subComponentId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent component = getComponent(id);\n\n\t\tif (component == null) {\n\t\t\tthrow new ObjectRetrievalFailureException(NCSComponent.class, \"Unable to locate component with type=\" + type + \", foreignSource=\" + foreignSource + \", foreignId=\" + foreignId);\n\t\t}\n\n\t\tfinal NCSComponent updatedSubComponent = addOrUpdateComponents(subComponentId, subComponent, ceq, deleteOrphans);\n\t\tcomponent.addSubcomponent(updatedSubComponent);\n\t\t\n\t\tm_componentDao.update(component);\n\t\tceq.componentUpdated(id);\n\n\t\tceq.sendAll(m_eventForwarder);\n\n\t\treturn getComponent(id);\n\t}","id":662,"modified_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addSubcomponent(final String type, final String foreignSource, final String foreignId, final NCSComponent subComponent, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentIdentifier subComponentId = getIdentifier(subComponent);\n\t\t\n\t\tLogUtils.debugf(this, \"addSubcomponent(%s, %s, %s, %s, %s)\", type, foreignSource, foreignId, subComponentId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent component = getComponent(id);\n\n\t\tif (component == null) {\n\t\t\tthrow new ObjectRetrievalFailureException(NCSComponent.class, \"Unable to locate component with type=\" + type + \", foreignSource=\" + foreignSource + \", foreignId=\" + foreignId);\n\t\t}\n\n\t\tfinal NCSComponent updatedSubComponent = addOrUpdateComponents(subComponentId, subComponent, ceq, deleteOrphans);\n\t\tcomponent.addSubcomponent(updatedSubComponent);\n\t\t\n\t\tm_componentDao.update(component);\n\t\tceq.componentUpdated(id);\n\n\t\ttry {\n\t\t\tceq.sendAll(m_eventProxy);\n\t\t} catch (final EventProxyException e) {\n\t\t\tLogUtils.warnf(this, e, \"Component %s added to %s, but an error occured while sending add/delete/update events.\", subComponentId, id);\n\t\t}\n\n\t\treturn getComponent(id);\n\t}","commit_id":"4f4c800fb81515879776d1bf6f2fb05a365bf012","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t@Transactional\n\tpublic void deleteComponent(final String type, final String foreignSource, final String foreignId, final boolean deleteOrphans) {\n\t\tLogUtils.debugf(this, \"deleteSubcomponent(%s, %s, %s, %s)\", type, foreignSource, foreignId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tdeleteComponent(id, ceq, deleteOrphans);\n\t\tceq.sendAll(m_eventForwarder);\n\t}","id":663,"modified_method":"@Override\n\t@Transactional\n\tpublic void deleteComponent(final String type, final String foreignSource, final String foreignId, final boolean deleteOrphans) {\n\t\tLogUtils.debugf(this, \"deleteSubcomponent(%s, %s, %s, %s)\", type, foreignSource, foreignId, Boolean.valueOf(deleteOrphans));\n\n\t\tfinal ComponentIdentifier id = new ComponentIdentifier(type, foreignSource, foreignId);\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tdeleteComponent(id, ceq, deleteOrphans);\n\t\ttry {\n\t\t\tceq.sendAll(m_eventProxy);\n\t\t} catch (final EventProxyException e) {\n\t\t\tLogUtils.warnf(this, e, \"Component %s deleted, but an error occured while sending delete/update events.\", id);\n\t\t}\n\t}","commit_id":"4f4c800fb81515879776d1bf6f2fb05a365bf012","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addOrUpdateComponents(final NCSComponent component, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier componentId = getIdentifier(component);\n\t\tLogUtils.debugf(this, \"addOrUpdateComponents(%s, %s)\", componentId, Boolean.valueOf(deleteOrphans));\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent updatedComponent = addOrUpdateComponents(componentId, component, ceq, deleteOrphans);\n\t\tceq.sendAll(m_eventForwarder);\n\t\treturn updatedComponent;\n\t}","id":664,"modified_method":"@Override\n\t@Transactional\n\tpublic NCSComponent addOrUpdateComponents(final NCSComponent component, final boolean deleteOrphans) {\n\t\tfinal ComponentIdentifier componentId = getIdentifier(component);\n\t\tLogUtils.debugf(this, \"addOrUpdateComponents(%s, %s)\", componentId, Boolean.valueOf(deleteOrphans));\n\t\tfinal ComponentEventQueue ceq = new ComponentEventQueue();\n\t\tfinal NCSComponent updatedComponent = addOrUpdateComponents(componentId, component, ceq, deleteOrphans);\n\t\ttry {\n\t\t\tceq.sendAll(m_eventProxy);\n\t\t} catch (final EventProxyException e) {\n\t\t\tLogUtils.warnf(this, e, \"Component %s added, but an error occured while sending add/delete/update events.\", componentId);\n\t\t}\n\t\treturn updatedComponent;\n\t}","commit_id":"4f4c800fb81515879776d1bf6f2fb05a365bf012","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected long[] checkGroups(long userId, long[] groupIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldGroupIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any groups that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Group> mandatoryGroups =\n\t\t\t\tMembershipPolicyUtil.getMandatoryGroups(user);\n\n\t\t\tList<Group> oldGroups = groupLocalService.getUserGroups(userId);\n\n\t\t\toldGroupIds = new long[oldGroups.size()];\n\n\t\t\tfor (int i = 0; i < oldGroups.size(); i++) {\n\t\t\t\tGroup group = oldGroups.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(groupIds, group.getGroupId()) &&\n\t\t\t\t\t(!GroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryGroups.contains(group))) {\n\n\t\t\t\t\tgroupIds = ArrayUtil.append(groupIds, group.getGroupId());\n\t\t\t\t}\n\n\t\t\t\toldGroupIds[i] = group.getGroupId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new group\n\t\t// and that the group membership is allowed\n\n\t\tfor (long groupId : groupIds) {\n\t\t\tif ((oldGroupIds == null) ||\n\t\t\t\t!ArrayUtil.contains(oldGroupIds, groupId)) {\n\n\t\t\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\t\t\tGroupPermissionUtil.check(\n\t\t\t\t\tpermissionChecker, group, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\t\tif (!MembershipPolicyUtil.isMembershipAllowed(group, user)) {\n\t\t\t\t\tif (membershipPolicyException == null) {\n\t\t\t\t\t\tmembershipPolicyException =\n\t\t\t\t\t\t\tnew MembershipPolicyException(\n\t\t\t\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\t\t\t\tGROUP_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t\t\t}\n\n\t\t\t\t\tmembershipPolicyException.addGroup(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn groupIds;\n\t}","id":665,"modified_method":"protected long[] checkGroups(long userId, long[] groupIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldGroupIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any groups that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Group> mandatoryGroups =\n\t\t\t\tMembershipPolicyUtil.getMandatoryGroups(user);\n\n\t\t\tList<Group> oldGroups = groupLocalService.getUserGroups(userId);\n\n\t\t\toldGroupIds = new long[oldGroups.size()];\n\n\t\t\tfor (int i = 0; i < oldGroups.size(); i++) {\n\t\t\t\tGroup group = oldGroups.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(groupIds, group.getGroupId()) &&\n\t\t\t\t\t(!GroupPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, group.getGroupId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryGroups.contains(group))) {\n\n\t\t\t\t\tgroupIds = ArrayUtil.append(groupIds, group.getGroupId());\n\t\t\t\t}\n\n\t\t\t\toldGroupIds[i] = group.getGroupId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new group\n\t\t// and that the group membership is allowed\n\n\t\tfor (long groupId : groupIds) {\n\t\t\tif ((oldGroupIds != null) &&\n\t\t\t\tArrayUtil.contains(oldGroupIds, groupId)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\t\tGroupPermissionUtil.check(\n\t\t\t\tpermissionChecker, group, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\tif (MembershipPolicyUtil.isMembershipAllowed(group, user)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (membershipPolicyException == null) {\n\t\t\t\tmembershipPolicyException = new MembershipPolicyException(\n\t\t\t\t\tMembershipPolicyException.GROUP_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t}\n\n\t\t\tmembershipPolicyException.addGroup(group);\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn groupIds;\n\t}","commit_id":"d5b20a329801b1bf90ec7eb2e1b8d89a3f6b1286","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long[] checkRoles(long userId, long[] roleIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldRoleIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any roles that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Role> mandatoryRoles = MembershipPolicyUtil.getMandatoryRoles(\n\t\t\t\tuser);\n\n\t\t\tList<Role> oldRoles = roleLocalService.getUserRoles(userId);\n\n\t\t\toldRoleIds = new long[oldRoles.size()];\n\n\t\t\tfor (int i = 0; i < oldRoles.size(); i++) {\n\t\t\t\tRole role = oldRoles.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(roleIds, role.getRoleId()) &&\n\t\t\t\t\t(!RolePermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, role.getRoleId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryRoles.contains(role))) {\n\n\t\t\t\t\troleIds = ArrayUtil.append(roleIds, role.getRoleId());\n\t\t\t\t}\n\n\t\t\t\toldRoleIds[i] = role.getRoleId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new role\n\t\t// and that the role membership is allowed\n\n\t\tfor (long roleId : roleIds) {\n\t\t\tif ((oldRoleIds == null) ||\n\t\t\t\t!ArrayUtil.contains(oldRoleIds, roleId)) {\n\n\t\t\t\tRolePermissionUtil.check(\n\t\t\t\t\tpermissionChecker, roleId, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\t\tRole role = rolePersistence.findByPrimaryKey(roleId);\n\n\t\t\t\tif (!MembershipPolicyUtil.isMembershipAllowed(role, user)) {\n\t\t\t\t\tif (membershipPolicyException == null) {\n\t\t\t\t\t\tmembershipPolicyException =\n\t\t\t\t\t\t\tnew MembershipPolicyException(\n\t\t\t\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\t\t\t\tROLE_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t\t\t}\n\n\t\t\t\t\tmembershipPolicyException.addRole(role);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn roleIds;\n\t}","id":666,"modified_method":"protected long[] checkRoles(long userId, long[] roleIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldRoleIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any roles that the administrator does not have the\n\t\t\t// rights to remove or that have a mandatory membership\n\n\t\t\tSet<Role> mandatoryRoles = MembershipPolicyUtil.getMandatoryRoles(\n\t\t\t\tuser);\n\n\t\t\tList<Role> oldRoles = roleLocalService.getUserRoles(userId);\n\n\t\t\toldRoleIds = new long[oldRoles.size()];\n\n\t\t\tfor (int i = 0; i < oldRoles.size(); i++) {\n\t\t\t\tRole role = oldRoles.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(roleIds, role.getRoleId()) &&\n\t\t\t\t\t(!RolePermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, role.getRoleId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryRoles.contains(role))) {\n\n\t\t\t\t\troleIds = ArrayUtil.append(roleIds, role.getRoleId());\n\t\t\t\t}\n\n\t\t\t\toldRoleIds[i] = role.getRoleId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new role\n\t\t// and that the role membership is allowed\n\n\t\tfor (long roleId : roleIds) {\n\t\t\tif ((oldRoleIds != null) &&\n\t\t\t\tArrayUtil.contains(oldRoleIds, roleId)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRolePermissionUtil.check(\n\t\t\t\tpermissionChecker, roleId, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\tRole role = rolePersistence.findByPrimaryKey(roleId);\n\n\t\t\tif (MembershipPolicyUtil.isMembershipAllowed(role, user)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (membershipPolicyException == null) {\n\t\t\t\tmembershipPolicyException = new MembershipPolicyException(\n\t\t\t\t\tMembershipPolicyException.ROLE_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t}\n\n\t\t\tmembershipPolicyException.addRole(role);\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn roleIds;\n\t}","commit_id":"d5b20a329801b1bf90ec7eb2e1b8d89a3f6b1286","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long[] checkOrganizations(long userId, long[] organizationIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldOrganizationIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any organizations that the administrator does not have\n\t\t\t// the rights to remove or that have a mandatory membership\n\n\t\t\tSet<Organization> mandatoryOrganizations =\n\t\t\t\tMembershipPolicyUtil.getMandatoryOrganizations(user);\n\n\t\t\tList<Organization> oldOrganizations =\n\t\t\t\torganizationLocalService.getUserOrganizations(userId);\n\n\t\t\toldOrganizationIds = new long[oldOrganizations.size()];\n\n\t\t\tfor (int i = 0; i < oldOrganizations.size(); i++) {\n\t\t\t\tOrganization organization = oldOrganizations.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId()) &&\n\t\t\t\t\t!OrganizationPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, organization.getOrganizationId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryOrganizations.contains(organization)) {\n\n\t\t\t\t\torganizationIds = ArrayUtil.append(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\toldOrganizationIds[i] = organization.getOrganizationId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new\n\t\t// organization and that the organization membership is allowed\n\n\t\tfor (long organizationId : organizationIds) {\n\t\t\tOrganization organization =\n\t\t\t\torganizationPersistence.findByPrimaryKey(organizationId);\n\n\t\t\tif ((oldOrganizationIds == null) ||\n\t\t\t\t!ArrayUtil.contains(oldOrganizationIds, organizationId)) {\n\n\t\t\t\tOrganizationPermissionUtil.check(\n\t\t\t\t\tpermissionChecker, organization, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\t\tif (!MembershipPolicyUtil.isMembershipAllowed(\n\t\t\t\t\t\torganization, user)) {\n\n\t\t\t\t\tif (membershipPolicyException == null) {\n\t\t\t\t\t\tmembershipPolicyException =\n\t\t\t\t\t\t\tnew MembershipPolicyException(\n\t\t\t\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\t\t\t\tORGANIZATION_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t\t\t}\n\n\t\t\t\t\tmembershipPolicyException.addOrganization(organization);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn organizationIds;\n\t}","id":667,"modified_method":"protected long[] checkOrganizations(long userId, long[] organizationIds)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong[] oldOrganizationIds = null;\n\n\t\tPermissionChecker permissionChecker = getPermissionChecker();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tif (userId != CompanyConstants.SYSTEM) {\n\n\t\t\t// Add back any organizations that the administrator does not have\n\t\t\t// the rights to remove or that have a mandatory membership\n\n\t\t\tSet<Organization> mandatoryOrganizations =\n\t\t\t\tMembershipPolicyUtil.getMandatoryOrganizations(user);\n\n\t\t\tList<Organization> oldOrganizations =\n\t\t\t\torganizationLocalService.getUserOrganizations(userId);\n\n\t\t\toldOrganizationIds = new long[oldOrganizations.size()];\n\n\t\t\tfor (int i = 0; i < oldOrganizations.size(); i++) {\n\t\t\t\tOrganization organization = oldOrganizations.get(i);\n\n\t\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId()) &&\n\t\t\t\t\t!OrganizationPermissionUtil.contains(\n\t\t\t\t\t\tpermissionChecker, organization.getOrganizationId(),\n\t\t\t\t\t\tActionKeys.ASSIGN_MEMBERS) ||\n\t\t\t\t\tmandatoryOrganizations.contains(organization)) {\n\n\t\t\t\t\torganizationIds = ArrayUtil.append(\n\t\t\t\t\t\torganizationIds, organization.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\toldOrganizationIds[i] = organization.getOrganizationId();\n\t\t\t}\n\t\t}\n\n\t\tMembershipPolicyException membershipPolicyException = null;\n\n\t\t// Check that the administrator has the permission to add a new\n\t\t// organization and that the organization membership is allowed\n\n\t\tfor (long organizationId : organizationIds) {\n\t\t\tOrganization organization =\n\t\t\t\torganizationPersistence.findByPrimaryKey(organizationId);\n\n\t\t\tif ((oldOrganizationIds != null) &&\n\t\t\t\tArrayUtil.contains(oldOrganizationIds, organizationId)) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tOrganizationPermissionUtil.check(\n\t\t\t\tpermissionChecker, organization, ActionKeys.ASSIGN_MEMBERS);\n\n\t\t\tif (MembershipPolicyUtil.isMembershipAllowed(organization, user)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (membershipPolicyException == null) {\n\t\t\t\tmembershipPolicyException = new MembershipPolicyException(\n\t\t\t\t\tMembershipPolicyException.\n\t\t\t\t\t\tORGANIZATION_MEMBERSHIP_NOT_ALLOWED);\n\n\t\t\t\tmembershipPolicyException.addUser(user);\n\t\t\t}\n\n\t\t\tmembershipPolicyException.addOrganization(organization);\n\t\t}\n\n\t\tif (membershipPolicyException != null) {\n\t\t\tthrow membershipPolicyException;\n\t\t}\n\n\t\treturn organizationIds;\n\t}","commit_id":"d5b20a329801b1bf90ec7eb2e1b8d89a3f6b1286","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tSequence s1 = getArgument(0).eval(contextSequence);\n\t\tSequence s2 = getArgument(1).eval(contextSequence);\n\t\tif (s1.getLength() == 0 || s2.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tif (Collations.endsWith(context.getDefaultCollator(), s1.getStringValue(), s2.getStringValue()))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","id":668,"modified_method":"public Sequence eval(\n\t\tSequence contextSequence,\n\t\tItem contextItem)\n\t\tthrows XPathException {\n\t\tif (contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tString s1 = getArgument(0).eval(contextSequence).getStringValue();\n\t\tString s2 = getArgument(1).eval(contextSequence).getStringValue();\n\t\tif (s1.length() == 0 || s2.length() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tCollator collator = getCollator(contextSequence, contextItem, 3);\n\t\tif (Collations.endsWith(collator, s1, s2))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","commit_id":"3d8496bd163d4bc1431bd09b3187b4fb4b7ea20b","url":"https://github.com/eXist-db/exist"},{"original_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tSequence s1 = getArgument(0).eval(contextSequence);\n\t\tSequence s2 = getArgument(1).eval(contextSequence);\n\t\tif(s1.getLength() == 0 || s2.getLength() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tif(Collations.startsWith(context.getDefaultCollator(), s1.getStringValue(), s2.getStringValue()))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","id":669,"modified_method":"public Sequence eval(Sequence contextSequence, Item contextItem) throws XPathException {\n\t\tif(contextItem != null)\n\t\t\tcontextSequence = contextItem.toSequence();\n\n\t\tString s1 = getArgument(0).eval(contextSequence).getStringValue();\n\t\tString s2 = getArgument(1).eval(contextSequence).getStringValue();\n\t\tif(s1.length() == 0 || s2.length() == 0)\n\t\t\treturn Sequence.EMPTY_SEQUENCE;\n\t\tCollator collator = getCollator(contextSequence, contextItem, 3);\n\t\tif(Collations.startsWith(collator, s1, s2))\n\t\t\treturn BooleanValue.TRUE;\n\t\telse\n\t\t\treturn BooleanValue.FALSE;\n\t}","commit_id":"3d8496bd163d4bc1431bd09b3187b4fb4b7ea20b","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n        myModel.put(\"request\", limit.toString());\n\n        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n\n            context.setRequestAttribute(\"rowStart\", rowstart);\n            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() +1 ) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n        myModel.put(\"rowStart\", rowstart);\n        myModel.put(\"rowEnd\", rowend);\n        myModel.put(\"begin\", rowstart);\n        myModel.put(\"end\", rowend);\n\n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = null;\n            sortOrder = \"asc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        OutagesFilteringView filterView = new OutagesFilteringView();\n        filterView.setCategoryDao(m_categoryDao);\n        \n        OnmsCriteria criteria = filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = filterView.buildCriteria(request);\n        \n        Integer totalRows = m_outageService.getOutageCount(countCriteria);\n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        // Pretty smart to build the collection after any suppressions..... \n        Collection theTable = m_cview.theTable(foundOutages);\n\n        myModel.put(\"tabledata\", theTable);\n        myModel.put(\"totalRows\", totalRows);\n\n        myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        return new ModelAndView(getSuccessView(), myModel);\n    }","id":670,"modified_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n//        myModel.put(\"request\", limit.toString());\n\n//        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n//\n//            context.setRequestAttribute(\"rowStart\", rowstart);\n//            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() + 1) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n//        myModel.put(\"rowStart\", rowstart);\n//        myModel.put(\"rowEnd\", rowend);\n//        myModel.put(\"begin\", rowstart);\n//        myModel.put(\"end\", rowend);\n\n        OnmsCriteria criteria = m_filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = m_filterView.buildCriteria(request);\n        \n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = \"outageid\";\n            sortOrder = \"desc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        myModel.put(\"tabledata\", m_outageListBuilder.theTable(foundOutages));\n        myModel.put(\"totalRows\", m_outageService.getOutageCount(countCriteria)); // used by org.extremecomponents.table.callback.LimitCallback.retrieveRows\n\n        //myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        \n        return new ModelAndView(getSuccessView(), myModel);\n    }","commit_id":"0b0dc60768cddede0bacce260d41c3b82d3a13c6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n        myModel.put(\"request\", limit.toString());\n\n        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n\n            context.setRequestAttribute(\"rowStart\", rowstart);\n            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() +1 ) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n        myModel.put(\"rowStart\", rowstart);\n        myModel.put(\"rowEnd\", rowend);\n        myModel.put(\"begin\", rowstart);\n        myModel.put(\"end\", rowend);\n\n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = null;\n            sortOrder = \"asc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        OutagesFilteringView filterView = new OutagesFilteringView();\n        filterView.setCategoryDao(m_categoryDao);\n        \n        OnmsCriteria criteria = filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = filterView.buildCriteria(request);\n        \n        Integer totalRows = m_outageService.getOutageCount(countCriteria);\n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        // Pretty smart to build the collection after any suppressions..... \n        Collection theTable = m_cview.theTable(foundOutages);\n\n        myModel.put(\"tabledata\", theTable);\n        myModel.put(\"totalRows\", totalRows);\n\n        myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        return new ModelAndView(getSuccessView(), myModel);\n    }","id":671,"modified_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n//        myModel.put(\"request\", limit.toString());\n\n//        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n//\n//            context.setRequestAttribute(\"rowStart\", rowstart);\n//            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() + 1) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n//        myModel.put(\"rowStart\", rowstart);\n//        myModel.put(\"rowEnd\", rowend);\n//        myModel.put(\"begin\", rowstart);\n//        myModel.put(\"end\", rowend);\n\n        OnmsCriteria criteria = m_filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = m_filterView.buildCriteria(request);\n        \n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = \"outageid\";\n            sortOrder = \"desc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        myModel.put(\"tabledata\", m_outageListBuilder.theTable(foundOutages));\n        myModel.put(\"totalRows\", m_outageService.getOutageCount(countCriteria)); // used by org.extremecomponents.table.callback.LimitCallback.retrieveRows\n\n        //myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        \n        return new ModelAndView(getSuccessView(), myModel);\n    }","commit_id":"a87a543202406adba4caf11eeb5d996faf6fc2e3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n        myModel.put(\"request\", limit.toString());\n\n        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n\n            context.setRequestAttribute(\"rowStart\", rowstart);\n            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() +1 ) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n        myModel.put(\"rowStart\", rowstart);\n        myModel.put(\"rowEnd\", rowend);\n        myModel.put(\"begin\", rowstart);\n        myModel.put(\"end\", rowend);\n\n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = null;\n            sortOrder = \"asc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        OutagesFilteringView filterView = new OutagesFilteringView();\n        filterView.setCategoryDao(m_categoryDao);\n        \n        OnmsCriteria criteria = filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = filterView.buildCriteria(request);\n        \n        Integer totalRows = m_outageService.getOutageCount(countCriteria);\n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        // Pretty smart to build the collection after any suppressions..... \n        Collection theTable = m_cview.theTable(foundOutages);\n\n        myModel.put(\"tabledata\", theTable);\n        myModel.put(\"totalRows\", totalRows);\n\n        myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        return new ModelAndView(getSuccessView(), myModel);\n    }","id":672,"modified_method":"@Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse reply) throws Exception {\n        Context context = new HttpServletRequestContext(request);\n        LimitFactory limitFactory = new TableLimitFactory(context, \"tabledata\");\n        Limit limit = new TableLimit(limitFactory);\n\n        Map<String, Object> myModel = new HashMap<String, Object>();\n\n//        myModel.put(\"request\", limit.toString());\n\n//        myModel.put(\"all_params\", request.getParameterNames().toString());\n        \n        Integer rowstart;\n        Integer rowend;\n        if (limit.getPage() == 1) {\n            // no offset set\n            rowstart = 0;\n            rowend = getDefaultRowsDisplayed();\n//\n//            context.setRequestAttribute(\"rowStart\", rowstart);\n//            context.setRequestAttribute(\"rowEnd\", rowend);\n        } else {\n            //quirky situation... - as we started on 0 (zero)\n            rowstart = ((limit.getPage() * getDefaultRowsDisplayed() + 1) - getDefaultRowsDisplayed());\n            rowend = getDefaultRowsDisplayed();\n        }\n        \n//        myModel.put(\"rowStart\", rowstart);\n//        myModel.put(\"rowEnd\", rowend);\n//        myModel.put(\"begin\", rowstart);\n//        myModel.put(\"end\", rowend);\n\n        OnmsCriteria criteria = m_filterView.buildCriteria(request);\n        OnmsCriteria countCriteria = m_filterView.buildCriteria(request);\n        \n        String orderProperty;\n        String sortOrder;\n        \n        if (limit.getSort().getProperty() == null) {\n            orderProperty = \"outageid\";\n            sortOrder = \"desc\";\n        } else {\n            orderProperty = limit.getSort().getProperty();\n            sortOrder = limit.getSort().getSortOrder();\n        }\n        \n        Collection<OnmsOutage> foundOutages = m_outageService.getOutagesByRange(rowstart, rowend, orderProperty, sortOrder, criteria);\n\n        myModel.put(\"tabledata\", m_outageListBuilder.theTable(foundOutages));\n        myModel.put(\"totalRows\", m_outageService.getOutageCount(countCriteria)); // used by org.extremecomponents.table.callback.LimitCallback.retrieveRows\n\n        //myModel.put(\"selected_outages\", CurrentOutageParseResponse.findSelectedOutagesIDs(request,m_outageService));\n        \n        return new ModelAndView(getSuccessView(), myModel);\n    }","commit_id":"d370370ca456facba7028cd86f4cc0f09666211a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Post-processing tokenization rules for the NFL domain\n    //\n    pool.register(STANFORD_NFL_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className =\n          \"edu.stanford.nlp.pipeline.NFLTokenizerAnnotator\";\n        return ReflectionLoading.loadByReflection(className);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // no used props for this one\n        return \"\";\n      }\n    });\n\n    //\n    // Entity and relation extraction for the NFL domain\n    //\n    pool.register(STANFORD_NFL, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        // these paths now extracted inside c'tor\n        // String gazetteer = properties.getProperty(\"nfl.gazetteer\", DefaultPaths.DEFAULT_NFL_GAZETTEER);\n        // String entityModel = properties.getProperty(\"nfl.entity.model\", DefaultPaths.DEFAULT_NFL_ENTITY_MODEL);\n        // String relationModel = properties.getProperty(\"nfl.relation.model\", DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n        final String className = \"edu.stanford.nlp.pipeline.NFLAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"nfl.verbose:\" +\n                properties.getProperty(\"nfl.verbose\",\n                        \"false\") +\n                \"nfl.relations.use.max.recall:\" +\n                properties.getProperty(\"nfl.relations.use.max.recall\",\n                        \"false\") +\n                \"nfl.relations.use.model.merging:\" +\n                properties.getProperty(\"nfl.relations.use.model.merging\",\n                        \"false\") +\n                \"nfl.relations.use.basic.inference:\" +\n                properties.getProperty(\"nfl.relations.use.basic.inference\",\n                        \"true\") +\n                \"nfl.gazetteer:\" +\n                properties.getProperty(\"nfl.gazetteer\",\n                        DefaultPaths.DEFAULT_NFL_GAZETTEER) +\n                \"nfl.entity.model:\" +\n                properties.getProperty(\"nfl.entity.model\",\n                        DefaultPaths.DEFAULT_NFL_ENTITY_MODEL) +\n                \"nfl.relation.model:\" +\n                properties.getProperty(\"nfl.relation.model\",\n                        DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className = \"edu.stanford.nlp.pipeline.RelationExtractorAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"TODO\";\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":673,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"c4a22d77d46a69177c53e687a383434c507d3c2e","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Post-processing tokenization rules for the NFL domain\n    //\n    pool.register(STANFORD_NFL_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className =\n          \"edu.stanford.nlp.pipeline.NFLTokenizerAnnotator\";\n        return ReflectionLoading.loadByReflection(className);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // no used props for this one\n        return \"\";\n      }\n    });\n\n    //\n    // Entity and relation extraction for the NFL domain\n    //\n    pool.register(STANFORD_NFL, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        // these paths now extracted inside c'tor\n        // String gazetteer = properties.getProperty(\"nfl.gazetteer\", DefaultPaths.DEFAULT_NFL_GAZETTEER);\n        // String entityModel = properties.getProperty(\"nfl.entity.model\", DefaultPaths.DEFAULT_NFL_ENTITY_MODEL);\n        // String relationModel = properties.getProperty(\"nfl.relation.model\", DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n        final String className = \"edu.stanford.nlp.pipeline.NFLAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"nfl.verbose:\" +\n                properties.getProperty(\"nfl.verbose\",\n                        \"false\") +\n                \"nfl.relations.use.max.recall:\" +\n                properties.getProperty(\"nfl.relations.use.max.recall\",\n                        \"false\") +\n                \"nfl.relations.use.model.merging:\" +\n                properties.getProperty(\"nfl.relations.use.model.merging\",\n                        \"false\") +\n                \"nfl.relations.use.basic.inference:\" +\n                properties.getProperty(\"nfl.relations.use.basic.inference\",\n                        \"true\") +\n                \"nfl.gazetteer:\" +\n                properties.getProperty(\"nfl.gazetteer\",\n                        DefaultPaths.DEFAULT_NFL_GAZETTEER) +\n                \"nfl.entity.model:\" +\n                properties.getProperty(\"nfl.entity.model\",\n                        DefaultPaths.DEFAULT_NFL_ENTITY_MODEL) +\n                \"nfl.relation.model:\" +\n                properties.getProperty(\"nfl.relation.model\",\n                        DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className = \"edu.stanford.nlp.pipeline.RelationExtractorAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"TODO\";\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":674,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"3832346aab66a19293177272a2417d97f083e462","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Post-processing tokenization rules for the NFL domain\n    //\n    pool.register(STANFORD_NFL_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className =\n          \"edu.stanford.nlp.pipeline.NFLTokenizerAnnotator\";\n        return ReflectionLoading.loadByReflection(className);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // no used props for this one\n        return \"\";\n      }\n    });\n\n    //\n    // Entity and relation extraction for the NFL domain\n    //\n    pool.register(STANFORD_NFL, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        // these paths now extracted inside c'tor\n        // String gazetteer = properties.getProperty(\"nfl.gazetteer\", DefaultPaths.DEFAULT_NFL_GAZETTEER);\n        // String entityModel = properties.getProperty(\"nfl.entity.model\", DefaultPaths.DEFAULT_NFL_ENTITY_MODEL);\n        // String relationModel = properties.getProperty(\"nfl.relation.model\", DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n        final String className = \"edu.stanford.nlp.pipeline.NFLAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"nfl.verbose:\" +\n                properties.getProperty(\"nfl.verbose\",\n                        \"false\") +\n                \"nfl.relations.use.max.recall:\" +\n                properties.getProperty(\"nfl.relations.use.max.recall\",\n                        \"false\") +\n                \"nfl.relations.use.model.merging:\" +\n                properties.getProperty(\"nfl.relations.use.model.merging\",\n                        \"false\") +\n                \"nfl.relations.use.basic.inference:\" +\n                properties.getProperty(\"nfl.relations.use.basic.inference\",\n                        \"true\") +\n                \"nfl.gazetteer:\" +\n                properties.getProperty(\"nfl.gazetteer\",\n                        DefaultPaths.DEFAULT_NFL_GAZETTEER) +\n                \"nfl.entity.model:\" +\n                properties.getProperty(\"nfl.entity.model\",\n                        DefaultPaths.DEFAULT_NFL_ENTITY_MODEL) +\n                \"nfl.relation.model:\" +\n                properties.getProperty(\"nfl.relation.model\",\n                        DefaultPaths.DEFAULT_NFL_RELATION_MODEL);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        final String className = \"edu.stanford.nlp.pipeline.RelationExtractorAnnotator\";\n        return ReflectionLoading.loadByReflection(className, properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"TODO\";\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","id":675,"modified_method":"private static synchronized AnnotatorPool getDefaultAnnotatorPool(final Properties inputProps) {\n    // if the pool already exists reuse!\n    if(pool == null) {\n      // first time we get here\n      pool = new AnnotatorPool();\n    }\n\n    //\n    // tokenizer: breaks text into a sequence of tokens\n    // this is required for all following annotators!\n    //\n    pool.register(STANFORD_TOKENIZE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                          \"false\"))) {\n          return new WhitespaceTokenizerAnnotator(properties);\n        } else {\n          String options = properties.getProperty(\"tokenize.options\",\n                  PTBTokenizerAnnotator.DEFAULT_OPTIONS);\n          boolean keepNewline =\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          // If the user specifies \"tokenizeNLs=false\" in tokenize.options, then this default will\n          // be overridden.\n          if (keepNewline) {\n            options = \"tokenizeNLs,\" + options;\n          }\n          return new PTBTokenizerAnnotator(false, options);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(\"tokenize.whitespace:\" +\n                properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        if (Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\",\n                \"false\"))) {\n          os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + \":\" +\n                  properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,\n                          \"false\"));\n          os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,\n                          \"false\"));\n          return os.toString();\n        } else {\n          os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                  Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                          \"false\")));\n        }\n        return os.toString();\n      }\n    });\n\n    pool.register(STANFORD_CLEAN_XML, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String xmlTags =\n          properties.getProperty(\"clean.xmltags\",\n                            CleanXmlAnnotator.DEFAULT_XML_TAGS);\n        String sentenceEndingTags =\n          properties.getProperty(\"clean.sentenceendingtags\",\n                            CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);\n        String singleSentenceTags =\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);\n        String allowFlawedString = properties.getProperty(\"clean.allowflawedxml\");\n        boolean allowFlawed = CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;\n        if (allowFlawedString != null)\n          allowFlawed = Boolean.valueOf(allowFlawedString);\n        String dateTags =\n          properties.getProperty(\"clean.datetags\",\n                            CleanXmlAnnotator.DEFAULT_DATE_TAGS);\n        String docIdTags =\n                properties.getProperty(\"clean.docIdtags\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS);\n        String docTypeTags =\n                properties.getProperty(\"clean.docTypetags\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);\n        String utteranceTurnTags =\n                properties.getProperty(\"clean.turntags\",\n                        CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);\n        String speakerTags =\n                properties.getProperty(\"clean.speakertags\",\n                        CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);\n        String docAnnotations =\n                properties.getProperty(\"clean.docAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);\n        String tokenAnnotations =\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);\n        String sectionTags =\n                properties.getProperty(\"clean.sectiontags\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_TAGS);\n        String sectionAnnotations =\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n        String ssplitDiscardTokens =\n                properties.getProperty(\"clean.ssplitDiscardTokens\");\n        CleanXmlAnnotator annotator = new CleanXmlAnnotator(xmlTags,\n            sentenceEndingTags,\n            dateTags,\n            allowFlawed);\n        annotator.setSingleSentenceTagMatcher(singleSentenceTags);\n        annotator.setDocIdTagMatcher(docIdTags);\n        annotator.setDocTypeTagMatcher(docTypeTags);\n        annotator.setDiscourseTags(utteranceTurnTags, speakerTags);\n        annotator.setDocAnnotationPatterns(docAnnotations);\n        annotator.setTokenAnnotationPatterns(tokenAnnotations);\n        annotator.setSectionTagMatcher(sectionTags);\n        annotator.setSectionAnnotationPatterns(sectionAnnotations);\n        annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);\n        return annotator;\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"clean.xmltags:\" +\n                properties.getProperty(\"clean.xmltags\",\n                  CleanXmlAnnotator.DEFAULT_XML_TAGS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.sentenceendingtags\",\n                  CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS) +\n                \"clean.sentenceendingtags:\" +\n                properties.getProperty(\"clean.singlesentencetags\",\n                        CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS) +\n                \"clean.allowflawedxml:\" +\n                properties.getProperty(\"clean.allowflawedxml\", \"\") +\n                \"clean.datetags:\" +\n                properties.getProperty(\"clean.datetags\",\n                  CleanXmlAnnotator.DEFAULT_DATE_TAGS) +\n                \"clean.docidtags:\" +\n                properties.getProperty(\"clean.docid\",\n                        CleanXmlAnnotator.DEFAULT_DOCID_TAGS) +\n                \"clean.doctypetags:\" +\n                properties.getProperty(\"clean.doctype\",\n                        CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS) +\n                \"clean.turntags:\" +\n                properties.getProperty(\"clean.turntags\",\n                  CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS) +\n                \"clean.speakertags:\" +\n                properties.getProperty(\"clean.speakertags\",\n                  CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS) +\n                \"clean.docAnnotations:\" +\n                properties.getProperty(\"clean.docAnnotations\",\n                  CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS) +\n                \"clean.tokenAnnotations:\" +\n                properties.getProperty(\"clean.tokenAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS) +\n                \"clean.sectiontags:\" +\n                properties.getProperty(\"clean.sectiontags\",\n                  CleanXmlAnnotator.DEFAULT_SECTION_TAGS) +\n                \"clean.sectionAnnotations:\" +\n                properties.getProperty(\"clean.sectionAnnotations\",\n                        CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);\n      }\n    });\n\n    //\n    // Sentence splitter: splits the above sequence of tokens into\n    // sentences.  This is required when processing entire documents or\n    // text consisting of multiple sentences.\n    //\n    pool.register(STANFORD_SSPLIT, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        boolean nlSplitting = Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (nlSplitting) {\n          boolean whitespaceTokenization = Boolean.valueOf(properties.getProperty(\"tokenize.whitespace\", \"false\"));\n          if (whitespaceTokenization) {\n            if (System.getProperty(\"line.separator\").equals(\"\\n\")) {\n              return WordsToSentencesAnnotator.newlineSplitter(false, \"\\n\");\n            } else {\n              // throw \"\\n\" in just in case files use that instead of\n              // the system separator\n              return WordsToSentencesAnnotator.newlineSplitter(false, System.getProperty(\"line.separator\"), \"\\n\");\n            }\n          } else {\n            return WordsToSentencesAnnotator.newlineSplitter(false, PTBTokenizer.getNewlineToken());\n          }\n\n        } else {\n          // Treat as one sentence: You get a no-op sentence splitter that always returns all tokens as one sentence.\n          String isOneSentence = properties.getProperty(\"ssplit.isOneSentence\");\n          if (Boolean.parseBoolean(isOneSentence)) { // this method treats null as false\n            return WordsToSentencesAnnotator.nonSplitter(false);\n          }\n\n          // multi token sentence boundaries\n          String boundaryMultiTokenRegex = properties.getProperty(\"ssplit.boundaryMultiTokenRegex\");\n\n          // Discard these tokens without marking them as sentence boundaries\n          String tokenPatternsToDiscardProp = properties.getProperty(\"ssplit.tokenPatternsToDiscard\");\n          Set<String> tokenRegexesToDiscard = null;\n          if (tokenPatternsToDiscardProp != null){\n            String [] toks = tokenPatternsToDiscardProp.split(\",\");\n            tokenRegexesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          // regular boundaries\n          String boundaryTokenRegex = properties.getProperty(\"ssplit.boundaryTokenRegex\");\n          Set<String> boundariesToDiscard = null;\n\n          // newline boundaries which are discarded.\n          String bounds = properties.getProperty(\"ssplit.boundariesToDiscard\");\n          if (bounds != null) {\n            String [] toks = bounds.split(\",\");\n            boundariesToDiscard = Generics.newHashSet(Arrays.asList(toks));\n          }\n          Set<String> htmlElementsToDiscard = null;\n          // HTML boundaries which are discarded\n          bounds = properties.getProperty(\"ssplit.htmlBoundariesToDiscard\");\n          if (bounds != null) {\n            String [] elements = bounds.split(\",\");\n            htmlElementsToDiscard = Generics.newHashSet(Arrays.asList(elements));\n          }\n          String nlsb = properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\");\n\n          return new WordsToSentencesAnnotator(false, boundaryTokenRegex, boundariesToDiscard, htmlElementsToDiscard,\n                  nlsb, boundaryMultiTokenRegex, tokenRegexesToDiscard);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        StringBuilder os = new StringBuilder();\n        os.append(NEWLINE_SPLITTER_PROPERTY + \":\" +\n                properties.getProperty(NEWLINE_SPLITTER_PROPERTY, \"false\"));\n        if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,\n                \"false\"))) {\n          os.append(\"tokenize.whitespace:\" +\n                  properties.getProperty(\"tokenize.whitespace\", \"false\"));\n        } else {\n          os.append(\"ssplit.isOneSentence:\" +\n                  properties.getProperty(\"ssplit.isOneSentence\", \"false\"));\n          if ( ! Boolean.valueOf(properties.getProperty(\"ssplit.isOneSentence\", \"false\"))) {\n            os.append(\"ssplit.boundaryTokenRegex:\" +\n                    properties.getProperty(\"ssplit.boundaryTokenRegex\", \"\"));\n            os.append(\"ssplit.boundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.boundariesToDiscard\", \"\"));\n            os.append(\"ssplit.htmlBoundariesToDiscard:\" +\n                    properties.getProperty(\"ssplit.htmlBoundariesToDiscard\", \"\"));\n            os.append(\"ssplit.newlineIsSentenceBreak:\" +\n                    properties.getProperty(\"ssplit.newlineIsSentenceBreak\", \"two\"));\n          }\n        }\n        return os.toString();\n      }\n    });\n\n    //\n    // POS tagger\n    //\n    pool.register(STANFORD_POS, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        try {\n          return new POSTaggerAnnotator(\"pos\", properties);\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return (\"pos.maxlen:\" + properties.getProperty(\"pos.maxlen\", \"\") +\n                \"pos.model:\" + properties.getProperty(\"pos.model\", DefaultPaths.DEFAULT_POS_MODEL) +\n                \"pos.nthreads:\" + properties.getProperty(\"pos.nthreads\", properties.getProperty(\"nthreads\", \"\")));\n      }\n    });\n\n    //\n    // Lemmatizer\n    //\n    pool.register(STANFORD_LEMMA, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new MorphaAnnotator(false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        // nothing for this one\n        return \"\";\n      }\n    });\n\n    //\n    // NER\n    //\n    pool.register(STANFORD_NER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        List<String> models = new ArrayList<String>();\n        String modelNames = properties.getProperty(\"ner.model\");\n        if (modelNames == null) {\n          modelNames = DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + \",\" + DefaultPaths.DEFAULT_NER_MUC_MODEL + \",\" + DefaultPaths.DEFAULT_NER_CONLL_MODEL;\n        }\n        if (modelNames.length() > 0) {\n          models.addAll(Arrays.asList(modelNames.split(\",\")));\n        }\n        if (models.isEmpty()) {\n          // Allow for no real NER model - can just use numeric classifiers or SUTime.\n          // Have to unset ner.model, so unlikely that people got here by accident.\n          System.err.println(\"WARNING: no NER models specified\");\n        }\n        NERClassifierCombiner nerCombiner;\n        try {\n          boolean applyNumericClassifiers =\n            PropertiesUtils.getBool(properties,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);\n          boolean useSUTime =\n            PropertiesUtils.getBool(properties,\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                NumberSequenceClassifier.USE_SUTIME_DEFAULT);\n          nerCombiner = new NERClassifierCombiner(applyNumericClassifiers,\n                useSUTime, properties,\n                models.toArray(new String[models.size()]));\n        } catch (FileNotFoundException e) {\n          throw new RuntimeIOException(e);\n        }\n        return new NERCombinerAnnotator(nerCombiner, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"ner.model:\" +\n                properties.getProperty(\"ner.model\", \"\") +\n                \"ner.model.3class:\" +\n                properties.getProperty(\"ner.model.3class\",\n                        DefaultPaths.DEFAULT_NER_THREECLASS_MODEL) +\n                \"ner.model.7class:\" +\n                properties.getProperty(\"ner.model.7class\",\n                        DefaultPaths.DEFAULT_NER_MUC_MODEL) +\n                \"ner.model.MISCclass:\" +\n                properties.getProperty(\"ner.model.MISCclass\",\n                        DefaultPaths.DEFAULT_NER_CONLL_MODEL) +\n                NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + \":\" +\n                properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,\n                        Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)) +\n                NumberSequenceClassifier.USE_SUTIME_PROPERTY + \":\" +\n                properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,\n                        Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));\n      }\n    });\n\n    //\n    // Regex NER\n    //\n    pool.register(STANFORD_REGEXNER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new TokensRegexNERAnnotator(\"regexner\", properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return PropertiesUtils.getSignature(\"regexner\", properties, TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);\n      }\n    });\n\n    //\n    // Gender Annotator\n    //\n    pool.register(STANFORD_GENDER, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new GenderAnnotator(false, properties.getProperty(\"gender.firstnames\", DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"gender.firstnames:\" +\n                properties.getProperty(\"gender.firstnames\",\n                        DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);\n      }\n    });\n\n\n    //\n    // True caser\n    //\n    pool.register(STANFORD_TRUECASE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return new TrueCaseAnnotator(model, bias, mixed, false);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n                properties.getProperty(\"truecase.model\",\n                        DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n                \"truecase.bias:\" +\n                properties.getProperty(\"truecase.bias\",\n                        TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n                \"truecase.mixedcasefile:\" +\n                properties.getProperty(\"truecase.mixedcasefile\",\n                        DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    });\n\n    //\n    // Parser\n    //\n    pool.register(STANFORD_PARSE, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String parserType = properties.getProperty(\"parse.type\", \"stanford\");\n        String maxLenStr = properties.getProperty(\"parse.maxlen\");\n\n        if (parserType.equalsIgnoreCase(\"stanford\")) {\n          ParserAnnotator anno = new ParserAnnotator(\"parse\", properties);\n          return anno;\n        } else if (parserType.equalsIgnoreCase(\"charniak\")) {\n          String model = properties.getProperty(\"parse.model\");\n          String parserExecutable = properties.getProperty(\"parse.executable\");\n          if (model == null || parserExecutable == null) {\n            throw new RuntimeException(\"Both parse.model and parse.executable properties must be specified if parse.type=charniak\");\n          }\n          int maxLen = 399;\n          if (maxLenStr != null) {\n            maxLen = Integer.parseInt(maxLenStr);\n          }\n\n          CharniakParserAnnotator anno = new CharniakParserAnnotator(model, parserExecutable, false, maxLen);\n\n          return anno;\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + parserType + \" (currently supported: stanford and charniak)\");\n        }\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        String type = properties.getProperty(\"parse.type\", \"stanford\");\n        if(type.equalsIgnoreCase(\"stanford\")){\n          return ParserAnnotator.signature(\"parser\", properties);\n        } else if(type.equalsIgnoreCase(\"charniak\")) {\n          return \"parse.model:\" +\n                  properties.getProperty(\"parse.model\", \"\") +\n                  \"parse.executable:\" +\n                  properties.getProperty(\"parse.executable\", \"\") +\n                  \"parse.maxlen:\" +\n                  properties.getProperty(\"parse.maxlen\", \"\");\n        } else {\n          throw new RuntimeException(\"Unknown parser type: \" + type +\n                  \" (currently supported: stanford and charniak)\");\n        }\n      }\n    });\n\n    //\n    // Coreference resolution\n    //\n    pool.register(STANFORD_DETERMINISTIC_COREF, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new DeterministicCorefAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return DeterministicCorefAnnotator.signature(properties);\n      }\n    });\n\n    // add annotators loaded via reflection from classnames specified\n    // in the properties\n    for (Object propertyKey : inputProps.stringPropertyNames()) {\n      if (!(propertyKey instanceof String))\n        continue; // should this be an Exception?\n      String property = (String) propertyKey;\n      if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {\n        final String customName =\n          property.substring(CUSTOM_ANNOTATOR_PREFIX.length());\n        final String customClassName = inputProps.getProperty(property);\n        System.err.println(\"Registering annotator \" + customName +\n            \" with class \" + customClassName);\n        pool.register(customName, new AnnotatorFactory(inputProps) {\n          private static final long serialVersionUID = 1L;\n          private final String name = customName;\n          private final String className = customClassName;\n          @Override\n          public Annotator create() {\n            return ReflectionLoading.loadByReflection(className, name,\n                                                      properties);\n          }\n          @Override\n          public String signature() {\n            // keep track of all relevant properties for this annotator here!\n            // since we don't know what props they need, let's copy all\n            // TODO: can we do better here? maybe signature() should be a method in the Annotator?\n            StringBuilder os = new StringBuilder();\n            for(Object key: properties.keySet()) {\n              String skey = (String) key;\n              os.append(skey + \":\" + properties.getProperty(skey));\n            }\n            return os.toString();\n          }\n        });\n      }\n    }\n\n\n    pool.register(STANFORD_RELATION, new AnnotatorFactory(inputProps) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return new RelationExtractorAnnotator(properties);\n      }\n\n      @Override\n      public String signature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"sup.relation.verbose:\" +\n        properties.getProperty(\"sup.relation.verbose\",\n                \"false\") +\n        properties.getProperty(\"sup.relation.model\",\n                DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);\n      }\n    });\n    \n    //\n    // add more annotators here!\n    //\n    return pool;\n  }","commit_id":"65a8fe26905112e4b26a83d6d4260ebaff7c4266","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else\n           pair.set(position, value);\n    }","id":676,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","commit_id":"0183dc0b36e684082832de43a21b3dc0a9716d48","url":"https://github.com/apache/cassandra"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else\n           pair.set(position, value);\n    }","id":677,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","commit_id":"9e6087c0138eb434e3fee769bae2cdc72b863ba5","url":"https://github.com/apache/cassandra"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else\n           pair.set(position, value);\n    }","id":678,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","commit_id":"5cdfaab72c6c8a2a9fab0d1a97fd1cdeafd6c2df","url":"https://github.com/apache/cassandra"},{"original_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else\n           pair.set(position, value);\n    }","id":679,"modified_method":"private void setTupleValue(Tuple pair, int position, Object value) throws ExecException\n    {\n       if (value instanceof BigInteger)\n           pair.set(position, ((BigInteger) value).intValue());\n       else if (value instanceof ByteBuffer)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));\n       else if (value instanceof UUID)\n           pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));\n       else if (value instanceof Date)\n           pair.set(position, new DataByteArray(ByteBufferUtil.getArray(DateType.instance.decompose((Date) value))));\n       else\n           pair.set(position, value);\n    }","commit_id":"6ba063387f3088e4e21aab20509c6d9237809ce9","url":"https://github.com/apache/cassandra"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","id":680,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _entityMgr.findById(Account.class, getId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n        \n        account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","id":681,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _entityMgr.findById(Account.class, getId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n        \n        account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","id":682,"modified_method":"@Override\n    public long getEntityOwnerId() {\n        Account account = _entityMgr.findById(Account.class, getId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n        account = _accountService.getActiveAccountByName(getAccountName(), getDomainId());\n        if (account != null) {\n            return account.getAccountId();\n        }\n\n        return Account.ACCOUNT_ID_SYSTEM; // no account info given, parent this command to SYSTEM so ERROR events are tracked\n    }","commit_id":"d98130c0610da23db2dccedd58033a647b0afeff","url":"https://github.com/apache/cloudstack"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":683,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"8d866b1e95052d1b97ade88abd36f545544d17b4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":684,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"bd2a043d5e80f1e89cd75344997e83991b93605a","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":685,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"a0d02c5506fc159ed891b6463ade845ade6db01c","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n        JettyWebServer ws = new JettyWebServer();\n        \n        HashSet<String> packages = new HashSet<String>();\n        packages.add(\"org.neo4j.server.web\");\n        ws.addPackages(packages);\n        \n        NeoServer theServer = new NeoServer(conf, \n                                            new Database(conf.configuration().getString(\"database.location\")), \n                                            ws); \n        theServer.start();\n    }","id":686,"modified_method":"public static void main(String[] args) {\n        Configurator conf = new Configurator(getConfigFile());\n\n        JettyWebServer ws = new JettyWebServer();\n        ws.setPort(conf.configuration().getInt(WEBSERVER_PORT));\n        //ws.addPackages(getPackagesToLoad(conf.configuration().getStringArray(WEBSERVICE_PACKAGES)));\n        ws.addPackages(\"org.example.coffeeshop, org.example.petshop\");\n\n        theServer = new NeoServer(conf, new Database(conf.configuration().getString(DATABASE_LOCATION)), ws);\n        theServer.start();\n    }","commit_id":"95b8d53da4dbe9962671b12df00fe2964813f8dc","url":"https://github.com/neo4j/neo4j"},{"original_method":"public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.RIGHT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( middle, 0 );\n    fdName.top = new FormAttachment( 0, margin );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.General.Label\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // SETTINGS grouping?\n    // ////////////////////////\n    // START OF SETTINGS GROUP\n    //\n\n    wSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wSettings );\n    wSettings.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Settings.Label\" ) );\n\n    FormLayout groupLayout = new FormLayout();\n    groupLayout.marginWidth = 10;\n    groupLayout.marginHeight = 10;\n    wSettings.setLayout( groupLayout );\n\n    // GPG Program\n    wlGpgExe = new Label( wSettings, SWT.RIGHT );\n    wlGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Label\" ) );\n    props.setLook( wlGpgExe );\n    fdlGpgExe = new FormData();\n    fdlGpgExe.left = new FormAttachment( 0, 0 );\n    fdlGpgExe.top = new FormAttachment( wName, margin );\n    fdlGpgExe.right = new FormAttachment( middle, -margin );\n    wlGpgExe.setLayoutData( fdlGpgExe );\n\n    // Browse Source files button ...\n    wbbGpgExe = new Button( wSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbGpgExe );\n    wbbGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    fdbbGpgExe = new FormData();\n    fdbbGpgExe.right = new FormAttachment( 100, -margin );\n    fdbbGpgExe.top = new FormAttachment( wName, margin );\n    wbbGpgExe.setLayoutData( fdbbGpgExe );\n\n    wbbGpgExe.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wGpgExe.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wGpgExe.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    wGpgExe = new TextVar( jobMeta, wSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wGpgExe.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Tooltip\" ) );\n    props.setLook( wGpgExe );\n    wGpgExe.addModifyListener( lsMod );\n    fdGpgExe = new FormData();\n    fdGpgExe.left = new FormAttachment( middle, 0 );\n    fdGpgExe.top = new FormAttachment( wName, margin );\n    fdGpgExe.right = new FormAttachment( wbbGpgExe, -margin );\n    wGpgExe.setLayoutData( fdGpgExe );\n\n    wlasciiMode = new Label( wSettings, SWT.RIGHT );\n    wlasciiMode.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Label\" ) );\n    props.setLook( wlasciiMode );\n    fdlasciiMode = new FormData();\n    fdlasciiMode.left = new FormAttachment( 0, 0 );\n    fdlasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdlasciiMode.right = new FormAttachment( middle, -margin );\n    wlasciiMode.setLayoutData( fdlasciiMode );\n    wasciiMode = new Button( wSettings, SWT.CHECK );\n    props.setLook( wasciiMode );\n    wasciiMode.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Tooltip\" ) );\n    fdasciiMode = new FormData();\n    fdasciiMode.left = new FormAttachment( middle, 0 );\n    fdasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdasciiMode.right = new FormAttachment( 100, 0 );\n    wasciiMode.setLayoutData( fdasciiMode );\n    wasciiMode.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlIncludeSubfolders = new Label( wSettings, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettings, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // previous\n    wlPrevious = new Label( wSettings, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettings, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        RefreshArgFromPrevious();\n\n      }\n    } );\n    fdSettings = new FormData();\n    fdSettings.left = new FormAttachment( 0, margin );\n    fdSettings.top = new FormAttachment( wName, margin );\n    fdSettings.right = new FormAttachment( 100, -margin );\n    wSettings.setLayoutData( fdSettings );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // SourceFileFolder line\n    wlSourceFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Label\" ) );\n    props.setLook( wlSourceFileFolder );\n    FormData fdlSourceFileFolder = new FormData();\n    fdlSourceFileFolder.left = new FormAttachment( 0, 0 );\n    fdlSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdlSourceFileFolder.right = new FormAttachment( middle, -margin );\n    wlSourceFileFolder.setLayoutData( fdlSourceFileFolder );\n\n    // Browse Source folders button ...\n    wbSourceDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceDirectory );\n    wbSourceDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbSourceDirectory = new FormData();\n    fdbSourceDirectory.right = new FormAttachment( 100, 0 );\n    fdbSourceDirectory.top = new FormAttachment( wSettings, margin );\n    wbSourceDirectory.setLayoutData( fdbSourceDirectory );\n\n    wbSourceDirectory.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wSourceFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wSourceFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Source files button ...\n    wbSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceFileFolder );\n    wbSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbSourceFileFolder = new FormData();\n    fdbSourceFileFolder.right = new FormAttachment( wbSourceDirectory, -margin );\n    fdbSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbSourceFileFolder.setLayoutData( fdbSourceFileFolder );\n\n    // Browse Destination file add button ...\n    wbaSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbaSourceFileFolder );\n    wbaSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameAdd.Button\" ) );\n    fdbaSourceFileFolder = new FormData();\n    fdbaSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -margin );\n    fdbaSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbaSourceFileFolder.setLayoutData( fdbaSourceFileFolder );\n\n    wSourceFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Tooltip\" ) );\n\n    props.setLook( wSourceFileFolder );\n    wSourceFileFolder.addModifyListener( lsMod );\n    FormData fdSourceFileFolder = new FormData();\n    fdSourceFileFolder.left = new FormAttachment( middle, 0 );\n    fdSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wSourceFileFolder.setLayoutData( fdSourceFileFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wSourceFileFolder.addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        wSourceFileFolder.setToolTipText( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n      }\n    } );\n\n    wbSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wSourceFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Destination\n    wlDestinationFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlDestinationFileFolder.setText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Label\" ) );\n    props.setLook( wlDestinationFileFolder );\n    fdlDestinationFileFolder = new FormData();\n    fdlDestinationFileFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdlDestinationFileFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFileFolder.setLayoutData( fdlDestinationFileFolder );\n\n    // Browse Destination folders button ...\n    wbDestinationDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationDirectory );\n    wbDestinationDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbDestinationDirectory = new FormData();\n    fdbDestinationDirectory.right = new FormAttachment( 100, 0 );\n    fdbDestinationDirectory.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationDirectory.setLayoutData( fdbDestinationDirectory );\n\n    wbDestinationDirectory.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wDestinationFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Destination file browse button ...\n    wbDestinationFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFileFolder );\n    wbDestinationFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbDestinationFileFolder = new FormData();\n    fdbDestinationFileFolder.right = new FormAttachment( wbDestinationDirectory, -margin );\n    fdbDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationFileFolder.setLayoutData( fdbDestinationFileFolder );\n\n    wDestinationFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wDestinationFileFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Tooltip\" ) );\n    props.setLook( wDestinationFileFolder );\n    wDestinationFileFolder.addModifyListener( lsMod );\n    fdDestinationFileFolder = new FormData();\n    fdDestinationFileFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdDestinationFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wDestinationFileFolder.setLayoutData( fdDestinationFileFolder );\n\n    wbDestinationFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wDestinationFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wDestinationFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Buttons to the right of the screen...\n    wbdSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbdSourceFileFolder );\n    wbdSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Button\" ) );\n    wbdSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Tooltip\" ) );\n    fdbdSourceFileFolder = new FormData();\n    fdbdSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbdSourceFileFolder.top = new FormAttachment( wDestinationFileFolder, 40 );\n    wbdSourceFileFolder.setLayoutData( fdbdSourceFileFolder );\n\n    wbeSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbeSourceFileFolder );\n    wbeSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Button\" ) );\n    wbeSourceFileFolder.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Tooltip\" ) );\n    fdbeSourceFileFolder = new FormData();\n    fdbeSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbeSourceFileFolder.left = new FormAttachment( wbdSourceFileFolder, 0, SWT.LEFT );\n    fdbeSourceFileFolder.top = new FormAttachment( wbdSourceFileFolder, margin );\n    wbeSourceFileFolder.setLayoutData( fdbeSourceFileFolder );\n\n    // Wildcard\n    wlWildcard = new Label( wGeneralComp, SWT.RIGHT );\n    wlWildcard.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Label\" ) );\n    props.setLook( wlWildcard );\n    fdlWildcard = new FormData();\n    fdlWildcard.left = new FormAttachment( 0, 0 );\n    fdlWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdlWildcard.right = new FormAttachment( middle, -margin );\n    wlWildcard.setLayoutData( fdlWildcard );\n\n    wWildcard = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wWildcard.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Tooltip\" ) );\n    props.setLook( wWildcard );\n    wWildcard.addModifyListener( lsMod );\n    fdWildcard = new FormData();\n    fdWildcard.left = new FormAttachment( middle, 0 );\n    fdWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdWildcard.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wWildcard.setLayoutData( fdWildcard );\n\n    wlFields = new Label( wGeneralComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wWildcard, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Action.Label\" ),\n          ColumnInfo.COLUMN_TYPE_CCOMBO, JobEntryPGPEncryptFiles.actionTypeDesc, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[0].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Tooltip\" ) );\n\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Tooltip\" ) );\n    colinf[3].setUsingVariables( true );\n    colinf[3]\n      .setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n\n    wFields =\n      new TableView(\n        jobMeta, wGeneralComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( wbeSourceFileFolder, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    RefreshArgFromPrevious();\n\n    // Add the file to the list of files...\n    SelectionAdapter selA = new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        wFields.add( new String[] {\n          JobEntryPGPEncryptFiles.actionTypeDesc[0], wSourceFileFolder.getText(), wWildcard.getText(), null,\n          wDestinationFileFolder.getText() } );\n        wSourceFileFolder.setText( \"\" );\n        wDestinationFileFolder.setText( \"\" );\n        wWildcard.setText( \"\" );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n        wFields.optWidth( true );\n      }\n    };\n    wbaSourceFileFolder.addSelectionListener( selA );\n    wSourceFileFolder.addSelectionListener( selA );\n\n    // Delete files from the list of files...\n    wbdSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    // Edit the selected file & remove from the list...\n    wbeSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int idx = wFields.getSelectionIndex();\n        if ( idx >= 0 ) {\n          String[] string = wFields.getItem( idx );\n          wSourceFileFolder.setText( string[0] );\n          wDestinationFileFolder.setText( string[1] );\n          wWildcard.setText( string[2] );\n          wFields.remove( idx );\n        }\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n    props.setLook( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF DESTINATION FILE TAB ///\n    // ///////////////////////////////////\n\n    wDestinationFileTab = new CTabItem( wTabFolder, SWT.NONE );\n    wDestinationFileTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFileTab.Label\" ) );\n\n    FormLayout DestcontentLayout = new FormLayout();\n    DestcontentLayout.marginWidth = 3;\n    DestcontentLayout.marginHeight = 3;\n\n    wDestinationFileComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wDestinationFileComp );\n    wDestinationFileComp.setLayout( DestcontentLayout );\n\n    // DestinationFile grouping?\n    // ////////////////////////\n    // START OF DestinationFile GROUP\n    //\n\n    wDestinationFile = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wDestinationFile );\n    wDestinationFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupDestinationFile.Label\" ) );\n\n    FormLayout groupLayoutFile = new FormLayout();\n    groupLayoutFile.marginWidth = 10;\n    groupLayoutFile.marginHeight = 10;\n    wDestinationFile.setLayout( groupLayoutFile );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wDestinationFile, SWT.RIGHT );\n    wlCreateDestinationFolder.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wDestinationFile, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Do not keep folder structure?\n    wlDoNotKeepFolderStructure = new Label( wDestinationFile, SWT.RIGHT );\n    wlDoNotKeepFolderStructure.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Label\" ) );\n    props.setLook( wlDoNotKeepFolderStructure );\n    fdlDoNotKeepFolderStructure = new FormData();\n    fdlDoNotKeepFolderStructure.left = new FormAttachment( 0, 0 );\n    fdlDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlDoNotKeepFolderStructure.right = new FormAttachment( middle, -margin );\n    wlDoNotKeepFolderStructure.setLayoutData( fdlDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Tooltip\" ) );\n    fdDoNotKeepFolderStructure = new FormData();\n    fdDoNotKeepFolderStructure.left = new FormAttachment( middle, 0 );\n    fdDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdDoNotKeepFolderStructure.right = new FormAttachment( 100, 0 );\n    wDoNotKeepFolderStructure.setLayoutData( fdDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddDate = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Label\" ) );\n    props.setLook( wlAddDate );\n    fdlAddDate = new FormData();\n    fdlAddDate.left = new FormAttachment( 0, 0 );\n    fdlAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdlAddDate.right = new FormAttachment( middle, -margin );\n    wlAddDate.setLayoutData( fdlAddDate );\n    wAddDate = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDate );\n    wAddDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Tooltip\" ) );\n    fdAddDate = new FormData();\n    fdAddDate.left = new FormAttachment( middle, 0 );\n    fdAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdAddDate.right = new FormAttachment( 100, 0 );\n    wAddDate.setLayoutData( fdAddDate );\n    wAddDate.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddTime = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Label\" ) );\n    props.setLook( wlAddTime );\n    fdlAddTime = new FormData();\n    fdlAddTime.left = new FormAttachment( 0, 0 );\n    fdlAddTime.top = new FormAttachment( wAddDate, margin );\n    fdlAddTime.right = new FormAttachment( middle, -margin );\n    wlAddTime.setLayoutData( fdlAddTime );\n    wAddTime = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddTime );\n    wAddTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Tooltip\" ) );\n    fdAddTime = new FormData();\n    fdAddTime.left = new FormAttachment( middle, 0 );\n    fdAddTime.top = new FormAttachment( wAddDate, margin );\n    fdAddTime.right = new FormAttachment( 100, 0 );\n    wAddTime.setLayoutData( fdAddTime );\n    wAddTime.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlSpecifyFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Label\" ) );\n    props.setLook( wlSpecifyFormat );\n    fdlSpecifyFormat = new FormData();\n    fdlSpecifyFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdlSpecifyFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyFormat.setLayoutData( fdlSpecifyFormat );\n    wSpecifyFormat = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wSpecifyFormat );\n    wSpecifyFormat.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Tooltip\" ) );\n    fdSpecifyFormat = new FormData();\n    fdSpecifyFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdSpecifyFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyFormat.setLayoutData( fdSpecifyFormat );\n    wSpecifyFormat.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setDateTimeFormat();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // DateTimeFormat\n    wlDateTimeFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DateTimeFormat.Label\" ) );\n    props.setLook( wlDateTimeFormat );\n    fdlDateTimeFormat = new FormData();\n    fdlDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdlDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlDateTimeFormat.setLayoutData( fdlDateTimeFormat );\n    wDateTimeFormat = new CCombo( wDestinationFile, SWT.BORDER | SWT.READ_ONLY );\n    wDateTimeFormat.setEditable( true );\n    props.setLook( wDateTimeFormat );\n    wDateTimeFormat.addModifyListener( lsMod );\n    fdDateTimeFormat = new FormData();\n    fdDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wDateTimeFormat.setLayoutData( fdDateTimeFormat );\n    // Prepare a list of possible DateTimeFormats...\n    String[] dats = Const.getDateFormats();\n    for ( int x = 0; x < dats.length; x++ ) {\n      wDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddDateBeforeExtension = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddDateBeforeExtension );\n    fdlAddDateBeforeExtension = new FormData();\n    fdlAddDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdlAddDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddDateBeforeExtension.setLayoutData( fdlAddDateBeforeExtension );\n    wAddDateBeforeExtension = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDateBeforeExtension );\n    wAddDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Tooltip\" ) );\n    fdAddDateBeforeExtension = new FormData();\n    fdAddDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdAddDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddDateBeforeExtension.setLayoutData( fdAddDateBeforeExtension );\n    wAddDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If File Exists\n    wlIfFileExists = new Label( wDestinationFile, SWT.RIGHT );\n    wlIfFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfFileExists.Label\" ) );\n    props.setLook( wlIfFileExists );\n    fdlIfFileExists = new FormData();\n    fdlIfFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    wlIfFileExists.setLayoutData( fdlIfFileExists );\n    wIfFileExists = new CCombo( wDestinationFile, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Overwrite_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Unique_Name_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Delete_Source_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Move_To_Folder_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfFileExists.Label\" ) );\n    wIfFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfFileExists );\n    fdIfFileExists = new FormData();\n    fdIfFileExists.left = new FormAttachment( middle, 0 );\n    fdIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdIfFileExists.right = new FormAttachment( 100, 0 );\n    wIfFileExists.setLayoutData( fdIfFileExists );\n\n    wIfFileExists.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        activeDestinationFolder();\n        setMovedDateTimeFormat();\n        // setAddDateBeforeExtension();\n        setAddMovedDateBeforeExtension();\n\n      }\n    } );\n\n    fdDestinationFile = new FormData();\n    fdDestinationFile.left = new FormAttachment( 0, margin );\n    fdDestinationFile.top = new FormAttachment( wName, margin );\n    fdDestinationFile.right = new FormAttachment( 100, -margin );\n    wDestinationFile.setLayoutData( fdDestinationFile );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DestinationFile GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // MoveTo grouping?\n    // ////////////////////////\n    // START OF MoveTo GROUP\n    //\n\n    wMoveToGroup = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wMoveToGroup );\n    wMoveToGroup.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupMoveToGroup.Label\" ) );\n\n    FormLayout MovetoLayoutFile = new FormLayout();\n    MovetoLayoutFile.marginWidth = 10;\n    MovetoLayoutFile.marginHeight = 10;\n    wMoveToGroup.setLayout( MovetoLayoutFile );\n\n    // DestinationFolder line\n    wlDestinationFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlDestinationFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFolder.Label\" ) );\n    props.setLook( wlDestinationFolder );\n    fdlDestinationFolder = new FormData();\n    fdlDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdlDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFolder.setLayoutData( fdlDestinationFolder );\n\n    wbDestinationFolder = new Button( wMoveToGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFolder );\n    wbDestinationFolder.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbDestinationFolder = new FormData();\n    fdbDestinationFolder.right = new FormAttachment( 100, 0 );\n    fdbDestinationFolder.top = new FormAttachment( wDestinationFile, 0 );\n    wbDestinationFolder.setLayoutData( fdbDestinationFolder );\n\n    wDestinationFolder = new TextVar( jobMeta, wMoveToGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wDestinationFolder );\n    wDestinationFolder.addModifyListener( lsMod );\n    fdDestinationFolder = new FormData();\n    fdDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdDestinationFolder.right = new FormAttachment( wbDestinationFolder, -margin );\n    wDestinationFolder.setLayoutData( fdDestinationFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wDestinationFolder.addModifyListener( new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        wDestinationFolder.setToolTipText( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n      }\n    } );\n\n    wbDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog dialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFolder.getText() != null ) {\n          dialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n        }\n\n        String dir = dialog.open();\n        if ( dir != null ) {\n          wDestinationFolder.setText( dir );\n        }\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateMoveToFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlCreateMoveToFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Label\" ) );\n    props.setLook( wlCreateMoveToFolder );\n    fdlCreateMoveToFolder = new FormData();\n    fdlCreateMoveToFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdlCreateMoveToFolder.right = new FormAttachment( middle, -margin );\n    wlCreateMoveToFolder.setLayoutData( fdlCreateMoveToFolder );\n    wCreateMoveToFolder = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wCreateMoveToFolder );\n    wCreateMoveToFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Tooltip\" ) );\n    fdCreateMoveToFolder = new FormData();\n    fdCreateMoveToFolder.left = new FormAttachment( middle, 0 );\n    fdCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdCreateMoveToFolder.right = new FormAttachment( 100, 0 );\n    wCreateMoveToFolder.setLayoutData( fdCreateMoveToFolder );\n    wCreateMoveToFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddMovedDate = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Label\" ) );\n    props.setLook( wlAddMovedDate );\n    fdlAddMovedDate = new FormData();\n    fdlAddMovedDate.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdlAddMovedDate.right = new FormAttachment( middle, -margin );\n    wlAddMovedDate.setLayoutData( fdlAddMovedDate );\n    wAddMovedDate = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDate );\n    wAddMovedDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Tooltip\" ) );\n    fdAddMovedDate = new FormData();\n    fdAddMovedDate.left = new FormAttachment( middle, 0 );\n    fdAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdAddMovedDate.right = new FormAttachment( 100, 0 );\n    wAddMovedDate.setLayoutData( fdAddMovedDate );\n    wAddMovedDate.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddMovedTime = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Label\" ) );\n    props.setLook( wlAddMovedTime );\n    fdlAddMovedTime = new FormData();\n    fdlAddMovedTime.left = new FormAttachment( 0, 0 );\n    fdlAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdlAddMovedTime.right = new FormAttachment( middle, -margin );\n    wlAddMovedTime.setLayoutData( fdlAddMovedTime );\n    wAddMovedTime = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedTime );\n    wAddMovedTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Tooltip\" ) );\n    fdAddMovedTime = new FormData();\n    fdAddMovedTime.left = new FormAttachment( middle, 0 );\n    fdAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdAddMovedTime.right = new FormAttachment( 100, 0 );\n    wAddMovedTime.setLayoutData( fdAddMovedTime );\n    wAddMovedTime.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyMoveFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlSpecifyMoveFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Label\" ) );\n    props.setLook( wlSpecifyMoveFormat );\n    fdlSpecifyMoveFormat = new FormData();\n    fdlSpecifyMoveFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdlSpecifyMoveFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyMoveFormat.setLayoutData( fdlSpecifyMoveFormat );\n    wSpecifyMoveFormat = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wSpecifyMoveFormat );\n    wSpecifyMoveFormat.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Tooltip\" ) );\n    fdSpecifyMoveFormat = new FormData();\n    fdSpecifyMoveFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdSpecifyMoveFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyMoveFormat.setLayoutData( fdSpecifyMoveFormat );\n    wSpecifyMoveFormat.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setMovedDateTimeFormat();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Moved DateTimeFormat\n    wlMovedDateTimeFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlMovedDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.MovedDateTimeFormat.Label\" ) );\n    props.setLook( wlMovedDateTimeFormat );\n    fdlMovedDateTimeFormat = new FormData();\n    fdlMovedDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdlMovedDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlMovedDateTimeFormat.setLayoutData( fdlMovedDateTimeFormat );\n    wMovedDateTimeFormat = new CCombo( wMoveToGroup, SWT.BORDER | SWT.READ_ONLY );\n    wMovedDateTimeFormat.setEditable( true );\n    props.setLook( wMovedDateTimeFormat );\n    wMovedDateTimeFormat.addModifyListener( lsMod );\n    fdMovedDateTimeFormat = new FormData();\n    fdMovedDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdMovedDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wMovedDateTimeFormat.setLayoutData( fdMovedDateTimeFormat );\n\n    for ( int x = 0; x < dats.length; x++ ) {\n      wMovedDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddMovedDateBeforeExtension = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddMovedDateBeforeExtension );\n    fdlAddMovedDateBeforeExtension = new FormData();\n    fdlAddMovedDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdlAddMovedDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddMovedDateBeforeExtension.setLayoutData( fdlAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Tooltip\" ) );\n    fdAddMovedDateBeforeExtension = new FormData();\n    fdAddMovedDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdAddMovedDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddMovedDateBeforeExtension.setLayoutData( fdAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If moved File Exists\n    wlIfMovedFileExists = new Label( wMoveToGroup, SWT.RIGHT );\n    wlIfMovedFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfMovedFileExists.Label\" ) );\n    props.setLook( wlIfMovedFileExists );\n    fdlIfMovedFileExists = new FormData();\n    fdlIfMovedFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfMovedFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    wlIfMovedFileExists.setLayoutData( fdlIfMovedFileExists );\n    wIfMovedFileExists = new CCombo( wMoveToGroup, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.Overwrite_Filename_IffMovedFileExists.Label\" ) );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.UniqueName_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfMovedFileExists );\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdMoveToGroup = new FormData();\n    fdMoveToGroup.left = new FormAttachment( 0, margin );\n    fdMoveToGroup.top = new FormAttachment( wDestinationFile, margin );\n    fdMoveToGroup.right = new FormAttachment( 100, -margin );\n    wMoveToGroup.setLayoutData( fdMoveToGroup );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF MoveToGroup GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdDestinationFileComp = new FormData();\n    fdDestinationFileComp.left = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.top = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.right = new FormAttachment( 100, 0 );\n    fdDestinationFileComp.bottom = new FormAttachment( 100, 0 );\n    wDestinationFileComp.setLayoutData( wDestinationFileComp );\n\n    wDestinationFileComp.layout();\n    wDestinationFileTab.setControl( wDestinationFileComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DESTINATION FILETAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF ADVANCED TAB ///\n    // ///////////////////////////////////\n\n    wAdvancedTab = new CTabItem( wTabFolder, SWT.NONE );\n    wAdvancedTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.Advanced.Label\" ) );\n\n    FormLayout contentLayout = new FormLayout();\n    contentLayout.marginWidth = 3;\n    contentLayout.marginHeight = 3;\n\n    wAdvancedComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wAdvancedComp );\n    wAdvancedComp.setLayout( contentLayout );\n\n    // SuccessOngrouping?\n    // ////////////////////////\n    // START OF SUCCESS ON GROUP///\n    // /\n    wSuccessOn = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wSuccessOn );\n    wSuccessOn.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessOn.Group.Label\" ) );\n\n    FormLayout successongroupLayout = new FormLayout();\n    successongroupLayout.marginWidth = 10;\n    successongroupLayout.marginHeight = 10;\n\n    wSuccessOn.setLayout( successongroupLayout );\n\n    // Success Condition\n    wlSuccessCondition = new Label( wSuccessOn, SWT.RIGHT );\n    wlSuccessCondition.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessCondition.Label\" ) );\n    props.setLook( wlSuccessCondition );\n    fdlSuccessCondition = new FormData();\n    fdlSuccessCondition.left = new FormAttachment( 0, 0 );\n    fdlSuccessCondition.right = new FormAttachment( middle, 0 );\n    fdlSuccessCondition.top = new FormAttachment( 0, margin );\n    wlSuccessCondition.setLayoutData( fdlSuccessCondition );\n    wSuccessCondition = new CCombo( wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAllWorksFine.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAtLeat.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenErrorsLessThan.Label\" ) );\n\n    wSuccessCondition.select( 0 ); // +1: starts at -1\n\n    props.setLook( wSuccessCondition );\n    fdSuccessCondition = new FormData();\n    fdSuccessCondition.left = new FormAttachment( middle, 0 );\n    fdSuccessCondition.top = new FormAttachment( 0, margin );\n    fdSuccessCondition.right = new FormAttachment( 100, 0 );\n    wSuccessCondition.setLayoutData( fdSuccessCondition );\n    wSuccessCondition.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        activeSuccessCondition();\n\n      }\n    } );\n\n    // Success when number of errors less than\n    wlNrErrorsLessThan = new Label( wSuccessOn, SWT.RIGHT );\n    wlNrErrorsLessThan.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Label\" ) );\n    props.setLook( wlNrErrorsLessThan );\n    fdlNrErrorsLessThan = new FormData();\n    fdlNrErrorsLessThan.left = new FormAttachment( 0, 0 );\n    fdlNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdlNrErrorsLessThan.right = new FormAttachment( middle, -margin );\n    wlNrErrorsLessThan.setLayoutData( fdlNrErrorsLessThan );\n\n    wNrErrorsLessThan =\n      new TextVar( jobMeta, wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Tooltip\" ) );\n    props.setLook( wNrErrorsLessThan );\n    wNrErrorsLessThan.addModifyListener( lsMod );\n    fdNrErrorsLessThan = new FormData();\n    fdNrErrorsLessThan.left = new FormAttachment( middle, 0 );\n    fdNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdNrErrorsLessThan.right = new FormAttachment( 100, -margin );\n    wNrErrorsLessThan.setLayoutData( fdNrErrorsLessThan );\n\n    fdSuccessOn = new FormData();\n    fdSuccessOn.left = new FormAttachment( 0, margin );\n    fdSuccessOn.top = new FormAttachment( wDestinationFile, margin );\n    fdSuccessOn.right = new FormAttachment( 100, -margin );\n    wSuccessOn.setLayoutData( fdSuccessOn );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Success ON GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // fileresult grouping?\n    // ////////////////////////\n    // START OF LOGGING GROUP///\n    // /\n    wFileResult = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wFileResult );\n    wFileResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FileResult.Group.Label\" ) );\n\n    FormLayout fileresultgroupLayout = new FormLayout();\n    fileresultgroupLayout.marginWidth = 10;\n    fileresultgroupLayout.marginHeight = 10;\n\n    wFileResult.setLayout( fileresultgroupLayout );\n\n    // Add file to result\n    wlAddFileToResult = new Label( wFileResult, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wFileResult, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    fdFileResult = new FormData();\n    fdFileResult.left = new FormAttachment( 0, margin );\n    fdFileResult.top = new FormAttachment( wSuccessOn, margin );\n    fdFileResult.right = new FormAttachment( 100, -margin );\n    wFileResult.setLayoutData( fdFileResult );\n    // ///////////////////////////////////////////////////////////\n    // / END OF FilesResult GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdAdvancedComp = new FormData();\n    fdAdvancedComp.left = new FormAttachment( 0, 0 );\n    fdAdvancedComp.top = new FormAttachment( 0, 0 );\n    fdAdvancedComp.right = new FormAttachment( 100, 0 );\n    fdAdvancedComp.bottom = new FormAttachment( 100, 0 );\n    wAdvancedComp.setLayoutData( wAdvancedComp );\n\n    wAdvancedComp.layout();\n    wAdvancedTab.setControl( wAdvancedComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF ADVANCED TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wSourceFileFolder.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    activeSuccessCondition();\n    setDateTimeFormat();\n    activeSuccessCondition();\n\n    activeDestinationFolder();\n    setMovedDateTimeFormat();\n    setAddDateBeforeExtension();\n    setAddMovedDateBeforeExtension();\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","id":687,"modified_method":"@Override\n  public JobEntryInterface open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      @Override\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.RIGHT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( middle, 0 );\n    fdName.top = new FormAttachment( 0, margin );\n    fdName.right = new FormAttachment( 100, 0 );\n    wName.setLayoutData( fdName );\n\n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    // ////////////////////////\n    // START OF GENERAL TAB ///\n    // ////////////////////////\n\n    wGeneralTab = new CTabItem( wTabFolder, SWT.NONE );\n    wGeneralTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.General.Label\" ) );\n\n    wGeneralComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wGeneralComp );\n\n    FormLayout generalLayout = new FormLayout();\n    generalLayout.marginWidth = 3;\n    generalLayout.marginHeight = 3;\n    wGeneralComp.setLayout( generalLayout );\n\n    // SETTINGS grouping?\n    // ////////////////////////\n    // START OF SETTINGS GROUP\n    //\n\n    wSettings = new Group( wGeneralComp, SWT.SHADOW_NONE );\n    props.setLook( wSettings );\n    wSettings.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Settings.Label\" ) );\n\n    FormLayout groupLayout = new FormLayout();\n    groupLayout.marginWidth = 10;\n    groupLayout.marginHeight = 10;\n    wSettings.setLayout( groupLayout );\n\n    // GPG Program\n    wlGpgExe = new Label( wSettings, SWT.RIGHT );\n    wlGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Label\" ) );\n    props.setLook( wlGpgExe );\n    fdlGpgExe = new FormData();\n    fdlGpgExe.left = new FormAttachment( 0, 0 );\n    fdlGpgExe.top = new FormAttachment( wName, margin );\n    fdlGpgExe.right = new FormAttachment( middle, -margin );\n    wlGpgExe.setLayoutData( fdlGpgExe );\n\n    // Browse Source files button ...\n    wbbGpgExe = new Button( wSettings, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbbGpgExe );\n    wbbGpgExe.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    fdbbGpgExe = new FormData();\n    fdbbGpgExe.right = new FormAttachment( 100, -margin );\n    fdbbGpgExe.top = new FormAttachment( wName, margin );\n    wbbGpgExe.setLayoutData( fdbbGpgExe );\n\n    wbbGpgExe.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wGpgExe.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wGpgExe.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    wGpgExe = new TextVar( jobMeta, wSettings, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wGpgExe.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GpgExe.Tooltip\" ) );\n    props.setLook( wGpgExe );\n    wGpgExe.addModifyListener( lsMod );\n    fdGpgExe = new FormData();\n    fdGpgExe.left = new FormAttachment( middle, 0 );\n    fdGpgExe.top = new FormAttachment( wName, margin );\n    fdGpgExe.right = new FormAttachment( wbbGpgExe, -margin );\n    wGpgExe.setLayoutData( fdGpgExe );\n\n    wlasciiMode = new Label( wSettings, SWT.RIGHT );\n    wlasciiMode.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Label\" ) );\n    props.setLook( wlasciiMode );\n    fdlasciiMode = new FormData();\n    fdlasciiMode.left = new FormAttachment( 0, 0 );\n    fdlasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdlasciiMode.right = new FormAttachment( middle, -margin );\n    wlasciiMode.setLayoutData( fdlasciiMode );\n    wasciiMode = new Button( wSettings, SWT.CHECK );\n    props.setLook( wasciiMode );\n    wasciiMode.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.asciiMode.Tooltip\" ) );\n    fdasciiMode = new FormData();\n    fdasciiMode.left = new FormAttachment( middle, 0 );\n    fdasciiMode.top = new FormAttachment( wGpgExe, margin );\n    fdasciiMode.right = new FormAttachment( 100, 0 );\n    wasciiMode.setLayoutData( fdasciiMode );\n    wasciiMode.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlIncludeSubfolders = new Label( wSettings, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettings, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wasciiMode, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // previous\n    wlPrevious = new Label( wSettings, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettings, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n\n        RefreshArgFromPrevious();\n\n      }\n    } );\n    fdSettings = new FormData();\n    fdSettings.left = new FormAttachment( 0, margin );\n    fdSettings.top = new FormAttachment( wName, margin );\n    fdSettings.right = new FormAttachment( 100, -margin );\n    wSettings.setLayoutData( fdSettings );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // SourceFileFolder line\n    wlSourceFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Label\" ) );\n    props.setLook( wlSourceFileFolder );\n    FormData fdlSourceFileFolder = new FormData();\n    fdlSourceFileFolder.left = new FormAttachment( 0, 0 );\n    fdlSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdlSourceFileFolder.right = new FormAttachment( middle, -margin );\n    wlSourceFileFolder.setLayoutData( fdlSourceFileFolder );\n\n    // Browse Source folders button ...\n    wbSourceDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceDirectory );\n    wbSourceDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbSourceDirectory = new FormData();\n    fdbSourceDirectory.right = new FormAttachment( 100, 0 );\n    fdbSourceDirectory.top = new FormAttachment( wSettings, margin );\n    wbSourceDirectory.setLayoutData( fdbSourceDirectory );\n\n    wbSourceDirectory.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wSourceFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wSourceFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Source files button ...\n    wbSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbSourceFileFolder );\n    wbSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbSourceFileFolder = new FormData();\n    fdbSourceFileFolder.right = new FormAttachment( wbSourceDirectory, -margin );\n    fdbSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbSourceFileFolder.setLayoutData( fdbSourceFileFolder );\n\n    // Browse Destination file add button ...\n    wbaSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbaSourceFileFolder );\n    wbaSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameAdd.Button\" ) );\n    fdbaSourceFileFolder = new FormData();\n    fdbaSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -margin );\n    fdbaSourceFileFolder.top = new FormAttachment( wSettings, margin );\n    wbaSourceFileFolder.setLayoutData( fdbaSourceFileFolder );\n\n    wSourceFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SourceFileFolder.Tooltip\" ) );\n\n    props.setLook( wSourceFileFolder );\n    wSourceFileFolder.addModifyListener( lsMod );\n    FormData fdSourceFileFolder = new FormData();\n    fdSourceFileFolder.left = new FormAttachment( middle, 0 );\n    fdSourceFileFolder.top = new FormAttachment( wSettings, 2 * margin );\n    fdSourceFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wSourceFileFolder.setLayoutData( fdSourceFileFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wSourceFileFolder.addModifyListener( new ModifyListener() {\n      @Override\n      public void modifyText( ModifyEvent e ) {\n        wSourceFileFolder.setToolTipText( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n      }\n    } );\n\n    wbSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wSourceFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wSourceFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wSourceFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Destination\n    wlDestinationFileFolder = new Label( wGeneralComp, SWT.RIGHT );\n    wlDestinationFileFolder.setText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Label\" ) );\n    props.setLook( wlDestinationFileFolder );\n    fdlDestinationFileFolder = new FormData();\n    fdlDestinationFileFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdlDestinationFileFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFileFolder.setLayoutData( fdlDestinationFileFolder );\n\n    // Browse Destination folders button ...\n    wbDestinationDirectory = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationDirectory );\n    wbDestinationDirectory.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFolders.Label\" ) );\n    FormData fdbDestinationDirectory = new FormData();\n    fdbDestinationDirectory.right = new FormAttachment( 100, 0 );\n    fdbDestinationDirectory.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationDirectory.setLayoutData( fdbDestinationDirectory );\n\n    wbDestinationDirectory.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog ddialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFileFolder.getText() != null ) {\n          ddialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n\n        // Calling open() will open and run the dialog.\n        // It will return the selected directory, or\n        // null if user cancels\n        String dir = ddialog.open();\n        if ( dir != null ) {\n          // Set the text box to the new selection\n          wDestinationFileFolder.setText( dir );\n        }\n\n      }\n    } );\n\n    // Browse Destination file browse button ...\n    wbDestinationFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFileFolder );\n    wbDestinationFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.BrowseFiles.Label\" ) );\n    FormData fdbDestinationFileFolder = new FormData();\n    fdbDestinationFileFolder.right = new FormAttachment( wbDestinationDirectory, -margin );\n    fdbDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    wbDestinationFileFolder.setLayoutData( fdbDestinationFileFolder );\n\n    wDestinationFileFolder = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wDestinationFileFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationFileFolder.Tooltip\" ) );\n    props.setLook( wDestinationFileFolder );\n    wDestinationFileFolder.addModifyListener( lsMod );\n    fdDestinationFileFolder = new FormData();\n    fdDestinationFileFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFileFolder.top = new FormAttachment( wSourceFileFolder, margin );\n    fdDestinationFileFolder.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wDestinationFileFolder.setLayoutData( fdDestinationFileFolder );\n\n    wbDestinationFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        FileDialog dialog = new FileDialog( shell, SWT.OPEN );\n        dialog.setFilterExtensions( new String[] { \"*\" } );\n        if ( wDestinationFileFolder.getText() != null ) {\n          dialog.setFileName( jobMeta.environmentSubstitute( wDestinationFileFolder.getText() ) );\n        }\n        dialog.setFilterNames( FILETYPES );\n        if ( dialog.open() != null ) {\n          wDestinationFileFolder.setText( dialog.getFilterPath() + Const.FILE_SEPARATOR + dialog.getFileName() );\n        }\n      }\n    } );\n\n    // Buttons to the right of the screen...\n    wbdSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbdSourceFileFolder );\n    wbdSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Button\" ) );\n    wbdSourceFileFolder\n      .setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameDelete.Tooltip\" ) );\n    fdbdSourceFileFolder = new FormData();\n    fdbdSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbdSourceFileFolder.top = new FormAttachment( wDestinationFileFolder, 40 );\n    wbdSourceFileFolder.setLayoutData( fdbdSourceFileFolder );\n\n    wbeSourceFileFolder = new Button( wGeneralComp, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbeSourceFileFolder );\n    wbeSourceFileFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Button\" ) );\n    wbeSourceFileFolder.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FilenameEdit.Tooltip\" ) );\n    fdbeSourceFileFolder = new FormData();\n    fdbeSourceFileFolder.right = new FormAttachment( 100, 0 );\n    fdbeSourceFileFolder.left = new FormAttachment( wbdSourceFileFolder, 0, SWT.LEFT );\n    fdbeSourceFileFolder.top = new FormAttachment( wbdSourceFileFolder, margin );\n    wbeSourceFileFolder.setLayoutData( fdbeSourceFileFolder );\n\n    // Wildcard\n    wlWildcard = new Label( wGeneralComp, SWT.RIGHT );\n    wlWildcard.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Label\" ) );\n    props.setLook( wlWildcard );\n    fdlWildcard = new FormData();\n    fdlWildcard.left = new FormAttachment( 0, 0 );\n    fdlWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdlWildcard.right = new FormAttachment( middle, -margin );\n    wlWildcard.setLayoutData( fdlWildcard );\n\n    wWildcard = new TextVar( jobMeta, wGeneralComp, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wWildcard.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Wildcard.Tooltip\" ) );\n    props.setLook( wWildcard );\n    wWildcard.addModifyListener( lsMod );\n    fdWildcard = new FormData();\n    fdWildcard.left = new FormAttachment( middle, 0 );\n    fdWildcard.top = new FormAttachment( wDestinationFileFolder, margin );\n    fdWildcard.right = new FormAttachment( wbSourceFileFolder, -55 );\n    wWildcard.setLayoutData( fdWildcard );\n\n    wlFields = new Label( wGeneralComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wWildcard, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Action.Label\" ),\n          ColumnInfo.COLUMN_TYPE_CCOMBO, JobEntryPGPEncryptFiles.actionTypeDesc, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT, false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.Wildcard.Tooltip\" ) );\n    colinf[3].setUsingVariables( true );\n    colinf[3].setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.UserID.Tooltip\" ) );\n    colinf[4]\n      .setToolTip( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n\n    wFields =\n      new TableView(\n        jobMeta, wGeneralComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( wbeSourceFileFolder, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    RefreshArgFromPrevious();\n\n    // Add the file to the list of files...\n    SelectionAdapter selA = new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent arg0 ) {\n        wFields.add( new String[] {\n          JobEntryPGPEncryptFiles.actionTypeDesc[0], wSourceFileFolder.getText(), wWildcard.getText(), null,\n          wDestinationFileFolder.getText() } );\n        wSourceFileFolder.setText( \"\" );\n        wDestinationFileFolder.setText( \"\" );\n        wWildcard.setText( \"\" );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n        wFields.optWidth( true );\n      }\n    };\n    wbaSourceFileFolder.addSelectionListener( selA );\n    wSourceFileFolder.addSelectionListener( selA );\n\n    // Delete files from the list of files...\n    wbdSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    // Edit the selected file & remove from the list...\n    wbeSourceFileFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int idx = wFields.getSelectionIndex();\n        if ( idx >= 0 ) {\n          String[] string = wFields.getItem( idx );\n          wSourceFileFolder.setText( string[0] );\n          wDestinationFileFolder.setText( string[1] );\n          wWildcard.setText( string[2] );\n          wFields.remove( idx );\n        }\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    fdGeneralComp = new FormData();\n    fdGeneralComp.left = new FormAttachment( 0, 0 );\n    fdGeneralComp.top = new FormAttachment( 0, 0 );\n    fdGeneralComp.right = new FormAttachment( 100, 0 );\n    fdGeneralComp.bottom = new FormAttachment( 100, 0 );\n    wGeneralComp.setLayoutData( fdGeneralComp );\n\n    wGeneralComp.layout();\n    wGeneralTab.setControl( wGeneralComp );\n    props.setLook( wGeneralComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF GENERAL TAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF DESTINATION FILE TAB ///\n    // ///////////////////////////////////\n\n    wDestinationFileTab = new CTabItem( wTabFolder, SWT.NONE );\n    wDestinationFileTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFileTab.Label\" ) );\n\n    FormLayout DestcontentLayout = new FormLayout();\n    DestcontentLayout.marginWidth = 3;\n    DestcontentLayout.marginHeight = 3;\n\n    wDestinationFileComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wDestinationFileComp );\n    wDestinationFileComp.setLayout( DestcontentLayout );\n\n    // DestinationFile grouping?\n    // ////////////////////////\n    // START OF DestinationFile GROUP\n    //\n\n    wDestinationFile = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wDestinationFile );\n    wDestinationFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupDestinationFile.Label\" ) );\n\n    FormLayout groupLayoutFile = new FormLayout();\n    groupLayoutFile.marginWidth = 10;\n    groupLayoutFile.marginHeight = 10;\n    wDestinationFile.setLayout( groupLayoutFile );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wDestinationFile, SWT.RIGHT );\n    wlCreateDestinationFolder.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( 0, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wDestinationFile, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Do not keep folder structure?\n    wlDoNotKeepFolderStructure = new Label( wDestinationFile, SWT.RIGHT );\n    wlDoNotKeepFolderStructure.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Label\" ) );\n    props.setLook( wlDoNotKeepFolderStructure );\n    fdlDoNotKeepFolderStructure = new FormData();\n    fdlDoNotKeepFolderStructure.left = new FormAttachment( 0, 0 );\n    fdlDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlDoNotKeepFolderStructure.right = new FormAttachment( middle, -margin );\n    wlDoNotKeepFolderStructure.setLayoutData( fdlDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.DoNotKeepFolderStructure.Tooltip\" ) );\n    fdDoNotKeepFolderStructure = new FormData();\n    fdDoNotKeepFolderStructure.left = new FormAttachment( middle, 0 );\n    fdDoNotKeepFolderStructure.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdDoNotKeepFolderStructure.right = new FormAttachment( 100, 0 );\n    wDoNotKeepFolderStructure.setLayoutData( fdDoNotKeepFolderStructure );\n    wDoNotKeepFolderStructure.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddDate = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Label\" ) );\n    props.setLook( wlAddDate );\n    fdlAddDate = new FormData();\n    fdlAddDate.left = new FormAttachment( 0, 0 );\n    fdlAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdlAddDate.right = new FormAttachment( middle, -margin );\n    wlAddDate.setLayoutData( fdlAddDate );\n    wAddDate = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDate );\n    wAddDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddDate.Tooltip\" ) );\n    fdAddDate = new FormData();\n    fdAddDate.left = new FormAttachment( middle, 0 );\n    fdAddDate.top = new FormAttachment( wDoNotKeepFolderStructure, margin );\n    fdAddDate.right = new FormAttachment( 100, 0 );\n    wAddDate.setLayoutData( fdAddDate );\n    wAddDate.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddTime = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Label\" ) );\n    props.setLook( wlAddTime );\n    fdlAddTime = new FormData();\n    fdlAddTime.left = new FormAttachment( 0, 0 );\n    fdlAddTime.top = new FormAttachment( wAddDate, margin );\n    fdlAddTime.right = new FormAttachment( middle, -margin );\n    wlAddTime.setLayoutData( fdlAddTime );\n    wAddTime = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddTime );\n    wAddTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddTime.Tooltip\" ) );\n    fdAddTime = new FormData();\n    fdAddTime.left = new FormAttachment( middle, 0 );\n    fdAddTime.top = new FormAttachment( wAddDate, margin );\n    fdAddTime.right = new FormAttachment( 100, 0 );\n    wAddTime.setLayoutData( fdAddTime );\n    wAddTime.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlSpecifyFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Label\" ) );\n    props.setLook( wlSpecifyFormat );\n    fdlSpecifyFormat = new FormData();\n    fdlSpecifyFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdlSpecifyFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyFormat.setLayoutData( fdlSpecifyFormat );\n    wSpecifyFormat = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wSpecifyFormat );\n    wSpecifyFormat.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyFormat.Tooltip\" ) );\n    fdSpecifyFormat = new FormData();\n    fdSpecifyFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyFormat.top = new FormAttachment( wAddTime, margin );\n    fdSpecifyFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyFormat.setLayoutData( fdSpecifyFormat );\n    wSpecifyFormat.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setDateTimeFormat();\n        setAddDateBeforeExtension();\n      }\n    } );\n\n    // DateTimeFormat\n    wlDateTimeFormat = new Label( wDestinationFile, SWT.RIGHT );\n    wlDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DateTimeFormat.Label\" ) );\n    props.setLook( wlDateTimeFormat );\n    fdlDateTimeFormat = new FormData();\n    fdlDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdlDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlDateTimeFormat.setLayoutData( fdlDateTimeFormat );\n    wDateTimeFormat = new CCombo( wDestinationFile, SWT.BORDER | SWT.READ_ONLY );\n    wDateTimeFormat.setEditable( true );\n    props.setLook( wDateTimeFormat );\n    wDateTimeFormat.addModifyListener( lsMod );\n    fdDateTimeFormat = new FormData();\n    fdDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdDateTimeFormat.top = new FormAttachment( wSpecifyFormat, margin );\n    fdDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wDateTimeFormat.setLayoutData( fdDateTimeFormat );\n    // Prepare a list of possible DateTimeFormats...\n    String[] dats = Const.getDateFormats();\n    for ( int x = 0; x < dats.length; x++ ) {\n      wDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddDateBeforeExtension = new Label( wDestinationFile, SWT.RIGHT );\n    wlAddDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddDateBeforeExtension );\n    fdlAddDateBeforeExtension = new FormData();\n    fdlAddDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdlAddDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddDateBeforeExtension.setLayoutData( fdlAddDateBeforeExtension );\n    wAddDateBeforeExtension = new Button( wDestinationFile, SWT.CHECK );\n    props.setLook( wAddDateBeforeExtension );\n    wAddDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddDateBeforeExtension.Tooltip\" ) );\n    fdAddDateBeforeExtension = new FormData();\n    fdAddDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddDateBeforeExtension.top = new FormAttachment( wDateTimeFormat, margin );\n    fdAddDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddDateBeforeExtension.setLayoutData( fdAddDateBeforeExtension );\n    wAddDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If File Exists\n    wlIfFileExists = new Label( wDestinationFile, SWT.RIGHT );\n    wlIfFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfFileExists.Label\" ) );\n    props.setLook( wlIfFileExists );\n    fdlIfFileExists = new FormData();\n    fdlIfFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    wlIfFileExists.setLayoutData( fdlIfFileExists );\n    wIfFileExists = new CCombo( wDestinationFile, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Overwrite_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Unique_Name_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Delete_Source_File_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Move_To_Folder_IfFileExists.Label\" ) );\n    wIfFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfFileExists.Label\" ) );\n    wIfFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfFileExists );\n    fdIfFileExists = new FormData();\n    fdIfFileExists.left = new FormAttachment( middle, 0 );\n    fdIfFileExists.top = new FormAttachment( wAddDateBeforeExtension, margin );\n    fdIfFileExists.right = new FormAttachment( 100, 0 );\n    wIfFileExists.setLayoutData( fdIfFileExists );\n\n    wIfFileExists.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n\n        activeDestinationFolder();\n        setMovedDateTimeFormat();\n        // setAddDateBeforeExtension();\n        setAddMovedDateBeforeExtension();\n\n      }\n    } );\n\n    fdDestinationFile = new FormData();\n    fdDestinationFile.left = new FormAttachment( 0, margin );\n    fdDestinationFile.top = new FormAttachment( wName, margin );\n    fdDestinationFile.right = new FormAttachment( 100, -margin );\n    wDestinationFile.setLayoutData( fdDestinationFile );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DestinationFile GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // MoveTo grouping?\n    // ////////////////////////\n    // START OF MoveTo GROUP\n    //\n\n    wMoveToGroup = new Group( wDestinationFileComp, SWT.SHADOW_NONE );\n    props.setLook( wMoveToGroup );\n    wMoveToGroup.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.GroupMoveToGroup.Label\" ) );\n\n    FormLayout MovetoLayoutFile = new FormLayout();\n    MovetoLayoutFile.marginWidth = 10;\n    MovetoLayoutFile.marginHeight = 10;\n    wMoveToGroup.setLayout( MovetoLayoutFile );\n\n    // DestinationFolder line\n    wlDestinationFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlDestinationFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.DestinationFolder.Label\" ) );\n    props.setLook( wlDestinationFolder );\n    fdlDestinationFolder = new FormData();\n    fdlDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdlDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlDestinationFolder.setLayoutData( fdlDestinationFolder );\n\n    wbDestinationFolder = new Button( wMoveToGroup, SWT.PUSH | SWT.CENTER );\n    props.setLook( wbDestinationFolder );\n    wbDestinationFolder.setText( BaseMessages.getString( PKG, \"System.Button.Browse\" ) );\n    fdbDestinationFolder = new FormData();\n    fdbDestinationFolder.right = new FormAttachment( 100, 0 );\n    fdbDestinationFolder.top = new FormAttachment( wDestinationFile, 0 );\n    wbDestinationFolder.setLayoutData( fdbDestinationFolder );\n\n    wDestinationFolder = new TextVar( jobMeta, wMoveToGroup, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wDestinationFolder );\n    wDestinationFolder.addModifyListener( lsMod );\n    fdDestinationFolder = new FormData();\n    fdDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdDestinationFolder.top = new FormAttachment( wDestinationFile, margin );\n    fdDestinationFolder.right = new FormAttachment( wbDestinationFolder, -margin );\n    wDestinationFolder.setLayoutData( fdDestinationFolder );\n\n    // Whenever something changes, set the tooltip to the expanded version:\n    wDestinationFolder.addModifyListener( new ModifyListener() {\n      @Override\n      public void modifyText( ModifyEvent e ) {\n        wDestinationFolder.setToolTipText( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n      }\n    } );\n\n    wbDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        DirectoryDialog dialog = new DirectoryDialog( shell, SWT.OPEN );\n        if ( wDestinationFolder.getText() != null ) {\n          dialog.setFilterPath( jobMeta.environmentSubstitute( wDestinationFolder.getText() ) );\n        }\n\n        String dir = dialog.open();\n        if ( dir != null ) {\n          wDestinationFolder.setText( dir );\n        }\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateMoveToFolder = new Label( wMoveToGroup, SWT.RIGHT );\n    wlCreateMoveToFolder.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Label\" ) );\n    props.setLook( wlCreateMoveToFolder );\n    fdlCreateMoveToFolder = new FormData();\n    fdlCreateMoveToFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdlCreateMoveToFolder.right = new FormAttachment( middle, -margin );\n    wlCreateMoveToFolder.setLayoutData( fdlCreateMoveToFolder );\n    wCreateMoveToFolder = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wCreateMoveToFolder );\n    wCreateMoveToFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.CreateMoveToFolder.Tooltip\" ) );\n    fdCreateMoveToFolder = new FormData();\n    fdCreateMoveToFolder.left = new FormAttachment( middle, 0 );\n    fdCreateMoveToFolder.top = new FormAttachment( wDestinationFolder, margin );\n    fdCreateMoveToFolder.right = new FormAttachment( 100, 0 );\n    wCreateMoveToFolder.setLayoutData( fdCreateMoveToFolder );\n    wCreateMoveToFolder.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create multi-part file?\n    wlAddMovedDate = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDate.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Label\" ) );\n    props.setLook( wlAddMovedDate );\n    fdlAddMovedDate = new FormData();\n    fdlAddMovedDate.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdlAddMovedDate.right = new FormAttachment( middle, -margin );\n    wlAddMovedDate.setLayoutData( fdlAddMovedDate );\n    wAddMovedDate = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDate );\n    wAddMovedDate.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedDate.Tooltip\" ) );\n    fdAddMovedDate = new FormData();\n    fdAddMovedDate.left = new FormAttachment( middle, 0 );\n    fdAddMovedDate.top = new FormAttachment( wCreateMoveToFolder, margin );\n    fdAddMovedDate.right = new FormAttachment( 100, 0 );\n    wAddMovedDate.setLayoutData( fdAddMovedDate );\n    wAddMovedDate.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n    // Create multi-part file?\n    wlAddMovedTime = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedTime.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Label\" ) );\n    props.setLook( wlAddMovedTime );\n    fdlAddMovedTime = new FormData();\n    fdlAddMovedTime.left = new FormAttachment( 0, 0 );\n    fdlAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdlAddMovedTime.right = new FormAttachment( middle, -margin );\n    wlAddMovedTime.setLayoutData( fdlAddMovedTime );\n    wAddMovedTime = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedTime );\n    wAddMovedTime.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddMovedTime.Tooltip\" ) );\n    fdAddMovedTime = new FormData();\n    fdAddMovedTime.left = new FormAttachment( middle, 0 );\n    fdAddMovedTime.top = new FormAttachment( wAddMovedDate, margin );\n    fdAddMovedTime.right = new FormAttachment( 100, 0 );\n    wAddMovedTime.setLayoutData( fdAddMovedTime );\n    wAddMovedTime.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Specify date time format?\n    wlSpecifyMoveFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlSpecifyMoveFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Label\" ) );\n    props.setLook( wlSpecifyMoveFormat );\n    fdlSpecifyMoveFormat = new FormData();\n    fdlSpecifyMoveFormat.left = new FormAttachment( 0, 0 );\n    fdlSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdlSpecifyMoveFormat.right = new FormAttachment( middle, -margin );\n    wlSpecifyMoveFormat.setLayoutData( fdlSpecifyMoveFormat );\n    wSpecifyMoveFormat = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wSpecifyMoveFormat );\n    wSpecifyMoveFormat.setToolTipText( BaseMessages\n      .getString( PKG, \"JobPGPEncryptFiles.SpecifyMoveFormat.Tooltip\" ) );\n    fdSpecifyMoveFormat = new FormData();\n    fdSpecifyMoveFormat.left = new FormAttachment( middle, 0 );\n    fdSpecifyMoveFormat.top = new FormAttachment( wAddMovedTime, margin );\n    fdSpecifyMoveFormat.right = new FormAttachment( 100, 0 );\n    wSpecifyMoveFormat.setLayoutData( fdSpecifyMoveFormat );\n    wSpecifyMoveFormat.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        setMovedDateTimeFormat();\n        setAddMovedDateBeforeExtension();\n      }\n    } );\n\n    // Moved DateTimeFormat\n    wlMovedDateTimeFormat = new Label( wMoveToGroup, SWT.RIGHT );\n    wlMovedDateTimeFormat.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.MovedDateTimeFormat.Label\" ) );\n    props.setLook( wlMovedDateTimeFormat );\n    fdlMovedDateTimeFormat = new FormData();\n    fdlMovedDateTimeFormat.left = new FormAttachment( 0, 0 );\n    fdlMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdlMovedDateTimeFormat.right = new FormAttachment( middle, -margin );\n    wlMovedDateTimeFormat.setLayoutData( fdlMovedDateTimeFormat );\n    wMovedDateTimeFormat = new CCombo( wMoveToGroup, SWT.BORDER | SWT.READ_ONLY );\n    wMovedDateTimeFormat.setEditable( true );\n    props.setLook( wMovedDateTimeFormat );\n    wMovedDateTimeFormat.addModifyListener( lsMod );\n    fdMovedDateTimeFormat = new FormData();\n    fdMovedDateTimeFormat.left = new FormAttachment( middle, 0 );\n    fdMovedDateTimeFormat.top = new FormAttachment( wSpecifyMoveFormat, margin );\n    fdMovedDateTimeFormat.right = new FormAttachment( 100, 0 );\n    wMovedDateTimeFormat.setLayoutData( fdMovedDateTimeFormat );\n\n    for ( int x = 0; x < dats.length; x++ ) {\n      wMovedDateTimeFormat.add( dats[x] );\n    }\n\n    // Add Date before extension?\n    wlAddMovedDateBeforeExtension = new Label( wMoveToGroup, SWT.RIGHT );\n    wlAddMovedDateBeforeExtension.setText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Label\" ) );\n    props.setLook( wlAddMovedDateBeforeExtension );\n    fdlAddMovedDateBeforeExtension = new FormData();\n    fdlAddMovedDateBeforeExtension.left = new FormAttachment( 0, 0 );\n    fdlAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdlAddMovedDateBeforeExtension.right = new FormAttachment( middle, -margin );\n    wlAddMovedDateBeforeExtension.setLayoutData( fdlAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension = new Button( wMoveToGroup, SWT.CHECK );\n    props.setLook( wAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.setToolTipText( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.AddMovedDateBeforeExtension.Tooltip\" ) );\n    fdAddMovedDateBeforeExtension = new FormData();\n    fdAddMovedDateBeforeExtension.left = new FormAttachment( middle, 0 );\n    fdAddMovedDateBeforeExtension.top = new FormAttachment( wMovedDateTimeFormat, margin );\n    fdAddMovedDateBeforeExtension.right = new FormAttachment( 100, 0 );\n    wAddMovedDateBeforeExtension.setLayoutData( fdAddMovedDateBeforeExtension );\n    wAddMovedDateBeforeExtension.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // If moved File Exists\n    wlIfMovedFileExists = new Label( wMoveToGroup, SWT.RIGHT );\n    wlIfMovedFileExists.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.IfMovedFileExists.Label\" ) );\n    props.setLook( wlIfMovedFileExists );\n    fdlIfMovedFileExists = new FormData();\n    fdlIfMovedFileExists.left = new FormAttachment( 0, 0 );\n    fdlIfMovedFileExists.right = new FormAttachment( middle, 0 );\n    fdlIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    wlIfMovedFileExists.setLayoutData( fdlIfMovedFileExists );\n    wIfMovedFileExists = new CCombo( wMoveToGroup, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Do_Nothing_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString(\n      PKG, \"JobPGPEncryptFiles.Overwrite_Filename_IffMovedFileExists.Label\" ) );\n    wIfMovedFileExists\n      .add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.UniqueName_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Fail_IfMovedFileExists.Label\" ) );\n    wIfMovedFileExists.select( 0 ); // +1: starts at -1\n\n    props.setLook( wIfMovedFileExists );\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdIfMovedFileExists = new FormData();\n    fdIfMovedFileExists.left = new FormAttachment( middle, 0 );\n    fdIfMovedFileExists.top = new FormAttachment( wAddMovedDateBeforeExtension, margin );\n    fdIfMovedFileExists.right = new FormAttachment( 100, 0 );\n    wIfMovedFileExists.setLayoutData( fdIfMovedFileExists );\n\n    fdMoveToGroup = new FormData();\n    fdMoveToGroup.left = new FormAttachment( 0, margin );\n    fdMoveToGroup.top = new FormAttachment( wDestinationFile, margin );\n    fdMoveToGroup.right = new FormAttachment( 100, -margin );\n    wMoveToGroup.setLayoutData( fdMoveToGroup );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF MoveToGroup GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdDestinationFileComp = new FormData();\n    fdDestinationFileComp.left = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.top = new FormAttachment( 0, 0 );\n    fdDestinationFileComp.right = new FormAttachment( 100, 0 );\n    fdDestinationFileComp.bottom = new FormAttachment( 100, 0 );\n    wDestinationFileComp.setLayoutData( wDestinationFileComp );\n\n    wDestinationFileComp.layout();\n    wDestinationFileTab.setControl( wDestinationFileComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF DESTINATION FILETAB\n    // ///////////////////////////////////////////////////////////\n\n    // ////////////////////////////////////\n    // START OF ADVANCED TAB ///\n    // ///////////////////////////////////\n\n    wAdvancedTab = new CTabItem( wTabFolder, SWT.NONE );\n    wAdvancedTab.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.Tab.Advanced.Label\" ) );\n\n    FormLayout contentLayout = new FormLayout();\n    contentLayout.marginWidth = 3;\n    contentLayout.marginHeight = 3;\n\n    wAdvancedComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wAdvancedComp );\n    wAdvancedComp.setLayout( contentLayout );\n\n    // SuccessOngrouping?\n    // ////////////////////////\n    // START OF SUCCESS ON GROUP///\n    // /\n    wSuccessOn = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wSuccessOn );\n    wSuccessOn.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessOn.Group.Label\" ) );\n\n    FormLayout successongroupLayout = new FormLayout();\n    successongroupLayout.marginWidth = 10;\n    successongroupLayout.marginHeight = 10;\n\n    wSuccessOn.setLayout( successongroupLayout );\n\n    // Success Condition\n    wlSuccessCondition = new Label( wSuccessOn, SWT.RIGHT );\n    wlSuccessCondition.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessCondition.Label\" ) );\n    props.setLook( wlSuccessCondition );\n    fdlSuccessCondition = new FormData();\n    fdlSuccessCondition.left = new FormAttachment( 0, 0 );\n    fdlSuccessCondition.right = new FormAttachment( middle, 0 );\n    fdlSuccessCondition.top = new FormAttachment( 0, margin );\n    wlSuccessCondition.setLayoutData( fdlSuccessCondition );\n    wSuccessCondition = new CCombo( wSuccessOn, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAllWorksFine.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenAtLeat.Label\" ) );\n    wSuccessCondition.add( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.SuccessWhenErrorsLessThan.Label\" ) );\n\n    wSuccessCondition.select( 0 ); // +1: starts at -1\n\n    props.setLook( wSuccessCondition );\n    fdSuccessCondition = new FormData();\n    fdSuccessCondition.left = new FormAttachment( middle, 0 );\n    fdSuccessCondition.top = new FormAttachment( 0, margin );\n    fdSuccessCondition.right = new FormAttachment( 100, 0 );\n    wSuccessCondition.setLayoutData( fdSuccessCondition );\n    wSuccessCondition.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        activeSuccessCondition();\n\n      }\n    } );\n\n    // Success when number of errors less than\n    wlNrErrorsLessThan = new Label( wSuccessOn, SWT.RIGHT );\n    wlNrErrorsLessThan.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Label\" ) );\n    props.setLook( wlNrErrorsLessThan );\n    fdlNrErrorsLessThan = new FormData();\n    fdlNrErrorsLessThan.left = new FormAttachment( 0, 0 );\n    fdlNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdlNrErrorsLessThan.right = new FormAttachment( middle, -margin );\n    wlNrErrorsLessThan.setLayoutData( fdlNrErrorsLessThan );\n\n    wNrErrorsLessThan =\n      new TextVar( jobMeta, wSuccessOn, SWT.SINGLE | SWT.LEFT | SWT.BORDER, BaseMessages.getString(\n        PKG, \"JobPGPEncryptFiles.NrErrorsLessThan.Tooltip\" ) );\n    props.setLook( wNrErrorsLessThan );\n    wNrErrorsLessThan.addModifyListener( lsMod );\n    fdNrErrorsLessThan = new FormData();\n    fdNrErrorsLessThan.left = new FormAttachment( middle, 0 );\n    fdNrErrorsLessThan.top = new FormAttachment( wSuccessCondition, margin );\n    fdNrErrorsLessThan.right = new FormAttachment( 100, -margin );\n    wNrErrorsLessThan.setLayoutData( fdNrErrorsLessThan );\n\n    fdSuccessOn = new FormData();\n    fdSuccessOn.left = new FormAttachment( 0, margin );\n    fdSuccessOn.top = new FormAttachment( wDestinationFile, margin );\n    fdSuccessOn.right = new FormAttachment( 100, -margin );\n    wSuccessOn.setLayoutData( fdSuccessOn );\n    // ///////////////////////////////////////////////////////////\n    // / END OF Success ON GROUP\n    // ///////////////////////////////////////////////////////////\n\n    // fileresult grouping?\n    // ////////////////////////\n    // START OF LOGGING GROUP///\n    // /\n    wFileResult = new Group( wAdvancedComp, SWT.SHADOW_NONE );\n    props.setLook( wFileResult );\n    wFileResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.FileResult.Group.Label\" ) );\n\n    FormLayout fileresultgroupLayout = new FormLayout();\n    fileresultgroupLayout.marginWidth = 10;\n    fileresultgroupLayout.marginHeight = 10;\n\n    wFileResult.setLayout( fileresultgroupLayout );\n\n    // Add file to result\n    wlAddFileToResult = new Label( wFileResult, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wFileResult, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobPGPEncryptFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wSuccessOn, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    fdFileResult = new FormData();\n    fdFileResult.left = new FormAttachment( 0, margin );\n    fdFileResult.top = new FormAttachment( wSuccessOn, margin );\n    fdFileResult.right = new FormAttachment( 100, -margin );\n    wFileResult.setLayoutData( fdFileResult );\n    // ///////////////////////////////////////////////////////////\n    // / END OF FilesResult GROUP\n    // ///////////////////////////////////////////////////////////\n\n    fdAdvancedComp = new FormData();\n    fdAdvancedComp.left = new FormAttachment( 0, 0 );\n    fdAdvancedComp.top = new FormAttachment( 0, 0 );\n    fdAdvancedComp.right = new FormAttachment( 100, 0 );\n    fdAdvancedComp.bottom = new FormAttachment( 100, 0 );\n    wAdvancedComp.setLayoutData( wAdvancedComp );\n\n    wAdvancedComp.layout();\n    wAdvancedTab.setControl( wAdvancedComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF ADVANCED TAB\n    // ///////////////////////////////////////////////////////////\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( wName, margin );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -50 );\n    wTabFolder.setLayoutData( fdTabFolder );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    BaseStepDialog.positionBottomButtons( shell, new Button[] { wOK, wCancel }, margin, wTabFolder );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      @Override\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      @Override\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      @Override\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n    wSourceFileFolder.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      @Override\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    activeSuccessCondition();\n    setDateTimeFormat();\n    activeSuccessCondition();\n\n    activeDestinationFolder();\n    setMovedDateTimeFormat();\n    setAddDateBeforeExtension();\n    setAddMovedDateBeforeExtension();\n    wTabFolder.setSelection( 0 );\n    BaseStepDialog.setSize( shell );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return jobEntry;\n  }","commit_id":"b641c2f73460105a960c65b1f0543bf45d255831","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n//    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n    wFilesTab.setText( \"Files\" );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ), ColumnInfo.COLUMN_TYPE_TEXT,\n          false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[0].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    colinf[0].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","id":688,"modified_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n        new ColumnInfo[] {\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ) };\n    \n    setComboValues( colinf[0] );\n    \n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    setComboValues( colinf[3] );\n    \n    colinf[4].setUsingVariables( true );\n    colinf[4].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[4].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","commit_id":"552d8adb2723f9fb17d3bce7701d53c9c12f4237","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n//    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n    wFilesTab.setText( \"Files\" );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n      new ColumnInfo[] {\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n          ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n        new ColumnInfo(\n          BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ), ColumnInfo.COLUMN_TYPE_TEXT,\n          false ), };\n\n    colinf[0].setUsingVariables( true );\n    colinf[0].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    colinf[0].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","id":689,"modified_method":"protected void initUI() {\n    Shell parent = getParent();\n\n    shell = new Shell( parent, props.getJobsDialogStyle() );\n    props.setLook( shell );\n    Button helpButton = JobDialog.setShellImage( shell, jobEntry );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        jobEntry.setChanged();\n      }\n    };\n    changed = jobEntry.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Filename line\n    wlName = new Label( shell, SWT.LEFT );\n    wlName.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Name.Label\" ) );\n    props.setLook( wlName );\n    fdlName = new FormData();\n    fdlName.left = new FormAttachment( 0, 0 );\n    fdlName.right = new FormAttachment( middle, -margin );\n    fdlName.top = new FormAttachment( 0, margin );\n    wlName.setLayoutData( fdlName );\n    wName = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wName );\n    wName.addModifyListener( lsMod );\n    fdName = new FormData();\n    fdName.left = new FormAttachment( 0, 0 );\n    fdName.top = new FormAttachment( wlName, margin );\n    fdName.right = new FormAttachment( 40, 0 );\n    wName.setLayoutData( fdName );\n    Label wlIcon = new Label( shell, SWT.RIGHT );\n    wlIcon.setImage( getImage() );\n    props.setLook( wlIcon );\n    FormData fdlIcon = new FormData();\n    fdlIcon.top = new FormAttachment( 0, margin * 3 );\n    fdlIcon.right = new FormAttachment( 100, -margin );\n    wlIcon.setLayoutData( fdlIcon );\n    \n    Label lTopSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdTopSeparator = new FormData();\n    fdTopSeparator.top = new FormAttachment( wName, margin * 3 );\n    fdTopSeparator.left = new FormAttachment( 0, 0 );\n    fdTopSeparator.right = new FormAttachment( 100, 0 );\n    lTopSeparator.setLayoutData( fdTopSeparator );    \n    \n    \n    wTabFolder = new CTabFolder( shell, SWT.BORDER );\n    props.setLook( wTabFolder, Props.WIDGET_STYLE_TAB );\n\n    fdTabFolder = new FormData();\n    fdTabFolder.left = new FormAttachment( 0, 0 );\n    fdTabFolder.top = new FormAttachment( lTopSeparator, margin * 3 );\n    fdTabFolder.right = new FormAttachment( 100, 0 );\n    fdTabFolder.bottom = new FormAttachment( 100, -60 );\n    wTabFolder.setLayoutData( fdTabFolder );\n    \n    // ///////////////////////////////////////////////////////////\n    // / START OF FILES TAB\n    // ///////////////////////////////////////////////////////////\n    \n    wFilesTab = new CTabItem( wTabFolder, SWT.NONE );\n    wFilesTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Tab.Files.Label\" ) );\n\n    wFilesComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wFilesComp );\n    \n    FormLayout filesLayout = new FormLayout();\n    filesLayout.marginWidth = 3;\n    filesLayout.marginHeight = 3;\n    wFilesComp.setLayout( filesLayout );\n    \n    fdFilesComp = new FormData();\n    fdFilesComp.left = new FormAttachment( 0, 0 );\n    fdFilesComp.top = new FormAttachment( 0, 0 );\n    fdFilesComp.right = new FormAttachment( 100, 0 );\n    fdFilesComp.bottom = new FormAttachment( 100, 0 );\n    wFilesComp.setLayoutData( fdFilesComp );\n\n    wFilesComp.layout();\n    wFilesTab.setControl( wFilesComp );\n    \n    // ///////////////////////////////////////////////////////////\n    // / END OF FILES TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    // ////////////////////////\n    // START OF SETTINGS TAB ///\n    // ////////////////////////\n\n    wSettingsTab = new CTabItem( wTabFolder, SWT.NONE );\n    wSettingsTab.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Settings.Label\" ) );\n\n    wSettingsComp = new Composite( wTabFolder, SWT.NONE );\n    props.setLook( wSettingsComp );\n\n    FormLayout settingsLayout = new FormLayout();\n    settingsLayout.marginWidth = 3;\n    settingsLayout.marginHeight = 3;\n    wSettingsComp.setLayout( settingsLayout );\n    \n    wlIncludeSubfolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlIncludeSubfolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Label\" ) );\n    props.setLook( wlIncludeSubfolders );\n    fdlIncludeSubfolders = new FormData();\n    fdlIncludeSubfolders.left = new FormAttachment( 0, 0 );\n    fdlIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdlIncludeSubfolders.right = new FormAttachment( middle, -margin );\n    wlIncludeSubfolders.setLayoutData( fdlIncludeSubfolders );\n    wIncludeSubfolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wIncludeSubfolders );\n    wIncludeSubfolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.IncludeSubfolders.Tooltip\" ) );\n    fdIncludeSubfolders = new FormData();\n    fdIncludeSubfolders.left = new FormAttachment( middle, 0 );\n    fdIncludeSubfolders.top = new FormAttachment( wName, margin );\n    fdIncludeSubfolders.right = new FormAttachment( 100, 0 );\n    wIncludeSubfolders.setLayoutData( fdIncludeSubfolders );\n    wIncludeSubfolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n        CheckIncludeSubFolders();\n      }\n    } );\n\n    // Destination is a file?\n    wlDestinationIsAFile = new Label( wSettingsComp, SWT.RIGHT );\n    wlDestinationIsAFile.setText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Label\" ) );\n    props.setLook( wlDestinationIsAFile );\n    fdlDestinationIsAFile = new FormData();\n    fdlDestinationIsAFile.left = new FormAttachment( 0, 0 );\n    fdlDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdlDestinationIsAFile.right = new FormAttachment( middle, -margin );\n    wlDestinationIsAFile.setLayoutData( fdlDestinationIsAFile );\n    wDestinationIsAFile = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wDestinationIsAFile );\n    wDestinationIsAFile.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.DestinationIsAFile.Tooltip\" ) );\n    fdDestinationIsAFile = new FormData();\n    fdDestinationIsAFile.left = new FormAttachment( middle, 0 );\n    fdDestinationIsAFile.top = new FormAttachment( wIncludeSubfolders, margin );\n    fdDestinationIsAFile.right = new FormAttachment( 100, 0 );\n    wDestinationIsAFile.setLayoutData( fdDestinationIsAFile );\n    wDestinationIsAFile.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Copy empty folders\n    wlCopyEmptyFolders = new Label( wSettingsComp, SWT.RIGHT );\n    wlCopyEmptyFolders.setText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Label\" ) );\n    props.setLook( wlCopyEmptyFolders );\n    fdlCopyEmptyFolders = new FormData();\n    fdlCopyEmptyFolders.left = new FormAttachment( 0, 0 );\n    fdlCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdlCopyEmptyFolders.right = new FormAttachment( middle, -margin );\n    wlCopyEmptyFolders.setLayoutData( fdlCopyEmptyFolders );\n    wCopyEmptyFolders = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCopyEmptyFolders );\n    wCopyEmptyFolders.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.CopyEmptyFolders.Tooltip\" ) );\n    fdCopyEmptyFolders = new FormData();\n    fdCopyEmptyFolders.left = new FormAttachment( middle, 0 );\n    fdCopyEmptyFolders.top = new FormAttachment( wDestinationIsAFile, margin );\n    fdCopyEmptyFolders.right = new FormAttachment( 100, 0 );\n    wCopyEmptyFolders.setLayoutData( fdCopyEmptyFolders );\n    wCopyEmptyFolders.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Create destination folder/parent folder\n    wlCreateDestinationFolder = new Label( wSettingsComp, SWT.RIGHT );\n    wlCreateDestinationFolder\n      .setText( BaseMessages.getString( PKG, \"JobCopyFiles.CreateDestinationFolder.Label\" ) );\n    props.setLook( wlCreateDestinationFolder );\n    fdlCreateDestinationFolder = new FormData();\n    fdlCreateDestinationFolder.left = new FormAttachment( 0, 0 );\n    fdlCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdlCreateDestinationFolder.right = new FormAttachment( middle, -margin );\n    wlCreateDestinationFolder.setLayoutData( fdlCreateDestinationFolder );\n    wCreateDestinationFolder = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wCreateDestinationFolder );\n    wCreateDestinationFolder.setToolTipText( BaseMessages.getString(\n      PKG, \"JobCopyFiles.CreateDestinationFolder.Tooltip\" ) );\n    fdCreateDestinationFolder = new FormData();\n    fdCreateDestinationFolder.left = new FormAttachment( middle, 0 );\n    fdCreateDestinationFolder.top = new FormAttachment( wCopyEmptyFolders, margin );\n    fdCreateDestinationFolder.right = new FormAttachment( 100, 0 );\n    wCreateDestinationFolder.setLayoutData( fdCreateDestinationFolder );\n    wCreateDestinationFolder.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // OverwriteFiles Option\n    wlOverwriteFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlOverwriteFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Label\" ) );\n    props.setLook( wlOverwriteFiles );\n    fdlOverwriteFiles = new FormData();\n    fdlOverwriteFiles.left = new FormAttachment( 0, 0 );\n    fdlOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdlOverwriteFiles.right = new FormAttachment( middle, -margin );\n    wlOverwriteFiles.setLayoutData( fdlOverwriteFiles );\n    wOverwriteFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wOverwriteFiles );\n    wOverwriteFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.OverwriteFiles.Tooltip\" ) );\n    fdOverwriteFiles = new FormData();\n    fdOverwriteFiles.left = new FormAttachment( middle, 0 );\n    fdOverwriteFiles.top = new FormAttachment( wCreateDestinationFolder, margin );\n    fdOverwriteFiles.right = new FormAttachment( 100, 0 );\n    wOverwriteFiles.setLayoutData( fdOverwriteFiles );\n    wOverwriteFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    // Remove source files option\n    wlRemoveSourceFiles = new Label( wSettingsComp, SWT.RIGHT );\n    wlRemoveSourceFiles.setText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Label\" ) );\n    props.setLook( wlRemoveSourceFiles );\n    fdlRemoveSourceFiles = new FormData();\n    fdlRemoveSourceFiles.left = new FormAttachment( 0, 0 );\n    fdlRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdlRemoveSourceFiles.right = new FormAttachment( middle, -margin );\n    wlRemoveSourceFiles.setLayoutData( fdlRemoveSourceFiles );\n    wRemoveSourceFiles = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wRemoveSourceFiles );\n    wRemoveSourceFiles.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.RemoveSourceFiles.Tooltip\" ) );\n    fdRemoveSourceFiles = new FormData();\n    fdRemoveSourceFiles.left = new FormAttachment( middle, 0 );\n    fdRemoveSourceFiles.top = new FormAttachment( wOverwriteFiles, margin );\n    fdRemoveSourceFiles.right = new FormAttachment( 100, 0 );\n    wRemoveSourceFiles.setLayoutData( fdRemoveSourceFiles );\n    wRemoveSourceFiles.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n\n    wlPrevious = new Label( wSettingsComp, SWT.RIGHT );\n    wlPrevious.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Label\" ) );\n    props.setLook( wlPrevious );\n    fdlPrevious = new FormData();\n    fdlPrevious.left = new FormAttachment( 0, 0 );\n    fdlPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdlPrevious.right = new FormAttachment( middle, -margin );\n    wlPrevious.setLayoutData( fdlPrevious );\n    wPrevious = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wPrevious );\n    wPrevious.setSelection( jobEntry.arg_from_previous );\n    wPrevious.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.Previous.Tooltip\" ) );\n    fdPrevious = new FormData();\n    fdPrevious.left = new FormAttachment( middle, 0 );\n    fdPrevious.top = new FormAttachment( wRemoveSourceFiles, margin );\n    fdPrevious.right = new FormAttachment( 100, 0 );\n    wPrevious.setLayoutData( fdPrevious );\n    wPrevious.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n\n        refreshArgFromPrevious();\n\n      }\n    } );\n    \n    // Add file to result\n    wlAddFileToResult = new Label( wSettingsComp, SWT.RIGHT );\n    wlAddFileToResult.setText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Label\" ) );\n    props.setLook( wlAddFileToResult );\n    fdlAddFileToResult = new FormData();\n    fdlAddFileToResult.left = new FormAttachment( 0, 0 );\n    fdlAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdlAddFileToResult.right = new FormAttachment( middle, -margin );\n    wlAddFileToResult.setLayoutData( fdlAddFileToResult );\n    wAddFileToResult = new Button( wSettingsComp, SWT.CHECK );\n    props.setLook( wAddFileToResult );\n    wAddFileToResult.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.AddFileToResult.Tooltip\" ) );\n    fdAddFileToResult = new FormData();\n    fdAddFileToResult.left = new FormAttachment( middle, 0 );\n    fdAddFileToResult.top = new FormAttachment( wPrevious, margin );\n    fdAddFileToResult.right = new FormAttachment( 100, 0 );\n    wAddFileToResult.setLayoutData( fdAddFileToResult );\n    wAddFileToResult.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent e ) {\n        jobEntry.setChanged();\n      }\n    } );\n    \n    fdSettingsComp = new FormData();\n    fdSettingsComp.left = new FormAttachment( 0, 0 );\n    fdSettingsComp.top = new FormAttachment( 0, 0 );\n    fdSettingsComp.right = new FormAttachment( 100, 0 );\n    fdSettingsComp.bottom = new FormAttachment( 100, 0 );\n    wSettingsComp.setLayoutData( fdSettingsComp );\n\n    wSettingsComp.layout();\n    wSettingsTab.setControl( wSettingsComp );\n    props.setLook( wSettingsComp );\n\n    // ///////////////////////////////////////////////////////////\n    // / END OF SETTINGS TAB\n    // ///////////////////////////////////////////////////////////    \n    \n    ToolBar tb = new ToolBar( wFilesComp, SWT.HORIZONTAL | SWT.FLAT );\n    props.setLook( tb );\n    FormData fdTb = new FormData();\n    fdTb.right = new FormAttachment( 100, 0 );\n    fdTb.top = new FormAttachment( wFilesComp, margin );\n    tb.setLayoutData( fdTb );\n\n    deleteToolItem = new ToolItem( tb, SWT.PUSH );\n    deleteToolItem.setImage( GUIResource.getInstance().getImageDelete() );\n    deleteToolItem.setToolTipText( BaseMessages.getString( PKG, \"JobCopyFiles.FilenameDelete.Tooltip\" ) );\n    deleteToolItem.addSelectionListener( new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        int[] idx = wFields.getSelectionIndices();\n        wFields.remove( idx );\n        wFields.removeEmptyRows();\n        wFields.setRowNums();\n      }\n    } );\n\n    wlFields = new Label( wFilesComp, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, margin );\n    fdlFields.right = new FormAttachment( middle, -margin );\n    fdlFields.top = new FormAttachment( wFilesComp, 15 );\n    wlFields.setLayoutData( fdlFields );\n\n    int rows =\n      jobEntry.source_filefolder == null ? 1 : ( jobEntry.source_filefolder.length == 0\n        ? 0 : jobEntry.source_filefolder.length );\n    final int FieldsRows = rows;\n\n    ColumnInfo[] colinf =\n        new ColumnInfo[] {\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT, false ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationEnvironment.Label\" ),\n              ColumnInfo.COLUMN_TYPE_CCOMBO, false, true ),\n          new ColumnInfo( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Label\" ),\n              ColumnInfo.COLUMN_TYPE_TEXT_BUTTON, false ) };\n    \n    setComboValues( colinf[0] );\n    \n    colinf[1].setUsingVariables( true );\n    colinf[1].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.SourceFileFolder.Tooltip\" ) );\n    colinf[1].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n\n    colinf[2].setUsingVariables( true );\n    colinf[2].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.Wildcard.Tooltip\" ) );\n\n    setComboValues( colinf[3] );\n    \n    colinf[4].setUsingVariables( true );\n    colinf[4].setToolTip( BaseMessages.getString( PKG, \"JobCopyFiles.Fields.DestinationFileFolder.Tooltip\" ) );\n    colinf[4].setTextVarButtonSelectionListener( getFileSelectionAdapter() );\n    \n    wFields =\n      new TableView(\n        jobMeta, wFilesComp, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, margin );\n    fdFields.top = new FormAttachment( tb, margin );\n    fdFields.right = new FormAttachment( 100, -margin );\n    fdFields.bottom = new FormAttachment( 100, -margin );\n    wFields.setLayoutData( fdFields );\n\n    refreshArgFromPrevious();\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    Label lBottomSeparator = new Label( shell, SWT.HORIZONTAL | SWT.SEPARATOR );\n    FormData fdBottomSeparator = new FormData();\n    fdBottomSeparator.top = new FormAttachment( wTabFolder, margin * 3 );\n    fdBottomSeparator.left = new FormAttachment( 0, 0 );\n    fdBottomSeparator.right = new FormAttachment( 100, 0 );\n    lBottomSeparator.setLayoutData( fdBottomSeparator );\n\n    BaseStepDialog.positionBottomRightButtons( shell, new Button[] { wOK, wCancel }, margin, lBottomSeparator );\n    FormData fdOK = (FormData) wOK.getLayoutData();\n    FormData fdHelpButton = new FormData();\n    fdHelpButton.top = fdOK.top;\n    fdHelpButton.left = new FormAttachment( 0, margin );\n    helpButton.setLayoutData( fdHelpButton );\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wName.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    getData();\n    CheckIncludeSubFolders();\n    wTabFolder.setSelection( 0 );\n    \n  }","commit_id":"3b40563eded4766513075a8cfab98c1a5583ae28","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            dsLabelValue = ResourceTypeUtils.getStringProperty(directory, threshold.getDatasourceLabel());\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","id":690,"modified_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            String key = threshold.getDatasourceLabel();\n            dsLabelValue = (key == null ? null : ResourceTypeUtils.getStringProperty(directory, key));\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","commit_id":"4927f7c5d0dd87dc91fb6fb522e0f5cf068c2946","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            dsLabelValue = ResourceTypeUtils.getStringProperty(directory, threshold.getDatasourceLabel());\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","id":691,"modified_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            String key = threshold.getDatasourceLabel();\n            dsLabelValue = (key == null ? null : ResourceTypeUtils.getStringProperty(directory, key));\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","commit_id":"3987d793ca1d12c2799fa43848eec274e4c0ef9b","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            dsLabelValue = ResourceTypeUtils.getStringProperty(directory, threshold.getDatasourceLabel());\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","id":692,"modified_method":"/**\n     * Get the value to use for the ds-label from this threshold\n     */\n    private String getDataSourceLabel(File directory, SnmpThresholdNetworkInterface snmpIface, ThresholdEntity threshold) {\n        String dsLabelValue = null;\n        \n        try {\n            String key = threshold.getDatasourceLabel();\n            dsLabelValue = (key == null ? null : ResourceTypeUtils.getStringProperty(directory, key));\n        } catch (DataAccessException e) {\n            if (log().isDebugEnabled()) {\n                log().debug (\"getDataSourceLabel: I/O exception when looking for strings.properties file for node id: \" + snmpIface.getNodeId() + \" looking here: \" + directory + \": \" + e, e);\n            }\n        }\n        \n        return (dsLabelValue == null ? \"Unknown\" : dsLabelValue);\n\n    }","commit_id":"a7ed0a04b6abf82eee23b19335363ba91eecd546","url":"https://github.com/OpenNMS/opennms"}]