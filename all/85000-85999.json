[{"original_method":"/**\n     * Populates the Map with the variables which are made available to a script or template\n     *\n     * @param exchange the exchange to make available\n     * @param map      the map to populate\n     */\n    public static void populateVariableMap(Exchange exchange, Map<String, Object> map) {\n        map.put(\"exchange\", exchange);\n        Message in = exchange.getIn();\n        map.put(\"in\", in);\n        map.put(\"request\", in);\n        map.put(\"headers\", in.getHeaders());\n        map.put(\"body\", in.getBody());\n        if (isOutCapable(exchange)) {\n            Message out = exchange.getOut();\n            map.put(\"out\", out);\n            map.put(\"response\", out);\n        }\n        map.put(\"camelContext\", exchange.getContext());\n    }","id":85000,"modified_method":"/**\n     * Populates the Map with the variables which are made available to a script or template\n     *\n     * @param exchange the exchange to make available\n     * @param map      the map to populate\n     */\n    public static void populateVariableMap(Exchange exchange, Map<String, Object> map) {\n        map.put(\"exchange\", exchange);\n        Message in = exchange.getIn();\n        map.put(\"in\", in);\n        map.put(\"request\", in);\n        map.put(\"headers\", in.getHeaders());\n        map.put(\"body\", in.getBody());\n        if (isOutCapable(exchange)) {\n            // if we are out capable then set out and response as well\n            // however only grab OUT if it exists, otherwise reuse IN\n            // this prevents side effects to alter the Exchange if we force creating an OUT message\n            Message msg = exchange.hasOut() ? exchange.getOut() : exchange.getIn();\n            map.put(\"out\", msg);\n            map.put(\"response\", msg);\n        }\n        map.put(\"camelContext\", exchange.getContext());\n    }","commit_id":"96c71cf059bea96da948a22050c09bf83bdc972c","url":"https://github.com/apache/camel"},{"original_method":"public void populateRestletResponseFromExchange(Exchange exchange, Response response) throws Exception {\n        Message out;\n        if (exchange.isFailed()) {\n            // 500 for internal server error which can be overridden by response code in header\n            response.setStatus(Status.valueOf(500));\n            if (exchange.hasOut() && exchange.getOut().isFault()) {\n                out = exchange.getOut();\n            } else {\n                // print exception as message and stacktrace\n                Exception t = exchange.getException();\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                t.printStackTrace(pw);\n                response.setEntity(sw.toString(), MediaType.TEXT_PLAIN);\n                return;\n            }\n        } else {\n            out = exchange.getOut();\n        }\n\n        // get content type\n        MediaType mediaType = out.getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            Object body = out.getBody();\n            mediaType = MediaType.TEXT_PLAIN;\n            if (body instanceof String) {\n                mediaType = MediaType.TEXT_PLAIN;\n            } else if (body instanceof StringSource || body instanceof DOMSource) {\n                mediaType = MediaType.TEXT_XML;\n            }\n        }\n\n        // get response code\n        Integer responseCode = out.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class);\n        if (responseCode != null) {\n            response.setStatus(Status.valueOf(responseCode));\n        }\n\n        // set response body according to the message body\n        Object body = out.getBody();\n        if (body instanceof WrappedFile) {\n            // grab body from generic file holder\n            GenericFile<?> gf = (GenericFile<?>) body;\n            body = gf.getBody();\n        }\n\n        if (body == null) {\n            // empty response\n            response.setEntity(\"\", MediaType.TEXT_PLAIN);\n        } else if (body instanceof Response) {\n            // its already a restlet response, so dont do anything\n            LOG.debug(\"Using existing Restlet Response from exchange body: {}\", body);\n        } else if (body instanceof InputStream) {\n            response.setEntity(new InputRepresentation(out.getBody(InputStream.class), mediaType));\n        } else if (body instanceof File) {\n            response.setEntity(new FileRepresentation(out.getBody(File.class), mediaType));\n        } else {\n            // fallback and use string\n            String text = out.getBody(String.class);\n            response.setEntity(text, mediaType);\n        }\n        LOG.debug(\"Populate Restlet response from exchange body: {}\", body);\n\n        if (exchange.getProperty(Exchange.CHARSET_NAME) != null) {\n            CharacterSet cs = CharacterSet.valueOf(exchange.getProperty(Exchange.CHARSET_NAME, String.class));\n            response.getEntity().setCharacterSet(cs);\n        }\n\n        // set headers at the end, as the entity must be set first\n        for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                setResponseHeader(exchange, response, key, value);\n                LOG.debug(\"Populate Restlet HTTP header in response from exchange header: {} value: {}\", key, value);\n            }\n        }\n    }","id":85001,"modified_method":"public void populateRestletResponseFromExchange(Exchange exchange, Response response) throws Exception {\n        Message out;\n        if (exchange.isFailed()) {\n            // 500 for internal server error which can be overridden by response code in header\n            response.setStatus(Status.valueOf(500));\n            if (exchange.hasOut() && exchange.getOut().isFault()) {\n                out = exchange.getOut();\n            } else {\n                // print exception as message and stacktrace\n                Exception t = exchange.getException();\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                t.printStackTrace(pw);\n                response.setEntity(sw.toString(), MediaType.TEXT_PLAIN);\n                return;\n            }\n        } else {\n            out = exchange.hasOut() ? exchange.getOut() : exchange.getIn();\n        }\n\n        // get content type\n        MediaType mediaType = out.getHeader(Exchange.CONTENT_TYPE, MediaType.class);\n        if (mediaType == null) {\n            Object body = out.getBody();\n            mediaType = MediaType.TEXT_PLAIN;\n            if (body instanceof String) {\n                mediaType = MediaType.TEXT_PLAIN;\n            } else if (body instanceof StringSource || body instanceof DOMSource) {\n                mediaType = MediaType.TEXT_XML;\n            }\n        }\n\n        // get response code\n        Integer responseCode = out.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class);\n        if (responseCode != null) {\n            response.setStatus(Status.valueOf(responseCode));\n        }\n\n        // set response body according to the message body\n        Object body = out.getBody();\n        if (body instanceof WrappedFile) {\n            // grab body from generic file holder\n            GenericFile<?> gf = (GenericFile<?>) body;\n            body = gf.getBody();\n        }\n\n        if (body == null) {\n            // empty response\n            response.setEntity(\"\", MediaType.TEXT_PLAIN);\n        } else if (body instanceof Response) {\n            // its already a restlet response, so dont do anything\n            LOG.debug(\"Using existing Restlet Response from exchange body: {}\", body);\n        } else if (body instanceof InputStream) {\n            response.setEntity(new InputRepresentation(out.getBody(InputStream.class), mediaType));\n        } else if (body instanceof File) {\n            response.setEntity(new FileRepresentation(out.getBody(File.class), mediaType));\n        } else {\n            // fallback and use string\n            String text = out.getBody(String.class);\n            response.setEntity(text, mediaType);\n        }\n        LOG.debug(\"Populate Restlet response from exchange body: {}\", body);\n\n        if (exchange.getProperty(Exchange.CHARSET_NAME) != null) {\n            CharacterSet cs = CharacterSet.valueOf(exchange.getProperty(Exchange.CHARSET_NAME, String.class));\n            response.getEntity().setCharacterSet(cs);\n        }\n\n        // set headers at the end, as the entity must be set first\n        for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {\n            String key = entry.getKey();\n            Object value = entry.getValue();\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {\n                setResponseHeader(exchange, response, key, value);\n                LOG.debug(\"Populate Restlet HTTP header in response from exchange header: {} value: {}\", key, value);\n            }\n        }\n    }","commit_id":"9ea0a2725392f0869924c8d3b8116494b4108583","url":"https://github.com/apache/camel"},{"original_method":"public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        if (camelExchange.isFailed()) {\n            throw camelExchange.getException();\n        }\n        \n        return camelExchange.getOut().getBody();\n    }","id":85002,"modified_method":"public Object populateCxfRsResponseFromExchange(Exchange camelExchange,\n                                                    org.apache.cxf.message.Exchange cxfExchange) throws Exception {\n        if (camelExchange.isFailed()) {\n            throw camelExchange.getException();\n        }\n\n        org.apache.camel.Message response;\n        if (camelExchange.getPattern().isOutCapable()) {\n            if (camelExchange.hasOut()) {\n                response = camelExchange.getOut();\n                LOG.trace(\"Get the response from the out message\");\n            } else {\n                response = camelExchange.getIn();\n                LOG.trace(\"Get the response from the in message as a fallback\");\n            }\n        } else {\n            response = camelExchange.getIn();\n            LOG.trace(\"Get the response from the in message\");\n        }\n\n        return response.getBody();\n    }","commit_id":"fffd1393bda6bbc01b43514f6fde2279829a9b0d","url":"https://github.com/apache/camel"},{"original_method":"@Override\n        protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            final PathAddress address = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR));\n\n            final Resource web = context.readResourceFromRoot(address.subAddress(0, address.size()), false);\n            final ModelNode subModel = web.getModel();\n\n            final String host = VIRTUAL_HOST.resolveModelAttribute(context, subModel).asString();\n            final String path = CONTEXT_ROOT.resolveModelAttribute(context, subModel).asString();\n\n            final ServiceController<?> controller = context.getServiceRegistry(false).getService(UndertowService.deploymentServiceName(host, path));\n\n            SessionStat stat = SessionStat.getStat(operation.require(ModelDescriptionConstants.NAME).asString());\n\n            if (stat == null) {\n                context.getFailureDescription().set(UndertowMessages.MESSAGES.unknownMetric(operation.require(ModelDescriptionConstants.NAME).asString()));\n            } else {\n                context.getResult().set(\"<not implemented>\");\n                /*final Context webContext = Context.class.cast(controller.getValue());\n                ManagerBase sm = (ManagerBase) webContext.getManager();\n                ModelNode result = new ModelNode();\n                switch (stat) {\n                    case ACTIVE_SESSIONS:\n                        result.set(sm.getActiveSessions());\n                        break;\n                    case EXPIRED_SESSIONS:\n                        result.set(sm.getExpiredSessions());\n                        break;\n                    case MAX_ACTIVE_SESSIONS:\n                        result.set(sm.getMaxActive());\n                        break;\n                    case SESSIONS_CREATED:\n                        result.set(sm.getSessionCounter());\n                        break;\n                    case DUPLICATED_SESSION_IDS:\n                        result.set(sm.getDuplicates());\n                        break;\n                    case SESSION_AVG_ALIVE_TIME:\n                        result.set(sm.getSessionAverageAliveTime());\n                        break;\n                    case SESSION_MAX_ALIVE_TIME:\n                        result.set(sm.getSessionMaxAliveTime());\n                        break;\n                    case REJECTED_SESSIONS:\n                        result.set(sm.getRejectedSessions());\n                        break;\n                    default:\n                        throw new IllegalStateException(WebMessages.MESSAGES.unknownMetric(stat));\n                }\n                context.getResult().set(result);*/\n            }\n\n            context.stepCompleted();\n        }","id":85003,"modified_method":"@Override\n        protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            final PathAddress address = PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR));\n\n            final Resource web = context.readResourceFromRoot(address.subAddress(0, address.size()), false);\n            final ModelNode subModel = web.getModel();\n\n            final String host = VIRTUAL_HOST.resolveModelAttribute(context, subModel).asString();\n            final String path = CONTEXT_ROOT.resolveModelAttribute(context, subModel).asString();\n            final String server = SERVER.resolveModelAttribute(context, subModel).asString();\n\n            final ServiceController<?> controller = context.getServiceRegistry(false).getService(UndertowService.deploymentServiceName(server, host, path));\n\n            SessionStat stat = SessionStat.getStat(operation.require(ModelDescriptionConstants.NAME).asString());\n\n            if (stat == null) {\n                context.getFailureDescription().set(UndertowMessages.MESSAGES.unknownMetric(operation.require(ModelDescriptionConstants.NAME).asString()));\n            } else {\n                context.getResult().set(\"<not implemented>\");\n                /*final Context webContext = Context.class.cast(controller.getValue());\n                ManagerBase sm = (ManagerBase) webContext.getManager();\n                ModelNode result = new ModelNode();\n                switch (stat) {\n                    case ACTIVE_SESSIONS:\n                        result.set(sm.getActiveSessions());\n                        break;\n                    case EXPIRED_SESSIONS:\n                        result.set(sm.getExpiredSessions());\n                        break;\n                    case MAX_ACTIVE_SESSIONS:\n                        result.set(sm.getMaxActive());\n                        break;\n                    case SESSIONS_CREATED:\n                        result.set(sm.getSessionCounter());\n                        break;\n                    case DUPLICATED_SESSION_IDS:\n                        result.set(sm.getDuplicates());\n                        break;\n                    case SESSION_AVG_ALIVE_TIME:\n                        result.set(sm.getSessionAverageAliveTime());\n                        break;\n                    case SESSION_MAX_ALIVE_TIME:\n                        result.set(sm.getSessionMaxAliveTime());\n                        break;\n                    case REJECTED_SESSIONS:\n                        result.set(sm.getRejectedSessions());\n                        break;\n                    default:\n                        throw new IllegalStateException(WebMessages.MESSAGES.unknownMetric(stat));\n                }\n                context.getResult().set(result);*/\n            }\n\n            context.stepCompleted();\n        }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"public HttpHandler createHttpHandler(HttpHandler next) {\n        Class<? extends HttpHandler> handlerClass = handler.getHandlerClass();\n        List<AttributeDefinition> attributes = new ArrayList<>(handler.getAttributes());\n        int numOfParams = attributes.size() + 1;\n        try {\n            for (Constructor<?> c : handlerClass.getDeclaredConstructors()) {\n                if (c.getParameterTypes().length == numOfParams) {\n                    Object[] params = new Object[numOfParams];\n                    Class[] parameterTypes = c.getParameterTypes();\n                    for (int i = 0; i < parameterTypes.length; i++) {\n                        Class param = parameterTypes[i];\n                        if (param == String.class) {\n                            params[i] = model.get(attributes.get(i).getName()).asString();\n                        } else if (param == Integer.class || param == int.class) {\n                            params[i] = model.get(attributes.get(i).getName()).asInt();\n                        } else if (param == Long.class || param == long.class) {\n                            params[i] = model.get(attributes.get(i).getName()).asLong();\n                        } else if (param == HttpHandler.class) {\n                            params[i] = next;\n                        }\n                    }\n                    return (HttpHandler) c.newInstance(params);\n                }\n            }\n        } catch (Throwable e) {\n            throw UndertowMessages.MESSAGES.cannotCreateHttpHandler(handlerClass, model, e);\n        }\n        throw UndertowMessages.MESSAGES.cannotCreateHttpHandler(handlerClass, model, null);\n    }","id":85004,"modified_method":"public HttpHandler createHttpHandler(HttpHandler next) {\n        Class<? extends HttpHandler> handlerClass = handler.getHandlerClass();\n        List<AttributeDefinition> attributes = new ArrayList<>(handler.getAttributes());\n        int numOfParams = attributes.size() + 1;\n        try {\n            for (Constructor<?> c : handlerClass.getDeclaredConstructors()) {\n                if (c.getParameterTypes().length == numOfParams) {\n                    Object[] params = new Object[numOfParams];\n                    Class[] parameterTypes = c.getParameterTypes();\n                    int attrCounter = 0;\n                    for (int i = 0; i < parameterTypes.length; i++) {\n                        Class param = parameterTypes[i];\n                        if (param == String.class) {\n                            params[i] = model.get(attributes.get(attrCounter).getName()).asString();\n                            attrCounter++;\n                        } else if (param == Integer.class || param == int.class) {\n                            params[i] = model.get(attributes.get(attrCounter).getName()).asInt();\n                            attrCounter++;\n                        } else if (param == Long.class || param == long.class) {\n                            params[i] = model.get(attributes.get(attrCounter).getName()).asLong();\n                            attrCounter++;\n                        } else if (param == HttpHandler.class) {\n                            params[i] = next;\n                        }\n                    }\n                    return (HttpHandler) c.newInstance(params);\n                }\n            }\n        } catch (Throwable e) {\n            throw UndertowMessages.MESSAGES.cannotCreateHttpHandler(handlerClass, model, e);\n        }\n        throw UndertowMessages.MESSAGES.cannotCreateHttpHandler(handlerClass, model, null);\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathAddress parent = address.subAddress(0, address.size() - 1);\n        final String name = address.getLastElement().getValue();\n        List<String> aliases = HostDefinition.ALIAS.unwrap(context, model);\n        String defaultWebModule = HostDefinition.DEFAULT_WEB_MODULE.resolveModelAttribute(context, model).asString();\n        Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS);\n        Resource accessLog = resource.getChild(UndertowExtension.PATH_ACCESS_LOG);\n\n        final String serverName = parent.getLastElement().getValue();\n        final ServiceName virtualHostServiceName = UndertowService.virtualHostName(serverName, name);\n        final ServiceName accessLogServiceName = UndertowService.accessLogServiceName(serverName, name);\n        Host service = new Host(name, aliases == null ? new LinkedList<String>() : aliases, defaultWebModule);\n        final ServiceBuilder<Host> builder = context.getServiceTarget().addService(virtualHostServiceName, service)\n                .addDependency(UndertowService.SERVER.append(serverName), Server.class, service.getServerInjection())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, service.getUndertowService())\n                .addDependency(accessLog != null ? REQUIRED : OPTIONAL, accessLogServiceName, AccessLogService.class, service.getAccessLogService());\n\n        builder.addListener(verificationHandler);\n        builder.setInitialMode(Mode.ON_DEMAND);\n\n\n        final ServiceController<WebHost> commonController = addCommonHost(context, verificationHandler, name, aliases, serverName, virtualHostServiceName);\n\n        final ServiceController<Host> serviceController = builder.install();\n\n        // Setup the web console redirect\n        final ServiceName consoleRedirectName = UndertowService.consoleRedirectServiceName(serverName, name);\n        final ServiceController<ConsoleRedirectService> consoleServiceServiceController;\n        // A standalone server is the only process type with a console redirect\n        if (context.getProcessType() == ProcessType.STANDALONE_SERVER) {\n            final ConsoleRedirectService redirectService = new ConsoleRedirectService();\n            final ServiceBuilder<ConsoleRedirectService> redirectBuilder = context.getServiceTarget().addService(consoleRedirectName, redirectService)\n                    .addDependency(UndertowHttpManagementService.SERVICE_NAME, HttpManagement.class, redirectService.getHttpManagementInjector())\n                    .addDependency(virtualHostServiceName, Host.class, redirectService.getHostInjector())\n                    .setInitialMode(Mode.PASSIVE);\n            consoleServiceServiceController = redirectBuilder.install();\n        } else {\n            // Other process types don't have a console, not depending on the UndertowHttpManagementService should\n            // result in a null dependency in the service and redirect accordingly\n            final ConsoleRedirectService redirectService = new ConsoleRedirectService();\n            final ServiceBuilder<ConsoleRedirectService> redirectBuilder = context.getServiceTarget().addService(consoleRedirectName, redirectService)\n                    .addDependency(virtualHostServiceName, Host.class, redirectService.getHostInjector())\n                    .setInitialMode(Mode.PASSIVE);\n            consoleServiceServiceController = redirectBuilder.install();\n        }\n\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n            newControllers.add(consoleServiceServiceController);\n            newControllers.add(commonController);\n        }\n    }","id":85005,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathAddress serverAddress = address.subAddress(0, address.size() - 1);\n        final PathAddress subsystemAddress = serverAddress.subAddress(0, address.size() - 1);\n        final ModelNode subsystemModel = Resource.Tools.readModel(context.readResourceFromRoot(subsystemAddress));\n\n\n        final String name = address.getLastElement().getValue();\n        final List<String> aliases = HostDefinition.ALIAS.unwrap(context, model);\n        final String defaultWebModule = HostDefinition.DEFAULT_WEB_MODULE.resolveModelAttribute(context, model).asString();\n        final Resource resource = context.readResource(PathAddress.EMPTY_ADDRESS);\n        final Resource accessLog = resource.getChild(UndertowExtension.PATH_ACCESS_LOG);\n        final String defaultServerName = UndertowRootDefinition.DEFAULT_SERVER.resolveModelAttribute(context,subsystemModel).asString();\n        final String serverName = serverAddress.getLastElement().getValue();\n\n        boolean installCommonHost = defaultServerName.equals(serverName);\n\n\n        final ServiceName virtualHostServiceName = UndertowService.virtualHostName(serverName, name);\n        final ServiceName accessLogServiceName = UndertowService.accessLogServiceName(serverName, name);\n        Host service = new Host(name, aliases == null ? new LinkedList<String>() : aliases, defaultWebModule);\n        final ServiceBuilder<Host> builder = context.getServiceTarget().addService(virtualHostServiceName, service)\n                .addDependency(UndertowService.SERVER.append(serverName), Server.class, service.getServerInjection())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, service.getUndertowService())\n                .addDependency(accessLog != null ? REQUIRED : OPTIONAL, accessLogServiceName, AccessLogService.class, service.getAccessLogService());\n\n        builder.addListener(verificationHandler);\n        builder.setInitialMode(Mode.ON_DEMAND);\n\n\n        final ServiceController<WebHost> commonController = null;\n        if (installCommonHost){\n            addCommonHost(context, verificationHandler, name, aliases, serverName, virtualHostServiceName);\n        }\n\n        final ServiceController<Host> serviceController = builder.install();\n\n        // Setup the web console redirect\n        final ServiceName consoleRedirectName = UndertowService.consoleRedirectServiceName(serverName, name);\n        final ServiceController<ConsoleRedirectService> consoleServiceServiceController;\n        // A standalone server is the only process type with a console redirect\n        if (context.getProcessType() == ProcessType.STANDALONE_SERVER) {\n            final ConsoleRedirectService redirectService = new ConsoleRedirectService();\n            final ServiceBuilder<ConsoleRedirectService> redirectBuilder = context.getServiceTarget().addService(consoleRedirectName, redirectService)\n                    .addDependency(UndertowHttpManagementService.SERVICE_NAME, HttpManagement.class, redirectService.getHttpManagementInjector())\n                    .addDependency(virtualHostServiceName, Host.class, redirectService.getHostInjector())\n                    .setInitialMode(Mode.PASSIVE);\n            consoleServiceServiceController = redirectBuilder.install();\n        } else {\n            // Other process types don't have a console, not depending on the UndertowHttpManagementService should\n            // result in a null dependency in the service and redirect accordingly\n            final ConsoleRedirectService redirectService = new ConsoleRedirectService();\n            final ServiceBuilder<ConsoleRedirectService> redirectBuilder = context.getServiceTarget().addService(consoleRedirectName, redirectService)\n                    .addDependency(virtualHostServiceName, Host.class, redirectService.getHostInjector())\n                    .setInitialMode(Mode.PASSIVE);\n            consoleServiceServiceController = redirectBuilder.install();\n        }\n\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n            newControllers.add(consoleServiceServiceController);\n            if (installCommonHost){\n                newControllers.add(commonController);\n            }\n        }\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathAddress parent = address.subAddress(0, address.size() - 1);\n        String name = address.getLastElement().getValue();\n        String bindingRef = ListenerResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context, model).asString();\n        String workerName = ListenerResourceDefinition.WORKER.resolveModelAttribute(context, model).asString();\n        String bufferPoolName = ListenerResourceDefinition.BUFFER_POOL.resolveModelAttribute(context, model).asString();\n        boolean enabled = ListenerResourceDefinition.ENABLED.resolveModelAttribute(context, model).asBoolean();\n        OptionMap options = OptionList.resolveOptions(context, model, ListenerResourceDefinition.OPTIONS);\n        String serverName = parent.getLastElement().getValue();\n        final ListenerService<? extends ListenerService> service = createService(name, serverName, context, model, options);\n        final ServiceBuilder<? extends ListenerService> serviceBuilder = context.getServiceTarget().addService(constructServiceName(name), service);\n        serviceBuilder.addDependency(IOServices.WORKER.append(workerName), XnioWorker.class, service.getWorker())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(bindingRef), SocketBinding.class, service.getBinding())\n                .addDependency(IOServices.BUFFER_POOL.append(bufferPoolName), Pool.class, service.getBufferPool())\n                .addDependency(UndertowService.SERVER.append(serverName), Server.class, service.getServerService());\n\n        configureAdditionalDependencies(context, serviceBuilder, model, service);\n        serviceBuilder.setInitialMode(enabled ? ServiceController.Mode.ACTIVE : ServiceController.Mode.NEVER);\n\n        serviceBuilder.addListener(verificationHandler);\n        final ServiceController<? extends ListenerService> serviceController = serviceBuilder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n    }","id":85006,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathAddress parent = address.subAddress(0, address.size() - 1);\n        String name = address.getLastElement().getValue();\n        String bindingRef = ListenerResourceDefinition.SOCKET_BINDING.resolveModelAttribute(context, model).asString();\n        String workerName = ListenerResourceDefinition.WORKER.resolveModelAttribute(context, model).asString();\n        String bufferPoolName = ListenerResourceDefinition.BUFFER_POOL.resolveModelAttribute(context, model).asString();\n        boolean enabled = ListenerResourceDefinition.ENABLED.resolveModelAttribute(context, model).asBoolean();\n        OptionMap options = OptionList.resolveOptions(context, model, ListenerResourceDefinition.OPTIONS);\n        String serverName = parent.getLastElement().getValue();\n        final ServiceName listenerServiceName = UndertowService.listenerName(name);\n        final ListenerService<? extends ListenerService> service = createService(name, serverName, context, model, options);\n        final ServiceBuilder<? extends ListenerService> serviceBuilder = context.getServiceTarget().addService(listenerServiceName, service);\n        serviceBuilder.addDependency(IOServices.WORKER.append(workerName), XnioWorker.class, service.getWorker())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(bindingRef), SocketBinding.class, service.getBinding())\n                .addDependency(IOServices.BUFFER_POOL.append(bufferPoolName), Pool.class, service.getBufferPool())\n                .addDependency(UndertowService.SERVER.append(serverName), Server.class, service.getServerService());\n\n        configureAdditionalDependencies(context, serviceBuilder, model, service);\n        serviceBuilder.setInitialMode(enabled ? ServiceController.Mode.ACTIVE : ServiceController.Mode.NEVER);\n\n        serviceBuilder.addListener(verificationHandler);\n        final ServiceController<? extends ListenerService> serviceController = serviceBuilder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"ListenerRemoveHandler(ListenerAdd addOperation) {\n        super(addOperation);\n        this.listenerAddHandler = addOperation;\n    }","id":85007,"modified_method":"ListenerRemoveHandler(ListenerAdd addOperation) {\n        super(addOperation);\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected ServiceName serviceName(String name) {\n        return listenerAddHandler.constructServiceName(name);\n    }","id":85008,"modified_method":"@Override\n    protected ServiceName serviceName(String name) {\n        return UndertowService.listenerName(name);\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ResponseHeaderHandler() {\n        super(\"response-header\");\n    }","id":85009,"modified_method":"private ResponseHeaderHandler() {\n        super(\"response-header\");\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Class<? extends HttpHandler> getHandlerClass() {\n        return null;\n    }","id":85010,"modified_method":"@Override\n    public Class<? extends HttpHandler> getHandlerClass() {\n        return SetHeaderHandler.class;\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final String defaultHost = ServerDefinition.DEFAULT_HOST.resolveModelAttribute(context, model).asString();\n        final String servletContainer = ServerDefinition.SERVLET_CONTAINER.resolveModelAttribute(context, model).asString();\n\n        final ServiceName serverName = UndertowService.SERVER.append(name);\n        final Server service = new Server(name, defaultHost);\n        final ServiceBuilder<Server> builder = context.getServiceTarget().addService(serverName, service)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(servletContainer), ServletContainerService.class, service.getServletContainer())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, service.getUndertowService());\n\n        builder.setInitialMode(ServiceController.Mode.ACTIVE);\n        builder.addListener(verificationHandler);\n        final ServiceController<Server> serviceController = builder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n        WebServerService commonWebServer = new WebServerService();\n        final ServiceBuilder<WebServerService> commonServerBuilder = context.getServiceTarget().addService(CommonWebServer.SERVICE_NAME, commonWebServer)\n                .addDependency(serverName, Server.class, commonWebServer.getServerInjectedValue())\n                .setInitialMode(ServiceController.Mode.PASSIVE);\n\n\n        addCommonHostListenerDeps(context, commonServerBuilder, UndertowExtension.HTTP_LISTENER_PATH);\n        addCommonHostListenerDeps(context, commonServerBuilder, UndertowExtension.AJP_LISTENER_PATH);\n        addCommonHostListenerDeps(context, commonServerBuilder, UndertowExtension.HTTPS_LISTENER_PATH);\n\n        final ServiceController<WebServerService> commonServerController = commonServerBuilder.install();\n\n        if (verificationHandler != null) {\n            commonServerController.addListener(verificationHandler);\n        }\n        if (newControllers != null) {\n            newControllers.add(commonServerController);\n        }\n    }","id":85011,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final PathAddress parentAddress = address.subAddress(0, address.size() - 1);\n        final ModelNode subsystemModel = Resource.Tools.readModel(context.readResourceFromRoot(parentAddress));\n\n        final String name = address.getLastElement().getValue();\n        final String defaultHost = ServerDefinition.DEFAULT_HOST.resolveModelAttribute(context, model).asString();\n        final String servletContainer = ServerDefinition.SERVLET_CONTAINER.resolveModelAttribute(context, model).asString();\n        final String defaultServerName = UndertowRootDefinition.DEFAULT_SERVER.resolveModelAttribute(context,subsystemModel).asString();\n\n        final ServiceName serverName = UndertowService.SERVER.append(name);\n        final Server service = new Server(name, defaultHost);\n        final ServiceBuilder<Server> builder = context.getServiceTarget().addService(serverName, service)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(servletContainer), ServletContainerService.class, service.getServletContainer())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, service.getUndertowService());\n\n        builder.setInitialMode(ServiceController.Mode.ACTIVE);\n        builder.addListener(verificationHandler);\n        final ServiceController<Server> serviceController = builder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n        if (name.equals(defaultServerName)) { //only install for default server\n            WebServerService commonWebServer = new WebServerService();\n            final ServiceBuilder<WebServerService> commonServerBuilder = context.getServiceTarget().addService(CommonWebServer.SERVICE_NAME, commonWebServer)\n                    .addDependency(serverName, Server.class, commonWebServer.getServerInjectedValue())\n                    .setInitialMode(ServiceController.Mode.PASSIVE);\n\n            addCommonHostListenerDeps(context, commonServerBuilder, UndertowExtension.HTTP_LISTENER_PATH);\n            addCommonHostListenerDeps(context, commonServerBuilder, UndertowExtension.AJP_LISTENER_PATH);\n            addCommonHostListenerDeps(context, commonServerBuilder, UndertowExtension.HTTPS_LISTENER_PATH);\n\n            final ServiceController<WebServerService> commonServerController = commonServerBuilder.install();\n\n            if (verificationHandler != null) {\n                commonServerController.addListener(verificationHandler);\n            }\n            if (newControllers != null) {\n                newControllers.add(commonServerController);\n            }\n        }\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void addCommonHostListenerDeps(OperationContext context, ServiceBuilder<WebServerService> builder, final PathElement listenerPath) {\n        ModelNode listeners = Resource.Tools.readModel(context.readResource(PathAddress.pathAddress(listenerPath)), 1);\n        if (listeners.isDefined()) {\n            for (Property p : listeners.asPropertyList()) {\n                for (Property listener : p.getValue().asPropertyList()) {\n                    builder.addDependency(UndertowService.LISTENER.append(listener.getName()));\n                }\n            }\n        }\n    }","id":85012,"modified_method":"private void addCommonHostListenerDeps(OperationContext context, ServiceBuilder<WebServerService> builder, final PathElement listenerPath) {\n        ModelNode listeners = Resource.Tools.readModel(context.readResource(PathAddress.pathAddress(listenerPath)), 1);\n        if (listeners.isDefined()) {\n            for (Property p : listeners.asPropertyList()) {\n                for (Property listener : p.getValue().asPropertyList()) {\n                    builder.addDependency(UndertowService.listenerName(listener.getName()));\n                }\n            }\n        }\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void processDeployment(final WarMetaData warMetaData, final DeploymentUnit deploymentUnit, final ServiceTarget serviceTarget, String hostName)\n            throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        if (module == null) {\n            throw new DeploymentUnitProcessingException(MESSAGES.failedToResolveModule(deploymentUnit));\n        }\n        final JBossWebMetaData metaData = warMetaData.getMergedJBossWebMetaData();\n        final List<SetupAction> setupActions = deploymentUnit.getAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS);\n        metaData.resolveRunAs();\n\n        ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);\n\n        final Set<ServiceName> dependentComponents = new HashSet<>();\n        // see AS7-2077\n        // basically we want to ignore components that have failed for whatever reason\n        // if they are important they will be picked up when the web deployment actually starts\n        final List<ServiceName> components = deploymentUnit.getAttachmentList(WebComponentDescription.WEB_COMPONENTS);\n        final Set<ServiceName> failed = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.FAILED_COMPONENTS);\n        for (final ServiceName component : components) {\n            if (!failed.contains(component)) {\n                dependentComponents.add(component);\n            }\n        }\n\n        boolean componentRegistryExists = true;\n        ComponentRegistry componentRegistry = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY);\n        if (componentRegistry == null) {\n            componentRegistryExists = false;\n            //we do this to avoid lots of other null checks\n            //this will only happen if the EE subsystem is not installed\n            componentRegistry = new ComponentRegistry(null);\n        }\n\n        final WebInjectionContainer injectionContainer = new WebInjectionContainer(module.getClassLoader(), componentRegistry);\n\n        String securityContextId = deploymentUnit.getName();\n        if (deploymentUnit.getParent() != null) {\n            securityContextId = deploymentUnit.getParent().getName() + \"!\" + securityContextId;\n        }\n\n        final String pathName = pathNameOfDeployment(deploymentUnit, metaData);\n\n\n        String metaDataSecurityDomain = metaData.getSecurityDomain();\n        if (metaDataSecurityDomain == null) {\n            metaDataSecurityDomain = getJBossAppSecurityDomain(deploymentUnit);\n        }\n        if (metaDataSecurityDomain != null) {\n            metaDataSecurityDomain = metaDataSecurityDomain.trim();\n        }\n\n        String securityDomain = metaDataSecurityDomain == null ? SecurityConstants.DEFAULT_APPLICATION_POLICY : SecurityUtil\n                .unprefixSecurityDomain(metaDataSecurityDomain);\n\n        final ServiceName deploymentServiceName = UndertowService.deploymentServiceName(hostName,pathName);\n\n        final Set<ServiceName> additionalDependencies = new HashSet<>();\n        for(final SetupAction setupAction : setupActions) {\n            Set<ServiceName> dependencies = setupAction.dependencies();\n            if(dependencies != null) {\n                additionalDependencies.addAll(dependencies);\n            }\n        }\n        final ServiceName hostServiceName = UndertowService.virtualHostName(defaultServer, hostName);\n        TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        UndertowDeploymentInfoService undertowDeploymentInfoService = UndertowDeploymentInfoService.builder()\n                        .setAttributes(deploymentUnit.getAttachment(ServletContextAttribute.ATTACHMENT_KEY))\n                .setContextPath(pathName)\n                .setDeploymentName(deploymentUnit.getName())\n                .setDeploymentRoot(deploymentRoot)\n                .setMergedMetaData(warMetaData.getMergedJBossWebMetaData())\n                .setModule(module)\n                .setScisMetaData(scisMetaData)\n                .setSecurityContextId(securityContextId)\n                .setSecurityDomain(securityDomain)\n                .setSharedTlds(tldsMetaData == null ? Collections.<TldMetaData>emptyList() : tldsMetaData.getSharedTlds(deploymentUnit))\n                .setTldsMetaData(tldsMetaData)\n                .setSetupActions(setupActions)\n                .setOverlays(warMetaData.getOverlays())\n                .setExpressionFactoryWrappers(deploymentUnit.getAttachmentList(ExpressionFactoryWrapper.ATTACHMENT_KEY))\n                .setPredicatedHandlers(deploymentUnit.getAttachment(UndertowHandlersDeploymentProcessor.PREDICATED_HANDLERS))\n                .setExplodedDeployment(ExplodedDeploymentMarker.isExplodedDeployment(deploymentUnit))\n                .createUndertowDeploymentInfoService();\n\n        final ServiceName deploymentInfoServiceName = deploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);\n        ServiceBuilder<DeploymentInfo> infoBuilder = serviceTarget.addService(deploymentInfoServiceName, undertowDeploymentInfoService)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, undertowDeploymentInfoService.getContainer())\n                .addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomain), SecurityDomainContext.class, undertowDeploymentInfoService.getSecurityDomainContextValue())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowDeploymentInfoService.getUndertowService())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, undertowDeploymentInfoService.getPathManagerInjector())\n                .addDependency(hostServiceName, Host.class, undertowDeploymentInfoService.getHost())\n                .addDependencies(additionalDependencies);\n\n        final Set<String> seenExecutors = new HashSet<String>();\n        if (metaData.getExecutorName() != null) {\n            final InjectedValue<Executor> executor = new InjectedValue<Executor>();\n            infoBuilder.addDependency(IOServices.WORKER.append(metaData.getExecutorName()), Executor.class, executor);\n            undertowDeploymentInfoService.addInjectedExecutor(metaData.getExecutorName(), executor);\n            seenExecutors.add(metaData.getExecutorName());\n        }\n        if (metaData.getServlets() != null) {\n            for (JBossServletMetaData servlet : metaData.getServlets()) {\n                if (servlet.getExecutorName() != null && !seenExecutors.contains(servlet.getExecutorName())) {\n                    final InjectedValue<Executor> executor = new InjectedValue<Executor>();\n                    infoBuilder.addDependency(IOServices.WORKER.append(servlet.getExecutorName()), Executor.class, executor);\n                    undertowDeploymentInfoService.addInjectedExecutor(servlet.getExecutorName(), executor);\n                    seenExecutors.add(servlet.getExecutorName());\n                }\n            }\n        }\n\n        if(componentRegistryExists) {\n            infoBuilder.addDependency(ComponentRegistry.serviceName(deploymentUnit), ComponentRegistry.class, undertowDeploymentInfoService.getComponentRegistryInjectedValue());\n        } else {\n            undertowDeploymentInfoService.getComponentRegistryInjectedValue().setValue(new ImmediateValue<>(componentRegistry));\n        }\n\n        if (metaData.getDistributable() != null) {\n            DistributableSessionManagerFactoryBuilder builder = new DistributableSessionManagerFactoryBuilderValue().getValue();\n            if (builder != null) {\n                ServiceName factoryName = deploymentServiceName.append(\"session\");\n                builder.buildDeploymentDependency(serviceTarget, factoryName, deploymentServiceName, module, metaData)\n                    .setInitialMode(Mode.ON_DEMAND)\n                    .install()\n                ;\n                infoBuilder.addDependency(factoryName, SessionManagerFactory.class, undertowDeploymentInfoService.getSessionManagerFactoryInjector());\n            } else {\n                UndertowLogger.ROOT_LOGGER.clusteringNotSupported();\n            }\n        }\n\n        infoBuilder.install();\n\n        final boolean isWebappBundle = deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST);\n\n        final UndertowDeploymentService service = new UndertowDeploymentService(injectionContainer, !isWebappBundle);\n        final ServiceBuilder<UndertowDeploymentService> builder = serviceTarget.addService(deploymentServiceName, service)\n                .addDependencies(dependentComponents)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, service.getContainer())\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(deploymentInfoServiceName, DeploymentInfo.class, service.getDeploymentInfoInjectedValue());\n\n        deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, deploymentServiceName);\n\n        // OSGi web applications are activated in {@link WebContextActivationProcessor} according to bundle lifecycle changes\n        if (isWebappBundle) {\n            UndertowDeploymentService.ContextActivatorImpl activator = new UndertowDeploymentService.ContextActivatorImpl(builder.install());\n            deploymentUnit.putAttachment(ContextActivator.ATTACHMENT_KEY, activator);\n            deploymentUnit.addToAttachmentList(Attachments.BUNDLE_ACTIVE_DEPENDENCIES, deploymentServiceName);\n        } else {\n            builder.install();\n        }\n\n        // Process the web related mgmt information\n        final ModelNode node = deploymentUnit.getDeploymentSubsystemModel(UndertowExtension.SUBSYSTEM_NAME);\n        node.get(DeploymentDefinition.CONTEXT_ROOT.getName()).set(\"\".equals(pathName) ? \"/\" : pathName);\n        node.get(DeploymentDefinition.VIRTUAL_HOST.getName()).set(hostName);\n        processManagement(deploymentUnit, metaData);\n    }","id":85013,"modified_method":"private void processDeployment(final WarMetaData warMetaData, final DeploymentUnit deploymentUnit, final ServiceTarget serviceTarget, String hostName)\n            throws DeploymentUnitProcessingException {\n        final VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        if (module == null) {\n            throw new DeploymentUnitProcessingException(MESSAGES.failedToResolveModule(deploymentUnit));\n        }\n        final JBossWebMetaData metaData = warMetaData.getMergedJBossWebMetaData();\n        final List<SetupAction> setupActions = deploymentUnit.getAttachmentList(org.jboss.as.ee.component.Attachments.WEB_SETUP_ACTIONS);\n        metaData.resolveRunAs();\n\n        ScisMetaData scisMetaData = deploymentUnit.getAttachment(ScisMetaData.ATTACHMENT_KEY);\n\n        final Set<ServiceName> dependentComponents = new HashSet<>();\n        // see AS7-2077\n        // basically we want to ignore components that have failed for whatever reason\n        // if they are important they will be picked up when the web deployment actually starts\n        final List<ServiceName> components = deploymentUnit.getAttachmentList(WebComponentDescription.WEB_COMPONENTS);\n        final Set<ServiceName> failed = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.FAILED_COMPONENTS);\n        for (final ServiceName component : components) {\n            if (!failed.contains(component)) {\n                dependentComponents.add(component);\n            }\n        }\n\n        boolean componentRegistryExists = true;\n        ComponentRegistry componentRegistry = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.COMPONENT_REGISTRY);\n        if (componentRegistry == null) {\n            componentRegistryExists = false;\n            //we do this to avoid lots of other null checks\n            //this will only happen if the EE subsystem is not installed\n            componentRegistry = new ComponentRegistry(null);\n        }\n\n        final WebInjectionContainer injectionContainer = new WebInjectionContainer(module.getClassLoader(), componentRegistry);\n\n        String securityContextId = deploymentUnit.getName();\n        if (deploymentUnit.getParent() != null) {\n            securityContextId = deploymentUnit.getParent().getName() + \"!\" + securityContextId;\n        }\n\n        final String pathName = pathNameOfDeployment(deploymentUnit, metaData);\n\n\n        String metaDataSecurityDomain = metaData.getSecurityDomain();\n        if (metaDataSecurityDomain == null) {\n            metaDataSecurityDomain = getJBossAppSecurityDomain(deploymentUnit);\n        }\n        if (metaDataSecurityDomain != null) {\n            metaDataSecurityDomain = metaDataSecurityDomain.trim();\n        }\n\n        String securityDomain = metaDataSecurityDomain == null ? SecurityConstants.DEFAULT_APPLICATION_POLICY : SecurityUtil\n                .unprefixSecurityDomain(metaDataSecurityDomain);\n\n        String serverInstanceName = metaData.getServerInstanceName() == null ? defaultServer : metaData.getServerInstanceName();\n        final ServiceName deploymentServiceName = UndertowService.deploymentServiceName(serverInstanceName, hostName,pathName);\n\n        final Set<ServiceName> additionalDependencies = new HashSet<>();\n        for(final SetupAction setupAction : setupActions) {\n            Set<ServiceName> dependencies = setupAction.dependencies();\n            if(dependencies != null) {\n                additionalDependencies.addAll(dependencies);\n            }\n        }\n\n        final ServiceName hostServiceName = UndertowService.virtualHostName(serverInstanceName, hostName);\n        TldsMetaData tldsMetaData = deploymentUnit.getAttachment(TldsMetaData.ATTACHMENT_KEY);\n        UndertowDeploymentInfoService undertowDeploymentInfoService = UndertowDeploymentInfoService.builder()\n                        .setAttributes(deploymentUnit.getAttachment(ServletContextAttribute.ATTACHMENT_KEY))\n                .setContextPath(pathName)\n                .setDeploymentName(deploymentUnit.getName())\n                .setDeploymentRoot(deploymentRoot)\n                .setMergedMetaData(warMetaData.getMergedJBossWebMetaData())\n                .setModule(module)\n                .setScisMetaData(scisMetaData)\n                .setSecurityContextId(securityContextId)\n                .setSecurityDomain(securityDomain)\n                .setSharedTlds(tldsMetaData == null ? Collections.<TldMetaData>emptyList() : tldsMetaData.getSharedTlds(deploymentUnit))\n                .setTldsMetaData(tldsMetaData)\n                .setSetupActions(setupActions)\n                .setOverlays(warMetaData.getOverlays())\n                .setExpressionFactoryWrappers(deploymentUnit.getAttachmentList(ExpressionFactoryWrapper.ATTACHMENT_KEY))\n                .setPredicatedHandlers(deploymentUnit.getAttachment(UndertowHandlersDeploymentProcessor.PREDICATED_HANDLERS))\n                .setExplodedDeployment(ExplodedDeploymentMarker.isExplodedDeployment(deploymentUnit))\n                .createUndertowDeploymentInfoService();\n\n        final ServiceName deploymentInfoServiceName = deploymentServiceName.append(UndertowDeploymentInfoService.SERVICE_NAME);\n        ServiceBuilder<DeploymentInfo> infoBuilder = serviceTarget.addService(deploymentInfoServiceName, undertowDeploymentInfoService)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, undertowDeploymentInfoService.getContainer())\n                .addDependency(SecurityDomainService.SERVICE_NAME.append(securityDomain), SecurityDomainContext.class, undertowDeploymentInfoService.getSecurityDomainContextValue())\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowDeploymentInfoService.getUndertowService())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, undertowDeploymentInfoService.getPathManagerInjector())\n                .addDependency(hostServiceName, Host.class, undertowDeploymentInfoService.getHost())\n                .addDependencies(additionalDependencies);\n\n        final Set<String> seenExecutors = new HashSet<String>();\n        if (metaData.getExecutorName() != null) {\n            final InjectedValue<Executor> executor = new InjectedValue<Executor>();\n            infoBuilder.addDependency(IOServices.WORKER.append(metaData.getExecutorName()), Executor.class, executor);\n            undertowDeploymentInfoService.addInjectedExecutor(metaData.getExecutorName(), executor);\n            seenExecutors.add(metaData.getExecutorName());\n        }\n        if (metaData.getServlets() != null) {\n            for (JBossServletMetaData servlet : metaData.getServlets()) {\n                if (servlet.getExecutorName() != null && !seenExecutors.contains(servlet.getExecutorName())) {\n                    final InjectedValue<Executor> executor = new InjectedValue<Executor>();\n                    infoBuilder.addDependency(IOServices.WORKER.append(servlet.getExecutorName()), Executor.class, executor);\n                    undertowDeploymentInfoService.addInjectedExecutor(servlet.getExecutorName(), executor);\n                    seenExecutors.add(servlet.getExecutorName());\n                }\n            }\n        }\n\n        if(componentRegistryExists) {\n            infoBuilder.addDependency(ComponentRegistry.serviceName(deploymentUnit), ComponentRegistry.class, undertowDeploymentInfoService.getComponentRegistryInjectedValue());\n        } else {\n            undertowDeploymentInfoService.getComponentRegistryInjectedValue().setValue(new ImmediateValue<>(componentRegistry));\n        }\n\n        if (metaData.getDistributable() != null) {\n            DistributableSessionManagerFactoryBuilder builder = new DistributableSessionManagerFactoryBuilderValue().getValue();\n            if (builder != null) {\n                ServiceName factoryName = deploymentServiceName.append(\"session\");\n                builder.buildDeploymentDependency(serviceTarget, factoryName, deploymentServiceName, module, metaData)\n                    .setInitialMode(Mode.ON_DEMAND)\n                    .install()\n                ;\n                infoBuilder.addDependency(factoryName, SessionManagerFactory.class, undertowDeploymentInfoService.getSessionManagerFactoryInjector());\n            } else {\n                UndertowLogger.ROOT_LOGGER.clusteringNotSupported();\n            }\n        }\n\n        infoBuilder.install();\n\n        final boolean isWebappBundle = deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST);\n\n        final UndertowDeploymentService service = new UndertowDeploymentService(injectionContainer, !isWebappBundle);\n        final ServiceBuilder<UndertowDeploymentService> builder = serviceTarget.addService(deploymentServiceName, service)\n                .addDependencies(dependentComponents)\n                .addDependency(UndertowService.SERVLET_CONTAINER.append(defaultContainer), ServletContainerService.class, service.getContainer())\n                .addDependency(hostServiceName, Host.class, service.getHost())\n                .addDependencies(deploymentUnit.getAttachmentList(Attachments.WEB_DEPENDENCIES))\n                .addDependency(deploymentInfoServiceName, DeploymentInfo.class, service.getDeploymentInfoInjectedValue());\n\n        deploymentUnit.addToAttachmentList(Attachments.DEPLOYMENT_COMPLETE_SERVICES, deploymentServiceName);\n\n        // OSGi web applications are activated in {@link WebContextActivationProcessor} according to bundle lifecycle changes\n        if (isWebappBundle) {\n            UndertowDeploymentService.ContextActivatorImpl activator = new UndertowDeploymentService.ContextActivatorImpl(builder.install());\n            deploymentUnit.putAttachment(ContextActivator.ATTACHMENT_KEY, activator);\n            deploymentUnit.addToAttachmentList(Attachments.BUNDLE_ACTIVE_DEPENDENCIES, deploymentServiceName);\n        } else {\n            builder.install();\n        }\n\n        // Process the web related mgmt information\n        final ModelNode node = deploymentUnit.getDeploymentSubsystemModel(UndertowExtension.SUBSYSTEM_NAME);\n        node.get(DeploymentDefinition.CONTEXT_ROOT.getName()).set(\"\".equals(pathName) ? \"/\" : pathName);\n        node.get(DeploymentDefinition.VIRTUAL_HOST.getName()).set(hostName);\n        node.get(DeploymentDefinition.SERVER.getName()).set(serverInstanceName);\n        processManagement(deploymentUnit, metaData);\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ServiceBuilder<?> build(ServiceTarget target, String connector) {\n        InjectedValue<ContainerEventHandler> eventHandler = new InjectedValue<>();\n        InjectedValue<UndertowService> undertowService = new InjectedValue<>();\n        @SuppressWarnings(\"rawtypes\")\n        InjectedValue<ListenerService> listener = new InjectedValue<>();\n        return target.addService(SERVICE_NAME, new UndertowEventHandlerAdapter(eventHandler, undertowService, listener))\n                .addDependency(ContainerEventHandlerService.SERVICE_NAME, ContainerEventHandler.class, eventHandler)\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowService)\n                .addDependency(UndertowService.LISTENER.append(connector), ListenerService.class, listener)\n        ;\n    }","id":85014,"modified_method":"@Override\n    public ServiceBuilder<?> build(ServiceTarget target, String connector) {\n        InjectedValue<ContainerEventHandler> eventHandler = new InjectedValue<>();\n        InjectedValue<UndertowService> undertowService = new InjectedValue<>();\n        @SuppressWarnings(\"rawtypes\")\n        InjectedValue<ListenerService> listener = new InjectedValue<>();\n        return target.addService(SERVICE_NAME, new UndertowEventHandlerAdapter(eventHandler, undertowService, listener))\n                .addDependency(ContainerEventHandlerService.SERVICE_NAME, ContainerEventHandler.class, eventHandler)\n                .addDependency(UndertowService.UNDERTOW, UndertowService.class, undertowService)\n                //todo this is wrong, it should be replaced with injecting server instead of directly listener\n                .addDependency(UndertowService.listenerName(connector), ListenerService.class, listener)\n        ;\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceName deploymentServiceName(final String virtualHost, final String contextPath) {\n        return WEB_DEPLOYMENT_BASE.append(virtualHost).append(\"\".equals(contextPath) ? \"/\" : contextPath);\n    }","id":85015,"modified_method":"public static ServiceName deploymentServiceName(final String serverName, final String virtualHost, final String contextPath) {\n        return WEB_DEPLOYMENT_BASE.append(serverName).append(virtualHost).append(\"\".equals(contextPath) ? \"/\" : contextPath);\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static ServiceName virtualHostName(final String server, final String virtualHost) {\n        return SERVER.append(server).append(Constants.HOST).append(virtualHost);\n    }","id":85016,"modified_method":"public static ServiceName virtualHostName(final String server, final String virtualHost) {\n        return SERVER.append(server).append(virtualHost);\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRuntime() throws Exception {\n        KernelServicesBuilder builder = createKernelServicesBuilder(new AdditionalInitialization() {\n        })\n                .setSubsystemXml(getSubsystemXml());\n        KernelServices mainServices = builder.build();\n        if (!mainServices.isSuccessfulBoot()) {\n            Assert.fail(mainServices.getBootError().toString());\n        }\n        ServiceController<FilterService> filter = (ServiceController<FilterService>) mainServices.getContainer().getService(UndertowService.FILTER.append(\"limit-connections\"));\n        filter.setMode(ServiceController.Mode.ACTIVE);\n        FilterService filterService = filter.getService().getValue();\n        HttpHandler result = filterService.createHttpHandler(new PathHandler());\n        Assert.assertNotNull(\"handler should have been created\", result);\n\n        final ServiceName locationServiceName = UndertowService.locationServiceName(\"default-server\", \"default-host\", \"/\");\n        ServiceController<LocationService> locationSC = (ServiceController<LocationService>) mainServices.getContainer().getService(locationServiceName);\n        Assert.assertNotNull(locationSC);\n        locationSC.setMode(ServiceController.Mode.ACTIVE);\n        LocationService locationService = locationSC.getValue();\n        Assert.assertNotNull(locationService);\n        /*FilterService injectedFilter = locationService.getFilterInjector().get(0).getValue();\n        Assert.assertNotNull(injectedFilter);\n        */filter.setMode(ServiceController.Mode.REMOVE);\n        final ServiceName jspServiceName = UndertowService.SERVLET_CONTAINER.append(\"default\");\n        ServiceController<ServletContainerService> jspServiceServiceController = (ServiceController<ServletContainerService>) mainServices.getContainer().getService(jspServiceName);\n        Assert.assertNotNull(jspServiceServiceController);\n        JSPConfig jspConfig = jspServiceServiceController.getService().getValue().getJspConfig();\n        Assert.assertNotNull(jspConfig);\n        Assert.assertNotNull(jspConfig.getJSPServletInfo());\n\n\n    }","id":85017,"modified_method":"@Test\n    public void testRuntime() throws Exception {\n        System.setProperty(\"server.data.dir\",System.getProperty(\"java.io.tmpdir\"));\n        System.setProperty(\"jboss.home.dir\",System.getProperty(\"java.io.tmpdir\"));\n        System.setProperty(\"jboss.home.dir\",System.getProperty(\"java.io.tmpdir\"));\n        System.setProperty(\"jboss.server.server.dir\",System.getProperty(\"java.io.tmpdir\"));\n        KernelServicesBuilder builder = createKernelServicesBuilder(new AdditionalInitialization() {\n            @Override\n            protected void addExtraServices(ServiceTarget target) {\n                super.addExtraServices(target);\n                target.addService(Services.JBOSS_SERVICE_MODULE_LOADER, new ServiceModuleLoader(null)).install();\n            }\n        })\n                .setSubsystemXml(getSubsystemXml());\n        KernelServices mainServices = builder.build();\n        if (!mainServices.isSuccessfulBoot()) {\n            Assert.fail(mainServices.getBootError().toString());\n        }\n        ServiceController<FilterService> connectionLimiter = (ServiceController<FilterService>) mainServices.getContainer().getService(UndertowService.FILTER.append(\"limit-connections\"));\n        connectionLimiter.setMode(ServiceController.Mode.ACTIVE);\n        FilterService connectionLimiterService = connectionLimiter.getService().getValue();\n        HttpHandler result = connectionLimiterService.createHttpHandler(new PathHandler());\n        Assert.assertNotNull(\"handler should have been created\", result);\n\n\n        ServiceController<FilterService> headersFilter = (ServiceController<FilterService>) mainServices.getContainer().getService(UndertowService.FILTER.append(\"headers\"));\n        headersFilter.setMode(ServiceController.Mode.ACTIVE);\n        FilterService headersService = headersFilter.getService().getValue();\n        HttpHandler headerHandler = headersService.createHttpHandler(new PathHandler());\n        Assert.assertNotNull(\"handler should have been created\", headerHandler);\n\n        final ServiceName locationServiceName = UndertowService.locationServiceName(\"default-server\", \"default-host\", \"/\");\n        ServiceController<LocationService> locationSC = (ServiceController<LocationService>) mainServices.getContainer().getService(locationServiceName);\n        Assert.assertNotNull(locationSC);\n        locationSC.setMode(ServiceController.Mode.ACTIVE);\n        LocationService locationService = locationSC.getValue();\n        Assert.assertNotNull(locationService);\n        connectionLimiter.setMode(ServiceController.Mode.REMOVE);\n        final ServiceName jspServiceName = UndertowService.SERVLET_CONTAINER.append(\"myContainer\");\n        ServiceController<ServletContainerService> jspServiceServiceController = (ServiceController<ServletContainerService>) mainServices.getContainer().getService(jspServiceName);\n        Assert.assertNotNull(jspServiceServiceController);\n        JSPConfig jspConfig = jspServiceServiceController.getService().getValue().getJspConfig();\n        Assert.assertNotNull(jspConfig);\n        Assert.assertNotNull(jspConfig.getJSPServletInfo());\n\n\n    }","commit_id":"faa0b324d1479eaeef0a31dc60d5cd44443e3963","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Convenience method for handler: return the value of the second input field.\n     *\n     * @param pipelineContext   pipeline context\n     * @return                  value to store in the second input field\n     */\n    public String getSecondValueUseFormat(PipelineContext pipelineContext) {\n        final String result;\n\n        final String typeName = getBuiltinTypeName();\n        if (\"dateTime\".equals(typeName)) {\n            // Format value specially\n\n            // Assume xs: prefix for default formats\n            final Map prefixToURIMap = new HashMap();\n            prefixToURIMap.put(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n\n            final NodeInfo boundNode = getBoundNode();\n            if (boundNode == null) {\n                result = null;\n            } else {\n                result = XPathCache.evaluateAsString(pipelineContext, boundNode,\n                        XFormsProperties.getTypeInputFormat(containingDocument, \"time\"),\n                        prefixToURIMap, getContextStack().getCurrentVariables(),\n                        XFormsContainingDocument.getFunctionLibrary(),\n                        getContextStack().getFunctionContext(), null, getLocationData());\n            }\n\n        } else {\n            // N/A\n            result = null;\n        }\n\n        return (result != null) ? result : \"\";\n    }","id":85018,"modified_method":"/**\n     * Convenience method for handler: return the value of the second input field.\n     *\n     * @param pipelineContext   pipeline context\n     * @return                  value to store in the second input field\n     */\n    public String getSecondValueUseFormat(PipelineContext pipelineContext) {\n        final String result;\n\n        final String typeName = getBuiltinTypeName();\n        if (\"dateTime\".equals(typeName)) {\n            // Format value specially\n\n            // Assume xs: prefix for default formats\n            final Map prefixToURIMap = new HashMap();\n            prefixToURIMap.put(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n\n            final NodeInfo boundNode = getBoundNode();\n            if (boundNode == null) {\n                result = null;\n            } else {\n\n                final String xpathExpression =\n                        \"if (. castable as xs:date) then format-date(xs:date(.), '\"\n                                + XFormsProperties.getTypeInputFormat(containingDocument, \"time\")\n                                + \"', 'en', (), ()) else .\";\n\n                result = XPathCache.evaluateAsString(pipelineContext, boundNode,\n                        xpathExpression,\n                        prefixToURIMap, getContextStack().getCurrentVariables(),\n                        XFormsContainingDocument.getFunctionLibrary(),\n                        getContextStack().getFunctionContext(), null, getLocationData());\n            }\n\n        } else {\n            // N/A\n            result = null;\n        }\n\n        return (result != null) ? result : \"\";\n    }","commit_id":"4f2e79b2a2d12ea2be7e2528b4e6152dbcf4e3e9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Convenience method for handler: return the value of the first input field.\n     *\n     * @param pipelineContext   pipeline context\n     * @return                  value to store in the first input field\n     */\n    public String getFirstValueUseFormat(PipelineContext pipelineContext) {\n        final String result;\n\n        final String typeName = getBuiltinTypeName();\n        if (\"date\".equals(typeName) || \"time\".equals(typeName) || \"dateTime\".equals(typeName)) {\n            // Format value specially\n\n            // Assume xs: prefix for default formats\n            final Map prefixToURIMap = new HashMap();\n            prefixToURIMap.put(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n\n            final NodeInfo boundNode = getBoundNode();\n            if (boundNode == null) {\n                result = null;\n            } else {\n                result = XPathCache.evaluateAsString(pipelineContext, boundNode,\n                        XFormsProperties.getTypeInputFormat(containingDocument, \"time\".equals(typeName) ? \"time\" : \"date\"),\n                        prefixToURIMap, getContextStack().getCurrentVariables(),\n                        XFormsContainingDocument.getFunctionLibrary(),\n                        getContextStack().getFunctionContext(), null, getLocationData());\n            }\n\n        } else {\n            // Regular case, use external value\n            result = getExternalValue(pipelineContext);\n        }\n\n        return (result != null) ? result : \"\";\n    }","id":85019,"modified_method":"/**\n     * Convenience method for handler: return the value of the first input field.\n     *\n     * @param pipelineContext   pipeline context\n     * @return                  value to store in the first input field\n     */\n    public String getFirstValueUseFormat(PipelineContext pipelineContext) {\n        final String result;\n\n        final String typeName = getBuiltinTypeName();\n        if (\"date\".equals(typeName) || \"time\".equals(typeName) || \"dateTime\".equals(typeName)) {\n            // Format value specially\n\n            // Assume xs: prefix for default formats\n            final Map prefixToURIMap = new HashMap();\n            prefixToURIMap.put(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n\n            final NodeInfo boundNode = getBoundNode();\n            if (boundNode == null) {\n                result = null;\n            } else {\n\n                final String xpathExpression =\n                        \"if (. castable as xs:date) then format-date(xs:date(.), '\"\n                                + XFormsProperties.getTypeInputFormat(containingDocument, \"time\".equals(typeName) ? \"time\" : \"date\")\n                                + \"', 'en', (), ()) else .\";\n\n                result = XPathCache.evaluateAsString(pipelineContext, boundNode,\n                        xpathExpression,\n                        prefixToURIMap, getContextStack().getCurrentVariables(),\n                        XFormsContainingDocument.getFunctionLibrary(),\n                        getContextStack().getFunctionContext(), null, getLocationData());\n            }\n\n        } else {\n            // Regular case, use external value\n            result = getExternalValue(pipelineContext);\n        }\n\n        return (result != null) ? result : \"\";\n    }","commit_id":"4f2e79b2a2d12ea2be7e2528b4e6152dbcf4e3e9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public int getIntegerProperty(String propertyName) {\n        final Integer documentProperty = (Integer) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null)\n            return documentProperty.intValue();\n        else\n            return ((Integer) (XFormsProperties.getPropertyDefinition(propertyName)).getDefaultValue()).intValue();\n    }","id":85020,"modified_method":"public int getIntegerProperty(String propertyName) {\n        final Integer documentProperty = (Integer) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null) {\n            return documentProperty.intValue();\n        } else {\n            final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(propertyName);\n            return ((Integer) propertyDefinition.getDefaultValue()).intValue();\n        }\n    }","commit_id":"4f2e79b2a2d12ea2be7e2528b4e6152dbcf4e3e9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public boolean getBooleanProperty(String propertyName) {\n        final Boolean documentProperty = (Boolean) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null)\n            return documentProperty.booleanValue();\n        else\n            return ((Boolean) (XFormsProperties.getPropertyDefinition(propertyName)).getDefaultValue()).booleanValue();\n    }","id":85021,"modified_method":"public boolean getBooleanProperty(String propertyName) {\n        final Boolean documentProperty = (Boolean) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null) {\n            return documentProperty.booleanValue();\n        } else {\n            final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(propertyName);\n            return ((Boolean) propertyDefinition.getDefaultValue()).booleanValue();\n        }\n    }","commit_id":"4f2e79b2a2d12ea2be7e2528b4e6152dbcf4e3e9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public String getStringProperty(String propertyName) {\n        final String documentProperty = (String) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null)\n            return documentProperty;\n        else\n            return (String) (XFormsProperties.getPropertyDefinition(propertyName)).getDefaultValue();\n    }","id":85022,"modified_method":"public String getStringProperty(String propertyName) {\n        final String documentProperty = (String) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null) {\n            return documentProperty;\n        } else {\n            final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(propertyName);\n            return (propertyDefinition != null) ? (String) propertyDefinition.getDefaultValue() : null; // may be null for example for type formats\n        }\n    }","commit_id":"4f2e79b2a2d12ea2be7e2528b4e6152dbcf4e3e9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public Object getProperty(String propertyName) {\n        final Object documentProperty = (Object) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null)\n            return documentProperty;\n        else\n            return XFormsProperties.getPropertyDefinition(propertyName).getDefaultValue();\n    }","id":85023,"modified_method":"public Object getProperty(String propertyName) {\n        final Object documentProperty = (Object) nonDefaultProperties.get(propertyName);\n        if (documentProperty != null) {\n            return documentProperty;\n        } else {\n            final XFormsProperties.PropertyDefinition propertyDefinition = XFormsProperties.getPropertyDefinition(propertyName);\n            return (propertyDefinition != null) ? propertyDefinition.getDefaultValue() : null; // may be null for example for type formats\n        }\n    }","commit_id":"4f2e79b2a2d12ea2be7e2528b4e6152dbcf4e3e9","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Generate a \"standard\" Orbeon text document.\n     *\n     * @param is                    InputStream to read from\n     * @param encoding              character encoding to use, or null for default\n     * @param output                output ContentHandler to write text document to\n     * @param contentType           optional content type to set as attribute on the root element\n     */\n    public static void readText(InputStream is, String encoding, ContentHandler output, String contentType, Long lastModified) {\n\n        if (encoding == null)\n            encoding = DEFAULT_TEXT_READING_ENCODING;\n\n        try {\n            // Create attributes for root element: xsi:type, and optional content-type\n            final AttributesImpl attributes = new AttributesImpl();\n            output.startPrefixMapping(XMLConstants.XSI_PREFIX, XMLConstants.XSI_URI);\n            output.startPrefixMapping(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n            attributes.addAttribute(XMLConstants.XSI_URI, \"type\", \"xsi:type\", \"CDATA\", XMLConstants.XS_STRING_QNAME.getQualifiedName());\n            if (contentType != null)\n                attributes.addAttribute(\"\", \"content-type\", \"content-type\", \"CDATA\", contentType);\n            if (lastModified != null)\n                attributes.addAttribute(\"\", \"last-modified\", \"last-modified\", \"CDATA\", ISODateUtils.getRFC1123Date(lastModified.longValue()));\n\n            // Write document\n            output.startDocument();\n            output.startElement(\"\", DEFAULT_TEXT_DOCUMENT_ELEMENT, DEFAULT_TEXT_DOCUMENT_ELEMENT, attributes);\n            XMLUtils.readerToCharacters(new InputStreamReader(is, encoding), output);\n            output.endElement(\"\", DEFAULT_TEXT_DOCUMENT_ELEMENT, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n            output.endDocument();\n\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":85024,"modified_method":"/**\n     * Generate a \"standard\" Orbeon text document.\n     *\n     * @param is                    InputStream to read from\n     * @param encoding              character encoding to use, or null for default\n     * @param output                output ContentHandler to write text document to\n     * @param contentType           optional content type to set as attribute on the root element\n     */\n    public static void readText(InputStream is, String encoding, ContentHandler output, String contentType, Long lastModified) {\n\n        if (encoding == null)\n            encoding = DEFAULT_TEXT_READING_ENCODING;\n\n        try {\n            // Create attributes for root element: xsi:type, and optional content-type\n            final AttributesImpl attributes = new AttributesImpl();\n            attributes.addAttribute(XMLConstants.XSI_URI, \"type\", \"xsi:type\", \"CDATA\", XMLConstants.XS_STRING_QNAME.getQualifiedName());\n            if (contentType != null)\n                attributes.addAttribute(\"\", \"content-type\", \"content-type\", \"CDATA\", contentType);\n            if (lastModified != null)\n                attributes.addAttribute(\"\", \"last-modified\", \"last-modified\", \"CDATA\", ISODateUtils.getRFC1123Date(lastModified.longValue()));\n\n            // Write document\n            output.startDocument();\n            output.startPrefixMapping(XMLConstants.XSI_PREFIX, XMLConstants.XSI_URI);\n            output.startPrefixMapping(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n            output.startElement(\"\", DEFAULT_TEXT_DOCUMENT_ELEMENT, DEFAULT_TEXT_DOCUMENT_ELEMENT, attributes);\n            XMLUtils.readerToCharacters(new InputStreamReader(is, encoding), output);\n            output.endElement(\"\", DEFAULT_TEXT_DOCUMENT_ELEMENT, DEFAULT_TEXT_DOCUMENT_ELEMENT);\n            output.endPrefixMapping(XMLConstants.XSD_PREFIX);\n            output.endPrefixMapping(XMLConstants.XSI_PREFIX);\n            output.endDocument();\n\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"de70c22713671f06f459d22bc72379242ad88eb6","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Generate a \"standard\" Orbeon binary document.\n     *\n     * @param is            InputStream to read from\n     * @param output        output ContentHandler to write binary document to\n     * @param contentType   optional content type to set as attribute on the root element\n     */\n    public static void readBinary(InputStream is, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            // Create attributes for root element: xsi:type, and optional content-type\n            AttributesImpl attributes = new AttributesImpl();\n            output.startPrefixMapping(XMLConstants.XSI_PREFIX, XMLConstants.XSI_URI);\n            output.startPrefixMapping(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n            attributes.addAttribute(XMLConstants.XSI_URI, \"type\", \"xsi:type\", \"CDATA\", XMLConstants.XS_BASE64BINARY_QNAME.getQualifiedName());\n            if (contentType != null)\n                attributes.addAttribute(\"\", \"content-type\", \"content-type\", \"CDATA\", contentType);\n            if (lastModified != null)\n                attributes.addAttribute(\"\", \"last-modified\", \"last-modified\", \"CDATA\",  ISODateUtils.getRFC1123Date(lastModified.longValue()));\n\n            // Write document\n            output.startDocument();\n            output.startElement(\"\", DEFAULT_BINARY_DOCUMENT_ELEMENT, DEFAULT_BINARY_DOCUMENT_ELEMENT, attributes);\n            XMLUtils.inputStreamToBase64Characters(new BufferedInputStream(is), output);\n            output.endElement(\"\", DEFAULT_BINARY_DOCUMENT_ELEMENT, DEFAULT_BINARY_DOCUMENT_ELEMENT);\n            output.endDocument();\n\n        } catch (SAXException e) {\n            throw new OXFException(e);\n        }\n    }","id":85025,"modified_method":"/**\n     * Generate a \"standard\" Orbeon binary document.\n     *\n     * @param is            InputStream to read from\n     * @param output        output ContentHandler to write binary document to\n     * @param contentType   optional content type to set as attribute on the root element\n     */\n    public static void readBinary(InputStream is, ContentHandler output, String contentType, Long lastModified) {\n        try {\n            // Create attributes for root element: xsi:type, and optional content-type\n            AttributesImpl attributes = new AttributesImpl();\n            attributes.addAttribute(XMLConstants.XSI_URI, \"type\", \"xsi:type\", \"CDATA\", XMLConstants.XS_BASE64BINARY_QNAME.getQualifiedName());\n            if (contentType != null)\n                attributes.addAttribute(\"\", \"content-type\", \"content-type\", \"CDATA\", contentType);\n            if (lastModified != null)\n                attributes.addAttribute(\"\", \"last-modified\", \"last-modified\", \"CDATA\",  ISODateUtils.getRFC1123Date(lastModified.longValue()));\n\n            // Write document\n            output.startDocument();\n            output.startPrefixMapping(XMLConstants.XSI_PREFIX, XMLConstants.XSI_URI);\n            output.startPrefixMapping(XMLConstants.XSD_PREFIX, XMLConstants.XSD_URI);\n            output.startElement(\"\", DEFAULT_BINARY_DOCUMENT_ELEMENT, DEFAULT_BINARY_DOCUMENT_ELEMENT, attributes);\n            XMLUtils.inputStreamToBase64Characters(new BufferedInputStream(is), output);\n            output.endElement(\"\", DEFAULT_BINARY_DOCUMENT_ELEMENT, DEFAULT_BINARY_DOCUMENT_ELEMENT);\n            output.endPrefixMapping(XMLConstants.XSD_PREFIX);\n            output.endPrefixMapping(XMLConstants.XSI_PREFIX);\n            output.endDocument();\n\n        } catch (SAXException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"de70c22713671f06f459d22bc72379242ad88eb6","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public IngestModule.ProcessResult process(AbstractFile file) {\n        // Skip everything except unallocated space files.\n        if (file.getType() != TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) {\n            return IngestModule.ProcessResult.OK;\n        }\n\n        Path tempFilePath = null;\n        try {\n            long id = getRootId(file);\n            // make sure we have a valid systemID\n            if (id == -1) {\n                return ProcessResult.ERROR;\n            }\n\n            // Verify initialization succeeded.\n            if (null == this.executableFile) {\n                logger.log(Level.SEVERE, \"PhotoRec carver called after failed start up\");  // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Check that we have roughly enough disk space left to complete the operation\n            // Some network drives always return -1 for free disk space. \n            // In this case, expect enough space and move on.\n            long freeDiskSpace = IngestServices.getInstance().getFreeDiskSpace();\n            if ((freeDiskSpace != -1) && ((file.getSize() * 1.2) > freeDiskSpace)) {\n                logger.log(Level.SEVERE, \"PhotoRec error processing {0} with {1} Not enough space on primary disk to save unallocated space.\", // NON-NLS\n                        new Object[]{file.getName(), PhotoRecCarverIngestModuleFactory.getModuleName()}); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.UnableToCarve\", file.getName()),\n                        NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.NotEnoughDiskSpace\"));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Write the file to disk.\n            WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.get(this.context.getJobId());\n            tempFilePath = Paths.get(paths.getTempDirPath().toString(), file.getName());\n            ContentUtils.writeToFile(file, tempFilePath.toFile());\n\n            // Create a subdirectory for this file.\n            Path outputDirPath = Paths.get(paths.getOutputDirPath().toString(), file.getName());\n            Files.createDirectory(outputDirPath);\n            File log = new File(Paths.get(outputDirPath.toString(), LOG_FILE).toString()); //NON-NLS\n\n            // Scan the file with Unallocated Carver.\n            ProcessBuilder processAndSettings = new ProcessBuilder(\n                    \"\\\"\" + executableFile + \"\\\"\",\n                    \"/d\", // NON-NLS\n                    \"\\\"\" + outputDirPath.toAbsolutePath() + File.separator + PHOTOREC_RESULTS_BASE + \"\\\"\",\n                    \"/cmd\", // NON-NLS\n                    \"\\\"\" + tempFilePath.toFile() + \"\\\"\",\n                    \"search\");  // NON_NLS\n\n            // Add environment variable to force PhotoRec to run with the same permissions Autopsy uses\n            processAndSettings.environment().put(\"__COMPAT_LAYER\", \"RunAsInvoker\"); //NON-NLS\n            processAndSettings.redirectErrorStream(true);\n            processAndSettings.redirectOutput(Redirect.appendTo(log));\n            \n            FileIngestModuleProcessTerminator terminator = new FileIngestModuleProcessTerminator(this.context, true);\n            int exitValue = ExecUtil.execute(processAndSettings, terminator);\n            \n            if (this.context.fileIngestIsCancelled() == true) {\n                // if it was cancelled by the user, result is OK\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.INFO, \"PhotoRec cancelled by user\"); // NON-NLS\n                return IngestModule.ProcessResult.OK;\n            } else if (terminator.getTerminationCode() == ProcTerminationCode.TIME_OUT) {\n                cleanup(outputDirPath, tempFilePath);\n                String msg = NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.processTerminated\") + file.getName(); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.moduleError\"), msg); // NON-NLS                \n                logger.log(Level.SEVERE, msg);\n                return IngestModule.ProcessResult.ERROR;\n            } else if (0 != exitValue) {\n                // if it failed or was cancelled by timeout, result is ERROR\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.SEVERE, \"PhotoRec carver returned error exit value = {0} when scanning {1}\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}); // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Move carver log file to avoid placement into Autopsy results. PhotoRec appends \".1\" to the folder name.\n            java.io.File oldAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_RESULTS_EXTENDED, PHOTOREC_REPORT).toString()); //NON-NLS\n            java.io.File newAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_REPORT).toString()); //NON-NLS\n            oldAuditFile.renameTo(newAuditFile);\n\n            Path pathToRemove = Paths.get(outputDirPath.toAbsolutePath().toString());\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(pathToRemove)) {\n                for (Path entry : stream) {\n                    if (Files.isDirectory(entry)) {\n                        FileUtil.deleteDir(new File(entry.toString()));\n                    }\n                }\n            }\n            \n            // Now that we've cleaned up the folders and data files, parse the xml output file to add carved items into the database\n            PhotoRecCarverOutputParser parser = new PhotoRecCarverOutputParser(outputDirPath);\n            List<LayoutFile> theList = parser.parse(newAuditFile, id, file);\n            if (theList != null) { // if there were any results from carving, add the unallocated carving event to the reports list.\n                context.addFilesToJob(new ArrayList<>(theList));\n                services.fireModuleContentEvent(new ModuleContentEvent(theList.get(0))); // fire an event to update the tree\n            }\n        }\n        catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error processing \" + file.getName() + \" with PhotoRec carver\", ex); // NON-NLS\n            return IngestModule.ProcessResult.ERROR;\n        }\n\n        finally {\n            if (null != tempFilePath && Files.exists(tempFilePath)) {\n                // Get rid of the unallocated space file.\n                tempFilePath.toFile().delete();\n            }\n        }\n        return IngestModule.ProcessResult.OK;\n\n    }","id":85026,"modified_method":"/**\n     * @inheritDoc\n     */\n    @Override\n    public IngestModule.ProcessResult process(AbstractFile file) {\n        // Skip everything except unallocated space files.\n        if (file.getType() != TskData.TSK_DB_FILES_TYPE_ENUM.UNALLOC_BLOCKS) {\n            return IngestModule.ProcessResult.OK;\n        }\n\n        Path tempFilePath = null;\n        try {\n            long id = getRootId(file);\n            // make sure we have a valid systemID\n            if (id == -1) {\n                return ProcessResult.ERROR;\n            }\n\n            // Verify initialization succeeded.\n            if (null == this.executableFile) {\n                logger.log(Level.SEVERE, \"PhotoRec carver called after failed start up\");  // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Check that we have roughly enough disk space left to complete the operation\n            // Some network drives always return -1 for free disk space. \n            // In this case, expect enough space and move on.\n            long freeDiskSpace = IngestServices.getInstance().getFreeDiskSpace();\n            if ((freeDiskSpace != IngestMonitor.DISK_FREE_SPACE_UNKNOWN) && ((file.getSize() * 1.2) > freeDiskSpace)) {\n                logger.log(Level.SEVERE, \"PhotoRec error processing {0} with {1} Not enough space on primary disk to save unallocated space.\", // NON-NLS\n                        new Object[]{file.getName(), PhotoRecCarverIngestModuleFactory.getModuleName()}); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.UnableToCarve\", file.getName()),\n                        NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.NotEnoughDiskSpace\"));\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Write the file to disk.\n            WorkingPaths paths = PhotoRecCarverFileIngestModule.pathsByJob.get(this.context.getJobId());\n            tempFilePath = Paths.get(paths.getTempDirPath().toString(), file.getName());\n            ContentUtils.writeToFile(file, tempFilePath.toFile());\n\n            // Create a subdirectory for this file.\n            Path outputDirPath = Paths.get(paths.getOutputDirPath().toString(), file.getName());\n            Files.createDirectory(outputDirPath);\n            File log = new File(Paths.get(outputDirPath.toString(), LOG_FILE).toString()); //NON-NLS\n\n            // Scan the file with Unallocated Carver.\n            ProcessBuilder processAndSettings = new ProcessBuilder(\n                    \"\\\"\" + executableFile + \"\\\"\",\n                    \"/d\", // NON-NLS\n                    \"\\\"\" + outputDirPath.toAbsolutePath() + File.separator + PHOTOREC_RESULTS_BASE + \"\\\"\",\n                    \"/cmd\", // NON-NLS\n                    \"\\\"\" + tempFilePath.toFile() + \"\\\"\",\n                    \"search\");  // NON_NLS\n\n            // Add environment variable to force PhotoRec to run with the same permissions Autopsy uses\n            processAndSettings.environment().put(\"__COMPAT_LAYER\", \"RunAsInvoker\"); //NON-NLS\n            processAndSettings.redirectErrorStream(true);\n            processAndSettings.redirectOutput(Redirect.appendTo(log));\n            \n            FileIngestModuleProcessTerminator terminator = new FileIngestModuleProcessTerminator(this.context, true);\n            int exitValue = ExecUtil.execute(processAndSettings, terminator);\n            \n            if (this.context.fileIngestIsCancelled() == true) {\n                // if it was cancelled by the user, result is OK\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.INFO, \"PhotoRec cancelled by user\"); // NON-NLS\n                return IngestModule.ProcessResult.OK;\n            } else if (terminator.getTerminationCode() == ProcTerminationCode.TIME_OUT) {\n                cleanup(outputDirPath, tempFilePath);\n                String msg = NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.processTerminated\") + file.getName(); // NON-NLS\n                MessageNotifyUtil.Notify.error(NbBundle.getMessage(this.getClass(), \"PhotoRecIngestModule.moduleError\"), msg); // NON-NLS                \n                logger.log(Level.SEVERE, msg);\n                return IngestModule.ProcessResult.ERROR;\n            } else if (0 != exitValue) {\n                // if it failed or was cancelled by timeout, result is ERROR\n                cleanup(outputDirPath, tempFilePath);\n                logger.log(Level.SEVERE, \"PhotoRec carver returned error exit value = {0} when scanning {1}\", // NON-NLS\n                        new Object[]{exitValue, file.getName()}); // NON-NLS\n                return IngestModule.ProcessResult.ERROR;\n            }\n\n            // Move carver log file to avoid placement into Autopsy results. PhotoRec appends \".1\" to the folder name.\n            java.io.File oldAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_RESULTS_EXTENDED, PHOTOREC_REPORT).toString()); //NON-NLS\n            java.io.File newAuditFile = new java.io.File(Paths.get(outputDirPath.toString(), PHOTOREC_REPORT).toString()); //NON-NLS\n            oldAuditFile.renameTo(newAuditFile);\n\n            Path pathToRemove = Paths.get(outputDirPath.toAbsolutePath().toString());\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(pathToRemove)) {\n                for (Path entry : stream) {\n                    if (Files.isDirectory(entry)) {\n                        FileUtil.deleteDir(new File(entry.toString()));\n                    }\n                }\n            }\n            \n            // Now that we've cleaned up the folders and data files, parse the xml output file to add carved items into the database\n            PhotoRecCarverOutputParser parser = new PhotoRecCarverOutputParser(outputDirPath);\n            List<LayoutFile> theList = parser.parse(newAuditFile, id, file);\n            if (theList != null) { // if there were any results from carving, add the unallocated carving event to the reports list.\n                context.addFilesToJob(new ArrayList<>(theList));\n                services.fireModuleContentEvent(new ModuleContentEvent(theList.get(0))); // fire an event to update the tree\n            }\n        }\n        catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error processing \" + file.getName() + \" with PhotoRec carver\", ex); // NON-NLS\n            return IngestModule.ProcessResult.ERROR;\n        }\n\n        finally {\n            if (null != tempFilePath && Files.exists(tempFilePath)) {\n                // Get rid of the unallocated space file.\n                tempFilePath.toFile().delete();\n            }\n        }\n        return IngestModule.ProcessResult.OK;\n\n    }","commit_id":"fc0c6af1d37b8e99e8da0642451fd32a2421fe51","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Add the attachments within the PSTMessage to the EmailMessage.\n     *\n     * @param email\n     * @param msg\n     */\n    private void extractAttachments(EmailMessage email, PSTMessage msg) {\n        int numberOfAttachments = msg.getNumberOfAttachments();\n        String outputDirPath = ThunderbirdMboxFileIngestModule.getModuleOutputPath() + File.separator;\n        for (int x = 0; x < numberOfAttachments; x++) {\n            String filename = \"\";\n            try {\n                PSTAttachment attach = msg.getAttachment(x);\n                long size = attach.getAttachSize();\n                if (size >= services.getFreeDiskSpace()) {\n                    continue;\n                }\n                // both long and short filenames can be used for attachments\n                filename = attach.getLongFilename();\n                if (filename.isEmpty()) {\n                    filename = attach.getFilename();\n                }\n                String uniqueFilename = msg.getDescriptorNodeId() + \"-\" + filename;\n                String outPath = outputDirPath + uniqueFilename;\n                saveAttachmentToDisk(attach, outPath);\n\n                EmailMessage.Attachment attachment = new EmailMessage.Attachment();\n\n                long crTime = attach.getCreationTime().getTime() / 1000;\n                long mTime = attach.getModificationTime().getTime() / 1000;\n                String relPath = getRelModuleOutputPath() + File.separator + uniqueFilename;\n                attachment.setName(filename);\n                attachment.setCrTime(crTime);\n                attachment.setmTime(mTime);\n                attachment.setLocalPath(relPath);\n                attachment.setSize(attach.getFilesize());\n                email.addAttachment(attachment);\n            } catch (PSTException | IOException ex) {\n                addErrorMessage(\n                        NbBundle.getMessage(this.getClass(), \"PstParser.extractAttch.errMsg.failedToExtractToDisk\",\n                        filename));\n                logger.log(Level.WARNING, \"Failed to extract attachment from pst file.\", ex); //NON-NLS\n            }\n        }\n    }","id":85027,"modified_method":"/**\n     * Add the attachments within the PSTMessage to the EmailMessage.\n     *\n     * @param email\n     * @param msg\n     */\n    private void extractAttachments(EmailMessage email, PSTMessage msg) {\n        int numberOfAttachments = msg.getNumberOfAttachments();\n        String outputDirPath = ThunderbirdMboxFileIngestModule.getModuleOutputPath() + File.separator;\n        for (int x = 0; x < numberOfAttachments; x++) {\n            String filename = \"\";\n            try {\n                PSTAttachment attach = msg.getAttachment(x);\n                long size = attach.getAttachSize();\n                long freeSpace = services.getFreeDiskSpace();\n                if ((freeSpace != IngestMonitor.DISK_FREE_SPACE_UNKNOWN) && (size >= freeSpace)) {\n                    continue;\n                }\n                // both long and short filenames can be used for attachments\n                filename = attach.getLongFilename();\n                if (filename.isEmpty()) {\n                    filename = attach.getFilename();\n                }\n                String uniqueFilename = msg.getDescriptorNodeId() + \"-\" + filename;\n                String outPath = outputDirPath + uniqueFilename;\n                saveAttachmentToDisk(attach, outPath);\n\n                EmailMessage.Attachment attachment = new EmailMessage.Attachment();\n\n                long crTime = attach.getCreationTime().getTime() / 1000;\n                long mTime = attach.getModificationTime().getTime() / 1000;\n                String relPath = getRelModuleOutputPath() + File.separator + uniqueFilename;\n                attachment.setName(filename);\n                attachment.setCrTime(crTime);\n                attachment.setmTime(mTime);\n                attachment.setLocalPath(relPath);\n                attachment.setSize(attach.getFilesize());\n                email.addAttachment(attachment);\n            } catch (PSTException | IOException ex) {\n                addErrorMessage(\n                        NbBundle.getMessage(this.getClass(), \"PstParser.extractAttch.errMsg.failedToExtractToDisk\",\n                        filename));\n                logger.log(Level.WARNING, \"Failed to extract attachment from pst file.\", ex); //NON-NLS\n            }\n        }\n    }","commit_id":"fc0c6af1d37b8e99e8da0642451fd32a2421fe51","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Parse and extract email messages and attachments from an MBox file.\n     *\n     * @param abstractFile\n     * @param ingestContext\n     * @return\n     */\n    private ProcessResult processMBox(AbstractFile abstractFile) {\n        String mboxFileName = abstractFile.getName();\n        String mboxParentDir = abstractFile.getParentPath();\n        // use the local path to determine the e-mail folder structure\n        String emailFolder = \"\";\n        // email folder is everything after \"Mail\" or ImapMail\n        if (mboxParentDir.contains(\"/Mail/\")) { //NON-NLS\n            emailFolder = mboxParentDir.substring(mboxParentDir.indexOf(\"/Mail/\") + 5); //NON-NLS\n        } else if (mboxParentDir.contains(\"/ImapMail/\")) { //NON-NLS\n            emailFolder = mboxParentDir.substring(mboxParentDir.indexOf(\"/ImapMail/\") + 9); //NON-NLS\n        }\n        emailFolder = emailFolder + mboxFileName;\n        emailFolder = emailFolder.replaceAll(\".sbd\", \"\"); //NON-NLS\n\n        String fileName = getTempPath() + File.separator + abstractFile.getName()\n                + \"-\" + String.valueOf(abstractFile.getId());\n        File file = new File(fileName);\n\n        if (abstractFile.getSize() >= services.getFreeDiskSpace()) {\n            logger.log(Level.WARNING, \"Not enough disk space to write file to disk.\"); //NON-NLS\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processMBox.errProcFile.msg\",\n                    abstractFile.getName()),\n                    NbBundle.getMessage(this.getClass(),\n                    \"ThunderbirdMboxFileIngestModule.processMBox.errProfFile.details\"));\n            return ProcessResult.OK;\n        }\n\n        try {\n            ContentUtils.writeToFile(abstractFile, file);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Failed writing mbox file to disk.\", ex); //NON-NLS\n            return ProcessResult.OK;\n        }\n\n        MboxParser parser = new MboxParser(services, emailFolder);\n        List<EmailMessage> emails = parser.parse(file);\n\n        processEmails(emails, abstractFile);\n\n        if (file.delete() == false) {\n            logger.log(Level.INFO, \"Failed to delete temp file: {0}\", file.getName()); //NON-NLS\n        }\n\n        String errors = parser.getErrors();\n        if (errors.isEmpty() == false) {\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processMBox.errProcFile.msg2\",\n                    abstractFile.getName()), errors);\n        }\n\n        return ProcessResult.OK;\n    }","id":85028,"modified_method":"/**\n     * Parse and extract email messages and attachments from an MBox file.\n     *\n     * @param abstractFile\n     * @param ingestContext\n     * @return\n     */\n    private ProcessResult processMBox(AbstractFile abstractFile) {\n        String mboxFileName = abstractFile.getName();\n        String mboxParentDir = abstractFile.getParentPath();\n        // use the local path to determine the e-mail folder structure\n        String emailFolder = \"\";\n        // email folder is everything after \"Mail\" or ImapMail\n        if (mboxParentDir.contains(\"/Mail/\")) { //NON-NLS\n            emailFolder = mboxParentDir.substring(mboxParentDir.indexOf(\"/Mail/\") + 5); //NON-NLS\n        } else if (mboxParentDir.contains(\"/ImapMail/\")) { //NON-NLS\n            emailFolder = mboxParentDir.substring(mboxParentDir.indexOf(\"/ImapMail/\") + 9); //NON-NLS\n        }\n        emailFolder = emailFolder + mboxFileName;\n        emailFolder = emailFolder.replaceAll(\".sbd\", \"\"); //NON-NLS\n\n        String fileName = getTempPath() + File.separator + abstractFile.getName()\n                + \"-\" + String.valueOf(abstractFile.getId());\n        File file = new File(fileName);\n\n        long freeSpace = services.getFreeDiskSpace();\n        if ((freeSpace != IngestMonitor.DISK_FREE_SPACE_UNKNOWN) && (abstractFile.getSize() >= freeSpace)) {\n            logger.log(Level.WARNING, \"Not enough disk space to write file to disk.\"); //NON-NLS\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processMBox.errProcFile.msg\",\n                    abstractFile.getName()),\n                    NbBundle.getMessage(this.getClass(),\n                    \"ThunderbirdMboxFileIngestModule.processMBox.errProfFile.details\"));\n            return ProcessResult.OK;\n        }\n\n        try {\n            ContentUtils.writeToFile(abstractFile, file);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Failed writing mbox file to disk.\", ex); //NON-NLS\n            return ProcessResult.OK;\n        }\n\n        MboxParser parser = new MboxParser(services, emailFolder);\n        List<EmailMessage> emails = parser.parse(file);\n\n        processEmails(emails, abstractFile);\n\n        if (file.delete() == false) {\n            logger.log(Level.INFO, \"Failed to delete temp file: {0}\", file.getName()); //NON-NLS\n        }\n\n        String errors = parser.getErrors();\n        if (errors.isEmpty() == false) {\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processMBox.errProcFile.msg2\",\n                    abstractFile.getName()), errors);\n        }\n\n        return ProcessResult.OK;\n    }","commit_id":"fc0c6af1d37b8e99e8da0642451fd32a2421fe51","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Processes a pst/ost data file and extracts and adds email artifacts.\n     *\n     * @param abstractFile The pst/ost data file to process.\n     * @return\n     */\n    private ProcessResult processPst(AbstractFile abstractFile) {\n        String fileName = getTempPath() + File.separator + abstractFile.getName()\n                + \"-\" + String.valueOf(abstractFile.getId());\n        File file = new File(fileName);\n\n        if (abstractFile.getSize() >= services.getFreeDiskSpace()) {\n            logger.log(Level.WARNING, \"Not enough disk space to write file to disk.\"); //NON-NLS\n            IngestMessage msg = IngestMessage.createErrorMessage(EmailParserModuleFactory.getModuleName(), EmailParserModuleFactory.getModuleName(),\n                    NbBundle.getMessage(this.getClass(),\n                    \"ThunderbirdMboxFileIngestModule.processPst.errMsg.outOfDiskSpace\",\n                    abstractFile.getName()));\n            services.postMessage(msg);\n            return ProcessResult.OK;\n        }\n\n        try {\n            ContentUtils.writeToFile(abstractFile, file);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Failed writing pst file to disk.\", ex); //NON-NLS\n            return ProcessResult.OK;\n        }\n\n        PstParser parser = new PstParser(services);\n        PstParser.ParseResult result = parser.parse(file);\n\n        if (result == PstParser.ParseResult.OK) {\n            // parse success: Process email and add artifacts\n            processEmails(parser.getResults(), abstractFile);\n        } else if (result == PstParser.ParseResult.ENCRYPT) {\n            // encrypted pst: Add encrypted file artifact\n            try {\n                BlackboardArtifact artifact = abstractFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED);\n                artifact.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), EmailParserModuleFactory.getModuleName(), NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.encryptionFileLevel\")));\n                services.fireModuleDataEvent(new ModuleDataEvent(EmailParserModuleFactory.getModuleName(), BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED));\n            } catch (TskCoreException ex) {\n                logger.log(Level.INFO, \"Failed to add encryption attribute to file: {0}\", abstractFile.getName()); //NON-NLS\n            }\n        } else {\n            // parsing error: log message\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processPst.errProcFile.msg\",\n                    abstractFile.getName()),\n                    NbBundle.getMessage(this.getClass(),\n                    \"ThunderbirdMboxFileIngestModule.processPst.errProcFile.details\"));\n            logger.log(Level.INFO, \"PSTParser failed to parse {0}\", abstractFile.getName()); //NON-NLS\n            return ProcessResult.ERROR;\n        }\n\n        if (file.delete() == false) {\n            logger.log(Level.INFO, \"Failed to delete temp file: {0}\", file.getName()); //NON-NLS\n        }\n\n        String errors = parser.getErrors();\n        if (errors.isEmpty() == false) {\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processPst.errProcFile.msg2\",\n                    abstractFile.getName()), errors);\n        }\n\n        return ProcessResult.OK;\n    }","id":85029,"modified_method":"/**\n     * Processes a pst/ost data file and extracts and adds email artifacts.\n     *\n     * @param abstractFile The pst/ost data file to process.\n     * @return\n     */\n    private ProcessResult processPst(AbstractFile abstractFile) {\n        String fileName = getTempPath() + File.separator + abstractFile.getName()\n                + \"-\" + String.valueOf(abstractFile.getId());\n        File file = new File(fileName);\n\n        long freeSpace = services.getFreeDiskSpace();\n        if ((freeSpace != IngestMonitor.DISK_FREE_SPACE_UNKNOWN) && (abstractFile.getSize() >= freeSpace)) {\n            logger.log(Level.WARNING, \"Not enough disk space to write file to disk.\"); //NON-NLS\n            IngestMessage msg = IngestMessage.createErrorMessage(EmailParserModuleFactory.getModuleName(), EmailParserModuleFactory.getModuleName(),\n                    NbBundle.getMessage(this.getClass(),\n                    \"ThunderbirdMboxFileIngestModule.processPst.errMsg.outOfDiskSpace\",\n                    abstractFile.getName()));\n            services.postMessage(msg);\n            return ProcessResult.OK;\n        }\n\n        try {\n            ContentUtils.writeToFile(abstractFile, file);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Failed writing pst file to disk.\", ex); //NON-NLS\n            return ProcessResult.OK;\n        }\n\n        PstParser parser = new PstParser(services);\n        PstParser.ParseResult result = parser.parse(file);\n\n        if (result == PstParser.ParseResult.OK) {\n            // parse success: Process email and add artifacts\n            processEmails(parser.getResults(), abstractFile);\n        } else if (result == PstParser.ParseResult.ENCRYPT) {\n            // encrypted pst: Add encrypted file artifact\n            try {\n                BlackboardArtifact artifact = abstractFile.newArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED);\n                artifact.addAttribute(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), EmailParserModuleFactory.getModuleName(), NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.encryptionFileLevel\")));\n                services.fireModuleDataEvent(new ModuleDataEvent(EmailParserModuleFactory.getModuleName(), BlackboardArtifact.ARTIFACT_TYPE.TSK_ENCRYPTION_DETECTED));\n            } catch (TskCoreException ex) {\n                logger.log(Level.INFO, \"Failed to add encryption attribute to file: {0}\", abstractFile.getName()); //NON-NLS\n            }\n        } else {\n            // parsing error: log message\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processPst.errProcFile.msg\",\n                    abstractFile.getName()),\n                    NbBundle.getMessage(this.getClass(),\n                    \"ThunderbirdMboxFileIngestModule.processPst.errProcFile.details\"));\n            logger.log(Level.INFO, \"PSTParser failed to parse {0}\", abstractFile.getName()); //NON-NLS\n            return ProcessResult.ERROR;\n        }\n\n        if (file.delete() == false) {\n            logger.log(Level.INFO, \"Failed to delete temp file: {0}\", file.getName()); //NON-NLS\n        }\n\n        String errors = parser.getErrors();\n        if (errors.isEmpty() == false) {\n            postErrorMessage(\n                    NbBundle.getMessage(this.getClass(), \"ThunderbirdMboxFileIngestModule.processPst.errProcFile.msg2\",\n                    abstractFile.getName()), errors);\n        }\n\n        return ProcessResult.OK;\n    }","commit_id":"fc0c6af1d37b8e99e8da0642451fd32a2421fe51","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static String propertyName( Field f ) {\n    return Fields.canonicalName( f ).toLowerCase( );\n  }","id":85030,"modified_method":"public static String propertyName( Field f ) {\n    Class c = f.getDeclaringClass( );\n    if ( c.isAnnotationPresent( ConfigurableClass.class ) && f.isAnnotationPresent( ConfigurableField.class ) ) {\n      ConfigurableClass classAnnote = ( ConfigurableClass ) c.getAnnotation( ConfigurableClass.class );\n      ConfigurableField annote = ( ConfigurableField ) f.getAnnotation( ConfigurableField.class );\n      String description = annote.description( );\n      String defaultValue = annote.initial( );\n      String fq = classAnnote.root( ) + \".\" + f.getName( ).toLowerCase( );\n      return fq.replaceAll( \"\\\\..*\", \"\" );\n    } else {\n      throw new NoSuchElementException( Ats.from( f ).toString( ) );\n    }\n  }","commit_id":"045c82ee20010c5bfc651726c6c35c77f1292831","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public String getDescription() {\n        return new StringBuilder()\n                .append(\"time: \").append(time)\n                .append(\", field: \").append(field)\n                .append(\", check type: \").append(type.toString().toLowerCase())\n                .append(\", threshold_type: \").append(thresholdType.toString().toLowerCase())\n                .append(\", threshold: \").append(decimalFormat.format(threshold))\n                .append(\", grace: \").append(grace)\n                .toString();\n    }","id":85031,"modified_method":"@Override\n    public String getDescription() {\n        return \"time: \" + time\n                + \", field: \" + field\n                + \", check type: \" + type.toString().toLowerCase()\n                + \", threshold_type: \" + thresholdType.toString().toLowerCase()\n                + \", threshold: \" + decimalFormat.format(threshold)\n                + \", grace: \" + grace;\n    }","commit_id":"e4b903337efb1bebb0a0f088f660c48006f18c19","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = null;\n        try {\n            String filter = \"streams:\"+stream.getId();\n            FieldStatsResult fieldStatsResult = searches.fieldStats(field,\n                                                                    \"*\",\n                                                                    filter,\n                                                                    new RelativeRange(time * 60));\n            if (getBacklog() != null && getBacklog() > 0) {\n                this.searchHits = Lists.newArrayList();\n                for (ResultMessage resultMessage : fieldStatsResult.getSearchHits()) {\n                    this.searchHits.add(new Message(resultMessage.getMessage()));\n                }\n            }\n\n            if (fieldStatsResult.getCount() == 0) {\n                LOG.debug(\"Alert check <{}> did not match any messages. Returning not triggered.\", type);\n                return new CheckResult(false);\n            }\n\n            double result;\n            switch (type) {\n                case MEAN:\n                    result = fieldStatsResult.getMean();\n                    break;\n                case MIN:\n                    result = fieldStatsResult.getMin();\n                    break;\n                case MAX:\n                    result = fieldStatsResult.getMax();\n                    break;\n                case SUM:\n                    result = fieldStatsResult.getSum();\n                    break;\n                case STDDEV:\n                    result = fieldStatsResult.getStdDeviation();\n                    break;\n                default:\n                    LOG.error(\"No such field value check type: [{}]. Returning not triggered.\", type);\n                    return new CheckResult(false);\n            }\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, result);\n\n            if(Double.isInfinite(result)) {\n                // This happens when there are no ES results/docs.\n                LOG.debug(\"Infinite value. Returning not triggered.\");\n                return new CheckResult(false);\n            }\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case HIGHER:\n                    triggered = result > threshold.doubleValue();\n                    break;\n                case LOWER:\n                    triggered = result < threshold.doubleValue();\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Field \").append(field).append(\" had a \")\n                        .append(type.toString().toLowerCase()).append(\" of \")\n                        .append(decimalFormat.format(result)).append(\" in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(decimalFormat.format(threshold)).append(\". \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        } catch (Searches.FieldTypeException e) {\n            LOG.debug(\"Field [{}] seems not to have a numerical type or doesn't even exist at all. Returning not triggered.\", field, e);\n            return new CheckResult(false);\n        }\n    }","id":85032,"modified_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = Collections.emptyList();\n        try {\n            String filter = \"streams:\" + stream.getId();\n            FieldStatsResult fieldStatsResult = searches.fieldStats(field, \"*\", filter, new RelativeRange(time * 60));\n            if (getBacklog() != null && getBacklog() > 0) {\n                this.searchHits = Lists.newArrayList();\n                for (ResultMessage resultMessage : fieldStatsResult.getSearchHits()) {\n                    this.searchHits.add(new Message(resultMessage.getMessage()));\n                }\n            }\n\n            if (fieldStatsResult.getCount() == 0) {\n                LOG.debug(\"Alert check <{}> did not match any messages. Returning not triggered.\", type);\n                return new CheckResult(false);\n            }\n\n            double result;\n            switch (type) {\n                case MEAN:\n                    result = fieldStatsResult.getMean();\n                    break;\n                case MIN:\n                    result = fieldStatsResult.getMin();\n                    break;\n                case MAX:\n                    result = fieldStatsResult.getMax();\n                    break;\n                case SUM:\n                    result = fieldStatsResult.getSum();\n                    break;\n                case STDDEV:\n                    result = fieldStatsResult.getStdDeviation();\n                    break;\n                default:\n                    LOG.error(\"No such field value check type: [{}]. Returning not triggered.\", type);\n                    return new CheckResult(false);\n            }\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, result);\n\n            if (Double.isInfinite(result)) {\n                // This happens when there are no ES results/docs.\n                LOG.debug(\"Infinite value. Returning not triggered.\");\n                return new CheckResult(false);\n            }\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case HIGHER:\n                    triggered = result > threshold.doubleValue();\n                    break;\n                case LOWER:\n                    triggered = result < threshold.doubleValue();\n                    break;\n            }\n\n            if (triggered) {\n                final String resultDescription = \"Field \" + field + \" had a \" + type + \" of \"\n                        + decimalFormat.format(result) + \" in the last \" + time + \" minutes with trigger condition \"\n                        + thresholdType + \" than \" + decimalFormat.format(threshold) + \". \"\n                        + \"(Current grace time: \" + grace + \" minutes)\";\n                return new CheckResult(true, this, resultDescription, Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        } catch (Searches.FieldTypeException e) {\n            LOG.debug(\"Field [{}] seems not to have a numerical type or doesn't even exist at all. Returning not triggered.\", field, e);\n            return new CheckResult(false);\n        }\n    }","commit_id":"e4b903337efb1bebb0a0f088f660c48006f18c19","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public String getDescription() {\n        return new StringBuilder()\n                .append(\"time: \").append(time)\n                .append(\", threshold_type: \").append(thresholdType.toString().toLowerCase())\n                .append(\", threshold: \").append(threshold)\n                .append(\", grace: \").append(grace)\n                .toString();\n    }","id":85033,"modified_method":"@Override\n    public String getDescription() {\n        return \"time: \" + time\n                + \", threshold_type: \" + thresholdType.toString().toLowerCase()\n                + \", threshold: \" + threshold\n                + \", grace: \" + grace;\n    }","commit_id":"e4b903337efb1bebb0a0f088f660c48006f18c19","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = null;\n        try {\n            String filter = \"streams:\"+stream.getId();\n            CountResult result = searches.count(\"*\", new RelativeRange(time * 60), filter);\n            long count = result.getCount();\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, count);\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case MORE:\n                    triggered = count > threshold;\n                    break;\n                case LESS:\n                    triggered = count < threshold;\n                    break;\n            }\n\n            if (triggered) {\n                Integer backlogSize = getBacklog();\n                if (backlogSize != null && backlogSize > 0) {\n                    SearchResult backlogResult = searches.search(\"*\", filter, new RelativeRange(time * 60), backlogSize, 0, new Sorting(\"timestamp\", Sorting.Direction.DESC));\n                    this.searchHits = Lists.newArrayList();\n                    for (ResultMessage resultMessage : backlogResult.getResults()) {\n                        searchHits.add(new Message(resultMessage.getMessage()));\n                    }\n                }\n\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Stream had \").append(count).append(\" messages in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\" messages. \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        }\n    }","id":85034,"modified_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = Collections.emptyList();\n        try {\n            String filter = \"streams:\" + stream.getId();\n            CountResult result = searches.count(\"*\", new RelativeRange(time * 60), filter);\n            long count = result.getCount();\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, count);\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case MORE:\n                    triggered = count > threshold;\n                    break;\n                case LESS:\n                    triggered = count < threshold;\n                    break;\n            }\n\n            if (triggered) {\n                Integer backlogSize = getBacklog();\n                if (backlogSize != null && backlogSize > 0) {\n                    SearchResult backlogResult = searches.search(\"*\", filter, new RelativeRange(time * 60), backlogSize, 0, new Sorting(\"timestamp\", Sorting.Direction.DESC));\n                    this.searchHits = Lists.newArrayList();\n                    for (ResultMessage resultMessage : backlogResult.getResults()) {\n                        searchHits.add(new Message(resultMessage.getMessage()));\n                    }\n                }\n\n                final String resultDescription = \"Stream had \" + count + \" messages in the last \" + time\n                        + \" minutes with trigger condition \" + thresholdType.toString().toLowerCase()\n                        + \" than \" + threshold + \" messages. \" + \"(Current grace time: \" + grace + \" minutes)\";\n                return new CheckResult(true, this, resultDescription, Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        }\n    }","commit_id":"e4b903337efb1bebb0a0f088f660c48006f18c19","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"protected abstract void removed(final ServiceReference<T> ref);","id":85035,"modified_method":"protected void removed(final ServiceReference<T> ref)\n    {\n        final WhiteboardServiceInfo<T> info = this.getServiceInfo(ref);\n        this.contextManager.removeWhiteboardService(info);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"protected abstract void added(final ServiceReference<T> ref);","id":85036,"modified_method":"protected void added(final ServiceReference<T> ref)\n    {\n        final WhiteboardServiceInfo<T> info = this.getServiceInfo(ref);\n        this.contextManager.addWhiteboardService(info);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"private void modified(final ServiceReference<T> ref) {\n        removed(ref);\n        added(ref);\n    }","id":85037,"modified_method":"protected void modified(final ServiceReference<T> ref)\n    {\n        removed(ref);\n        added(ref);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public AbstractReferenceTracker(final BundleContext context, final Filter filter)\n    {\n        super(context, filter, null);\n    }","id":85038,"modified_method":"public AbstractReferenceTracker(final ServletContextHelperManager contextManager,\n            final BundleContext context, final Filter filter)\n    {\n        super(context, filter, null);\n        this.contextManager = contextManager;\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public void activate(final Bundle bundle)\n    {\n        getServletContext(bundle);\n    }","id":85039,"modified_method":"public void activate()\n    {\n        getServletContext(bundle);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public void destroyed(final ServletContextListenerInfo listenerInfo)\n    {\n        // no need to sync map - destroyed is called in sync\n        final ServletContextListener listener = this.listeners.remove(listenerInfo.getServiceId());\n        if ( listener != null )\n        {\n            final ServletContext context = this.getServletContext(listenerInfo.getServiceReference().getBundle());\n            listener.contextDestroyed(new ServletContextEvent(context));\n            this.ungetServletContext(listenerInfo.getServiceReference().getBundle());\n        }\n    }","id":85040,"modified_method":"public void destroyed(@Nonnull final ServletContextListenerInfo listenerInfo)\n    {\n        // no need to sync map - destroyed is called in sync\n        final ServletContextListener listener = this.listeners.remove(listenerInfo.getServiceId());\n        if ( listener != null )\n        {\n            final ServletContext context = this.getServletContext(listenerInfo.getServiceReference().getBundle());\n            listener.contextDestroyed(new ServletContextEvent(context));\n            // call unget twice, once for the call in initialized and once for the call in this method(!)\n            this.ungetServletContext(listenerInfo.getServiceReference().getBundle());\n            this.ungetServletContext(listenerInfo.getServiceReference().getBundle());\n            final ServiceObjects<ServletContextListener> so = bundle.getBundleContext().getServiceObjects(listenerInfo.getServiceReference());\n            if ( so != null )\n            {\n                so.ungetService(listener);\n            }\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public void addListener(@Nonnull final Bundle bundle, @Nonnull final ServletContextAttributeListenerInfo info)\n    {\n        final  ServletContextAttributeListener service = bundle.getBundleContext().getServiceObjects(info.getServiceReference()).getService();\n        if ( service != null )\n        {\n            this.contextAttributeListeners.put(info.getServiceId(), service);\n        }\n    }","id":85041,"modified_method":"/**\n     * Add servlet context attribute listener\n     * @param info\n     */\n    public void addListener(@Nonnull final ServletContextAttributeListenerInfo info)\n    {\n        final ServiceObjects<ServletContextAttributeListener> so =  bundle.getBundleContext().getServiceObjects(info.getServiceReference());\n        if ( so != null )\n        {\n            final  ServletContextAttributeListener service = bundle.getBundleContext().getServiceObjects(info.getServiceReference()).getService();\n            if ( service != null )\n            {\n                this.contextAttributeListeners.put(info.getServiceId(), service);\n            }\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public void initialized(final Bundle bundle, final ServletContextListenerInfo listenerInfo)\n    {\n        final ServletContextListener listener = bundle.getBundleContext().getServiceObjects(listenerInfo.getServiceReference()).getService();\n        if ( listener != null)\n        {\n            // no need to sync map - initialized is called in sync\n            this.listeners.put(listenerInfo.getServiceId(), listener);\n\n            final ServletContext context = this.getServletContext(listenerInfo.getServiceReference().getBundle());\n\n            listener.contextInitialized(new ServletContextEvent(context));\n        }\n    }","id":85042,"modified_method":"public void initialized(@Nonnull final ServletContextListenerInfo listenerInfo)\n    {\n        final ServiceObjects<ServletContextListener> so = bundle.getBundleContext().getServiceObjects(listenerInfo.getServiceReference());\n        if ( so != null )\n        {\n            final ServletContextListener listener = so.getService();\n            if ( listener != null)\n            {\n                // no need to sync map - initialized is called in sync\n                this.listeners.put(listenerInfo.getServiceId(), listener);\n\n                final ServletContext context = this.getServletContext(listenerInfo.getServiceReference().getBundle());\n\n                listener.contextInitialized(new ServletContextEvent(context));\n            }\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public void ungetServletContext(@Nonnull final Bundle bundle)\n    {\n        final Long key = bundle.getBundleId();\n        synchronized ( this.contextMap )\n        {\n            ContextHolder holder = this.contextMap.get(key);\n            if ( holder != null )\n            {\n                holder.counter--;\n                if ( holder.counter <= 0 )\n                {\n                    this.contextMap.remove(key);\n                    bundle.getBundleContext().getServiceObjects(this.info.getServiceReference()).ungetService(holder.servletContextHelper);\n                }\n            }\n        }\n    }","id":85043,"modified_method":"public void ungetServletContext(@Nonnull final Bundle bundle)\n    {\n        final Long key = bundle.getBundleId();\n        synchronized ( this.contextMap )\n        {\n            ContextHolder holder = this.contextMap.get(key);\n            if ( holder != null )\n            {\n                holder.counter--;\n                if ( holder.counter <= 0 )\n                {\n                    this.contextMap.remove(key);\n                    final ServiceObjects<ServletContextHelper> so = bundle.getBundleContext().getServiceObjects(this.info.getServiceReference());\n                    if ( so != null )\n                    {\n                        so.ungetService(holder.servletContextHelper);\n                    }\n                }\n            }\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public void deactivate(final Bundle bundle)\n    {\n        this.ungetServletContext(bundle);\n    }","id":85044,"modified_method":"public void deactivate()\n    {\n        this.ungetServletContext(bundle);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public ExtServletContext getServletContext(@Nonnull final Bundle bundle)\n    {\n        final Long key = bundle.getBundleId();\n        synchronized ( this.contextMap )\n        {\n            ContextHolder holder = this.contextMap.get(key);\n            if ( holder == null )\n            {\n                holder = new ContextHolder();\n                // TODO check for null\n                holder.servletContextHelper = bundle.getBundleContext().getServiceObjects(this.info.getServiceReference()).getService();\n                holder.servletContext = new PerBundleServletContextImpl(bundle,\n                        this.sharedContext,\n                        holder.servletContextHelper);\n            }\n            holder.counter++;\n\n            return holder.servletContext;\n        }\n    }","id":85045,"modified_method":"public ExtServletContext getServletContext(@Nonnull final Bundle bundle)\n    {\n        final Long key = bundle.getBundleId();\n        synchronized ( this.contextMap )\n        {\n            ContextHolder holder = this.contextMap.get(key);\n            if ( holder == null )\n            {\n                final ServiceObjects<ServletContextHelper> so = bundle.getBundleContext().getServiceObjects(this.info.getServiceReference());\n                if ( so != null )\n                {\n                    holder = new ContextHolder();\n                    // TODO check for null\n                    holder.servletContextHelper = so.getService();\n                    holder.servletContext = new PerBundleServletContextImpl(bundle,\n                            this.sharedContext,\n                            holder.servletContextHelper);\n                    this.contextMap.put(key, holder);\n                }\n            }\n            holder.counter++;\n\n            return holder.servletContext;\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public void removeListener(@Nonnull final Bundle bundle, @Nonnull final ServletContextAttributeListenerInfo info)\n    {\n        final  ServletContextAttributeListener service = this.contextAttributeListeners.remove(info.getServiceId());\n        if ( service != null )\n        {\n            bundle.getBundleContext().getServiceObjects(info.getServiceReference()).ungetService(service);\n        }\n    }","id":85046,"modified_method":"/**\n     * Remove servlet context attribute listener\n     * @param info\n     */\n    public void removeListener(@Nonnull final ServletContextAttributeListenerInfo info)\n    {\n        final  ServletContextAttributeListener service = this.contextAttributeListeners.remove(info.getServiceId());\n        if ( service != null )\n        {\n            final ServiceObjects<ServletContextAttributeListener> so =  bundle.getBundleContext().getServiceObjects(info.getServiceReference());\n            if ( so != null ) {\n                so.ungetService(service);\n            }\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Get the context info\n     */\n    public ContextInfo getContextInfo()\n    {\n        return this.info;\n    }","id":85047,"modified_method":"/**\n     * Get the context info\n     */\n    public ServletContextHelperInfo getContextInfo()\n    {\n        return this.info;\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Create new handler.\n     * @param info\n     * @param webContext\n     */\n    public ContextHandler(final ContextInfo info, final ServletContext webContext)\n    {\n        this.info = info;\n        this.sharedContext = new SharedServletContextImpl(webContext,\n                info.getPrefix(),\n                info.getName(),\n                new ServletContextAttributeListener() {\n\n                    @Override\n                    public void attributeReplaced(final ServletContextAttributeEvent event) {\n                        for(final ServletContextAttributeListener l : contextAttributeListeners.values())\n                        {\n                            l.attributeReplaced(event);\n                        }\n                    }\n\n                    @Override\n                    public void attributeRemoved(final ServletContextAttributeEvent event) {\n                        for(final ServletContextAttributeListener l : contextAttributeListeners.values())\n                        {\n                            l.attributeReplaced(event);\n                        }\n                    }\n\n                    @Override\n                    public void attributeAdded(final ServletContextAttributeEvent event) {\n                        for(final ServletContextAttributeListener l : contextAttributeListeners.values())\n                        {\n                            l.attributeReplaced(event);\n                        }\n                    }\n                });\n    }","id":85048,"modified_method":"/**\n     * Create new handler.\n     * @param info\n     * @param webContext\n     */\n    public ContextHandler(final ServletContextHelperInfo info,\n            final ServletContext webContext,\n            final Bundle bundle)\n    {\n        this.info = info;\n        this.bundle = bundle;\n        this.sharedContext = new SharedServletContextImpl(webContext,\n                info.getPrefix(),\n                info.getName(),\n                new ServletContextAttributeListener() {\n\n                    @Override\n                    public void attributeReplaced(final ServletContextAttributeEvent event) {\n                        for(final ServletContextAttributeListener l : contextAttributeListeners.values())\n                        {\n                            l.attributeReplaced(event);\n                        }\n                    }\n\n                    @Override\n                    public void attributeRemoved(final ServletContextAttributeEvent event) {\n                        for(final ServletContextAttributeListener l : contextAttributeListeners.values())\n                        {\n                            l.attributeReplaced(event);\n                        }\n                    }\n\n                    @Override\n                    public void attributeAdded(final ServletContextAttributeEvent event) {\n                        for(final ServletContextAttributeListener l : contextAttributeListeners.values())\n                        {\n                            l.attributeReplaced(event);\n                        }\n                    }\n                });\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public FilterHandler(final ContextInfo contextInfo, ExtServletContext context, Filter filter, FilterInfo filterInfo)\n    {\n        super(context, filterInfo.getInitParams(), filterInfo.getName());\n        this.filter = filter;\n        this.filterInfo = filterInfo;\n        // Compose a single array of all patterns & regexs the filter must represent...\n        String[] patterns = getFilterPatterns(filterInfo);\n\n        this.patterns = new Pattern[patterns.length];\n        for (int i = 0; i < patterns.length; i++)\n        {\n            this.patterns[i] = Pattern.compile(patterns[i]);\n        }\n        if ( contextInfo != null )\n        {\n            this.contextServiceId = contextInfo.getServiceId();\n        }\n        else\n        {\n            this.contextServiceId = -1;\n        }\n    }","id":85049,"modified_method":"public FilterHandler(final ServletContextHelperInfo contextInfo, ExtServletContext context, Filter filter, FilterInfo filterInfo)\n    {\n        super(context, filterInfo.getInitParams(), filterInfo.getName());\n        this.filter = filter;\n        this.filterInfo = filterInfo;\n        // Compose a single array of all patterns & regexs the filter must represent...\n        String[] patterns = getFilterPatterns(filterInfo);\n\n        this.patterns = new Pattern[patterns.length];\n        for (int i = 0; i < patterns.length; i++)\n        {\n            this.patterns[i] = Pattern.compile(patterns[i]);\n        }\n        if ( contextInfo != null )\n        {\n            this.contextServiceId = contextInfo.getServiceId();\n        }\n        else\n        {\n            this.contextServiceId = -1;\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void added(final ServiceReference<Filter> ref)\n    {\n        final FilterInfo info = new FilterInfo(ref);\n\n        if ( info.isValid() )\n        {\n            this.contextManager.addWhiteboardService(info);\n        }\n        else\n        {\n            SystemLogger.debug(\"Ignoring Filter service \" + ref);\n        }\n    }","id":85050,"modified_method":"@Override\n    protected WhiteboardServiceInfo<Filter> getServiceInfo(final ServiceReference<Filter> ref) {\n        return new FilterInfo(ref);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public FilterTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(context, createFilter(context));\n        this.contextManager = manager;\n    }","id":85051,"modified_method":"public FilterTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(manager, context, createFilter(context));\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Add a new servlet.\n     */\n    public synchronized void addServlet(ContextInfo contextInfo, ServletHandler handler) throws ServletException, NamespaceException\n    {\n        if (this.servletMap.containsKey(handler.getServlet()))\n        {\n            // Do not destroy the servlet as the same instance was already registered\n            throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");\n        }\n\n        // Can be null in case of error-handling servlets...\n        String[] patterns = handler.getServletInfo().getPatterns();\n        int length = patterns == null ? 0 : patterns.length;\n\n        for (int i = 0; i < length; i++)\n        {\n            String pattern = contextInfo != null ? contextInfo.getFullPath(patterns[i]) : patterns[i];\n            if (this.servletPatternMap.containsKey(pattern))\n            {\n                throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");\n            }\n            this.servletPatternMap.put(pattern, handler.getServlet());\n        }\n\n        patterns = handler.getServletInfo().getErrorPage();\n        if ( patterns != null )\n        {\n            for(final String errorPage : patterns)\n            {\n                this.errorsMapping.addErrorServlet(errorPage, handler);\n            }\n        }\n        handler.init();\n        this.servletMap.put(handler.getServlet(), handler);\n\n        updateServletMapping();\n    }","id":85052,"modified_method":"/**\n     * Add a new servlet.\n     */\n    public synchronized void addServlet(ServletContextHelperInfo contextInfo, ServletHandler handler) throws ServletException, NamespaceException\n    {\n        if (this.servletMap.containsKey(handler.getServlet()))\n        {\n            // Do not destroy the servlet as the same instance was already registered\n            throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");\n        }\n\n        // Can be null in case of error-handling servlets...\n        String[] patterns = handler.getServletInfo().getPatterns();\n        int length = patterns == null ? 0 : patterns.length;\n\n        for (int i = 0; i < length; i++)\n        {\n            String pattern = contextInfo != null ? contextInfo.getFullPath(patterns[i]) : patterns[i];\n            if (this.servletPatternMap.containsKey(pattern))\n            {\n                throw new ServletException(\"Servlet instance \" + handler.getName() + \" already registered\");\n            }\n            this.servletPatternMap.put(pattern, handler.getServlet());\n        }\n\n        patterns = handler.getServletInfo().getErrorPage();\n        if ( patterns != null )\n        {\n            for(final String errorPage : patterns)\n            {\n                this.errorsMapping.addErrorServlet(errorPage, handler);\n            }\n        }\n        handler.init();\n        this.servletMap.put(handler.getServlet(), handler);\n\n        updateServletMapping();\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public synchronized Servlet removeServlet(final ContextInfo contextInfo, ServletInfo servletInfo, final boolean destroy)\n    {\n        for(final ServletHandler handler : this.servletMap.values())\n        {\n            if ( handler.getServletInfo().compareTo(servletInfo) == 0 )\n            {\n                this.servletMap.remove(handler.getServlet());\n                updateServletMapping();\n\n                // Can be null in case of error-handling servlets...\n                String[] patterns = handler.getServletInfo().getPatterns();\n                int length = patterns == null ? 0 : patterns.length;\n\n                for (int i = 0; i < length; i++)\n                {\n                    this.servletPatternMap.remove(contextInfo.getFullPath(patterns[i]));\n                }\n\n                this.errorsMapping.removeServlet(handler.getServlet());\n\n                if (destroy)\n                {\n                    handler.destroy();\n                }\n                return handler.getServlet();\n            }\n        }\n        return null;\n    }","id":85053,"modified_method":"public synchronized Servlet removeServlet(final ServletContextHelperInfo contextInfo, ServletInfo servletInfo, final boolean destroy)\n    {\n        for(final ServletHandler handler : this.servletMap.values())\n        {\n            if ( handler.getServletInfo().compareTo(servletInfo) == 0 )\n            {\n                this.servletMap.remove(handler.getServlet());\n                updateServletMapping();\n\n                // Can be null in case of error-handling servlets...\n                String[] patterns = handler.getServletInfo().getPatterns();\n                int length = patterns == null ? 0 : patterns.length;\n\n                for (int i = 0; i < length; i++)\n                {\n                    this.servletPatternMap.remove(contextInfo.getFullPath(patterns[i]));\n                }\n\n                this.errorsMapping.removeServlet(handler.getServlet());\n\n                if (destroy)\n                {\n                    handler.destroy();\n                }\n                return handler.getServlet();\n            }\n        }\n        return null;\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void added(final ServiceReference<Object> ref)\n    {\n        final ResourceInfo info = new ResourceInfo(ref);\n\n        if ( info.isValid() )\n        {\n            this.contextManager.addWhiteboardService(info);\n        }\n        else\n        {\n            SystemLogger.debug(\"Ignoring Resource service \" + ref);\n        }\n    }","id":85054,"modified_method":"@Override\n    protected WhiteboardServiceInfo<Object> getServiceInfo(final ServiceReference<Object> ref) {\n        return new ResourceInfo(ref);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public ResourceTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(context, createFilter(context));\n        this.contextManager = manager;\n    }","id":85055,"modified_method":"public ResourceTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(manager, context, createFilter(context));\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void added(final ServiceReference<ServletContextAttributeListener> ref)\n    {\n        final ServletContextAttributeListenerInfo info = new ServletContextAttributeListenerInfo(ref);\n\n        if ( info.isValid() )\n        {\n            this.contextManager.addWhiteboardService(info);\n        }\n        else\n        {\n            SystemLogger.debug(\"Ignoring ServletContextAttributeListenerInfo service \" + ref);\n        }\n    }","id":85056,"modified_method":"@Override\n    protected WhiteboardServiceInfo<ServletContextAttributeListener> getServiceInfo(final ServiceReference<ServletContextAttributeListener> ref) {\n        return new ServletContextAttributeListenerInfo(ref);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public ServletContextAttributeListenerTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(context, createFilter(context));\n        this.contextManager = manager;\n    }","id":85057,"modified_method":"public ServletContextAttributeListenerTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(manager, context, createFilter(context));\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Unregister whiteboard service from the http service\n     * @param contextInfo Context info\n     * @param info Whiteboard service info\n     */\n    private void unregisterWhiteboardService(final ContextHandler handler, final WhiteboardServiceInfo<?> info)\n    {\n        if ( info instanceof ServletInfo )\n        {\n            this.httpService.unregisterServlet(handler, (ServletInfo)info);\n        }\n        else if ( info instanceof FilterInfo )\n        {\n            this.httpService.unregisterFilter(handler, (FilterInfo)info);\n        }\n        else if ( info instanceof ResourceInfo )\n        {\n            this.httpService.unregisterResource(handler, (ResourceInfo)info);\n        }\n        else if ( info instanceof ServletContextAttributeListenerInfo )\n        {\n            handler.removeListener(this.bundle, (ServletContextAttributeListenerInfo)info );\n        }\n    }","id":85058,"modified_method":"/**\n     * Unregister whiteboard service from the http service\n     * @param contextInfo Context info\n     * @param info Whiteboard service info\n     */\n    private void unregisterWhiteboardService(final ContextHandler handler, final WhiteboardServiceInfo<?> info)\n    {\n        if ( info instanceof ServletInfo )\n        {\n            this.httpService.unregisterServlet(handler, (ServletInfo)info);\n        }\n        else if ( info instanceof FilterInfo )\n        {\n            this.httpService.unregisterFilter(handler, (FilterInfo)info);\n        }\n        else if ( info instanceof ResourceInfo )\n        {\n            this.httpService.unregisterResource(handler, (ResourceInfo)info);\n        }\n        else if ( info instanceof ServletContextAttributeListenerInfo )\n        {\n            handler.removeListener((ServletContextAttributeListenerInfo)info );\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Register whiteboard service in the http service\n     * @param contextInfo Context info\n     * @param info Whiteboard service info\n     */\n    private void registerWhiteboardService(final ContextHandler handler, final WhiteboardServiceInfo<?> info)\n    {\n        if ( info instanceof ServletInfo )\n        {\n            this.httpService.registerServlet(handler, (ServletInfo)info);\n        }\n        else if ( info instanceof FilterInfo )\n        {\n            this.httpService.registerFilter(handler, (FilterInfo)info);\n        }\n        else if ( info instanceof ResourceInfo )\n        {\n            this.httpService.registerResource(handler, (ResourceInfo)info);\n        }\n        else if ( info instanceof ServletContextAttributeListenerInfo )\n        {\n            handler.addListener(this.bundle, (ServletContextAttributeListenerInfo)info );\n        }\n    }","id":85059,"modified_method":"/**\n     * Register whiteboard service in the http service\n     * @param contextInfo Context info\n     * @param info Whiteboard service info\n     */\n    private void registerWhiteboardService(final ContextHandler handler, final WhiteboardServiceInfo<?> info)\n    {\n        if ( info instanceof ServletInfo )\n        {\n            this.httpService.registerServlet(handler, (ServletInfo)info);\n        }\n        else if ( info instanceof FilterInfo )\n        {\n            this.httpService.registerFilter(handler, (FilterInfo)info);\n        }\n        else if ( info instanceof ResourceInfo )\n        {\n            this.httpService.registerResource(handler, (ResourceInfo)info);\n        }\n        else if ( info instanceof ServletContextAttributeListenerInfo )\n        {\n            handler.addListener((ServletContextAttributeListenerInfo)info );\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Add a servlet context helper.\n     */\n    public void addContextHelper(final ContextInfo info)\n    {\n        final ContextHandler handler = new ContextHandler(info, this.webContext);\n        synchronized ( this.contextMap )\n        {\n            List<ContextHandler> handlerList = this.contextMap.get(info.getName());\n            if ( handlerList == null )\n            {\n                handlerList = new ArrayList<ContextHandler>();\n                this.contextMap.put(info.getName(), handlerList);\n            }\n            handlerList.add(handler);\n            Collections.sort(handlerList);\n            // check for activate/deactivate\n            if ( handlerList.get(0) == handler )\n            {\n                // check for deactivate\n                if ( handlerList.size() > 1 )\n                {\n                    this.deactivate(handlerList.get(1));\n                }\n                this.activate(handler);\n            }\n        }\n    }","id":85060,"modified_method":"/**\n     * Add a servlet context helper.\n     */\n    public void addContextHelper(final ServletContextHelperInfo info)\n    {\n        if ( info.isValid() )\n        {\n            final ContextHandler handler = new ContextHandler(info, this.webContext, this.bundle);\n            synchronized ( this.contextMap )\n            {\n                List<ContextHandler> handlerList = this.contextMap.get(info.getName());\n                if ( handlerList == null )\n                {\n                    handlerList = new ArrayList<ContextHandler>();\n                    this.contextMap.put(info.getName(), handlerList);\n                }\n                handlerList.add(handler);\n                Collections.sort(handlerList);\n                // check for activate/deactivate\n                if ( handlerList.get(0) == handler )\n                {\n                    // check for deactivate\n                    if ( handlerList.size() > 1 )\n                    {\n                        this.deactivate(handlerList.get(1));\n                    }\n                    this.activate(handler);\n                }\n            }\n        }\n        else\n        {\n            // TODO - failure DTO\n            final String type = info.getClass().getSimpleName().substring(0, info.getClass().getSimpleName().length() - 4);\n            SystemLogger.debug(\"Ignoring \" + type + \" service \" + info.getServiceReference());\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Add new whiteboard service to the registry\n     * @param info Whiteboard service info\n     */\n    public void addWhiteboardService(final WhiteboardServiceInfo<?> info)\n    {\n        synchronized ( this.contextMap )\n        {\n            final List<ContextHandler> handlerList = this.getMatchingContexts(info);\n            this.servicesMap.put(info, handlerList);\n            for(final ContextHandler h : handlerList)\n            {\n                this.registerWhiteboardService(h, info);\n            }\n        }\n    }","id":85061,"modified_method":"/**\n     * Add new whiteboard service to the registry\n     * @param info Whiteboard service info\n     */\n    public void addWhiteboardService(@Nonnull final WhiteboardServiceInfo<?> info)\n    {\n        if ( info.isValid() )\n        {\n            synchronized ( this.contextMap )\n            {\n                final List<ContextHandler> handlerList = this.getMatchingContexts(info);\n                this.servicesMap.put(info, handlerList);\n                for(final ContextHandler h : handlerList)\n                {\n                    this.registerWhiteboardService(h, info);\n                }\n            }\n        }\n        else\n        {\n            // TODO - failure DTO\n            final String type = info.getClass().getSimpleName().substring(0, info.getClass().getSimpleName().length() - 4);\n            SystemLogger.debug(\"Ignoring \" + type + \" service \" + info.getServiceReference());\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Activate a servlet context helper.\n     * @param contextInfo A context info\n     */\n    private void activate(final ContextHandler handler)\n    {\n        handler.activate(this.bundle);\n        // context listeners first\n        final List<WhiteboardServiceInfo<?>> services = new ArrayList<WhiteboardServiceInfo<?>>();\n        for(final Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>> entry : this.servicesMap.entrySet())\n        {\n            if ( entry.getKey().getContextSelectionFilter().match(handler.getContextInfo().getServiceReference()) )\n            {\n                entry.getValue().add(handler);\n                if ( entry.getKey() instanceof ServletContextListenerInfo )\n                {\n                    handler.initialized(this.bundle, (ServletContextListenerInfo)entry.getKey());\n                }\n                else\n                {\n                    services.add(entry.getKey());\n                }\n            }\n        }\n        // now register services\n        for(final WhiteboardServiceInfo<?> info : services)\n        {\n            this.registerWhiteboardService(handler, info);\n        }\n    }","id":85062,"modified_method":"/**\n     * Activate a servlet context helper.\n     * @param contextInfo A context info\n     */\n    private void activate(final ContextHandler handler)\n    {\n        handler.activate();\n        // context listeners first\n        final List<WhiteboardServiceInfo<?>> services = new ArrayList<WhiteboardServiceInfo<?>>();\n        for(final Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>> entry : this.servicesMap.entrySet())\n        {\n            if ( entry.getKey().getContextSelectionFilter().match(handler.getContextInfo().getServiceReference()) )\n            {\n                entry.getValue().add(handler);\n                if ( entry.getKey() instanceof ServletContextListenerInfo )\n                {\n                    handler.initialized((ServletContextListenerInfo)entry.getKey());\n                }\n                else\n                {\n                    services.add(entry.getKey());\n                }\n            }\n        }\n        // now register services\n        for(final WhiteboardServiceInfo<?> info : services)\n        {\n            this.registerWhiteboardService(handler, info);\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Deactivate a servlet context helper.\n     * @param contextInfo A context info\n     */\n    private void deactivate(final ContextHandler handler)\n    {\n        // context listeners last\n        final List<ServletContextListenerInfo> listeners = new ArrayList<ServletContextListenerInfo>();\n        final Iterator<Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>>> i = this.servicesMap.entrySet().iterator();\n        while ( i.hasNext() )\n        {\n            final Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>> entry = i.next();\n            if ( entry.getValue().remove(handler) )\n            {\n                if ( entry.getKey() instanceof ServletContextListenerInfo )\n                {\n                    listeners.add((ServletContextListenerInfo)entry.getKey());\n                }\n                else\n                {\n                    this.unregisterWhiteboardService(handler, entry.getKey());\n                }\n                if ( entry.getValue().isEmpty() ) {\n                    i.remove();\n                }\n            }\n        }\n        for(final ServletContextListenerInfo info : listeners)\n        {\n            handler.destroyed(info);\n        }\n        handler.deactivate(this.bundle);\n    }","id":85063,"modified_method":"/**\n     * Deactivate a servlet context helper.\n     * @param contextInfo A context info\n     */\n    private void deactivate(final ContextHandler handler)\n    {\n        // context listeners last\n        final List<ServletContextListenerInfo> listeners = new ArrayList<ServletContextListenerInfo>();\n        final Iterator<Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>>> i = this.servicesMap.entrySet().iterator();\n        while ( i.hasNext() )\n        {\n            final Map.Entry<WhiteboardServiceInfo<?>, List<ContextHandler>> entry = i.next();\n            if ( entry.getValue().remove(handler) )\n            {\n                if ( entry.getKey() instanceof ServletContextListenerInfo )\n                {\n                    listeners.add((ServletContextListenerInfo)entry.getKey());\n                }\n                else\n                {\n                    this.unregisterWhiteboardService(handler, entry.getKey());\n                }\n                if ( entry.getValue().isEmpty() ) {\n                    i.remove();\n                }\n            }\n        }\n        for(final ServletContextListenerInfo info : listeners)\n        {\n            handler.destroyed(info);\n        }\n        handler.deactivate();\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Remove a servlet context helper\n     */\n    public void removeContextHelper(final ContextInfo info)\n    {\n        synchronized ( this.contextMap )\n        {\n            final List<ContextHandler> handlerList = this.contextMap.get(info.getName());\n            if ( handlerList != null )\n            {\n                final Iterator<ContextHandler> i = handlerList.iterator();\n                boolean first = true;\n                boolean activateNext = false;\n                while ( i.hasNext() )\n                {\n                    final ContextHandler handler = i.next();\n                    if ( handler.getContextInfo().compareTo(info) == 0 )\n                    {\n                        i.remove();\n                        // check for deactivate\n                        if ( first )\n                        {\n                            this.deactivate(handler);\n                            activateNext = true;\n                        }\n                        break;\n                    }\n                    first = false;\n                }\n                if ( handlerList.isEmpty() )\n                {\n                    this.contextMap.remove(info.getName());\n                }\n                else if ( activateNext )\n                {\n                    this.activate(handlerList.get(0));\n                }\n            }\n        }\n    }","id":85064,"modified_method":"/**\n     * Remove a servlet context helper\n     */\n    public void removeContextHelper(final ServletContextHelperInfo info)\n    {\n        synchronized ( this.contextMap )\n        {\n            final List<ContextHandler> handlerList = this.contextMap.get(info.getName());\n            if ( handlerList != null )\n            {\n                final Iterator<ContextHandler> i = handlerList.iterator();\n                boolean first = true;\n                boolean activateNext = false;\n                while ( i.hasNext() )\n                {\n                    final ContextHandler handler = i.next();\n                    if ( handler.getContextInfo().compareTo(info) == 0 )\n                    {\n                        i.remove();\n                        // check for deactivate\n                        if ( first )\n                        {\n                            this.deactivate(handler);\n                            activateNext = true;\n                        }\n                        break;\n                    }\n                    first = false;\n                }\n                if ( handlerList.isEmpty() )\n                {\n                    this.contextMap.remove(info.getName());\n                }\n                else if ( activateNext )\n                {\n                    this.activate(handlerList.get(0));\n                }\n            }\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void removed(final ServiceReference<ServletContextHelper> ref)\n    {\n        final ContextInfo info = new ContextInfo(ref);\n        if ( info.isValid() )\n        {\n            this.contextManager.removeContextHelper(info);\n        }\n    }","id":85065,"modified_method":"private void removed(@Nonnull final ServiceReference<ServletContextHelper> ref)\n    {\n        final ServletContextHelperInfo info = new ServletContextHelperInfo(ref);\n        this.contextManager.removeContextHelper(info);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void added(final ServiceReference<ServletContextHelper> ref)\n    {\n        final ContextInfo info = new ContextInfo(ref);\n\n        if ( info.isValid() )\n        {\n            this.contextManager.addContextHelper(info);\n        }\n        else\n        {\n            SystemLogger.debug(\"Ignoring ServletContextHelper service \" + ref);\n        }\n    }","id":85066,"modified_method":"private void added(@Nonnull final ServiceReference<ServletContextHelper> ref)\n    {\n        final ServletContextHelperInfo info = new ServletContextHelperInfo(ref);\n        this.contextManager.addContextHelper(info);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public ServletContextHelperTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(context, createFilter(context));\n        this.contextManager = manager;\n    }","id":85067,"modified_method":"public ServletContextHelperTracker(@Nonnull final BundleContext context, @Nonnull final ServletContextHelperManager manager)\n    {\n        super(context, createFilter(context), null);\n        this.contextManager = manager;\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void added(final ServiceReference<ServletContextListener> ref)\n    {\n        final ServletContextListenerInfo info = new ServletContextListenerInfo(ref);\n\n        if ( info.isValid() )\n        {\n            this.contextManager.addWhiteboardService(info);\n        }\n        else\n        {\n            SystemLogger.debug(\"Ignoring ServletContextListenerInfo service \" + ref);\n        }\n    }","id":85068,"modified_method":"@Override\n    protected WhiteboardServiceInfo<ServletContextListener> getServiceInfo(final ServiceReference<ServletContextListener> ref) {\n        return new ServletContextListenerInfo(ref);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public ServletContextListenerTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(context, createFilter(context));\n        this.contextManager = manager;\n    }","id":85069,"modified_method":"public ServletContextListenerTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(manager, context, createFilter(context));\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public ServletHandler(final ContextInfo contextInfo,\n                          final ExtServletContext context,\n                          final ServletInfo servletInfo,\n                          final Servlet servlet)\n    {\n        super(context, servletInfo.getInitParams(), servletInfo.getName());\n        this.servlet = servlet;\n        this.servletInfo = servletInfo;\n\n        // Can be null in case of error-handling servlets...\n        String[] patterns = this.servletInfo.getPatterns();\n        final int length = patterns == null ? 0 : patterns.length;\n\n        this.patterns = new Pattern[length];\n        for (int i = 0; i < length; i++)\n        {\n            String pattern = (contextInfo == null ? patterns[i] : contextInfo.getFullPath(patterns[i]));\n            this.patterns[i] = Pattern.compile(PatternUtil.convertToRegEx(pattern));\n        }\n        if ( contextInfo != null )\n        {\n            this.contextServiceId = contextInfo.getServiceId();\n        }\n        else\n        {\n            this.contextServiceId = -1;\n        }\n    }","id":85070,"modified_method":"public ServletHandler(final ServletContextHelperInfo contextInfo,\n                          final ExtServletContext context,\n                          final ServletInfo servletInfo,\n                          final Servlet servlet)\n    {\n        super(context, servletInfo.getInitParams(), servletInfo.getName());\n        this.servlet = servlet;\n        this.servletInfo = servletInfo;\n\n        // Can be null in case of error-handling servlets...\n        String[] patterns = this.servletInfo.getPatterns();\n        final int length = patterns == null ? 0 : patterns.length;\n\n        this.patterns = new Pattern[length];\n        for (int i = 0; i < length; i++)\n        {\n            String pattern = (contextInfo == null ? patterns[i] : contextInfo.getFullPath(patterns[i]));\n            this.patterns[i] = Pattern.compile(PatternUtil.convertToRegEx(pattern));\n        }\n        if ( contextInfo != null )\n        {\n            this.contextServiceId = contextInfo.getServiceId();\n        }\n        else\n        {\n            this.contextServiceId = -1;\n        }\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"public ServletTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(context, createFilter(context));\n        this.contextManager = manager;\n    }","id":85071,"modified_method":"public ServletTracker(final BundleContext context, final ServletContextHelperManager manager)\n    {\n        super(manager, context, createFilter(context));\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void added(final ServiceReference<Servlet> ref)\n    {\n        final ServletInfo info = new ServletInfo(ref);\n\n        if ( info.isValid() )\n        {\n            this.contextManager.addWhiteboardService(info);\n        }\n        else\n        {\n            SystemLogger.debug(\"Ignoring Servlet service \" + ref);\n        }\n    }","id":85072,"modified_method":"@Override\n    protected WhiteboardServiceInfo<Servlet> getServiceInfo(final ServiceReference<Servlet> ref) {\n        return new ServletInfo(ref);\n    }","commit_id":"2c9a8ccad9e3fa5ebe3ae4c25520e8bf1119770b","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Initialize the object\n     * @return {code -1} on success, a failure reason according to {@link DTOConstants} otherwise.\n     */\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        if (this.filter == null)\n        {\n            return DTOConstants.FAILURE_REASON_SERVICE_NOT_GETTABLE;\n        }\n\n        try\n        {\n            filter.init(new FilterConfigImpl(getName(), getContext(), getFilterInfo().getInitParameters()));\n        }\n        catch (final ServletException e)\n        {\n            SystemLogger.error(this.getFilterInfo().getServiceReference(),\n                    \"Error during calling init() on filter \" + this.filter,\n                    e);\n            return DTOConstants.FAILURE_REASON_EXCEPTION_ON_INIT;\n        }\n        this.useCount++;\n        return -1;\n    }","id":85073,"modified_method":"/**\n     * Initialize the object\n     * @return {code -1} on success, a failure reason according to {@link DTOConstants} otherwise.\n     */\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        if (this.filter == null)\n        {\n            return DTOConstants.FAILURE_REASON_SERVICE_NOT_GETTABLE;\n        }\n\n        try\n        {\n            filter.init(new FilterConfigImpl(getName(), getContext(), getFilterInfo().getInitParameters()));\n        }\n        catch (final Exception e)\n        {\n            SystemLogger.error(this.getFilterInfo().getServiceReference(),\n                    \"Error during calling init() on filter \" + this.filter,\n                    e);\n            return DTOConstants.FAILURE_REASON_EXCEPTION_ON_INIT;\n        }\n        this.useCount++;\n        return -1;\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"public ResourceServlet(String path)\n    {\n        this.path = path;\n    }","id":85074,"modified_method":"public ResourceServlet(final String prefix)\n    {\n        this.prefix = prefix;\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"private void handle(HttpServletRequest req, HttpServletResponse res, URL url, String resName) throws IOException\n    {\n        String contentType = getServletContext().getMimeType(resName);\n        if (contentType != null)\n        {\n            res.setContentType(contentType);\n        }\n\n        long lastModified = getLastModified(url);\n        if (lastModified != 0)\n        {\n            res.setDateHeader(\"Last-Modified\", lastModified);\n        }\n\n        if (!resourceModified(lastModified, req.getDateHeader(\"If-Modified-Since\")))\n        {\n            res.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n        }\n        else\n        {\n            copyResource(url, res);\n        }\n    }","id":85075,"modified_method":"private void handle(final HttpServletRequest req,\n            final HttpServletResponse res, final URL url, final String resName)\n    throws IOException\n    {\n        final String contentType = getServletContext().getMimeType(resName);\n        if (contentType != null)\n        {\n            res.setContentType(contentType);\n        }\n\n        final long lastModified = getLastModified(url);\n        if (lastModified != 0)\n        {\n            res.setDateHeader(\"Last-Modified\", lastModified);\n        }\n\n        if (!resourceModified(lastModified, req.getDateHeader(\"If-Modified-Since\")))\n        {\n            res.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n        }\n        else\n        {\n            copyResource(url, res);\n        }\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException\n    {\n        String target = req.getPathInfo();\n        if (target == null)\n        {\n            target = \"\";\n        }\n\n        if (!target.startsWith(\"/\"))\n        {\n            target += \"/\" + target;\n        }\n\n        String resName = this.path + target;\n        URL url = getServletContext().getResource(resName);\n\n        if (url == null)\n        {\n            res.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n        else\n        {\n            handle(req, res, url, resName);\n        }\n    }","id":85076,"modified_method":"@Override\n    protected void doGet(final HttpServletRequest req, final HttpServletResponse res)\n            throws ServletException, IOException\n    {\n        final String target = req.getPathInfo();\n        final String resName = (target == null ? this.prefix : this.prefix + target);\n\n        final URL url = getServletContext().getResource(resName);\n\n        if (url == null)\n        {\n            res.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n        else\n        {\n            handle(req, res, url, resName);\n        }\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"private long getLastModified(URL url)\n    {\n        long lastModified = 0;\n\n        try\n        {\n            URLConnection conn = url.openConnection();\n            lastModified = conn.getLastModified();\n        }\n        catch (Exception e)\n        {\n            // Do nothing\n        }\n\n        if (lastModified == 0)\n        {\n            String filepath = url.getPath();\n            if (filepath != null)\n            {\n                File f = new File(filepath);\n                if (f.exists())\n                {\n                    lastModified = f.lastModified();\n                }\n            }\n        }\n\n        return lastModified;\n    }","id":85077,"modified_method":"private long getLastModified(final URL url)\n    {\n        long lastModified = 0;\n\n        try\n        {\n            final URLConnection conn = url.openConnection();\n            lastModified = conn.getLastModified();\n        }\n        catch (final Exception e)\n        {\n            // Do nothing\n        }\n\n        if (lastModified == 0)\n        {\n            final String filepath = url.getPath();\n            if (filepath != null)\n            {\n                final File f = new File(filepath);\n                if (f.exists())\n                {\n                    lastModified = f.lastModified();\n                }\n            }\n        }\n\n        return lastModified;\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Initialize the object\n     * @return {code -1} on success, a failure reason according to {@link DTOConstants} otherwise.\n     */\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        if (this.servlet == null)\n        {\n            return DTOConstants.FAILURE_REASON_SERVICE_NOT_GETTABLE;\n        }\n\n        try\n        {\n            servlet.init(new ServletConfigImpl(getName(), getContext(), getServletInfo().getInitParameters()));\n        }\n        catch (final ServletException e)\n        {\n            SystemLogger.error(this.getServletInfo().getServiceReference(),\n                    \"Error during calling init() on servlet \" + this.servlet,\n                    e);\n            return DTOConstants.FAILURE_REASON_EXCEPTION_ON_INIT;\n        }\n        this.useCount++;\n        return -1;\n    }","id":85078,"modified_method":"/**\n     * Initialize the object\n     * @return {code -1} on success, a failure reason according to {@link DTOConstants} otherwise.\n     */\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        if (this.servlet == null)\n        {\n            return DTOConstants.FAILURE_REASON_SERVICE_NOT_GETTABLE;\n        }\n\n        try\n        {\n            servlet.init(new ServletConfigImpl(getName(), getContext(), getServletInfo().getInitParameters()));\n        }\n        catch (final Exception e)\n        {\n            SystemLogger.error(this.getServletInfo().getServiceReference(),\n                    \"Error during calling init() on servlet \" + this.servlet,\n                    e);\n            return DTOConstants.FAILURE_REASON_EXCEPTION_ON_INIT;\n        }\n        this.useCount++;\n        return -1;\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        final ServiceReference<Filter> serviceReference = getFilterInfo().getServiceReference();\n        final ServiceObjects<Filter> so = this.bundleContext.getServiceObjects(serviceReference);\n\n        this.setFilter((so == null ? null : so.getService()));\n\n        final int reason = super.init();\n        if ( reason != -1 )\n        {\n            so.ungetService(this.getFilter());\n            this.setFilter(null);\n        }\n        return reason;\n    }","id":85079,"modified_method":"@Override\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        final ServiceReference<Filter> serviceReference = getFilterInfo().getServiceReference();\n        final ServiceObjects<Filter> so = this.bundleContext.getServiceObjects(serviceReference);\n\n        this.setFilter((so == null ? null : so.getService()));\n\n        final int reason = super.init();\n        if ( reason != -1 )\n        {\n            if ( so != null )\n            {\n                so.ungetService(this.getFilter());\n            }\n            this.setFilter(null);\n        }\n        return reason;\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        final ServiceReference<Servlet> serviceReference = getServletInfo().getServiceReference();\n        final ServiceObjects<Servlet> so = this.bundleContext.getServiceObjects(serviceReference);\n\n        this.setServlet((so == null ? null : so.getService()));\n\n        final int reason = super.init();\n        if ( reason != -1 )\n        {\n            so.ungetService(this.getServlet());\n            this.setServlet(null);\n        }\n        return reason;\n    }","id":85080,"modified_method":"@Override\n    public int init()\n    {\n        if ( this.useCount > 0 )\n        {\n            this.useCount++;\n            return -1;\n        }\n\n        final ServiceReference<Servlet> serviceReference = getServletInfo().getServiceReference();\n        final ServiceObjects<Servlet> so = this.bundleContext.getServiceObjects(serviceReference);\n\n        this.setServlet((so == null ? null : so.getService()));\n\n        final int reason = super.init();\n        if ( reason != -1 )\n        {\n            if ( so != null )\n            {\n                so.ungetService(this.getServlet());\n            }\n            this.setServlet(null);\n        }\n        return reason;\n    }","commit_id":"04d0a0098b3b86719a82f25e84724fd7ee9f4bcc","url":"https://github.com/apache/felix"},{"original_method":"private static boolean readEntry( FileChannel channel, ByteBuffer buf, \n            XaCommandFactory cf ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            // ok no more entries we're done\n            return false;\n        }\n        buf.flip();\n        byte byteEntry = buf.get();\n        LogEntry entry;\n        switch ( byteEntry )\n        {\n            case LogEntry.TX_START:\n                long position = channel.position();\n                entry = LogIoUtils.readTxStartEntry( buf, channel, position );\n                System.out.println( \"Start: \" + entry );\n                return entry != null;\n            case LogEntry.TX_PREPARE:\n                entry = LogIoUtils.readTxPrepareEntry( buf, channel );\n                System.out.println( \"Prepare: \" + entry );\n                return entry != null;\n            case LogEntry.TX_1P_COMMIT:\n                entry = LogIoUtils.readTxOnePhaseCommit( buf, channel );\n                System.out.println( \"1PC: \" + entry );\n                return entry != null;\n            case LogEntry.TX_2P_COMMIT:\n                entry = LogIoUtils.readTxTwoPhaseCommit( buf, channel );\n                System.out.println( \"2PC: \" + entry );\n                return entry != null;\n            case LogEntry.COMMAND:\n                entry = LogIoUtils.readTxCommand( buf, channel, cf );\n                System.out.println( \"Command: \" + entry );\n                return entry != null;\n            case LogEntry.DONE:\n                entry = LogIoUtils.readTxDoneEntry( buf, channel );\n                System.out.println( \"Done: \" + entry );\n                return entry != null;\n            case LogEntry.EMPTY:\n                position = channel.position();\n                System.out.println( \"Empty @ position \" + position );\n                channel.position( channel.position() - 1 );\n                return false;\n            default:\n                throw new IOException( \"Internal recovery failed, \"\n                    + \"unknown log entry[\" + byteEntry + \"]\" );\n        }\n    }","id":85081,"modified_method":"private static boolean readEntry( FileChannel channel, ByteBuffer buf, \n            XaCommandFactory cf ) throws IOException\n    {\n        LogEntry entry = LogIoUtils.readEntry( buf, channel, cf );\n        if ( entry != null )\n        {\n            System.out.println( entry.toString() );\n            return true;\n        }\n        return false;\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"OnePhaseCommit( int identifier, long txId )\n        {\n            super( identifier );\n            this.txId = txId;\n        }","id":85082,"modified_method":"OnePhaseCommit( int identifier, long txId )\n        {\n            super( identifier, txId );\n        }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String toString()\n        {\n            return \"2PC[\" + getIdentifier() + \", txId=\" + txId + \"]\";\n        }","id":85083,"modified_method":"public String toString()\n        {\n            return \"2PC[\" + getIdentifier() + \", txId=\" + getTxId() + \"]\";\n        }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String toString()\n        {\n            return \"1PC[\" + getIdentifier() + \", txId=\" + txId + \"]\";\n        }","id":85084,"modified_method":"public String toString()\n        {\n            return \"1PC[\" + getIdentifier() + \", txId=\" + getTxId() + \"]\";\n        }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"TwoPhaseCommit( int identifier, long txId )\n        {\n            super( identifier );\n            this.txId = txId;\n        }","id":85085,"modified_method":"TwoPhaseCommit( int identifier, long txId )\n        {\n            super( identifier, txId );\n        }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Done readTxDoneEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Done( identifier );\n    }","id":85086,"modified_method":"private static LogEntry.Done readTxDoneEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Done( identifier );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Command readTxCommand( \n            ByteBuffer buf, ReadableByteChannel channel, XaCommandFactory cf ) \n        throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        XaCommand command = cf.readCommand( channel, buf );\n        if ( command == null )\n        {\n            return null;\n        }\n        return new LogEntry.Command( identifier, command );\n    }","id":85087,"modified_method":"private static LogEntry.Command readTxCommandEntry( \n            ByteBuffer buf, ReadableByteChannel channel, XaCommandFactory cf ) \n        throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        XaCommand command = cf.readCommand( channel, buf );\n        if ( command == null )\n        {\n            return null;\n        }\n        return new LogEntry.Command( identifier, command );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.OnePhaseCommit readTxOnePhaseCommit( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.OnePhaseCommit( identifier, txId );\n    }","id":85088,"modified_method":"private static LogEntry.OnePhaseCommit readTxOnePhaseCommitEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.OnePhaseCommit( identifier, txId );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Prepare readTxPrepareEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Prepare( identifier );\n    }","id":85089,"modified_method":"private static LogEntry.Prepare readTxPrepareEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Prepare( identifier );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.TwoPhaseCommit readTxTwoPhaseCommit( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.TwoPhaseCommit( identifier, txId );\n    }","id":85090,"modified_method":"private static LogEntry.TwoPhaseCommit readTxTwoPhaseCommitEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.TwoPhaseCommit( identifier, txId );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Start readTxStartEntry( ByteBuffer buf, \n            ReadableByteChannel channel, long position ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte globalIdLength = buf.get();\n        // get the branchId id\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte branchIdLength = buf.get();\n        byte globalId[] = new byte[globalIdLength];\n        ByteBuffer tmpBuffer = ByteBuffer.wrap( globalId );\n        if ( channel.read( tmpBuffer ) != globalId.length )\n        {\n            return null;\n        }\n        byte branchId[] = new byte[branchIdLength];\n        tmpBuffer = ByteBuffer.wrap( branchId );\n        if ( channel.read( tmpBuffer ) != branchId.length )\n        {\n            return null;\n        }\n        // get the tx identifier\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        // get the format id\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int formatId = buf.getInt();\n        // re-create the transaction\n        Xid xid = new XidImpl( globalId, branchId, formatId );\n        return new LogEntry.Start( xid, identifier, position );\n    }","id":85091,"modified_method":"private static LogEntry.Start readTxStartEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte globalIdLength = buf.get();\n        // get the branchId id\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte branchIdLength = buf.get();\n        byte globalId[] = new byte[globalIdLength];\n        ByteBuffer tmpBuffer = ByteBuffer.wrap( globalId );\n        if ( channel.read( tmpBuffer ) != globalId.length )\n        {\n            return null;\n        }\n        byte branchId[] = new byte[branchIdLength];\n        tmpBuffer = ByteBuffer.wrap( branchId );\n        if ( channel.read( tmpBuffer ) != branchId.length )\n        {\n            return null;\n        }\n        // get the tx identifier\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        // get the format id\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int formatId = buf.getInt();\n        // re-create the transaction\n        Xid xid = new XidImpl( globalId, branchId, formatId );\n        return new LogEntry.Start( xid, identifier, -1 );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n        DumpLogicalLog.main( new String[] { currentLogFile } );\n        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        buffer.clear(); // ignore other 8 bytes\n        buffer.limit( 1 );\n        boolean emptyHit = false;\n        while ( fileChannel.read( buffer ) == 1 && !emptyHit )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    readAndWriteTxStartEntry( newLog );\n                    break;\n                case LogEntry.TX_PREPARE:\n                    readAndWriteTxPrepareEntry( newLog );\n                    break;\n                case LogEntry.TX_1P_COMMIT:\n                    readAndWriteTxOnePhaseCommit( newLog );\n                    break;\n                case LogEntry.TX_2P_COMMIT:\n                    readAndWriteTxTwoPhaseCommit( newLog );\n                    break;\n                case LogEntry.COMMAND:\n                    readAndWriteCommandEntry( newLog );\n                    break;\n                case LogEntry.DONE:\n                    readAndVerifyDoneEntry();\n                    break;\n                case LogEntry.EMPTY:\n                    emptyHit = true;\n                    break;\n                default:\n                    throw new IOException( \"Log rotation failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":85092,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"boolean readAndApplyAndWriteEntry( int newXidIdentifier ) throws IOException\n        {\n            buffer.clear();\n            buffer.limit( 1 );\n            if ( byteChannel.read( buffer ) != buffer.limit() )\n            {\n                // ok no more entries we're done\n                return false;\n            }\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry = null;\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    logEntry = readTxStartEntry( newXidIdentifier );\n                    startEntry = (LogEntry.Start) logEntry;\n                    break;\n                case LogEntry.TX_PREPARE:\n                    logEntry = readTxPrepareEntry( newXidIdentifier );\n                    break;\n                case LogEntry.TX_1P_COMMIT:\n                    logEntry = readAndApplyTxOnePhaseCommit( newXidIdentifier );\n                    break;\n                case LogEntry.TX_2P_COMMIT:\n                    logEntry = readAndApplyTxTwoPhaseCommit( newXidIdentifier );\n                    break;\n                case LogEntry.COMMAND:\n                    logEntry = readCommandEntry( newXidIdentifier );\n                    break;\n                case LogEntry.DONE:\n                    logEntry = readDoneEntry( newXidIdentifier );\n                    break;\n                case LogEntry.EMPTY:\n                    break;\n                default:\n                    throw new IOException( \"Internal recovery failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n            if ( logEntry != null )\n            {\n                logEntry.setIdentifier( newXidIdentifier );\n                LogIoUtils.writeLogEntry( logEntry, writeBuffer );\n                return true;\n            }\n            return false;\n        }","id":85093,"modified_method":"boolean readAndApplyAndWriteEntry( int newXidIdentifier ) throws IOException\n        {\n            LogEntry entry = LogIoUtils.readEntry( buffer, byteChannel, cf );\n            if ( entry != null )\n            {\n                entry.setIdentifier( newXidIdentifier );\n                applyEntry( entry );\n            }\n            if ( entry != null )\n            {\n                entry.setIdentifier( newXidIdentifier );\n                LogIoUtils.writeLogEntry( entry, writeBuffer );\n                return true;\n            }\n            return false;\n        }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n        DumpLogicalLog.main( new String[] { logFileName } );\n        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n        System.out.println( \" ---- Created \" + newName + \" -----\" );\n        DumpLogicalLog.main( new String[] { newName } );\n        System.out.println( \" ----- end ----\" );\n    }","id":85094,"modified_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":85095,"modified_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start entry = logApplier.startEntry;\n        if ( entry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = entry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":85096,"modified_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start entry = logApplier.startEntry;\n        if ( entry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = entry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void releaseCurrentLogFile() throws IOException\n    {\n        if ( writeBuffer != null )\n        {\n            writeBuffer.force();\n//            writeBuffer = null;\n        }\n        fileChannel.close();\n        fileChannel = null;\n    }","id":85097,"modified_method":"private void releaseCurrentLogFile() throws IOException\n    {\n        if ( writeBuffer != null )\n        {\n            writeBuffer.force();\n            writeBuffer = null;\n        }\n        fileChannel.close();\n        fileChannel = null;\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"boolean readAndApplyEntry() throws IOException\n        {\n            buffer.clear();\n            buffer.limit( 1 );\n            if ( byteChannel.read( buffer ) != buffer.limit() )\n            {\n                // ok no more entries we're done\n                return false;\n            }\n            buffer.flip();\n            byte entry = buffer.get();\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    readTxStartEntry( -1 );\n                    return true;\n                case LogEntry.TX_PREPARE:\n                    readTxPrepareEntry( -1 );\n                    return true;\n                case LogEntry.TX_1P_COMMIT:\n                    readAndApplyTxOnePhaseCommit( -1 );\n                    return true;\n                case LogEntry.TX_2P_COMMIT:\n                    readAndApplyTxTwoPhaseCommit( -1 );\n                    return true;\n                case LogEntry.COMMAND:\n                    readCommandEntry( -1 );\n                    return true;\n                case LogEntry.DONE:\n                    readDoneEntry( -1 );\n                    return true;\n                case LogEntry.EMPTY:\n                    return false;\n                default:\n                    throw new IOException( \"Internal recovery failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n        }","id":85098,"modified_method":"boolean readAndApplyEntry() throws IOException\n        {\n            LogEntry entry = LogIoUtils.readEntry( buffer, byteChannel, cf );\n            if ( entry != null )\n            {\n                applyEntry( entry );\n            }\n            return entry != null;\n        }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        buffer.clear();\n        buffer.limit( 1 );\n        boolean done = false;\n        while ( !done && log.read( buffer ) == buffer.limit() )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry;\n            switch ( entry )\n            {\n            case LogEntry.TX_START:\n                logEntry = LogIoUtils.readTxStartEntry( buffer, log, -1 );\n                if ( logEntry.getIdentifier() == identifier )\n                {\n                    logEntryList.add( logEntry );\n                }\n                break;\n            case LogEntry.TX_PREPARE:\n                logEntry = LogIoUtils.readTxPrepareEntry( buffer, log );\n                break;\n            case LogEntry.COMMAND:\n                logEntry = LogIoUtils.readTxCommand( buffer, log, cf );\n                if ( logEntry.getIdentifier() == identifier )\n                {\n                    logEntryList.add( logEntry );\n                }\n                break;\n            case LogEntry.TX_1P_COMMIT:\n                logEntry = LogIoUtils.readTxOnePhaseCommit( buffer, log );\n                break;\n            case LogEntry.TX_2P_COMMIT:\n                logEntry = LogIoUtils.readTxTwoPhaseCommit( buffer, log );\n                break;\n            case LogEntry.DONE:\n                logEntry = LogIoUtils.readTxDoneEntry( buffer, log );\n                break;\n            case LogEntry.EMPTY:\n                done = true;\n                break;\n            default:\n                throw new IOException( \"Unknown log entry \" + entry );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","id":85099,"modified_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean readEntry() throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 1 );\n        if ( fileChannel.read( buffer ) != buffer.limit() )\n        {\n            // ok no more entries we're done\n            return false;\n        }\n        buffer.flip();\n        byte entry = buffer.get();\n        switch ( entry )\n        {\n            case LogEntry.TX_START:\n                return readTxStartEntry();\n            case LogEntry.TX_PREPARE:\n                return readTxPrepareEntry();\n            case LogEntry.TX_1P_COMMIT:\n                return readTxOnePhaseCommit();\n            case LogEntry.TX_2P_COMMIT:\n                return readTxTwoPhaseCommit();\n            case LogEntry.COMMAND:\n                return readCommandEntry();\n            case LogEntry.DONE:\n                return readDoneEntry();\n            case LogEntry.EMPTY:\n                fileChannel.position( fileChannel.position() - 1 );\n                return false;\n            default:\n                throw new IOException( \"Internal recovery failed, \"\n                    + \"unknown log entry[\" + entry + \"]\" );\n        }\n    }","id":85100,"modified_method":"private LogEntry readEntry() throws IOException\n    {\n        long position = fileChannel.position();\n        LogEntry entry = LogIoUtils.readEntry( buffer, fileChannel, cf );\n        if ( entry instanceof LogEntry.Start )\n        {\n            ((LogEntry.Start) entry).setStartPosition( position );\n        }\n        return entry;\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void fixCleanKill( String fileName ) throws IOException\n    {\n        File file = new File( fileName );\n        if ( !keepLogs )\n        {\n            if ( !file.delete() )\n            {\n                throw new IllegalStateException( \n                    \"Active marked as clean and unable to delete log \" + \n                    fileName );\n            }\n        }\n        else\n        {\n            System.out.println( \"close fix cleanKill () @ pos: \" + writeBuffer.getFileChannelPosition() + \" and endPos=\" + file.length() );\n            renameCurrentLogFileAndIncrementVersion( fileName, file.length() );\n        }\n    }","id":85101,"modified_method":"private void fixCleanKill( String fileName ) throws IOException\n    {\n        File file = new File( fileName );\n        if ( !keepLogs )\n        {\n            if ( !file.delete() )\n            {\n                throw new IllegalStateException( \n                    \"Active marked as clean and unable to delete log \" + \n                    fileName );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName, file.length() );\n        }\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        while ( readEntry() )\n        {\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start entry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    entry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","id":85102,"modified_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.fine( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Close invoked with \" + xidIdentMap.size() + \n                \" running transaction(s). \" );\n            writeBuffer.force();\n            // writeBuffer = null;\n            fileChannel.close();\n            log.info( \"Dirty log: \" + fileName + \".\" + currentLog + \n                \" now closed. Recovery will be started automatically next \" + \n                \"time it is opened.\" );\n            return;\n        }\n        releaseCurrentLogFile();\n        char logWas = currentLog;\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( logWas == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + logWas );\n            }\n        }\n        else\n        {\n            System.out.println( \"close() @ pos: \" + writeBuffer.getFileChannelPosition() + \" and endPos=\" + endPosition );\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                logWas, endPosition );\n        }\n    }","id":85103,"modified_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.fine( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Close invoked with \" + xidIdentMap.size() + \n                \" running transaction(s). \" );\n            writeBuffer.force();\n            writeBuffer = null;\n            fileChannel.close();\n            log.info( \"Dirty log: \" + fileName + \".\" + currentLog + \n                \" now closed. Recovery will be started automatically next \" + \n                \"time it is opened.\" );\n            return;\n        }\n        releaseCurrentLogFile();\n        char logWas = currentLog;\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( logWas == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + logWas );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                logWas, endPosition );\n        }\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        buffer.clear();\n        buffer.limit( 1 );\n        while ( logEntryList == null && \n                log.read( buffer ) == buffer.limit() )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry;\n            switch ( entry )\n            {\n            case LogEntry.TX_START:\n                logEntry = LogIoUtils.readTxStartEntry( buffer, log, -1 );\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( logEntry );\n                transactions.put( logEntry.getIdentifier(), list );\n                break;\n            case LogEntry.TX_PREPARE:\n                logEntry = LogIoUtils.readTxPrepareEntry( buffer, log );\n                transactions.get( logEntry.getIdentifier() ).add( logEntry );\n                break;\n            case LogEntry.TX_1P_COMMIT:\n                logEntry = LogIoUtils.readTxOnePhaseCommit( buffer, log );\n                if ( ((LogEntry.OnePhaseCommit) logEntry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( logEntry.getIdentifier() );\n                    logEntryList.add( logEntry );\n                }\n                else\n                {\n                    transactions.remove( logEntry.getIdentifier() );\n                }\n                break;\n            case LogEntry.TX_2P_COMMIT:\n                logEntry = LogIoUtils.readTxTwoPhaseCommit( buffer, log );\n                if ( ((LogEntry.TwoPhaseCommit) logEntry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( logEntry.getIdentifier() );\n                    logEntryList.add( logEntry );\n                }\n                else\n                {\n                    transactions.remove( logEntry.getIdentifier() );\n                }\n                break;\n            case LogEntry.COMMAND:\n                logEntry = LogIoUtils.readTxCommand( buffer, log, cf );\n                transactions.get( logEntry.getIdentifier() ).add( logEntry );\n                break;\n            case LogEntry.DONE:\n                logEntry = LogIoUtils.readTxDoneEntry( buffer, log );\n                transactions.remove( logEntry.getIdentifier() );\n                break;\n            default:\n                throw new IOException( \"Unable to locate transaction[\"\n                    + txId + \"]\" );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","id":85104,"modified_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","commit_id":"1362fe5b0fa6aea1f7a6805553da612e4f692694","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static boolean readEntry( FileChannel channel, ByteBuffer buf, \n            XaCommandFactory cf ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            // ok no more entries we're done\n            return false;\n        }\n        buf.flip();\n        byte byteEntry = buf.get();\n        LogEntry entry;\n        switch ( byteEntry )\n        {\n            case LogEntry.TX_START:\n                long position = channel.position();\n                entry = LogIoUtils.readTxStartEntry( buf, channel, position );\n                System.out.println( \"Start: \" + entry );\n                return entry != null;\n            case LogEntry.TX_PREPARE:\n                entry = LogIoUtils.readTxPrepareEntry( buf, channel );\n                System.out.println( \"Prepare: \" + entry );\n                return entry != null;\n            case LogEntry.TX_1P_COMMIT:\n                entry = LogIoUtils.readTxOnePhaseCommit( buf, channel );\n                System.out.println( \"1PC: \" + entry );\n                return entry != null;\n            case LogEntry.TX_2P_COMMIT:\n                entry = LogIoUtils.readTxTwoPhaseCommit( buf, channel );\n                System.out.println( \"2PC: \" + entry );\n                return entry != null;\n            case LogEntry.COMMAND:\n                entry = LogIoUtils.readTxCommand( buf, channel, cf );\n                System.out.println( \"Command: \" + entry );\n                return entry != null;\n            case LogEntry.DONE:\n                entry = LogIoUtils.readTxDoneEntry( buf, channel );\n                System.out.println( \"Done: \" + entry );\n                return entry != null;\n            case LogEntry.EMPTY:\n                position = channel.position();\n                System.out.println( \"Empty @ position \" + position );\n                channel.position( channel.position() - 1 );\n                return false;\n            default:\n                throw new IOException( \"Internal recovery failed, \"\n                    + \"unknown log entry[\" + byteEntry + \"]\" );\n        }\n    }","id":85105,"modified_method":"private static boolean readEntry( FileChannel channel, ByteBuffer buf, \n            XaCommandFactory cf ) throws IOException\n    {\n        LogEntry entry = LogIoUtils.readEntry( buf, channel, cf );\n        if ( entry != null )\n        {\n            System.out.println( entry.toString() );\n            return true;\n        }\n        return false;\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"TwoPhaseCommit( int identifier, long txId )\n        {\n            super( identifier );\n            this.txId = txId;\n        }","id":85106,"modified_method":"TwoPhaseCommit( int identifier, long txId )\n        {\n            super( identifier, txId );\n        }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String toString()\n        {\n            return \"2PC[\" + getIdentifier() + \", txId=\" + txId + \"]\";\n        }","id":85107,"modified_method":"public String toString()\n        {\n            return \"2PC[\" + getIdentifier() + \", txId=\" + getTxId() + \"]\";\n        }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String toString()\n        {\n            return \"1PC[\" + getIdentifier() + \", txId=\" + txId + \"]\";\n        }","id":85108,"modified_method":"public String toString()\n        {\n            return \"1PC[\" + getIdentifier() + \", txId=\" + getTxId() + \"]\";\n        }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"OnePhaseCommit( int identifier, long txId )\n        {\n            super( identifier );\n            this.txId = txId;\n        }","id":85109,"modified_method":"OnePhaseCommit( int identifier, long txId )\n        {\n            super( identifier, txId );\n        }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.OnePhaseCommit readTxOnePhaseCommit( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.OnePhaseCommit( identifier, txId );\n    }","id":85110,"modified_method":"private static LogEntry.OnePhaseCommit readTxOnePhaseCommitEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.OnePhaseCommit( identifier, txId );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.TwoPhaseCommit readTxTwoPhaseCommit( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.TwoPhaseCommit( identifier, txId );\n    }","id":85111,"modified_method":"private static LogEntry.TwoPhaseCommit readTxTwoPhaseCommitEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.TwoPhaseCommit( identifier, txId );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Command readTxCommand( \n            ByteBuffer buf, ReadableByteChannel channel, XaCommandFactory cf ) \n        throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        XaCommand command = cf.readCommand( channel, buf );\n        if ( command == null )\n        {\n            return null;\n        }\n        return new LogEntry.Command( identifier, command );\n    }","id":85112,"modified_method":"private static LogEntry.Command readTxCommandEntry( \n            ByteBuffer buf, ReadableByteChannel channel, XaCommandFactory cf ) \n        throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        XaCommand command = cf.readCommand( channel, buf );\n        if ( command == null )\n        {\n            return null;\n        }\n        return new LogEntry.Command( identifier, command );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Start readTxStartEntry( ByteBuffer buf, \n            ReadableByteChannel channel, long position ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte globalIdLength = buf.get();\n        // get the branchId id\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte branchIdLength = buf.get();\n        byte globalId[] = new byte[globalIdLength];\n        ByteBuffer tmpBuffer = ByteBuffer.wrap( globalId );\n        if ( channel.read( tmpBuffer ) != globalId.length )\n        {\n            return null;\n        }\n        byte branchId[] = new byte[branchIdLength];\n        tmpBuffer = ByteBuffer.wrap( branchId );\n        if ( channel.read( tmpBuffer ) != branchId.length )\n        {\n            return null;\n        }\n        // get the tx identifier\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        // get the format id\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int formatId = buf.getInt();\n        // re-create the transaction\n        Xid xid = new XidImpl( globalId, branchId, formatId );\n        return new LogEntry.Start( xid, identifier, position );\n    }","id":85113,"modified_method":"private static LogEntry.Start readTxStartEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte globalIdLength = buf.get();\n        // get the branchId id\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte branchIdLength = buf.get();\n        byte globalId[] = new byte[globalIdLength];\n        ByteBuffer tmpBuffer = ByteBuffer.wrap( globalId );\n        if ( channel.read( tmpBuffer ) != globalId.length )\n        {\n            return null;\n        }\n        byte branchId[] = new byte[branchIdLength];\n        tmpBuffer = ByteBuffer.wrap( branchId );\n        if ( channel.read( tmpBuffer ) != branchId.length )\n        {\n            return null;\n        }\n        // get the tx identifier\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        // get the format id\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int formatId = buf.getInt();\n        // re-create the transaction\n        Xid xid = new XidImpl( globalId, branchId, formatId );\n        return new LogEntry.Start( xid, identifier, -1 );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Done readTxDoneEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Done( identifier );\n    }","id":85114,"modified_method":"private static LogEntry.Done readTxDoneEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Done( identifier );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Prepare readTxPrepareEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Prepare( identifier );\n    }","id":85115,"modified_method":"private static LogEntry.Prepare readTxPrepareEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Prepare( identifier );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        while ( readEntry() )\n        {\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start entry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    entry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","id":85116,"modified_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void releaseCurrentLogFile() throws IOException\n    {\n        if ( writeBuffer != null )\n        {\n            writeBuffer.force();\n//            writeBuffer = null;\n        }\n        fileChannel.close();\n        fileChannel = null;\n    }","id":85117,"modified_method":"private void releaseCurrentLogFile() throws IOException\n    {\n        if ( writeBuffer != null )\n        {\n            writeBuffer.force();\n            writeBuffer = null;\n        }\n        fileChannel.close();\n        fileChannel = null;\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"boolean readAndApplyEntry() throws IOException\n        {\n            buffer.clear();\n            buffer.limit( 1 );\n            if ( byteChannel.read( buffer ) != buffer.limit() )\n            {\n                // ok no more entries we're done\n                return false;\n            }\n            buffer.flip();\n            byte entry = buffer.get();\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    readTxStartEntry( -1 );\n                    return true;\n                case LogEntry.TX_PREPARE:\n                    readTxPrepareEntry( -1 );\n                    return true;\n                case LogEntry.TX_1P_COMMIT:\n                    readAndApplyTxOnePhaseCommit( -1 );\n                    return true;\n                case LogEntry.TX_2P_COMMIT:\n                    readAndApplyTxTwoPhaseCommit( -1 );\n                    return true;\n                case LogEntry.COMMAND:\n                    readCommandEntry( -1 );\n                    return true;\n                case LogEntry.DONE:\n                    readDoneEntry( -1 );\n                    return true;\n                case LogEntry.EMPTY:\n                    return false;\n                default:\n                    throw new IOException( \"Internal recovery failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n        }","id":85118,"modified_method":"boolean readAndApplyEntry() throws IOException\n        {\n            LogEntry entry = LogIoUtils.readEntry( buffer, byteChannel, cf );\n            if ( entry != null )\n            {\n                applyEntry( entry );\n            }\n            return entry != null;\n        }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n        DumpLogicalLog.main( new String[] { currentLogFile } );\n        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        buffer.clear(); // ignore other 8 bytes\n        buffer.limit( 1 );\n        boolean emptyHit = false;\n        while ( fileChannel.read( buffer ) == 1 && !emptyHit )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    readAndWriteTxStartEntry( newLog );\n                    break;\n                case LogEntry.TX_PREPARE:\n                    readAndWriteTxPrepareEntry( newLog );\n                    break;\n                case LogEntry.TX_1P_COMMIT:\n                    readAndWriteTxOnePhaseCommit( newLog );\n                    break;\n                case LogEntry.TX_2P_COMMIT:\n                    readAndWriteTxTwoPhaseCommit( newLog );\n                    break;\n                case LogEntry.COMMAND:\n                    readAndWriteCommandEntry( newLog );\n                    break;\n                case LogEntry.DONE:\n                    readAndVerifyDoneEntry();\n                    break;\n                case LogEntry.EMPTY:\n                    emptyHit = true;\n                    break;\n                default:\n                    throw new IOException( \"Log rotation failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":85119,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start entry = logApplier.startEntry;\n        if ( entry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = entry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":85120,"modified_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start entry = logApplier.startEntry;\n        if ( entry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = entry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.fine( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Close invoked with \" + xidIdentMap.size() + \n                \" running transaction(s). \" );\n            writeBuffer.force();\n            // writeBuffer = null;\n            fileChannel.close();\n            log.info( \"Dirty log: \" + fileName + \".\" + currentLog + \n                \" now closed. Recovery will be started automatically next \" + \n                \"time it is opened.\" );\n            return;\n        }\n        releaseCurrentLogFile();\n        char logWas = currentLog;\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( logWas == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + logWas );\n            }\n        }\n        else\n        {\n            System.out.println( \"close() @ pos: \" + writeBuffer.getFileChannelPosition() + \" and endPos=\" + endPosition );\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                logWas, endPosition );\n        }\n    }","id":85121,"modified_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.fine( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Close invoked with \" + xidIdentMap.size() + \n                \" running transaction(s). \" );\n            writeBuffer.force();\n            writeBuffer = null;\n            fileChannel.close();\n            log.info( \"Dirty log: \" + fileName + \".\" + currentLog + \n                \" now closed. Recovery will be started automatically next \" + \n                \"time it is opened.\" );\n            return;\n        }\n        releaseCurrentLogFile();\n        char logWas = currentLog;\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( logWas == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + logWas );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                logWas, endPosition );\n        }\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        buffer.clear();\n        buffer.limit( 1 );\n        boolean done = false;\n        while ( !done && log.read( buffer ) == buffer.limit() )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry;\n            switch ( entry )\n            {\n            case LogEntry.TX_START:\n                logEntry = LogIoUtils.readTxStartEntry( buffer, log, -1 );\n                if ( logEntry.getIdentifier() == identifier )\n                {\n                    logEntryList.add( logEntry );\n                }\n                break;\n            case LogEntry.TX_PREPARE:\n                logEntry = LogIoUtils.readTxPrepareEntry( buffer, log );\n                break;\n            case LogEntry.COMMAND:\n                logEntry = LogIoUtils.readTxCommand( buffer, log, cf );\n                if ( logEntry.getIdentifier() == identifier )\n                {\n                    logEntryList.add( logEntry );\n                }\n                break;\n            case LogEntry.TX_1P_COMMIT:\n                logEntry = LogIoUtils.readTxOnePhaseCommit( buffer, log );\n                break;\n            case LogEntry.TX_2P_COMMIT:\n                logEntry = LogIoUtils.readTxTwoPhaseCommit( buffer, log );\n                break;\n            case LogEntry.DONE:\n                logEntry = LogIoUtils.readTxDoneEntry( buffer, log );\n                break;\n            case LogEntry.EMPTY:\n                done = true;\n                break;\n            default:\n                throw new IOException( \"Unknown log entry \" + entry );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","id":85122,"modified_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n        DumpLogicalLog.main( new String[] { logFileName } );\n        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n        System.out.println( \" ---- Created \" + newName + \" -----\" );\n        DumpLogicalLog.main( new String[] { newName } );\n        System.out.println( \" ----- end ----\" );\n    }","id":85123,"modified_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean readEntry() throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 1 );\n        if ( fileChannel.read( buffer ) != buffer.limit() )\n        {\n            // ok no more entries we're done\n            return false;\n        }\n        buffer.flip();\n        byte entry = buffer.get();\n        switch ( entry )\n        {\n            case LogEntry.TX_START:\n                return readTxStartEntry();\n            case LogEntry.TX_PREPARE:\n                return readTxPrepareEntry();\n            case LogEntry.TX_1P_COMMIT:\n                return readTxOnePhaseCommit();\n            case LogEntry.TX_2P_COMMIT:\n                return readTxTwoPhaseCommit();\n            case LogEntry.COMMAND:\n                return readCommandEntry();\n            case LogEntry.DONE:\n                return readDoneEntry();\n            case LogEntry.EMPTY:\n                fileChannel.position( fileChannel.position() - 1 );\n                return false;\n            default:\n                throw new IOException( \"Internal recovery failed, \"\n                    + \"unknown log entry[\" + entry + \"]\" );\n        }\n    }","id":85124,"modified_method":"private LogEntry readEntry() throws IOException\n    {\n        long position = fileChannel.position();\n        LogEntry entry = LogIoUtils.readEntry( buffer, fileChannel, cf );\n        if ( entry instanceof LogEntry.Start )\n        {\n            ((LogEntry.Start) entry).setStartPosition( position );\n        }\n        return entry;\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":85125,"modified_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void fixCleanKill( String fileName ) throws IOException\n    {\n        File file = new File( fileName );\n        if ( !keepLogs )\n        {\n            if ( !file.delete() )\n            {\n                throw new IllegalStateException( \n                    \"Active marked as clean and unable to delete log \" + \n                    fileName );\n            }\n        }\n        else\n        {\n            System.out.println( \"close fix cleanKill () @ pos: \" + writeBuffer.getFileChannelPosition() + \" and endPos=\" + file.length() );\n            renameCurrentLogFileAndIncrementVersion( fileName, file.length() );\n        }\n    }","id":85126,"modified_method":"private void fixCleanKill( String fileName ) throws IOException\n    {\n        File file = new File( fileName );\n        if ( !keepLogs )\n        {\n            if ( !file.delete() )\n            {\n                throw new IllegalStateException( \n                    \"Active marked as clean and unable to delete log \" + \n                    fileName );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName, file.length() );\n        }\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"boolean readAndApplyAndWriteEntry( int newXidIdentifier ) throws IOException\n        {\n            buffer.clear();\n            buffer.limit( 1 );\n            if ( byteChannel.read( buffer ) != buffer.limit() )\n            {\n                // ok no more entries we're done\n                return false;\n            }\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry = null;\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    logEntry = readTxStartEntry( newXidIdentifier );\n                    startEntry = (LogEntry.Start) logEntry;\n                    break;\n                case LogEntry.TX_PREPARE:\n                    logEntry = readTxPrepareEntry( newXidIdentifier );\n                    break;\n                case LogEntry.TX_1P_COMMIT:\n                    logEntry = readAndApplyTxOnePhaseCommit( newXidIdentifier );\n                    break;\n                case LogEntry.TX_2P_COMMIT:\n                    logEntry = readAndApplyTxTwoPhaseCommit( newXidIdentifier );\n                    break;\n                case LogEntry.COMMAND:\n                    logEntry = readCommandEntry( newXidIdentifier );\n                    break;\n                case LogEntry.DONE:\n                    logEntry = readDoneEntry( newXidIdentifier );\n                    break;\n                case LogEntry.EMPTY:\n                    break;\n                default:\n                    throw new IOException( \"Internal recovery failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n            if ( logEntry != null )\n            {\n                logEntry.setIdentifier( newXidIdentifier );\n                LogIoUtils.writeLogEntry( logEntry, writeBuffer );\n                return true;\n            }\n            return false;\n        }","id":85127,"modified_method":"boolean readAndApplyAndWriteEntry( int newXidIdentifier ) throws IOException\n        {\n            LogEntry entry = LogIoUtils.readEntry( buffer, byteChannel, cf );\n            if ( entry != null )\n            {\n                entry.setIdentifier( newXidIdentifier );\n                applyEntry( entry );\n            }\n            if ( entry != null )\n            {\n                entry.setIdentifier( newXidIdentifier );\n                LogIoUtils.writeLogEntry( entry, writeBuffer );\n                return true;\n            }\n            return false;\n        }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        buffer.clear();\n        buffer.limit( 1 );\n        while ( logEntryList == null && \n                log.read( buffer ) == buffer.limit() )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry;\n            switch ( entry )\n            {\n            case LogEntry.TX_START:\n                logEntry = LogIoUtils.readTxStartEntry( buffer, log, -1 );\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( logEntry );\n                transactions.put( logEntry.getIdentifier(), list );\n                break;\n            case LogEntry.TX_PREPARE:\n                logEntry = LogIoUtils.readTxPrepareEntry( buffer, log );\n                transactions.get( logEntry.getIdentifier() ).add( logEntry );\n                break;\n            case LogEntry.TX_1P_COMMIT:\n                logEntry = LogIoUtils.readTxOnePhaseCommit( buffer, log );\n                if ( ((LogEntry.OnePhaseCommit) logEntry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( logEntry.getIdentifier() );\n                    logEntryList.add( logEntry );\n                }\n                else\n                {\n                    transactions.remove( logEntry.getIdentifier() );\n                }\n                break;\n            case LogEntry.TX_2P_COMMIT:\n                logEntry = LogIoUtils.readTxTwoPhaseCommit( buffer, log );\n                if ( ((LogEntry.TwoPhaseCommit) logEntry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( logEntry.getIdentifier() );\n                    logEntryList.add( logEntry );\n                }\n                else\n                {\n                    transactions.remove( logEntry.getIdentifier() );\n                }\n                break;\n            case LogEntry.COMMAND:\n                logEntry = LogIoUtils.readTxCommand( buffer, log, cf );\n                transactions.get( logEntry.getIdentifier() ).add( logEntry );\n                break;\n            case LogEntry.DONE:\n                logEntry = LogIoUtils.readTxDoneEntry( buffer, log );\n                transactions.remove( logEntry.getIdentifier() );\n                break;\n            default:\n                throw new IOException( \"Unable to locate transaction[\"\n                    + txId + \"]\" );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","id":85128,"modified_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","commit_id":"0053e0df2a134c41e9579e7390012dde93f50dd9","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static boolean readEntry( FileChannel channel, ByteBuffer buf, \n            XaCommandFactory cf ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            // ok no more entries we're done\n            return false;\n        }\n        buf.flip();\n        byte byteEntry = buf.get();\n        LogEntry entry;\n        switch ( byteEntry )\n        {\n            case LogEntry.TX_START:\n                long position = channel.position();\n                entry = LogIoUtils.readTxStartEntry( buf, channel, position );\n                System.out.println( \"Start: \" + entry );\n                return entry != null;\n            case LogEntry.TX_PREPARE:\n                entry = LogIoUtils.readTxPrepareEntry( buf, channel );\n                System.out.println( \"Prepare: \" + entry );\n                return entry != null;\n            case LogEntry.TX_1P_COMMIT:\n                entry = LogIoUtils.readTxOnePhaseCommit( buf, channel );\n                System.out.println( \"1PC: \" + entry );\n                return entry != null;\n            case LogEntry.TX_2P_COMMIT:\n                entry = LogIoUtils.readTxTwoPhaseCommit( buf, channel );\n                System.out.println( \"2PC: \" + entry );\n                return entry != null;\n            case LogEntry.COMMAND:\n                entry = LogIoUtils.readTxCommand( buf, channel, cf );\n                System.out.println( \"Command: \" + entry );\n                return entry != null;\n            case LogEntry.DONE:\n                entry = LogIoUtils.readTxDoneEntry( buf, channel );\n                System.out.println( \"Done: \" + entry );\n                return entry != null;\n            case LogEntry.EMPTY:\n                position = channel.position();\n                System.out.println( \"Empty @ position \" + position );\n                channel.position( channel.position() - 1 );\n                return false;\n            default:\n                throw new IOException( \"Internal recovery failed, \"\n                    + \"unknown log entry[\" + byteEntry + \"]\" );\n        }\n    }","id":85129,"modified_method":"private static boolean readEntry( FileChannel channel, ByteBuffer buf, \n            XaCommandFactory cf ) throws IOException\n    {\n        LogEntry entry = LogIoUtils.readEntry( buf, channel, cf );\n        if ( entry != null )\n        {\n            System.out.println( entry.toString() );\n            return true;\n        }\n        return false;\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String toString()\n        {\n            return \"2PC[\" + getIdentifier() + \", txId=\" + txId + \"]\";\n        }","id":85130,"modified_method":"public String toString()\n        {\n            return \"2PC[\" + getIdentifier() + \", txId=\" + getTxId() + \"]\";\n        }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"TwoPhaseCommit( int identifier, long txId )\n        {\n            super( identifier );\n            this.txId = txId;\n        }","id":85131,"modified_method":"TwoPhaseCommit( int identifier, long txId )\n        {\n            super( identifier, txId );\n        }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public String toString()\n        {\n            return \"1PC[\" + getIdentifier() + \", txId=\" + txId + \"]\";\n        }","id":85132,"modified_method":"public String toString()\n        {\n            return \"1PC[\" + getIdentifier() + \", txId=\" + getTxId() + \"]\";\n        }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"OnePhaseCommit( int identifier, long txId )\n        {\n            super( identifier );\n            this.txId = txId;\n        }","id":85133,"modified_method":"OnePhaseCommit( int identifier, long txId )\n        {\n            super( identifier, txId );\n        }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Prepare readTxPrepareEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Prepare( identifier );\n    }","id":85134,"modified_method":"private static LogEntry.Prepare readTxPrepareEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Prepare( identifier );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Start readTxStartEntry( ByteBuffer buf, \n            ReadableByteChannel channel, long position ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte globalIdLength = buf.get();\n        // get the branchId id\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte branchIdLength = buf.get();\n        byte globalId[] = new byte[globalIdLength];\n        ByteBuffer tmpBuffer = ByteBuffer.wrap( globalId );\n        if ( channel.read( tmpBuffer ) != globalId.length )\n        {\n            return null;\n        }\n        byte branchId[] = new byte[branchIdLength];\n        tmpBuffer = ByteBuffer.wrap( branchId );\n        if ( channel.read( tmpBuffer ) != branchId.length )\n        {\n            return null;\n        }\n        // get the tx identifier\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        // get the format id\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int formatId = buf.getInt();\n        // re-create the transaction\n        Xid xid = new XidImpl( globalId, branchId, formatId );\n        return new LogEntry.Start( xid, identifier, position );\n    }","id":85135,"modified_method":"private static LogEntry.Start readTxStartEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte globalIdLength = buf.get();\n        // get the branchId id\n        buf.clear();\n        buf.limit( 1 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        byte branchIdLength = buf.get();\n        byte globalId[] = new byte[globalIdLength];\n        ByteBuffer tmpBuffer = ByteBuffer.wrap( globalId );\n        if ( channel.read( tmpBuffer ) != globalId.length )\n        {\n            return null;\n        }\n        byte branchId[] = new byte[branchIdLength];\n        tmpBuffer = ByteBuffer.wrap( branchId );\n        if ( channel.read( tmpBuffer ) != branchId.length )\n        {\n            return null;\n        }\n        // get the tx identifier\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        // get the format id\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int formatId = buf.getInt();\n        // re-create the transaction\n        Xid xid = new XidImpl( globalId, branchId, formatId );\n        return new LogEntry.Start( xid, identifier, -1 );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.OnePhaseCommit readTxOnePhaseCommit( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.OnePhaseCommit( identifier, txId );\n    }","id":85136,"modified_method":"private static LogEntry.OnePhaseCommit readTxOnePhaseCommitEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.OnePhaseCommit( identifier, txId );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Done readTxDoneEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Done( identifier );\n    }","id":85137,"modified_method":"private static LogEntry.Done readTxDoneEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        return new LogEntry.Done( identifier );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.TwoPhaseCommit readTxTwoPhaseCommit( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.TwoPhaseCommit( identifier, txId );\n    }","id":85138,"modified_method":"private static LogEntry.TwoPhaseCommit readTxTwoPhaseCommitEntry( ByteBuffer buf, \n            ReadableByteChannel channel ) throws IOException\n    {\n        buf.clear();\n        buf.limit( 12 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        long txId = buf.getLong();\n        return new LogEntry.TwoPhaseCommit( identifier, txId );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static LogEntry.Command readTxCommand( \n            ByteBuffer buf, ReadableByteChannel channel, XaCommandFactory cf ) \n        throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        XaCommand command = cf.readCommand( channel, buf );\n        if ( command == null )\n        {\n            return null;\n        }\n        return new LogEntry.Command( identifier, command );\n    }","id":85139,"modified_method":"private static LogEntry.Command readTxCommandEntry( \n            ByteBuffer buf, ReadableByteChannel channel, XaCommandFactory cf ) \n        throws IOException\n    {\n        buf.clear();\n        buf.limit( 4 );\n        if ( channel.read( buf ) != buf.limit() )\n        {\n            return null;\n        }\n        buf.flip();\n        int identifier = buf.getInt();\n        XaCommand command = cf.readCommand( channel, buf );\n        if ( command == null )\n        {\n            return null;\n        }\n        return new LogEntry.Command( identifier, command );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"boolean readAndApplyAndWriteEntry( int newXidIdentifier ) throws IOException\n        {\n            buffer.clear();\n            buffer.limit( 1 );\n            if ( byteChannel.read( buffer ) != buffer.limit() )\n            {\n                // ok no more entries we're done\n                return false;\n            }\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry = null;\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    logEntry = readTxStartEntry( newXidIdentifier );\n                    startEntry = (LogEntry.Start) logEntry;\n                    break;\n                case LogEntry.TX_PREPARE:\n                    logEntry = readTxPrepareEntry( newXidIdentifier );\n                    break;\n                case LogEntry.TX_1P_COMMIT:\n                    logEntry = readAndApplyTxOnePhaseCommit( newXidIdentifier );\n                    break;\n                case LogEntry.TX_2P_COMMIT:\n                    logEntry = readAndApplyTxTwoPhaseCommit( newXidIdentifier );\n                    break;\n                case LogEntry.COMMAND:\n                    logEntry = readCommandEntry( newXidIdentifier );\n                    break;\n                case LogEntry.DONE:\n                    logEntry = readDoneEntry( newXidIdentifier );\n                    break;\n                case LogEntry.EMPTY:\n                    break;\n                default:\n                    throw new IOException( \"Internal recovery failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n            if ( logEntry != null )\n            {\n                logEntry.setIdentifier( newXidIdentifier );\n                LogIoUtils.writeLogEntry( logEntry, writeBuffer );\n                return true;\n            }\n            return false;\n        }","id":85140,"modified_method":"boolean readAndApplyAndWriteEntry( int newXidIdentifier ) throws IOException\n        {\n            LogEntry entry = LogIoUtils.readEntry( buffer, byteChannel, cf );\n            if ( entry != null )\n            {\n                entry.setIdentifier( newXidIdentifier );\n                applyEntry( entry );\n            }\n            if ( entry != null )\n            {\n                entry.setIdentifier( newXidIdentifier );\n                LogIoUtils.writeLogEntry( entry, writeBuffer );\n                return true;\n            }\n            return false;\n        }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        while ( readEntry() )\n        {\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start entry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    entry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","id":85141,"modified_method":"private void doInternalRecovery( String logFileName ) throws IOException\n    {\n        log.info( \"Non clean shutdown detected on log [\" + logFileName + \n            \"]. Recovery started ...\" );\n        // get log creation time\n        buffer.clear();\n        buffer.limit( 16 );\n        if ( fileChannel.read( buffer ) != 16 )\n        {\n            log.info( \"Unable to read timestamp information, \"\n                + \"no records in logical log.\" );\n            fileChannel.close();\n            boolean success = FileUtils.renameFile( new File( logFileName ), \n                new File( logFileName + \"_unknown_timestamp_\" + \n                    System.currentTimeMillis() + \".log\" ) );\n            assert success;\n            fileChannel = new RandomAccessFile( logFileName, \n                \"rw\" ).getChannel();\n            return;\n        }\n        buffer.flip();\n        logVersion = buffer.getLong();\n        long lastCommittedTx = buffer.getLong();\n        previousLogLastCommittedTx = lastCommittedTx;\n        log.fine( \"Logical log version: \" + logVersion + \" with committed tx[\" +\n            lastCommittedTx + \"]\" );\n        long logEntriesFound = 0;\n        long lastEntryPos = fileChannel.position();\n        LogEntry entry;\n        while ( (entry = readEntry()) != null )\n        {\n            applyEntry( entry );\n            logEntriesFound++;\n            lastEntryPos = fileChannel.position();\n        }\n        // make sure we overwrite any broken records\n        fileChannel.position( lastEntryPos );\n        // zero out the slow way since windows don't support truncate very well\n        buffer.clear();\n        while ( buffer.hasRemaining() )\n        {\n            buffer.put( (byte)0 );\n        }\n        buffer.flip();\n        long endPosition = fileChannel.size();\n        do\n        {\n            long bytesLeft = fileChannel.size() - fileChannel.position();\n            if ( bytesLeft < buffer.capacity() )\n            {\n                buffer.limit( (int) bytesLeft );\n            }\n            fileChannel.write( buffer );\n            buffer.flip();\n        } while ( fileChannel.position() < endPosition );\n        fileChannel.position( lastEntryPos );\n        scanIsComplete = true;\n        log.fine( \"Internal recovery completed, scanned \" + logEntriesFound\n            + \" log entries.\" );\n        xaRm.checkXids();\n        if ( xidIdentMap.size() == 0 )\n        {\n            log.fine( \"Recovery completed.\" );\n        }\n        else\n        {\n            log.fine( \"[\" + logFileName + \"] Found \" + xidIdentMap.size()\n                + \" prepared 2PC transactions.\" );\n            for ( LogEntry.Start startEntry : xidIdentMap.values() )\n            {\n                log.fine( \"[\" + logFileName + \"] 2PC xid[\" + \n                    startEntry.getXid() + \"]\" );\n            }\n        }\n        recoveredTxMap.clear();\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void fixCleanKill( String fileName ) throws IOException\n    {\n        File file = new File( fileName );\n        if ( !keepLogs )\n        {\n            if ( !file.delete() )\n            {\n                throw new IllegalStateException( \n                    \"Active marked as clean and unable to delete log \" + \n                    fileName );\n            }\n        }\n        else\n        {\n            System.out.println( \"close fix cleanKill () @ pos: \" + writeBuffer.getFileChannelPosition() + \" and endPos=\" + file.length() );\n            renameCurrentLogFileAndIncrementVersion( fileName, file.length() );\n        }\n    }","id":85142,"modified_method":"private void fixCleanKill( String fileName ) throws IOException\n    {\n        File file = new File( fileName );\n        if ( !keepLogs )\n        {\n            if ( !file.delete() )\n            {\n                throw new IllegalStateException( \n                    \"Active marked as clean and unable to delete log \" + \n                    fileName );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName, file.length() );\n        }\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start entry = logApplier.startEntry;\n        if ( entry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = entry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":85143,"modified_method":"public synchronized void applyTransactionWithoutTxId( ReadableByteChannel byteChannel, \n            long nextTxId ) throws IOException\n    {\n        if ( nextTxId != (xaTf.getLastCommittedTx() + 1) )\n        {\n            throw new IllegalStateException( \"Tried to apply tx \" + \n                nextTxId + \" but expected transaction \" + \n                (xaTf.getCurrentVersion() + 1) );\n        }\n        log.fine( \"Logical log version: \" + logVersion + \n            \", committing tx=\" + nextTxId + \")\" );\n//        System.out.println( \"applyTxWithoutTxId#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        LogEntry.Start entry = logApplier.startEntry;\n        if ( entry == null )\n        {\n            throw new IOException( \"Unable to find start entry\" );\n        }\n//        System.out.println( \"applyTxWithoutTxId#before 1PC @ pos: \" + writeBuffer.getFileChannelPosition() );\n        LogEntry.OnePhaseCommit commit = new LogEntry.OnePhaseCommit( \n                xidIdent, nextTxId );\n        LogIoUtils.writeLogEntry( commit, writeBuffer );\n        Xid xid = entry.getXid();\n        try\n        {\n            XaTransaction xaTx = xaRm.getXaTransaction( xid );\n            xaTx.setCommitTxId( nextTxId );\n            xaRm.commit( xid, true );\n        }\n        catch ( XAException e )\n        {\n            e.printStackTrace();\n            throw new IOException( e.getMessage() );\n        }\n//        LogEntry.Done done = new LogEntry.Done( entry.getIdentifier() );\n//        LogIoUtils.writeLogEntry( done, writeBuffer );\n        // xaTf.setLastCommittedTx( nextTxId ); // done in doCommit\n        log.info( \"Tx[\" + nextTxId + \"] \" + \" applied successfully.\" );\n//        System.out.println( \"applyTxWithoutTxId#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        buffer.clear();\n        buffer.limit( 1 );\n        while ( logEntryList == null && \n                log.read( buffer ) == buffer.limit() )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry;\n            switch ( entry )\n            {\n            case LogEntry.TX_START:\n                logEntry = LogIoUtils.readTxStartEntry( buffer, log, -1 );\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( logEntry );\n                transactions.put( logEntry.getIdentifier(), list );\n                break;\n            case LogEntry.TX_PREPARE:\n                logEntry = LogIoUtils.readTxPrepareEntry( buffer, log );\n                transactions.get( logEntry.getIdentifier() ).add( logEntry );\n                break;\n            case LogEntry.TX_1P_COMMIT:\n                logEntry = LogIoUtils.readTxOnePhaseCommit( buffer, log );\n                if ( ((LogEntry.OnePhaseCommit) logEntry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( logEntry.getIdentifier() );\n                    logEntryList.add( logEntry );\n                }\n                else\n                {\n                    transactions.remove( logEntry.getIdentifier() );\n                }\n                break;\n            case LogEntry.TX_2P_COMMIT:\n                logEntry = LogIoUtils.readTxTwoPhaseCommit( buffer, log );\n                if ( ((LogEntry.TwoPhaseCommit) logEntry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( logEntry.getIdentifier() );\n                    logEntryList.add( logEntry );\n                }\n                else\n                {\n                    transactions.remove( logEntry.getIdentifier() );\n                }\n                break;\n            case LogEntry.COMMAND:\n                logEntry = LogIoUtils.readTxCommand( buffer, log, cf );\n                transactions.get( logEntry.getIdentifier() ).add( logEntry );\n                break;\n            case LogEntry.DONE:\n                logEntry = LogIoUtils.readTxDoneEntry( buffer, log );\n                transactions.remove( logEntry.getIdentifier() );\n                break;\n            default:\n                throw new IOException( \"Unable to locate transaction[\"\n                    + txId + \"]\" );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","id":85144,"modified_method":"private List<LogEntry> extractTransactionFromLog( long txId, \n            long expectedVersion, ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        buffer.flip();\n        long versionInLog = buffer.getLong();\n        assertExpectedVersion( expectedVersion, versionInLog );\n        long prevTxId = buffer.getLong();\n        assertLogCanContainTx( txId, prevTxId );\n        List<LogEntry> logEntryList = null;\n        Map<Integer,List<LogEntry>> transactions = \n            new HashMap<Integer,List<LogEntry>>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null && \n                logEntryList == null )\n        {\n            if ( entry instanceof LogEntry.Start )\n            {\n                List<LogEntry> list = new LinkedList<LogEntry>();\n                list.add( entry );\n                transactions.put( entry.getIdentifier(), list );\n            }\n            else if ( entry instanceof LogEntry.Commit )\n            {\n                if ( ((LogEntry.Commit) entry).getTxId() == txId )\n                {\n                    logEntryList = transactions.get( entry.getIdentifier() );\n                    logEntryList.add( entry );\n                }\n                else\n                {\n                    transactions.remove( entry.getIdentifier() );\n                }\n            }\n            else if ( entry instanceof LogEntry.Command )\n            {\n                transactions.get( entry.getIdentifier() ).add( entry );\n            }\n            else if ( entry instanceof LogEntry.Done )\n            {\n                transactions.remove( entry.getIdentifier() );\n            }\n            else\n            {\n                throw new RuntimeException( \"Unknown entry: \" + entry );\n            }\n        }\n        if ( logEntryList == null )\n        {\n            throw new IOException( \"Transaction[\" + txId + \n                    \"] not found in log (\" + expectedVersion + \", \" + \n                    prevTxId + \")\" );\n        }\n        return logEntryList;\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"private boolean readEntry() throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 1 );\n        if ( fileChannel.read( buffer ) != buffer.limit() )\n        {\n            // ok no more entries we're done\n            return false;\n        }\n        buffer.flip();\n        byte entry = buffer.get();\n        switch ( entry )\n        {\n            case LogEntry.TX_START:\n                return readTxStartEntry();\n            case LogEntry.TX_PREPARE:\n                return readTxPrepareEntry();\n            case LogEntry.TX_1P_COMMIT:\n                return readTxOnePhaseCommit();\n            case LogEntry.TX_2P_COMMIT:\n                return readTxTwoPhaseCommit();\n            case LogEntry.COMMAND:\n                return readCommandEntry();\n            case LogEntry.DONE:\n                return readDoneEntry();\n            case LogEntry.EMPTY:\n                fileChannel.position( fileChannel.position() - 1 );\n                return false;\n            default:\n                throw new IOException( \"Internal recovery failed, \"\n                    + \"unknown log entry[\" + entry + \"]\" );\n        }\n    }","id":85145,"modified_method":"private LogEntry readEntry() throws IOException\n    {\n        long position = fileChannel.position();\n        LogEntry entry = LogIoUtils.readEntry( buffer, fileChannel, cf );\n        if ( entry instanceof LogEntry.Start )\n        {\n            ((LogEntry.Start) entry).setStartPosition( position );\n        }\n        return entry;\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.fine( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Close invoked with \" + xidIdentMap.size() + \n                \" running transaction(s). \" );\n            writeBuffer.force();\n            // writeBuffer = null;\n            fileChannel.close();\n            log.info( \"Dirty log: \" + fileName + \".\" + currentLog + \n                \" now closed. Recovery will be started automatically next \" + \n                \"time it is opened.\" );\n            return;\n        }\n        releaseCurrentLogFile();\n        char logWas = currentLog;\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( logWas == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + logWas );\n            }\n        }\n        else\n        {\n            System.out.println( \"close() @ pos: \" + writeBuffer.getFileChannelPosition() + \" and endPos=\" + endPosition );\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                logWas, endPosition );\n        }\n    }","id":85146,"modified_method":"public synchronized void close() throws IOException\n    {\n        if ( fileChannel == null || !fileChannel.isOpen() )\n        {\n            log.fine( \"Logical log: \" + fileName + \" already closed\" );\n            return;\n        }\n        long endPosition = writeBuffer.getFileChannelPosition();\n        if ( xidIdentMap.size() > 0 )\n        {\n            log.info( \"Close invoked with \" + xidIdentMap.size() + \n                \" running transaction(s). \" );\n            writeBuffer.force();\n            writeBuffer = null;\n            fileChannel.close();\n            log.info( \"Dirty log: \" + fileName + \".\" + currentLog + \n                \" now closed. Recovery will be started automatically next \" + \n                \"time it is opened.\" );\n            return;\n        }\n        releaseCurrentLogFile();\n        char logWas = currentLog;\n        if ( currentLog != CLEAN ) // again special case, see above\n        {\n            setActiveLog( CLEAN );\n        }\n        if ( !keepLogs || backupSlave )\n        {\n            if ( logWas == CLEAN )\n            {\n                // special case going from old xa version with no log rotation\n                // and we started with a recovery\n                deleteCurrentLogFile( fileName );\n            }\n            else\n            {\n                deleteCurrentLogFile( fileName + \".\" + logWas );\n            }\n        }\n        else\n        {\n            renameCurrentLogFileAndIncrementVersion( fileName + \".\" + \n                logWas, endPosition );\n        }\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        buffer.clear();\n        buffer.limit( 1 );\n        boolean done = false;\n        while ( !done && log.read( buffer ) == buffer.limit() )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            LogEntry logEntry;\n            switch ( entry )\n            {\n            case LogEntry.TX_START:\n                logEntry = LogIoUtils.readTxStartEntry( buffer, log, -1 );\n                if ( logEntry.getIdentifier() == identifier )\n                {\n                    logEntryList.add( logEntry );\n                }\n                break;\n            case LogEntry.TX_PREPARE:\n                logEntry = LogIoUtils.readTxPrepareEntry( buffer, log );\n                break;\n            case LogEntry.COMMAND:\n                logEntry = LogIoUtils.readTxCommand( buffer, log, cf );\n                if ( logEntry.getIdentifier() == identifier )\n                {\n                    logEntryList.add( logEntry );\n                }\n                break;\n            case LogEntry.TX_1P_COMMIT:\n                logEntry = LogIoUtils.readTxOnePhaseCommit( buffer, log );\n                break;\n            case LogEntry.TX_2P_COMMIT:\n                logEntry = LogIoUtils.readTxTwoPhaseCommit( buffer, log );\n                break;\n            case LogEntry.DONE:\n                logEntry = LogIoUtils.readTxDoneEntry( buffer, log );\n                break;\n            case LogEntry.EMPTY:\n                done = true;\n                break;\n            default:\n                throw new IOException( \"Unknown log entry \" + entry );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","id":85147,"modified_method":"private List<LogEntry> extractPreparedTransactionFromLog( long identifier, \n            ReadableByteChannel log ) throws IOException\n    {\n        buffer.clear();\n        buffer.limit( 16 );\n        log.read( buffer );\n        List<LogEntry> logEntryList = new ArrayList<LogEntry>();\n        LogEntry entry;\n        while ( (entry = LogIoUtils.readEntry( buffer, log, cf )) != null )\n        {\n            if ( entry.getIdentifier() != identifier )\n            {\n                continue;\n            }\n            if ( entry instanceof LogEntry.Start || entry instanceof LogEntry.Command )\n            {\n                logEntryList.add( entry );\n            }\n            else\n            {\n                throw new RuntimeException( \"Expected start or command entry but found: \" + entry );\n            }\n        }\n        if ( logEntryList.isEmpty() )\n        {\n            throw new IOException( \"Transaction for internal identifier[\" + identifier + \n                    \"] not found in current log\" );\n        }\n        return logEntryList;\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n        DumpLogicalLog.main( new String[] { logFileName } );\n        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n        System.out.println( \" ---- Created \" + newName + \" -----\" );\n        DumpLogicalLog.main( new String[] { newName } );\n        System.out.println( \" ----- end ----\" );\n    }","id":85148,"modified_method":"private void renameCurrentLogFileAndIncrementVersion( String logFileName, \n        long endPosition ) throws IOException\n    {\n//        System.out.println( \" ---- Performing clean close on \" + logFileName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { logFileName } );\n//        System.out.println( \" ----- end ----\" );\n        File file = new File( logFileName );\n        if ( !file.exists() )\n        {\n            throw new IOException( \"Logical log[\" + logFileName + \n                \"] not found\" );\n        }\n        String newName = fileName + \".v\" + xaTf.getAndSetNewVersion();\n        File newFile = new File( newName );\n        boolean renamed = FileUtils.renameFile( file, newFile );\n        \n        if ( !renamed )\n        {\n            throw new IOException( \"Failed to rename log to: \" + newName );\n        }\n        else\n        {\n            try\n            {\n                FileChannel channel = new RandomAccessFile( newName, \n                    \"rw\" ).getChannel();\n                FileUtils.truncateFile( channel, endPosition );\n            }\n            catch ( IOException e )\n            {\n                log.log( Level.WARNING, \n                    \"Failed to truncate log at correct size\", e );\n            }\n        }\n//        System.out.println( \" ---- Created \" + newName + \" -----\" );\n//        DumpLogicalLog.main( new String[] { newName } );\n//        System.out.println( \" ----- end ----\" );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"boolean readAndApplyEntry() throws IOException\n        {\n            buffer.clear();\n            buffer.limit( 1 );\n            if ( byteChannel.read( buffer ) != buffer.limit() )\n            {\n                // ok no more entries we're done\n                return false;\n            }\n            buffer.flip();\n            byte entry = buffer.get();\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    readTxStartEntry( -1 );\n                    return true;\n                case LogEntry.TX_PREPARE:\n                    readTxPrepareEntry( -1 );\n                    return true;\n                case LogEntry.TX_1P_COMMIT:\n                    readAndApplyTxOnePhaseCommit( -1 );\n                    return true;\n                case LogEntry.TX_2P_COMMIT:\n                    readAndApplyTxTwoPhaseCommit( -1 );\n                    return true;\n                case LogEntry.COMMAND:\n                    readCommandEntry( -1 );\n                    return true;\n                case LogEntry.DONE:\n                    readDoneEntry( -1 );\n                    return true;\n                case LogEntry.EMPTY:\n                    return false;\n                default:\n                    throw new IOException( \"Internal recovery failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n        }","id":85149,"modified_method":"boolean readAndApplyEntry() throws IOException\n        {\n            LogEntry entry = LogIoUtils.readEntry( buffer, byteChannel, cf );\n            if ( entry != null )\n            {\n                applyEntry( entry );\n            }\n            return entry != null;\n        }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void releaseCurrentLogFile() throws IOException\n    {\n        if ( writeBuffer != null )\n        {\n            writeBuffer.force();\n//            writeBuffer = null;\n        }\n        fileChannel.close();\n        fileChannel = null;\n    }","id":85150,"modified_method":"private void releaseCurrentLogFile() throws IOException\n    {\n        if ( writeBuffer != null )\n        {\n            writeBuffer.force();\n            writeBuffer = null;\n        }\n        fileChannel.close();\n        fileChannel = null;\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","id":85151,"modified_method":"public synchronized void applyTransaction( ReadableByteChannel byteChannel )\n        throws IOException\n    {\n//        System.out.println( \"applyFullTx#start @ pos: \" + writeBuffer.getFileChannelPosition() );\n        long logEntriesFound = 0;\n        LogApplier logApplier = new LogApplier( byteChannel );\n        int xidIdent = getNextIdentifier();\n        while ( logApplier.readAndApplyAndWriteEntry( xidIdent ) )\n        {\n            logEntriesFound++;\n        }\n        byteChannel.close();\n//        System.out.println( \"applyFullTx#end @ pos: \" + writeBuffer.getFileChannelPosition() );\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n        DumpLogicalLog.main( new String[] { currentLogFile } );\n        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        buffer.clear(); // ignore other 8 bytes\n        buffer.limit( 1 );\n        boolean emptyHit = false;\n        while ( fileChannel.read( buffer ) == 1 && !emptyHit )\n        {\n            buffer.flip();\n            byte entry = buffer.get();\n            switch ( entry )\n            {\n                case LogEntry.TX_START:\n                    readAndWriteTxStartEntry( newLog );\n                    break;\n                case LogEntry.TX_PREPARE:\n                    readAndWriteTxPrepareEntry( newLog );\n                    break;\n                case LogEntry.TX_1P_COMMIT:\n                    readAndWriteTxOnePhaseCommit( newLog );\n                    break;\n                case LogEntry.TX_2P_COMMIT:\n                    readAndWriteTxTwoPhaseCommit( newLog );\n                    break;\n                case LogEntry.COMMAND:\n                    readAndWriteCommandEntry( newLog );\n                    break;\n                case LogEntry.DONE:\n                    readAndVerifyDoneEntry();\n                    break;\n                case LogEntry.EMPTY:\n                    emptyHit = true;\n                    break;\n                default:\n                    throw new IOException( \"Log rotation failed, \"\n                        + \"unknown log entry[\" + entry + \"]\" );\n            }\n            buffer.clear();\n            buffer.limit( 1 );\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","id":85152,"modified_method":"public synchronized void rotate() throws IOException\n    {\n        xaTf.flushAll();\n        String newLogFile = fileName + \".2\";\n        String currentLogFile = fileName + \".1\";\n        char newActiveLog = LOG2;\n        long currentVersion = xaTf.getCurrentVersion();\n        String oldCopy = fileName + \".v\" + currentVersion;\n        if ( currentLog == CLEAN || currentLog == LOG2 )\n        {\n            newActiveLog = LOG1;\n            newLogFile = fileName + \".1\";\n            currentLogFile = fileName + \".2\";\n        }\n        else\n        {\n            assert currentLog == LOG1;\n        }\n        if ( new File( newLogFile ).exists() )\n        {\n            throw new IOException( \"New log file: \" + newLogFile + \n                \" already exist\" );\n        }\n        if ( new File( oldCopy ).exists() )\n        {\n            throw new IOException( \"Copy log file: \" + oldCopy + \n                \" already exist\" );\n        }\n//        System.out.println( \" ---- Performing rotate on \" + currentLogFile + \" -----\" );\n//        DumpLogicalLog.main( new String[] { currentLogFile } );\n//        System.out.println( \" ----- end ----\" );\n        long endPosition = writeBuffer.getFileChannelPosition();\n        writeBuffer.force();\n        FileChannel newLog = new RandomAccessFile( \n            newLogFile, \"rw\" ).getChannel();\n        buffer.clear();\n        buffer.putLong( currentVersion + 1 );\n        long lastTx = xaTf.getLastCommittedTx();\n        buffer.putLong( lastTx ).flip();\n        previousLogLastCommittedTx = lastTx;\n        if ( newLog.write( buffer ) != 16 )\n        {\n            throw new IOException( \"Unable to write log version to new\" );\n        }\n        fileChannel.position( 0 );\n        buffer.clear();\n        buffer.limit( 16 );\n        if( fileChannel.read( buffer ) != 16 )\n        {\n            throw new IOException( \"Verification of log version failed\" );\n        }\n        buffer.flip();\n        long verification = buffer.getLong();\n        if ( verification != currentVersion )\n        {\n            throw new IOException( \"Verification of log version failed, \" + \n                \" expected \" + currentVersion + \" got \" + verification );\n        }\n        if ( xidIdentMap.size() > 0 )\n        {\n            fileChannel.position( getFirstStartEntry( endPosition ) );\n        }\n        LogEntry entry;\n        while ((entry = LogIoUtils.readEntry( buffer, fileChannel, cf )) != null )\n        {\n            if ( xidIdentMap.get( entry.getIdentifier() ) != null )\n            {\n                if ( entry instanceof LogEntry.Start )\n                {\n                    ((LogEntry.Start) entry).setStartPosition( newLog.position() );\n                }\n                LogBuffer newLogBuffer = new DirectLogBuffer( newLog, buffer );\n                LogIoUtils.writeLogEntry( entry, newLogBuffer );\n            }\n        }\n        newLog.force( false );\n        releaseCurrentLogFile();\n        setActiveLog( newActiveLog );\n        if ( keepLogs )\n        {\n            renameCurrentLogFileAndIncrementVersion( currentLogFile, \n                endPosition );\n        }\n        else\n        {\n            deleteCurrentLogFile( currentLogFile );\n            xaTf.getAndSetNewVersion();\n        }\n        if ( xaTf.getCurrentVersion() != ( currentVersion + 1 ) )\n        {\n            throw new IOException( \"version change failed\" );\n        }\n        fileChannel = newLog;\n        if ( !useMemoryMapped )\n        {\n            writeBuffer = new DirectMappedLogBuffer( fileChannel );\n        }\n        else\n        {\n            writeBuffer = new MemoryMappedLogBuffer( fileChannel );\n        }\n    }","commit_id":"c79d8090ee128de157e38a43415995f3e5442d94","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void documentChanged(DocumentEvent e) {\n    Document document = e.getDocument();\n    if(myLexer instanceof JspHighlightLexer && myEditor != null && myEditor.getProject() != null){\n      final PsiDocumentManager instance = PsiDocumentManager.getInstance(myEditor.getProject());\n      final PsiFile psiFile = instance.getPsiFile(document);\n      if(psiFile instanceof JspFile) ((JspHighlightLexer)myLexer).setBaseFile((JspFile)psiFile);\n    }\n    if(mySegments.getSegmentCount() == 0) {\n      setText(document.getCharsSequence());\n      return;\n    }\n    CharSequence text = document.getCharsSequence();\n    int oldStartOffset = e.getOffset();\n\n    int startIndex = Math.max(0, mySegments.findSegmentIndex(oldStartOffset) - 2);\n\n    int data;\n    do {\n      data = mySegments.getSegmentData(startIndex);\n      if (isInitialState(data)|| startIndex == 0) break;\n      startIndex--;\n    }\n    while (true);\n\n    int startOffset = mySegments.getSegmentStart(startIndex);\n    int newEndOffset = e.getOffset() + e.getNewLength();\n\n    myLexer.start(CharArrayUtil.fromSequence(text), startOffset, text.length(), myInitialState);\n    SegmentArrayWithData insertSegments = new SegmentArrayWithData();\n    int oldEndIndex = -1;\n    int insertSegmentCount = 0;\n    int repaintEnd = -1;\n\n    int lastTokenStart = -1;\n    while(myLexer.getTokenType() != null) {\n      int tokenStart = myLexer.getTokenStart();\n      if (tokenStart == lastTokenStart) {\n        throw new IllegalStateException(\"Error while updating lexer: \" + e + \" document text: \" + e.getDocument().getText());\n      }\n\n      lastTokenStart = tokenStart;\n\n      int tokenEnd = myLexer.getTokenEnd();\n      int lexerState;\n      lexerState = myLexer.getState();\n      data = packData(myLexer.getTokenType(), lexerState);\n      if(tokenStart >= newEndOffset && lexerState == myInitialState) {\n        int shiftedTokenStart = tokenStart - e.getNewLength() + e.getOldLength();\n        int index = mySegments.findSegmentIndex(shiftedTokenStart);\n        if (mySegments.getSegmentStart(index) == shiftedTokenStart && mySegments.getSegmentData(index) == data) {\n          repaintEnd = tokenStart;\n          oldEndIndex = index;\n          break;\n        }\n      }\n      insertSegments.setElementAt(insertSegmentCount, tokenStart, tokenEnd, data);\n      insertSegmentCount++;\n      myLexer.advance();\n    }\n\n    if(repaintEnd == -1) {\n      repaintEnd = text.length();\n    }\n\n    if (oldEndIndex < 0){\n      oldEndIndex = mySegments.getSegmentCount();\n    }\n    mySegments.shiftSegments(oldEndIndex, e.getNewLength() - e.getOldLength());\n    mySegments.remove(startIndex, oldEndIndex);\n    mySegments.insert(insertSegments, startIndex);\n\n    int lastDocOffset = e.getDocument().getTextLength();\n    checkUpdateCorrect(lastDocOffset);\n\n    if (insertSegmentCount == 0 ||\n        oldEndIndex == startIndex + 1 && insertSegmentCount == 1 && data == mySegments.getSegmentData(startIndex)) {\n      return;\n    }\n\n    ((EditorEx) myEditor).repaint(startOffset, repaintEnd);\n  }","id":85153,"modified_method":"public synchronized void documentChanged(DocumentEvent e) {\n    Document document = e.getDocument();\n    if(myLexer instanceof JspHighlightLexer && myEditor != null && myEditor.getProject() != null){\n      final PsiDocumentManager instance = PsiDocumentManager.getInstance(myEditor.getProject());\n      final PsiFile psiFile = instance.getPsiFile(document);\n      if(psiFile instanceof JspFile) ((JspHighlightLexer)myLexer).setBaseFile((JspFile)psiFile);\n    }\n    if(mySegments.getSegmentCount() == 0) {\n      setText(document.getCharsSequence());\n      return;\n    }\n    CharSequence text = document.getCharsSequence();\n    int oldStartOffset = e.getOffset();\n\n    int startIndex = Math.max(0, mySegments.findSegmentIndex(oldStartOffset) - 2);\n\n    int data;\n    do {\n      data = mySegments.getSegmentData(startIndex);\n      if (isInitialState(data)|| startIndex == 0) break;\n      startIndex--;\n    }\n    while (true);\n\n    int startOffset = mySegments.getSegmentStart(startIndex);\n    int newEndOffset = e.getOffset() + e.getNewLength();\n\n    myLexer.start(CharArrayUtil.fromSequence(text), startOffset, text.length(), myInitialState);\n    SegmentArrayWithData insertSegments = new SegmentArrayWithData();\n    int oldEndIndex = -1;\n    int insertSegmentCount = 0;\n    int repaintEnd = -1;\n\n    int lastTokenStart = -1;\n\n    while (myLexer.getTokenType() != null) {\n      int tokenStart = myLexer.getTokenStart();\n      if (tokenStart == lastTokenStart) {\n        throw new IllegalStateException(\"Error while updating lexer: \" + e + \" document text: \" + e.getDocument().getText());\n      }\n\n      int tokenEnd = myLexer.getTokenEnd();\n      int lexerState = myLexer.getState();\n      data = packData(myLexer.getTokenType(), lexerState);\n      if (mySegments.getSegmentStart(startIndex) != tokenStart ||\n        mySegments.getSegmentEnd(startIndex) != tokenEnd ||\n        mySegments.getSegmentData(startIndex) != data) {\n        break;\n      }\n      startIndex++;\n      myLexer.advance();\n      lastTokenStart = tokenStart;\n    }\n\n    startOffset = mySegments.getSegmentStart(startIndex);\n\n    while(myLexer.getTokenType() != null) {\n      int tokenStart = myLexer.getTokenStart();\n      if (tokenStart == lastTokenStart) {\n        throw new IllegalStateException(\"Error while updating lexer: \" + e + \" document text: \" + e.getDocument().getText());\n      }\n\n      lastTokenStart = tokenStart;\n\n      int tokenEnd = myLexer.getTokenEnd();\n      int lexerState = myLexer.getState();\n      data = packData(myLexer.getTokenType(), lexerState);\n      if(tokenStart >= newEndOffset && lexerState == myInitialState) {\n        int shiftedTokenStart = tokenStart - e.getNewLength() + e.getOldLength();\n        int index = mySegments.findSegmentIndex(shiftedTokenStart);\n        if (mySegments.getSegmentStart(index) == shiftedTokenStart && mySegments.getSegmentData(index) == data) {\n          repaintEnd = tokenStart;\n          oldEndIndex = index;\n          break;\n        }\n      }\n      insertSegments.setElementAt(insertSegmentCount, tokenStart, tokenEnd, data);\n      insertSegmentCount++;\n      myLexer.advance();\n    }\n\n    if(repaintEnd == -1) {\n      repaintEnd = text.length();\n    }\n\n    if (oldEndIndex < 0){\n      oldEndIndex = mySegments.getSegmentCount();\n    }\n    mySegments.shiftSegments(oldEndIndex, e.getNewLength() - e.getOldLength());\n    mySegments.remove(startIndex, oldEndIndex);\n    mySegments.insert(insertSegments, startIndex);\n\n    int lastDocOffset = e.getDocument().getTextLength();\n    checkUpdateCorrect(lastDocOffset);\n\n    if (insertSegmentCount == 0 ||\n        oldEndIndex == startIndex + 1 && insertSegmentCount == 1 && data == mySegments.getSegmentData(startIndex)) {\n      return;\n    }\n\n    ((EditorEx) myEditor).repaint(startOffset, repaintEnd);\n  }","commit_id":"9a7f2744f887ba9d3fe6828a845f630573e483e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TreeElement addToken(CompositeElement decl, Lexer lexer) {\n    final TreeElement element = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n    TreeUtil.addChildren(decl, element);\n    lexer.advance();\n    return element;\n  }","id":85154,"modified_method":"private TreeElement addToken(CompositeElement decl, Lexer lexer) {\n    final TreeElement element = ParseUtil.createTokenElement(lexer, myContext.getCharTable());\n    if (element != null) {\n      TreeUtil.addChildren(decl, element);\n      lexer.advance();\n    }\n    return element;\n  }","commit_id":"c381184ab6f23ced235314e7403fbe1a9122a031","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LoadingOrder getOrder() {\n    String orderAttr = myExtensionElement.getAttributeValue(\"order\");\n    return LoadingOrder.readOrder(orderAttr);\n  }","id":85155,"modified_method":"public LoadingOrder getOrder() {\n    return LoadingOrder.readOrder(myExtensionElement.getAttributeValue(\"order\"));\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testLoadingOrderReading() {\n    assertEquals(LoadingOrder.ANY, createAdapter(\"<extension/>\").getOrder());\n    assertEquals(LoadingOrder.FIRST, createAdapter(\"<extension order=\\\"FIRST\\\"/>\").getOrder());\n    assertEquals(LoadingOrder.LAST, createAdapter(\"<extension order=\\\"LAST\\\"/>\").getOrder());\n    assertEquals(LoadingOrder.before(\"test\"), createAdapter(\"<extension order=\\\"BEFORE:test\\\"/>\").getOrder());\n    assertEquals(LoadingOrder.after(\"test\"), createAdapter(\"<extension order=\\\"AFTER:test\\\"/>\").getOrder());\n  }","id":85156,"modified_method":"public void testLoadingOrderReading() {\n    assertEquals(LoadingOrder.ANY, createAdapter(\"<extension/>\").getOrder());\n    assertEquals(LoadingOrder.FIRST, createAdapter(\"<extension order=\\\"FIRST\\\"/>\").getOrder());\n    assertEquals(LoadingOrder.LAST, createAdapter(\"<extension order=\\\"LAST\\\"/>\").getOrder());\n    assertEquals(LoadingOrder.before(\"test\"), createAdapter(\"<extension order=\\\"BEFORE test\\\"/>\").getOrder());\n    assertEquals(LoadingOrder.after(\"test\"), createAdapter(\"<extension order=\\\"AFTER test\\\"/>\").getOrder());\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testExtensionsWithOrderingUpdate() {\n    ExtensionsAreaImpl extensionsArea = new ExtensionsAreaImpl(new DefaultPicoContainer(), new Extensions.SimpleLogProvider());\n    extensionsArea.registerExtensionPoint(\"ep1\", TestExtensionClassOne.class.getName());\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"LAST\\\"><text>6<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"FIRST\\\"><text>1<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"id\\\"><text>3<\/text><\/extension>\"));\n    ExtensionPoint extensionPoint = extensionsArea.getExtensionPoint(\"ep1\");\n    TestExtensionClassOne[] extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(3, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"3\", extensions[1].getText());\n    assertEquals(\"6\", extensions[2].getText());\n    TestExtensionClassOne extension = new TestExtensionClassOne(\"xxx\");\n    extensionPoint.registerExtension(extension);\n    extensionPoint.unregisterExtension(extension);\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"BEFORE:id\\\"><text>2<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"AFTER:id\\\"><text>4<\/text><\/extension>\"));\n    extensionPoint.registerExtension(new TestExtensionClassOne(\"5\"));\n    extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(6, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"2\", extensions[1].getText());\n    assertEquals(\"3\", extensions[2].getText());\n    assertEquals(\"4\", extensions[3].getText());\n    assertEquals(\"5\", extensions[4].getText());\n    assertEquals(\"6\", extensions[5].getText());\n  }","id":85157,"modified_method":"public void testExtensionsWithOrderingUpdate() {\n    ExtensionsAreaImpl extensionsArea = new ExtensionsAreaImpl(new DefaultPicoContainer(), new Extensions.SimpleLogProvider());\n    extensionsArea.registerExtensionPoint(\"ep1\", TestExtensionClassOne.class.getName());\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"_7\\\" order=\\\"LAST\\\"><text>7<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"fst\\\" order=\\\"FIRST\\\"><text>1<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"id\\\"><text>4<\/text><\/extension>\"));\n    ExtensionPoint extensionPoint = extensionsArea.getExtensionPoint(\"ep1\");\n    TestExtensionClassOne[] extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(3, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"4\", extensions[1].getText());\n    assertEquals(\"7\", extensions[2].getText());\n    TestExtensionClassOne extension = new TestExtensionClassOne(\"xxx\");\n    extensionPoint.registerExtension(extension);\n    extensionPoint.unregisterExtension(extension);\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"BEFORE id\\\"><text>3<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"AFTER id\\\"><text>6<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"last, after _7\\\"><text>8<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"after id, before _7, after fst\\\"><text>5<\/text><\/extension>\"));\n    extensionPoint.registerExtension(new TestExtensionClassOne(\"2\"));\n    extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(8, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"2\", extensions[1].getText());\n    assertEquals(\"3\", extensions[2].getText());\n    assertEquals(\"4\", extensions[3].getText());\n    assertEquals(\"5\", extensions[4].getText());\n    assertEquals(\"6\", extensions[5].getText());\n    assertEquals(\"7\", extensions[6].getText());\n    assertEquals(\"8\", extensions[7].getText());\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static LoadingOrder readOrder(String orderAttr) {\n    if (orderAttr != null) {\n      if (\"FIRST\".equalsIgnoreCase(orderAttr)) return FIRST;\n      if (\"LAST\".equalsIgnoreCase(orderAttr)) return LAST;\n      if (\"ANY\".equalsIgnoreCase(orderAttr)) return ANY;\n      if (orderAttr.toUpperCase().startsWith(BEFORE_STR)) {\n        return before(orderAttr.substring(BEFORE_STR.length()));\n      }\n      if (orderAttr.toUpperCase().startsWith(AFTER_STR)) {\n        return after(orderAttr.substring(AFTER_STR.length()));\n      }\n    }\n    return ANY;\n  }","id":85158,"modified_method":"public static LoadingOrder readOrder(@NonNls String orderAttr) {\n    return orderAttr != null ? new LoadingOrder(orderAttr) : ANY;\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static LoadingOrder after(final String id) {\n    return new AfterLoadingOrder(id);\n  }","id":85159,"modified_method":"public static LoadingOrder after(@NonNls final String id) {\n    return new LoadingOrder(AFTER_STR + id);\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void sort(Orderable[] orderables) {\n    Orderable first = null;\n    Orderable last = null;\n    List other = new ArrayList();\n    for (int i = 0; i < orderables.length; i++) {\n      Orderable orderable = orderables[i];\n      if (orderable.getOrder() == FIRST) {\n        if (first != null) {\n          throw new SortingException(\"More than one 'first' element\", new Element[] {first.getDescribingElement(), orderable.getDescribingElement()});\n        }\n        first = orderable;\n      }\n      else if (orderable.getOrder() == LAST) {\n        if (last != null) {\n          throw new SortingException(\"More than one 'last' element\", new Element[] {last.getDescribingElement(), orderable.getDescribingElement()});\n        }\n        last = orderable;\n      }\n      else {\n        other.add(orderable);\n      }\n    }\n    List result = new ArrayList();\n    if (first != null) {\n      result.add(first);\n    }\n    result.addAll(other);\n    if (last != null) {\n      result.add(last);\n    }\n\n    assert result.size() == orderables.length;\n\n    Orderable[] presorted = (Orderable[]) result.toArray(new Orderable[result.size()]);\n\n    int swapCount = 0;\n    int maxSwaps = presorted.length * presorted.length;\n    for (int i = 0; i < presorted.length; i++) {\n      Orderable orderable = presorted[i];\n      LoadingOrder order = orderable.getOrder();\n      int place = order.findPlace(presorted, i);\n      if (place == DONT_CARE || place == ACCEPTABLE || place == SPECIAL) {\n        continue;\n      }\n      if (place == 0 && presorted[0].getOrder() == FIRST) {\n        throw new SortingException(\"Element attempts to go before the specified first\", new Element[] {orderable.getDescribingElement(), presorted[0].getDescribingElement()});\n      }\n      if (place == presorted.length - 1 && presorted[presorted.length - 1].getOrder() == LAST) {\n        throw new SortingException(\"Element attempts to go after the specified last\", new Element[] {orderable.getDescribingElement(), presorted[presorted.length - 1].getDescribingElement()});\n      }\n      moveTo(presorted, i, place);\n      if (i > place) {\n        i = place;\n      }\n      else {\n        i--;\n      }\n      swapCount++;\n      if (swapCount > maxSwaps) {\n        List allElements = new ArrayList();\n        for (int j = 0; j < presorted.length; j++) {\n          allElements.add(presorted[j].getDescribingElement());\n        }\n        throw new SortingException(\"Could not satisfy sorting requirements\", (Element[]) allElements.toArray(new Element[allElements.size()]));\n      }\n    }\n\n    System.arraycopy(presorted, 0, orderables, 0, presorted.length);\n  }","id":85160,"modified_method":"public static void sort(final Orderable[] orderables) {\n    final Map<String,Orderable> map = new HashMap<String, Orderable>();\n    for (final Orderable orderable : orderables) {\n      final String id = orderable.getOrderId();\n      if (StringUtil.isNotEmpty(id)) {\n        map.put(id, orderable);\n      }\n    }\n\n    DFSTBuilder<Orderable> builder = new DFSTBuilder<Orderable>(new GraphGenerator<Orderable>(new CachingSemiGraph<Orderable>(new GraphGenerator.SemiGraph<Orderable>() {\n      public Collection<Orderable> getNodes() {\n        return Arrays.asList(orderables);\n      }\n\n      public Iterator<Orderable> getIn(final Orderable n) {\n        final LoadingOrder order = n.getOrder();\n\n        Set<Orderable> predecessors = new LinkedHashSet<Orderable>();\n        for (final String id : order.myAfter) {\n          final Orderable orderable = map.get(id);\n          if (orderable != null) {\n            predecessors.add(orderable);\n          }\n        }\n\n        String id = n.getOrderId();\n        for (final Orderable orderable : orderables) {\n          final LoadingOrder hisOrder = orderable.getOrder();\n          if (StringUtil.isNotEmpty(id) && hisOrder.myBefore.contains(id) ||\n              order.myLast && !hisOrder.myLast ||\n              hisOrder.myFirst && !order.myFirst) {\n            predecessors.add(orderable);\n          }\n        }\n        return predecessors.iterator();\n      }\n    })));\n\n    if (!builder.isAcyclic()) {\n      final Pair<Orderable,Orderable> dependency = builder.getCircularDependency();\n      throw new SortingException(\"Could not satisfy sorting requirements\", new Element[]{dependency.first.getDescribingElement(), dependency.second.getDescribingElement()});\n    }\n\n    Arrays.sort(orderables, builder.comparator());\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static LoadingOrder before(final String id) {\n    return new BeforeLoadingOrder(id);\n  }","id":85161,"modified_method":"public static LoadingOrder before(@NonNls final String id) {\n    return new LoadingOrder(BEFORE_STR + id);\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private LoadingOrder(String name) {\n    myName = name;\n  }","id":85162,"modified_method":"private LoadingOrder(@NonNls @NotNull String text) {\n    myName = text;\n    final String[] strings = text.split(\",\");\n    for (final String string : strings) {\n      String trimmed = string.trim();\n      if (trimmed.equalsIgnoreCase(FIRST_STR)) myFirst = true;\n      else if (trimmed.equalsIgnoreCase(LAST_STR)) myLast = true;\n      else if (StringUtil.startsWithIgnoreCase(trimmed, BEFORE_STR)) myBefore.add(trimmed.substring(BEFORE_STR.length()));\n      else if (StringUtil.startsWithIgnoreCase(trimmed, AFTER_STR)) myAfter.add(trimmed.substring(AFTER_STR.length()));\n      else throw new AssertionError(\"Invalid specification: \" + trimmed + \"; should be one of FIRST, LAST, BEFORE <id> or AFTER <id>\");\n    }\n\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testComplexSorting2() {\n    ArrayList target = new ArrayList();\n    String idOne = \"idone\";\n    target.add(createElement(LoadingOrder.before(idOne), null, \"2\"));\n    target.add(createElement(LoadingOrder.after(idOne), null, \"4\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    target.add(createElement(LoadingOrder.ANY, idOne, \"3\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"5\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"6\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"123456\");\n  }","id":85163,"modified_method":"public void testComplexSorting2() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    @NonNls String idOne = \"idone\";\n    target.add(createElement(LoadingOrder.before(idOne), null, \"3\"));\n    target.add(createElement(LoadingOrder.after(idOne), null, \"5\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    target.add(createElement(LoadingOrder.ANY, idOne, \"4\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"2\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"6\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"123456\");\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFailingSortingAfterLast() {\n    ArrayList target = new ArrayList();\n    target.add(createElement(LoadingOrder.after(\"last\"), null, \"bad\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"good\"));\n    target.add(createElement(LoadingOrder.LAST, \"last\", \"bad\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"good\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array, 2);\n  }","id":85164,"modified_method":"public void testFailingSortingAfterLast() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    target.add(createElement(LoadingOrder.after(\"last\"), null, \"bad\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"good\"));\n    target.add(createElement(LoadingOrder.LAST, \"last\", \"bad\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"good\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array);\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFailingSortingBeforeFirst() {\n    ArrayList target = new ArrayList();\n    target.add(createElement(LoadingOrder.ANY, null, \"good\"));\n    target.add(createElement(LoadingOrder.FIRST, \"first\", \"bad\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"good\"));\n    target.add(createElement(LoadingOrder.before(\"first\"), null, \"bad\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array, 2);\n  }","id":85165,"modified_method":"public void testFailingSortingBeforeFirst() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    target.add(createElement(LoadingOrder.ANY, null, \"good\"));\n    target.add(createElement(LoadingOrder.FIRST, \"first\", \"bad\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"good\"));\n    target.add(createElement(LoadingOrder.before(\"first\"), null, \"bad\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array);\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFailingSortingFirst() {\n    ArrayList target = new ArrayList();\n    target.add(createElement(LoadingOrder.ANY, null, \"good\"));\n    target.add(createElement(LoadingOrder.FIRST, \"first\", \"bad\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"good\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"bad\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array, 2);\n  }","id":85166,"modified_method":"public void testFailingSortingFirst() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    target.add(createElement(LoadingOrder.ANY, null, \"2\"));\n    target.add(createElement(LoadingOrder.FIRST, \"first\", \"1\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"3\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"1123\");\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFailingSortingLast() {\n    ArrayList target = new ArrayList();\n    target.add(createElement(LoadingOrder.LAST, null, \"bad\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"good\"));\n    target.add(createElement(LoadingOrder.LAST, \"last\", \"bad\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"good\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array, 2);\n  }","id":85167,"modified_method":"public void testFailingSortingLast() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    target.add(createElement(LoadingOrder.LAST, null, \"3\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    target.add(createElement(LoadingOrder.LAST, \"last\", \"3\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"2\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"1233\");\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkSortingFailure(LoadingOrder.Orderable[] array, int expectedCount) {\n    try {\n      LoadingOrder.sort(array);\n      fail(\"Should have failed\");\n    }\n    catch (SortingException e) {\n      Element[] conflictingElements = e.getConflictingElements();\n      assertEquals(expectedCount, conflictingElements.length);\n      for (int i = 0; i < conflictingElements.length; i++) {\n        MyElement conflictingElement = (MyElement) conflictingElements[i];\n        assertEquals(\"bad\", conflictingElement.getID());\n      }\n    }\n  }","id":85168,"modified_method":"private static void checkSortingFailure(LoadingOrder.Orderable[] array) {\n    try {\n      LoadingOrder.sort(array);\n      fail(\"Should have failed\");\n    }\n    catch (SortingException e) {\n      Element[] conflictingElements = e.getConflictingElements();\n      assertEquals(2, conflictingElements.length);\n      assertEquals(\"bad\", ((MyElement)conflictingElements[0]).getID());\n      assertEquals(\"bad\", ((MyElement)conflictingElements[1]).getID());\n    }\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private StringBuffer buildSequence(LoadingOrder.Orderable[] array) {\n    StringBuffer sequence = new StringBuffer();\n    for (int i = 0; i < array.length; i++) {\n      LoadingOrder.Orderable adapter = array[i];\n      sequence.append(((MyElement)adapter.getDescribingElement()).getID());\n    }\n    return sequence;\n  }","id":85169,"modified_method":"private static StringBuffer buildSequence(LoadingOrder.Orderable[] array) {\n    StringBuffer sequence = new StringBuffer();\n    for (LoadingOrder.Orderable adapter : array) {\n      sequence.append(((MyElement)adapter.getDescribingElement()).getID());\n    }\n    return sequence;\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testComplexSorting() {\n    ArrayList target = new ArrayList();\n    String idOne = \"idone\";\n    String idTwo = \"idTwo\";\n    target.add(createElement(LoadingOrder.before(idTwo), idOne, \"2\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"0\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"5\"));\n    target.add(createElement(LoadingOrder.after(idTwo), null, \"4\"));\n    target.add(createElement(LoadingOrder.ANY, idTwo, \"3\"));\n    target.add(createElement(LoadingOrder.before(idOne), null, \"1\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"012345\");\n  }","id":85170,"modified_method":"public void testComplexSorting() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    @NonNls String idOne = \"idone\";\n    @NonNls String idTwo = \"idTwo\";\n    target.add(createElement(LoadingOrder.before(idTwo), idOne, \"2\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"0\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"5\"));\n    target.add(createElement(LoadingOrder.after(idTwo), null, \"4\"));\n    target.add(createElement(LoadingOrder.ANY, idTwo, \"3\"));\n    target.add(createElement(LoadingOrder.before(idOne), null, \"1\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"012345\");\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFailingSortingComplex() {\n    ArrayList target = new ArrayList();\n    target.add(createElement(LoadingOrder.after(\"2\"), \"1\", \"bad\"));\n    target.add(createElement(LoadingOrder.after(\"3\"), \"2\", \"bad\"));\n    target.add(createElement(LoadingOrder.after(\"1\"), \"3\", \"bad\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array, 3);\n  }","id":85171,"modified_method":"public void testFailingSortingComplex() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    target.add(createElement(LoadingOrder.after(\"2\"), \"1\", \"bad\"));\n    target.add(createElement(LoadingOrder.after(\"3\"), \"2\", \"bad\"));\n    target.add(createElement(LoadingOrder.after(\"1\"), \"3\", \"bad\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    checkSortingFailure(array);\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSimpleSorting() {\n    ArrayList target = new ArrayList();\n    target.add(createElement(LoadingOrder.ANY, null, \"any\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"2\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"any\"));\n    LoadingOrder.Orderable[] array = (LoadingOrder.Orderable[]) target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"1anyany2\");\n  }","id":85172,"modified_method":"public void testSimpleSorting() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    target.add(createElement(LoadingOrder.ANY, null, \"any\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"2\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"any\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"1anyany2\");\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String parseScope(final Lexer lexer) {\n    if (lexer.getTokenType() != ScopeTokenTypes.IDENTIFIER) return PatternPackageSet.SCOPE_ANY;\n    String id = getTokenText(lexer);\n    String scope = PatternPackageSet.SCOPE_ANY;\n    if (PatternPackageSet.SCOPE_SOURCE.equals(id)) {\n      scope = PatternPackageSet.SCOPE_SOURCE;\n    } else if (PatternPackageSet.SCOPE_TEST.equals(id)) {\n      scope = PatternPackageSet.SCOPE_TEST;\n    } else if (PatternPackageSet.SCOPE_PROBLEM.equals(id)) {\n      scope = PatternPackageSet.SCOPE_PROBLEM;\n    } else if (PatternPackageSet.SCOPE_LIBRARY.equals(id)) {\n      scope = PatternPackageSet.SCOPE_LIBRARY;\n    } else if (id.trim().length() > 0) {\n      scope = null;\n    }\n    final CharSequence buf = lexer.getBufferSequence();\n    int end = lexer.getTokenEnd();\n    int bufferEnd = lexer.getBufferEnd();\n\n    if (scope == PatternPackageSet.SCOPE_ANY || end >= bufferEnd || buf.charAt(end) != ':' && buf.charAt(end) != '[') {\n      return PatternPackageSet.SCOPE_ANY;\n    }\n\n    lexer.advance();\n\n    return scope;\n  }","id":85173,"modified_method":"public String parseScope(final Lexer lexer) {\n    if (lexer.getTokenType() != ScopeTokenTypes.IDENTIFIER) return PatternPackageSet.SCOPE_ANY;\n    String id = getTokenText(lexer);\n    String scope = PatternPackageSet.SCOPE_ANY;\n    if (PatternPackageSet.SCOPE_SOURCE.equals(id)) {\n      scope = PatternPackageSet.SCOPE_SOURCE;\n    } else if (PatternPackageSet.SCOPE_TEST.equals(id)) {\n      scope = PatternPackageSet.SCOPE_TEST;\n    } else if (PatternPackageSet.SCOPE_PROBLEM.equals(id)) {\n      scope = PatternPackageSet.SCOPE_PROBLEM;\n    } else if (PatternPackageSet.SCOPE_LIBRARY.equals(id)) {\n      scope = PatternPackageSet.SCOPE_LIBRARY;\n    } else if (id.trim().length() > 0) {\n      scope = null;\n    }\n    final CharSequence buf = lexer.getBufferSequence();\n    int end = lexer.getTokenEnd();\n    int bufferEnd = lexer.getBufferEnd();\n\n    if (scope == PatternPackageSet.SCOPE_ANY || end >= bufferEnd || buf.charAt(end) != ':' && buf.charAt(end) != '[') {\n      return PatternPackageSet.SCOPE_ANY;\n    }\n\n    if (scope != null) {\n      lexer.advance();\n    }\n\n    return scope;\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void invoke(final Project project, final Editor editor, PsiFile file, Surrounder surrounder){\n    if (!editor.getSelectionModel().hasSelection()) {\n      editor.getSelectionModel().selectLineAtCaret();\n    }\n    int startOffset = editor.getSelectionModel().getSelectionStart();\n    int endOffset = editor.getSelectionModel().getSelectionEnd();\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    PsiElement element1 = file.findElementAt(startOffset);\n    PsiElement element2 = file.findElementAt(endOffset - 1);\n\n    if (element1 == null || element2 == null) return;\n    Language lang1 = getLanguage(element1);\n    Language lang2 = getLanguage(element2);\n\n    if (element1 instanceof PsiWhiteSpace && isLanguageWithWSSignificant(lang1) ) {\n      startOffset = element1.getTextRange().getEndOffset();\n      element1 = file.findElementAt(startOffset);\n    }\n    if (element2 instanceof PsiWhiteSpace && isLanguageWithWSSignificant(lang2) ) {\n      endOffset = element2.getTextRange().getStartOffset();\n      element2 = file.findElementAt(endOffset);\n    }\n\n    lang1 = getLanguage(element1);\n    lang2 = getLanguage(element2);\n\n    if(lang1 != lang2) return;\n\n    final List<SurroundDescriptor> surroundDescriptors = LanguageSurrounders.INSTANCE.allForLanguage(element1.getLanguage());\n    if (surroundDescriptors.isEmpty()) return;\n\n    for (SurroundDescriptor descriptor : surroundDescriptors) {\n      final PsiElement[] elements = descriptor.getElementsToSurround(file, startOffset, endOffset);\n      if (elements.length > 0) {\n        if (surrounder == null) {\n          PopupActionChooser popupActionChooser = new PopupActionChooser(CHOOSER_TITLE);\n          popupActionChooser.invoke(project, editor, descriptor.getSurrounders(), elements);\n          return;\n        }\n        else {\n          doSurround(project, editor, surrounder, elements);\n        }\n      }\n    }\n  }","id":85174,"modified_method":"public static void invoke(final Project project, final Editor editor, PsiFile file, Surrounder surrounder){\n    if (!editor.getSelectionModel().hasSelection()) {\n      editor.getSelectionModel().selectLineAtCaret();\n    }\n    int startOffset = editor.getSelectionModel().getSelectionStart();\n    int endOffset = editor.getSelectionModel().getSelectionEnd();\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    PsiElement element1 = file.findElementAt(startOffset);\n    PsiElement element2 = file.findElementAt(endOffset - 1);\n\n    if (element1 == null || element2 == null) return;\n    Language lang1 = getLanguage(element1);\n    Language lang2 = getLanguage(element2);\n\n    if (element1 instanceof PsiWhiteSpace && isLanguageWithWSSignificant(lang1) ) {\n      startOffset = element1.getTextRange().getEndOffset();\n      element1 = file.findElementAt(startOffset);\n    }\n    if (element2 instanceof PsiWhiteSpace && isLanguageWithWSSignificant(lang2) ) {\n      endOffset = element2.getTextRange().getStartOffset();\n      element2 = file.findElementAt(endOffset);\n    }\n\n    lang1 = getLanguage(element1);\n    lang2 = getLanguage(element2);\n\n    if(lang1 != lang2) return;\n\n    final List<SurroundDescriptor> surroundDescriptors = LanguageSurrounders.INSTANCE.allForLanguage(element1.getLanguage());\n    if (surroundDescriptors.isEmpty()) return;\n\n    for (SurroundDescriptor descriptor : surroundDescriptors) {\n      final PsiElement[] elements = descriptor.getElementsToSurround(file, startOffset, endOffset);\n      if (elements.length > 0) {\n        if (surrounder == null) {\n          PopupActionChooser popupActionChooser = new PopupActionChooser(CHOOSER_TITLE);\n          popupActionChooser.invoke(project, editor, descriptor.getSurrounders(), elements);\n          return;\n        }\n        else {\n          invokeSurrondInTestMode(project, editor, surrounder, descriptor, elements);\n        }\n      }\n    }\n  }","commit_id":"132abc5562778dee1f50346b0693b96a32f581a8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"UnusedDeclaration\"})\n    public static ComponentUI createUI(JComponent c) {\n        return ui;\n    }","id":85175,"modified_method":"@SuppressWarnings({\"UnusedDeclaration\"})\n    public static ComponentUI createUI(JComponent c) {\n        return new ImageComponentUI(c);\n    }","commit_id":"6b57ebc53744a719cc6771a9172a578d50122883","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void paint(Graphics g, JComponent c) {\n        ImageComponent ic = (ImageComponent)c;\n        if (ic != null) {\n            ImageDocument document = ic.getDocument();\n            BufferedImage image = document.getValue();\n            if (image != null) {\n                paintBorder(g, ic);\n\n                Dimension size = ic.getCanvasSize();\n                Graphics igc = g.create(2, 2, size.width, size.height);\n\n                // Transparency chessboard\n                if (ic.isTransparencyChessboardVisible()) {\n                    paintChessboard(igc, ic);\n                }\n\n                paintImage(igc, ic);\n\n                // Grid\n                if (ic.isGridVisible()) {\n                    paintGrid(igc, ic);\n                }\n\n                igc.dispose();\n            }\n        }\n    }","id":85176,"modified_method":"@Override\n    public void paint(Graphics g, JComponent c) {\n        ImageComponent ic = (ImageComponent)c;\n        if (ic != null) {\n            ImageDocument document = ic.getDocument();\n            BufferedImage image = document.getValue();\n            if (image != null) {\n                paintBorder(g, ic);\n\n                Dimension size = ic.getCanvasSize();\n                Graphics igc = g.create(2, 2, size.width, size.height);\n\n                // Transparency chessboard\n                if (ic.isTransparencyChessboardVisible() && image.getTransparency() != Transparency.OPAQUE) {\n                    paintChessboard(igc, ic);\n                }\n\n                paintImage(igc, ic);\n\n                // Grid\n                if (ic.isGridVisible()) {\n                    paintGrid(igc, ic);\n                }\n\n                igc.dispose();\n            }\n        }\n    }","commit_id":"6b57ebc53744a719cc6771a9172a578d50122883","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintImage(Graphics g, ImageComponent ic) {\n        ImageDocument document = ic.getDocument();\n        Dimension size = ic.getCanvasSize();\n\n        Graphics2D g2d = (Graphics2D)g;\n        RenderingHints oldHints = g2d.getRenderingHints();\n  \n        // disable any kind of source image manipulation when resizing\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        g.drawImage(document.getRenderer(), 0, 0, size.width, size.height, ic);\n      \n        g2d.setRenderingHints(oldHints);\n    }","id":85177,"modified_method":"private static void paintImage(Graphics g, ImageComponent ic) {\n        ImageDocument document = ic.getDocument();\n        Dimension size = ic.getCanvasSize();\n\n        Graphics2D g2d = (Graphics2D)g;\n        RenderingHints oldHints = g2d.getRenderingHints();\n\n        BufferedImage image = ic.getDocument().getValue();\n        Image renderer = document.getValue();\n\n        if (size.width > image.getWidth() && size.height > image.getHeight()) {\n            // disable any kind of source image manipulation when resizing\n            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n        } else {\n            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n            g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);\n        }\n        g.drawImage(renderer, 0, 0, size.width, size.height, ic);\n\n        g2d.setRenderingHints(oldHints);\n    }","commit_id":"6b57ebc53744a719cc6771a9172a578d50122883","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintChessboard(Graphics g, ImageComponent ic) {\n        Dimension size = ic.getCanvasSize();\n        // Create pattern\n        int cellSize = ic.getTransparencyChessboardCellSize();\n        int patternSize = 2 * cellSize;\n        BufferedImage pattern = UIUtil.createImage(patternSize, patternSize, BufferedImage.TYPE_INT_ARGB);\n        Graphics imageGraphics = pattern.getGraphics();\n        imageGraphics.setColor(ic.getTransparencyChessboardWhiteColor());\n        imageGraphics.fillRect(0, 0, patternSize, patternSize);\n        imageGraphics.setColor(ic.getTransparencyChessboardBlackColor());\n        imageGraphics.fillRect(0, cellSize, cellSize, cellSize);\n        imageGraphics.fillRect(cellSize, 0, cellSize, cellSize);\n\n        ((Graphics2D)g).setPaint(new TexturePaint(pattern, new Rectangle(0, 0, patternSize, patternSize)));\n        g.fillRect(0, 0, size.width, size.height);\n    }","id":85178,"modified_method":"private void paintChessboard(Graphics g, ImageComponent ic) {\n        Dimension size = ic.getCanvasSize();\n        // Create pattern\n        int cellSize = ic.getTransparencyChessboardCellSize();\n        int patternSize = 2 * cellSize;\n\n        if (pattern == null) {\n            pattern = UIUtil.createImage(patternSize, patternSize, BufferedImage.TYPE_INT_ARGB);\n            Graphics imageGraphics = pattern.getGraphics();\n            imageGraphics.setColor(ic.getTransparencyChessboardWhiteColor());\n            imageGraphics.fillRect(0, 0, patternSize, patternSize);\n            imageGraphics.setColor(ic.getTransparencyChessboardBlackColor());\n            imageGraphics.fillRect(0, cellSize, cellSize, cellSize);\n            imageGraphics.fillRect(cellSize, 0, cellSize, cellSize);\n        }\n\n        ((Graphics2D)g).setPaint(new TexturePaint(pattern, new Rectangle(0, 0, patternSize, patternSize)));\n        g.fillRect(0, 0, size.width, size.height);\n    }","commit_id":"6b57ebc53744a719cc6771a9172a578d50122883","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Returns the container specific resolution policy.\n     * @param zookeeper\n     * @return\n     * @throws InterruptedException\n     * @throws KeeperException\n     */\n     private static String getContainerResolutionPolicy(IZKClient zookeeper, String container) throws InterruptedException, KeeperException {\n         String policy = ZkDefs.LOCAL_HOSTNAME;\n         List<String> validResoverList = Arrays.asList(ZkDefs.VALID_RESOLVERS);\n         if (zookeeper.exists(ZkPath.POLICIES.getPath(ZkDefs.RESOLVER)) != null) {\n             policy = zookeeper.getStringData(ZkPath.CONTAINER_RESOLVER.getPath(container));\n         } else if (System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY) != null && validResoverList.contains(System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY))) {\n             policy = System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY);\n         }\n         if (policy == null || !validResoverList.contains(policy)) {\n             policy = getGlobalResolutionPolicy(zookeeper);\n         }\n         zookeeper.createOrSetWithParents(ZkPath.CONTAINER_RESOLVER.getPath(container), policy, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n         return policy;\n     }","id":85179,"modified_method":"/**\n     * Returns the container specific resolution policy.\n     * @param zookeeper\n     * @return\n     * @throws InterruptedException\n     * @throws KeeperException\n     */\n     private static String getContainerResolutionPolicy(IZKClient zookeeper, String container) throws InterruptedException, KeeperException {\n         String policy = ZkDefs.LOCAL_HOSTNAME;\n         List<String> validResoverList = Arrays.asList(ZkDefs.VALID_RESOLVERS);\n         if (zookeeper.exists(ZkPath.POLICIES.getPath(ZkDefs.RESOLVER)) != null) {\n             policy = zookeeper.getStringData(ZkPath.CONTAINER_RESOLVER.getPath(container));\n         } else if (System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY) != null && validResoverList.contains(System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY))) {\n             policy = System.getProperty(ZkDefs.LOCAL_RESOLVER_PROPERTY);\n         }\n         if (policy == null || !validResoverList.contains(policy)) {\n             policy = getGlobalResolutionPolicy(zookeeper);\n         }\n         if (policy != null && zookeeper.exists(ZkPath.CONTAINER_RESOLVER.getPath(container)) == null) {\n             zookeeper.createOrSetWithParents(ZkPath.CONTAINER_RESOLVER.getPath(container), policy, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n         }\n         return policy;\n     }","commit_id":"839abb1b0327e42ccb71dc4ca727b489c0c022bf","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void onConnected() {\n        try {\n            connected = true;\n            String name = System.getProperty(\"karaf.name\");\n            String nodeAlive = AGENT_ALIVE.getPath(name);\n            Stat stat = zooKeeper.exists(nodeAlive);\n            if (stat != null) {\n                if (stat.getEphemeralOwner() != zooKeeper.getSessionId()) {\n                    zooKeeper.delete(nodeAlive);\n                    zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n                }\n            } else {\n                zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            }\n\n            String domainsNode = AGENT_DOMAINS.getPath(name);\n            stat = zooKeeper.exists(domainsNode);\n            if (stat != null) {\n                zooKeeper.deleteWithChildren(domainsNode);\n            }\n\n            String jmxUrl = getJmxUrl();\n            if (jmxUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_JMX.getPath(name), getJmxUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            String sshUrl = getSshUrl();\n            if (sshUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_SSH.getPath(name), getSshUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            zooKeeper.createOrSetWithParents(AGENT_IP.getPath(name), getLocalHostAddress(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            zooKeeper.createOrSetWithParents(AGENT_ROOT.getPath(name), getRootName(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            String version = System.getProperty(\"fabric.version\", \"base\");\n            String profiles = System.getProperty(\"fabric.profiles\", \"default\");\n\n            String versionNode = CONFIG_AGENT.getPath(name);\n            String profileNode = CONFIG_VERSIONS_AGENT.getPath(version, name);\n\n            zooKeeper.createOrSetWithParents(versionNode, version, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            zooKeeper.createOrSetWithParents(profileNode, profiles, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            registerDomains();\n        } catch (Exception e) {\n            // TODO\n            e.printStackTrace();\n        }\n    }","id":85180,"modified_method":"public void onConnected() {\n        try {\n            connected = true;\n            String name = System.getProperty(\"karaf.name\");\n            String nodeAlive = AGENT_ALIVE.getPath(name);\n            Stat stat = zooKeeper.exists(nodeAlive);\n            if (stat != null) {\n                if (stat.getEphemeralOwner() != zooKeeper.getSessionId()) {\n                    zooKeeper.delete(nodeAlive);\n                    zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n                }\n            } else {\n                zooKeeper.createWithParents(nodeAlive, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            }\n\n            String domainsNode = AGENT_DOMAINS.getPath(name);\n            stat = zooKeeper.exists(domainsNode);\n            if (stat != null) {\n                zooKeeper.deleteWithChildren(domainsNode);\n            }\n\n            String jmxUrl = getJmxUrl();\n            if (jmxUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_JMX.getPath(name), getJmxUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            String sshUrl = getSshUrl();\n            if (sshUrl != null) {\n                zooKeeper.createOrSetWithParents(AGENT_SSH.getPath(name), getSshUrl(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            zooKeeper.createOrSetWithParents(AGENT_IP.getPath(name), getLocalHostAddress(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            zooKeeper.createOrSetWithParents(AGENT_ROOT.getPath(name), getRootName(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            String version = System.getProperty(\"fabric.version\", \"base\");\n            String profiles = System.getProperty(\"fabric.profiles\", \"default\");\n\n            String versionNode = CONFIG_AGENT.getPath(name);\n            String profileNode = CONFIG_VERSIONS_AGENT.getPath(version, name);\n\n            if (zooKeeper.exists(versionNode) == null) {\n                zooKeeper.createOrSetWithParents(versionNode, version, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n            if (zooKeeper.exists(profileNode) == null) {\n                zooKeeper.createOrSetWithParents(profileNode, profiles, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n\n            registerDomains();\n        } catch (Exception e) {\n            // TODO\n            e.printStackTrace();\n        }\n    }","commit_id":"12bb2efacf18fae906edbb43b17cb4fbf7271d87","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        if (ignore.exists() && ignore.isFile()) {\n            nregex = merge(ignore, nregex);\n        }\n        if (include.exists() && include.isFile()) {\n            regex = merge(include, regex);\n        }\n        if (properties == true) {\n            filesystem = false;\n        }\n        if (filesystem == true) {\n            properties = false;\n        }\n        if (properties) {\n            readPropertiesFile();\n        }\n        if (filesystem) {\n            readFileSystem();\n        }\n        System.out.println(\"Successfully imported settings from \" + source);\n        return null;\n    }","id":85181,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        if (ignore.exists() && ignore.isFile()) {\n            nregex = merge(ignore, nregex);\n        }\n        if (include.exists() && include.isFile()) {\n            regex = merge(include, regex);\n        }\n        if (properties == true) {\n            filesystem = false;\n        }\n        if (filesystem == true) {\n            properties = false;\n        }\n        checkZooKeeperConnected();\n        if (properties) {\n            readPropertiesFile();\n        }\n        if (filesystem) {\n            readFileSystem();\n        }\n        System.out.println(\"Successfully imported settings from \" + source);\n        return null;\n    }","commit_id":"53b043280ec33606cc4d5928a802bd1467e5fa49","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private void readFileSystem() throws Exception {\n        Map<String, String> settings = new TreeMap<String, String>();\n        File s = new File(source);\n        getCandidates(s, s, settings);\n        List<Pattern> include = getPatterns(regex);\n        List<Pattern> exclude = getPatterns(nregex);\n\n        if (!target.endsWith(\"/\")) {\n            target = target + \"/\";\n        }\n        if (!target.startsWith(\"/\")) {\n            target = \"/\" + target;\n        }\n\n        List<String> paths = new ArrayList<String>();\n\n        for(String key : settings.keySet()) {\n            String data = settings.get(key);\n            key = target + key;\n            paths.add(key);\n            if (!matches(include, key, true) || matches(exclude, key, false)) {\n                continue;\n            }\n            if (!dryRun) {\n                getZooKeeper().createOrSetWithParents(key, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            } else {\n                System.out.printf(\"Creating path \\\"%s\\\" with value \\\"%s\\\"\\n\", key, data);\n            }\n        }\n\n        if (delete) {\n            deletePathsNotIn(paths);\n        }\n    }","id":85182,"modified_method":"private void readFileSystem() throws Exception {\n        Map<String, String> settings = new TreeMap<String, String>();\n        File s = new File(source);\n        getCandidates(s, s, settings);\n        List<Pattern> include = getPatterns(regex);\n        List<Pattern> exclude = getPatterns(nregex);\n\n        if (!target.endsWith(\"/\")) {\n            target = target + \"/\";\n        }\n        if (!target.startsWith(\"/\")) {\n            target = \"/\" + target;\n        }\n\n        List<String> paths = new ArrayList<String>();\n\n        for(String key : settings.keySet()) {\n            String data = settings.get(key);\n            key = target + key;\n            paths.add(key);\n            if (!matches(include, key, true) || matches(exclude, key, false)) {\n                continue;\n            }\n            if (!dryRun) {\n                if (data != null) {\n                    if (verbose) {\n                        System.out.println(\"importing: \" + key);\n                    }\n                    getZooKeeper().createOrSetWithParents(key, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n            } else {\n                System.out.printf(\"Creating path \\\"%s\\\" with value \\\"%s\\\"\\n\", key, data);\n            }\n        }\n\n        if (delete) {\n            deletePathsNotIn(paths);\n        }\n    }","commit_id":"53b043280ec33606cc4d5928a802bd1467e5fa49","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void setValue(EvaluationContext ctx, Object value)\n            throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                expr.setValue(ctx.getELContext(), value);\n                return;\n            }\n        }\n        ctx.setPropertyResolved(false);\n        ctx.getELResolver().setValue(ctx, null, this.image, value);\n    }","id":85183,"modified_method":"@Override\n    public void setValue(EvaluationContext ctx, Object value)\n            throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                expr.setValue(ctx.getELContext(), value);\n                return;\n            }\n        }\n        ctx.setPropertyResolved(false);\n        ctx.getELResolver().setValue(ctx, null, this.image, value);\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled.null\", this.image));\n        }\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Class<?> getType(EvaluationContext ctx) throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                return expr.getType(ctx.getELContext());\n            }\n        }\n        ctx.setPropertyResolved(false);\n        return ctx.getELResolver().getType(ctx, null, this.image);\n    }","id":85184,"modified_method":"@Override\n    public Class<?> getType(EvaluationContext ctx) throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                return expr.getType(ctx.getELContext());\n            }\n        }\n        ctx.setPropertyResolved(false);\n        Class<?> result = ctx.getELResolver().getType(ctx, null, this.image);\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled.null\", this.image));\n        }\n        return result;\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object getValue(EvaluationContext ctx) throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                return expr.getValue(ctx.getELContext());\n            }\n        }\n        ctx.setPropertyResolved(false);\n        return ctx.getELResolver().getValue(ctx, null, this.image);\n    }","id":85185,"modified_method":"@Override\n    public Object getValue(EvaluationContext ctx) throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                return expr.getValue(ctx.getELContext());\n            }\n        }\n        ctx.setPropertyResolved(false);\n        Object result = ctx.getELResolver().getValue(ctx, null, this.image);\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled.null\", this.image));\n        }\n        return result;\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean isReadOnly(EvaluationContext ctx) throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                return expr.isReadOnly(ctx.getELContext());\n            }\n        }\n        ctx.setPropertyResolved(false);\n        return ctx.getELResolver().isReadOnly(ctx, null, this.image);\n    }","id":85186,"modified_method":"@Override\n    public boolean isReadOnly(EvaluationContext ctx) throws ELException {\n        VariableMapper varMapper = ctx.getVariableMapper();\n        if (varMapper != null) {\n            ValueExpression expr = varMapper.resolveVariable(this.image);\n            if (expr != null) {\n                return expr.isReadOnly(ctx.getELContext());\n            }\n        }\n        ctx.setPropertyResolved(false);\n        boolean result = ctx.getELResolver().isReadOnly(ctx, null, this.image);\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled.null\", this.image));\n        }\n        return result;\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object getValue(EvaluationContext ctx) throws ELException {\n        Object base = this.children[0].getValue(ctx);\n        int propCount = this.jjtGetNumChildren();\n        int i = 1;\n        Object suffix = null;\n        ELResolver resolver = ctx.getELResolver();\n        while (base != null && i < propCount) {\n            suffix = this.children[i].getValue(ctx);\n            if (i + 1 < propCount &&\n                    (this.children[i+1] instanceof AstMethodParameters)) {\n                AstMethodParameters mps =\n                    (AstMethodParameters) this.children[i+1];\n                // This is a method\n                base = resolver.invoke(ctx, base, suffix,\n                        mps.getParameterTypes(ctx), mps.getParameters(ctx));\n                i+=2;\n            } else {\n                // This is a property\n                if (suffix == null) {\n                    return null;\n                } else {\n                    ctx.setPropertyResolved(false);\n                    base = resolver.getValue(ctx, base, suffix);\n                }\n                i++;\n            }\n        }\n        return base;\n    }","id":85187,"modified_method":"@Override\n    public Object getValue(EvaluationContext ctx) throws ELException {\n        Object base = this.children[0].getValue(ctx);\n        int propCount = this.jjtGetNumChildren();\n        int i = 1;\n        Object suffix = null;\n        ELResolver resolver = ctx.getELResolver();\n        while (base != null && i < propCount) {\n            suffix = this.children[i].getValue(ctx);\n            if (i + 1 < propCount &&\n                    (this.children[i+1] instanceof AstMethodParameters)) {\n                AstMethodParameters mps =\n                    (AstMethodParameters) this.children[i+1];\n                // This is a method\n                base = resolver.invoke(ctx, base, suffix,\n                        mps.getParameterTypes(ctx), mps.getParameters(ctx));\n                i+=2;\n            } else {\n                // This is a property\n                if (suffix == null) {\n                    return null;\n                } else {\n                    ctx.setPropertyResolved(false);\n                    base = resolver.getValue(ctx, base, suffix);\n                }\n                i++;\n            }\n        }\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled\", base, suffix));            \n        }\n        return base;\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean isReadOnly(EvaluationContext ctx) throws ELException {\n        Target t = getTarget(ctx);\n        ctx.setPropertyResolved(false);\n        return ctx.getELResolver().isReadOnly(ctx, t.base, t.property);\n    }","id":85188,"modified_method":"@Override\n    public boolean isReadOnly(EvaluationContext ctx) throws ELException {\n        Target t = getTarget(ctx);\n        ctx.setPropertyResolved(false);\n        boolean result =\n            ctx.getELResolver().isReadOnly(ctx, t.base, t.property);\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled\", t.base, t.property));            \n        }\n        return result;\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Class<?> getType(EvaluationContext ctx) throws ELException {\n        Target t = getTarget(ctx);\n        ctx.setPropertyResolved(false);\n        return ctx.getELResolver().getType(ctx, t.base, t.property);\n    }","id":85189,"modified_method":"@Override\n    public Class<?> getType(EvaluationContext ctx) throws ELException {\n        Target t = getTarget(ctx);\n        ctx.setPropertyResolved(false);\n        Class<?> result = ctx.getELResolver().getType(ctx, t.base, t.property);\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled\", t.base, t.property));            \n        }\n        return result;\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void setValue(EvaluationContext ctx, Object value)\n            throws ELException {\n        Target t = getTarget(ctx);\n        ctx.setPropertyResolved(false);\n        ELResolver resolver = ctx.getELResolver();\n\n        // coerce to the expected type\n        Class<?> targetClass = resolver.getType(ctx, t.base, t.property);\n        if (COERCE_TO_ZERO == true\n                || !isAssignable(value, targetClass)) {\n            resolver.setValue(ctx, t.base, t.property,\n                    ELSupport.coerceToType(value, targetClass));\n        } else {\n            resolver.setValue(ctx, t.base, t.property, value);\n        }\n    }","id":85190,"modified_method":"@Override\n    public void setValue(EvaluationContext ctx, Object value)\n            throws ELException {\n        Target t = getTarget(ctx);\n        ctx.setPropertyResolved(false);\n        ELResolver resolver = ctx.getELResolver();\n\n        // coerce to the expected type\n        Class<?> targetClass = resolver.getType(ctx, t.base, t.property);\n        if (COERCE_TO_ZERO == true\n                || !isAssignable(value, targetClass)) {\n            resolver.setValue(ctx, t.base, t.property,\n                    ELSupport.coerceToType(value, targetClass));\n        } else {\n            resolver.setValue(ctx, t.base, t.property, value);\n        }\n        if (!ctx.isPropertyResolved()) {\n            throw new PropertyNotFoundException(MessageFactory.get(\n                    \"error.resolver.unhandled\", t.base, t.property));            \n        }\n    }","commit_id":"aab12bb98b328e660f7ac570e49622a33f4fe476","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public MethodInfo getMethodInfo(ELContext context)\n            throws NullPointerException, PropertyNotFoundException,\n            MethodNotFoundException, ELException {\n        try {\n            return this.target.getMethodInfo(context);\n        } catch (MethodNotFoundException e) {\n            if (e instanceof JspMethodNotFoundException) throw e;\n            throw new JspMethodNotFoundException(this.mark, e);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","id":85191,"modified_method":"@Override\n    public MethodInfo getMethodInfo(ELContext context)\n            throws NullPointerException, PropertyNotFoundException,\n            MethodNotFoundException, ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        try {\n            MethodInfo result = this.target.getMethodInfo(context);\n            context.notifyAfterEvaluation(getExpressionString());\n            return result;\n        } catch (MethodNotFoundException e) {\n            if (e instanceof JspMethodNotFoundException) throw e;\n            throw new JspMethodNotFoundException(this.mark, e);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object invoke(ELContext context, Object[] params)\n            throws NullPointerException, PropertyNotFoundException,\n            MethodNotFoundException, ELException {\n        try {\n            return this.target.invoke(context, params);\n        } catch (MethodNotFoundException e) {\n            if (e instanceof JspMethodNotFoundException) throw e;\n            throw new JspMethodNotFoundException(this.mark, e);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","id":85192,"modified_method":"@Override\n    public Object invoke(ELContext context, Object[] params)\n            throws NullPointerException, PropertyNotFoundException,\n            MethodNotFoundException, ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        try {\n            Object result = this.target.invoke(context, params);\n            context.notifyAfterEvaluation(getExpressionString());\n            return result;\n        } catch (MethodNotFoundException e) {\n            if (e instanceof JspMethodNotFoundException) throw e;\n            throw new JspMethodNotFoundException(this.mark, e);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object getValue(ELContext context) throws NullPointerException,\n            PropertyNotFoundException, ELException {\n        try {\n            return this.target.getValue(context);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","id":85193,"modified_method":"@Override\n    public Object getValue(ELContext context) throws NullPointerException,\n            PropertyNotFoundException, ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        try {\n            Object result = this.target.getValue(context);\n            context.notifyAfterEvaluation(getExpressionString());\n            return result;\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Class<?> getType(ELContext context) throws NullPointerException,\n            PropertyNotFoundException, ELException {\n        try {\n            return this.target.getType(context);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","id":85194,"modified_method":"@Override\n    public Class<?> getType(ELContext context) throws NullPointerException,\n            PropertyNotFoundException, ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        try {\n            Class<?> result = this.target.getType(context);\n            context.notifyAfterEvaluation(getExpressionString());\n            return result;\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void setValue(ELContext context, Object value)\n            throws NullPointerException, PropertyNotFoundException,\n            PropertyNotWritableException, ELException {\n        try {\n            this.target.setValue(context, value);\n        } catch (PropertyNotWritableException e) {\n            if (e instanceof JspPropertyNotWritableException) throw e;\n            throw new JspPropertyNotWritableException(this.mark, e);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","id":85195,"modified_method":"@Override\n    public void setValue(ELContext context, Object value)\n            throws NullPointerException, PropertyNotFoundException,\n            PropertyNotWritableException, ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        try {\n            this.target.setValue(context, value);\n            context.notifyAfterEvaluation(getExpressionString());\n        } catch (PropertyNotWritableException e) {\n            if (e instanceof JspPropertyNotWritableException) throw e;\n            throw new JspPropertyNotWritableException(this.mark, e);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean isReadOnly(ELContext context) throws NullPointerException,\n            PropertyNotFoundException, ELException {\n        try {\n            return this.target.isReadOnly(context);\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","id":85196,"modified_method":"@Override\n    public boolean isReadOnly(ELContext context) throws NullPointerException,\n            PropertyNotFoundException, ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        try {\n            boolean result = this.target.isReadOnly(context);\n            context.notifyAfterEvaluation(getExpressionString());\n            return result;\n        } catch (PropertyNotFoundException e) {\n            if (e instanceof JspPropertyNotFoundException) throw e;\n            throw new JspPropertyNotFoundException(this.mark, e);\n        } catch (ELException e) {\n            if (e instanceof JspELException) throw e;\n            throw new JspELException(this.mark, e);\n        }\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Evaluates the expression relative to the provided context, invokes the\n     * method that was found using the supplied parameters, and returns the\n     * result of the method invocation.\n     *\n     * @param context\n     *            The context of this evaluation.\n     * @param params\n     *            The parameters to pass to the method, or <code>null<\/code>\n     *            if no parameters.\n     * @return the result of the method invocation (<code>null<\/code> if the\n     *         method has a <code>void<\/code> return type).\n     * @throws NullPointerException\n     *             if context is <code>null<\/code> or the base object is\n     *             <code>null<\/code> on the last resolution.\n     * @throws PropertyNotFoundException\n     *             if one of the property resolutions failed because a specified\n     *             variable or property does not exist or is not readable.\n     * @throws MethodNotFoundException\n     *             if no suitable method can be found.\n     * @throws ELException\n     *             if an exception was thrown while performing property or\n     *             variable resolution. The thrown exception must be included as\n     *             the cause property of this exception, if available. If the\n     *             exception thrown is an <code>InvocationTargetException<\/code>,\n     *             extract its <code>cause<\/code> and pass it to the\n     *             <code>ELException<\/code> constructor.\n     * @see javax.el.MethodExpression#invoke(javax.el.ELContext,\n     *      java.lang.Object[])\n     */\n    @Override\n    public Object invoke(ELContext context, Object[] params)\n            throws PropertyNotFoundException, MethodNotFoundException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        return this.getNode().invoke(ctx, this.paramTypes, params);\n    }","id":85197,"modified_method":"/**\n     * Evaluates the expression relative to the provided context, invokes the\n     * method that was found using the supplied parameters, and returns the\n     * result of the method invocation.\n     *\n     * @param context\n     *            The context of this evaluation.\n     * @param params\n     *            The parameters to pass to the method, or <code>null<\/code>\n     *            if no parameters.\n     * @return the result of the method invocation (<code>null<\/code> if the\n     *         method has a <code>void<\/code> return type).\n     * @throws NullPointerException\n     *             if context is <code>null<\/code> or the base object is\n     *             <code>null<\/code> on the last resolution.\n     * @throws PropertyNotFoundException\n     *             if one of the property resolutions failed because a specified\n     *             variable or property does not exist or is not readable.\n     * @throws MethodNotFoundException\n     *             if no suitable method can be found.\n     * @throws ELException\n     *             if an exception was thrown while performing property or\n     *             variable resolution. The thrown exception must be included as\n     *             the cause property of this exception, if available. If the\n     *             exception thrown is an <code>InvocationTargetException<\/code>,\n     *             extract its <code>cause<\/code> and pass it to the\n     *             <code>ELException<\/code> constructor.\n     * @see javax.el.MethodExpression#invoke(javax.el.ELContext,\n     *      java.lang.Object[])\n     */\n    @Override\n    public Object invoke(ELContext context, Object[] params)\n            throws PropertyNotFoundException, MethodNotFoundException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        ctx.notifyBeforeEvaluation(getExpressionString());\n        Object result = this.getNode().invoke(ctx, this.paramTypes, params);\n        ctx.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Evaluates the expression relative to the provided context, and returns\n     * information about the actual referenced method.\n     *\n     * @param context\n     *            The context of this evaluation\n     * @return an instance of <code>MethodInfo<\/code> containing information\n     *         about the method the expression evaluated to.\n     * @throws NullPointerException\n     *             if context is <code>null<\/code> or the base object is\n     *             <code>null<\/code> on the last resolution.\n     * @throws PropertyNotFoundException\n     *             if one of the property resolutions failed because a specified\n     *             variable or property does not exist or is not readable.\n     * @throws MethodNotFoundException\n     *             if no suitable method can be found.\n     * @throws ELException\n     *             if an exception was thrown while performing property or\n     *             variable resolution. The thrown exception must be included as\n     *             the cause property of this exception, if available.\n     * @see javax.el.MethodExpression#getMethodInfo(javax.el.ELContext)\n     */\n    @Override\n    public MethodInfo getMethodInfo(ELContext context)\n            throws PropertyNotFoundException, MethodNotFoundException,\n            ELException {\n        Node n = this.getNode();\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        return n.getMethodInfo(ctx, this.paramTypes);\n    }","id":85198,"modified_method":"/**\n     * Evaluates the expression relative to the provided context, and returns\n     * information about the actual referenced method.\n     *\n     * @param context\n     *            The context of this evaluation\n     * @return an instance of <code>MethodInfo<\/code> containing information\n     *         about the method the expression evaluated to.\n     * @throws NullPointerException\n     *             if context is <code>null<\/code> or the base object is\n     *             <code>null<\/code> on the last resolution.\n     * @throws PropertyNotFoundException\n     *             if one of the property resolutions failed because a specified\n     *             variable or property does not exist or is not readable.\n     * @throws MethodNotFoundException\n     *             if no suitable method can be found.\n     * @throws ELException\n     *             if an exception was thrown while performing property or\n     *             variable resolution. The thrown exception must be included as\n     *             the cause property of this exception, if available.\n     * @see javax.el.MethodExpression#getMethodInfo(javax.el.ELContext)\n     */\n    @Override\n    public MethodInfo getMethodInfo(ELContext context)\n            throws PropertyNotFoundException, MethodNotFoundException,\n            ELException {\n        Node n = this.getNode();\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        ctx.notifyBeforeEvaluation(getExpressionString());\n        MethodInfo result = n.getMethodInfo(ctx, this.paramTypes);\n        ctx.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object invoke(ELContext context, Object[] params) throws ELException {\n        if (this.expectedType != null) {\n            return context.convertToType(this.expr, this.expectedType);\n        } else {\n            return this.expr;\n        }\n    }","id":85199,"modified_method":"@Override\n    public Object invoke(ELContext context, Object[] params) throws ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        Object result;\n        if (this.expectedType != null) {\n            result = context.convertToType(this.expr, this.expectedType);\n        } else {\n            result = this.expr;\n        }\n        context.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public MethodInfo getMethodInfo(ELContext context) throws ELException {\n        return new MethodInfo(this.expr, this.expectedType, this.paramTypes);\n    }","id":85200,"modified_method":"@Override\n    public MethodInfo getMethodInfo(ELContext context) throws ELException {\n        context.notifyBeforeEvaluation(getExpressionString());\n        MethodInfo result =\n                new MethodInfo(this.expr, this.expectedType, this.paramTypes);\n        context.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Class<?> getType(ELContext context) throws PropertyNotFoundException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        return this.getNode().getType(ctx);\n    }","id":85201,"modified_method":"@Override\n    public Class<?> getType(ELContext context) throws PropertyNotFoundException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        context.notifyBeforeEvaluation(getExpressionString());\n        Class<?> result = this.getNode().getType(ctx);\n        context.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean isReadOnly(ELContext context)\n            throws PropertyNotFoundException, ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        return this.getNode().isReadOnly(ctx);\n    }","id":85202,"modified_method":"@Override\n    public boolean isReadOnly(ELContext context)\n            throws PropertyNotFoundException, ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        context.notifyBeforeEvaluation(getExpressionString());\n        boolean result = this.getNode().isReadOnly(ctx);\n        context.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object getValue(ELContext context) throws PropertyNotFoundException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        Object value = this.getNode().getValue(ctx);\n        if (this.expectedType != null) {\n            return context.convertToType(value, this.expectedType);\n        }\n        return value;\n    }","id":85203,"modified_method":"@Override\n    public Object getValue(ELContext context) throws PropertyNotFoundException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        context.notifyBeforeEvaluation(getExpressionString());\n        Object value = this.getNode().getValue(ctx);\n        if (this.expectedType != null) {\n            value = context.convertToType(value, this.expectedType);\n        }\n        context.notifyAfterEvaluation(getExpressionString());\n        return value;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void setValue(ELContext context, Object value)\n            throws PropertyNotFoundException, PropertyNotWritableException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        this.getNode().setValue(ctx, value);\n    }","id":85204,"modified_method":"@Override\n    public void setValue(ELContext context, Object value)\n            throws PropertyNotFoundException, PropertyNotWritableException,\n            ELException {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        context.notifyBeforeEvaluation(getExpressionString());\n        this.getNode().setValue(ctx, value);\n        context.notifyAfterEvaluation(getExpressionString());\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @since EL 2.2\n     */\n    @Override\n    public ValueReference getValueReference(ELContext context) {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        return this.getNode().getValueReference(ctx);\n    }","id":85205,"modified_method":"/**\n     * @since EL 2.2\n     */\n    @Override\n    public ValueReference getValueReference(ELContext context) {\n        EvaluationContext ctx = new EvaluationContext(context, this.fnMapper,\n                this.varMapper);\n        context.notifyBeforeEvaluation(getExpressionString());\n        ValueReference result = this.getNode().getValueReference(ctx);\n        context.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Class<?> getType(ELContext context) {\n        return (this.value != null) ? this.value.getClass() : null;\n    }","id":85206,"modified_method":"@Override\n    public Class<?> getType(ELContext context) {\n        context.notifyBeforeEvaluation(getExpressionString());\n        Class<?> result = (this.value != null) ? this.value.getClass() : null;\n        context.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void setValue(ELContext context, Object value) {\n        throw new PropertyNotWritableException(MessageFactory.get(\n                \"error.value.literal.write\", this.value));\n    }","id":85207,"modified_method":"@Override\n    public void setValue(ELContext context, Object value) {\n        context.notifyBeforeEvaluation(getExpressionString());\n        throw new PropertyNotWritableException(MessageFactory.get(\n                \"error.value.literal.write\", this.value));\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object getValue(ELContext context) {\n        if (this.expectedType != null) {\n            return context.convertToType(this.value, this.expectedType);\n        }\n        return this.value;\n    }","id":85208,"modified_method":"@Override\n    public Object getValue(ELContext context) {\n        context.notifyBeforeEvaluation(getExpressionString());\n        Object result;\n        if (this.expectedType != null) {\n            result = context.convertToType(this.value, this.expectedType);\n        } else {\n            result = this.value;\n        }\n        context.notifyAfterEvaluation(getExpressionString());\n        return result;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean isReadOnly(ELContext context) {\n        return true;\n    }","id":85209,"modified_method":"@Override\n    public boolean isReadOnly(ELContext context) {\n        context.notifyBeforeEvaluation(getExpressionString());\n        context.notifyAfterEvaluation(getExpressionString());\n        return true;\n    }","commit_id":"0be3cc219f024a2b6aed3e9e0ab4b841e08d3aae","url":"https://github.com/apache/tomcat"},{"original_method":"protected List<ImportNormalizer> getImplicitImports(boolean ignoreCase) {\n\t\treturn newArrayList(\n\t\t\t\tnew ImportNormalizer(QualifiedName.create(\"java\",\"lang\"), true, ignoreCase));\n\t}","id":85210,"modified_method":"protected List<ImportNormalizer> getImplicitImports(boolean ignoreCase) {\n\t\treturn newArrayList(\n\t\t\t\tnew ImportNormalizer(JAVA_LANG, true, false),\n\t\t\t\tnew ImportNormalizer(XBASE_LIB, true, false));\n\t}","commit_id":"361d60c30032f1de4a5301bea6ba2d47a4b4f6e4","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<ImportNormalizer> internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {\n\t\tif(EcoreUtil.getRootContainer(context) != context) \n\t\t\treturn Collections.emptyList();\n\t\tList<ImportNormalizer> importedNamespaceResolvers = Lists.newArrayList();\n\t\tXImportSection importSection = importsConfiguration.getImportSection((XtextResource) context.eResource());\n\t\tif(importSection != null) {\n\t\t\tfor (XImportDeclaration imp: importSection.getImportDeclarations()) {\n\t\t\t\tif (!imp.isStatic()) {\n\t\t\t\t\tImportNormalizer resolver = createImportedNamespaceResolver(imp.getImportedTypeName(), ignoreCase);\n\t\t\t\t\tif (resolver != null)\n\t\t\t\t\t\timportedNamespaceResolvers.add(resolver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn importedNamespaceResolvers;\n\t}","id":85211,"modified_method":"protected List<ImportNormalizer> internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {\n\t\tif(EcoreUtil.getRootContainer(context) != context) \n\t\t\treturn Collections.emptyList();\n\t\tList<ImportNormalizer> importedNamespaceResolvers = Lists.newArrayList();\n\t\tXImportSection importSection = importsConfiguration.getImportSection((XtextResource) context.eResource());\n\t\tif(importSection != null) {\n\t\t\tfor (XImportDeclaration imp: importSection.getImportDeclarations()) {\n\t\t\t\tif (!imp.isStatic()) {\n\t\t\t\t\tString value = imp.getImportedNamespace();\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t\tvalue = imp.getImportedTypeName();\n\t\t\t\t\tImportNormalizer resolver = createImportedNamespaceResolver(value, ignoreCase);\n\t\t\t\t\tif (resolver != null)\n\t\t\t\t\t\timportedNamespaceResolvers.add(resolver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn importedNamespaceResolvers;\n\t}","commit_id":"361d60c30032f1de4a5301bea6ba2d47a4b4f6e4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected List<ImportNormalizer> internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {\n\t\tif (!(context instanceof XtendFile))\n\t\t\treturn Collections.emptyList();\n\t\tXtendFile file = (XtendFile) context;\n\t\tList<ImportNormalizer> importedNamespaceResolvers = Lists.newArrayList();\n\t\tif(file.getImportSection() != null) {\n\t\t\tfor (XImportDeclaration imp : file.getImportSection().getImportDeclarations()) {\n\t\t\t\tif (!imp.isStatic() && imp instanceof XtendImport) {\n\t\t\t\t\tString value = ((XtendImport) imp).getImportedNamespace();\n\t\t\t\t\tif (value == null)\n\t\t\t\t\t\tvalue = imp.getImportedTypeName();\n\t\t\t\t\tImportNormalizer resolver = createImportedNamespaceResolver(value, ignoreCase);\n\t\t\t\t\tif (resolver != null)\n\t\t\t\t\t\timportedNamespaceResolvers.add(resolver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!Strings.isEmpty(((XtendFile) context).getPackage())) {\n\t\t\timportedNamespaceResolvers.add(new ImportNormalizer(nameConverter.toQualifiedName(((XtendFile) context)\n\t\t\t\t\t.getPackage()), true, ignoreCase));\n\t\t}\n\t\treturn importedNamespaceResolvers;\n\t}","id":85212,"modified_method":"@Override\n\tprotected List<ImportNormalizer> internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {\n\t\tList<ImportNormalizer> importedNamespaceResolvers = super.internalGetImportedNamespaceResolvers(context, ignoreCase);\n\t\tif (!Strings.isEmpty(((XtendFile) context).getPackage())) {\n\t\t\timportedNamespaceResolvers.add(new ImportNormalizer(getQualifiedNameConverter().toQualifiedName(((XtendFile) context)\n\t\t\t\t\t.getPackage()), true, ignoreCase));\n\t\t}\n\t\treturn importedNamespaceResolvers;\n\t}","commit_id":"361d60c30032f1de4a5301bea6ba2d47a4b4f6e4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected List<ImportNormalizer> getImplicitImports(boolean ignoreCase) {\n\t\treturn newArrayList(\n\t\t\t\tnew ImportNormalizer(JAVA_LANG, true, false),\n\t\t\t\tnew ImportNormalizer(XTEND_LIB, true, false));\n\t}","id":85213,"modified_method":"@Override\n\tprotected List<ImportNormalizer> getImplicitImports(boolean ignoreCase) {\n\t\tList<ImportNormalizer> implicitImports = super.getImplicitImports(ignoreCase);\n\t\timplicitImports.add(new ImportNormalizer(XTEND_LIB, true, false));\n\t\treturn implicitImports;\n\t}","commit_id":"361d60c30032f1de4a5301bea6ba2d47a4b4f6e4","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Object _text(XtendImport xtendImport) {\n\t\treturn xtendImport.getImportedTypeName();\n\t}","id":85214,"modified_method":"protected Object _text(XtendImport xtendImport) {\n\t\treturn (xtendImport.getImportedNamespace() != null) \n\t\t\t? xtendImport.getImportedNamespace()\n\t\t\t: xtendImport.getImportedTypeName();\n\t}","commit_id":"7d93cb77e9530c442a229b8eafa6723cbcf89313","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Object _text(XtendImport xtendImport) {\n\t\treturn xtendImport.getImportedTypeName();\n\t}","id":85215,"modified_method":"protected Object _text(XtendImport xtendImport) {\n\t\treturn (xtendImport.getImportedNamespace() != null) \n\t\t\t? xtendImport.getImportedNamespace()\n\t\t\t: xtendImport.getImportedTypeName();\n\t}","commit_id":"1f4dd62b889b678670f0c13c4ea80890c1242a02","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void parseImportSection(XImportSection importSection, IAcceptor<String> visiblePackages,\n\t\t\tIAcceptor<String> importedTypes) {\n\t\tfor (XImportDeclaration importDeclaration : importSection.getImportDeclarations()) {\n\t\t\tif (!(importDeclaration.isStatic() || importDeclaration.isExtension())) {\n\t\t\t\tString importedAsString = importDeclaration.getImportedTypeName();\n\t\t\t\tif(importedAsString != null)\n\t\t\t\t\timportedTypes.accept(importedAsString);\n\t\t\t}\n\t\t}\n\t}","id":85216,"modified_method":"protected void parseImportSection(XImportSection importSection, IAcceptor<String> visiblePackages,\n\t\t\tIAcceptor<String> importedTypes) {\n\t\tfor (XImportDeclaration importDeclaration : importSection.getImportDeclarations()) {\n\t\t\tif (!importDeclaration.isStatic()) {\n\t\t\t\tif (importDeclaration.getImportedNamespace() != null) {\n\t\t\t\t\tString importedAsString = importDeclaration.getImportedNamespace();\n\t\t\t\t\tif (importDeclaration.isWildcard()) {\n\t\t\t\t\t\timportedAsString = importedAsString.substring(0, importedAsString.length() - 2);\n\t\t\t\t\t\tvisiblePackages.accept(importedAsString);\n\t\t\t\t\t} else {\n\t\t\t\t\t\timportedTypes.accept(importedAsString);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\timportedTypes.accept(importDeclaration.getImportedTypeName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Object image(IEObjectDescription element) {\n\t\tEClass eClass = element.getEClass();\n\t\tboolean isStatic = descriptionFlags.isStatic(element);\n\t\tif (eClass == XTEND_FILE)\n\t\t\treturn images.forFile();\n\t\telse if (eClass == XTEND_IMPORT)\n\t\t\treturn images.forImport();\n\t\telse if (eClass == XTEND_CLASS || eClass == TypesPackage.Literals.JVM_GENERIC_TYPE)\n\t\t\treturn images.forClass(JvmVisibility.PUBLIC);\n\t\telse if (eClass == XTEND_FUNCTION)\n\t\t\treturn images.forOperation(JvmVisibility.PUBLIC, isStatic);\n\t\telse if (eClass == XTEND_FIELD)\n\t\t\treturn images.forField(JvmVisibility.PUBLIC, isStatic, false);\n\t\telse if (eClass == TypesPackage.Literals.JVM_OPERATION)\n\t\t\treturn (descriptionFlags.isDispatcherOperation(element)) \n\t\t\t\t? images.forDispatcherFunction(JvmVisibility.PUBLIC, isStatic) \n\t\t\t\t: images.forOperation(JvmVisibility.PUBLIC, isStatic);\n\t\telse\n\t\t\treturn super.image(element);\n\t}","id":85217,"modified_method":"@Override\n\tpublic Object image(IEObjectDescription element) {\n\t\tEClass eClass = element.getEClass();\n\t\tboolean isStatic = descriptionFlags.isStatic(element);\n\t\tif (eClass == XTEND_FILE)\n\t\t\treturn images.forFile();\n\t\telse if (eClass == XIMPORT_DECLARATION)\n\t\t\treturn images.forImport();\n\t\telse if (eClass == XTEND_CLASS || eClass == TypesPackage.Literals.JVM_GENERIC_TYPE)\n\t\t\treturn images.forClass(JvmVisibility.PUBLIC);\n\t\telse if (eClass == XTEND_FUNCTION)\n\t\t\treturn images.forOperation(JvmVisibility.PUBLIC, isStatic);\n\t\telse if (eClass == XTEND_FIELD)\n\t\t\treturn images.forField(JvmVisibility.PUBLIC, isStatic, false);\n\t\telse if (eClass == TypesPackage.Literals.JVM_OPERATION)\n\t\t\treturn (descriptionFlags.isDispatcherOperation(element)) \n\t\t\t\t? images.forDispatcherFunction(JvmVisibility.PUBLIC, isStatic) \n\t\t\t\t: images.forOperation(JvmVisibility.PUBLIC, isStatic);\n\t\telse\n\t\t\treturn super.image(element);\n\t}","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<String> getImportStrings() {\n\t\tXtextDocument document = (XtextDocument) getDocument();\n\t\treturn document.readOnly(new IUnitOfWork<List<String>, XtextResource>() {\n\t\t\tpublic List<String> exec(XtextResource state) throws Exception {\n\t\t\t\tXtendFile xtendFile = (XtendFile) state.getContents().get(0);\n\t\t\t\tif(xtendFile.getImportSection() == null) {\n\t\t\t\t\treturn emptyList();\n\t\t\t\t} else {\n\t\t\t\t\tEList<XImportDeclaration> xtendImports = xtendFile.getImportSection().getImportDeclarations();\n\t\t\t\t\tList<String> imports = Lists.newArrayList();\n\t\t\t\t\tfor (XImportDeclaration imp : xtendImports) {\n\t\t\t\t\t\tif(imp instanceof XtendImport && ((XtendImport)imp).getImportedNamespace() != null) \n\t\t\t\t\t\t\timports.add(((XtendImport)imp).getImportedNamespace());\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\timports.add(imp.getImportedTypeName());\n\t\t\t\t\t}\n\t\t\t\t\treturn imports;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":85218,"modified_method":"protected List<String> getImportStrings() {\n\t\tXtextDocument document = (XtextDocument) getDocument();\n\t\treturn document.readOnly(new IUnitOfWork<List<String>, XtextResource>() {\n\t\t\tpublic List<String> exec(XtextResource state) throws Exception {\n\t\t\t\tXtendFile xtendFile = (XtendFile) state.getContents().get(0);\n\t\t\t\tif(xtendFile.getImportSection() == null) {\n\t\t\t\t\treturn emptyList();\n\t\t\t\t} else {\n\t\t\t\t\tEList<XImportDeclaration> xtendImports = xtendFile.getImportSection().getImportDeclarations();\n\t\t\t\t\tList<String> imports = Lists.newArrayList();\n\t\t\t\t\tfor (XImportDeclaration imp : xtendImports) {\n\t\t\t\t\t\tString importedTypeName = imp.getImportedTypeName();\n\t\t\t\t\t\tif(importedTypeName != null) \n\t\t\t\t\t\t\timports.add(importedTypeName);\n\t\t\t\t\t}\n\t\t\t\t\treturn imports;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testDiscouragedConstructorCallInnernClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass$InnerInternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"InnerInternalClass x = new InnerInternalClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XTEND_IMPORT, IssueCodes.DISCOURAGED_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertWarning(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.DISCOURAGED_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertWarning(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85219,"modified_method":"@Test\n  public void testDiscouragedConstructorCallInnernClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass$InnerInternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"InnerInternalClass x = new InnerInternalClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XIMPORT_DECLARATION, IssueCodes.DISCOURAGED_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertWarning(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.DISCOURAGED_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertWarning(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testDiscouragedConstructorCall() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"InternalClass x = new InternalClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XTEND_IMPORT, IssueCodes.DISCOURAGED_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertWarning(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.DISCOURAGED_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertWarning(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85220,"modified_method":"@Test\n  public void testDiscouragedConstructorCall() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"InternalClass x = new InternalClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XIMPORT_DECLARATION, IssueCodes.DISCOURAGED_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertWarning(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.DISCOURAGED_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertWarning(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testDiscouragedImport() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XTEND_IMPORT, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85221,"modified_method":"@Test\n  public void testDiscouragedImport() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XIMPORT_DECLARATION, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testForbiddenConstructorCall() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"RestrictedClass x = new RestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XTEND_IMPORT, IssueCodes.FORBIDDEN_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertError(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.FORBIDDEN_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertError(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85222,"modified_method":"@Test\n  public void testForbiddenConstructorCall() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"RestrictedClass x = new RestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XIMPORT_DECLARATION, IssueCodes.FORBIDDEN_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertError(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.FORBIDDEN_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertError(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testForbiddenImportInnerClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass$InnerRestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XTEND_IMPORT, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85223,"modified_method":"@Test\n  public void testForbiddenImportInnerClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass$InnerRestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XIMPORT_DECLARATION, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testDiscouragedImportInnerClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass$InnerInternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XTEND_IMPORT, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85224,"modified_method":"@Test\n  public void testDiscouragedImportInnerClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.internal.InternalClass$InnerInternalClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertWarning(_get, Literals.XIMPORT_DECLARATION, IssueCodes.DISCOURAGED_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testForbiddenConstructorCallInnerClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass$InnerRestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"InnerRestrictedClass x = new InnerRestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XTEND_IMPORT, IssueCodes.FORBIDDEN_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertError(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.FORBIDDEN_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertError(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85225,"modified_method":"@Test\n  public void testForbiddenConstructorCallInnerClass() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass$InnerRestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"\\t\");\n      _builder.append(\"InnerRestrictedClass x = new InnerRestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XIMPORT_DECLARATION, IssueCodes.FORBIDDEN_REFERENCE);\n      EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n      Iterable<XtendClass> _filter = Iterables.<XtendClass>filter(_xtendTypes, XtendClass.class);\n      XtendClass _head = IterableExtensions.<XtendClass>head(_filter);\n      EList<XtendMember> _members = _head.getMembers();\n      XtendMember _head_1 = IterableExtensions.<XtendMember>head(_members);\n      final XtendField field = ((XtendField) _head_1);\n      JvmTypeReference _type = field.getType();\n      this.helper.assertError(_type, org.eclipse.xtext.common.types.TypesPackage.Literals.JVM_TYPE_REFERENCE, IssueCodes.FORBIDDEN_REFERENCE);\n      XExpression _initialValue = field.getInitialValue();\n      this.helper.assertError(_initialValue, org.eclipse.xtext.xbase.XbasePackage.Literals.XCONSTRUCTOR_CALL, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testForbiddenImport() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XTEND_IMPORT, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":85226,"modified_method":"@Test\n  public void testForbiddenImport() {\n    try {\n      StringConcatenation _builder = new StringConcatenation();\n      _builder.append(\"import org.eclipse.xtend.core.tests.restricted.RestrictedClass\");\n      _builder.newLine();\n      _builder.append(\"class Foo {\");\n      _builder.newLine();\n      _builder.append(\"}\");\n      _builder.newLine();\n      _builder.newLine();\n      final XtendFile xtendFile = this.testHelper.xtendFile(\"Clazz.xtend\", _builder.toString());\n      XImportSection _importSection = xtendFile.getImportSection();\n      EList<XImportDeclaration> _importDeclarations = _importSection.getImportDeclarations();\n      XImportDeclaration _get = _importDeclarations.get(0);\n      this.helper.assertError(_get, Literals.XIMPORT_DECLARATION, IssueCodes.FORBIDDEN_REFERENCE);\n    } catch (Exception _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"0fa6b1273294176982c27520d77ca57ea0c9d8d4","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JComponent createNorthPanel() {\n    JPanel panel = new JPanel(new GridBagLayout());\n\n    panel.setBorder(IdeBorderFactory.createBorder());\n\n    myInformationLabel = new JLabel();\n\n    panel.add(myInformationLabel, new GridBagConstraints(0,0,2,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n    DocumentListener documentListener = new DocumentAdapter() {\n      public void textChanged(DocumentEvent event) {\n        validateOKButton();\n      }\n    };\n\n    if (myShowDirectoryField) {\n      panel.add(new JLabel(RefactoringBundle.message(\"copy.files.to.directory.label\")), new GridBagConstraints(0,1,1,1,0,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n      final ComponentWithBrowseButton.BrowseFolderActionListener browseActionListener =\n        new ComponentWithBrowseButton.BrowseFolderActionListener<JComboBox>(RefactoringBundle.message(\"select.target.directory\"),\n                                                                 RefactoringBundle.message(\"the.file.will.be.copied.to.this.directory\"),\n                                                                 null, myProject, FileChooserDescriptorFactory.createSingleFolderDescriptor(),\n                                                                 TextComponentAccessor.STRING_COMBOBOX_WHOLE_TEXT);\n      myTargetDirectoryField = new EditorComboWithBrowseButton(browseActionListener, \"\", myProject,\n                                                               RECENT_KEYS);\n      myTargetDirectoryField.setTextFieldPreferredWidth(60);\n      panel.add(myTargetDirectoryField, new GridBagConstraints(1,1,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,0,4,8),0,0));\n\n      myTargetDirectoryField.getChildComponent().getDocument().addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n        @Override\n        public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n          validateOKButton();\n        }\n      });\n    }\n\n    if (myShowNewNameField) {\n      myNewNameField = new JTextField();\n      Dimension size = myNewNameField.getPreferredSize();\n      FontMetrics fontMetrics = myNewNameField.getFontMetrics(myNewNameField.getFont());\n      size.width = fontMetrics.charWidth('a') * 60;\n      myNewNameField.setPreferredSize(size);\n\n      panel.add(new JLabel(RefactoringBundle.message(\"copy.files.new.name.label\")), new GridBagConstraints(0,2,1,1,0,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n      panel.add(myNewNameField, new GridBagConstraints(1,2,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,0,4,8),0,0));\n\n      myNewNameField.getDocument().addDocumentListener(documentListener);\n    }\n\n    return panel;\n  }","id":85227,"modified_method":"protected JComponent createNorthPanel() {\n    JPanel panel = new JPanel(new GridBagLayout());\n\n    panel.setBorder(IdeBorderFactory.createBorder());\n\n    myInformationLabel = new JLabel();\n\n    panel.add(myInformationLabel, new GridBagConstraints(0,0,2,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n    DocumentListener documentListener = new DocumentAdapter() {\n      public void textChanged(DocumentEvent event) {\n        validateOKButton();\n      }\n    };\n\n    if (myShowDirectoryField) {\n      panel.add(new JLabel(RefactoringBundle.message(\"copy.files.to.directory.label\")), new GridBagConstraints(0,1,1,1,0,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n      myTargetDirectoryField = new EditorComboWithBrowseButton(null, \"\", myProject,\n                                                               RECENT_KEYS);\n      myTargetDirectoryField.addBrowseFolderListener(RefactoringBundle.message(\"select.target.directory\"),\n                                                                            RefactoringBundle.message(\"the.file.will.be.copied.to.this.directory\"),\n                                                                            myProject, FileChooserDescriptorFactory.createSingleFolderDescriptor(),\n                                                                            EditorComboBox.COMPONENT_ACCESSOR);\n      myTargetDirectoryField.setTextFieldPreferredWidth(60);\n      panel.add(myTargetDirectoryField, new GridBagConstraints(1,1,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,0,4,8),0,0));\n\n      myTargetDirectoryField.getChildComponent().getDocument().addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n        @Override\n        public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n          validateOKButton();\n        }\n      });\n    }\n\n    if (myShowNewNameField) {\n      myNewNameField = new JTextField();\n      Dimension size = myNewNameField.getPreferredSize();\n      FontMetrics fontMetrics = myNewNameField.getFontMetrics(myNewNameField.getFont());\n      size.width = fontMetrics.charWidth('a') * 60;\n      myNewNameField.setPreferredSize(size);\n\n      panel.add(new JLabel(RefactoringBundle.message(\"copy.files.new.name.label\")), new GridBagConstraints(0,2,1,1,0,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n      panel.add(myNewNameField, new GridBagConstraints(1,2,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,0,4,8),0,0));\n\n      myNewNameField.getDocument().addDocumentListener(documentListener);\n    }\n\n    return panel;\n  }","commit_id":"be29e51590a4c76e77fb60cbc9a5fc29c0c72c81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createNorthPanel() {\n    JPanel panel = new JPanel();\n    panel.setLayout(new GridBagLayout());\n\n    panel.setBorder(IdeBorderFactory.createBorder());\n\n    myNameLabel = new JLabel();\n    panel.add(myNameLabel, new GridBagConstraints(0,0,2,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n    panel.add(new JLabel(RefactoringBundle.message(\"move.files.to.directory.label\")),\n              new GridBagConstraints(0,1,1,1,0,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n    final ComponentWithBrowseButton.BrowseFolderActionListener browseActionListener =\n      new ComponentWithBrowseButton.BrowseFolderActionListener<JComboBox>(RefactoringBundle.message(\"select.target.directory\"),\n                                                               RefactoringBundle.message(\"the.file.will.be.moved.to.this.directory\"), null,\n                                                               myProject, FileChooserDescriptorFactory.createSingleFolderDescriptor(),\n                                                               TextComponentAccessor.STRING_COMBOBOX_WHOLE_TEXT);\n    myTargetDirectoryField = new EditorComboWithBrowseButton(browseActionListener, \"\", myProject, RECENT_KEYS);\n    myTargetDirectoryField.setTextFieldPreferredWidth(60);\n    panel.add(myTargetDirectoryField, new GridBagConstraints(1,1,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,0,4,8),0,0));\n\n    myTargetDirectoryField.getChildComponent().getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        validateOKButton();\n      }\n    });\n    Disposer.register(getDisposable(), myTargetDirectoryField);\n\n    return panel;\n  }","id":85228,"modified_method":"protected JComponent createNorthPanel() {\n    JPanel panel = new JPanel();\n    panel.setLayout(new GridBagLayout());\n\n    panel.setBorder(IdeBorderFactory.createBorder());\n\n    myNameLabel = new JLabel();\n    panel.add(myNameLabel, new GridBagConstraints(0,0,2,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n    panel.add(new JLabel(RefactoringBundle.message(\"move.files.to.directory.label\")),\n              new GridBagConstraints(0,1,1,1,0,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,8,4,8),0,0));\n\n    myTargetDirectoryField = new EditorComboWithBrowseButton(null, \"\", myProject, RECENT_KEYS);\n    myTargetDirectoryField.addBrowseFolderListener(RefactoringBundle.message(\"select.target.directory\"),\n                                                   RefactoringBundle.message(\"the.file.will.be.moved.to.this.directory\"),\n                                                   myProject,\n                                                   FileChooserDescriptorFactory.createSingleFolderDescriptor(),\n                                                   EditorComboBox.COMPONENT_ACCESSOR);\n    myTargetDirectoryField.setTextFieldPreferredWidth(60);\n    panel.add(myTargetDirectoryField, new GridBagConstraints(1,1,1,1,1,0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(4,0,4,8),0,0));\n\n    myTargetDirectoryField.getChildComponent().getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        validateOKButton();\n      }\n    });\n    Disposer.register(getDisposable(), myTargetDirectoryField);\n\n    return panel;\n  }","commit_id":"be29e51590a4c76e77fb60cbc9a5fc29c0c72c81","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private RunConfigurationTableModel getTableModel() {\n    return (RunConfigurationTableModel)modulesList.getModel();\n  }","id":85229,"modified_method":"private RunConfigurationTableModel getTableModel() {\n    return (RunConfigurationTableModel)myBundlesTable.getModel();\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public OsgiRunConfigurationEditor(final Project project) {\n    ApplicationSettings registry = ServiceManager.getService(ApplicationSettings.class);\n    myFrameworkStartLevel.setModel(new SpinnerNumberModel(0, 0, Integer.MAX_VALUE, 1));\n    JSpinner.DefaultEditor editor = (JSpinner.DefaultEditor)myFrameworkStartLevel.getEditor();\n    editor.getTextField().setFormatterFactory(new DefaultFormatterFactory(new JSpinnerCellEditor.MyNumberFormatter(\"Auto\")));\n    myDefaultStartLevel.setModel(new SpinnerNumberModel(1, 1, Integer.MAX_VALUE, 1));\n\n    //noinspection unchecked\n    frameworkInstances.setModel(new DefaultComboBoxModel(registry.getFrameworkInstanceDefinitions().toArray()));\n    frameworkInstances.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        onFrameworkChange();\n      }\n    });\n\n    this.project = project;\n    RunConfigurationTableModel model = new RunConfigurationTableModel();\n\n    modulesList.setModel(model);\n    modulesList.setRowSelectionAllowed(true);\n    modulesList.setColumnSelectionAllowed(false);\n    modulesList.setDefaultEditor(Integer.class, new JSpinnerCellEditor());\n    modulesList.setDefaultRenderer(Integer.class, new JSpinnerCellEditor());\n    modulesList.setAutoCreateRowSorter(true);\n\n    addButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        onAddClick();\n      }\n    });\n    removeButton.addActionListener(new ActionListener() {\n\n      public void actionPerformed(ActionEvent e) {\n        onRemoveClick();\n      }\n    });\n    osmorcControlledRadioButton.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean isUserDefined = !osmorcControlledRadioButton.isSelected();\n        workingDirField.setEnabled(isUserDefined);\n      }\n    });\n\n    workingDirField\n      .addBrowseFolderListener(\"Choose a working directory\", \"The working directory is the directory from which the framework is started\",\n                               null, FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    workingDirField.getTextField().setColumns(30);\n    frameworkSpecificBundleSelectionActions = new DefaultActionGroup(\"frameworkSpecificBundleSelectionActions\", true);\n\n    frameworkSpecificButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        JBPopupFactory.getInstance().createActionGroupPopup(null, frameworkSpecificBundleSelectionActions,\n                                                            DataManager.getInstance().getDataContext(frameworkSpecificButton),\n                                                            JBPopupFactory.ActionSelectionAid.NUMBERING, true)\n          .showUnderneathOf(frameworkSpecificButton);\n      }\n    });\n    modulesList.addComponentListener(new ComponentAdapter() {\n      @Override\n      public void componentResized(ComponentEvent e) {\n        int width = modulesList.getWidth();\n        int bundleNameWidth = 2 * width / 3;\n        int otherWidth = width / 3 / 2;\n\n        TableColumn bundleColumn = modulesList.getColumnModel().getColumn(0);\n        bundleColumn.setPreferredWidth(bundleNameWidth);\n\n        TableColumn startLevelColumn = modulesList.getColumnModel().getColumn(1);\n        startLevelColumn.setPreferredWidth(otherWidth);\n\n        TableColumn startColumn = modulesList.getColumnModel().getColumn(2);\n        startColumn.setPreferredWidth(otherWidth);\n      }\n    });\n    // avoid text fields growing the dialog when much text is entered.\n    vmParams.getTextField().setPreferredSize(new Dimension(100, 20));\n    programParameters.getTextField().setPreferredSize(new Dimension(100, 20));\n\n    setAnchor(alternativeJREPanel.getCbEnabled());\n  }","id":85230,"modified_method":"public OsgiRunConfigurationEditor(final Project project) {\n    myProject = project;\n\n    myFrameworkStartLevel.setModel(new SpinnerNumberModel(0, 0, Integer.MAX_VALUE, 1));\n    JSpinner.DefaultEditor editor = (JSpinner.DefaultEditor)myFrameworkStartLevel.getEditor();\n    editor.getTextField().setFormatterFactory(new DefaultFormatterFactory(new JSpinnerCellEditor.MyNumberFormatter(\"Auto\")));\n\n    myDefaultStartLevel.setModel(new SpinnerNumberModel(1, 1, Integer.MAX_VALUE, 1));\n\n    //noinspection unchecked\n    myFrameworkInstances.setModel(new DefaultComboBoxModel(ApplicationSettings.getInstance().getFrameworkInstanceDefinitions().toArray()));\n    myFrameworkInstances.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        onFrameworkChange();\n      }\n    });\n\n    myCurrentBundleSelectionActions = new DefaultActionGroup(\"frameworkSpecificBundleSelectionActions\", true);\n\n    myBundlesTable.setModel(new RunConfigurationTableModel());\n    myBundlesTable.setRowSelectionAllowed(true);\n    myBundlesTable.setColumnSelectionAllowed(false);\n    myBundlesTable.setDefaultEditor(Integer.class, new JSpinnerCellEditor());\n    myBundlesTable.setDefaultRenderer(Integer.class, new JSpinnerCellEditor());\n    myBundlesTable.setAutoCreateRowSorter(true);\n    myBundlesPanel.add(\n      ToolbarDecorator.createDecorator(myBundlesTable)\n        .setAddAction(new AnActionButtonRunnable() {\n          @Override\n          public void run(AnActionButton button) {\n            onAddClick();\n          }\n        })\n        .setRemoveAction(new AnActionButtonRunnable() {\n          @Override\n          public void run(AnActionButton button) {\n            onRemoveClick();\n          }\n        })\n        .addExtraAction(myExtraActionsButton = new AnActionButton(\"Extra Actions\", AllIcons.Actions.IntentionBulb) {\n          @Override\n          public void actionPerformed(AnActionEvent e) {\n            JBPopupFactory.getInstance().createActionGroupPopup(\n              \"Extra Actions\", myCurrentBundleSelectionActions, e.getDataContext(), false, false, false, null, -1, null\n            ).show(this.getPreferredPopupPoint());\n          }\n        })\n        .createPanel(), BorderLayout.CENTER\n    );\n    myBundlesTable.addComponentListener(new ComponentAdapter() {\n      @Override\n      public void componentResized(ComponentEvent e) {\n        int width = myBundlesTable.getWidth();\n        int bundleNameWidth = 2 * width / 3;\n        int otherWidth = width / 3 / 2;\n\n        TableColumn bundleColumn = myBundlesTable.getColumnModel().getColumn(0);\n        bundleColumn.setPreferredWidth(bundleNameWidth);\n\n        TableColumn startLevelColumn = myBundlesTable.getColumnModel().getColumn(1);\n        startLevelColumn.setPreferredWidth(otherWidth);\n\n        TableColumn startColumn = myBundlesTable.getColumnModel().getColumn(2);\n        startColumn.setPreferredWidth(otherWidth);\n      }\n    });\n\n    myOsmorcControlledDir.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean isUserDefined = !myOsmorcControlledDir.isSelected();\n        myWorkingDirField.setEnabled(isUserDefined);\n      }\n    });\n\n    FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n    String title = \"Choose a working directory\";\n    String description = \"The working directory is the directory from which the framework is started\";\n    myWorkingDirField.addBrowseFolderListener(title, description, null, descriptor);\n    myWorkingDirField.getTextField().setColumns(30);\n\n    // avoid text fields growing the dialog when much text is entered.\n    myVmOptions.getTextField().setPreferredSize(new Dimension(100, 20));\n    myProgramParameters.getTextField().setPreferredSize(new Dimension(100, 20));\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  public FrameworkInstanceDefinition getUsedFrameworkInstance() {\n    return (FrameworkInstanceDefinition)frameworkInstances.getSelectedItem();\n  }","id":85231,"modified_method":"@Nullable\n  public FrameworkInstanceDefinition getUsedFrameworkInstance() {\n    return (FrameworkInstanceDefinition)myFrameworkInstances.getSelectedItem();\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void applyEditorTo(OsgiRunConfiguration osgiRunConfiguration) throws ConfigurationException {\n    List<SelectedBundle> modules = getBundlesToRun();\n    osgiRunConfiguration.setBundlesToDeploy(modules);\n    osgiRunConfiguration.setVmParameters(vmParams.getText());\n    osgiRunConfiguration.setProgramParameters(programParameters.getText());\n    osgiRunConfiguration.setIncludeAllBundlesInClassPath(includeAllBundlesInClassPath.isSelected());\n    osgiRunConfiguration.setWorkingDir(workingDirField.getText().replace('\\\\', '/'));\n    osgiRunConfiguration.setUseAlternativeJre(alternativeJREPanel.isPathEnabled());\n    osgiRunConfiguration.setAlternativeJrePath(alternativeJREPanel.getPath());\n    osgiRunConfiguration.setFrameworkStartLevel((Integer)myFrameworkStartLevel.getValue());\n    osgiRunConfiguration.setDefaultStartLevel((Integer)myDefaultStartLevel.getValue());\n    osgiRunConfiguration.setGenerateWorkingDir(osmorcControlledRadioButton.isSelected());\n    FrameworkInstanceDefinition frameworkInstanceDefinition = (FrameworkInstanceDefinition)frameworkInstances.getSelectedItem();\n    if (frameworkInstanceDefinition != null) {\n      osgiRunConfiguration.setInstanceToUse(frameworkInstanceDefinition);\n    }\n\n    if (currentFrameworkRunPropertiesEditor != null) {\n      currentFrameworkRunPropertiesEditor.applyEditorTo(osgiRunConfiguration);\n    }\n  }","id":85232,"modified_method":"protected void applyEditorTo(OsgiRunConfiguration osgiRunConfiguration) throws ConfigurationException {\n    List<SelectedBundle> modules = getBundlesToRun();\n    osgiRunConfiguration.setBundlesToDeploy(modules);\n    osgiRunConfiguration.setVmParameters(myVmOptions.getText());\n    osgiRunConfiguration.setProgramParameters(myProgramParameters.getText());\n    osgiRunConfiguration.setIncludeAllBundlesInClassPath(myClassPathAllBundles.isSelected());\n    osgiRunConfiguration.setWorkingDir(myWorkingDirField.getText().replace('\\\\', '/'));\n    osgiRunConfiguration.setUseAlternativeJre(myAlternativeJrePanel.isPathEnabled());\n    osgiRunConfiguration.setAlternativeJrePath(myAlternativeJrePanel.getPath());\n    osgiRunConfiguration.setFrameworkStartLevel((Integer)myFrameworkStartLevel.getValue());\n    osgiRunConfiguration.setDefaultStartLevel((Integer)myDefaultStartLevel.getValue());\n    osgiRunConfiguration.setGenerateWorkingDir(myOsmorcControlledDir.isSelected());\n    FrameworkInstanceDefinition frameworkInstanceDefinition = (FrameworkInstanceDefinition)myFrameworkInstances.getSelectedItem();\n    if (frameworkInstanceDefinition != null) {\n      osgiRunConfiguration.setInstanceToUse(frameworkInstanceDefinition);\n    }\n\n    if (myCurrentRunPropertiesEditor != null) {\n      myCurrentRunPropertiesEditor.applyEditorTo(osgiRunConfiguration);\n    }\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * Called when the framework is changed. This will create a new editor for framework properties and will also remove\n   * any framework bundles from the list, as they are no longer in classpath.\n   */\n  private void onFrameworkChange() {\n    frameworkSpecificBundleSelectionActions.removeAll();\n    if (frameworkInstances.getSelectedItem() != null) {\n      FrameworkInstanceDefinition frameworkInstanceDefinition = (FrameworkInstanceDefinition)frameworkInstances.getSelectedItem();\n\n      // we got a framework instance, get the integrator\n      FrameworkIntegratorRegistry registry = ServiceManager.getService(FrameworkIntegratorRegistry.class);\n      FrameworkIntegrator integrator = registry.findIntegratorByInstanceDefinition(frameworkInstanceDefinition);\n\n      // clear the panel\n      additionalFrameworkPropertiesPanel.removeAll();\n\n      // create and install a new editor (if present)\n      currentFrameworkRunPropertiesEditor = integrator.createRunPropertiesEditor();\n      if (currentFrameworkRunPropertiesEditor != null) {\n        additionalFrameworkPropertiesPanel.removeAll();\n        additionalFrameworkPropertiesPanel.add(currentFrameworkRunPropertiesEditor.getUI(), BorderLayout.CENTER);\n        if (osgiRunConfiguration != null) {\n          currentFrameworkRunPropertiesEditor.resetEditorFrom(osgiRunConfiguration);\n          OsgiRunConfigurationChecker checker = null;\n          if (integrator instanceof OsgiRunConfigurationCheckerProvider) {\n            checker = ((OsgiRunConfigurationCheckerProvider)integrator).getOsgiRunConfigurationChecker();\n          }\n          osgiRunConfiguration.setAdditionalChecker(checker);\n        }\n      }\n\n      // remove all framework bundles from the list\n      RunConfigurationTableModel model = getTableModel();\n      model.removeAllOfType(SelectedBundle.BundleType.FrameworkBundle);\n\n      for (BundleSelectionAction bundleSelectionAction : integrator.getBundleSelectionActions()) {\n        bundleSelectionAction.setContext(this);\n        frameworkSpecificBundleSelectionActions.add(bundleSelectionAction);\n      }\n    }\n  }","id":85233,"modified_method":"/**\n   * Called when the framework is changed. This will create a new editor for framework properties and will also remove\n   * any framework bundles from the list, as they are no longer in classpath.\n   */\n  private void onFrameworkChange() {\n    myCurrentBundleSelectionActions.removeAll();\n    myExtraActionsButton.setEnabled(false);\n\n    if (myFrameworkInstances.getSelectedItem() != null) {\n      FrameworkInstanceDefinition instance = (FrameworkInstanceDefinition)myFrameworkInstances.getSelectedItem();\n      FrameworkIntegrator integrator = FrameworkIntegratorRegistry.getInstance().findIntegratorByInstanceDefinition(instance);\n      assert integrator != null : instance;\n\n      // clear the panel\n      myAdditionalPropertiesPanel.removeAll();\n\n      // create and install a new editor (if present)\n      myCurrentRunPropertiesEditor = integrator.createRunPropertiesEditor();\n      if (myCurrentRunPropertiesEditor != null) {\n        myAdditionalPropertiesPanel.removeAll();\n        myAdditionalPropertiesPanel.add(myCurrentRunPropertiesEditor.getUI(), BorderLayout.CENTER);\n        if (myRunConfiguration != null) {\n          myCurrentRunPropertiesEditor.resetEditorFrom(myRunConfiguration);\n          OsgiRunConfigurationChecker checker = null;\n          if (integrator instanceof OsgiRunConfigurationCheckerProvider) {\n            checker = ((OsgiRunConfigurationCheckerProvider)integrator).getOsgiRunConfigurationChecker();\n          }\n          myRunConfiguration.setAdditionalChecker(checker);\n        }\n      }\n\n      // remove all framework bundles from the list\n      RunConfigurationTableModel model = getTableModel();\n      model.removeAllOfType(SelectedBundle.BundleType.FrameworkBundle);\n\n      // setup framework-specific bundle actions\n      List<BundleSelectionAction> extraActions = integrator.getBundleSelectionActions();\n      if (!extraActions.isEmpty()) {\n        for (BundleSelectionAction bundleSelectionAction : extraActions) {\n          bundleSelectionAction.setContext(this);\n          myCurrentBundleSelectionActions.add(bundleSelectionAction);\n        }\n        myExtraActionsButton.setEnabled(true);\n      }\n    }\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void resetEditorFrom(OsgiRunConfiguration osgiRunConfiguration) {\n    this.osgiRunConfiguration = osgiRunConfiguration;\n    vmParams.setText(osgiRunConfiguration.getVmParameters());\n    programParameters.setText(osgiRunConfiguration.getProgramParameters());\n    frameworkInstances.setSelectedItem(osgiRunConfiguration.getInstanceToUse());\n    includeAllBundlesInClassPath.setSelected(osgiRunConfiguration.isIncludeAllBundlesInClassPath());\n\n    if (currentFrameworkRunPropertiesEditor != null) {\n      currentFrameworkRunPropertiesEditor.resetEditorFrom(osgiRunConfiguration);\n    }\n\n    // I deliberately set the list of modules as the last step here as\n    // the framework specific modules are cleaned out when you change the framework instance\n    // so the framework instance should be changed first\n    List<SelectedBundle> modules = osgiRunConfiguration.getBundlesToDeploy();\n    RunConfigurationTableModel model = getTableModel();\n    while (model.getRowCount() > 0) {\n      model.removeBundleAt(0);\n    }\n    for (SelectedBundle module : modules) {\n      model.addBundle(module);\n    }\n    modulesList.getColumnModel().getColumn(1).setPreferredWidth(200);\n\n    myFrameworkStartLevel.setValue(osgiRunConfiguration.getFrameworkStartLevel());\n    myDefaultStartLevel.setValue(osgiRunConfiguration.getDefaultStartLevel());\n\n    boolean useUserDefinedFields = !osgiRunConfiguration.isGenerateWorkingDir();\n    workingDirField.setText(osgiRunConfiguration.getWorkingDir());\n    if (workingDirField.getText().length() == 0) {\n      final CompilerProjectExtension extension = CompilerProjectExtension.getInstance(project);\n      if (extension != null) {\n        final VirtualFilePointer outputDirPointer = extension.getCompilerOutputPointer();\n        if (outputDirPointer != null) {\n          workingDirField.setText(VfsUtilCore.urlToPath(outputDirPointer.getUrl() + \"/run.osgi/\"));\n        }\n      }\n    }\n\n    workingDirField.setEnabled(useUserDefinedFields);\n    userDefinedRadioButton.setSelected(useUserDefinedFields);\n    osmorcControlledRadioButton.setSelected(!useUserDefinedFields);\n    alternativeJREPanel.init(osgiRunConfiguration.getAlternativeJrePath(), osgiRunConfiguration.isUseAlternativeJre());\n  }","id":85234,"modified_method":"protected void resetEditorFrom(OsgiRunConfiguration osgiRunConfiguration) {\n    myRunConfiguration = osgiRunConfiguration;\n    myVmOptions.setText(osgiRunConfiguration.getVmParameters());\n    myProgramParameters.setText(osgiRunConfiguration.getProgramParameters());\n    myFrameworkInstances.setSelectedItem(osgiRunConfiguration.getInstanceToUse());\n    myClassPathAllBundles.setSelected(osgiRunConfiguration.isIncludeAllBundlesInClassPath());\n\n    if (myCurrentRunPropertiesEditor != null) {\n      myCurrentRunPropertiesEditor.resetEditorFrom(osgiRunConfiguration);\n    }\n\n    // I deliberately set the list of modules as the last step here as\n    // the framework specific modules are cleaned out when you change the framework instance\n    // so the framework instance should be changed first\n    List<SelectedBundle> modules = osgiRunConfiguration.getBundlesToDeploy();\n    RunConfigurationTableModel model = getTableModel();\n    while (model.getRowCount() > 0) {\n      model.removeBundleAt(0);\n    }\n    for (SelectedBundle module : modules) {\n      model.addBundle(module);\n    }\n    myBundlesTable.getColumnModel().getColumn(1).setPreferredWidth(200);\n\n    myFrameworkStartLevel.setValue(osgiRunConfiguration.getFrameworkStartLevel());\n    myDefaultStartLevel.setValue(osgiRunConfiguration.getDefaultStartLevel());\n\n    boolean useUserDefinedFields = !osgiRunConfiguration.isGenerateWorkingDir();\n    myWorkingDirField.setText(osgiRunConfiguration.getWorkingDir());\n    if (myWorkingDirField.getText().length() == 0) {\n      final CompilerProjectExtension extension = CompilerProjectExtension.getInstance(myProject);\n      if (extension != null) {\n        final VirtualFilePointer outputDirPointer = extension.getCompilerOutputPointer();\n        if (outputDirPointer != null) {\n          myWorkingDirField.setText(VfsUtilCore.urlToPath(outputDirPointer.getUrl() + \"/run.osgi/\"));\n        }\n      }\n    }\n\n    myWorkingDirField.setEnabled(useUserDefinedFields);\n    myUserDefinedDir.setSelected(useUserDefinedFields);\n    myOsmorcControlledDir.setSelected(!useUserDefinedFields);\n    myAlternativeJrePanel.init(osgiRunConfiguration.getAlternativeJrePath(), osgiRunConfiguration.isUseAlternativeJre());\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void onRemoveClick() {\n    int[] indices = modulesList.getSelectedRows();\n    RunConfigurationTableModel model = getTableModel();\n    for (int i = indices.length - 1; i >= 0; i--) {\n      model.removeBundleAt(indices[i]);\n    }\n  }","id":85235,"modified_method":"private void onRemoveClick() {\n    int[] indices = myBundlesTable.getSelectedRows();\n    RunConfigurationTableModel model = getTableModel();\n    for (int i = indices.length - 1; i >= 0; i--) {\n      model.removeBundleAt(indices[i]);\n    }\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void onAddClick() {\n\n    BundleSelector selector = new BundleSelector(project);\n    selector.setUp((FrameworkInstanceDefinition)frameworkInstances.getSelectedItem(), getBundlesToRun());\n    selector.show(root);\n    List<SelectedBundle> selectedModules = selector.getSelectedBundles();\n    if (selectedModules != null) {\n      RunConfigurationTableModel model = getTableModel();\n      for (SelectedBundle aModule : selectedModules) {\n        model.addBundle(aModule);\n      }\n    }\n  }","id":85236,"modified_method":"private void onAddClick() {\n    BundleSelector selector = new BundleSelector(myProject);\n    selector.setUp((FrameworkInstanceDefinition)myFrameworkInstances.getSelectedItem(), getBundlesToRun());\n    selector.show(root);\n    List<SelectedBundle> selectedModules = selector.getSelectedBundles();\n    if (selectedModules != null) {\n      RunConfigurationTableModel model = getTableModel();\n      for (SelectedBundle aModule : selectedModules) {\n        model.addBundle(aModule);\n      }\n    }\n  }","commit_id":"a50107a7e87b7404f0dc4182e0497df553429cde","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n\t * Find the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above<\/em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching<\/em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationName}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)}\n\t * (supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap})\n\t * and {@link AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement, Class)} instead.\n\t */\n\t@Deprecated\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, String annotationName) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, annotationName, false, false);\n\t\treturn (attributes != null ?\n\t\t\t\tAnnotationUtils.synthesizeAnnotation(attributes, (Class<A>) attributes.annotationType(), element) : null);\n\t}","id":85237,"modified_method":"/**\n\t * Find the first annotation of the specified {@code annotationName} within\n\t * the annotation hierarchy <em>above<\/em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching<\/em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationName}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)}\n\t * (supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap})\n\t * and {@link AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)}.\n\t * @param element the annotated element\n\t * @param annotationName the fully qualified class name of the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t * @deprecated As of Spring Framework 4.2.3, use {@link #findMergedAnnotation(AnnotatedElement, Class)} instead.\n\t */\n\t@Deprecated\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, String annotationName) {\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, annotationName, false, false);\n\t\treturn AnnotationUtils.synthesizeAnnotation(attributes, (Class<A>) attributes.annotationType(), element);\n\t}","commit_id":"ee35b5ed07d863325b655ad43dcebb4ae5bd7c96","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above<\/em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching<\/em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\tAssert.notNull(annotationType, \"annotationType must not be null\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, annotationType, false, false);\n\t\treturn (attributes != null ?\n\t\t\t\tAnnotationUtils.synthesizeAnnotation(attributes, annotationType, element) : null);\n\t}","id":85238,"modified_method":"/**\n\t * Find the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above<\/em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching<\/em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t */\n\tpublic static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\tAssert.notNull(annotationType, \"annotationType must not be null\");\n\t\tAnnotationAttributes attributes = findMergedAnnotationAttributes(element, annotationType, false, false);\n\t\treturn AnnotationUtils.synthesizeAnnotation(attributes, annotationType, element);\n\t}","commit_id":"ee35b5ed07d863325b655ad43dcebb4ae5bd7c96","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above<\/em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching<\/em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, Class)}\n\t * and {@link AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t */\n\tpublic static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, annotationType);\n\t\treturn (attributes != null ? AnnotationUtils.synthesizeAnnotation(attributes, annotationType, element) : null);\n\t}","id":85239,"modified_method":"/**\n\t * Get the first annotation of the specified {@code annotationType} within\n\t * the annotation hierarchy <em>above<\/em> the supplied {@code element},\n\t * merge that annotation's attributes with <em>matching<\/em> attributes from\n\t * annotations in lower levels of the annotation hierarchy, and synthesize\n\t * the result back into an annotation of the specified {@code annotationType}.\n\t * <p>{@link AliasFor @AliasFor} semantics are fully supported, both\n\t * within a single annotation and within the annotation hierarchy.\n\t * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, Class)}\n\t * and {@link AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)}.\n\t * @param element the annotated element\n\t * @param annotationType the annotation type to find\n\t * @return the merged, synthesized {@code Annotation}, or {@code null} if not found\n\t * @since 4.2\n\t * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)\n\t * @see #findMergedAnnotation(AnnotatedElement, Class)\n\t * @see AnnotationUtils#synthesizeAnnotation(Map, Class, AnnotatedElement)\n\t */\n\tpublic static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {\n\t\tAnnotationAttributes attributes = getMergedAnnotationAttributes(element, annotationType);\n\t\treturn AnnotationUtils.synthesizeAnnotation(attributes, annotationType, element);\n\t}","commit_id":"ee35b5ed07d863325b655ad43dcebb4ae5bd7c96","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void newDownloadIndexes() {\n\t\tbanner.updateBannerInProgress();\n\t\treloadData();\n\t}","id":85240,"modified_method":"@Override\n\tpublic void newDownloadIndexes() {\n\t\tif(banner != null) {\n\t\t\tbanner.updateBannerInProgress();\n\t\t}\n\t\treloadData();\n\t}","commit_id":"83b0f37a2168a8679bbb2a14f1025b45af5ae83f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void downloadInProgress() {\n\t\tbanner.updateBannerInProgress();\n\t\tlistAdapter.notifyDataSetChanged();\n\t}","id":85241,"modified_method":"@Override\n\tpublic void downloadInProgress() {\n\t\tif(banner != null) {\n\t\t\tbanner.updateBannerInProgress();\n\t\t}\n\t\tlistAdapter.notifyDataSetChanged();\n\t}","commit_id":"83b0f37a2168a8679bbb2a14f1025b45af5ae83f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\t\tview = inflater.inflate(R.layout.maps_in_category_fragment, container, false);\n\t\tif (savedInstanceState != null) {\n\t\t\tgroupId = savedInstanceState.getString(REGION_ID_DLG_KEY);\n\t\t}\n\t\tif (groupId == null && getArguments() != null) {\n\t\t\tgroupId = getArguments().getString(REGION_ID_DLG_KEY);\n\t\t}\n\t\tif (groupId == null) {\n\t\t\tgroupId = \"\";\n\t\t}\n\t\tactivity = (DownloadActivity) getActivity();\n\n\t\ttoolbar = (Toolbar) view.findViewById(R.id.toolbar);\n\t\ttoolbar.setNavigationIcon(getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));\n\t\ttoolbar.setNavigationOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t});\n\t\tif (!openAsDialog()) {\n\t\t\ttoolbar.setVisibility(View.GONE);\n\t\t}\n\n\t\tsetHasOptionsMenu(true);\n\n\t\tbanner = new BannerAndDownloadFreeVersion(view, (DownloadActivity) getActivity());\n\n\t\tlistView = (ExpandableListView) view.findViewById(android.R.id.list);\n\t\tlistView.setOnChildClickListener(this);\n\t\tlistAdapter = new DownloadResourceGroupAdapter(activity);\n\t\tlistView.setAdapter(listAdapter);\n\n\t\treloadData();\n\t\treturn view;\n\t}","id":85242,"modified_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\t\tview = inflater.inflate(R.layout.maps_in_category_fragment, container, false);\n\t\tif (savedInstanceState != null) {\n\t\t\tgroupId = savedInstanceState.getString(REGION_ID_DLG_KEY);\n\t\t}\n\t\tif (groupId == null && getArguments() != null) {\n\t\t\tgroupId = getArguments().getString(REGION_ID_DLG_KEY);\n\t\t}\n\t\tif (groupId == null) {\n\t\t\tgroupId = \"\";\n\t\t}\n\t\tactivity = (DownloadActivity) getActivity();\n\n\t\ttoolbar = (Toolbar) view.findViewById(R.id.toolbar);\n\t\ttoolbar.setNavigationIcon(getMyApplication().getIconsCache().getIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha));\n\t\ttoolbar.setNavigationOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdismiss();\n\t\t\t}\n\t\t});\n\t\tif (!openAsDialog()) {\n\t\t\ttoolbar.setVisibility(View.GONE);\n\t\t}\n\n\t\tsetHasOptionsMenu(true);\n\n\t\tif(openAsDialog()) {\n\t\t\tbanner = new BannerAndDownloadFreeVersion(view, (DownloadActivity) getActivity());\n\t\t} else {\n\t\t\tbanner = null;\n\t\t\tview.findViewById(R.id.freeVersionBanner).setVisibility(View.GONE);\n\t\t}\n\n\t\tlistView = (ExpandableListView) view.findViewById(android.R.id.list);\n\t\tlistView.setOnChildClickListener(this);\n\t\tlistAdapter = new DownloadResourceGroupAdapter(activity);\n\t\tlistView.setAdapter(listAdapter);\n\n\t\treloadData();\n\t\treturn view;\n\t}","commit_id":"83b0f37a2168a8679bbb2a14f1025b45af5ae83f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void downloadHasFinished() {\n\t\tbanner.updateBannerInProgress();\n\t\tlistAdapter.notifyDataSetChanged();\n\t}","id":85243,"modified_method":"@Override\n\tpublic void downloadHasFinished() {\n\t\tif(banner != null) {\n\t\t\tbanner.updateBannerInProgress();\n\t\t}\n\t\tlistAdapter.notifyDataSetChanged();\n\t}","commit_id":"83b0f37a2168a8679bbb2a14f1025b45af5ae83f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected ScriptHelper newScript(Map<?,?> flags, String phase) {\n        ScriptHelper s = new ScriptHelper(this, phase+\" \"+elvis(entity,this));\n        if (!truth(flags.get(\"nonStandardLayout\"))) {\n            if (INSTALLING.equals(phase)) {\n                // mutexId should be global because otherwise package managers will contend with each other \n                s.useMutex(getLocation(), \"installing\", \"installing \"+elvis(entity,this));\n                s.header.append(\n                        \"export INSTALL_DIR=\\\"\"+getInstallDir()+\"\\\"\",\n                        \"mkdir -p $INSTALL_DIR\",\n                        \"cd $INSTALL_DIR\",\n                        \"test -f BROOKLYN && exit 0\"\n                        );\n                s.footer.append(\n                        \"date > $INSTALL_DIR/BROOKLYN\"\n                        );\n            }\n            if (ImmutableSet.of(CUSTOMIZING, LAUNCHING, CHECK_RUNNING, STOPPING, KILLING, RESTARTING).contains(phase)) {\n                s.header.append(\n                        \"export RUN_DIR=\\\"\"+getRunDir()+\"\\\"\",\n                        \"mkdir -p $RUN_DIR\",\n                        \"cd $RUN_DIR\"\n                        );\n            }\n        }\n\n        if (ImmutableSet.of(LAUNCHING, STOPPING, KILLING, RESTARTING).contains(phase)) {\n            s.failIfBodyEmpty();\n        }\n        if (ImmutableSet.of(INSTALLING, LAUNCHING).contains(phase)) {\n            s.updateTaskAndFailOnNonZeroResultCode();\n        }\n        if (phase.equalsIgnoreCase(CHECK_RUNNING)) {\n            s.setTransient();\n        }\n\n        if (truth(flags.get(USE_PID_FILE))) {\n            String pidFile = (flags.get(USE_PID_FILE) instanceof CharSequence ? flags.get(USE_PID_FILE) : getRunDir()+\"/\"+PID_FILENAME).toString();\n            String processOwner = (flags.containsKey(PROCESS_OWNER) ? flags.get(PROCESS_OWNER) : getMachine().getUser()).toString();\n            if (LAUNCHING.equals(phase)) {\n                s.footer.prepend(\"echo $! > \"+pidFile);\n            } else if (CHECK_RUNNING.equals(phase)) {\n                s.body.append(\n                        \"test -f \"+pidFile+\" || exit 1\", //no pid, not running\n\n                        //old method, for supplied service, or entity.id\n                        //\"ps aux | grep ${service} | grep \\$(cat ${pidFile}) > /dev/null\"\n                        //new way, preferred?\n                        \"ps -p `cat \"+pidFile+\"`\"\n                        );\n                s.requireResultCode(Predicates.or(Predicates.equalTo(0), Predicates.equalTo(1)));\n                // 1 is not running\n            } else if (STOPPING.equals(phase)) {\n                s.body.append(\n                        \"export PID=`cat \"+pidFile+\"`\",\n                        \"[[ -n \\\"$PID\\\" ]] || exit 0\",\n                        BashCommands.sudoAsUser(processOwner, \"kill $PID\"),\n                        BashCommands.sudoAsUser(processOwner, \"kill -9 $PID\"),\n                        \"rm -f \"+pidFile\n                        );\n            } else if (KILLING.equals(phase)) {\n                s.body.append(\n                        \"export PID=`cat \"+pidFile+\"`\",\n                        \"[[ -n \\\"$PID\\\" ]] || exit 0\",\n                        BashCommands.sudoAsUser(processOwner, \"kill -9 $PID\"),\n                        \"rm -f \"+pidFile\n                        );\n            } else if (RESTARTING.equals(phase)) {\n                s.footer.prepend(\n                        \"test -f \"+pidFile+\" || exit 1\", //no pid, not running\n                        \"ps -p `cat \"+pidFile+\"` || exit 1\" //no process; can't restart,\n                        );\n                // 1 is not running\n            } else {\n                log.warn(USE_PID_FILE+\": script option not valid for \"+s.summary);\n            }\n        }\n\n        return s;\n    }","id":85244,"modified_method":"protected ScriptHelper newScript(Map<?,?> flags, String phase) {\n        ScriptHelper s = new ScriptHelper(this, phase+\" \"+elvis(entity,this));\n        if (!truth(flags.get(\"nonStandardLayout\"))) {\n            if (INSTALLING.equals(phase)) {\n                // mutexId should be global because otherwise package managers will contend with each other \n                s.useMutex(getLocation(), \"installing\", \"installing \"+elvis(entity,this));\n                s.header.append(\n                        \"export INSTALL_DIR=\\\"\"+getInstallDir()+\"\\\"\",\n                        \"mkdir -p $INSTALL_DIR\",\n                        \"cd $INSTALL_DIR\",\n                        \"test -f BROOKLYN && exit 0\"\n                        );\n                s.footer.append(\n                        \"date > $INSTALL_DIR/BROOKLYN\"\n                        );\n            }\n            if (ImmutableSet.of(CUSTOMIZING, LAUNCHING, CHECK_RUNNING, STOPPING, KILLING, RESTARTING).contains(phase)) {\n                s.header.append(\n                        \"export RUN_DIR=\\\"\"+getRunDir()+\"\\\"\",\n                        \"mkdir -p $RUN_DIR\",\n                        \"cd $RUN_DIR\"\n                        );\n            }\n        }\n\n        if (ImmutableSet.of(LAUNCHING, STOPPING, KILLING, RESTARTING).contains(phase)) {\n            s.failIfBodyEmpty();\n        }\n        if (ImmutableSet.of(INSTALLING, LAUNCHING).contains(phase)) {\n            s.updateTaskAndFailOnNonZeroResultCode();\n        }\n        if (phase.equalsIgnoreCase(CHECK_RUNNING)) {\n            s.setTransient();\n        }\n\n        if (truth(flags.get(USE_PID_FILE))) {\n            String pidFile = (flags.get(USE_PID_FILE) instanceof CharSequence ? flags.get(USE_PID_FILE) : getRunDir()+\"/\"+PID_FILENAME).toString();\n            String processOwner = (String) flags.get(PROCESS_OWNER);\n            if (LAUNCHING.equals(phase)) {\n                s.footer.prepend(\"echo $! > \"+pidFile);\n            } else if (CHECK_RUNNING.equals(phase)) {\n                s.body.append(\n                        \"test -f \"+pidFile+\" || exit 1\", //no pid, not running\n\n                        //old method, for supplied service, or entity.id\n                        //\"ps aux | grep ${service} | grep \\$(cat ${pidFile}) > /dev/null\"\n                        //new way, preferred?\n                        \"ps -p `cat \"+pidFile+\"`\"\n                        );\n                s.requireResultCode(Predicates.or(Predicates.equalTo(0), Predicates.equalTo(1)));\n                // 1 is not running\n            } else if (STOPPING.equals(phase)) {\n                s.body.append(\n                        \"export PID=`cat \"+pidFile+\"`\",\n                        \"[[ -n \\\"$PID\\\" ]] || exit 0\",\n                        processOwner != null ? BashCommands.sudoAsUser(processOwner, \"kill $PID\") : \"kill $PID\",\n                        processOwner != null ? BashCommands.sudoAsUser(processOwner, \"kill -9 $PID\") : \"kill -9 $PID\",\n                        \"rm -f \"+pidFile\n                        );\n            } else if (KILLING.equals(phase)) {\n                s.body.append(\n                        \"export PID=`cat \"+pidFile+\"`\",\n                        \"[[ -n \\\"$PID\\\" ]] || exit 0\",\n                        processOwner != null ? BashCommands.sudoAsUser(processOwner, \"kill -9 $PID\") : \"kill -9 $PID\",\n                        \"rm -f \"+pidFile\n                        );\n            } else if (RESTARTING.equals(phase)) {\n                s.footer.prepend(\n                        \"test -f \"+pidFile+\" || exit 1\", //no pid, not running\n                        \"ps -p `cat \"+pidFile+\"` || exit 1\" //no process; can't restart,\n                        );\n                // 1 is not running\n            } else {\n                log.warn(USE_PID_FILE+\": script option not valid for \"+s.summary);\n            }\n        }\n\n        return s;\n    }","commit_id":"09527119ba89d8b31a7ef0fe59da4d505d1af610","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public Animator(final String name,\n                  final int totalFrames,\n                  final int cycleLength,\n                  boolean repeatable,\n                  final int interCycleGap,\n                  final int maxRepeatCount, boolean forward) {\n    myTotalFrames = totalFrames;\n    myCycleLength = cycleLength;\n    myRepeatable = repeatable;\n    myForward = forward;\n    myCurrentFrame = forward ? 0 : totalFrames;\n\n    Application application = ApplicationManager.getApplication();\n    myTimer = application == null || application.isUnitTestMode() ? null :\n              new Timer(name, myCycleLength / myTotalFrames) {\n      protected void onTimer() throws InterruptedException {\n        boolean repaint = true;\n        if (!isAnimated()) {\n          if (myLastAnimated) {\n            myCurrentFrame = myForward ? 0 : myTotalFrames;\n            myQueuedFrames = 0;\n            myLastAnimated = false;\n          }\n          else {\n            repaint = false;\n          }\n        }\n        else {\n          myLastAnimated = true;\n\n          if (myQueuedFrames > myTotalFrames) return;\n\n          boolean toNextFrame = myForward ? myCurrentFrame + 1 < myTotalFrames : myCurrentFrame - 1 >= 0;\n\n          if (toNextFrame && myForward) {\n            myCurrentFrame++;\n          } else if (toNextFrame && !myForward) {\n            myCurrentFrame--;\n          } else {\n            if (myRepeatable) {\n              if (maxRepeatCount == -1 || myRepeatCount < maxRepeatCount) {\n                myRepeatCount++;\n                myCurrentFrame = 0;\n                if (interCycleGap > 0) {\n                  Thread.sleep(interCycleGap - getSpan());\n                }\n              }\n              else {\n                repaint = false;\n                suspend();\n                myRepeatCount = 0;\n                cycleEnd();\n              }\n            }\n            else {\n              repaint = false;\n              suspend();\n              cycleEnd();\n            }\n          }\n        }\n\n        if (repaint) {\n          myQueuedFrames++;\n          // paint to EDT\n          //noinspection SSBasedInspection\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              myQueuedFrames--;\n              paintNow(myCurrentFrame, (float)myTotalFrames, (float)myCycleLength);\n            }\n          });\n        }\n      }\n    };\n  }","id":85245,"modified_method":"public Animator(final String name,\n                  final int totalFrames,\n                  final int cycleLength,\n                  boolean repeatable,\n                  final int interCycleGap,\n                  final int maxRepeatCount, boolean forward) {\n    myTotalFrames = totalFrames;\n    myCycleLength = cycleLength;\n    myRepeatable = repeatable;\n    myForward = forward;\n    myCurrentFrame = forward ? 0 : totalFrames;\n\n    Application application = ApplicationManager.getApplication();\n    myTimer = application == null || application.isUnitTestMode() ? null :\n              new Timer(name, myCycleLength / myTotalFrames) {\n      protected void onTimer() throws InterruptedException {\n        boolean repaint = true;\n        if (!isAnimated()) {\n          if (myLastAnimated) {\n            myCurrentFrame = myForward ? 0 : myTotalFrames;\n            myQueuedFrames = 0;\n            myLastAnimated = false;\n          }\n          else {\n            repaint = false;\n          }\n        }\n        else {\n          myLastAnimated = true;\n\n          if (myQueuedFrames > myTotalFrames) return;\n\n          boolean toNextFrame = myForward ? myCurrentFrame + 1 < myTotalFrames : myCurrentFrame - 1 >= 0;\n\n          if (toNextFrame && myForward) {\n            myCurrentFrame++;\n          } else if (toNextFrame && !myForward) {\n            myCurrentFrame--;\n          } else {\n            if (myRepeatable) {\n              if (maxRepeatCount == -1 || myRepeatCount < maxRepeatCount) {\n                myRepeatCount++;\n                myCurrentFrame = 0;\n                if (interCycleGap > 0) {\n                  Thread.sleep(interCycleGap - getSpan());\n                }\n              }\n              else {\n                repaint = false;\n                suspend();\n                myRepeatCount = 0;\n                cycleEnd();\n              }\n            }\n            else {\n              repaint = false;\n              suspend();\n              cycleEnd();\n            }\n          }\n        }\n\n        if (repaint) {\n          myQueuedFrames++;\n          // paint to EDT\n          //noinspection SSBasedInspection\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              myQueuedFrames--;\n              paintNow(myCurrentFrame, (float)myTotalFrames, (float)myCycleLength);\n            }\n          });\n        }\n      }\n    };\n\n    if (myTimer == null) {\n      try {\n        cycleEnd();\n      }\n      catch (InterruptedException e) {\n        return;\n      }\n    }\n  }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Dimension getPreferredSize() {\n    if (myComp != null) {\n      return myComp.getPreferredSize();\n    } else {\n      if (myDefaultPrefSize == null) {\n        final EmptyBorder border = new EmptyBorder(getNormalInset(), getNormalInset(), getNormalInset(), getNormalInset());\n        final MyComponent c = new MyComponent(myContent, this, border);\n        myDefaultPrefSize = c.getPreferredSize();\n      }\n      return myDefaultPrefSize;\n    }\n  }","id":85246,"modified_method":"public Dimension getPreferredSize() {\n    if (myComp != null) {\n      return myComp.getPreferredSize();\n    } else {\n      if (myDefaultPrefSize == null) {\n        final EmptyBorder border = getPointlessBorder();\n        final MyComponent c = new MyComponent(myContent, this, border);\n        myDefaultPrefSize = c.getPreferredSize();\n      }\n      return myDefaultPrefSize;\n    }\n  }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String[] args) {\n    IconLoader.activate();\n\n    final JFrame frame = new JFrame();\n    frame.getContentPane().setLayout(new BorderLayout());\n    final JPanel content = new JPanel(new BorderLayout());\n    frame.getContentPane().add(content, BorderLayout.CENTER);\n\n\n    final JTree tree = new Tree();\n    content.add(tree);\n\n\n    final Ref<BalloonImpl> balloon = new Ref<BalloonImpl>();\n\n    tree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mousePressed(final MouseEvent e) {\n        if (balloon.get() != null && balloon.get().isVisible()) {\n          balloon.get().dispose();\n        }\n        else {\n          final JEditorPane pane = new JEditorPane();\n          pane.setBorder(new EmptyBorder(6, 6, 6, 6));\n          pane.setEditorKit(new HTMLEditorKit());\n          pane.setText(UIUtil.toHtml(\n            \"<html><body><center>Really cool balloon<br>Really fucking <a href=\\\\\\\"http://jetbrains.com\\\\\\\">big<\/a><\/center><\/body><\/html\"));\n          final Dimension size = new JLabel(pane.getText()).getPreferredSize();\n          pane.setEditable(false);\n          pane.setOpaque(false);\n          pane.setBorder(null);\n          pane.setPreferredSize(size);\n\n          balloon.set(new BalloonImpl(pane, Color.black, MessageType.ERROR.getPopupBackground(), true, true, true, true, 2000, true, null, false));\n          balloon.get().setShowPointer(false);\n\n          if (e.isControlDown()) {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.ABOVE);\n          }\n          else if (e.isAltDown()) {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.BELOW);\n          }\n          else if (e.isMetaDown()) {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.AT_LEFT);\n          }\n          else {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.AT_RIGHT);\n          }\n        }\n      }\n    });\n\n    frame.setBounds(300, 300, 300, 300);\n    frame.show();\n  }","id":85247,"modified_method":"public static void main(String[] args) {\n    IconLoader.activate();\n\n    final JFrame frame = new JFrame();\n    frame.getContentPane().setLayout(new BorderLayout());\n    final JPanel content = new JPanel(new BorderLayout());\n    frame.getContentPane().add(content, BorderLayout.CENTER);\n\n\n    final JTree tree = new Tree();\n    content.add(tree);\n\n\n    final Ref<BalloonImpl> balloon = new Ref<BalloonImpl>();\n\n    tree.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mousePressed(final MouseEvent e) {\n        if (balloon.get() != null && balloon.get().isVisible()) {\n          balloon.get().dispose();\n        }\n        else {\n          JLabel pane1 = new JLabel(\"Hello, world!\");\n          JLabel pane2 = new JLabel(\"Hello, again\");\n          JPanel pane = new JPanel(new BorderLayout());\n          pane.add(pane1, BorderLayout.CENTER);\n          pane.add(pane2, BorderLayout.SOUTH);\n\n          pane.setBorder(new LineBorder(Color.blue));\n\n          balloon.set(new BalloonImpl(pane, Color.black, MessageType.ERROR.getPopupBackground(), true, true, true, true, 0, true, null, false));\n          balloon.get().setShowPointer(true);\n\n          if (e.isShiftDown()) {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.ABOVE);\n          }\n          else if (e.isAltDown()) {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.BELOW);\n          }\n          else if (e.isMetaDown()) {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.AT_LEFT);\n          }\n          else {\n            balloon.get().show(new RelativePoint(e), BalloonImpl.AT_RIGHT);\n          }\n        }\n      }\n    });\n\n    frame.setBounds(300, 300, 300, 300);\n    frame.show();\n  }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void show(PositionTracker<Balloon> tracker, Position position) {\n    if (isVisible()) return;\n\n    assert !myDisposed : \"Balloon is already disposed\";\n    assert tracker.getComponent().isShowing() : \"Target component is not showing: \" + tracker;\n\n    myTracker = tracker;\n    myTracker.init(this);\n\n    final Window window = SwingUtilities.getWindowAncestor(tracker.getComponent());\n\n    JRootPane root = null;\n    if (window instanceof JFrame) {\n      root = ((JFrame)window).getRootPane();\n    }\n    else if (window instanceof JDialog) {\n      root = ((JDialog)window).getRootPane();\n    }\n    else {\n      assert false : window;\n    }\n\n    myVisible = true;\n\n    myLayeredPane = root.getLayeredPane();\n    myPosition = position;\n\n    myLayeredPane.addComponentListener(myComponentListener);\n\n    final EmptyBorder border = myShowPointer\n                               ? myPosition.createBorder(this)\n                               : new EmptyBorder(getNormalInset(), getNormalInset(), getNormalInset(), getNormalInset());\n    myComp = new MyComponent(myContent, this, border);\n\n    myTargetPoint = tracker.recalculateLocation(this).getPoint(myLayeredPane);\n\n    myComp.clear();\n    myComp.myAlpha = 0f;\n\n\n    for (JBPopupListener each : myListeners) {\n      each.beforeShown(new LightweightWindowEvent(this));\n    }\n\n\n    myLayeredPane.add(myComp, JLayeredPane.POPUP_LAYER);\n\n\n    myPosition.updateLocation(this);\n\n\n    runAnimation(true, myLayeredPane);\n\n    myLayeredPane.revalidate();\n    myLayeredPane.repaint();\n\n\n    Toolkit.getDefaultToolkit().addAWTEventListener(myAwtActivityListener, MouseEvent.MOUSE_EVENT_MASK |\n                                                                           MouseEvent.MOUSE_MOTION_EVENT_MASK |\n                                                                           KeyEvent.KEY_EVENT_MASK);\n  }","id":85248,"modified_method":"private void show(PositionTracker<Balloon> tracker, Position position) {\n    if (isVisible()) return;\n\n    assert !myDisposed : \"Balloon is already disposed\";\n    assert tracker.getComponent().isShowing() : \"Target component is not showing: \" + tracker;\n\n    myTracker = tracker;\n    myTracker.init(this);\n\n    final Window window = SwingUtilities.getWindowAncestor(tracker.getComponent());\n\n    JRootPane root = null;\n    if (window instanceof JFrame) {\n      root = ((JFrame)window).getRootPane();\n    }\n    else if (window instanceof JDialog) {\n      root = ((JDialog)window).getRootPane();\n    }\n    else {\n      assert false : window;\n    }\n\n    myVisible = true;\n\n    myLayeredPane = root.getLayeredPane();\n    myPosition = position;\n\n    myLayeredPane.addComponentListener(myComponentListener);\n\n    createComponent();\n\n    myComp.validate();\n    Rectangle compBounds = myComp.getBounds();\n\n    Rectangle contentRec = SwingUtilities.convertRectangle(myContent.getParent(), myContent.getBounds(), myLayeredPane);\n\n    if (myShowPointer && !myPosition.isOkToHavePointer(myTargetPoint, contentRec, this)) {\n      myShowPointer = false;\n      myComp.removeAll();\n      myLayeredPane.remove(myComp);\n\n      myForcedBounds = myPosition.getPointlessContentRec(compBounds, this);\n      createComponent();\n    }\n\n    for (JBPopupListener each : myListeners) {\n      each.beforeShown(new LightweightWindowEvent(this));\n    }\n\n    runAnimation(true, myLayeredPane);\n\n    myLayeredPane.revalidate();\n    myLayeredPane.repaint();\n\n\n    Toolkit.getDefaultToolkit().addAWTEventListener(myAwtActivityListener, MouseEvent.MOUSE_EVENT_MASK |\n                                                                           MouseEvent.MOUSE_MOTION_EVENT_MASK |\n                                                                           KeyEvent.KEY_EVENT_MASK);\n  }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getNormalInset(), balloon.getNormalInset(), balloon.getPointerLength(), balloon.getNormalInset());\n    }","id":85249,"modified_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getNormalInset(), balloon.getNormalInset(), balloon.getPointerLength() + balloon.getNormalInset(), balloon.getNormalInset());\n    }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getPointerLength(), balloon.getNormalInset(), balloon.getNormalInset(), balloon.getNormalInset());\n    }","id":85250,"modified_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getPointerLength() + balloon.getNormalInset(), balloon.getNormalInset(), balloon.getNormalInset(), balloon.getNormalInset());\n    }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getNormalInset(), balloon.getPointerLength(), balloon.getNormalInset(), balloon.getNormalInset());\n    }","id":85251,"modified_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getNormalInset(), balloon.getPointerLength() + balloon.getNormalInset(), balloon.getNormalInset(), balloon.getNormalInset());\n    }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getNormalInset(), balloon.getNormalInset(), balloon.getNormalInset(), balloon.getPointerLength());\n    }","id":85252,"modified_method":"EmptyBorder createBorder(final BalloonImpl balloon) {\n      return new EmptyBorder(balloon.getNormalInset(), balloon.getNormalInset(), balloon.getNormalInset(), balloon.getPointerLength() + balloon.getNormalInset());\n    }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doLayout() {\n      Insets insets = getInsets();\n      if (insets == null) {\n        insets = new Insets(0, 0, 0, 0);\n      }\n\n      myContent.setBounds(insets.left, insets.right, getWidth() - insets.left - insets.right, getHeight() - insets.top - insets.bottom);\n\n      if (myBalloon.myEnableCloseButton) {\n        final Icon icon = myBalloon.getCloseButton();\n        final Rectangle bounds = getBounds();\n        myCloseRec.setBounds(bounds.width - icon.getIconWidth(), 0, icon.getIconWidth(), icon.getIconHeight());\n      }\n    }","id":85253,"modified_method":"@Override\n    public void doLayout() {\n      Insets insets = getInsets();\n      if (insets == null) {\n        insets = new Insets(0, 0, 0, 0);\n      }\n\n      myContent.setBounds(insets.left, insets.top, getWidth() - insets.left - insets.right, getHeight() - insets.top - insets.bottom);\n\n      if (myBalloon.myEnableCloseButton) {\n        final Icon icon = myBalloon.getCloseButton();\n        final Rectangle bounds = getBounds();\n        myCloseRec.setBounds(bounds.width - icon.getIconWidth(), 0, icon.getIconWidth(), icon.getIconHeight());\n      }\n    }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void paintComponent(final Graphics g) {\n      super.paintComponent(g);\n      final Point pointTarget = SwingUtilities.convertPoint(myLayeredPane, myBalloon.myTargetPoint, this);\n\n      if (myImage == null && myAlpha != -1) {\n        myImage = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);\n        myBalloon.myPosition.paintComponent(myBalloon, myContent.getBounds(), (Graphics2D)myImage.getGraphics(), pointTarget);\n      }\n\n      if (myImage != null && myAlpha != -1) {\n        final Graphics2D g2d = (Graphics2D)g;\n        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, myAlpha));\n\n        g2d.drawImage(myImage, 0, 0, null);\n      }\n      else {\n        myBalloon.myPosition.paintComponent(myBalloon, myContent.getBounds(), (Graphics2D)g, pointTarget);\n      }\n    }","id":85254,"modified_method":"@Override\n    protected void paintComponent(final Graphics g) {\n      super.paintComponent(g);\n\n      final Graphics2D g2d = (Graphics2D)g;\n\n      final Point pointTarget = SwingUtilities.convertPoint(myLayeredPane, myBalloon.myTargetPoint, this);\n\n      Rectangle shapeBounds = myContent.getBounds();\n\n      if (myImage == null && myAlpha != -1) {\n        myImage = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);\n        myBalloon.myPosition.paintComponent(myBalloon, shapeBounds, (Graphics2D)myImage.getGraphics(), pointTarget);\n      }\n\n      if (myImage != null && myAlpha != -1) {\n        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, myAlpha));\n\n        g2d.drawImage(myImage, 0, 0, null);\n      }\n      else {\n        myBalloon.myPosition.paintComponent(myBalloon, shapeBounds, (Graphics2D)g, pointTarget);\n      }\n    }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private MyComponent(JComponent content, BalloonImpl balloon, EmptyBorder shapeBorder) {\n      setOpaque(false);\n      setLayout(null);\n      myBalloon = balloon;\n\n      myContent = new Wrapper(content);\n      myContent.setBorder(shapeBorder);\n      myContent.setOpaque(false);\n\n      setBorder(new EmptyBorder(balloon.getCloseButton().getIconHeight() / 3, 0, 0, balloon.getCloseButton().getIconWidth() / 3));\n\n      add(myContent);\n\n      myButton = new BaseButtonBehavior(myCloseRec, TimedDeadzone.NULL) {\n        protected void execute(MouseEvent e) {\n          //noinspection SSBasedInspection\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              myBalloon.hide();\n            }\n          });\n        }\n      };\n\n      add(myCloseRec);\n\n      setComponentZOrder(myContent, 1);\n      setComponentZOrder(myCloseRec, 0);\n    }","id":85255,"modified_method":"private MyComponent(JComponent content, BalloonImpl balloon, EmptyBorder shapeBorder) {\n      setOpaque(false);\n      setLayout(null);\n      myBalloon = balloon;\n\n      myContent = new Wrapper(content);\n      myContent.setBorder(shapeBorder);\n      myContent.setOpaque(false);\n\n      add(myContent);\n\n      myButton = new BaseButtonBehavior(myCloseRec, TimedDeadzone.NULL) {\n        protected void execute(MouseEvent e) {\n          //noinspection SSBasedInspection\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              myBalloon.hide();\n            }\n          });\n        }\n      };\n\n      add(myCloseRec);\n\n      setComponentZOrder(myContent, 1);\n      setComponentZOrder(myCloseRec, 0);\n    }","commit_id":"b9bd025c395c1fdc433443f077ecacf4efc399eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n\t * Thread method: this thread will handle reading datagrams and \r\n\t * the periodic re-expressing of standing interests\r\n\t */\r\n\tpublic void run() {\r\n\t\tif (! _run) {\r\n\t\t\tLog.warning(\"CCNSimpleNetworkManager run() called after shutdown\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Allocate datagram buffer: want to wrap array to ensure backed by\r\n\t\t// array to permit decoding\r\n\t\tbyte[] buffer = new byte[MAX_PAYLOAD];\r\n\t\tByteBuffer datagram = ByteBuffer.wrap(buffer);\r\n\t\tWirePacket packet = new WirePacket();\r\n\t\tLog.info(\"CCNSimpleNetworkManager processing thread started\");\r\n\t\twhile (_run) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\t//--------------------------------- Read and decode\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (_selector.select(SOCKET_TIMEOUT) != 0) {\r\n\t\t\t\t\t\t// Note: we're selecting on only one channel to get\r\n\t\t\t\t\t\t// the ability to use wakeup, so there is no need to \r\n\t\t\t\t\t\t// inspect the selected-key set\r\n\t\t\t\t\t\tdatagram.clear(); // make ready for new read\r\n\t\t\t\t\t\tsynchronized (_channel) {\r\n\t\t\t\t\t\t\t_channel.read(datagram); // queue readers and writers\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tLog.finest(\"Read datagram (\" + datagram.position() + \" bytes)\");\r\n\t\t\t\t\t\t_selector.selectedKeys().clear();\r\n\t\t\t\t\t\tif (null != _error) {\r\n\t\t\t\t\t\t\tLog.info(\"Receive error cleared\");\r\n\t\t\t\t\t\t\t_error = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdatagram.flip(); // make ready to decode\r\n\t\t\t\t\t\tif (null != _tapStreamIn) {\r\n\t\t\t\t\t\t\tbyte [] b = new byte[datagram.limit()];\r\n\t\t\t\t\t\t\tdatagram.get(b);\r\n\t\t\t\t\t\t\t_tapStreamIn.write(b);\r\n\t\t\t\t\t\t\tdatagram.rewind();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tpacket.decode(datagram);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// This was a timeout or wakeup, no data\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tif (!_run) {\r\n\t\t\t\t\t\t\t// exit immediately if wakeup for shutdown\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!_channel.isConnected()) {\r\n\t\t\t\t\t\t\t_channel.connect(new InetSocketAddress(_host, _port));\r\n\t\t\t\t\t\t\tif (_channel.isConnected()) {\r\n\t\t\t\t\t\t\t\t_selector = Selector.open();\r\n\t\t\t\t\t\t\t\t_channel.register(_selector, SelectionKey.OP_READ);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException io) {\r\n\t\t\t\t\t// We see IOException on receive every time if agent is gone\r\n\t\t\t\t\t// so track it to log only start and end of outages\r\n\t\t\t\t\tif (null == _error) {\r\n\t\t\t\t\t\tLog.info(\"Unable to receive from agent: is it still running?\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_error = io;\r\n\t\t\t\t\tpacket.clear();\r\n\t\t\t\t}\r\n                if (!_run) {\r\n                    // exit immediately if wakeup for shutdown\r\n                    break;\r\n                }\r\n                \r\n                // If we got a data packet, hand it back to all the interested\r\n\t\t\t\t// parties (registered interests and getters).\r\n\t\t\t\t//--------------------------------- Process data from net (if any) \r\n\t\t\t\tfor (ContentObject co : packet.data()) {\r\n\t\t\t\t\tLog.fine(\"Data from net: {0}\", co.name());\r\n\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\r\n\t\t\t\t\t\r\n\t\t\t\t\tdeliverData(co);\r\n\t\t\t\t\t// External data never goes back to network, never held onto here\r\n\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//--------------------------------- Process interests from net (if any)\r\n\t\t\t\tfor (Interest interest : packet.interests()) {\r\n\t\t\t\t\tLog.fine(\"Interest from net: {0}\", interest);\r\n\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(this, interest, null, null);\r\n\t\t\t\t\tdeliverInterest(oInterest);\r\n\t\t\t\t\t// External interests never go back to network\r\n\t\t\t\t} // for interests\r\n\t\t\t\t\r\n\t\t\t} catch (Exception ex) {\r\n\t\t\t\tLog.severe(\"Processing thread failure (UNKNOWN): \" + ex.getMessage());\r\n                                Log.warningStackTrace(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_threadpool.shutdown();\r\n\t\tLog.info(\"Shutdown complete\");\r\n\t}","id":85256,"modified_method":"/**\r\n\t * Thread method: this thread will handle reading datagrams and \r\n\t * the periodic re-expressing of standing interests\r\n\t */\r\n\tpublic void run() {\r\n\t\tif (! _run) {\r\n\t\t\tLog.warning(\"CCNNetworkManager run() called after shutdown\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Allocate datagram buffer: want to wrap array to ensure backed by\r\n\t\t// array to permit decoding\r\n\t\tbyte[] buffer = new byte[MAX_PAYLOAD];\r\n\t\tByteBuffer datagram = ByteBuffer.wrap(buffer);\r\n\t\tWirePacket packet = new WirePacket();\r\n\t\tLog.info(\"CCNNetworkManager processing thread started\");\r\n\t\twhile (_run) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\t//--------------------------------- Read and decode\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (_selector.select(SOCKET_TIMEOUT) != 0) {\r\n\t\t\t\t\t\t// Note: we're selecting on only one channel to get\r\n\t\t\t\t\t\t// the ability to use wakeup, so there is no need to \r\n\t\t\t\t\t\t// inspect the selected-key set\r\n\t\t\t\t\t\tdatagram.clear(); // make ready for new read\r\n\t\t\t\t\t\tsynchronized (_channel) {\r\n\t\t\t\t\t\t\t_channel.read(datagram); // queue readers and writers\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tLog.finest(\"Read datagram (\" + datagram.position() + \" bytes)\");\r\n\t\t\t\t\t\t_selector.selectedKeys().clear();\r\n\t\t\t\t\t\tif (null != _error) {\r\n\t\t\t\t\t\t\tLog.info(\"Receive error cleared\");\r\n\t\t\t\t\t\t\t_error = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdatagram.flip(); // make ready to decode\r\n\t\t\t\t\t\tif (null != _tapStreamIn) {\r\n\t\t\t\t\t\t\tbyte [] b = new byte[datagram.limit()];\r\n\t\t\t\t\t\t\tdatagram.get(b);\r\n\t\t\t\t\t\t\t_tapStreamIn.write(b);\r\n\t\t\t\t\t\t\tdatagram.rewind();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tpacket.decode(datagram);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// This was a timeout or wakeup, no data\r\n\t\t\t\t\t\tpacket.clear();\r\n\t\t\t\t\t\tif (!_run) {\r\n\t\t\t\t\t\t\t// exit immediately if wakeup for shutdown\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!_channel.isConnected()) {\r\n\t\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t\t * This is the case where we noticed that the connect to ccnd went away.  We\r\n\t\t\t\t\t\t\t * try to reconnect, and if successful, we need to re-register our collection\r\n\t\t\t\t\t\t\t * of prefix registrations.\r\n\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t_channel.connect(new InetSocketAddress(_host, _port));\r\n\t\t\t\t\t\t\tif (_channel.isConnected()) {\r\n\t\t\t\t\t\t\t\t_selector = Selector.open();\r\n\t\t\t\t\t\t\t\t_channel.register(_selector, SelectionKey.OP_READ);\r\n\t\t\t\t\t\t\t\t_localPort = _channel.socket().getLocalPort();\r\n\t\t\t\t\t\t\t\t_faceID = null;\r\n\t\t\t\t\t\t\t\tLog.info(\"Reconnecting to CCN agent at \" + _host + \":\" + _port + \"on local port\" + _localPort);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException io) {\r\n\t\t\t\t\t// We see IOException on receive every time if agent is gone\r\n\t\t\t\t\t// so track it to log only start and end of outages\r\n\t\t\t\t\tif (null == _error) {\r\n\t\t\t\t\t\tLog.info(\"Unable to receive from agent: is it still running?\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_error = io;\r\n\t\t\t\t\tpacket.clear();\r\n\t\t\t\t}\r\n                if (!_run) {\r\n                    // exit immediately if wakeup for shutdown\r\n                    break;\r\n                }\r\n                \r\n                // If we got a data packet, hand it back to all the interested\r\n\t\t\t\t// parties (registered interests and getters).\r\n\t\t\t\t//--------------------------------- Process data from net (if any) \r\n\t\t\t\tfor (ContentObject co : packet.data()) {\r\n\t\t\t\t\tLog.fine(\"Data from net: {0}\", co.name());\r\n\t\t\t\t\t//\tSystemConfiguration.logObject(\"Data from net:\", co);\r\n\t\t\t\t\t\r\n\t\t\t\t\tdeliverData(co);\r\n\t\t\t\t\t// External data never goes back to network, never held onto here\r\n\t\t\t\t\t// External data never has a thread waiting, so no need to release sema\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//--------------------------------- Process interests from net (if any)\r\n\t\t\t\tfor (Interest interest : packet.interests()) {\r\n\t\t\t\t\tLog.fine(\"Interest from net: {0}\", interest);\r\n\t\t\t\t\tInterestRegistration oInterest = new InterestRegistration(this, interest, null, null);\r\n\t\t\t\t\tdeliverInterest(oInterest);\r\n\t\t\t\t\t// External interests never go back to network\r\n\t\t\t\t} // for interests\r\n\t\t\t\t\r\n\t\t\t} catch (Exception ex) {\r\n\t\t\t\tLog.severe(\"Processing thread failure (UNKNOWN): \" + ex.getMessage());\r\n                                Log.warningStackTrace(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_threadpool.shutdown();\r\n\t\tLog.info(\"Shutdown complete\");\r\n\t}","commit_id":"5924d7834f769fd61f8af13f27ea459d29416744","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public CCNDIdGetter(CCNNetworkManager mgr, KeyManager keyManager) { \r\n\t\t\t_mgr = mgr;\r\n\t\t\t_keyManager = keyManager;\r\n\t\t\t}","id":85257,"modified_method":"public CCNDIdGetter(CCNNetworkManager networkManager, KeyManager keyManager) { \r\n\t\t\t_networkManager = networkManager;\r\n\t\t\t_keyManager = keyManager;\r\n\t\t\t}","commit_id":"5924d7834f769fd61f8af13f27ea459d29416744","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\r\n\t\t * Deliver interest to a registered handler\r\n\t\t */\r\n\t\tpublic void deliver() {\r\n\t\t\ttry {\r\n\t\t\t\tArrayList<Interest> results = null;\r\n\t\t\t\tCCNFilterListener listener = null;\r\n\t\t\t\tsynchronized (this) {\r\n\t\t\t\t\tif (this.interests.size() > 0) { \r\n\t\t\t\t\t\tresults = interests;\r\n\t\t\t\t\t\tinterests = new ArrayList<Interest>(1);\r\n\t\t\t\t\t\tlistener = (CCNFilterListener)this.listener;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (null != results) {\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t// Call into client code without holding any library locks\r\n\t\t\t\t\tLog.finer(\"Filter callback ({0} interests) for: {1}\", results.size(), name);\r\n\t\t\t\t\tlistener.handleInterests(results);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tLog.finer(\"Filter callback skipped (no interests) for: {0}\", name);\r\n\t\t\t\t}\r\n\t\t\t} catch (RuntimeException ex) {\r\n\t\t\t\tLog.warning(\"failed to deliver interest: {0}\", ex);\r\n\t\t\t}\r\n\t\t}","id":85258,"modified_method":"/**\r\n\t\t * Deliver interest to a registered handler\r\n\t\t */\r\n\t\tpublic void deliver() {\r\n\t\t\ttry {\r\n\t\t\t\tArrayList<Interest> results = null;\r\n\t\t\t\tCCNFilterListener listener = null;\r\n\t\t\t\tsynchronized (this) {\r\n\t\t\t\t\tif (this.interests.size() > 0) { \r\n\t\t\t\t\t\tresults = interests;\r\n\t\t\t\t\t\tinterests = new ArrayList<Interest>(1);\r\n\t\t\t\t\t\tlistener = (CCNFilterListener)this.listener;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (null != results) {\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t// Call into client code without holding any library locks\r\n\t\t\t\t\tLog.finer(\"Filter callback ({0} interests) for: {1}\", results.size(), prefix);\r\n\t\t\t\t\tlistener.handleInterests(results);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tLog.finer(\"Filter callback skipped (no interests) for: {0}\", prefix);\r\n\t\t\t\t}\r\n\t\t\t} catch (RuntimeException ex) {\r\n\t\t\t\tLog.warning(\"failed to deliver interest: {0}\", ex);\r\n\t\t\t}\r\n\t\t}","commit_id":"5924d7834f769fd61f8af13f27ea459d29416744","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public void run() {\r\n\t\t\tboolean isNull = false;\r\n\t\t\tsynchronized (_idSyncer) {\r\n\t\t\t\tisNull = (null == _ccndId);\r\n\t\t\t}\r\n\t\t\tif (isNull) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tInterest interested = new Interest(ping);\r\n\t\t\t\t\tinterested.nonce(Interest.generateNonce());\r\n\t\t\t\t\tinterested.scope(1);\r\n\t\t\t\t\tContentObject contented = _mgr.get(interested, 500);\r\n\t\t\t\t\tif (null == contented) {\r\n\t\t\t\t\t\tString msg = (\"CCNDIdGetter: Fetch of content from ping uri failed due to timeout.\");\r\n\t\t\t\t\t\tLog.severe(msg);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tPublisherPublicKeyDigest sentID = contented.signedInfo().getPublisherKeyID();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// TODO: This needs to be fixed once the KeyRepository is fixed to provide a KeyManager\r\n\t\t\t\t\tif (null != _keyManager) {\r\n//\t\t\t\t\t\tPublicKey publicKey = _keyManager.getPublicKey(sentID);\r\n//\t\t\t\t\t\tif (!contented.verify(publicKey)) {\r\n//\t\t\t\t\t\t\tString msg = (\"CCNDIdGetter: Fetch of content reply from ping failed to verify.\");\r\n//\t\t\t\t\t\t\tLog.severe(msg);\r\n//\t\t\t\t\t\t\treturn;\r\n//\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tContentVerifier verifyer = new ContentObject.SimpleVerifier(sentID, _keyManager);\r\n\t\t\t\t\t\tif (!verifyer.verify(contented)) {\r\n\t\t\t\t\t\t\tString msg = (\"CCNDIdGetter: Fetch of content reply from ping failed to verify.\");\r\n\t\t\t\t\t\t\tLog.severe(msg);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsynchronized(_idSyncer) {\r\n\t\t\t\t\t\t_ccndId = sentID;\r\n\t\t\t\t\t\tLog.info(\"CCNDIdGetter: ccndId {0}\", ContentName.componentPrintURI(sentID.digest()));\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\tLog.warningStackTrace(e);\r\n\t\t\t\t} catch (MalformedContentNameStringException e) {\r\n\t\t\t\t\tString reason = e.getMessage();\r\n\t\t\t\t\tLog.warningStackTrace(e);\r\n\t\t\t\t\tString msg = (\"CCNDIdGetter: Unexpected MalformedContentNameStringException in call creating: \" + ping + \" reason: \" + reason);\r\n\t\t\t\t\tLog.severe(msg);\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tString reason = e.getMessage();\r\n\t\t\t\t\tLog.warningStackTrace(e);\r\n\t\t\t\t\tString msg = (\"CCNDIdGetter: Unexpected IOException in call getting ping Interest reason: \" + reason);\r\n\t\t\t\t\tLog.severe(msg);\r\n//\t\t\t\t} catch (InvalidKeyException e) {\r\n//\t\t\t\t\t// TODO Auto-generated catch block\r\n//\t\t\t\t\te.printStackTrace();\r\n//\t\t\t\t} catch (SignatureException e) {\r\n//\t\t\t\t\t// TODO Auto-generated catch block\r\n//\t\t\t\t\te.printStackTrace();\r\n//\t\t\t\t} catch (NoSuchAlgorithmException e) {\r\n//\t\t\t\t\t// TODO Auto-generated catch block\r\n//\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t} /* null == _ccndId */\r\n\t\t}","id":85259,"modified_method":"public void run() {\r\n\t\t\tboolean isNull = false;\r\n\t\t\tPublisherPublicKeyDigest sentID = null;\r\n\t\t\tsynchronized (_idSyncer) {\r\n\t\t\t\tisNull = (null == _ccndId);\r\n\t\t\t}\r\n\t\t\tif (isNull) {\r\n\t\t\t\tsentID = fetchCCNDId(_networkManager, _keyManager);\r\n\t\t\t\tif (null == sentID) {\r\n\t\t\t\t\tLog.severe(\"CCNDIdGetter: call to fetchCCNDId returned null.\");\r\n\t\t\t\t}\r\n\t\t\t\tsynchronized(_idSyncer) {\r\n\t\t\t\t\t_ccndId = sentID;\r\n\t\t\t\t\tLog.info(\"CCNDIdGetter: ccndId {0}\", ContentName.componentPrintURI(sentID.digest()));\r\n\t\t\t\t}\r\n\t\t\t} /* null == _ccndId */\r\n\t\t}","commit_id":"5924d7834f769fd61f8af13f27ea459d29416744","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"public Filter(CCNNetworkManager mgr, ContentName n, CCNFilterListener l, Object o) {\r\n\t\t\tname = n; listener = l; owner = o;\r\n\t\t\tmanager = mgr;\r\n\t\t}","id":85260,"modified_method":"public Filter(CCNNetworkManager mgr, ContentName n, CCNFilterListener l, Object o) {\r\n\t\t\tprefix = n; listener = l; owner = o;\r\n\t\t\tmanager = mgr;\r\n\t\t}","commit_id":"5924d7834f769fd61f8af13f27ea459d29416744","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\r\n\t * Get the CCN Name of the 'ccnd' we're connected to.\r\n\t * \r\n\t * @return the CCN Name of the 'ccnd' this CCNNetworkManager is connected to.\r\n\t */\r\n\tpublic PublisherPublicKeyDigest getCCNDId() {\r\n\t\t/*\r\n\t\t *  Now arrange to have the ccndId read.  We can't do that here because we need\r\n\t\t *  to return back to the create before we know we get the answer back.  We can\r\n\t\t *  cause the prefix registration to wait.\r\n\t\t */\r\n\t\tsynchronized (_idSyncer) {\r\n\t\t\tif (null == _ccndId && null == _getter) {\r\n\t\t\t\t_getter = new CCNDIdGetter(this, _keyManager);\r\n\t\t\t\t_threadpool.execute(_getter);\r\n\t\t\t} else {\r\n\t\t\t\treturn _ccndId;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t * If we get here, we don't yet have the ccndId we need to return, so...\r\n\t\t */\r\n\t\tint loopCnt = 0;\r\n\t\tdo {\r\n\t\t\ttry {\r\n\t\t\t\tThread.sleep(5);\r\n\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t\tsynchronized (_idSyncer) {\r\n\t\t\t\tif (null != _ccndId) {\r\n\t\t\t\t\treturn (_ccndId);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} while (loopCnt < 500);\r\n\t\treturn null;\r\n\t}","id":85261,"modified_method":"/**\r\n\t * Get the CCN Name of the 'ccnd' we're connected to.\r\n\t * \r\n\t * @return the CCN Name of the 'ccnd' this CCNNetworkManager is connected to.\r\n\t */\r\n\tpublic PublisherPublicKeyDigest getCCNDId() {\r\n\t\t/*\r\n\t\t *  Now arrange to have the ccndId read.  We can't do that here because we need\r\n\t\t *  to return back to the create before we know we get the answer back.  We can\r\n\t\t *  cause the prefix registration to wait.\r\n\t\t */\r\n\t\tPublisherPublicKeyDigest sentID = null;\r\n\t\tboolean doFetch = false;\r\n\t\t\r\n\t\tsynchronized (_idSyncer) {\r\n\t\t\tif (null == _ccndId) {\r\n\t\t\t\tdoFetch = true;\r\n\t\t\t} else {\r\n\t\t\t\treturn _ccndId;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (doFetch) {\r\n\t\t\tsentID = fetchCCNDId(this, _keyManager);\r\n\t\t\tif (null == sentID) {\r\n\t\t\t\tLog.severe(\"getCCNDId: call to fetchCCNDId returned null.\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsynchronized (_idSyncer) {\r\n\t\t\t_ccndId = sentID;\r\n\t\t\treturn _ccndId;\r\n\t\t}\r\n\t}","commit_id":"5924d7834f769fd61f8af13f27ea459d29416744","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn name.toString();\r\n\t\t}","id":85262,"modified_method":"@Override\r\n\t\tpublic String toString() {\r\n\t\t\treturn prefix.toString();\r\n\t\t}","commit_id":"5924d7834f769fd61f8af13f27ea459d29416744","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"Config build(Config config) {\n        try {\n            parse(config);\n        } catch (Exception e) {\n            throw new HazelcastException(e);\n        }\n        config.setConfigurationFile(configurationFile);\n        config.setConfigurationUrl(configurationUrl);\n        return config;\n    }","id":85263,"modified_method":"Config build(Config config) {\n        config.setConfigurationFile(configurationFile);\n        config.setConfigurationUrl(configurationUrl);\n        try {\n            parse(config);\n        } catch (Exception e) {\n            throw new HazelcastException(e);\n        }\n        return config;\n    }","commit_id":"84de8ca62777f93882b0c9d5f43e3d1fe3b0036a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Constructs a XmlConfigBuilder that tries to find a usable XML configuration file.\n     */\n    public XmlConfigBuilder() {\n        String configSystemProperty = System.getProperty(\"hazelcast.config\");\n        try {\n            if (configSystemProperty != null) {\n                logger.info(\"Loading configuration \" + configSystemProperty+\" from System property 'hazelcast.config'\");\n\n                //so there is an explicitly configured hazelcast configuration. We are either going to load it,\n                //or we are going to throw an exception. Not throwing an exception, but continuing to load some default\n                //is a violation of the 'fail fast principle'\n\n                if (configSystemProperty.startsWith(\"classpath:\")) {\n                    String resource = configSystemProperty.substring(\"classpath:\".length());\n\n                    logger.info(\"Using classpath resource at \" + resource);\n\n                    if(resource.isEmpty()){\n                        throw new HazelcastException(\"classpath resource can't be empty\");\n                    }\n\n                    URL url = Config.class.getClassLoader().getResource(configSystemProperty);\n                    if(url == null){\n                        throw new HazelcastException(\"Could not load classpath resource: \"+resource);\n                    }\n\n                    configurationFile = new File(url.getFile());\n                } else {\n                    //it is a file.\n                    configurationFile = new File(configSystemProperty);\n                    logger.info(\"Using configuration file at \" + configurationFile.getAbsolutePath());\n                    if (!configurationFile.exists()) {\n                        String msg = \"Config file at '\" + configurationFile.getAbsolutePath() + \"' doesn't exist.\";\n                        throw new HazelcastException(msg);\n                    }\n                }\n            }\n\n            if (configurationFile == null) {\n                configSystemProperty = \"hazelcast.xml\";\n                configurationFile = new File(\"hazelcast.xml\");\n                if (!configurationFile.exists()) {\n                    configurationFile = null;\n                }\n            }\n\n            if (configurationFile != null) {\n                logger.info(\"Using configuration file at \" + configurationFile.getAbsolutePath());\n                try {\n                    in = new FileInputStream(configurationFile);\n                    configurationUrl = configurationFile.toURI().toURL();\n                    usingSystemConfig = true;\n                } catch (final Exception e) {\n                    String msg = \"Having problem reading config file at '\" + configSystemProperty + \"'.\";\n                    msg += \"\\nException message: \" + e.getMessage();\n                    msg += \"\\nHazelcast will try to use the hazelcast.xml config file in classpath.\";\n                    logger.warning(msg);\n                    in = null;\n                }\n            }\n            if (in == null) {\n                logger.info(\"Looking for hazelcast.xml config file in classpath.\");\n                configurationUrl = Config.class.getClassLoader().getResource(\"hazelcast.xml\");\n                if (configurationUrl == null) {\n                    configurationUrl = Config.class.getClassLoader().getResource(\"hazelcast-default.xml\");\n                    logger.warning(\n                            \"Could not find hazelcast.xml in classpath.\\nHazelcast will use hazelcast-default.xml config file in jar.\");\n                    if (configurationUrl == null) {\n                        logger.warning(\"Could not find hazelcast-default.xml in the classpath!\"\n                                + \"\\nThis may be due to a wrong-packaged or corrupted jar file.\");\n                        return;\n                    }\n                }\n                logger.info(\"Using configuration file \" + configurationUrl.getFile() + \" in the classpath.\");\n                in = configurationUrl.openStream();\n                if (in == null) {\n                    String msg = \"Having problem reading config file hazelcast-default.xml in the classpath.\";\n                    msg += \"\\nHazelcast will start with default configuration.\";\n                    logger.warning(msg);\n                }\n            }\n        } catch (HazelcastException e) {\n            throw e;\n        } catch (final Error e) {\n            throw e;\n        } catch (Exception e) {\n            throw new HazelcastException(e);\n        }\n    }","id":85264,"modified_method":"/**\n     * Constructs a XmlConfigBuilder that tries to find a usable XML configuration file.\n     */\n    public XmlConfigBuilder() {\n        try {\n            if (loadFromSystemProperty()) {\n                return;\n            }\n\n            if (loadFromWorkingDirectory()) {\n                return;\n            }\n\n            if (loadHazelcastXmlFromClasspath()) {\n                return;\n            }\n\n            loadDefaultConfigurationFromClasspath();\n        } catch (RuntimeException e) {\n            throw new HazelcastException(e);\n        }\n    }","commit_id":"84de8ca62777f93882b0c9d5f43e3d1fe3b0036a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void parse(final Config config) throws Exception {\n        this.config = config;\n        final DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc;\n        try {\n            doc = builder.parse(in);\n        } catch (final Exception e) {\n            String msgPart = \"config file '\" + config.getConfigurationFile() + \"' set as a system property.\";\n            if (!usingSystemConfig) {\n                msgPart = \"hazelcast-default.xml config file in the classpath.\";\n            }\n            String msg = \"Having problem parsing the \" + msgPart;\n            msg += \"\\nException: \" + e.getMessage();\n            msg += \"\\nHazelcast startup interrupted.\";\n            logger.severe(msg);\n            throw e;\n        } finally {\n            IOUtil.closeResource(in);\n        }\n        Element element = doc.getDocumentElement();\n        try {\n            element.getTextContent();\n        } catch (final Throwable e) {\n            domLevel3 = false;\n        }\n        preprocess(element);\n        handleConfig(element);\n    }","id":85265,"modified_method":"private void parse(final Config config) throws Exception {\n        this.config = config;\n        final DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc;\n        try {\n            doc = builder.parse(in);\n        } catch (final Exception e) {\n            if (configurationFile != null) {\n                String msg = \"Failed to parse \" + configurationFile +\n                        \"\\nException: \" + e.getMessage() +\n                        \"\\nHazelcast startup interrupted.\";\n                logger.severe(msg);\n\n            } else if (configurationUrl != null) {\n                String msg = \"Failed to parse \" + configurationUrl +\n                        \"\\nException: \" + e.getMessage() +\n                        \"\\nHazelcast startup interrupted.\";\n                logger.severe(msg);\n            } else {\n                String msg = \"Failed to parse the inputstream\" +\n                        \"\\nException: \" + e.getMessage() +\n                        \"\\nHazelcast startup interrupted.\";\n                logger.severe(msg);\n\n            }\n            throw e;\n        } finally {\n            IOUtil.closeResource(in);\n        }\n        Element element = doc.getDocumentElement();\n        try {\n            element.getTextContent();\n        } catch (final Throwable e) {\n            domLevel3 = false;\n        }\n        preprocess(element);\n        handleConfig(element);\n    }","commit_id":"84de8ca62777f93882b0c9d5f43e3d1fe3b0036a","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void insert(int valueHC, int newValueId) {\n      if (doSanityCheck) myAssert(!isFull());\n      short recordCount = getChildrenCount();\n      if (doSanityCheck) myAssert(recordCount < getMaxChildrenCount());\n\n      final boolean indexLeaf = isIndexLeaf();\n\n      if (indexLeaf) {\n        if (recordCount == 0 && btree.indexNodeIsHashTable) {\n          setHashedLeaf(true);\n          ++btree.hashedPagesCount;\n        }\n\n        if (isHashedLeaf()) {\n          int index = hashInsertionIndex(valueHC);\n\n          if (index < 0) {\n            index = -index - 1;\n          }\n\n          setKeyAt(index, valueHC);\n          hashSetState(index, HASH_FULL);\n          setAddressAt(index, newValueId);\n          setChildrenCount((short)(recordCount + 1));\n\n          return;\n        }\n      }\n\n      int medianKeyInParent = search(valueHC);\n      if (doSanityCheck) myAssert(medianKeyInParent < 0);\n      int index = -medianKeyInParent - 1;\n      setChildrenCount((short)(recordCount + 1));\n\n      final int itemsToMove = recordCount - index;\n      btree.movedMembersCount += itemsToMove;\n\n      if (indexLeaf) {\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          final int bytesToMove = itemsToMove * INTERIOR_SIZE;\n          getBytes(indexToOffset(index), btree.buffer, bytesToMove);\n          putBytes(indexToOffset(index + 1), btree.buffer, bytesToMove);\n        } else {\n          for(int i = recordCount - 1; i >= index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n        setKeyAt(index, valueHC);\n        setAddressAt(index, newValueId);\n      } else {\n        // <address> (<key><address>) {record_count - 1}\n        //\n        setAddressAt(recordCount + 1, addressAt(recordCount));\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          int elementsAfterIndex = recordCount - index - 1;\n          if (elementsAfterIndex > 0) {\n            int bytesToMove = elementsAfterIndex * INTERIOR_SIZE;\n            getBytes(indexToOffset(index + 1), btree.buffer, bytesToMove);\n            putBytes(indexToOffset(index + 2), btree.buffer, bytesToMove);\n          }\n        } else {\n          for(int i = recordCount - 1; i > index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n\n        if (index < recordCount) setKeyAt(index + 1, keyAt(index));\n\n        setKeyAt(index, valueHC);\n        setAddressAt(index + 1, newValueId);\n      }\n\n      if (doSanityCheck) {\n        if (index > 0) myAssert(keyAt(index - 1) < keyAt(index));\n        if (index < recordCount) myAssert(keyAt(index) < keyAt(index + 1));\n      }\n    }","id":85266,"modified_method":"private void insert(int valueHC, int newValueId) {\n      if (doSanityCheck) myAssert(!isFull());\n      short recordCount = getChildrenCount();\n      if (doSanityCheck) myAssert(recordCount < getMaxChildrenCount());\n\n      final boolean indexLeaf = isIndexLeaf();\n\n      if (indexLeaf) {\n        if (recordCount == 0 && btree.indexNodeIsHashTable) {\n          setHashedLeaf(true);\n          ++btree.hashedPagesCount;\n        }\n\n        if (isHashedLeaf()) {\n          int index = hashInsertionIndex(valueHC);\n\n          if (index < 0) {\n            index = -index - 1;\n          }\n\n          setKeyAt(index, valueHC);\n          hashSetState(index, HASH_FULL);\n          setAddressAt(index, newValueId);\n          setChildrenCount((short)(recordCount + 1));\n\n          return;\n        }\n      }\n\n      int medianKeyInParent = search(valueHC);\n      if (doSanityCheck) myAssert(medianKeyInParent < 0);\n      int index = -medianKeyInParent - 1;\n      setChildrenCount((short)(recordCount + 1));\n\n      final int itemsToMove = recordCount - index;\n      btree.movedMembersCount += itemsToMove;\n\n      if (indexLeaf) {\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          ByteBuffer buffer = getBytes(indexToOffset(index), itemsToMove * INTERIOR_SIZE);\n          putBytes(indexToOffset(index + 1), buffer);\n        } else {\n          for(int i = recordCount - 1; i >= index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n        setKeyAt(index, valueHC);\n        setAddressAt(index, newValueId);\n      } else {\n        // <address> (<key><address>) {record_count - 1}\n        //\n        setAddressAt(recordCount + 1, addressAt(recordCount));\n        if (btree.isLarge && itemsToMove > LARGE_MOVE_THRESHOLD) {\n          int elementsAfterIndex = recordCount - index - 1;\n          if (elementsAfterIndex > 0) {\n            ByteBuffer buffer = getBytes(indexToOffset(index + 1), elementsAfterIndex * INTERIOR_SIZE);\n            putBytes(indexToOffset(index + 2), buffer);\n          }\n        } else {\n          for(int i = recordCount - 1; i > index; --i) {\n            setKeyAt(i + 1, keyAt(i));\n            setAddressAt(i + 1, addressAt(i));\n          }\n        }\n\n        if (index < recordCount) setKeyAt(index + 1, keyAt(index));\n\n        setKeyAt(index, valueHC);\n        setAddressAt(index + 1, newValueId);\n      }\n\n      if (doSanityCheck) {\n        if (index > 0) myAssert(keyAt(index - 1) < keyAt(index));\n        if (index < recordCount) myAssert(keyAt(index) < keyAt(index + 1));\n      }\n    }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"int[] exportKeys() {\n      assert isIndexLeaf();\n      short childrenCount = getChildrenCount();\n      int[] keys = new int[childrenCount];\n\n      if (isHashedLeaf()) {\n        getBytes(indexToOffset(0), btree.buffer, btree.pageSize - btree.metaDataLeafPageLength);\n        int keyNumber = 0;\n\n        for(int i = 0; i < btree.hashPageCapacity; ++i) {\n          if (hashGetState(i) == HASH_FULL) {\n            int key = Bits.getInt(btree.buffer, i * INTERIOR_SIZE + KEY_OFFSET);\n            keys[keyNumber++] = key;\n          }\n        }\n      } else {\n        for(int i = 0; i < childrenCount; ++i) {\n          keys[i] = keyAt(i);\n        }\n      }\n      return keys;\n    }","id":85267,"modified_method":"int[] exportKeys() {\n      assert isIndexLeaf();\n      short childrenCount = getChildrenCount();\n      int[] keys = new int[childrenCount];\n\n      if (isHashedLeaf()) {\n        final int offset = myAddressInBuffer + indexToOffset(0) + KEY_OFFSET;\n\n        int keyNumber = 0;\n\n        for(int i = 0; i < btree.hashPageCapacity; ++i) {\n          if (hashGetState(i) == HASH_FULL) {\n            int key = myBuffer.getInt(offset + i * INTERIOR_SIZE);\n            keys[keyNumber++] = key;\n          }\n        }\n      } else {\n        for(int i = 0; i < childrenCount; ++i) {\n          keys[i] = keyAt(i);\n        }\n      }\n      return keys;\n    }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int locate(int valueHC, boolean split) {\n      int searched = 0;\n      int parentAddress = 0;\n\n      while(true) {\n        if (split && isFull()) {\n          parentAddress = splitNode(parentAddress);\n          if (parentAddress != 0) setAddress(parentAddress);\n          --searched;\n        }\n\n        int i = search(valueHC);\n\n        ++searched;\n\n        if (isIndexLeaf()) {\n          btree.height = Math.max(btree.height, searched);\n          return i;\n        }\n\n        int address = i < 0 ? addressAt(-i - 1):addressAt(i + 1);\n        if (doSanityCheck) myAssert(address != 0);\n        parentAddress = this.address;\n        setAddress(-address);\n      }\n    }","id":85268,"modified_method":"private int locate(int valueHC, boolean split) {\n      int searched = 0;\n      int parentAddress = 0;\n\n      while(true) {\n        if (split && isFull()) {\n          parentAddress = splitNode(parentAddress);\n          if (parentAddress != 0) setAddress(parentAddress);\n          --searched;\n        }\n\n        int i = search(valueHC);\n\n        ++searched;\n\n        if (isIndexLeaf()) {\n          btree.height = Math.max(btree.height, searched);\n          return i;\n        }\n\n        int address = i < 0 ? addressAt(-i - 1):addressAt(i + 1);\n        parentAddress = this.address;\n        setAddress(-address);\n      }\n    }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int splitNode(int parentAddress) {\n      final boolean indexLeaf = isIndexLeaf();\n\n      if (doSanityCheck) {\n        myAssert(isFull());\n        dump(\"before split:\"+indexLeaf);\n      }\n\n      final boolean hashedLeaf = isHashedLeaf();\n      final short recordCount = getChildrenCount();\n      BtreeIndexNodeView parent = null;\n      HashLeafData hashLeafData = null;\n\n      if (parentAddress != 0) {\n        parent = new BtreeIndexNodeView(btree);\n        parent.setAddress(parentAddress);\n\n        if (btree.offloadToSiblingsBeforeSplit) {\n          if (hashedLeaf) {\n            hashLeafData = new HashLeafData(this, recordCount);\n            if (doOffloadToSiblingsWhenHashed(parent, hashLeafData)) return parentAddress;\n          } else {\n            if (doOffloadToSiblingsSorted(parent)) return parentAddress;\n          }\n        }\n      }\n\n      short maxIndex = (short)(getMaxChildrenCount() / 2);\n\n      BtreeIndexNodeView newIndexNode = new BtreeIndexNodeView(btree);\n      newIndexNode.setAddress(btree.nextPage());\n      syncWithStore(); // next page can cause ByteBuffer to be invalidated!\n      if (parent != null) parent.syncWithStore();\n      btree.root.syncWithStore();\n\n      newIndexNode.setIndexLeaf(indexLeaf);\n\n      int nextPage = getNextPage();\n      setNextPage(newIndexNode.address);\n      newIndexNode.setNextPage(nextPage);\n\n      int medianKey = -1;\n\n      if (indexLeaf && hashedLeaf) {\n        if (hashLeafData == null) hashLeafData = new HashLeafData(this, recordCount);\n        final int[] keys = hashLeafData.keys;\n\n        boolean defaultSplit = true;\n\n        //if (keys[keys.length - 1] < newValue && btree.height <= 3) {  // optimization for adding element to last block\n        //  btree.root.syncWithStore();\n        //  if (btree.height == 2 && btree.root.search(keys[0]) == btree.root.getChildrenCount() - 1) {\n        //    defaultSplit = false;\n        //  } else if (btree.height == 3 &&\n        //             btree.root.search(keys[0]) == -btree.root.getChildrenCount() - 1 &&\n        //             parent.search(keys[0]) == parent.getChildrenCount() - 1\n        //            ) {\n        //    defaultSplit = false;\n        //  }\n        //\n        //  if (!defaultSplit) {\n        //    newIndexNode.setChildrenCount((short)0);\n        //    newIndexNode.insert(newValue, 0);\n        //    ++btree.count;\n        //    medianKey = newValue;\n        //  }\n        //}\n\n        if (defaultSplit) {\n          hashLeafData.clean();\n\n          final TIntIntHashMap map = hashLeafData.values;\n\n          final int avg = keys.length / 2;\n          medianKey = keys[avg];\n          --btree.hashedPagesCount;\n          setChildrenCount((short)0);\n          newIndexNode.setChildrenCount((short)0);\n\n          for(int i = 0; i < avg; ++i) {\n            int key = keys[i];\n            insert(key, map.get(key));\n            key = keys[avg + i];\n            newIndexNode.insert(key, map.get(key));\n          }\n\n          /*setHashedLeaf(false);\n                  setChildrenCount((short)keys.length);\n\n                  --btree.hashedPagesCount;\n                  btree.movedMembersCount += keys.length;\n\n                  for(int i = 0; i < keys.length; ++i) {\n                    int key = keys[i];\n                    setKeyAt(i, key);\n                    setAddressAt(i, map.get(key));\n                  }\n                  return parentAddress;*/\n        }\n      } else {\n        short recordCountInNewNode = (short)(recordCount - maxIndex);\n        newIndexNode.setChildrenCount(recordCountInNewNode);\n        \n        if (btree.isLarge) {\n          final int bytesToMove = recordCountInNewNode * INTERIOR_SIZE;\n          getBytes(indexToOffset(maxIndex), btree.buffer, bytesToMove);\n          newIndexNode.putBytes(newIndexNode.indexToOffset(0), btree.buffer, bytesToMove);\n        } else {\n          for(int i = 0; i < recordCountInNewNode; ++i) {\n            newIndexNode.setAddressAt(i, addressAt(i + maxIndex));\n            newIndexNode.setKeyAt(i, keyAt(i + maxIndex));\n          }\n        }\n        if (indexLeaf) {\n          medianKey = newIndexNode.keyAt(0);\n        } else {\n          newIndexNode.setAddressAt(recordCountInNewNode, addressAt(recordCount));\n          --maxIndex;\n          medianKey = keyAt(maxIndex);     // key count is odd (since children count is even) and middle key goes to parent\n        }\n        setChildrenCount(maxIndex);\n      }\n\n      if (parent != null) {\n        if (doSanityCheck) {\n          int medianKeyInParent = parent.search(medianKey);\n          int ourKey = keyAt(0);\n          int ourKeyInParent = parent.search(ourKey);\n          parent.dump(\"About to insert \"+medianKey + \",\" + newIndexNode.address+\",\" + medianKeyInParent + \" our key \" + ourKey + \", \" + ourKeyInParent);\n\n          myAssert(medianKeyInParent < 0);\n          myAssert(!parent.isFull());\n        }\n\n        parent.insert(medianKey, -newIndexNode.address);\n\n        if (doSanityCheck) {\n          parent.dump(\"After modifying parent\");\n          int search = parent.search(medianKey);\n          myAssert(search >= 0);\n          myAssert(parent.addressAt(search + 1) == -newIndexNode.address);\n\n          dump(\"old node after split:\");\n          newIndexNode.dump(\"new node after split:\");\n        }\n      } else {\n        if (doSanityCheck) {\n          btree.root.dump(\"Splitting root:\"+medianKey);\n        }\n\n        int newRootAddress = btree.nextPage();\n        newIndexNode.syncWithStore();\n        syncWithStore();\n\n        if (doSanityCheck) {\n          System.out.println(\"Pages:\"+btree.pagesCount+\", elements:\"+btree.count + \", average:\" + (btree.height + 1));\n        }\n        btree.root.setAddress(newRootAddress);\n        parentAddress = newRootAddress;\n\n        btree.root.setChildrenCount((short)1);\n        btree.root.setKeyAt(0, medianKey);\n        btree.root.setAddressAt(0, -address);\n        btree.root.setAddressAt(1, -newIndexNode.address);\n\n\n        if (doSanityCheck) {\n          btree.root.dump(\"New root\");\n          dump(\"First child\");\n          newIndexNode.dump(\"Second child\");\n        }\n      }\n\n      return parentAddress;\n    }","id":85269,"modified_method":"private int splitNode(int parentAddress) {\n      final boolean indexLeaf = isIndexLeaf();\n\n      if (doSanityCheck) {\n        myAssert(isFull());\n        dump(\"before split:\"+indexLeaf);\n      }\n\n      final boolean hashedLeaf = isHashedLeaf();\n      final short recordCount = getChildrenCount();\n      BtreeIndexNodeView parent = null;\n      HashLeafData hashLeafData = null;\n\n      if (parentAddress != 0) {\n        parent = new BtreeIndexNodeView(btree);\n        parent.setAddress(parentAddress);\n\n        if (btree.offloadToSiblingsBeforeSplit) {\n          if (hashedLeaf) {\n            hashLeafData = new HashLeafData(this, recordCount);\n            if (doOffloadToSiblingsWhenHashed(parent, hashLeafData)) return parentAddress;\n          } else {\n            if (doOffloadToSiblingsSorted(parent)) return parentAddress;\n          }\n        }\n      }\n\n      short maxIndex = (short)(getMaxChildrenCount() / 2);\n\n      BtreeIndexNodeView newIndexNode = new BtreeIndexNodeView(btree);\n      newIndexNode.setAddress(btree.nextPage());\n      syncWithStore(); // next page can cause ByteBuffer to be invalidated!\n      if (parent != null) parent.syncWithStore();\n      btree.root.syncWithStore();\n\n      newIndexNode.setIndexLeaf(indexLeaf);\n\n      int nextPage = getNextPage();\n      setNextPage(newIndexNode.address);\n      newIndexNode.setNextPage(nextPage);\n\n      int medianKey = -1;\n\n      if (indexLeaf && hashedLeaf) {\n        if (hashLeafData == null) hashLeafData = new HashLeafData(this, recordCount);\n        final int[] keys = hashLeafData.keys;\n\n        boolean defaultSplit = true;\n\n        //if (keys[keys.length - 1] < newValue && btree.height <= 3) {  // optimization for adding element to last block\n        //  btree.root.syncWithStore();\n        //  if (btree.height == 2 && btree.root.search(keys[0]) == btree.root.getChildrenCount() - 1) {\n        //    defaultSplit = false;\n        //  } else if (btree.height == 3 &&\n        //             btree.root.search(keys[0]) == -btree.root.getChildrenCount() - 1 &&\n        //             parent.search(keys[0]) == parent.getChildrenCount() - 1\n        //            ) {\n        //    defaultSplit = false;\n        //  }\n        //\n        //  if (!defaultSplit) {\n        //    newIndexNode.setChildrenCount((short)0);\n        //    newIndexNode.insert(newValue, 0);\n        //    ++btree.count;\n        //    medianKey = newValue;\n        //  }\n        //}\n\n        if (defaultSplit) {\n          hashLeafData.clean();\n\n          final TIntIntHashMap map = hashLeafData.values;\n\n          final int avg = keys.length / 2;\n          medianKey = keys[avg];\n          --btree.hashedPagesCount;\n          setChildrenCount((short)0);\n          newIndexNode.setChildrenCount((short)0);\n\n          for(int i = 0; i < avg; ++i) {\n            int key = keys[i];\n            insert(key, map.get(key));\n            key = keys[avg + i];\n            newIndexNode.insert(key, map.get(key));\n          }\n\n          /*setHashedLeaf(false);\n                  setChildrenCount((short)keys.length);\n\n                  --btree.hashedPagesCount;\n                  btree.movedMembersCount += keys.length;\n\n                  for(int i = 0; i < keys.length; ++i) {\n                    int key = keys[i];\n                    setKeyAt(i, key);\n                    setAddressAt(i, map.get(key));\n                  }\n                  return parentAddress;*/\n        }\n      } else {\n        short recordCountInNewNode = (short)(recordCount - maxIndex);\n        newIndexNode.setChildrenCount(recordCountInNewNode);\n        \n        if (btree.isLarge) {\n          ByteBuffer buffer = getBytes(indexToOffset(maxIndex), recordCountInNewNode * INTERIOR_SIZE);\n          newIndexNode.putBytes(newIndexNode.indexToOffset(0), buffer);\n        } else {\n          for(int i = 0; i < recordCountInNewNode; ++i) {\n            newIndexNode.setAddressAt(i, addressAt(i + maxIndex));\n            newIndexNode.setKeyAt(i, keyAt(i + maxIndex));\n          }\n        }\n        if (indexLeaf) {\n          medianKey = newIndexNode.keyAt(0);\n        } else {\n          newIndexNode.setAddressAt(recordCountInNewNode, addressAt(recordCount));\n          --maxIndex;\n          medianKey = keyAt(maxIndex);     // key count is odd (since children count is even) and middle key goes to parent\n        }\n        setChildrenCount(maxIndex);\n      }\n\n      if (parent != null) {\n        if (doSanityCheck) {\n          int medianKeyInParent = parent.search(medianKey);\n          int ourKey = keyAt(0);\n          int ourKeyInParent = parent.search(ourKey);\n          parent.dump(\"About to insert \"+medianKey + \",\" + newIndexNode.address+\",\" + medianKeyInParent + \" our key \" + ourKey + \", \" + ourKeyInParent);\n\n          myAssert(medianKeyInParent < 0);\n          myAssert(!parent.isFull());\n        }\n\n        parent.insert(medianKey, -newIndexNode.address);\n\n        if (doSanityCheck) {\n          parent.dump(\"After modifying parent\");\n          int search = parent.search(medianKey);\n          myAssert(search >= 0);\n          myAssert(parent.addressAt(search + 1) == -newIndexNode.address);\n\n          dump(\"old node after split:\");\n          newIndexNode.dump(\"new node after split:\");\n        }\n      } else {\n        if (doSanityCheck) {\n          btree.root.dump(\"Splitting root:\"+medianKey);\n        }\n\n        int newRootAddress = btree.nextPage();\n        newIndexNode.syncWithStore();\n        syncWithStore();\n\n        if (doSanityCheck) {\n          System.out.println(\"Pages:\"+btree.pagesCount+\", elements:\"+btree.count + \", average:\" + (btree.height + 1));\n        }\n        btree.root.setAddress(newRootAddress);\n        parentAddress = newRootAddress;\n\n        btree.root.setChildrenCount((short)1);\n        btree.root.setKeyAt(0, medianKey);\n        btree.root.setAddressAt(0, -address);\n        btree.root.setAddressAt(1, -newIndexNode.address);\n\n\n        if (doSanityCheck) {\n          btree.root.dump(\"New root\");\n          dump(\"First child\");\n          newIndexNode.dump(\"Second child\");\n        }\n      }\n\n      return parentAddress;\n    }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IntToIntBtree(int _pageSize, File file, boolean initial) throws IOException {\n    pageSize = _pageSize;\n    buffer = new byte[_pageSize];\n\n    if (initial) {\n      FileUtil.delete(file);\n    }\n\n    storage = new ResizeableMappedFile(file, pageSize, PersistentEnumeratorBase.ourLock, 1024 * 1024, true);\n    root = new BtreeIndexNodeView(this);\n\n    if (initial) {\n      nextPage(); // allocate root\n      root.setAddress(0);\n      root.setIndexLeaf(true);\n    }\n\n    int i = (pageSize - BtreePage.RESERVED_META_PAGE_LEN) / BtreeIndexNodeView.INTERIOR_SIZE - 1;\n    assert i < Short.MAX_VALUE && i % 2 == 0;\n    maxInteriorNodes = (short)i;\n    maxLeafNodes = (short)i;\n\n    int metaPageLen = BtreePage.RESERVED_META_PAGE_LEN;\n\n    if (indexNodeIsHashTable) {\n      ++i;\n      final double bitsPerState = BtreeIndexNodeView.haveDeleteState? 2d:1d;\n      while(Math.ceil(bitsPerState * i / 8) + i * BtreeIndexNodeView.INTERIOR_SIZE + BtreePage.RESERVED_META_PAGE_LEN > pageSize ||\n            !isPrime(i)\n           ) {\n        i -= 2;\n      }\n\n      hashPageCapacity = i;\n      metaPageLen = BtreePage.RESERVED_META_PAGE_LEN + (int)Math.ceil(bitsPerState * hashPageCapacity / 8);\n      i = (int)(hashPageCapacity * 0.8);\n      if ((i & 1) == 1) ++i;\n    } else {\n      hashPageCapacity = -1;\n    }\n\n    metaDataLeafPageLength = metaPageLen;\n\n    assert i > 0 && i % 2 == 0;\n    maxLeafNodesInHash = (short) i;\n\n    if (hasCachedMappings) {\n      myCachedMappings = new TIntIntHashMap(myCachedMappingsSize = 4 * maxLeafNodes);\n    } else {\n      myCachedMappings = null;\n      myCachedMappingsSize = -1;\n    }\n  }","id":85270,"modified_method":"public IntToIntBtree(int _pageSize, File file, boolean initial) throws IOException {\n    pageSize = _pageSize;\n\n    if (initial) {\n      FileUtil.delete(file);\n    }\n\n    storage = new ResizeableMappedFile(file, pageSize, PersistentEnumeratorBase.ourLock, 1024 * 1024, true);\n    root = new BtreeIndexNodeView(this);\n\n    if (initial) {\n      nextPage(); // allocate root\n      root.setAddress(0);\n      root.setIndexLeaf(true);\n    }\n\n    int i = (pageSize - BtreePage.RESERVED_META_PAGE_LEN) / BtreeIndexNodeView.INTERIOR_SIZE - 1;\n    assert i < Short.MAX_VALUE && i % 2 == 0;\n    maxInteriorNodes = (short)i;\n    maxLeafNodes = (short)i;\n\n    int metaPageLen = BtreePage.RESERVED_META_PAGE_LEN;\n\n    if (indexNodeIsHashTable) {\n      ++i;\n      final double bitsPerState = BtreeIndexNodeView.haveDeleteState? 2d:1d;\n      while(Math.ceil(bitsPerState * i / 8) + i * BtreeIndexNodeView.INTERIOR_SIZE + BtreePage.RESERVED_META_PAGE_LEN > pageSize ||\n            !isPrime(i)\n           ) {\n        i -= 2;\n      }\n\n      hashPageCapacity = i;\n      metaPageLen = BtreePage.RESERVED_META_PAGE_LEN + (int)Math.ceil(bitsPerState * hashPageCapacity / 8);\n      i = (int)(hashPageCapacity * 0.8);\n      if ((i & 1) == 1) ++i;\n    } else {\n      hashPageCapacity = -1;\n    }\n\n    metaDataLeafPageLength = metaPageLen;\n\n    assert i > 0 && i % 2 == 0;\n    maxLeafNodesInHash = (short) i;\n\n    if (hasCachedMappings) {\n      myCachedMappings = new TIntIntHashMap(myCachedMappingsSize = 4 * maxLeafNodes);\n    } else {\n      myCachedMappings = null;\n      myCachedMappingsSize = -1;\n    }\n  }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void getBytes(int address, byte[] dst, int length) {\n      myBuffer.position(address + myAddressInBuffer);\n      myBuffer.get(dst, 0, length);\n    }","id":85271,"modified_method":"protected final ByteBuffer getBytes(int address, int length) {\n      ByteBuffer duplicate = myBuffer.duplicate();\n\n      int newPosition = address + myAddressInBuffer;\n      duplicate.position(newPosition);\n      duplicate.limit(newPosition + length);\n      return duplicate;\n    }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"HashLeafData(BtreeIndexNodeView _nodeView, int recordCount) {\n        nodeView = _nodeView;\n        final IntToIntBtree btree = _nodeView.btree;\n        nodeView.getBytes(nodeView.indexToOffset(0), btree.buffer, btree.pageSize - btree.metaDataLeafPageLength);\n        // TODO: using bytebuffers should more efficient for copying data too!\n        //int length = btree.pageSize - btree.metaDataLeafPageLength;\n        //final int offset = nodeView.indexToOffset(0);\n        //ByteBuffer buffer = nodeView.getBytes(offset, length);\n        //byte[] buf = new byte[btree.pageSize];\n        //buffer.get(buf, 0, length);\n        keys = new int[recordCount];\n        values = new TIntIntHashMap(recordCount);\n        int keyNumber = 0;\n        \n        for(int i = 0; i < btree.hashPageCapacity; ++i) {\n          if (nodeView.hashGetState(i) == HASH_FULL) {\n            int key = Bits.getInt(btree.buffer, i * INTERIOR_SIZE + KEY_OFFSET);\n            //int key2 = buffer.getInt(offset + i * INTERIOR_SIZE + KEY_OFFSET);\n            //myAssert(key == key2);\n            keys[keyNumber++] = key;\n            int value = Bits.getInt(btree.buffer, i * INTERIOR_SIZE);\n            //int value2 = buffer.getInt(offset + i * INTERIOR_SIZE);\n            //myAssert(value == value2);\n            values.put(key, value);\n          }\n        }\n        \n        Arrays.sort(keys);\n      }","id":85272,"modified_method":"HashLeafData(BtreeIndexNodeView _nodeView, int recordCount) {\n        nodeView = _nodeView;\n\n        final IntToIntBtree btree = _nodeView.btree;\n\n        final int offset = nodeView.myAddressInBuffer + nodeView.indexToOffset(0);\n        final ByteBuffer buffer = nodeView.myBuffer;\n        \n        keys = new int[recordCount];\n        values = new TIntIntHashMap(recordCount);\n        int keyNumber = 0;\n        \n        for(int i = 0; i < btree.hashPageCapacity; ++i) {\n          if (nodeView.hashGetState(i) == HASH_FULL) {\n            int key = buffer.getInt(offset + i * INTERIOR_SIZE + KEY_OFFSET);\n            keys[keyNumber++] = key;\n            int value = buffer.getInt(offset + i * INTERIOR_SIZE);\n            values.put(key, value);\n          }\n        }\n        \n        Arrays.sort(keys);\n      }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean doOffloadToSiblingsSorted(BtreeIndexNodeView parent) {\n      boolean indexLeaf = isIndexLeaf();\n      if (!indexLeaf) return false; // TODO\n\n      int indexInParent = parent.search(keyAt(0));\n\n      if (indexInParent >= 0) {\n        if (doSanityCheck) {\n          myAssert(parent.keyAt(indexInParent) == keyAt(0));\n          myAssert(parent.addressAt(indexInParent + 1) == -address);\n        }\n\n        BtreeIndexNodeView sibling = new BtreeIndexNodeView(btree);\n        sibling.setAddress(-parent.addressAt(indexInParent));\n\n        final int toMove = (sibling.getMaxChildrenCount() - sibling.getChildrenCount()) / 2;\n\n        if (toMove > 0) {\n          if (doSanityCheck) {\n            sibling.dump(\"Offloading to left sibling\");\n            parent.dump(\"parent before\");\n          }\n\n          for(int i = 0; i < toMove; ++i) sibling.insert(keyAt(i), addressAt(i));\n          if (doSanityCheck) {\n            sibling.dump(\"Left sibling after\");\n          }\n\n          parent.setKeyAt(indexInParent, keyAt(toMove));\n\n          int indexOfLastChildToMove = (int)getChildrenCount() - toMove;\n          btree.movedMembersCount += indexOfLastChildToMove;\n\n          if (btree.isLarge) {\n            final int bytesToMove = indexOfLastChildToMove * INTERIOR_SIZE;\n            getBytes(indexToOffset(toMove), btree.buffer, bytesToMove);\n            putBytes(indexToOffset(0), btree.buffer, bytesToMove);\n          }\n          else {\n            for (int i = 0; i < indexOfLastChildToMove; ++i) {\n              setAddressAt(i, addressAt(i + toMove));\n              setKeyAt(i, keyAt(i + toMove));\n            }\n          }\n\n          setChildrenCount((short)indexOfLastChildToMove);\n        }\n        else if (indexInParent + 1 < parent.getChildrenCount()) {\n          insertToRightSiblingWhenSorted(parent, indexInParent + 1, sibling);\n        }\n      } else if (indexInParent == -1) {\n        insertToRightSiblingWhenSorted(parent, 0, new BtreeIndexNodeView(btree));\n      }\n\n      if (!isFull()) {\n        if (doSanityCheck) {\n          dump(\"old node after split:\");\n          parent.dump(\"Parent node after split\");\n        }\n        return true;\n      }\n      return false;\n    }","id":85273,"modified_method":"private boolean doOffloadToSiblingsSorted(BtreeIndexNodeView parent) {\n      boolean indexLeaf = isIndexLeaf();\n      if (!indexLeaf) return false; // TODO\n\n      int indexInParent = parent.search(keyAt(0));\n\n      if (indexInParent >= 0) {\n        if (doSanityCheck) {\n          myAssert(parent.keyAt(indexInParent) == keyAt(0));\n          myAssert(parent.addressAt(indexInParent + 1) == -address);\n        }\n\n        BtreeIndexNodeView sibling = new BtreeIndexNodeView(btree);\n        sibling.setAddress(-parent.addressAt(indexInParent));\n\n        final int toMove = (sibling.getMaxChildrenCount() - sibling.getChildrenCount()) / 2;\n\n        if (toMove > 0) {\n          if (doSanityCheck) {\n            sibling.dump(\"Offloading to left sibling\");\n            parent.dump(\"parent before\");\n          }\n\n          for(int i = 0; i < toMove; ++i) sibling.insert(keyAt(i), addressAt(i));\n          if (doSanityCheck) {\n            sibling.dump(\"Left sibling after\");\n          }\n\n          parent.setKeyAt(indexInParent, keyAt(toMove));\n\n          int indexOfLastChildToMove = (int)getChildrenCount() - toMove;\n          btree.movedMembersCount += indexOfLastChildToMove;\n\n          if (btree.isLarge) {\n            ByteBuffer buffer = getBytes(indexToOffset(toMove), indexOfLastChildToMove * INTERIOR_SIZE);\n            putBytes(indexToOffset(0), buffer);\n          }\n          else {\n            for (int i = 0; i < indexOfLastChildToMove; ++i) {\n              setAddressAt(i, addressAt(i + toMove));\n              setKeyAt(i, keyAt(i + toMove));\n            }\n          }\n\n          setChildrenCount((short)indexOfLastChildToMove);\n        }\n        else if (indexInParent + 1 < parent.getChildrenCount()) {\n          insertToRightSiblingWhenSorted(parent, indexInParent + 1, sibling);\n        }\n      } else if (indexInParent == -1) {\n        insertToRightSiblingWhenSorted(parent, 0, new BtreeIndexNodeView(btree));\n      }\n\n      if (!isFull()) {\n        if (doSanityCheck) {\n          dump(\"old node after split:\");\n          parent.dump(\"Parent node after split\");\n        }\n        return true;\n      }\n      return false;\n    }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void putBytes(int address, byte[] src, int length) {\n      myBuffer.position(address + myAddressInBuffer);\n      myBuffer.put(src, 0, length);\n    }","id":85274,"modified_method":"protected final void putBytes(int address, ByteBuffer buffer) {\n      myBuffer.position(address + myAddressInBuffer);\n      myBuffer.put(buffer);\n    }","commit_id":"00694da4fd44c8dcdc10dd30433f23b4aab47849","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void writeServers(final XMLExtendedStreamWriter writer, final ModelNode modelNode) throws XMLStreamException {\n        writer.writeStartElement(Element.SERVERS.getLocalName());\n\n        for (Property prop : modelNode.asPropertyList()) {\n            final ModelNode server = prop.getValue();\n\n            writer.writeStartElement(Element.SERVER.getLocalName());\n\n            writeAttribute(writer, Attribute.NAME, prop.getName());\n            if (server.hasDefined(GROUP)) {\n                writeAttribute(writer, Attribute.GROUP, server.get(GROUP).asString());\n            }\n            if (server.hasDefined(START)) {\n                writeAttribute(writer, Attribute.START, server.get(START).asString());\n            }\n            if (server.hasDefined(PATH)) {\n                writePaths(writer, server.get(PATH));\n            }\n            if (server.hasDefined(SYSTEM_PROPERTY)) {\n                writeProperties(writer, modelNode.get(SYSTEM_PROPERTY), Element.SYSTEM_PROPERTIES);\n            }\n            if (server.hasDefined(INTERFACE)) {\n                writeInterfaces(writer, server.get(INTERFACE));\n            }\n            if (server.hasDefined(JVM)){\n                //TODO\n            }\n            if (server.hasDefined(SOCKET_BINDING_GROUP)) {\n                writer.writeStartElement(Element.SOCKET_BINDING_GROUP.getLocalName());\n                writeAttribute(writer, Attribute.REF, server.get(SOCKET_BINDING_GROUP).asString());\n                if (server.has(SOCKET_BINDING_PORT_OFFSET)) {\n                    writeAttribute(writer, Attribute.PORT_OFFSET, server.get(SOCKET_BINDING_PORT_OFFSET).asString());\n                }\n                writer.writeEndElement();\n            }\n\n            writer.writeEndElement();\n        }\n\n        writer.writeEndElement();\n    }","id":85275,"modified_method":"private void writeServers(final XMLExtendedStreamWriter writer, final ModelNode modelNode) throws XMLStreamException {\n        writer.writeStartElement(Element.SERVERS.getLocalName());\n\n        for (Property prop : modelNode.asPropertyList()) {\n            final ModelNode server = prop.getValue();\n\n            writer.writeStartElement(Element.SERVER.getLocalName());\n\n            writeAttribute(writer, Attribute.NAME, prop.getName());\n            if (server.hasDefined(GROUP)) {\n                writeAttribute(writer, Attribute.GROUP, server.get(GROUP).asString());\n            }\n            if (server.hasDefined(START)) {\n                writeAttribute(writer, Attribute.START, server.get(START).asString());\n            }\n            if (server.hasDefined(PATH)) {\n                writePaths(writer, server.get(PATH));\n            }\n            if (server.hasDefined(SYSTEM_PROPERTY)) {\n                writeProperties(writer, modelNode.get(SYSTEM_PROPERTY), Element.SYSTEM_PROPERTIES);\n            }\n            if (server.hasDefined(INTERFACE)) {\n                writeInterfaces(writer, server.get(INTERFACE));\n            }\n            if (server.hasDefined(JVM)){\n                for(final Property jvm : server.get(JVM).asPropertyList()) {\n                    writeJVMElement(writer, jvm.getName(), jvm.getValue());\n                    break; // TODO just write the first !?\n                }\n            }\n            if (server.hasDefined(SOCKET_BINDING_GROUP)) {\n                writer.writeStartElement(Element.SOCKET_BINDING_GROUP.getLocalName());\n                writeAttribute(writer, Attribute.REF, server.get(SOCKET_BINDING_GROUP).asString());\n                if (server.has(SOCKET_BINDING_PORT_OFFSET)) {\n                    writeAttribute(writer, Attribute.PORT_OFFSET, server.get(SOCKET_BINDING_PORT_OFFSET).asString());\n                }\n                writer.writeEndElement();\n            }\n\n            writer.writeEndElement();\n        }\n\n        writer.writeEndElement();\n    }","commit_id":"ca30107ab0b85ee28bceacc73d2a8bd5735a3cc1","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeContent(final XMLExtendedStreamWriter writer, final ModelMarshallingContext context) throws XMLStreamException {\n\n        final ModelNode modelNode = context.getModelNode();\n\n        writer.writeStartDocument();\n        writer.writeStartElement(Element.HOST.getLocalName());\n\n        if (hasDefinedChild(modelNode, NAME)) {\n            writeAttribute(writer, Attribute.NAME, modelNode.get(NAME).asString());\n        }\n\n        writer.writeDefaultNamespace(Namespace.CURRENT.getUriString());\n        writeNamespaces(writer, modelNode);\n        writeSchemaLocation(writer, modelNode);\n        if (modelNode.hasDefined(EXTENSION)) {\n            writeExtensions(writer, modelNode.get(EXTENSION));\n        }\n        if (modelNode.hasDefined(PATH)) {\n            writePaths(writer, modelNode.get(PATH));\n        }\n\n        if (modelNode.hasDefined(SYSTEM_PROPERTY)) {\n            writeProperties(writer, modelNode.get(SYSTEM_PROPERTY), Element.SYSTEM_PROPERTIES);\n        }\n\n        if (modelNode.hasDefined(MANAGEMENT)) {\n            writeManagement(writer, modelNode.get(MANAGEMENT));\n        }\n\n        //TODO Domain controller\n        if (modelNode.hasDefined(DOMAIN_CONTROLLER)) {\n            writeDomainController(writer, modelNode.get(DOMAIN_CONTROLLER));\n        }\n\n        if (modelNode.hasDefined(INTERFACE)) {\n            writeInterfaces(writer, modelNode.get(INTERFACE));\n        }\n\n        if (modelNode.hasDefined(JVM)) {\n            //TODO\n        }\n\n        if (modelNode.hasDefined(SERVER)) {\n            writeServers(writer, modelNode.get(SERVER));\n        }\n\n        writer.writeEndElement();\n        writer.writeEndDocument();\n    }","id":85276,"modified_method":"@Override\n    public void writeContent(final XMLExtendedStreamWriter writer, final ModelMarshallingContext context) throws XMLStreamException {\n\n        final ModelNode modelNode = context.getModelNode();\n\n        writer.writeStartDocument();\n        writer.writeStartElement(Element.HOST.getLocalName());\n\n        if (hasDefinedChild(modelNode, NAME)) {\n            writeAttribute(writer, Attribute.NAME, modelNode.get(NAME).asString());\n        }\n\n        writer.writeDefaultNamespace(Namespace.CURRENT.getUriString());\n        writeNamespaces(writer, modelNode);\n        writeSchemaLocation(writer, modelNode);\n        if (modelNode.hasDefined(EXTENSION)) {\n            writeExtensions(writer, modelNode.get(EXTENSION));\n        }\n        if (modelNode.hasDefined(PATH)) {\n            writePaths(writer, modelNode.get(PATH));\n        }\n\n        if (modelNode.hasDefined(SYSTEM_PROPERTY)) {\n            writeProperties(writer, modelNode.get(SYSTEM_PROPERTY), Element.SYSTEM_PROPERTIES);\n        }\n\n        if (modelNode.hasDefined(MANAGEMENT)) {\n            writeManagement(writer, modelNode.get(MANAGEMENT));\n        }\n\n        //TODO Domain controller\n        if (modelNode.hasDefined(DOMAIN_CONTROLLER)) {\n            writeDomainController(writer, modelNode.get(DOMAIN_CONTROLLER));\n        }\n\n        if (modelNode.hasDefined(INTERFACE)) {\n            writeInterfaces(writer, modelNode.get(INTERFACE));\n        }\n        if (modelNode.hasDefined(JVM)) {\n            writer.writeStartElement(Element.JVMS.getLocalName());\n            for(final Property jvm : modelNode.get(JVM).asPropertyList()) {\n                writeJVMElement(writer, jvm.getName(), jvm.getValue());\n            }\n            writer.writeEndElement();\n        }\n\n        if (modelNode.hasDefined(SERVER)) {\n            writeServers(writer, modelNode.get(SERVER));\n        }\n\n        writer.writeEndElement();\n        writer.writeEndDocument();\n    }","commit_id":"ca30107ab0b85ee28bceacc73d2a8bd5735a3cc1","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void visitMethodCallExpression(@NotNull PsiMethodCallExpression call){\n        if(containsAssertion){\n            return;\n        }\n        super.visitMethodCallExpression(call);\n        final PsiReferenceExpression methodExpression =\n                call.getMethodExpression();\n        if(methodExpression == null){\n            return;\n        }\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if(methodName == null)\n        {\n            return;\n        }\n        if(methodName.startsWith(\"assert\") || methodName.startsWith(\"fail\")){\n            containsAssertion = true;\n        }\n    }","id":85277,"modified_method":"public void visitMethodCallExpression(\n            @NotNull PsiMethodCallExpression call) {\n        if (containsAssertion) {\n            return;\n        }\n        super.visitMethodCallExpression(call);\n        final PsiReferenceExpression methodExpression =\n                call.getMethodExpression();\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if (methodName == null) {\n            return;\n        }\n        if (methodName.startsWith(\"assert\") || methodName.startsWith(\"fail\")) {\n            containsAssertion = true;\n        }\n    }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isAssertFalse(PsiMethodCallExpression expression) {\n        final PsiReferenceExpression methodExpression =\n                expression.getMethodExpression();\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if (!\"assertFalse\".equals(methodName)) {\n            return false;\n        }\n        final PsiMethod method = (PsiMethod)methodExpression.resolve();\n        if (method == null) {\n            return false;\n        }\n        final PsiClass targetClass = method.getContainingClass();\n        return targetClass != null &&\n                ClassUtils.isSubclass(targetClass,\n                        \"junit.framework.Assert\");\n    }","id":85278,"modified_method":"private static boolean isAssertFalse(PsiMethodCallExpression expression) {\n        final PsiReferenceExpression methodExpression =\n                expression.getMethodExpression();\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if (!\"assertFalse\".equals(methodName)) {\n            return false;\n        }\n        final PsiMethod method = (PsiMethod)methodExpression.resolve();\n        if (method == null) {\n            return false;\n        }\n        final PsiClass targetClass = method.getContainingClass();\n        return targetClass != null &&\n                (ClassUtils.isSubclass(targetClass, \"junit.framework.Assert\") ||\n                        \"org.junit.Assert\".equals(targetClass.getQualifiedName()));\n    }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isAssertTrue(PsiMethodCallExpression expression) {\n        final PsiReferenceExpression methodExpression =\n                expression.getMethodExpression();\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if (!\"assertTrue\".equals(methodName)) {\n            return false;\n        }\n        final PsiMethod method = (PsiMethod)methodExpression.resolve();\n        if (method == null) {\n            return false;\n        }\n        final PsiClass targetClass = method.getContainingClass();\n        return targetClass != null &&\n                ClassUtils.isSubclass(targetClass,\n                        \"junit.framework.Assert\");\n    }","id":85279,"modified_method":"private static boolean isAssertTrue(PsiMethodCallExpression expression) {\n        final PsiReferenceExpression methodExpression =\n                expression.getMethodExpression();\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if (!\"assertTrue\".equals(methodName)) {\n            return false;\n        }\n        final PsiMethod method = (PsiMethod)methodExpression.resolve();\n        if (method == null) {\n            return false;\n        }\n        final PsiClass targetClass = method.getContainingClass();\n        return targetClass != null &&\n                (ClassUtils.isSubclass(targetClass,\n                        \"junit.framework.Assert\") ||\n                        \"org.junit.Assert\".equals(targetClass.getQualifiedName()));\n    }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isAssertEquals(PsiMethodCallExpression expression) {\n        final PsiReferenceExpression methodExpression =\n                expression.getMethodExpression();\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if (!\"assertEquals\".equals(methodName)) {\n            return false;\n        }\n        final PsiMethod method = (PsiMethod)methodExpression.resolve();\n        if (method == null) {\n            return false;\n        }\n        final PsiClass targetClass = method.getContainingClass();\n        return targetClass != null &&\n                ClassUtils.isSubclass(targetClass,\n                        \"junit.framework.Assert\");\n    }","id":85280,"modified_method":"private static boolean isAssertEquals(PsiMethodCallExpression expression) {\n        final PsiReferenceExpression methodExpression =\n                expression.getMethodExpression();\n        @NonNls final String methodName = methodExpression.getReferenceName();\n        if (!\"assertEquals\".equals(methodName)) {\n            return false;\n        }\n        final PsiMethod method = (PsiMethod)methodExpression.resolve();\n        if (method == null) {\n            return false;\n        }\n        final PsiClass targetClass = method.getContainingClass();\n        return targetClass != null &&\n                (ClassUtils.isSubclass(targetClass, \"junit.framework.Assert\") ||\n                        \"org.junit.Assert\".equals(targetClass.getQualifiedName()));\n    }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replaceAssertTrueWithAssertEquals(\n                PsiMethodCallExpression callExpression, Project project)\n                throws IncorrectOperationException {\n            final PsiReferenceExpression methodExpression =\n                    callExpression.getMethodExpression();\n            final PsiMethod method = (PsiMethod)methodExpression.resolve();\n            assert method != null;\n            final PsiParameterList parameterList = method.getParameterList();\n            final PsiParameter[] parameters = parameterList.getParameters();\n            final PsiManager psiManager = callExpression.getManager();\n            final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n            final PsiType stringType =\n                    PsiType.getJavaLangString(psiManager, scope);\n            final PsiType paramType1 = parameters[0].getType();\n            final PsiExpressionList argumentList =\n                    callExpression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            final int testPosition;\n            final PsiExpression message;\n            if (paramType1.equals(stringType) && parameters.length >= 2) {\n                testPosition = 1;\n                message = args[0];\n            } else {\n                testPosition = 0;\n                message = null;\n            }\n            final PsiExpression testArg = args[testPosition];\n            PsiExpression lhs = null;\n            PsiExpression rhs = null;\n            if (testArg instanceof PsiBinaryExpression) {\n                lhs = ((PsiBinaryExpression)testArg).getLOperand();\n                rhs = ((PsiBinaryExpression)testArg).getROperand();\n            } else if (testArg instanceof PsiMethodCallExpression) {\n                final PsiMethodCallExpression call =\n                        (PsiMethodCallExpression)testArg;\n                final PsiReferenceExpression equalityMethodExpression =\n                        call.getMethodExpression();\n                final PsiExpressionList equalityArgumentList =\n                        call.getArgumentList();\n                final PsiExpression[] equalityArgs =\n                        equalityArgumentList.getExpressions();\n                rhs = equalityArgs[0];\n                lhs = equalityMethodExpression.getQualifierExpression();\n            }\n            if (!(lhs instanceof PsiLiteralExpression) &&\n                    rhs instanceof PsiLiteralExpression) {\n                final PsiExpression temp = lhs;\n                lhs = rhs;\n                rhs = temp;\n            }\n            @NonNls final StringBuffer newExpression =\n                    new StringBuffer();\n            newExpression.append(\"assertEquals(\");\n            if (message != null) {\n                newExpression.append(message.getText());\n                newExpression.append(',');\n            }\n            assert lhs != null;\n            newExpression.append(lhs.getText());\n            newExpression.append(',');\n            assert rhs != null;\n            newExpression.append(rhs.getText());\n            if (isFloatingPoint(lhs) || isFloatingPoint(rhs)) {\n                newExpression.append(\",0.0\");\n            }\n            newExpression.append(')');\n            replaceExpression(callExpression,\n                    newExpression.toString());\n        }","id":85281,"modified_method":"private static void replaceAssertTrueWithAssertEquals(\n                PsiMethodCallExpression callExpression, Project project)\n                throws IncorrectOperationException {\n            final PsiReferenceExpression methodExpression =\n                    callExpression.getMethodExpression();\n            final PsiMethod method = (PsiMethod)methodExpression.resolve();\n            assert method != null;\n            final PsiParameterList parameterList = method.getParameterList();\n            final PsiParameter[] parameters = parameterList.getParameters();\n            final PsiManager psiManager = callExpression.getManager();\n            final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n            final PsiType stringType =\n                    PsiType.getJavaLangString(psiManager, scope);\n            final PsiType paramType1 = parameters[0].getType();\n            final PsiExpressionList argumentList =\n                    callExpression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            final int testPosition;\n            final PsiExpression message;\n            if (paramType1.equals(stringType) && parameters.length >= 2) {\n                testPosition = 1;\n                message = args[0];\n            } else {\n                testPosition = 0;\n                message = null;\n            }\n            final PsiExpression testArg = args[testPosition];\n            PsiExpression lhs = null;\n            PsiExpression rhs = null;\n            if (testArg instanceof PsiBinaryExpression) {\n                lhs = ((PsiBinaryExpression)testArg).getLOperand();\n                rhs = ((PsiBinaryExpression)testArg).getROperand();\n            } else if (testArg instanceof PsiMethodCallExpression) {\n                final PsiMethodCallExpression call =\n                        (PsiMethodCallExpression)testArg;\n                final PsiReferenceExpression equalityMethodExpression =\n                        call.getMethodExpression();\n                final PsiExpressionList equalityArgumentList =\n                        call.getArgumentList();\n                final PsiExpression[] equalityArgs =\n                        equalityArgumentList.getExpressions();\n                rhs = equalityArgs[0];\n                lhs = equalityMethodExpression.getQualifierExpression();\n            }\n            if (!(lhs instanceof PsiLiteralExpression) &&\n                    rhs instanceof PsiLiteralExpression) {\n                final PsiExpression temp = lhs;\n                lhs = rhs;\n                rhs = temp;\n            }\n            @NonNls final StringBuffer newExpression =\n                    new StringBuffer();\n            final PsiMethod containingMethod = PsiTreeUtil.getParentOfType(\n                    callExpression, PsiMethod.class);\n            if (containingMethod != null && AnnotationUtil.isAnnotated(\n                    containingMethod, \"org.junit.Test\", true)) {\n                newExpression.append(\"org.junit.Assert.\");\n            }\n            newExpression.append(\"assertEquals(\");\n            if (message != null) {\n                newExpression.append(message.getText());\n                newExpression.append(',');\n            }\n            assert lhs != null;\n            newExpression.append(lhs.getText());\n            newExpression.append(',');\n            assert rhs != null;\n            newExpression.append(rhs.getText());\n            if (isFloatingPoint(lhs) || isFloatingPoint(rhs)) {\n                newExpression.append(\",0.0\");\n            }\n            newExpression.append(')');\n            replaceExpressionAndShorten(callExpression,\n                    newExpression.toString());\n        }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replaceAssertWithFail(\n                PsiMethodCallExpression callExpression)\n                throws IncorrectOperationException {\n            final PsiReferenceExpression methodExpression =\n                    callExpression.getMethodExpression();\n            final PsiMethod method = (PsiMethod)methodExpression.resolve();\n            assert method != null;\n            final PsiParameterList parameterList = method.getParameterList();\n            final PsiParameter[] parameters = parameterList.getParameters();\n            final PsiExpressionList argumentList =\n                    callExpression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            final PsiExpression message;\n            if (parameters.length == 2) {\n                message = args[0];\n            } else {\n                message = null;\n            }\n            @NonNls final StringBuffer newExpression =\n                    new StringBuffer();\n            newExpression.append(\"fail(\");\n            if (message != null) {\n                newExpression.append(message.getText());\n            }\n            newExpression.append(')');\n            replaceExpression(callExpression,\n                    newExpression.toString());\n        }","id":85282,"modified_method":"private static void replaceAssertWithFail(\n                PsiMethodCallExpression callExpression)\n                throws IncorrectOperationException {\n            final PsiReferenceExpression methodExpression =\n                    callExpression.getMethodExpression();\n            final PsiMethod method = (PsiMethod)methodExpression.resolve();\n            assert method != null;\n            final PsiParameterList parameterList = method.getParameterList();\n            final PsiParameter[] parameters = parameterList.getParameters();\n            final PsiExpressionList argumentList =\n                    callExpression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            final PsiExpression message;\n            if (parameters.length == 2) {\n                message = args[0];\n            } else {\n                message = null;\n            }\n            @NonNls final StringBuffer newExpression =\n                    new StringBuffer();\n            final PsiMethod containingMethod = PsiTreeUtil.getParentOfType(callExpression,\n                                                                           PsiMethod.class);\n            if(containingMethod!=null && AnnotationUtil.isAnnotated(containingMethod, \"org.junit.Test\", true))\n            {\n                newExpression.append(\"org.junit.Assert.\");\n            }\n            newExpression.append(\"fail(\");\n            if (message != null) {\n                newExpression.append(message.getText());\n            }\n            newExpression.append(')');\n            replaceExpressionAndShorten(callExpression,\n                    newExpression.toString());\n        }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replaceAssertEqualsWithAssertLiteral(\n                PsiMethodCallExpression callExpression, Project project)\n                throws IncorrectOperationException {\n            final PsiReferenceExpression methodExpression =\n                    callExpression.getMethodExpression();\n            final PsiMethod method = (PsiMethod)methodExpression.resolve();\n            assert method != null;\n            final PsiParameterList parameterList = method.getParameterList();\n            final PsiParameter[] parameters = parameterList.getParameters();\n            final PsiManager psiManager = callExpression.getManager();\n            final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n            final PsiType stringType =\n                    PsiType.getJavaLangString(psiManager, scope);\n            final PsiType paramType1 = parameters[0].getType();\n            final PsiExpressionList argumentList =\n                    callExpression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            final int firstTestPosition;\n            final int secondTestPosition;\n            final PsiExpression message;\n            if (paramType1.equals(stringType) && parameters.length >= 3) {\n                firstTestPosition = 1;\n                secondTestPosition = 2;\n                message = args[0];\n            } else {\n                firstTestPosition = 0;\n                secondTestPosition = 1;\n                message = null;\n            }\n            final PsiExpression firstTestArg = args[firstTestPosition];\n            final PsiExpression secondTestArg = args[secondTestPosition];\n            final String literalValue;\n            final String compareValue;\n            if (isSimpleLiteral(firstTestArg)) {\n                literalValue = firstTestArg.getText();\n                compareValue = secondTestArg.getText();\n            } else {\n                literalValue = secondTestArg.getText();\n                compareValue = firstTestArg.getText();\n            }\n            final String uppercaseLiteralValue =\n                    Character.toUpperCase(literalValue.charAt(0)) +\n                            literalValue.substring(1);\n            @NonNls final StringBuffer newExpression =\n                    new StringBuffer();\n            newExpression.append(\"assert\");\n            newExpression.append(uppercaseLiteralValue);\n            newExpression.append('(');\n            if (message != null) {\n                newExpression.append(message.getText());\n                newExpression.append(',');\n            }\n            newExpression.append(compareValue);\n            newExpression.append(')');\n            replaceExpression(callExpression,\n                    newExpression.toString());\n        }","id":85283,"modified_method":"private static void replaceAssertEqualsWithAssertLiteral(\n                PsiMethodCallExpression callExpression, Project project)\n                throws IncorrectOperationException {\n            final PsiReferenceExpression methodExpression =\n                    callExpression.getMethodExpression();\n            final PsiMethod method = (PsiMethod)methodExpression.resolve();\n            assert method != null;\n            final PsiParameterList parameterList = method.getParameterList();\n            final PsiParameter[] parameters = parameterList.getParameters();\n            final PsiManager psiManager = callExpression.getManager();\n            final GlobalSearchScope scope = GlobalSearchScope.allScope(project);\n            final PsiType stringType =\n                    PsiType.getJavaLangString(psiManager, scope);\n            final PsiType paramType1 = parameters[0].getType();\n            final PsiExpressionList argumentList =\n                    callExpression.getArgumentList();\n            final PsiExpression[] args = argumentList.getExpressions();\n            final int firstTestPosition;\n            final int secondTestPosition;\n            final PsiExpression message;\n            if (paramType1.equals(stringType) && parameters.length >= 3) {\n                firstTestPosition = 1;\n                secondTestPosition = 2;\n                message = args[0];\n            } else {\n                firstTestPosition = 0;\n                secondTestPosition = 1;\n                message = null;\n            }\n            final PsiExpression firstTestArg = args[firstTestPosition];\n            final PsiExpression secondTestArg = args[secondTestPosition];\n            final String literalValue;\n            final String compareValue;\n            if (isSimpleLiteral(firstTestArg)) {\n                literalValue = firstTestArg.getText();\n                compareValue = secondTestArg.getText();\n            } else {\n                literalValue = secondTestArg.getText();\n                compareValue = firstTestArg.getText();\n            }\n            final String uppercaseLiteralValue =\n                    Character.toUpperCase(literalValue.charAt(0)) +\n                            literalValue.substring(1);\n            @NonNls final StringBuffer newExpression =\n                    new StringBuffer();\n            final PsiMethod containingMethod = PsiTreeUtil.getParentOfType(\n                    callExpression, PsiMethod.class);\n            if (containingMethod != null && AnnotationUtil.isAnnotated(\n                    containingMethod, \"org.junit.Test\", true)) {\n                newExpression.append(\"org.junit.Assert.\");\n            }\n            newExpression.append(\"assert\");\n            newExpression.append(uppercaseLiteralValue);\n            newExpression.append('(');\n            if (message != null) {\n                newExpression.append(message.getText());\n                newExpression.append(',');\n            }\n            newExpression.append(compareValue);\n            newExpression.append(')');\n            replaceExpressionAndShorten(callExpression,\n                    newExpression.toString());\n        }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected InspectionGadgetsFix buildFix(PsiElement location) {\n        return new MoveClassFix();\n    }","id":85284,"modified_method":"protected InspectionGadgetsFix buildFix(PsiElement location) {\n        return fix;\n    }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethod(@NotNull PsiMethod method) {\n            //note: no call to super;\n            @NonNls final String methodName = method.getName();\n            if (!methodName.startsWith(\"test\")) {\n                return;\n            }\n            final PsiType returnType = method.getReturnType();\n            if (returnType == null) {\n                return;\n            }\n            final PsiParameterList parameterList = method.getParameterList();\n            final PsiParameter[] parameters = parameterList.getParameters();\n            if (parameters == null) {\n                return;\n            }\n            if (parameters.length == 0\n                    && returnType.equals(PsiType.VOID)\n                    && method.hasModifierProperty(PsiModifier.PUBLIC)) {\n                return;\n            }\n            final PsiClass targetClass = method.getContainingClass();\n            if (targetClass == null ||\n                    !ClassUtils.isSubclass(targetClass,\n                            \"junit.framework.TestCase\")) {\n                return;\n            }\n            registerMethodError(method);\n        }","id":85285,"modified_method":"public void visitMethod(@NotNull PsiMethod method) {\n            //note: no call to super;\n            @NonNls final String methodName = method.getName();\n            if (!methodName.startsWith(\"test\") && !AnnotationUtil.isAnnotated(\n                    method, \"org.junit.Test\", true)) {\n                return;\n            }\n            final PsiType returnType = method.getReturnType();\n            if (returnType == null) {\n                return;\n            }\n            final PsiParameterList parameterList = method.getParameterList();\n            if (parameterList == null) {\n                return;\n            }\n            final PsiParameter[] parameters = parameterList.getParameters();\n            if (parameters == null) {\n                return;\n            }\n            if (parameters.length == 0 && returnType.equals(PsiType.VOID) &&\n                    method.hasModifierProperty(PsiModifier.PUBLIC)) {\n                return;\n            }\n            final PsiClass targetClass = method.getContainingClass();\n            if (!AnnotationUtil.isAnnotated(method, \"org.junit.Test\", true)) {\n                if (targetClass == null || !ClassUtils.isSubclass(targetClass,\n                                                                  \"junit.framework.TestCase\"))\n                {\n                    return;\n                }\n            }\n            registerMethodError(method);\n        }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethod(@NotNull PsiMethod method) {\n            super.visitMethod(method);\n            if (!TestUtils.isJUnitTestMethod(method)) {\n                return;\n            }\n            final ContainsAssertionVisitor visitor =\n                    new ContainsAssertionVisitor();\n            method.accept(visitor);\n            if (visitor.containsAssertion()) {\n                return;\n            }\n            registerMethodError(method);\n        }","id":85286,"modified_method":"public void visitMethod(@NotNull PsiMethod method) {\n            super.visitMethod(method);\n            if (!TestUtils.isJUnitTestMethod(method)) {\n                return;\n            }\n            final PsiAnnotation testAnnotation = AnnotationUtil.findAnnotation(\n                    method, Collections.singleton(\"org.junit.Test\"));\n            if (testAnnotation != null) {\n                final PsiAnnotationParameterList parameterList =\n                        testAnnotation.getParameterList();\n                final PsiNameValuePair[] nameValuePairs =\n                        parameterList.getAttributes();\n                for (PsiNameValuePair nameValuePair : nameValuePairs) {\n                    final String parameterName = nameValuePair.getName();\n                    if (\"expected\".equals(parameterName)) {\n                        return;\n                    }\n                }\n            }\n            final ContainsAssertionVisitor visitor = new ContainsAssertionVisitor();\n            method.accept(visitor);\n            if (visitor.containsAssertion()) {\n                return;\n            }\n            registerMethodError(method);\n        }","commit_id":"392ddc7c8aa1bfe71ade11a429ad7d27cb812705","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void checkJavaVersion() {\n        JavaVersion javaVersion = JavaVersion.current();\n        if (!javaVersion.isJava6Compatible()) {\n            throw UnsupportedJavaRuntimeException.usingUnsupportedVersion(\"Gradle Tooling API\", JavaVersion.VERSION_1_6);\n        }\n        if (javaVersion == JavaVersion.VERSION_1_6) {\n            DeprecationLogger.nagUserWith(\"Support for using the Gradle Tooling API with Java 6 is deprecated and will be removed in Gradle 3.0\");\n        }\n    }","id":85287,"modified_method":"private static void checkJavaVersion() {\n        UnsupportedJavaRuntimeException.assertUsingVersion(\"Gradle Tooling API\", JavaVersion.VERSION_1_6);\n        JavaVersion javaVersion = JavaVersion.current();\n        if (javaVersion == JavaVersion.VERSION_1_6) {\n            DeprecationLogger.nagUserWith(\"Support for using the Gradle Tooling API with Java 6 is deprecated and will be removed in Gradle 3.0\");\n        }\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"private ProviderOperationParameters validateAndConvert(BuildParameters buildParameters) {\n        LOGGER.info(\"Tooling API is using target Gradle version: {}.\", GradleVersion.current().getVersion());\n        if (!JavaVersion.current().isJava6Compatible()) {\n            throw UnsupportedJavaRuntimeException.usingUnsupportedVersion(\"Gradle\", JavaVersion.VERSION_1_6);\n        }\n        if (!supportedConsumerVersion) {\n            throw unsupportedConnectionException();\n        }\n        return adapter.adapt(ProviderOperationParameters.class, buildParameters, BuildLogLevelMixIn.class);\n    }","id":85288,"modified_method":"private ProviderOperationParameters validateAndConvert(BuildParameters buildParameters) {\n        LOGGER.info(\"Tooling API is using target Gradle version: {}.\", GradleVersion.current().getVersion());\n        UnsupportedJavaRuntimeException.assertUsingVersion(\"Gradle\", JavaVersion.VERSION_1_6);\n        if (!supportedConsumerVersion) {\n            throw unsupportedConnectionException();\n        }\n        return adapter.adapt(ProviderOperationParameters.class, buildParameters, BuildLogLevelMixIn.class);\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"public Object execute(BuildAction action, BuildRequestContext buildRequestContext, BuildActionParameters actionParameters, ServiceRegistry contextServices) {\n        DefaultGradleLauncher gradleLauncher = (DefaultGradleLauncher) gradleLauncherFactory.newInstance(action.getStartParameter(), buildRequestContext, contextServices);\n        try {\n            gradleLauncher.addStandardOutputListener(buildRequestContext.getOutputListener());\n            gradleLauncher.addStandardErrorListener(buildRequestContext.getErrorListener());\n            if (!JavaVersion.current().isJava7Compatible()) {\n                DeprecationLogger.nagUserWith(\"Support for running Gradle using Java 6 has been deprecated and will be removed in Gradle 3.0\");\n            }\n            DefaultBuildController buildController = new DefaultBuildController(gradleLauncher);\n            buildActionRunner.run(action, buildController);\n            return buildController.result;\n        } finally {\n            gradleLauncher.stop();\n        }\n    }","id":85289,"modified_method":"public Object execute(BuildAction action, BuildRequestContext buildRequestContext, BuildActionParameters actionParameters, ServiceRegistry contextServices) {\n        DefaultGradleLauncher gradleLauncher = (DefaultGradleLauncher) gradleLauncherFactory.newInstance(action.getStartParameter(), buildRequestContext, contextServices);\n        try {\n            gradleLauncher.addStandardOutputListener(buildRequestContext.getOutputListener());\n            gradleLauncher.addStandardErrorListener(buildRequestContext.getErrorListener());\n            DefaultBuildController buildController = new DefaultBuildController(gradleLauncher);\n            buildActionRunner.run(action, buildController);\n            return buildController.result;\n        } finally {\n            gradleLauncher.stop();\n        }\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(ExecutionListener executionListener) {\n        if (!JavaVersion.current().isJava6Compatible()) {\n            throw UnsupportedJavaRuntimeException.usingUnsupportedVersion(\"Gradle\", JavaVersion.VERSION_1_6);\n        }\n        action.execute(executionListener);\n    }","id":85290,"modified_method":"public void execute(ExecutionListener executionListener) {\n        UnsupportedJavaRuntimeException.assertUsingVersion(\"Gradle\", JavaVersion.VERSION_1_7);\n        action.execute(executionListener);\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"public void validate(DaemonParameters parameters) {\n        if (parameters.getEffectiveJvm().equals(Jvm.current())) {\n            return;\n        }\n\n        JavaVersion javaVersion = versionDetector.getJavaVersion(parameters.getEffectiveJvm());\n        if (!javaVersion.isJava6Compatible()) {\n            throw UnsupportedJavaRuntimeException.configuredWithUnsupportedVersion(\"Gradle\", JavaVersion.VERSION_1_6, javaVersion);\n        }\n    }","id":85291,"modified_method":"public void validate(DaemonParameters parameters) {\n        if (parameters.getEffectiveJvm().equals(Jvm.current())) {\n            return;\n        }\n\n        JavaVersion javaVersion = versionDetector.getJavaVersion(parameters.getEffectiveJvm());\n        UnsupportedJavaRuntimeException.assertUsingVersion(\"Gradle\", JavaVersion.VERSION_1_7, javaVersion);\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"public static String normalize(String output) {\n        StringBuilder result = new StringBuilder();\n        List<String> lines;\n        try {\n            lines = CharSource.wrap(output).readLines();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        int i = 0;\n        while (i < lines.size()) {\n            String line = lines.get(i);\n            if (line.contains(\"Support for running Gradle using Java 6 has been deprecated and will be removed in Gradle 3.0\")) {\n                // Assume running build on Java 6, skip over stack trace and ignore\n                i++;\n                while (i < lines.size() && STACK_TRACE_ELEMENT.matcher(lines.get(i)).matches()) {\n                    i++;\n                }\n            } else if (line.contains(\"is deprecated and will be removed in tooling API version 3.0. You should upgrade your Gradle build to use Gradle 1.2 or later.\")) {\n                // Assume you are in a cross-version integration test and want to strip this line.\n                i++;\n            } else if (line.contains(STARTING_DAEMON_MESSAGE)) {\n                // Remove the \"daemon starting\" message\n                i++;\n\n                // Remove daemon reporting lines\n                while (i < lines.size() && !lines.get(i).contains(SUBSEQUENT_BUILDS_FASTER_MESSAGE)) {\n                    i++;\n                }\n\n                // Remove the \"subsequent builds faster\" message\n                i++;\n            } else if (i == lines.size() - 1 && line.matches(\"Total time: [\\\\d\\\\.]+ secs\")) {\n                result.append(\"Total time: 1 secs\");\n                result.append('\\n');\n                i++;\n            } else {\n                result.append(line);\n                result.append('\\n');\n                i++;\n            }\n        }\n\n        return result.toString();\n    }","id":85292,"modified_method":"public static String normalize(String output) {\n        StringBuilder result = new StringBuilder();\n        List<String> lines;\n        try {\n            lines = CharSource.wrap(output).readLines();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n        int i = 0;\n        while (i < lines.size()) {\n            String line = lines.get(i);\n            if (line.contains(STARTING_DAEMON_MESSAGE)) {\n                // Remove the \"daemon starting\" message\n                i++;\n\n                // Remove daemon reporting lines\n                while (i < lines.size() && !lines.get(i).contains(SUBSEQUENT_BUILDS_FASTER_MESSAGE)) {\n                    i++;\n                }\n\n                // Remove the \"subsequent builds faster\" message\n                i++;\n            } else if (i == lines.size() - 1 && line.matches(\"Total time: [\\\\d\\\\.]+ secs\")) {\n                result.append(\"Total time: 1 secs\");\n                result.append('\\n');\n                i++;\n            } else {\n                result.append(line);\n                result.append('\\n');\n                i++;\n            }\n        }\n\n        return result.toString();\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"public static UnsupportedJavaRuntimeException usingUnsupportedVersion(String component, JavaVersion minVersion) {\n        return new UnsupportedJavaRuntimeException(String.format(\"%s %s requires Java %s or later to run. You are currently using Java %s.\", component, GradleVersion.current().getVersion(),\n                minVersion.getMajorVersion(), JavaVersion.current().getMajorVersion()));\n    }","id":85293,"modified_method":"public static void assertUsingVersion(String component, JavaVersion minVersion) throws UnsupportedJavaRuntimeException {\n        JavaVersion current = JavaVersion.current();\n        if (current.compareTo(minVersion) >= 0) {\n            return;\n        }\n        throw new UnsupportedJavaRuntimeException(String.format(\"%s %s requires Java %s or later to run. You are currently using Java %s.\", component, GradleVersion.current().getVersion(),\n            minVersion.getMajorVersion(), current.getMajorVersion()));\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"public static UnsupportedJavaRuntimeException configuredWithUnsupportedVersion(String component, JavaVersion minVersion, JavaVersion configuredVersion) {\n        return new UnsupportedJavaRuntimeException(String.format(\"%s %s requires Java %s or later to run. Your build is currently configured to use Java %s.\", component, GradleVersion.current().getVersion(),\n                minVersion.getMajorVersion(), configuredVersion.getMajorVersion()));\n    }","id":85294,"modified_method":"public static void assertUsingVersion(String component, JavaVersion minVersion, JavaVersion configuredVersion) throws UnsupportedJavaRuntimeException {\n        if (configuredVersion.compareTo(minVersion) >= 0) {\n            return;\n        }\n        throw new UnsupportedJavaRuntimeException(String.format(\"%s %s requires Java %s or later to run. Your build is currently configured to use Java %s.\", component, GradleVersion.current().getVersion(),\n                minVersion.getMajorVersion(), configuredVersion.getMajorVersion()));\n    }","commit_id":"594c5d52761bc5db237cb7b1be9e0e56b0059596","url":"https://github.com/gradle/gradle"},{"original_method":"public void disposeUIResources() {\n    myLanguageLevelConfigurable.disposeUIResources();\n    super.disposeUIResources();\n  }","id":85295,"modified_method":"public void disposeUIResources() {\n    if (myLanguageLevelConfigurable != null) myLanguageLevelConfigurable.disposeUIResources();\n    super.disposeUIResources();\n  }","commit_id":"c32135fb12fe99ad40512c95119289fdad1b475e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    final Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(myMainPanel));\n\n    super.doOKAction();\n\n    if (myPreviewEditor != null) {\n      myPreviewEditor.disposeUIResources();\n    }\n    myPreviewOptions.disposeUIResources();\n    // set keymap\n    ((KeymapManagerImpl)KeymapManager.getInstance()).setActiveKeymap((Keymap)myKeymapComboBox.getSelectedItem());\n    // set color scheme\n    EditorColorsManager.getInstance().setGlobalScheme((EditorColorsScheme)myColorSchemeComboBox.getSelectedItem());\n    // create default todo_pattern for color scheme\n    TodoConfiguration.getInstance().resetToDefaultTodoPatterns();\n\n    final boolean createScript = myCreateScriptCheckbox.isSelected();\n    final boolean createEntry = myCreateEntryCheckBox.isSelected();\n    if (createScript || createEntry) {\n      final String pathName = myScriptPathTextField.getText();\n      final boolean globalEntry = myGlobalEntryCheckBox.isSelected();\n      ProgressManager.getInstance().run(new Task.Backgroundable(project, getTitle()) {\n        @Override\n        public void run(@NotNull final ProgressIndicator indicator) {\n          indicator.setFraction(0.0);\n          if (createScript) {\n            indicator.setText(\"Creating launcher script...\");\n            CreateLauncherScriptAction.createLauncherScript(project, pathName);\n            indicator.setFraction(0.5);\n          }\n          if (createEntry) {\n            CreateDesktopEntryAction.createDesktopEntry(project, indicator, globalEntry);\n          }\n          indicator.setFraction(1.0);\n        }\n      });\n    }\n  }","id":85296,"modified_method":"@Override\n  protected void doOKAction() {\n    final Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(myMainPanel));\n\n    super.doOKAction();\n\n    if (myPreviewEditor != null) {\n      myPreviewEditor.disposeUIResources();\n    }\n    if (myPreviewOptions != null) {\n      myPreviewOptions.disposeUIResources();\n    }\n    // set keymap\n    ((KeymapManagerImpl)KeymapManager.getInstance()).setActiveKeymap((Keymap)myKeymapComboBox.getSelectedItem());\n    // set color scheme\n    EditorColorsManager.getInstance().setGlobalScheme((EditorColorsScheme)myColorSchemeComboBox.getSelectedItem());\n    // create default todo_pattern for color scheme\n    TodoConfiguration.getInstance().resetToDefaultTodoPatterns();\n\n    final boolean createScript = myCreateScriptCheckbox.isSelected();\n    final boolean createEntry = myCreateEntryCheckBox.isSelected();\n    if (createScript || createEntry) {\n      final String pathName = myScriptPathTextField.getText();\n      final boolean globalEntry = myGlobalEntryCheckBox.isSelected();\n      ProgressManager.getInstance().run(new Task.Backgroundable(project, getTitle()) {\n        @Override\n        public void run(@NotNull final ProgressIndicator indicator) {\n          indicator.setFraction(0.0);\n          if (createScript) {\n            indicator.setText(\"Creating launcher script...\");\n            CreateLauncherScriptAction.createLauncherScript(project, pathName);\n            indicator.setFraction(0.5);\n          }\n          if (createEntry) {\n            CreateDesktopEntryAction.createDesktopEntry(project, indicator, globalEntry);\n          }\n          indicator.setFraction(1.0);\n        }\n      });\n    }\n  }","commit_id":"e92760e076870083a7c00ac828844b13815c097d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void tearDown() throws Exception {\n    myConfigurable.disposeUIResources();\n    myConfigurable = null;\n    myTree = null;\n    myRoot = null;\n    myModel = null;\n    super.tearDown();\n  }","id":85297,"modified_method":"@Override\n  protected void tearDown() throws Exception {\n    try {\n      if (myConfigurable != null) myConfigurable.disposeUIResources();\n      myConfigurable = null;\n      myTree = null;\n      myRoot = null;\n      myModel = null;\n    }\n    finally {\n      super.tearDown();\n    }\n  }","commit_id":"4d7e243911a621aa439773f22936aaad76181387","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static LinkageType[] getSuitableFrameworkLinkages(BuildConfigurationNature nature) {\n    if (nature.outputType == OutputType.Library) {\n      return LIB_LINKAGES;\n    }\n    else if (nature.pureAS) {\n      return AS_APP_LINKAGES;\n    }\n    else {\n      return nature.isMobilePlatform() ? FLEX_MOBILE_APP_LINKAGES : FLEX_WEB_OR_DESKTOP_APP_LINKAGES;\n    }\n  }","id":85298,"modified_method":"public static LinkageType[] getSuitableFrameworkLinkages(BuildConfigurationNature nature) {\n    if (nature.isLib()) {\n      return LIB_LINKAGES;\n    }\n    else if (nature.pureAS) {\n      return AS_APP_LINKAGES;\n    }\n    else {\n      return nature.isMobilePlatform() ? FLEX_MOBILE_APP_LINKAGES : FLEX_WEB_OR_DESKTOP_APP_LINKAGES;\n    }\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static LinkageType getDefaultFrameworkLinkage(BuildConfigurationNature nature) {\n    if (nature.outputType == OutputType.Library) {\n      return LinkageType.External;\n    }\n    else if (nature.pureAS) {\n      return LinkageType.Merged;\n    }\n    else if (nature.isWebPlatform()) {\n      return LinkageType.RSL; // Web Flex App\n    }\n    else {\n      return LinkageType.Merged; // AIR Flex App (Desktop or Mobile)\n    }\n  }","id":85299,"modified_method":"public static LinkageType getDefaultFrameworkLinkage(BuildConfigurationNature nature) {\n    if (nature.isLib()) {\n      return LinkageType.External;\n    }\n    else if (nature.pureAS) {\n      return LinkageType.Merged;\n    }\n    else if (nature.isWebPlatform()) {\n      return LinkageType.RSL; // Web Flex App\n    }\n    else {\n      return LinkageType.Merged; // AIR Flex App (Desktop or Mobile)\n    }\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n    public void run() {\n      Collection<FlexIdeBCConfigurable> dependencies = new ArrayList<FlexIdeBCConfigurable>();\n      List<MyTableItem> items = myTable.getItems();\n      for (MyTableItem item : items) {\n        if (item instanceof BCItem) {\n          FlexIdeBCConfigurable configurable = ((BCItem)item).configurable;\n          if (configurable != null) {\n            dependencies.add(configurable);\n          }\n        }\n      }\n\n      Map<Module, List<FlexIdeBCConfigurable>> treeItems = new HashMap<Module, List<FlexIdeBCConfigurable>>();\n      FlexIdeBCConfigurator configurator = FlexIdeModuleStructureExtension.getInstance().getConfigurator();\n      for (Module module : ModuleStructureConfigurable.getInstance(myProject).getModules()) {\n        if (ModuleType.get(module) != FlexModuleType.getInstance()) {\n          continue;\n        }\n        for (NamedConfigurable<FlexIdeBuildConfiguration> configurable : configurator.getBCConfigurables(module)) {\n          FlexIdeBCConfigurable flexIdeBCConfigurable = FlexIdeBCConfigurable.unwrapIfNeeded(configurable);\n          if (dependencies.contains(flexIdeBCConfigurable) ||\n              flexIdeBCConfigurable.getDependenciesConfigurable() == DependenciesConfigurable.this) {\n            continue;\n          }\n          FlexIdeBuildConfiguration.OutputType outputType = flexIdeBCConfigurable.getOutputType();\n          if (outputType != FlexIdeBuildConfiguration.OutputType.Library &&\n              outputType != FlexIdeBuildConfiguration.OutputType.RuntimeLoadedModule) {\n            continue;\n          }\n\n          List<FlexIdeBCConfigurable> list = treeItems.get(module);\n          if (list == null) {\n            list = new ArrayList<FlexIdeBCConfigurable>();\n            treeItems.put(module, list);\n          }\n          list.add(flexIdeBCConfigurable);\n        }\n      }\n\n      if (treeItems.isEmpty()) {\n        Messages.showInfoMessage(myProject, \"No applicable build configurations found\", \"Add Dependency\");\n        return;\n      }\n\n      ChooseBuildConfigurationDialog d = new ChooseBuildConfigurationDialog(myProject, treeItems);\n      d.show();\n      if (!d.isOK()) {\n        return;\n      }\n\n      FlexIdeBCConfigurable[] configurables = d.getSelectedConfigurables();\n      DefaultMutableTreeNode root = myTable.getRoot();\n      for (FlexIdeBCConfigurable configurable : configurables) {\n        root.add(new DefaultMutableTreeNode(new BCItem(configurable), false));\n      }\n      myTable.refresh();\n      myTable.getSelectionModel().clearSelection();\n      int rowCount = myTable.getRowCount();\n      myTable.getSelectionModel().addSelectionInterval(rowCount - configurables.length, rowCount - 1);\n    }","id":85300,"modified_method":"@Override\n    public void run() {\n      Collection<FlexIdeBCConfigurable> dependencies = new ArrayList<FlexIdeBCConfigurable>();\n      List<MyTableItem> items = myTable.getItems();\n      for (MyTableItem item : items) {\n        if (item instanceof BCItem) {\n          FlexIdeBCConfigurable configurable = ((BCItem)item).configurable;\n          if (configurable != null) {\n            dependencies.add(configurable);\n          }\n        }\n      }\n\n      Map<Module, List<FlexIdeBCConfigurable>> treeItems = new HashMap<Module, List<FlexIdeBCConfigurable>>();\n      FlexIdeBCConfigurator configurator = FlexIdeModuleStructureExtension.getInstance().getConfigurator();\n      for (Module module : ModuleStructureConfigurable.getInstance(myProject).getModules()) {\n        if (ModuleType.get(module) != FlexModuleType.getInstance()) {\n          continue;\n        }\n        for (NamedConfigurable<FlexIdeBuildConfiguration> configurable : configurator.getBCConfigurables(module)) {\n          FlexIdeBCConfigurable flexIdeBCConfigurable = FlexIdeBCConfigurable.unwrapIfNeeded(configurable);\n          if (dependencies.contains(flexIdeBCConfigurable) || flexIdeBCConfigurable.isParentFor(DependenciesConfigurable.this)) {\n            continue;\n          }\n          FlexIdeBuildConfiguration.OutputType outputType = flexIdeBCConfigurable.getOutputType();\n          if (outputType != FlexIdeBuildConfiguration.OutputType.Library &&\n              outputType != FlexIdeBuildConfiguration.OutputType.RuntimeLoadedModule) {\n            continue;\n          }\n\n          List<FlexIdeBCConfigurable> list = treeItems.get(module);\n          if (list == null) {\n            list = new ArrayList<FlexIdeBCConfigurable>();\n            treeItems.put(module, list);\n          }\n          list.add(flexIdeBCConfigurable);\n        }\n      }\n\n      if (treeItems.isEmpty()) {\n        Messages.showInfoMessage(myProject, \"No applicable build configurations found\", \"Add Dependency\");\n        return;\n      }\n\n      ChooseBuildConfigurationDialog d = new ChooseBuildConfigurationDialog(myProject, treeItems);\n      d.show();\n      if (!d.isOK()) {\n        return;\n      }\n\n      FlexIdeBCConfigurable[] configurables = d.getSelectedConfigurables();\n      DefaultMutableTreeNode root = myTable.getRoot();\n      for (FlexIdeBCConfigurable configurable : configurables) {\n        root.add(new DefaultMutableTreeNode(new BCItem(configurable), false));\n      }\n      myTable.refresh();\n      myTable.getSelectionModel().clearSelection();\n      int rowCount = myTable.getRowCount();\n      myTable.getSelectionModel().addSelectionInterval(rowCount - configurables.length, rowCount - 1);\n    }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public DependenciesConfigurable(final FlexIdeBuildConfiguration bc, Project project, FlexSdksModifiableModel sdksModel) {\n    mySdksModel = sdksModel;\n    myDependencies = bc.DEPENDENCIES;\n    myProject = project;\n    myNature = bc.getNature();\n\n    myDisposable = Disposer.newDisposable();\n    Disposer.register(myDisposable, mySdkPanel);\n\n    myTargetPlayerLabel.setVisible(myNature.isWebPlatform());\n    myTargetPlayerCombo.setVisible(myNature.isWebPlatform());\n\n    mySdkPanel.addListener(new ChangeListener() {\n      public void stateChanged(final ChangeEvent e) {\n        updateAvailableTargetPlayers();\n        updateComponentSetCombo();\n        updateSdkTableItem(mySdkPanel.getCurrentSdk());\n        myTable.refresh();\n      }\n    }, myDisposable);\n\n    myComponentSetCombo.setModel(new DefaultComboBoxModel(FlexIdeBuildConfiguration.ComponentSet.values()));\n    myComponentSetCombo.setRenderer(new ListCellRendererWrapper<FlexIdeBuildConfiguration.ComponentSet>(myComponentSetCombo.getRenderer()) {\n      public void customize(JList list, FlexIdeBuildConfiguration.ComponentSet value, int index, boolean selected, boolean hasFocus) {\n        setText(value.PRESENTABLE_TEXT);\n      }\n    });\n\n    final LinkageType defaultLinkage = BCUtils.getDefaultFrameworkLinkage(myNature);\n    myFrameworkLinkageCombo\n      .setRenderer(new ListCellRendererWrapper<LinkageType>(myFrameworkLinkageCombo.getRenderer()) {\n        public void customize(JList list, LinkageType value, int index, boolean selected, boolean hasFocus) {\n          if (value == LinkageType.Default) {\n            setText(MessageFormat.format(\"Default ({0})\", defaultLinkage.getLongText()));\n          }\n          else {\n            setText(value.getLongText());\n          }\n        }\n      });\n\n    myFrameworkLinkageCombo.setModel(new DefaultComboBoxModel(BCUtils.getSuitableFrameworkLinkages(myNature)));\n\n    ItemListener updateSdkItemsListener = new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        DefaultMutableTreeNode sdkNode = findSdkNode();\n        FlexSdk currentSdk = mySdkPanel.getCurrentSdk();\n        if (sdkNode != null && currentSdk != null) {\n          updateSdkEntries(sdkNode, currentSdk);\n          myTable.refresh();\n        }\n      }\n    };\n\n    myTargetPlayerCombo.addItemListener(updateSdkItemsListener);\n    myComponentSetCombo.addItemListener(updateSdkItemsListener);\n    myFrameworkLinkageCombo.addItemListener(updateSdkItemsListener);\n\n    myTable = new EditableTreeTable<MyTableItem>(\"\", DEPENDENCY_TYPE_COLUMN) {\n      @Override\n      protected void render(SimpleColoredComponent c, MyTableItem item) {\n        if (item != null) {\n          boolean invalid = item instanceof BCItem && ((BCItem)item).configurable == null;\n          c.append(item.getText(), invalid ? SimpleTextAttributes.ERROR_ATTRIBUTES : SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          c.setIcon(item.getIcon());\n        }\n      }\n    };\n    myTable.setRootVisible(false);\n    myTable.getTree().setShowsRootHandles(true);\n    myTable.getTree().setLineStyleAngled();\n\n    // we need to add listener *before* ToolbarDecorator's, so our listener is invoked after it\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        updateEditButton();\n        updateRemoveButton();\n      }\n    });\n\n    ToolbarDecorator d = ToolbarDecorator.createDecorator(myTable);\n    d.setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        addItem(button);\n      }\n    });\n    d.setRemoveAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton anActionButton) {\n        removeSelection();\n      }\n    });\n    //d.setUpAction(new AnActionButtonRunnable() {\n    //  @Override\n    //  public void run(AnActionButton anActionButton) {\n    //    moveSelection(-1);\n    //  }\n    //});\n    //d.setDownAction(new AnActionButtonRunnable() {\n    //  @Override\n    //  public void run(AnActionButton anActionButton) {\n    //    moveSelection(1);\n    //  }\n    //});\n    myEditAction = new AnActionButton(ProjectBundle.message(\"module.classpath.button.edit\"), IconUtil.getEditIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        MyTableItem item = myTable.getItemAt(myTable.getSelectedRow());\n        editLibrary(((ModuleLibraryItem)item).libraryEntry);\n      }\n    };\n    d.addExtraAction(myEditAction);\n    JPanel panel = d.createPanel();\n    myTablePanel.add(panel, BorderLayout.CENTER);\n    myRemoveButton = ToolbarDecorator.findRemoveButton(panel);\n\n    myTable.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          if (myTable.getSelectedRowCount() == 1) {\n            MyTableItem item = myTable.getItemAt(myTable.getSelectedRow());\n            if (item instanceof BCItem) {\n              FlexIdeBCConfigurable configurable = ((BCItem)item).configurable;\n              if (configurable != null) {\n                Place place = new Place().putPath(ProjectStructureConfigurable.CATEGORY, ModuleStructureConfigurable.getInstance(myProject))\n                  .putPath(MasterDetailsComponent.TREE_OBJECT, configurable.getEditableObject());\n                ProjectStructureConfigurable.getInstance(myProject).navigateTo(place, true);\n              }\n            }\n            else if (item instanceof ModuleLibraryItem) {\n              editLibrary(((ModuleLibraryItem)item).libraryEntry);\n            }\n          }\n        }\n      }\n    });\n\n    FlexIdeModuleStructureExtension.getInstance().getConfigurator().addListener(new FlexIdeBCConfigurator.Listener() {\n      @Override\n      public void moduleRemoved(Module module) {\n        // TODO return if module == this module\n        List<Integer> rowsToRemove = new ArrayList<Integer>();\n        // 1st-level nodes are always visible\n        // 2nd-level nodes cannot refer to BC\n        for (int row = 0; row < myTable.getRowCount(); row++) {\n          MyTableItem item = myTable.getItemAt(row);\n          if (item instanceof BCItem) {\n            FlexIdeBCConfigurable configurable = ((BCItem)item).configurable;\n            if (configurable != null && configurable.getModifiableRootModel().getModule() == module) {\n              rowsToRemove.add(row);\n            }\n          }\n        }\n\n        if (!rowsToRemove.isEmpty()) {\n          DefaultMutableTreeNode root = myTable.getRoot();\n          for (int i = 0; i < rowsToRemove.size(); i++) {\n            root.remove(rowsToRemove.get(i) - i);\n          }\n          myTable.refresh();\n        }\n      }\n\n      @Override\n      public void buildConfigurationRemoved(FlexIdeBCConfigurable configurable) {\n        if (configurable.getDependenciesConfigurable() == DependenciesConfigurable.this) {\n          return;\n        }\n\n        // 1st-level nodes are always visible\n        // 2nd-level nodes cannot refer to BC\n        for (int row = 0; row < myTable.getRowCount(); row++) {\n          MyTableItem item = myTable.getItemAt(row);\n          if (item instanceof BCItem && ((BCItem)item).configurable == configurable) {\n            myTable.getRoot().remove(row);\n            myTable.refresh();\n            // there may be only one dependency on a BC\n            break;\n          }\n        }\n      }\n    }, myDisposable);\n  }","id":85301,"modified_method":"public DependenciesConfigurable(final FlexIdeBuildConfiguration bc, Project project, FlexSdksModifiableModel sdksModel) {\n    mySdksModel = sdksModel;\n    myDependencies = bc.DEPENDENCIES;\n    myProject = project;\n    myNature = bc.getNature();\n\n    myDisposable = Disposer.newDisposable();\n    Disposer.register(myDisposable, mySdkPanel);\n\n    myTargetPlayerLabel.setVisible(myNature.isWebPlatform());\n    myTargetPlayerCombo.setVisible(myNature.isWebPlatform());\n\n    mySdkPanel.addListener(new ChangeListener() {\n      public void stateChanged(final ChangeEvent e) {\n        updateAvailableTargetPlayers();\n        updateComponentSetCombo();\n        updateSdkTableItem(mySdkPanel.getCurrentSdk());\n        myTable.refresh();\n      }\n    }, myDisposable);\n\n    myComponentSetCombo.setModel(new DefaultComboBoxModel(FlexIdeBuildConfiguration.ComponentSet.values()));\n    myComponentSetCombo.setRenderer(new ListCellRendererWrapper<FlexIdeBuildConfiguration.ComponentSet>(myComponentSetCombo.getRenderer()) {\n      public void customize(JList list, FlexIdeBuildConfiguration.ComponentSet value, int index, boolean selected, boolean hasFocus) {\n        setText(value.PRESENTABLE_TEXT);\n      }\n    });\n\n    final LinkageType defaultLinkage = BCUtils.getDefaultFrameworkLinkage(myNature);\n    myFrameworkLinkageCombo\n      .setRenderer(new ListCellRendererWrapper<LinkageType>(myFrameworkLinkageCombo.getRenderer()) {\n        public void customize(JList list, LinkageType value, int index, boolean selected, boolean hasFocus) {\n          if (value == LinkageType.Default) {\n            setText(MessageFormat.format(\"Default ({0})\", defaultLinkage.getLongText()));\n          }\n          else {\n            setText(value.getLongText());\n          }\n        }\n      });\n\n    myFrameworkLinkageCombo.setModel(new DefaultComboBoxModel(BCUtils.getSuitableFrameworkLinkages(myNature)));\n\n    ItemListener updateSdkItemsListener = new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        DefaultMutableTreeNode sdkNode = findSdkNode();\n        FlexSdk currentSdk = mySdkPanel.getCurrentSdk();\n        if (sdkNode != null && currentSdk != null) {\n          updateSdkEntries(sdkNode, currentSdk);\n          myTable.refresh();\n        }\n      }\n    };\n\n    myTargetPlayerCombo.addItemListener(updateSdkItemsListener);\n    myComponentSetCombo.addItemListener(updateSdkItemsListener);\n    myFrameworkLinkageCombo.addItemListener(updateSdkItemsListener);\n\n    myTable = new EditableTreeTable<MyTableItem>(\"\", DEPENDENCY_TYPE_COLUMN) {\n      @Override\n      protected void render(SimpleColoredComponent c, MyTableItem item) {\n        if (item != null) {\n          boolean invalid = item instanceof BCItem && ((BCItem)item).configurable == null;\n          c.append(item.getText(), invalid ? SimpleTextAttributes.ERROR_ATTRIBUTES : SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          c.setIcon(item.getIcon());\n        }\n      }\n    };\n    myTable.setRootVisible(false);\n    myTable.getTree().setShowsRootHandles(true);\n    myTable.getTree().setLineStyleAngled();\n\n    // we need to add listener *before* ToolbarDecorator's, so our listener is invoked after it\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        updateEditButton();\n        updateRemoveButton();\n      }\n    });\n\n    ToolbarDecorator d = ToolbarDecorator.createDecorator(myTable);\n    d.setAddAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton button) {\n        addItem(button);\n      }\n    });\n    d.setRemoveAction(new AnActionButtonRunnable() {\n      @Override\n      public void run(AnActionButton anActionButton) {\n        removeSelection();\n      }\n    });\n    //d.setUpAction(new AnActionButtonRunnable() {\n    //  @Override\n    //  public void run(AnActionButton anActionButton) {\n    //    moveSelection(-1);\n    //  }\n    //});\n    //d.setDownAction(new AnActionButtonRunnable() {\n    //  @Override\n    //  public void run(AnActionButton anActionButton) {\n    //    moveSelection(1);\n    //  }\n    //});\n    myEditAction = new AnActionButton(ProjectBundle.message(\"module.classpath.button.edit\"), IconUtil.getEditIcon()) {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        MyTableItem item = myTable.getItemAt(myTable.getSelectedRow());\n        editLibrary(((ModuleLibraryItem)item).libraryEntry);\n      }\n    };\n    d.addExtraAction(myEditAction);\n    JPanel panel = d.createPanel();\n    myTablePanel.add(panel, BorderLayout.CENTER);\n    myRemoveButton = ToolbarDecorator.findRemoveButton(panel);\n\n    myTable.addMouseListener(new MouseAdapter() {\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        if (e.getClickCount() == 2) {\n          if (myTable.getSelectedRowCount() == 1) {\n            MyTableItem item = myTable.getItemAt(myTable.getSelectedRow());\n            if (item instanceof BCItem) {\n              FlexIdeBCConfigurable configurable = ((BCItem)item).configurable;\n              if (configurable != null) {\n                Place place = new Place().putPath(ProjectStructureConfigurable.CATEGORY, ModuleStructureConfigurable.getInstance(myProject))\n                  .putPath(MasterDetailsComponent.TREE_OBJECT, configurable.getEditableObject());\n                ProjectStructureConfigurable.getInstance(myProject).navigateTo(place, true);\n              }\n            }\n            else if (item instanceof ModuleLibraryItem) {\n              editLibrary(((ModuleLibraryItem)item).libraryEntry);\n            }\n          }\n        }\n      }\n    });\n\n    FlexIdeModuleStructureExtension.getInstance().getConfigurator().addListener(new FlexIdeBCConfigurator.Listener() {\n      @Override\n      public void moduleRemoved(Module module) {\n        // TODO return if module == this module\n        List<Integer> rowsToRemove = new ArrayList<Integer>();\n        // 1st-level nodes are always visible\n        // 2nd-level nodes cannot refer to BC\n        for (int row = 0; row < myTable.getRowCount(); row++) {\n          MyTableItem item = myTable.getItemAt(row);\n          if (item instanceof BCItem) {\n            FlexIdeBCConfigurable configurable = ((BCItem)item).configurable;\n            if (configurable != null && configurable.getModifiableRootModel().getModule() == module) {\n              rowsToRemove.add(row);\n            }\n          }\n        }\n\n        if (!rowsToRemove.isEmpty()) {\n          DefaultMutableTreeNode root = myTable.getRoot();\n          for (int i = 0; i < rowsToRemove.size(); i++) {\n            root.remove(rowsToRemove.get(i) - i);\n          }\n          myTable.refresh();\n        }\n      }\n\n      @Override\n      public void buildConfigurationRemoved(FlexIdeBCConfigurable configurable) {\n        if (configurable.isParentFor(DependenciesConfigurable.this)) {\n          return;\n        }\n\n        // 1st-level nodes are always visible\n        // 2nd-level nodes cannot refer to BC\n        for (int row = 0; row < myTable.getRowCount(); row++) {\n          MyTableItem item = myTable.getItemAt(row);\n          if (item instanceof BCItem && ((BCItem)item).configurable == configurable) {\n            myTable.getRoot().remove(row);\n            myTable.refresh();\n            // there may be only one dependency on a BC\n            break;\n          }\n        }\n      }\n    }, myDisposable);\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public boolean isModified() {\n    if (!myConfiguration.NAME.equals(myName)) return true;\n    if (myConfiguration.TARGET_PLATFORM != myTargetPlatformCombo.getSelectedItem()) return true;\n    if (myConfiguration.PURE_ACTION_SCRIPT != myPureActionScriptCheckBox.isSelected()) return true;\n    if (myConfiguration.OUTPUT_TYPE != myOutputTypeCombo.getSelectedItem()) return true;\n    if (!myConfiguration.OPTIMIZE_FOR.equals(myOptimizeForCombo.getSelectedItem())) return true;\n    if (!myConfiguration.MAIN_CLASS.equals(myMainClassTextField.getText().trim())) return true;\n    if (!myConfiguration.OUTPUT_FILE_NAME.equals(myOutputFileNameTextField.getText().trim())) return true;\n    if (!myConfiguration.OUTPUT_FOLDER.equals(FileUtil.toSystemIndependentName(myOutputFolderField.getText().trim()))) return true;\n    if (myConfiguration.USE_HTML_WRAPPER != myUseHTMLWrapperCheckBox.isSelected()) return true;\n    if (!myConfiguration.WRAPPER_TEMPLATE_PATH.equals(FileUtil.toSystemIndependentName(myWrapperTemplateTextWithBrowse.getText().trim()))) {\n      return true;\n    }\n\n    if (myDependenciesConfigurable.isModified()) return true;\n    if (myCompilerOptionsConfigurable.isModified()) return true;\n    if (myAirDesktopPackagingConfigurable.isModified()) return true;\n    if (myAndroidPackagingConfigurable.isModified()) return true;\n    if (myIOSPackagingConfigurable.isModified()) return true;\n\n    return false;\n  }","id":85302,"modified_method":"public boolean isModified() {\n    if (!myConfiguration.NAME.equals(myName)) return true;\n    if (myConfiguration.TARGET_PLATFORM != myTargetPlatformCombo.getSelectedItem()) return true;\n    if (myConfiguration.PURE_ACTION_SCRIPT != myPureActionScriptCheckBox.isSelected()) return true;\n    if (myConfiguration.OUTPUT_TYPE != myOutputTypeCombo.getSelectedItem()) return true;\n    if (!myConfiguration.OPTIMIZE_FOR.equals(myOptimizeForCombo.getSelectedItem())) return true;\n    if (!myConfiguration.MAIN_CLASS.equals(myMainClassTextField.getText().trim())) return true;\n    if (!myConfiguration.OUTPUT_FILE_NAME.equals(myOutputFileNameTextField.getText().trim())) return true;\n    if (!myConfiguration.OUTPUT_FOLDER.equals(FileUtil.toSystemIndependentName(myOutputFolderField.getText().trim()))) return true;\n    if (myConfiguration.USE_HTML_WRAPPER != myUseHTMLWrapperCheckBox.isSelected()) return true;\n    if (!myConfiguration.WRAPPER_TEMPLATE_PATH.equals(FileUtil.toSystemIndependentName(myWrapperTemplateTextWithBrowse.getText().trim()))) {\n      return true;\n    }\n\n    if (myDependenciesConfigurable.isModified()) return true;\n    if (myCompilerOptionsConfigurable.isModified()) return true;\n    if (myAirDesktopPackagingConfigurable != null && myAirDesktopPackagingConfigurable.isModified()) return true;\n    if (myAndroidPackagingConfigurable != null && myAndroidPackagingConfigurable.isModified()) return true;\n    if (myIOSPackagingConfigurable != null && myIOSPackagingConfigurable.isModified()) return true;\n\n    return false;\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void disposeUIResources() {\n    if (FlexIdeUtils.isFlatUi()) {\n      myDependenciesConfigurable.disposeUIResources();\n      myCompilerOptionsConfigurable.disposeUIResources();\n      myAirDesktopPackagingConfigurable.disposeUIResources();\n      myAndroidPackagingConfigurable.disposeUIResources();\n      myIOSPackagingConfigurable.disposeUIResources();\n    }\n  }","id":85303,"modified_method":"public void disposeUIResources() {\n    if (FlexIdeUtils.isFlatUi()) {\n      myDependenciesConfigurable.disposeUIResources();\n      myCompilerOptionsConfigurable.disposeUIResources();\n      if (myAirDesktopPackagingConfigurable != null) myAirDesktopPackagingConfigurable.disposeUIResources();\n      if (myAndroidPackagingConfigurable != null) myAndroidPackagingConfigurable.disposeUIResources();\n      if (myIOSPackagingConfigurable != null) myIOSPackagingConfigurable.disposeUIResources();\n    }\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void apply() throws ConfigurationException {\n    applyOwnTo(myConfiguration, true);\n\n    myDependenciesConfigurable.apply();\n    myCompilerOptionsConfigurable.apply();\n    myAirDesktopPackagingConfigurable.apply();\n    myAndroidPackagingConfigurable.apply();\n    myIOSPackagingConfigurable.apply();\n  }","id":85304,"modified_method":"public void apply() throws ConfigurationException {\n    applyOwnTo(myConfiguration, true);\n\n    myDependenciesConfigurable.apply();\n    myCompilerOptionsConfigurable.apply();\n    if (myAirDesktopPackagingConfigurable != null) myAirDesktopPackagingConfigurable.apply();\n    if (myAndroidPackagingConfigurable != null) myAndroidPackagingConfigurable.apply();\n    if (myIOSPackagingConfigurable != null) myIOSPackagingConfigurable.apply();\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public List<NamedConfigurable> getChildren() {\n    List<NamedConfigurable> children = new ArrayList<NamedConfigurable>();\n    children.add(getDependenciesConfigurable());\n    children.add(getCompilerOptionsConfigurable());\n\n    final FlexIdeBuildConfiguration configuration = getEditableObject();\n    switch (configuration.TARGET_PLATFORM) {\n      case Web:\n        break;\n      case Desktop:\n        children.add(getAirDesktopPackagingConfigurable());\n        break;\n      case Mobile:\n        children.add(getAndroidPackagingConfigurable());\n        children.add(getIOSPackagingConfigurable());\n        break;\n    }\n    return children;\n  }","id":85305,"modified_method":"public List<NamedConfigurable> getChildren() {\n    final List<NamedConfigurable> children = new ArrayList<NamedConfigurable>();\n\n    children.add(myDependenciesConfigurable);\n    children.add(myCompilerOptionsConfigurable);\n    ContainerUtil.addIfNotNull(myAirDesktopPackagingConfigurable, children);\n    ContainerUtil.addIfNotNull(myAndroidPackagingConfigurable, children);\n    ContainerUtil.addIfNotNull(myIOSPackagingConfigurable, children);\n\n    return children;\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public DependenciesConfigurable getDependenciesConfigurable() {\n    return myDependenciesConfigurable;\n  }","id":85306,"modified_method":"public boolean isParentFor(final DependenciesConfigurable dependenciesConfigurable) {\n    return myDependenciesConfigurable == dependenciesConfigurable;\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public FlexIdeBCConfigurable(final Module module,\n                               final FlexIdeBuildConfiguration configuration,\n                               final Runnable treeNodeNameUpdater,\n                               final ModifiableRootModel modifiableRootModel, FlexSdksModifiableModel sdksModel) {\n    super(false, treeNodeNameUpdater);\n    myModule = module;\n    myConfiguration = configuration;\n    myTreeNodeNameUpdater = treeNodeNameUpdater;\n    myModifiableRootModel = modifiableRootModel;\n    myName = configuration.NAME;\n\n    myDependenciesConfigurable = new DependenciesConfigurable(configuration, module.getProject(), sdksModel);\n    myCompilerOptionsConfigurable = new CompilerOptionsConfigurable(module, configuration.COMPILER_OPTIONS);\n    myAirDesktopPackagingConfigurable = new AirDesktopPackagingConfigurable(module, configuration.AIR_DESKTOP_PACKAGING_OPTIONS);\n    myAndroidPackagingConfigurable = new AndroidPackagingConfigurable(module.getProject(), configuration.ANDROID_PACKAGING_OPTIONS);\n    myIOSPackagingConfigurable = new IOSPackagingConfigurable(module.getProject(), configuration.IOS_PACKAGING_OPTIONS);\n\n    myNameField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        setDisplayName(myNameField.getText());\n        if (treeNodeNameUpdater != null) {\n          treeNodeNameUpdater.run();\n        }\n      }\n    });\n\n    initCombos();\n    myOutputFolderField.addBrowseFolderListener(null, null, module.getProject(),\n                                                FileChooserDescriptorFactory.createSingleFolderDescriptor());\n\n    myUseHTMLWrapperCheckBox.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        updateControls();\n        IdeFocusManager.getInstance(module.getProject()).requestFocus(myWrapperTemplateTextWithBrowse.getTextField(), true);\n      }\n    });\n\n    final String title = \"Select folder with HTML wrapper template\";\n    final String description = \"Folder must contain 'index.template.html' file which must contain '${swf}' macro.\";\n    myWrapperTemplateTextWithBrowse.addBrowseFolderListener(title, description, module.getProject(),\n                                                            FileChooserDescriptorFactory.createSingleFolderDescriptor());\n  }","id":85307,"modified_method":"public FlexIdeBCConfigurable(final Module module,\n                               final FlexIdeBuildConfiguration configuration,\n                               final Runnable treeNodeNameUpdater,\n                               final ModifiableRootModel modifiableRootModel, FlexSdksModifiableModel sdksModel) {\n    super(false, treeNodeNameUpdater);\n    myModule = module;\n    myConfiguration = configuration;\n    myTreeNodeNameUpdater = treeNodeNameUpdater;\n    myModifiableRootModel = modifiableRootModel;\n    myName = configuration.NAME;\n\n    final BuildConfigurationNature nature = configuration.getNature();\n\n    myDependenciesConfigurable = new DependenciesConfigurable(configuration, module.getProject(), sdksModel);\n    myCompilerOptionsConfigurable = new CompilerOptionsConfigurable(module, configuration.COMPILER_OPTIONS);\n    myAirDesktopPackagingConfigurable = nature.isDesktopPlatform() && nature.isApp()\n                                        ? new AirDesktopPackagingConfigurable(module, configuration.AIR_DESKTOP_PACKAGING_OPTIONS)\n                                        : null;\n    myAndroidPackagingConfigurable = nature.isMobilePlatform() && nature.isApp()\n                                     ? new AndroidPackagingConfigurable(module.getProject(), configuration.ANDROID_PACKAGING_OPTIONS)\n                                     : null;\n    myIOSPackagingConfigurable = nature.isMobilePlatform() && nature.isApp()\n                                 ? new IOSPackagingConfigurable(module.getProject(), configuration.IOS_PACKAGING_OPTIONS)\n                                 : null;\n\n    myNameField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        setDisplayName(myNameField.getText());\n        if (treeNodeNameUpdater != null) {\n          treeNodeNameUpdater.run();\n        }\n      }\n    });\n\n    initCombos();\n    myOutputFolderField.addBrowseFolderListener(null, null, module.getProject(),\n                                                FileChooserDescriptorFactory.createSingleFolderDescriptor());\n\n    myUseHTMLWrapperCheckBox.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        updateControls();\n        IdeFocusManager.getInstance(module.getProject()).requestFocus(myWrapperTemplateTextWithBrowse.getTextField(), true);\n      }\n    });\n\n    final String title = \"Select folder with HTML wrapper template\";\n    final String description = \"Folder must contain 'index.template.html' file which must contain '${swf}' macro.\";\n    myWrapperTemplateTextWithBrowse.addBrowseFolderListener(title, description, module.getProject(),\n                                                            FileChooserDescriptorFactory.createSingleFolderDescriptor());\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void reset() {\n    setDisplayName(myConfiguration.NAME);\n    myTargetPlatformCombo.setSelectedItem(myConfiguration.TARGET_PLATFORM);\n    myPureActionScriptCheckBox.setSelected(myConfiguration.PURE_ACTION_SCRIPT);\n    myOutputTypeCombo.setSelectedItem(myConfiguration.OUTPUT_TYPE);\n    myOptimizeForCombo.setSelectedItem(myConfiguration.OPTIMIZE_FOR);\n\n    myMainClassTextField.setText(myConfiguration.MAIN_CLASS);\n    myOutputFileNameTextField.setText(myConfiguration.OUTPUT_FILE_NAME);\n    myOutputFolderField.setText(FileUtil.toSystemDependentName(myConfiguration.OUTPUT_FOLDER));\n    myUseHTMLWrapperCheckBox.setSelected(myConfiguration.USE_HTML_WRAPPER);\n    myWrapperTemplateTextWithBrowse.setText(FileUtil.toSystemDependentName(myConfiguration.WRAPPER_TEMPLATE_PATH));\n\n    updateControls();\n\n    myDependenciesConfigurable.reset();\n    myCompilerOptionsConfigurable.reset();\n    myAirDesktopPackagingConfigurable.reset();\n    myAndroidPackagingConfigurable.reset();\n    myIOSPackagingConfigurable.reset();\n  }","id":85308,"modified_method":"public void reset() {\n    setDisplayName(myConfiguration.NAME);\n    myTargetPlatformCombo.setSelectedItem(myConfiguration.TARGET_PLATFORM);\n    myPureActionScriptCheckBox.setSelected(myConfiguration.PURE_ACTION_SCRIPT);\n    myOutputTypeCombo.setSelectedItem(myConfiguration.OUTPUT_TYPE);\n    myOptimizeForCombo.setSelectedItem(myConfiguration.OPTIMIZE_FOR);\n\n    myMainClassTextField.setText(myConfiguration.MAIN_CLASS);\n    myOutputFileNameTextField.setText(myConfiguration.OUTPUT_FILE_NAME);\n    myOutputFolderField.setText(FileUtil.toSystemDependentName(myConfiguration.OUTPUT_FOLDER));\n    myUseHTMLWrapperCheckBox.setSelected(myConfiguration.USE_HTML_WRAPPER);\n    myWrapperTemplateTextWithBrowse.setText(FileUtil.toSystemDependentName(myConfiguration.WRAPPER_TEMPLATE_PATH));\n\n    updateControls();\n\n    myDependenciesConfigurable.reset();\n    myCompilerOptionsConfigurable.reset();\n    if (myAirDesktopPackagingConfigurable != null) myAirDesktopPackagingConfigurable.reset();\n    if (myAndroidPackagingConfigurable != null) myAndroidPackagingConfigurable.reset();\n    if (myIOSPackagingConfigurable != null) myIOSPackagingConfigurable.reset();\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void applyTo(final FlexIdeBuildConfiguration configuration, boolean validate) throws ConfigurationException {\n    applyOwnTo(configuration, validate);\n\n    myDependenciesConfigurable.applyTo(configuration.DEPENDENCIES);\n    myCompilerOptionsConfigurable.applyTo(configuration.COMPILER_OPTIONS);\n    myAirDesktopPackagingConfigurable.applyTo(configuration.AIR_DESKTOP_PACKAGING_OPTIONS);\n    myAndroidPackagingConfigurable.applyTo(configuration.ANDROID_PACKAGING_OPTIONS);\n    myIOSPackagingConfigurable.applyTo(configuration.IOS_PACKAGING_OPTIONS);\n  }","id":85309,"modified_method":"private void applyTo(final FlexIdeBuildConfiguration configuration, boolean validate) throws ConfigurationException {\n    applyOwnTo(configuration, validate);\n\n    myDependenciesConfigurable.applyTo(configuration.DEPENDENCIES);\n    myCompilerOptionsConfigurable.applyTo(configuration.COMPILER_OPTIONS);\n    if (myAirDesktopPackagingConfigurable != null) myAirDesktopPackagingConfigurable.applyTo(configuration.AIR_DESKTOP_PACKAGING_OPTIONS);\n    if (myAndroidPackagingConfigurable != null) myAndroidPackagingConfigurable.applyTo(configuration.ANDROID_PACKAGING_OPTIONS);\n    if (myIOSPackagingConfigurable != null) myIOSPackagingConfigurable.applyTo(configuration.IOS_PACKAGING_OPTIONS);\n  }","commit_id":"2b28ffcf17d91e954b9c7525f0d3ddeeafd9d63b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void disposeUIResources() {\n    super.disposeUIResources();\n    myMappings.disposeUIResources();\n    myGeneralPanel.disposeUIResources();\n    myMappings = null;\n  }","id":85310,"modified_method":"@Override\n  public void disposeUIResources() {\n    super.disposeUIResources();\n    if (myMappings != null) {\n      myMappings.disposeUIResources();\n    }\n    if (myGeneralPanel != null) {\n      myGeneralPanel.disposeUIResources();\n    }\n    myMappings = null;\n  }","commit_id":"35ab7ea8baef7e8a14b597f63b9999577e971935","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void dispose() {\n      myPreviewEditor.disposeUIResources();\n      myPreviewOptions.disposeUIResources();\n    }","id":85311,"modified_method":"@Override\n    public void dispose() {\n      if (myPreviewEditor != null) {\n        myPreviewEditor.disposeUIResources();\n      }\n      myPreviewOptions.disposeUIResources();\n    }","commit_id":"45ffe2182db265f939d8216ea202ed3d6bb621c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    final Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(myMainPanel));\n\n    super.doOKAction();\n\n    myPreviewEditor.disposeUIResources();\n    myPreviewOptions.disposeUIResources();\n    // set keymap\n    ((KeymapManagerImpl)KeymapManager.getInstance()).setActiveKeymap((Keymap)myKeymapComboBox.getSelectedItem());\n    // set color scheme\n    EditorColorsManager.getInstance().setGlobalScheme((EditorColorsScheme)myColorSchemeComboBox.getSelectedItem());\n    // create default todo_pattern for color scheme\n    TodoConfiguration.getInstance().resetToDefaultTodoPatterns();\n\n    final boolean createScript = myCreateScriptCheckbox.isSelected();\n    final boolean createEntry = myCreateEntryCheckBox.isSelected();\n    if (createScript || createEntry) {\n      final String pathName = myScriptPathTextField.getText();\n      final boolean globalEntry = myGlobalEntryCheckBox.isSelected();\n      ProgressManager.getInstance().run(new Task.Backgroundable(project, getTitle()) {\n        @Override\n        public void run(@NotNull final ProgressIndicator indicator) {\n          indicator.setFraction(0.0);\n          if (createScript) {\n            indicator.setText(\"Creating launcher script...\");\n            CreateLauncherScriptAction.createLauncherScript(project, pathName);\n            indicator.setFraction(0.5);\n          }\n          if (createEntry) {\n            CreateDesktopEntryAction.createDesktopEntry(project, indicator, globalEntry);\n          }\n          indicator.setFraction(1.0);\n        }\n      });\n    }\n  }","id":85312,"modified_method":"@Override\n  protected void doOKAction() {\n    final Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(myMainPanel));\n\n    super.doOKAction();\n\n    if (myPreviewEditor != null) {\n      myPreviewEditor.disposeUIResources();\n    }\n    myPreviewOptions.disposeUIResources();\n    // set keymap\n    ((KeymapManagerImpl)KeymapManager.getInstance()).setActiveKeymap((Keymap)myKeymapComboBox.getSelectedItem());\n    // set color scheme\n    EditorColorsManager.getInstance().setGlobalScheme((EditorColorsScheme)myColorSchemeComboBox.getSelectedItem());\n    // create default todo_pattern for color scheme\n    TodoConfiguration.getInstance().resetToDefaultTodoPatterns();\n\n    final boolean createScript = myCreateScriptCheckbox.isSelected();\n    final boolean createEntry = myCreateEntryCheckBox.isSelected();\n    if (createScript || createEntry) {\n      final String pathName = myScriptPathTextField.getText();\n      final boolean globalEntry = myGlobalEntryCheckBox.isSelected();\n      ProgressManager.getInstance().run(new Task.Backgroundable(project, getTitle()) {\n        @Override\n        public void run(@NotNull final ProgressIndicator indicator) {\n          indicator.setFraction(0.0);\n          if (createScript) {\n            indicator.setText(\"Creating launcher script...\");\n            CreateLauncherScriptAction.createLauncherScript(project, pathName);\n            indicator.setFraction(0.5);\n          }\n          if (createEntry) {\n            CreateDesktopEntryAction.createDesktopEntry(project, indicator, globalEntry);\n          }\n          indicator.setFraction(1.0);\n        }\n      });\n    }\n  }","commit_id":"45ffe2182db265f939d8216ea202ed3d6bb621c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Iterable<Row> resolve() throws IOException\n    {\n        ArrayList<RowIterator> iters = new ArrayList<RowIterator>(responses.size());\n        int n = 0;\n        for (Message response : responses)\n        {\n            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody(), response.getVersion());\n            n = Math.max(n, reply.rows.size());\n            iters.add(new RowIterator(reply.rows.iterator(), response.getFrom()));\n        }\n        // for each row, compute the combination of all different versions seen, and repair incomplete versions\n        MergeIterator<Pair<Row,InetAddress>, Row> iter = MergeIterator.get(iters, new Comparator<Pair<Row,InetAddress>>()\n        {\n            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)\n            {\n                return o1.left.key.compareTo(o2.left.key);\n            }\n        }, new MergeIterator.Reducer<Pair<Row,InetAddress>, Row>()\n        {\n            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());\n            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());\n            DecoratedKey key;\n\n            public void reduce(Pair<Row,InetAddress> current)\n            {\n                key = current.left.key;\n                versions.add(current.left.cf);\n                versionSources.add(current.right);\n            }\n\n            protected Row getReduced()\n            {\n                ColumnFamily resolved = versions.size() > 1\n                                      ? RowRepairResolver.resolveSuperset(versions)\n                                      : versions.get(0);\n                if (versions.size() < sources.size())\n                {\n                    // add placeholder rows for sources that didn't have any data, so maybeScheduleRepairs sees them\n                    for (InetAddress source : sources)\n                    {\n                        if (!versionSources.contains(source))\n                        {\n                            versions.add(null);\n                            versionSources.add(source);\n                        }\n                    }\n                }\n                RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);\n                versions.clear();\n                versionSources.clear();\n                return new Row(key, resolved);\n            }\n        });\n\n        List<Row> resolvedRows = new ArrayList<Row>(n);\n        while (iter.hasNext())\n            resolvedRows.add(iter.next());\n\n        return resolvedRows;\n    }","id":85313,"modified_method":"public Iterable<Row> resolve() throws IOException\n    {\n        ArrayList<RowIterator> iters = new ArrayList<RowIterator>(responses.size());\n        int n = 0;\n        for (Message response : responses)\n        {\n            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody(), response.getVersion());\n            n = Math.max(n, reply.rows.size());\n            iters.add(new RowIterator(reply.rows.iterator(), response.getFrom()));\n        }\n        // for each row, compute the combination of all different versions seen, and repair incomplete versions\n        MergeIterator<Pair<Row,InetAddress>, Row> iter = MergeIterator.get(iters, new Comparator<Pair<Row,InetAddress>>()\n        {\n            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)\n            {\n                return o1.left.key.compareTo(o2.left.key);\n            }\n        }, new MergeIterator.Reducer<Pair<Row,InetAddress>, Row>()\n        {\n            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());\n            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());\n            DecoratedKey key;\n\n            public void reduce(Pair<Row,InetAddress> current)\n            {\n                key = current.left.key;\n                versions.add(current.left.cf);\n                versionSources.add(current.right);\n            }\n\n            protected Row getReduced()\n            {\n                ColumnFamily resolved = versions.size() > 1\n                                      ? RowRepairResolver.resolveSuperset(versions)\n                                      : versions.get(0);\n                if (versions.size() < sources.size())\n                {\n                    // add placeholder rows for sources that didn't have any data, so maybeScheduleRepairs sees them\n                    for (InetAddress source : sources)\n                    {\n                        if (!versionSources.contains(source))\n                        {\n                            versions.add(null);\n                            versionSources.add(source);\n                        }\n                    }\n                }\n                // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet\n                if (resolved != null)\n                    RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);\n                versions.clear();\n                versionSources.clear();\n                return new Row(key, resolved);\n            }\n        });\n\n        List<Row> resolvedRows = new ArrayList<Row>(n);\n        while (iter.hasNext())\n            resolvedRows.add(iter.next());\n\n        return resolvedRows;\n    }","commit_id":"1caffdfdadf6e11e474790f4099e6627d8b33271","url":"https://github.com/apache/cassandra"},{"original_method":"public Row resolve() throws DigestMismatchException, IOException\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolving \" + replies.size() + \" responses\");\n\n        long startTime = System.currentTimeMillis();\n\t\tList<ColumnFamily> versions = new ArrayList<ColumnFamily>();\n\t\tList<InetAddress> endpoints = new ArrayList<InetAddress>();\n\n        // case 1: validate digests against each other; throw immediately on mismatch.\n        // also, collects data results into versions/endpoints lists.\n        //\n        // results are cleared as we process them, to avoid unnecessary duplication of work\n        // when resolve() is called a second time for read repair on responses that were not\n        // necessary to satisfy ConsistencyLevel.\n        for (Map.Entry<Message, ReadResponse> entry : replies.entrySet())\n        {\n            Message message = entry.getKey();\n            ReadResponse response = entry.getValue();\n            assert !response.isDigestQuery();\n            versions.add(response.row().cf);\n            endpoints.add(message.getFrom());\n        }\n\n        ColumnFamily resolved;\n        if (versions.size() > 1)\n        {\n            resolved = resolveSuperset(versions);\n            if (logger.isDebugEnabled())\n                logger.debug(\"versions merged\");\n            maybeScheduleRepairs(resolved, table, key, versions, endpoints);\n        }\n        else\n        {\n            resolved = versions.get(0);\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolve: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n\t\treturn new Row(key, resolved);\n\t}","id":85314,"modified_method":"public Row resolve() throws DigestMismatchException, IOException\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolving \" + replies.size() + \" responses\");\n\n        long startTime = System.currentTimeMillis();\n\t\tList<ColumnFamily> versions = new ArrayList<ColumnFamily>();\n\t\tList<InetAddress> endpoints = new ArrayList<InetAddress>();\n\n        // case 1: validate digests against each other; throw immediately on mismatch.\n        // also, collects data results into versions/endpoints lists.\n        //\n        // results are cleared as we process them, to avoid unnecessary duplication of work\n        // when resolve() is called a second time for read repair on responses that were not\n        // necessary to satisfy ConsistencyLevel.\n        for (Map.Entry<Message, ReadResponse> entry : replies.entrySet())\n        {\n            Message message = entry.getKey();\n            ReadResponse response = entry.getValue();\n            assert !response.isDigestQuery();\n            versions.add(response.row().cf);\n            endpoints.add(message.getFrom());\n        }\n\n        ColumnFamily resolved;\n        if (versions.size() > 1)\n        {\n            resolved = resolveSuperset(versions);\n            if (logger.isDebugEnabled())\n                logger.debug(\"versions merged\");\n            // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet\n            if (resolved != null)\n                maybeScheduleRepairs(resolved, table, key, versions, endpoints);\n        }\n        else\n        {\n            resolved = versions.get(0);\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolve: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n\t\treturn new Row(key, resolved);\n\t}","commit_id":"1caffdfdadf6e11e474790f4099e6627d8b33271","url":"https://github.com/apache/cassandra"},{"original_method":"public Iterable<Row> resolve() throws IOException\n    {\n        CollatingIterator collator = new CollatingIterator(new Comparator<Pair<Row,InetAddress>>()\n        {\n            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)\n            {\n                return o1.left.key.compareTo(o2.left.key);\n            }\n        });\n\n        int n = 0;\n        for (Message response : responses)\n        {\n            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody(), response.getVersion());\n            n = Math.max(n, reply.rows.size());\n            collator.addIterator(new RowIterator(reply.rows.iterator(), response.getFrom()));\n        }\n\n        // for each row, compute the combination of all different versions seen, and repair incomplete versions\n        return new ReducingIterator<Pair<Row,InetAddress>, Row>(collator)\n        {\n            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());\n            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());\n            DecoratedKey key;\n\n            @Override\n            protected boolean isEqual(Pair<Row, InetAddress> o1, Pair<Row, InetAddress> o2)\n            {\n                return o1.left.key.equals(o2.left.key);\n            }\n\n            public void reduce(Pair<Row,InetAddress> current)\n            {\n                key = current.left.key;\n                versions.add(current.left.cf);\n                versionSources.add(current.right);\n            }\n\n            protected Row getReduced()\n            {\n                ColumnFamily resolved = versions.size() > 1\n                                      ? RowRepairResolver.resolveSuperset(versions)\n                                      : versions.get(0);\n                if (versions.size() < sources.size())\n                {\n                    // add placeholder rows for sources that didn't have any data, so maybeScheduleRepairs sees them\n                    for (InetAddress source : sources)\n                    {\n                        if (!versionSources.contains(source))\n                        {\n                            versions.add(null);\n                            versionSources.add(source);\n                        }\n                    }\n                }\n                RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);\n                versions.clear();\n                versionSources.clear();\n                return new Row(key, resolved);\n            }\n        };\n    }","id":85315,"modified_method":"public Iterable<Row> resolve() throws IOException\n    {\n        CollatingIterator collator = new CollatingIterator(new Comparator<Pair<Row,InetAddress>>()\n        {\n            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)\n            {\n                return o1.left.key.compareTo(o2.left.key);\n            }\n        });\n\n        int n = 0;\n        for (Message response : responses)\n        {\n            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody(), response.getVersion());\n            n = Math.max(n, reply.rows.size());\n            collator.addIterator(new RowIterator(reply.rows.iterator(), response.getFrom()));\n        }\n\n        // for each row, compute the combination of all different versions seen, and repair incomplete versions\n        return new ReducingIterator<Pair<Row,InetAddress>, Row>(collator)\n        {\n            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());\n            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());\n            DecoratedKey key;\n\n            @Override\n            protected boolean isEqual(Pair<Row, InetAddress> o1, Pair<Row, InetAddress> o2)\n            {\n                return o1.left.key.equals(o2.left.key);\n            }\n\n            public void reduce(Pair<Row,InetAddress> current)\n            {\n                key = current.left.key;\n                versions.add(current.left.cf);\n                versionSources.add(current.right);\n            }\n\n            protected Row getReduced()\n            {\n                ColumnFamily resolved = versions.size() > 1\n                                      ? RowRepairResolver.resolveSuperset(versions)\n                                      : versions.get(0);\n                if (versions.size() < sources.size())\n                {\n                    // add placeholder rows for sources that didn't have any data, so maybeScheduleRepairs sees them\n                    for (InetAddress source : sources)\n                    {\n                        if (!versionSources.contains(source))\n                        {\n                            versions.add(null);\n                            versionSources.add(source);\n                        }\n                    }\n                }\n                // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet\n                if (resolved != null)\n                    RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);\n                versions.clear();\n                versionSources.clear();\n                return new Row(key, resolved);\n            }\n        };\n    }","commit_id":"ebe9815431255fceba3b2238814be92360caada7","url":"https://github.com/apache/cassandra"},{"original_method":"public Row resolve() throws DigestMismatchException, IOException\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolving \" + replies.size() + \" responses\");\n\n        long startTime = System.currentTimeMillis();\n\t\tList<ColumnFamily> versions = new ArrayList<ColumnFamily>();\n\t\tList<InetAddress> endpoints = new ArrayList<InetAddress>();\n\n        // case 1: validate digests against each other; throw immediately on mismatch.\n        // also, collects data results into versions/endpoints lists.\n        //\n        // results are cleared as we process them, to avoid unnecessary duplication of work\n        // when resolve() is called a second time for read repair on responses that were not\n        // necessary to satisfy ConsistencyLevel.\n        for (Map.Entry<Message, ReadResponse> entry : replies.entrySet())\n        {\n            Message message = entry.getKey();\n            ReadResponse response = entry.getValue();\n            assert !response.isDigestQuery();\n            versions.add(response.row().cf);\n            endpoints.add(message.getFrom());\n        }\n\n        ColumnFamily resolved;\n        if (versions.size() > 1)\n        {\n            resolved = resolveSuperset(versions);\n            if (logger.isDebugEnabled())\n                logger.debug(\"versions merged\");\n            maybeScheduleRepairs(resolved, table, key, versions, endpoints);\n        }\n        else\n        {\n            resolved = versions.get(0);\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolve: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n\t\treturn new Row(key, resolved);\n\t}","id":85316,"modified_method":"public Row resolve() throws DigestMismatchException, IOException\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolving \" + replies.size() + \" responses\");\n\n        long startTime = System.currentTimeMillis();\n\t\tList<ColumnFamily> versions = new ArrayList<ColumnFamily>();\n\t\tList<InetAddress> endpoints = new ArrayList<InetAddress>();\n\n        // case 1: validate digests against each other; throw immediately on mismatch.\n        // also, collects data results into versions/endpoints lists.\n        //\n        // results are cleared as we process them, to avoid unnecessary duplication of work\n        // when resolve() is called a second time for read repair on responses that were not\n        // necessary to satisfy ConsistencyLevel.\n        for (Map.Entry<Message, ReadResponse> entry : replies.entrySet())\n        {\n            Message message = entry.getKey();\n            ReadResponse response = entry.getValue();\n            assert !response.isDigestQuery();\n            versions.add(response.row().cf);\n            endpoints.add(message.getFrom());\n        }\n\n        ColumnFamily resolved;\n        if (versions.size() > 1)\n        {\n            resolved = resolveSuperset(versions);\n            if (logger.isDebugEnabled())\n                logger.debug(\"versions merged\");\n            // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet\n            if (resolved != null)\n                maybeScheduleRepairs(resolved, table, key, versions, endpoints);\n        }\n        else\n        {\n            resolved = versions.get(0);\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolve: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n\t\treturn new Row(key, resolved);\n\t}","commit_id":"ebe9815431255fceba3b2238814be92360caada7","url":"https://github.com/apache/cassandra"},{"original_method":"public Iterable<Row> resolve() throws IOException\n    {\n        CollatingIterator collator = new CollatingIterator(new Comparator<Pair<Row,InetAddress>>()\n        {\n            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)\n            {\n                return o1.left.key.compareTo(o2.left.key);\n            }\n        });\n\n        int n = 0;\n        for (Message response : responses)\n        {\n            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody());\n            n = Math.max(n, reply.rows.size());\n            collator.addIterator(new RowIterator(reply.rows.iterator(), response.getFrom()));\n        }\n\n        // for each row, compute the combination of all different versions seen, and repair incomplete versions\n        return new ReducingIterator<Pair<Row,InetAddress>, Row>(collator)\n        {\n            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());\n            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());\n            DecoratedKey key;\n\n            @Override\n            protected boolean isEqual(Pair<Row, InetAddress> o1, Pair<Row, InetAddress> o2)\n            {\n                return o1.left.key.equals(o2.left.key);\n            }\n\n            public void reduce(Pair<Row,InetAddress> current)\n            {\n                key = current.left.key;\n                versions.add(current.left.cf);\n                versionSources.add(current.right);\n            }\n\n            protected Row getReduced()\n            {\n                ColumnFamily resolved = versions.size() > 1\n                                      ? RowRepairResolver.resolveSuperset(versions)\n                                      : versions.get(0);\n                if (versions.size() < sources.size())\n                {\n                    // add placeholder rows for sources that didn't have any data, so maybeScheduleRepairs sees them\n                    for (InetAddress source : sources)\n                    {\n                        if (!versionSources.contains(source))\n                        {\n                            versions.add(null);\n                            versionSources.add(source);\n                        }\n                    }\n                }\n                RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);\n                versions.clear();\n                versionSources.clear();\n                return new Row(key, resolved);\n            }\n        };\n    }","id":85317,"modified_method":"public Iterable<Row> resolve() throws IOException\n    {\n        CollatingIterator collator = new CollatingIterator(new Comparator<Pair<Row,InetAddress>>()\n        {\n            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)\n            {\n                return o1.left.key.compareTo(o2.left.key);\n            }\n        });\n\n        int n = 0;\n        for (Message response : responses)\n        {\n            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody());\n            n = Math.max(n, reply.rows.size());\n            collator.addIterator(new RowIterator(reply.rows.iterator(), response.getFrom()));\n        }\n\n        // for each row, compute the combination of all different versions seen, and repair incomplete versions\n        return new ReducingIterator<Pair<Row,InetAddress>, Row>(collator)\n        {\n            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());\n            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());\n            DecoratedKey key;\n\n            @Override\n            protected boolean isEqual(Pair<Row, InetAddress> o1, Pair<Row, InetAddress> o2)\n            {\n                return o1.left.key.equals(o2.left.key);\n            }\n\n            public void reduce(Pair<Row,InetAddress> current)\n            {\n                key = current.left.key;\n                versions.add(current.left.cf);\n                versionSources.add(current.right);\n            }\n\n            protected Row getReduced()\n            {\n                ColumnFamily resolved = versions.size() > 1\n                                      ? RowRepairResolver.resolveSuperset(versions)\n                                      : versions.get(0);\n                if (versions.size() < sources.size())\n                {\n                    // add placeholder rows for sources that didn't have any data, so maybeScheduleRepairs sees them\n                    for (InetAddress source : sources)\n                    {\n                        if (!versionSources.contains(source))\n                        {\n                            versions.add(null);\n                            versionSources.add(source);\n                        }\n                    }\n                }\n                // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet\n                if (resolved != null)\n                    RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);\n                versions.clear();\n                versionSources.clear();\n                return new Row(key, resolved);\n            }\n        };\n    }","commit_id":"058cf7fe690d8db822a891b0b2cd3979b6f42a62","url":"https://github.com/apache/cassandra"},{"original_method":"public Row resolve() throws DigestMismatchException, IOException\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolving \" + replies.size() + \" responses\");\n\n        long startTime = System.currentTimeMillis();\n\t\tList<ColumnFamily> versions = new ArrayList<ColumnFamily>();\n\t\tList<InetAddress> endpoints = new ArrayList<InetAddress>();\n\n        // case 1: validate digests against each other; throw immediately on mismatch.\n        // also, collects data results into versions/endpoints lists.\n        //\n        // results are cleared as we process them, to avoid unnecessary duplication of work\n        // when resolve() is called a second time for read repair on responses that were not\n        // necessary to satisfy ConsistencyLevel.\n        for (Map.Entry<Message, ReadResponse> entry : replies.entrySet())\n        {\n            Message message = entry.getKey();\n            ReadResponse response = entry.getValue();\n            assert !response.isDigestQuery();\n            versions.add(response.row().cf);\n            endpoints.add(message.getFrom());\n        }\n\n        ColumnFamily resolved;\n        if (versions.size() > 1)\n        {\n            resolved = resolveSuperset(versions);\n            if (logger.isDebugEnabled())\n                logger.debug(\"versions merged\");\n            maybeScheduleRepairs(resolved, table, key, versions, endpoints);\n        }\n        else\n        {\n            resolved = versions.get(0);\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolve: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n\t\treturn new Row(key, resolved);\n\t}","id":85318,"modified_method":"public Row resolve() throws DigestMismatchException, IOException\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolving \" + replies.size() + \" responses\");\n\n        long startTime = System.currentTimeMillis();\n\t\tList<ColumnFamily> versions = new ArrayList<ColumnFamily>();\n\t\tList<InetAddress> endpoints = new ArrayList<InetAddress>();\n\n        // case 1: validate digests against each other; throw immediately on mismatch.\n        // also, collects data results into versions/endpoints lists.\n        //\n        // results are cleared as we process them, to avoid unnecessary duplication of work\n        // when resolve() is called a second time for read repair on responses that were not\n        // necessary to satisfy ConsistencyLevel.\n        for (Map.Entry<Message, ReadResponse> entry : replies.entrySet())\n        {\n            Message message = entry.getKey();\n            ReadResponse response = entry.getValue();\n            assert !response.isDigestQuery();\n            versions.add(response.row().cf);\n            endpoints.add(message.getFrom());\n        }\n\n        ColumnFamily resolved;\n        if (versions.size() > 1)\n        {\n            resolved = resolveSuperset(versions);\n            if (logger.isDebugEnabled())\n                logger.debug(\"versions merged\");\n            // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet\n            if (resolved != null)\n                maybeScheduleRepairs(resolved, table, key, versions, endpoints);\n        }\n        else\n        {\n            resolved = versions.get(0);\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"resolve: \" + (System.currentTimeMillis() - startTime) + \" ms.\");\n\t\treturn new Row(key, resolved);\n\t}","commit_id":"058cf7fe690d8db822a891b0b2cd3979b6f42a62","url":"https://github.com/apache/cassandra"},{"original_method":"public Document parse(final DigestURI location, final String mimeType, final String charset, final InputStream source) throws ParserException, InterruptedException {\r\n        \r\n        PDDocument theDocument = null;\r\n        Writer writer = null;\r\n        File writerFile = null;\r\n        try {       \r\n            // reducing thread priority\r\n            Thread.currentThread().setPriority(Thread.MIN_PRIORITY);                        \r\n            \r\n            // deactivating the logging for jMimeMagic\r\n//            Logger theLogger = Logger.getLogger(\"org.pdfbox\");\r\n//            theLogger.setLevel(Level.INFO);            \r\n            \r\n            String docTitle = null, docSubject = null, docAuthor = null, docKeywordStr = null;\r\n            \r\n            // check for interruption\r\n            checkInterruption();\r\n            \r\n            // creating a pdf parser\r\n            final PDFParser parser = new PDFParser(source);\r\n            parser.parse();\r\n                        \r\n            // check for interruption\r\n            checkInterruption();\r\n            \r\n            // creating a text stripper\r\n            final PDFTextStripper stripper = new PDFTextStripper();\r\n            theDocument = parser.getPDDocument();\r\n            \r\n            if (theDocument.isEncrypted()) {\r\n                theDocument.openProtection(new StandardDecryptionMaterial(\"\"));\r\n                final AccessPermission perm = theDocument.getCurrentAccessPermission();\r\n                if (perm == null || !perm.canExtractContent())\r\n                    throw new ParserException(\"Document is encrypted\", location);\r\n            }\r\n            \r\n            // extracting some metadata\r\n            final PDDocumentInformation theDocInfo = theDocument.getDocumentInformation();            \r\n            if (theDocInfo != null) {\r\n                docTitle = theDocInfo.getTitle();\r\n                docSubject = theDocInfo.getSubject();\r\n                docAuthor = theDocInfo.getAuthor();\r\n                docKeywordStr = theDocInfo.getKeywords();\r\n            }            \r\n            \r\n            // creating a writer for output\r\n            if ((this.contentLength == -1) || (this.contentLength > Idiom.MAX_KEEP_IN_MEMORY_SIZE)) {\r\n                writerFile = File.createTempFile(\"pdfParser\",\".prt\");\r\n                writer = new OutputStreamWriter(new FileOutputStream(writerFile),\"UTF-8\");\r\n            } else {\r\n                writer = new CharBuffer(); \r\n            }\r\n            try {\r\n                stripper.writeText(theDocument, writer ); // may throw a NPE\r\n            } catch (Exception e) {\r\n                Log.logWarning(\"pdfParser\", e.getMessage());\r\n            }\r\n            theDocument.close(); theDocument = null;            \r\n            writer.close();\r\n\r\n            \r\n            String[] docKeywords = null;\r\n            if (docKeywordStr != null) docKeywords = docKeywordStr.split(\" |,\");\r\n            \r\n            Document theDoc = null;\r\n            \r\n            if (writer instanceof CharBuffer) {\r\n                final byte[] contentBytes = ((CharBuffer)writer).toString().getBytes(\"UTF-8\");\r\n                theDoc = new Document(\r\n                        location,\r\n                        mimeType,\r\n                        \"UTF-8\",\r\n                        null,\r\n                        docKeywords,\r\n                        (docTitle == null) ? docSubject : docTitle,\r\n                        docAuthor,\r\n                        null,\r\n                        null,\r\n                        contentBytes,\r\n                        null,\r\n                        null);\r\n            } else {\r\n                theDoc = new Document(\r\n                        location,\r\n                        mimeType,\r\n                        \"UTF-8\",\r\n                        null,\r\n                        docKeywords,\r\n                        (docTitle == null) ? docSubject : docTitle,\r\n                        docAuthor,\r\n                        null,\r\n                        null,\r\n                        writerFile,\r\n                        null,\r\n                        null);                \r\n            }\r\n            \r\n            return theDoc;\r\n        }\r\n        catch (final Exception e) {       \r\n            if (e instanceof InterruptedException) throw (InterruptedException) e;\r\n            if (e instanceof ParserException) throw (ParserException) e;\r\n            \r\n            // close the writer\r\n            if (writer != null) try { writer.close(); } catch (final Exception ex) {/* ignore this */}\r\n            \r\n            // delete the file\r\n            if (writerFile != null) FileUtils.deletedelete(writerFile);\r\n            \r\n            Log.logException(e);\r\n            throw new ParserException(\"Unexpected error while parsing pdf file. \" + e.getMessage(),location); \r\n        } finally {\r\n            if (theDocument != null) try { theDocument.close(); } catch (final Exception e) {/* ignore this */}\r\n            if (writer != null)      try { writer.close(); }      catch (final Exception e) {/* ignore this */}\r\n            Thread.currentThread().setPriority(Thread.NORM_PRIORITY);\r\n        }\r\n    }","id":85319,"modified_method":"public Document parse(final DigestURI location, final String mimeType, final String charset, final InputStream source) throws ParserException, InterruptedException {\r\n        \r\n        PDDocument theDocument = null;\r\n        Writer writer = null;\r\n        File writerFile = null;\r\n        \r\n        String docTitle = null, docSubject = null, docAuthor = null, docKeywordStr = null;\r\n        \r\n        // check for interruption\r\n        checkInterruption();\r\n        \r\n        // creating a pdf parser\r\n        final PDFParser parser;\r\n        final PDFTextStripper stripper;\r\n        try {\r\n            Thread.currentThread().setPriority(Thread.MIN_PRIORITY);\r\n            parser = new PDFParser(source);\r\n            parser.parse();\r\n            checkInterruption();\r\n            stripper = new PDFTextStripper();\r\n            theDocument = parser.getPDDocument();\r\n        } catch (IOException e) {\r\n            Log.logException(e);\r\n            throw new ParserException(e.getMessage(), location);\r\n        } finally {\r\n            Thread.currentThread().setPriority(Thread.NORM_PRIORITY);\r\n        }\r\n        \r\n        if (theDocument.isEncrypted()) {\r\n            try {\r\n                theDocument.openProtection(new StandardDecryptionMaterial(\"\"));\r\n            } catch (BadSecurityHandlerException e) {\r\n                Log.logException(e);\r\n                throw new ParserException(\"Document is encrypted (1): \" + e.getMessage(), location);\r\n            } catch (IOException e) {\r\n                Log.logException(e);\r\n                throw new ParserException(\"Document is encrypted (2): \" + e.getMessage(), location);\r\n            } catch (CryptographyException e) {\r\n                Log.logException(e);\r\n                throw new ParserException(\"Document is encrypted (3): \" + e.getMessage(), location);\r\n            }\r\n            final AccessPermission perm = theDocument.getCurrentAccessPermission();\r\n            if (perm == null || !perm.canExtractContent())\r\n                throw new ParserException(\"Document is encrypted and cannot decrypted\", location);\r\n        }\r\n        \r\n        // extracting some metadata\r\n        final PDDocumentInformation theDocInfo = theDocument.getDocumentInformation();            \r\n        if (theDocInfo != null) {\r\n            docTitle = theDocInfo.getTitle();\r\n            docSubject = theDocInfo.getSubject();\r\n            docAuthor = theDocInfo.getAuthor();\r\n            docKeywordStr = theDocInfo.getKeywords();\r\n        }            \r\n        \r\n        try {\r\n            // creating a writer for output\r\n            if ((this.contentLength == -1) || (this.contentLength > Idiom.MAX_KEEP_IN_MEMORY_SIZE)) {\r\n                writerFile = File.createTempFile(\"pdfParser\",\".prt\");\r\n                writer = new OutputStreamWriter(new FileOutputStream(writerFile),\"UTF-8\");\r\n            } else {\r\n                writer = new CharBuffer(); \r\n            }\r\n            try {\r\n                stripper.writeText(theDocument, writer ); // may throw a NPE\r\n            } catch (Exception e) {\r\n                Log.logException(e);\r\n                Log.logWarning(\"pdfParser\", e.getMessage());\r\n            }\r\n            theDocument.close(); theDocument = null;            \r\n            writer.close();\r\n        } catch (IOException e) {\r\n            Log.logException(e);\r\n            // close the writer\r\n            if (writer != null) try { writer.close(); } catch (final Exception ex) {}\r\n            \r\n            // delete the file\r\n            if (writerFile != null) FileUtils.deletedelete(writerFile);\r\n            throw new ParserException(e.getMessage(), location);\r\n        }\r\n            \r\n        String[] docKeywords = null;\r\n        if (docKeywordStr != null) docKeywords = docKeywordStr.split(\" |,\");\r\n        \r\n        Document theDoc = null;\r\n        \r\n        if (writer instanceof CharBuffer) {\r\n            byte[] contentBytes;\r\n            try {\r\n                contentBytes = ((CharBuffer) writer).toString().getBytes(\"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                Log.logException(e);\r\n                throw new ParserException(e.getMessage(), location);\r\n            }\r\n            theDoc = new Document(\r\n                    location,\r\n                    mimeType,\r\n                    \"UTF-8\",\r\n                    null,\r\n                    docKeywords,\r\n                    (docTitle == null) ? docSubject : docTitle,\r\n                    docAuthor,\r\n                    null,\r\n                    null,\r\n                    contentBytes,\r\n                    null,\r\n                    null);\r\n        } else {\r\n            theDoc = new Document(\r\n                    location,\r\n                    mimeType,\r\n                    \"UTF-8\",\r\n                    null,\r\n                    docKeywords,\r\n                    (docTitle == null) ? docSubject : docTitle,\r\n                    docAuthor,\r\n                    null,\r\n                    null,\r\n                    writerFile,\r\n                    null,\r\n                    null);                \r\n        }\r\n        \r\n        return theDoc;\r\n    }","commit_id":"605e896d6c3aa8da2eaa74853077e37f5623a36d","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void doResponse(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream out, final InputStream body) {\n\n        String path = null;\n        try {\n            // getting some connection properties\n            final String method = (String) conProp.get(HeaderFramework.CONNECTION_PROP_METHOD);\n            path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            String argsString = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // is null if no args were given\n            final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n            String clientIP = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); if (clientIP == null) clientIP = \"unknown-host\";\n\n            // check hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            path = UTF8.decodeURL(path);\n\n            // check against hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            // allow proper access to current peer via virtual directory\n            if (path.startsWith(\"/currentyacypeer/\")) {\n            \tpath = path.substring(16);\n            }\n\n            // cache settings\n            boolean nocache = path.contains(\"?\") || body != null;\n\n            // a bad patch to map the /xml/ path to /api/\n            if (path.startsWith(\"/xml/\")) {\n                path = \"/api/\" + path.substring(5);\n            }\n            // another bad patch to map the /util/ path to /api/util/ to support old yacybars\n            if (path.startsWith(\"/util/\")) {\n                path = \"/api/util/\" + path.substring(6);\n            }\n            // one more for bookmarks\n            if (path.startsWith(\"/bookmarks/\")) {\n                path = \"/api/bookmarks/\" + path.substring(11);\n            }\n\n            // these are the 5 cases where an access granted:\n            // (the alternative is that we deliver a 401 to request authorization)\n\n            // -1- the page is not protected; or\n            final boolean protectedPage = path.indexOf(\"_p.\",0) > 0;\n            boolean accessGranted = !protectedPage;\n\n            // -2- a password is not configured; or\n            final String adminAccountBase64MD5 = switchboard.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n            if (!accessGranted) {\n                accessGranted = adminAccountBase64MD5.length() == 0;\n            }\n\n            // -3- access from localhost is granted and access comes from localhost; or\n            final String refererHost = requestHeader.refererHost();\n            if (!accessGranted) {\n                final boolean adminAccountForLocalhost = sb.getConfigBool(\"adminAccountForLocalhost\", false);\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = adminAccountForLocalhost && accessFromLocalhost;\n            }\n\n            // -4- a password is configured and access comes from localhost\n            //     and the realm-value of a http-authentify String is equal to the stored base64MD5; or\n            String realmProp = requestHeader.get(RequestHeader.AUTHORIZATION);\n            if (realmProp != null && realmProp.length() == 0) realmProp = null;\n            final String realmValue = realmProp == null ? null : realmProp.substring(6);\n            if (!accessGranted) {\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = accessFromLocalhost && realmValue != null && realmProp.length() > 6 && (adminAccountBase64MD5.equals(realmValue));\n                Log.logInfo(\"HTTPDFileHandler\", \"access from localhost blocked, clientIP=\" + clientIP);\n            }\n\n            // -5- a password is configured and access comes with matching http-authentify\n            if (!accessGranted) {\n                accessGranted = realmProp != null && realmValue != null && (sb.userDB.hasAdminRight(realmProp, requestHeader.getHeaderCookies()) || adminAccountBase64MD5.equals(Digest.encodeMD5Hex(realmValue)));\n            }\n\n            // in case that we are still not granted we ask for a password\n            if (!accessGranted) {\n                Log.logInfo(\"HTTPD\", \"Wrong log-in for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                final Integer attempts = serverCore.bfHost.get(clientIP);\n                if (attempts == null)\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                else\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n\n                final ResponseHeader responseHeader = getDefaultHeaders(path);\n                responseHeader.put(RequestHeader.WWW_AUTHENTICATE, \"Basic realm=\\\"\" + serverObjects.ADMIN_AUTHENTICATE_MSG + \"\\\"\");\n                final servletProperties tp=new servletProperties();\n                tp.put(\"returnto\", path);\n                HTTPDemon.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, responseHeader);\n                return;\n            }\n\n            // Authentication successful. remove brute-force flag\n            serverCore.bfHost.remove(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n\n            // parse arguments\n            serverObjects args = new serverObjects();\n            int argc = 0;\n            if (argsString == null) {\n                // no args here, maybe a POST with multipart extension\n                final int length = requestHeader.getContentLength();\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\n\n                /* don't parse body in case of a POST CGI call since it has to be\n                 * handed over to the CGI script unaltered and parsed by the script\n                 */\n                if (method.equals(HeaderFramework.METHOD_POST) &&\n                        !(switchboard.getConfigBool(\"cgi.allow\", false) &&\n                        matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)))\n                        ) {\n\n                    // if its a POST, it can be either multipart or as args in the body\n                    if ((requestHeader.containsKey(HeaderFramework.CONTENT_TYPE)) &&\n                            (requestHeader.get(HeaderFramework.CONTENT_TYPE).toLowerCase().startsWith(\"multipart\"))) {\n                        // parse multipart\n                        final Map<String, byte[]> files = HTTPDemon.parseMultipart(requestHeader, args, body);\n                        // integrate these files into the args\n                        if (files != null) {\n                            final Iterator<Map.Entry<String, byte[]>> fit = files.entrySet().iterator();\n                            Map.Entry<String, byte[]> entry;\n                            while (fit.hasNext()) {\n                                entry = fit.next();\n                                args.put(entry.getKey() + \"$file\", entry.getValue());\n                            }\n                        }\n                        argc = Integer.parseInt(requestHeader.get(\"ARGC\"));\n                    } else {\n                        // parse args in body\n                        argc = HTTPDemon.parseArgs(args, body, length);\n                    }\n                } else {\n                    // no args\n                    argsString = null;\n                    args = null;\n                    argc = 0;\n                }\n            } else {\n                // simple args in URL (stuff after the \"?\")\n                argc = HTTPDemon.parseArgs(args, argsString);\n            }\n\n            // check for cross site scripting - attacks in request arguments\n            if (args != null && argc > 0) {\n                // check all values for occurrences of script values\n                final Iterator<String> e = args.values().iterator(); // enumeration of values\n                String val;\n                while (e.hasNext()) {\n                    val = e.next();\n                    if ((val != null) && (val.indexOf(\"<script\",0) >= 0) && !path.equals(\"/Crawler_p.html\")) {\n                        // deny request\n                        HTTPDemon.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\n                        return;\n                    }\n                }\n            }\n\n            if (args != null) nocache = true;\n\n            // we are finished with parsing\n            // the result of value hand-over is in args and argc\n            if (path.isEmpty()) {\n                HTTPDemon.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\n                out.flush();\n                return;\n            }\n            File targetClass = null;\n\n            // locate the file\n            if (!path.isEmpty() && path.charAt(0) != '/' && path.charAt(0) != '\\\\') {\n                path = \"/\" + path; // attach leading slash\n            }\n            if (path.endsWith(\"index.html\")) {\n                path = path.substring(0, path.length() - 10);\n            }\n\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\n            if (args != null && (args.containsKey(\"language\"))) {\n                // TODO 9.11.06 Bost: a class with information about available languages is needed.\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\n                localeSelection = args.get(\"language\", localeSelection);\n                if (localeSelection.indexOf('.') != -1)\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf('.'));\n            }\n\n            File targetFile = getLocalizedFile(path, localeSelection);\n            String targetExt = (String) conProp.get(\"EXT\"); if (targetExt == null) targetExt = \"\";\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\n            if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n                String testpath;\n                // look for indexForward setting\n                if (indexForward.length() > 0 && (targetFile = getOverlayedFile(path + indexForward)).exists()) {\n                    testpath = path + indexForward;\n                    targetClass = getOverlayedClass(testpath);\n                    path = testpath;\n                } else {\n                    // attach default file name(s)\n                    for (final String defaultFile : defaultFiles) {\n                        testpath = path + defaultFile;\n                        targetFile = getOverlayedFile(testpath);\n                        targetClass = getOverlayedClass(testpath);\n                        if (targetFile.exists()) {\n                            path = testpath;\n                            break;\n                        }\n                    }\n                }\n                targetFile = getLocalizedFile(path, localeSelection);\n\n                //no defaultfile, send a dirlisting\n                if (targetFile == null || !targetFile.exists() || (targetFile.exists() && targetFile.isDirectory())) {\n                    final StringBuilder aBuffer = new StringBuilder();\n                    aBuffer.append(\"<html>\\n<head>\\n<\/head>\\n<body>\\n<h1>Index of \" + path + \"<\/h1>\\n  <ul>\\n\");\n                    String[] list = targetFile.list();\n                    if (list == null) list = new String[0]; // should not occur!\n                    File f;\n                    String size;\n                    long sz;\n                    String headline, author, description, publisher;\n                    int images, links;\n                    ContentScraper scraper;\n                    for (final String element : list) {\n                        f = new File(targetFile, element);\n                        if (f.isDirectory()) {\n                            aBuffer.append(\"    <li><a href=\\\"\" + path + element + \"/\\\">\" + element + \"/<\/a><br/><\/li>\\n\");\n                        } else {\n                            if (element.endsWith(\"html\") || (element.endsWith(\"htm\"))) {\n                                scraper = ContentScraper.parseResource(f, 10000);\n                                headline = scraper.getTitle();\n                                author = scraper.getAuthor();\n                                publisher = scraper.getPublisher();\n                                description = scraper.getDescription();\n                                images = scraper.getImages().size();\n                                links = scraper.getAnchors().size();\n                            } else {\n                                headline = null;\n                                author = null;\n                                publisher = null;\n                                description = null;\n                                images = 0;\n                                links = 0;\n                            }\n                            sz = f.length();\n                            if (sz < 1024) {\n                                size = sz + \" bytes\";\n                            } else if (sz < 1024 * 1024) {\n                                size = (sz / 1024) + \" KB\";\n                            } else {\n                                size = (sz / 1024 / 1024) + \" MB\";\n                            }\n                            aBuffer.append(\"    <li>\");\n                            if (headline != null && headline.length() > 0) aBuffer.append(\"<a href=\\\"\" + element + \"\\\"><b>\" + headline + \"<\/b><\/a><br/>\");\n                            aBuffer.append(\"<a href=\\\"\" + path + element + \"\\\">\" + element + \"<\/a><br/>\");\n                            if (author != null && author.length() > 0) aBuffer.append(\"Author: \" + author + \"<br/>\");\n                            if (publisher != null && publisher.length() > 0) aBuffer.append(\"Publisher: \" + publisher + \"<br/>\");\n                            if (description != null && description.length() > 0) aBuffer.append(\"Description: \" + description + \"<br/>\");\n                            aBuffer.append(GenericFormatter.SHORT_DAY_FORMATTER.format(new Date(f.lastModified())) + \", \" + size + ((images > 0) ? \", \" + images + \" images\" : \"\") + ((links > 0) ? \", \" + links + \" links\" : \"\") + \"<br/><\/li>\\n\");\n                        }\n                    }\n                    aBuffer.append(\"  <\/ul>\\n<\/body>\\n<\/html>\\n\");\n\n                    // write the list to the client\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, \"text/html; charset=UTF-8\", aBuffer.length(), new Date(targetFile.lastModified()), null, new ResponseHeader(200), null, null, true);\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        out.write(UTF8.getBytes(aBuffer.toString()));\n                    }\n                    return;\n                }\n            } else {\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\n                    if ( !(targetFile.exists()) &&\n                            !((path.endsWith(\"png\")||path.endsWith(\"gif\") ||\n                            matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) ||\n                            path.endsWith(\".stream\")) &&\n                            targetClass!=null ) ){\n                        targetFile = new File(htDocsPath, path);\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\n                    }\n            }\n\n            // implement proxy via url (not in servlet, because we need binary access on ouputStream)\n            if (path.equals(\"/proxy.html\")) {\n            \tfinal List<Pattern> urlProxyAccess = Domains.makePatterns(sb.getConfig(\"proxyURL.access\", Domains.LOCALHOST));\n                final UserDB.Entry user = sb.userDB.getUser(requestHeader);\n                final boolean user_may_see_proxyurl = Domains.matchesList(clientIP, urlProxyAccess) || (user!=null && user.hasRight(UserDB.AccessRight.PROXY_RIGHT));\n            \tif (sb.getConfigBool(\"proxyURL\", false) && user_may_see_proxyurl) {\n            \t\tdoURLProxy(conProp, requestHeader, out);\n            \t\treturn;\n            \t}\n                HTTPDemon.sendRespondError(conProp,out,3,403,\"Access denied\",null,null);\n            }\n\n            // track all files that had been accessed so far\n            if (targetFile != null && targetFile.exists()) {\n                if (args != null && args.size() > 0) sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), path));\n            }\n\n            //File targetClass = rewriteClassFile(targetFile);\n            //We need tp here\n            servletProperties templatePatterns = null;\n            Date targetDate;\n\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\n                // call an image-servlet to produce an on-the-fly - generated image\n                Object img = null;\n                try {\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                    requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"png\");\n                    // in case that there are no args given, args = null or empty hashmap\n                    img = invokeServlet(targetClass, requestHeader, args);\n                } catch (final InvocationTargetException e) {\n                    theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                    e.getMessage() +\n                    \" target exception at \" + targetClass + \": \" +\n                    e.getTargetException().toString() + \":\" +\n                    e.getTargetException().getMessage() +\n                    \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\");\n                    Log.logException(e);\n                    Log.logException(e.getCause());\n                    Log.logException(e.getTargetException());\n                    targetClass = null;\n                }\n                if (img == null) {\n                    // error with image generation; send file-not-found\n                    HTTPDemon.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\n                } else {\n                    if (img instanceof RasterPlotter) {\n                        final RasterPlotter yp = (RasterPlotter) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = RasterPlotter.exportImage(yp.getImage(), targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    if (img instanceof EncodedImage) {\n                        final EncodedImage yp = (EncodedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = yp.getImage();\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    /*\n                    if (img instanceof BufferedImage) {\n                        final BufferedImage i = (BufferedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(); if (height < 0) height = 96; // bad hack\n                        final ByteBuffer result = RasterPlotter.exportImage(i, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    */\n                    if (img instanceof Image) {\n                        final Image i = (Image) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n                        final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null);\n                        final ByteBuffer result = RasterPlotter.exportImage(bi, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                }\n            // old-school CGI execution\n            } else if ((switchboard.getConfigBool(\"cgi.allow\", false) // check if CGI execution is allowed in config\n                    && matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) // \"right\" file extension?\n                    && path.substring(0, path.indexOf(targetFile.getName())).toUpperCase().contains(\"/CGI-BIN/\") // file in right directory?\n                    && targetFile.exists())\n                    ) {\n\n                if (!targetFile.canExecute()) {\n                    HTTPDemon.sendRespondError(\n                            conProp,\n                            out,\n                            -1,\n                            403,\n                            null,\n                            HeaderFramework.http1_1.get(\n                                    Integer.toString(403)),\n                            null);\n                    Log.logWarning(\n                            \"HTTPD\",\n                            \"CGI script \" + targetFile.getPath()\n                            + \" could not be executed due to \"\n                            + \"insufficient access rights.\");\n                } else {\n                    String mimeType = \"text/html\";\n                    int statusCode = 200;\n\n                    final ProcessBuilder pb =\n                            new ProcessBuilder(assembleCommandFromShebang(targetFile));\n                    pb.directory(targetFile.getParentFile());\n\n                    final String fileSeparator =\n                            System.getProperty(\"file.separator\", \"/\");\n\n                    // set environment variables\n                    final Map<String, String> env = pb.environment();\n                    env.put(\n                            \"SERVER_SOFTWARE\",\n                            getDefaultHeaders(path).get(HeaderFramework.SERVER));\n                    env.put(\"SERVER_NAME\", sb.peers.mySeed().getName());\n                    env.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n                    if (httpVersion != null) {\n                        env.put(\"SERVER_PROTOCOL\", httpVersion);\n                    }\n                    env.put(\"SERVER_PORT\", switchboard.getConfig(\"port\", \"8090\"));\n                    env.put(\"REQUEST_METHOD\", method);\n    //                env.put(\"PATH_INFO\", \"\");         // TODO: implement\n    //                env.put(\"PATH_TRANSLATED\", \"\");   // TODO: implement\n                    env.put(\"SCRIPT_NAME\", path);\n                    if (argsString != null) {\n                        env.put(\"QUERY_STRING\", argsString);\n                    }\n                    env.put(\"REMOTE_ADDR\", clientIP);\n    //                env.put(\"AUTH_TYPE\", \"\");         // TODO: implement\n    //                env.put(\"REMOTE_USER\", \"\");       // TODO: implement\n    //                env.put(\"REMOTE_IDENT\", \"\");      // I don't think we need this\n                    env.put(\n                            \"DOCUMENT_ROOT\",\n                            switchboard.getAppPath().getAbsolutePath()\n                            + fileSeparator + switchboard.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\n                    if (requestHeader.getContentType() != null) {\n                        env.put(\"CONTENT_TYPE\", requestHeader.getContentType());\n                    }\n                    if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST)\n                            && body != null) {\n                        env.put(\n                                \"CONTENT_LENGTH\",\n                                Integer.toString(requestHeader.getContentLength()));\n                    }\n\n                    /* add values from request header to environment\n                     * (see: http://hoohoo.ncsa.uiuc.edu/cgi/env.html#headers) */\n                    for (final Map.Entry<String, String> requestHeaderEntry\n                            : requestHeader.entrySet()) {\n                        env.put(\"HTTP_\"\n                            + requestHeaderEntry.getKey().toUpperCase().replace(\"-\", \"_\"),\n                            requestHeaderEntry.getValue());\n                    }\n\n                    int exitValue = 0;\n                    String cgiBody = null;\n                    final StringBuilder error = new StringBuilder(256);\n\n                    try {\n                        // start execution of script\n                        final Process p = pb.start();\n\n                        final OutputStream os =\n                                new BufferedOutputStream(p.getOutputStream());\n\n                        if (method.equalsIgnoreCase(\n                                HeaderFramework.METHOD_POST) && body != null) {\n                            final byte[] buffer = new byte[1024];\n                            int len = requestHeader.getContentLength();\n                            while (len > 0) {\n                                body.read(buffer);\n                                len = len - buffer.length;\n                                os.write(buffer);\n                            }\n                        }\n\n                        os.close();\n\n                        try {\n                            p.waitFor();\n                        } catch (final InterruptedException ex) {\n\n                        }\n\n                        exitValue = p.exitValue();\n\n                        final InputStream is =\n                                new BufferedInputStream(p.getInputStream());\n\n                        final InputStream es =\n                                new BufferedInputStream(p.getErrorStream());\n\n                        final StringBuilder processOutput =\n                                new StringBuilder(1024);\n\n                        while (is.available() > 0) {\n                            processOutput.append((char) is.read());\n                        }\n\n                        while (es.available() > 0) {\n                            error.append((char) es.read());\n                        }\n\n                        int indexOfDelimiter = processOutput.indexOf(\"\\n\\n\", 0);\n                        final String[] cgiHeader;\n                        if (indexOfDelimiter > -1) {\n                            cgiHeader =\n                                    processOutput.substring(\n                                            0, indexOfDelimiter).split(\"\\n\");\n                        } else {\n                            cgiHeader = new String[0];\n                        }\n                        cgiBody = processOutput.substring(indexOfDelimiter + 1);\n\n                        String key;\n                        String value;\n                        for (final String element : cgiHeader) {\n                            indexOfDelimiter = element.indexOf(':');\n                            key = element.substring(0, indexOfDelimiter).trim();\n                            value = element.substring(indexOfDelimiter + 1).trim();\n                            conProp.put(key, value);\n                            if (\"Cache-Control\".equals(key)\n                                    && \"no-cache\".equals(value)) {\n                                nocache = true;\n                            } else if (\"Content-type\".equals(key)) {\n                                mimeType = value;\n                            } else if (\"Status\".equals(key)) {\n                                if (key.length() > 2) {\n                                    try {\n                                        statusCode =\n                                                Integer.parseInt(\n                                                        value.substring(0, 3));\n                                    } catch (final NumberFormatException ex) {\n                                        Log.logWarning(\n                                                \"HTTPD\",\n                                                \"CGI script \" + targetFile.getPath()\n                                                + \" returned illegal status code \\\"\"\n                                                + value + \"\\\".\");\n                                    }\n                                }\n                            }\n                        }\n                    } catch (final IOException ex) {\n                        exitValue = -1;\n                    }\n\n                    /* did the script return an exit value != 0\n                     * and still there is supposed to be\n                     * everything right with the HTTP status?\n                     * -> change status to 500 since 200 would\n                     * be a lie\n                     */\n                    if (exitValue != 0 && statusCode == 200) {\n                        statusCode = 500;\n                    }\n\n                    targetDate = new Date(System.currentTimeMillis());\n\n                    if (cgiBody != null && !cgiBody.isEmpty()) {\n                        HTTPDemon.sendRespondHeader(\n                                conProp,\n                                out,\n                                httpVersion,\n                                statusCode,\n                                null,\n                                mimeType,\n                                cgiBody.length(),\n                                targetDate,\n                                null,\n                                null,\n                                null,\n                                null,\n                                nocache);\n                        out.write(UTF8.getBytes(cgiBody));\n                    } else {\n                        HTTPDemon.sendRespondError(\n                                conProp,\n                                out,\n                                exitValue,\n                                statusCode,\n                                null,\n                                HeaderFramework.http1_1.get(\n                                        Integer.toString(statusCode)),\n                                null);\n                        Log.logWarning(\n                                \"HTTPD\",\n                                \"CGI script \" + targetFile.getPath()\n                                + \" returned exit value \" + exitValue\n                                + \", body empty: \"\n                                + (cgiBody == null || cgiBody.isEmpty()));\n                        if (error.length() > 0) {\n                            Log.logWarning(\"HTTPD\", \"Reported error: \" + error);\n                        }\n                    }\n                }\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\n                // call rewrite-class\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"stream\");\n                //requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\n                //requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\n\n                HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null);\n\n                // in case that there are no args given, args = null or empty hashmap\n                /* servletProperties tp = (servlerObjects) */ invokeServlet(targetClass, requestHeader, args);\n                forceConnectionClose(conProp);\n                return;\n            } else if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n                // we have found a file that can be written to the client\n                // if this file uses templates, then we use the template\n                // re-write - method to create an result\n                String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                String ext = (String) conProp.get(\"EXT\"); if (ext == null) ext = \"\";\n                final boolean zipContent = requestHeader.acceptGzip() && HTTPDemon.shallTransportZipped(\".\" + ext);\n                if (path.endsWith(\"html\") ||\n                        path.endsWith(\"htm\") ||\n                        path.endsWith(\"xml\") ||\n                        path.endsWith(\"json\") ||\n                        path.endsWith(\"rdf\") ||\n                        path.endsWith(\"rss\") ||\n                        path.endsWith(\"csv\") ||\n                        path.endsWith(\"pac\") ||\n                        path.endsWith(\"src\") ||\n                        path.endsWith(\"vcf\") ||\n                        path.endsWith(\"kml\") ||\n                        path.endsWith(\"gpx\") ||\n                        path.endsWith(\"css\") ||\n                        path.endsWith(\"/\") ||\n                        path.equals(\"/robots.txt\")) {\n\n                    /*targetFile = getLocalizedFile(path);\n                    if (!(targetFile.exists())) {\n                        // try to find that file in the htDocsPath\n                        File trialFile = new File(htDocsPath, path);\n                        if (trialFile.exists()) targetFile = trialFile;\n                    }*/\n\n\n                    // call rewrite-class\n\n                    if (targetClass != null) {\n                        // CGI-class: call the class to create a property for rewriting\n                        try {\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                            final int ep = path.lastIndexOf(\".\");\n                            requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.substring(ep + 1));\n                            // in case that there are no args given, args = null or empty hashmap\n                            final Object tmp = invokeServlet(targetClass, requestHeader, args);\n                            if (tmp == null) {\n                                // if no args given, then tp will be an empty Hashtable object (not null)\n                                templatePatterns = new servletProperties();\n                            } else if (tmp instanceof servletProperties) {\n                                templatePatterns = (servletProperties) tmp;\n                            } else {\n                                templatePatterns = new servletProperties((serverObjects) tmp);\n                            }\n                            // check if the servlets requests authentication\n                            if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\n                                // handle brute-force protection\n                                if (realmProp != null) {\n                                    Log.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                                    final Integer attempts = serverCore.bfHost.get(clientIP);\n                                    if (attempts == null)\n                                        serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                                    else\n                                        serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n                                }\n                                // send authentication request to browser\n                                final ResponseHeader headers = getDefaultHeaders(path);\n                                headers.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + templatePatterns.get(serverObjects.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\n                                HTTPDemon.sendRespondHeader(conProp,out,httpVersion,401,headers);\n                                return;\n                            } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\n                                String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\n                                if (location.length() == 0) location = path;\n\n                                final ResponseHeader headers = getDefaultHeaders(path);\n                                headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\n                                headers.put(HeaderFramework.LOCATION,location);\n                                HTTPDemon.sendRespondHeader(conProp,out,httpVersion,302,headers);\n                                return;\n                            }\n                            // add the application version, the uptime and the client name to every rewrite table\n                            templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n                            templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n                            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n                            templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, ((Switchboard) switchboard).peers.myID());\n                            templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n                            final Seed myPeer = sb.peers.mySeed();\n                            templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\n                            templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n                            //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\n                        } catch (final InvocationTargetException e) {\n                            if (e.getCause() instanceof InterruptedException) {\n                                throw new InterruptedException(e.getCause().getMessage());\n                            }\n                            Log.logException(e);\n                            Log.logException(e.getCause());\n                            Log.logException(e.getTargetException());\n                            targetClass = null;\n                            throw e;\n                        }\n                        nocache = true;\n                    }\n\n                    targetDate = new Date(targetFile.lastModified());\n                    Date expireDate = null;\n                    if (templatePatterns == null) {\n                    \t// if the file will not be changed, cache it in the browser\n                    \texpireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    }\n\n\n                    // rewrite the file\n                    InputStream fis = null;\n\n                    // read the file/template\n                    TemplateCacheEntry templateCacheEntry = null;\n                    final long fileSize = targetFile.length();\n                    if (useTemplateCache && fileSize <= 512 * 1024) {\n                        // read from cache\n                        SoftReference<TemplateCacheEntry> ref = templateCache.get(targetFile);\n                        if (ref != null) {\n                            templateCacheEntry = ref.get();\n                            if (templateCacheEntry == null) templateCache.remove(targetFile);\n                        }\n\n                        final Date targetFileDate = new Date(targetFile.lastModified());\n                        if (templateCacheEntry == null || targetFileDate.after(templateCacheEntry.lastModified)) {\n                            // loading the content of the template file into\n                            // a byte array\n                            templateCacheEntry = new TemplateCacheEntry();\n                            templateCacheEntry.lastModified = targetFileDate;\n                            templateCacheEntry.content = FileUtils.read(targetFile);\n\n                            // storing the content into the cache\n                            ref = new SoftReference<TemplateCacheEntry>(templateCacheEntry);\n                            if (MemoryControl.shortStatus()) templateCache.clear();\n                            templateCache.put(targetFile, ref);\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache MISS for file \" + targetFile);\n                        } else {\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache HIT for file \" + targetFile);\n                        }\n\n                        // creating an inputstream needed by the template\n                        // rewrite function\n                        fis = new ByteArrayInputStream(templateCacheEntry.content);\n                        templateCacheEntry = null;\n                    } else if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                        // read file completely into ram, avoid that too many files are open at the same time\n                        fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                    } else {\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\n                    }\n\n                    if (mimeType.startsWith(\"text\")) {\n                        // every text-file distributed by yacy is UTF-8\n                        if (!path.startsWith(\"/repository\")) {\n                            mimeType = mimeType + \"; charset=UTF-8\";\n                        } else {\n                            // detect charset of html-files\n                            if ((path.endsWith(\"html\") || path.endsWith(\"htm\"))) {\n                                // save position\n                                fis.mark(1000);\n                                // scrape document to look up charset\n                                final ScraperInputStream htmlFilter = new ScraperInputStream(fis, \"UTF-8\", new DigestURI(\"http://localhost\"), null, false, 10);\n                                final String charset = htmlParser.patchCharsetEncoding(htmlFilter.detectCharset());\n                                htmlFilter.close();\n                                if (charset != null) mimeType = mimeType + \"; charset=\"+charset;\n                                // reset position\n                                fis.reset();\n                            }\n                        }\n                    }\n\n                    // write the array to the client\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\n                    final boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\n                    final boolean chunked = !method.equals(HeaderFramework.METHOD_HEAD) && !yacyClient && httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1);\n                    if (chunked) {\n                        // send page in chunks and parse SSIs\n                        final ByteBuffer o = new ByteBuffer();\n                        // apply templates\n                        TemplateEngine.writeTemplate(fis, o, templatePatterns, UNRESOLVED_PATTERN);\n                        fis.close();\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        HTTPDemon.sendRespondHeader(conProp, out,\n                                httpVersion, rh.getStatusCode(), null, mimeType, -1,\n                                targetDate, expireDate, rh,\n                                null, \"chunked\", nocache);\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\n                        final ChunkedOutputStream chos = new ChunkedOutputStream(out);\n                        // GZIPOutputStream does not implement flush (this is a bug IMHO)\n                        // so we can't compress this stuff, without loosing the cool SSI trickle feature\n                        ServerSideIncludes.writeSSI(o, chos, realmProp, clientIP, requestHeader);\n                        //chos.write(result);\n                        chos.finish();\n                    } else {\n                        // send page as whole thing, SSIs are not possible\n                        final String contentEncoding = (zipContent) ? \"gzip\" : null;\n                        // apply templates\n                        final ByteBuffer o1 = new ByteBuffer();\n                        TemplateEngine.writeTemplate(fis, o1, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        final ByteBuffer o = new ByteBuffer();\n\n                        if (zipContent) {\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\n                            ServerSideIncludes.writeSSI(o1, zippedOut, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                            zippedOut.finish();\n                            zippedOut.flush();\n                            zippedOut.close();\n                            zippedOut = null;\n                        } else {\n                            ServerSideIncludes.writeSSI(o1, o, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                        }\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        if (method.equals(HeaderFramework.METHOD_HEAD)) {\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, o.length(),\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                        } else {\n                            final byte[] result = o.getBytes(); // this interrupts streaming (bad idea!)\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, result.length,\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                            FileUtils.copy(result, out);\n                        }\n                    }\n                } else { // no html\n\n                    int statusCode = 200;\n                    int rangeStartOffset = 0;\n                    final ResponseHeader header = new ResponseHeader(statusCode);\n\n                    // adding the accept ranges header\n                    header.put(HeaderFramework.ACCEPT_RANGES, \"bytes\");\n\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\n                    String targetMD5 = null;\n                    final File targetMd5File = new File(targetFile + \".md5\");\n                    try {\n                        if (targetMd5File.exists()) {\n                            //String description = null;\n                            targetMD5 = UTF8.String(FileUtils.read(targetMd5File));\n                            final int pos = targetMD5.indexOf('\\n');\n                            if (pos >= 0) {\n                                //description = targetMD5.substring(pos + 1);\n                                targetMD5 = targetMD5.substring(0, pos);\n                            }\n\n                            // using the checksum as ETAG header\n                            header.put(HeaderFramework.ETAG, targetMD5);\n                        }\n                    } catch (final IOException e) {\n                        Log.logException(e);\n                    }\n\n                    if (requestHeader.containsKey(HeaderFramework.RANGE)) {\n                        final Object ifRange = requestHeader.ifRange();\n                        if ((ifRange == null)||\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\n                            final String rangeHeaderVal = requestHeader.get(HeaderFramework.RANGE).trim();\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\n                                final String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\n                                final String[] ranges = rangesVal.split(\",\");\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\n                                    rangeStartOffset = NumberTools.parseIntDecSubstring(ranges[0], 0, ranges[0].length() - 1);\n                                    statusCode = 206;\n                                    header.put(HeaderFramework.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\n                                }\n                            }\n                        }\n                    }\n\n                    // write the file to the client\n                    targetDate = new Date(targetFile.lastModified());\n                    // cache file for one month in browser (but most browsers won't cache for that long)\n                    final Date expireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    final long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\n                    final String contentEncoding  = (zipContent) ? \"gzip\" : null;\n                    final String transferEncoding = (httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) ? \"chunked\" : null;\n                    if (!httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\n\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, expireDate, header, contentEncoding, transferEncoding, nocache);\n\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        ChunkedOutputStream chunkedOut = null;\n                        GZIPOutputStream zipped = null;\n                        OutputStream newOut = out;\n\n                        if (transferEncoding != null) {\n                            chunkedOut = new ChunkedOutputStream(newOut);\n                            newOut = chunkedOut;\n                        }\n                        if (contentEncoding != null) {\n                            zipped = new GZIPOutputStream(newOut);\n                            newOut = zipped;\n                        }\n\n                        FileUtils.copyRange(targetFile, newOut, rangeStartOffset);\n\n                        if (zipped != null) {\n                            zipped.flush();\n                            zipped.finish();\n                        }\n                        if (chunkedOut != null) {\n                            chunkedOut.finish();\n                        }\n\n                        // flush all\n                        try {newOut.flush();}catch (final Exception e) {}\n                    }\n                }\n            } else {\n                HTTPDemon.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\n                return;\n            }\n        } catch (final Exception e) {\n            try {\n                // error handling\n                if (e instanceof NullPointerException) {\n                    Log.logException(e);\n                }\n                int httpStatusCode = 400;\n                final String httpStatusText = null;\n                final StringBuilder errorMessage = new StringBuilder(2000);\n                Exception errorExc = null;\n\n                final String errorMsg = e.getMessage();\n                if (\n                        (e instanceof InterruptedException) ||\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\n                   ) {\n                    errorMessage.append(\"Interruption detected while processing query.\");\n                    httpStatusCode = 503;\n                } else {\n                    if ((errorMsg != null) &&\n                        (\n                           errorMsg.contains(\"Broken pipe\") ||\n                           errorMsg.contains(\"Connection reset\") ||\n                           errorMsg.contains(\"Read timed out\") ||\n                           errorMsg.contains(\"Connection timed out\") ||\n                           errorMsg.contains(\"Software caused connection abort\")\n                       )) {\n                        // client closed the connection, so we just end silently\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\n                    } else {\n                        errorMessage.append(\"Unexpected error while processing query.\");\n                        httpStatusCode = 500;\n                        errorExc = e;\n                    }\n                }\n\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\n                            .append(\"\\nQuery:   \").append(path)\n                            .append(\"\\nClient:  \").append(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP))\n                            .append(\"\\nReason:  \").append(e.getMessage());\n\n                if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                    // sending back an error message to the client\n                    // if we have not already send an http header\n                    HTTPDemon.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(), errorExc);\n                } else {\n                    // otherwise we close the connection\n                    forceConnectionClose(conProp);\n                }\n\n                // if it is an unexpected error we log it\n                if (httpStatusCode == 500) {\n                    theLogger.logWarning(errorMessage.toString(), e);\n                }\n\n            } catch (final Exception ee) {\n                forceConnectionClose(conProp);\n            }\n\n        } finally {\n            try {out.flush();}catch (final Exception e) {}\n        }\n    }","id":85320,"modified_method":"public static void doResponse(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream out, final InputStream body) {\n\n        String path = null;\n        try {\n            // getting some connection properties\n            final String method = (String) conProp.get(HeaderFramework.CONNECTION_PROP_METHOD);\n            path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            String argsString = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // is null if no args were given\n            final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n            String clientIP = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); if (clientIP == null) clientIP = \"unknown-host\";\n\n            // check hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            path = UTF8.decodeURL(path);\n\n            // check against hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            // allow proper access to current peer via virtual directory\n            if (path.startsWith(\"/currentyacypeer/\")) {\n            \tpath = path.substring(16);\n            }\n\n            // cache settings\n            boolean nocache = path.contains(\"?\") || body != null;\n\n            // a bad patch to map the /xml/ path to /api/\n            if (path.startsWith(\"/xml/\")) {\n                path = \"/api/\" + path.substring(5);\n            }\n            // another bad patch to map the /util/ path to /api/util/ to support old yacybars\n            if (path.startsWith(\"/util/\")) {\n                path = \"/api/util/\" + path.substring(6);\n            }\n            // one more for bookmarks\n            if (path.startsWith(\"/bookmarks/\")) {\n                path = \"/api/bookmarks/\" + path.substring(11);\n            }\n\n            // these are the 5 cases where an access granted:\n            // (the alternative is that we deliver a 401 to request authorization)\n\n            // -1- the page is not protected; or\n            final boolean protectedPage = path.indexOf(\"_p.\",0) > 0;\n            boolean accessGranted = !protectedPage;\n\n            // -2- a password is not configured; or\n            final String adminAccountBase64MD5 = switchboard.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n            if (!accessGranted) {\n                accessGranted = adminAccountBase64MD5.length() == 0;\n            }\n\n            // -3- access from localhost is granted and access comes from localhost; or\n            final String refererHost = requestHeader.refererHost();\n            if (!accessGranted) {\n                final boolean adminAccountForLocalhost = sb.getConfigBool(\"adminAccountForLocalhost\", false);\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = adminAccountForLocalhost && accessFromLocalhost;\n            }\n\n            // -4- a password is configured and access comes from localhost\n            //     and the realm-value of a http-authentify String is equal to the stored base64MD5; or\n            String realmProp = requestHeader.get(RequestHeader.AUTHORIZATION);\n            if (realmProp != null && realmProp.length() == 0) realmProp = null;\n            final String realmValue = realmProp == null ? null : realmProp.substring(6);\n            if (!accessGranted) {\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.length() == 0 || Domains.isLocalhost(refererHost));\n                accessGranted = accessFromLocalhost && realmValue != null && realmProp.length() > 6 && (adminAccountBase64MD5.equals(realmValue));\n                Log.logInfo(\"HTTPDFileHandler\", \"access from localhost blocked, clientIP=\" + clientIP);\n            }\n\n            // -5- a password is configured and access comes with matching http-authentify\n            if (!accessGranted) {\n                accessGranted = realmProp != null && realmValue != null && (sb.userDB.hasAdminRight(realmProp, requestHeader.getHeaderCookies()) || adminAccountBase64MD5.equals(Digest.encodeMD5Hex(realmValue)));\n            }\n\n            // in case that we are still not granted we ask for a password\n            if (!accessGranted) {\n                Log.logInfo(\"HTTPD\", \"Wrong log-in for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                final Integer attempts = serverCore.bfHost.get(clientIP);\n                if (attempts == null)\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                else\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n\n                final ResponseHeader responseHeader = getDefaultHeaders(path);\n                responseHeader.put(RequestHeader.WWW_AUTHENTICATE, \"Basic realm=\\\"\" + serverObjects.ADMIN_AUTHENTICATE_MSG + \"\\\"\");\n                final servletProperties tp=new servletProperties();\n                tp.put(\"returnto\", path);\n                HTTPDemon.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, responseHeader);\n                return;\n            }\n\n            // Authentication successful. remove brute-force flag\n            serverCore.bfHost.remove(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n\n            // parse arguments\n            serverObjects args = new serverObjects();\n            int argc = 0;\n            if (argsString == null) {\n                // no args here, maybe a POST with multipart extension\n                final int length = requestHeader.getContentLength();\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\n\n                /* don't parse body in case of a POST CGI call since it has to be\n                 * handed over to the CGI script unaltered and parsed by the script\n                 */\n                if (method.equals(HeaderFramework.METHOD_POST) &&\n                        !(switchboard.getConfigBool(\"cgi.allow\", false) &&\n                        matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)))\n                        ) {\n\n                    // if its a POST, it can be either multipart or as args in the body\n                    if ((requestHeader.containsKey(HeaderFramework.CONTENT_TYPE)) &&\n                            (requestHeader.get(HeaderFramework.CONTENT_TYPE).toLowerCase().startsWith(\"multipart\"))) {\n                        // parse multipart\n                        final Map<String, byte[]> files = HTTPDemon.parseMultipart(requestHeader, args, body);\n                        // integrate these files into the args\n                        if (files != null) {\n                            final Iterator<Map.Entry<String, byte[]>> fit = files.entrySet().iterator();\n                            Map.Entry<String, byte[]> entry;\n                            while (fit.hasNext()) {\n                                entry = fit.next();\n                                args.put(entry.getKey() + \"$file\", entry.getValue());\n                            }\n                        }\n                        argc = Integer.parseInt(requestHeader.get(\"ARGC\"));\n                    } else {\n                        // parse args in body\n                        argc = HTTPDemon.parseArgs(args, body, length);\n                    }\n                } else {\n                    // no args\n                    argsString = null;\n                    args = null;\n                    argc = 0;\n                }\n            } else {\n                // simple args in URL (stuff after the \"?\")\n                argc = HTTPDemon.parseArgs(args, argsString);\n            }\n\n            // check for cross site scripting - attacks in request arguments\n            if (args != null && argc > 0) {\n                // check all values for occurrences of script values\n                final Iterator<String> e = args.values().iterator(); // enumeration of values\n                String val;\n                while (e.hasNext()) {\n                    val = e.next();\n                    if ((val != null) && (val.indexOf(\"<script\",0) >= 0) && !path.equals(\"/Crawler_p.html\")) {\n                        // deny request\n                        HTTPDemon.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\n                        return;\n                    }\n                }\n            }\n\n            if (args != null) nocache = true;\n\n            // we are finished with parsing\n            // the result of value hand-over is in args and argc\n            if (path.isEmpty()) {\n                HTTPDemon.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\n                out.flush();\n                return;\n            }\n            File targetClass = null;\n\n            // locate the file\n            if (!path.isEmpty() && path.charAt(0) != '/' && path.charAt(0) != '\\\\') {\n                path = \"/\" + path; // attach leading slash\n            }\n            if (path.endsWith(\"index.html\")) {\n                path = path.substring(0, path.length() - 10);\n            }\n\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\n            if (args != null && (args.containsKey(\"language\"))) {\n                // TODO 9.11.06 Bost: a class with information about available languages is needed.\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\n                localeSelection = args.get(\"language\", localeSelection);\n                if (localeSelection.indexOf('.') != -1)\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf('.'));\n            }\n\n            File targetFile = getLocalizedFile(path, localeSelection);\n            String targetExt = (String) conProp.get(\"EXT\"); if (targetExt == null) targetExt = \"\";\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\n            if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n                String testpath;\n                // look for indexForward setting\n                if (indexForward.length() > 0 && (targetFile = getOverlayedFile(path + indexForward)).exists()) {\n                    testpath = path + indexForward;\n                    targetClass = getOverlayedClass(testpath);\n                    path = testpath;\n                } else {\n                    // attach default file name(s)\n                    for (final String defaultFile : defaultFiles) {\n                        testpath = path + defaultFile;\n                        targetFile = getOverlayedFile(testpath);\n                        targetClass = getOverlayedClass(testpath);\n                        if (targetFile.exists()) {\n                            path = testpath;\n                            break;\n                        }\n                    }\n                }\n                targetFile = getLocalizedFile(path, localeSelection);\n\n                //no defaultfile, send a dirlisting\n                if (targetFile == null || !targetFile.exists() || (targetFile.exists() && targetFile.isDirectory())) {\n                    final StringBuilder aBuffer = new StringBuilder();\n                    aBuffer.append(\"<html>\\n<head>\\n<\/head>\\n<body>\\n<h1>Index of \" + path + \"<\/h1>\\n  <ul>\\n\");\n                    String[] list = targetFile.list();\n                    if (list == null) list = new String[0]; // should not occur!\n                    File f;\n                    String size;\n                    long sz;\n                    String headline, author, description, publisher;\n                    int images, links;\n                    ContentScraper scraper;\n                    for (final String element : list) {\n                        f = new File(targetFile, element);\n                        if (f.isDirectory()) {\n                            aBuffer.append(\"    <li><a href=\\\"\" + path + element + \"/\\\">\" + element + \"/<\/a><br/><\/li>\\n\");\n                        } else {\n                            if (element.endsWith(\"html\") || (element.endsWith(\"htm\"))) {\n                                scraper = ContentScraper.parseResource(f, 10000);\n                                headline = scraper.getTitle();\n                                author = scraper.getAuthor();\n                                publisher = scraper.getPublisher();\n                                description = scraper.getDescription();\n                                images = scraper.getImages().size();\n                                links = scraper.getAnchors().size();\n                            } else {\n                                headline = null;\n                                author = null;\n                                publisher = null;\n                                description = null;\n                                images = 0;\n                                links = 0;\n                            }\n                            sz = f.length();\n                            if (sz < 1024) {\n                                size = sz + \" bytes\";\n                            } else if (sz < 1024 * 1024) {\n                                size = (sz / 1024) + \" KB\";\n                            } else {\n                                size = (sz / 1024 / 1024) + \" MB\";\n                            }\n                            aBuffer.append(\"    <li>\");\n                            if (headline != null && headline.length() > 0) aBuffer.append(\"<a href=\\\"\" + element + \"\\\"><b>\" + headline + \"<\/b><\/a><br/>\");\n                            aBuffer.append(\"<a href=\\\"\" + path + element + \"\\\">\" + element + \"<\/a><br/>\");\n                            if (author != null && author.length() > 0) aBuffer.append(\"Author: \" + author + \"<br/>\");\n                            if (publisher != null && publisher.length() > 0) aBuffer.append(\"Publisher: \" + publisher + \"<br/>\");\n                            if (description != null && description.length() > 0) aBuffer.append(\"Description: \" + description + \"<br/>\");\n                            aBuffer.append(GenericFormatter.SHORT_DAY_FORMATTER.format(new Date(f.lastModified())) + \", \" + size + ((images > 0) ? \", \" + images + \" images\" : \"\") + ((links > 0) ? \", \" + links + \" links\" : \"\") + \"<br/><\/li>\\n\");\n                        }\n                    }\n                    aBuffer.append(\"  <\/ul>\\n<\/body>\\n<\/html>\\n\");\n\n                    // write the list to the client\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, \"text/html; charset=UTF-8\", aBuffer.length(), new Date(targetFile.lastModified()), null, new ResponseHeader(200), null, null, true);\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        out.write(UTF8.getBytes(aBuffer.toString()));\n                    }\n                    return;\n                }\n            } else {\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\n                    if ( !(targetFile.exists()) &&\n                            !((path.endsWith(\"png\")||path.endsWith(\"gif\") ||\n                            matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) ||\n                            path.endsWith(\".stream\")) &&\n                            targetClass!=null ) ){\n                        targetFile = new File(htDocsPath, path);\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\n                    }\n            }\n\n            // implement proxy via url (not in servlet, because we need binary access on ouputStream)\n            if (path.equals(\"/proxy.html\")) {\n            \tfinal List<Pattern> urlProxyAccess = Domains.makePatterns(sb.getConfig(\"proxyURL.access\", Domains.LOCALHOST));\n                final UserDB.Entry user = sb.userDB.getUser(requestHeader);\n                final boolean user_may_see_proxyurl = Domains.matchesList(clientIP, urlProxyAccess) || (user!=null && user.hasRight(UserDB.AccessRight.PROXY_RIGHT));\n            \tif (sb.getConfigBool(\"proxyURL\", false) && user_may_see_proxyurl) {\n            \t\tdoURLProxy(conProp, requestHeader, out);\n            \t\treturn;\n            \t}\n                HTTPDemon.sendRespondError(conProp,out,3,403,\"Access denied\",null,null);\n            }\n\n            // track all files that had been accessed so far\n            if (targetFile != null && targetFile.exists()) {\n                if (args != null && args.size() > 0) sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), path));\n            }\n\n            //File targetClass = rewriteClassFile(targetFile);\n            //We need tp here\n            servletProperties templatePatterns = null;\n            Date targetDate;\n\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\n                // call an image-servlet to produce an on-the-fly - generated image\n                Object img = null;\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"png\");\n                // in case that there are no args given, args = null or empty hashmap\n                img = invokeServlet(targetClass, requestHeader, args);\n                if (img == null) {\n                    // error with image generation; send file-not-found\n                    HTTPDemon.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\n                } else {\n                    if (img instanceof RasterPlotter) {\n                        final RasterPlotter yp = (RasterPlotter) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = RasterPlotter.exportImage(yp.getImage(), targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    if (img instanceof EncodedImage) {\n                        final EncodedImage yp = (EncodedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = yp.getImage();\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    /*\n                    if (img instanceof BufferedImage) {\n                        final BufferedImage i = (BufferedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(); if (height < 0) height = 96; // bad hack\n                        final ByteBuffer result = RasterPlotter.exportImage(i, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    */\n                    if (img instanceof Image) {\n                        final Image i = (Image) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n                        final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null);\n                        final ByteBuffer result = RasterPlotter.exportImage(bi, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                }\n            // old-school CGI execution\n            } else if ((switchboard.getConfigBool(\"cgi.allow\", false) // check if CGI execution is allowed in config\n                    && matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) // \"right\" file extension?\n                    && path.substring(0, path.indexOf(targetFile.getName())).toUpperCase().contains(\"/CGI-BIN/\") // file in right directory?\n                    && targetFile.exists())\n                    ) {\n\n                if (!targetFile.canExecute()) {\n                    HTTPDemon.sendRespondError(\n                            conProp,\n                            out,\n                            -1,\n                            403,\n                            null,\n                            HeaderFramework.http1_1.get(\n                                    Integer.toString(403)),\n                            null);\n                    Log.logWarning(\n                            \"HTTPD\",\n                            \"CGI script \" + targetFile.getPath()\n                            + \" could not be executed due to \"\n                            + \"insufficient access rights.\");\n                } else {\n                    String mimeType = \"text/html\";\n                    int statusCode = 200;\n\n                    final ProcessBuilder pb =\n                            new ProcessBuilder(assembleCommandFromShebang(targetFile));\n                    pb.directory(targetFile.getParentFile());\n\n                    final String fileSeparator =\n                            System.getProperty(\"file.separator\", \"/\");\n\n                    // set environment variables\n                    final Map<String, String> env = pb.environment();\n                    env.put(\n                            \"SERVER_SOFTWARE\",\n                            getDefaultHeaders(path).get(HeaderFramework.SERVER));\n                    env.put(\"SERVER_NAME\", sb.peers.mySeed().getName());\n                    env.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n                    if (httpVersion != null) {\n                        env.put(\"SERVER_PROTOCOL\", httpVersion);\n                    }\n                    env.put(\"SERVER_PORT\", switchboard.getConfig(\"port\", \"8090\"));\n                    env.put(\"REQUEST_METHOD\", method);\n    //                env.put(\"PATH_INFO\", \"\");         // TODO: implement\n    //                env.put(\"PATH_TRANSLATED\", \"\");   // TODO: implement\n                    env.put(\"SCRIPT_NAME\", path);\n                    if (argsString != null) {\n                        env.put(\"QUERY_STRING\", argsString);\n                    }\n                    env.put(\"REMOTE_ADDR\", clientIP);\n    //                env.put(\"AUTH_TYPE\", \"\");         // TODO: implement\n    //                env.put(\"REMOTE_USER\", \"\");       // TODO: implement\n    //                env.put(\"REMOTE_IDENT\", \"\");      // I don't think we need this\n                    env.put(\n                            \"DOCUMENT_ROOT\",\n                            switchboard.getAppPath().getAbsolutePath()\n                            + fileSeparator + switchboard.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\n                    if (requestHeader.getContentType() != null) {\n                        env.put(\"CONTENT_TYPE\", requestHeader.getContentType());\n                    }\n                    if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST)\n                            && body != null) {\n                        env.put(\n                                \"CONTENT_LENGTH\",\n                                Integer.toString(requestHeader.getContentLength()));\n                    }\n\n                    /* add values from request header to environment\n                     * (see: http://hoohoo.ncsa.uiuc.edu/cgi/env.html#headers) */\n                    for (final Map.Entry<String, String> requestHeaderEntry\n                            : requestHeader.entrySet()) {\n                        env.put(\"HTTP_\"\n                            + requestHeaderEntry.getKey().toUpperCase().replace(\"-\", \"_\"),\n                            requestHeaderEntry.getValue());\n                    }\n\n                    int exitValue = 0;\n                    String cgiBody = null;\n                    final StringBuilder error = new StringBuilder(256);\n\n                    try {\n                        // start execution of script\n                        final Process p = pb.start();\n\n                        final OutputStream os =\n                                new BufferedOutputStream(p.getOutputStream());\n\n                        if (method.equalsIgnoreCase(\n                                HeaderFramework.METHOD_POST) && body != null) {\n                            final byte[] buffer = new byte[1024];\n                            int len = requestHeader.getContentLength();\n                            while (len > 0) {\n                                body.read(buffer);\n                                len = len - buffer.length;\n                                os.write(buffer);\n                            }\n                        }\n\n                        os.close();\n\n                        try {\n                            p.waitFor();\n                        } catch (final InterruptedException ex) {\n\n                        }\n\n                        exitValue = p.exitValue();\n\n                        final InputStream is =\n                                new BufferedInputStream(p.getInputStream());\n\n                        final InputStream es =\n                                new BufferedInputStream(p.getErrorStream());\n\n                        final StringBuilder processOutput =\n                                new StringBuilder(1024);\n\n                        while (is.available() > 0) {\n                            processOutput.append((char) is.read());\n                        }\n\n                        while (es.available() > 0) {\n                            error.append((char) es.read());\n                        }\n\n                        int indexOfDelimiter = processOutput.indexOf(\"\\n\\n\", 0);\n                        final String[] cgiHeader;\n                        if (indexOfDelimiter > -1) {\n                            cgiHeader =\n                                    processOutput.substring(\n                                            0, indexOfDelimiter).split(\"\\n\");\n                        } else {\n                            cgiHeader = new String[0];\n                        }\n                        cgiBody = processOutput.substring(indexOfDelimiter + 1);\n\n                        String key;\n                        String value;\n                        for (final String element : cgiHeader) {\n                            indexOfDelimiter = element.indexOf(':');\n                            key = element.substring(0, indexOfDelimiter).trim();\n                            value = element.substring(indexOfDelimiter + 1).trim();\n                            conProp.put(key, value);\n                            if (\"Cache-Control\".equals(key)\n                                    && \"no-cache\".equals(value)) {\n                                nocache = true;\n                            } else if (\"Content-type\".equals(key)) {\n                                mimeType = value;\n                            } else if (\"Status\".equals(key)) {\n                                if (key.length() > 2) {\n                                    try {\n                                        statusCode =\n                                                Integer.parseInt(\n                                                        value.substring(0, 3));\n                                    } catch (final NumberFormatException ex) {\n                                        Log.logWarning(\n                                                \"HTTPD\",\n                                                \"CGI script \" + targetFile.getPath()\n                                                + \" returned illegal status code \\\"\"\n                                                + value + \"\\\".\");\n                                    }\n                                }\n                            }\n                        }\n                    } catch (final IOException ex) {\n                        exitValue = -1;\n                    }\n\n                    /* did the script return an exit value != 0\n                     * and still there is supposed to be\n                     * everything right with the HTTP status?\n                     * -> change status to 500 since 200 would\n                     * be a lie\n                     */\n                    if (exitValue != 0 && statusCode == 200) {\n                        statusCode = 500;\n                    }\n\n                    targetDate = new Date(System.currentTimeMillis());\n\n                    if (cgiBody != null && !cgiBody.isEmpty()) {\n                        HTTPDemon.sendRespondHeader(\n                                conProp,\n                                out,\n                                httpVersion,\n                                statusCode,\n                                null,\n                                mimeType,\n                                cgiBody.length(),\n                                targetDate,\n                                null,\n                                null,\n                                null,\n                                null,\n                                nocache);\n                        out.write(UTF8.getBytes(cgiBody));\n                    } else {\n                        HTTPDemon.sendRespondError(\n                                conProp,\n                                out,\n                                exitValue,\n                                statusCode,\n                                null,\n                                HeaderFramework.http1_1.get(\n                                        Integer.toString(statusCode)),\n                                null);\n                        Log.logWarning(\n                                \"HTTPD\",\n                                \"CGI script \" + targetFile.getPath()\n                                + \" returned exit value \" + exitValue\n                                + \", body empty: \"\n                                + (cgiBody == null || cgiBody.isEmpty()));\n                        if (error.length() > 0) {\n                            Log.logWarning(\"HTTPD\", \"Reported error: \" + error);\n                        }\n                    }\n                }\n            } else if ((targetClass != null) && (path.endsWith(\".stream\"))) {\n                // call rewrite-class\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"stream\");\n                //requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\n                //requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\n\n                HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null);\n\n                // in case that there are no args given, args = null or empty hashmap\n                /* servletProperties tp = (servlerObjects) */ invokeServlet(targetClass, requestHeader, args);\n                forceConnectionClose(conProp);\n                return;\n            } else if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n                // we have found a file that can be written to the client\n                // if this file uses templates, then we use the template\n                // re-write - method to create an result\n                String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                String ext = (String) conProp.get(\"EXT\"); if (ext == null) ext = \"\";\n                final boolean zipContent = requestHeader.acceptGzip() && HTTPDemon.shallTransportZipped(\".\" + ext);\n                if (path.endsWith(\"html\") ||\n                        path.endsWith(\"htm\") ||\n                        path.endsWith(\"xml\") ||\n                        path.endsWith(\"json\") ||\n                        path.endsWith(\"rdf\") ||\n                        path.endsWith(\"rss\") ||\n                        path.endsWith(\"csv\") ||\n                        path.endsWith(\"pac\") ||\n                        path.endsWith(\"src\") ||\n                        path.endsWith(\"vcf\") ||\n                        path.endsWith(\"kml\") ||\n                        path.endsWith(\"gpx\") ||\n                        path.endsWith(\"css\") ||\n                        path.endsWith(\"/\") ||\n                        path.equals(\"/robots.txt\")) {\n\n                    /*targetFile = getLocalizedFile(path);\n                    if (!(targetFile.exists())) {\n                        // try to find that file in the htDocsPath\n                        File trialFile = new File(htDocsPath, path);\n                        if (trialFile.exists()) targetFile = trialFile;\n                    }*/\n\n\n                    // call rewrite-class\n\n                    if (targetClass != null) {\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                        final int ep = path.lastIndexOf(\".\");\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.substring(ep + 1));\n                        // in case that there are no args given, args = null or empty hashmap\n                        final Object tmp = invokeServlet(targetClass, requestHeader, args);\n                        if (tmp == null) {\n                            // if no args given, then tp will be an empty Hashtable object (not null)\n                            templatePatterns = new servletProperties();\n                        } else if (tmp instanceof servletProperties) {\n                            templatePatterns = (servletProperties) tmp;\n                        } else {\n                            templatePatterns = new servletProperties((serverObjects) tmp);\n                        }\n                        // check if the servlets requests authentication\n                        if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\n                            // handle brute-force protection\n                            if (realmProp != null) {\n                                Log.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                                final Integer attempts = serverCore.bfHost.get(clientIP);\n                                if (attempts == null)\n                                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                                else\n                                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n                            }\n                            // send authentication request to browser\n                            final ResponseHeader headers = getDefaultHeaders(path);\n                            headers.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + templatePatterns.get(serverObjects.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\n                            HTTPDemon.sendRespondHeader(conProp,out,httpVersion,401,headers);\n                            return;\n                        } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\n                            String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\n                            if (location.length() == 0) location = path;\n\n                            final ResponseHeader headers = getDefaultHeaders(path);\n                            headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\n                            headers.put(HeaderFramework.LOCATION,location);\n                            HTTPDemon.sendRespondHeader(conProp,out,httpVersion,302,headers);\n                            return;\n                        }\n                        // add the application version, the uptime and the client name to every rewrite table\n                        templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n                        templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n                        templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n                        templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, ((Switchboard) switchboard).peers.myID());\n                        templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n                        final Seed myPeer = sb.peers.mySeed();\n                        templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\n                        templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n                        //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\n                        nocache = true;\n                    }\n\n                    targetDate = new Date(targetFile.lastModified());\n                    Date expireDate = null;\n                    if (templatePatterns == null) {\n                    \t// if the file will not be changed, cache it in the browser\n                    \texpireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    }\n\n\n                    // rewrite the file\n                    InputStream fis = null;\n\n                    // read the file/template\n                    TemplateCacheEntry templateCacheEntry = null;\n                    final long fileSize = targetFile.length();\n                    if (useTemplateCache && fileSize <= 512 * 1024) {\n                        // read from cache\n                        SoftReference<TemplateCacheEntry> ref = templateCache.get(targetFile);\n                        if (ref != null) {\n                            templateCacheEntry = ref.get();\n                            if (templateCacheEntry == null) templateCache.remove(targetFile);\n                        }\n\n                        final Date targetFileDate = new Date(targetFile.lastModified());\n                        if (templateCacheEntry == null || targetFileDate.after(templateCacheEntry.lastModified)) {\n                            // loading the content of the template file into\n                            // a byte array\n                            templateCacheEntry = new TemplateCacheEntry();\n                            templateCacheEntry.lastModified = targetFileDate;\n                            templateCacheEntry.content = FileUtils.read(targetFile);\n\n                            // storing the content into the cache\n                            ref = new SoftReference<TemplateCacheEntry>(templateCacheEntry);\n                            if (MemoryControl.shortStatus()) templateCache.clear();\n                            templateCache.put(targetFile, ref);\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache MISS for file \" + targetFile);\n                        } else {\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache HIT for file \" + targetFile);\n                        }\n\n                        // creating an inputstream needed by the template\n                        // rewrite function\n                        fis = new ByteArrayInputStream(templateCacheEntry.content);\n                        templateCacheEntry = null;\n                    } else if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                        // read file completely into ram, avoid that too many files are open at the same time\n                        fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                    } else {\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\n                    }\n\n                    if (mimeType.startsWith(\"text\")) {\n                        // every text-file distributed by yacy is UTF-8\n                        if (!path.startsWith(\"/repository\")) {\n                            mimeType = mimeType + \"; charset=UTF-8\";\n                        } else {\n                            // detect charset of html-files\n                            if ((path.endsWith(\"html\") || path.endsWith(\"htm\"))) {\n                                // save position\n                                fis.mark(1000);\n                                // scrape document to look up charset\n                                final ScraperInputStream htmlFilter = new ScraperInputStream(fis, \"UTF-8\", new DigestURI(\"http://localhost\"), null, false, 10);\n                                final String charset = htmlParser.patchCharsetEncoding(htmlFilter.detectCharset());\n                                htmlFilter.close();\n                                if (charset != null) mimeType = mimeType + \"; charset=\"+charset;\n                                // reset position\n                                fis.reset();\n                            }\n                        }\n                    }\n\n                    // write the array to the client\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\n                    final boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\n                    final boolean chunked = !method.equals(HeaderFramework.METHOD_HEAD) && !yacyClient && httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1);\n                    if (chunked) {\n                        // send page in chunks and parse SSIs\n                        final ByteBuffer o = new ByteBuffer();\n                        // apply templates\n                        TemplateEngine.writeTemplate(fis, o, templatePatterns, UNRESOLVED_PATTERN);\n                        fis.close();\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        HTTPDemon.sendRespondHeader(conProp, out,\n                                httpVersion, rh.getStatusCode(), null, mimeType, -1,\n                                targetDate, expireDate, rh,\n                                null, \"chunked\", nocache);\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\n                        final ChunkedOutputStream chos = new ChunkedOutputStream(out);\n                        // GZIPOutputStream does not implement flush (this is a bug IMHO)\n                        // so we can't compress this stuff, without loosing the cool SSI trickle feature\n                        ServerSideIncludes.writeSSI(o, chos, realmProp, clientIP, requestHeader);\n                        //chos.write(result);\n                        chos.finish();\n                    } else {\n                        // send page as whole thing, SSIs are not possible\n                        final String contentEncoding = (zipContent) ? \"gzip\" : null;\n                        // apply templates\n                        final ByteBuffer o1 = new ByteBuffer();\n                        TemplateEngine.writeTemplate(fis, o1, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        final ByteBuffer o = new ByteBuffer();\n\n                        if (zipContent) {\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\n                            ServerSideIncludes.writeSSI(o1, zippedOut, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                            zippedOut.finish();\n                            zippedOut.flush();\n                            zippedOut.close();\n                            zippedOut = null;\n                        } else {\n                            ServerSideIncludes.writeSSI(o1, o, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                        }\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        if (method.equals(HeaderFramework.METHOD_HEAD)) {\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, o.length(),\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                        } else {\n                            final byte[] result = o.getBytes(); // this interrupts streaming (bad idea!)\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, result.length,\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                            FileUtils.copy(result, out);\n                        }\n                    }\n                } else { // no html\n\n                    int statusCode = 200;\n                    int rangeStartOffset = 0;\n                    final ResponseHeader header = new ResponseHeader(statusCode);\n\n                    // adding the accept ranges header\n                    header.put(HeaderFramework.ACCEPT_RANGES, \"bytes\");\n\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\n                    String targetMD5 = null;\n                    final File targetMd5File = new File(targetFile + \".md5\");\n                    try {\n                        if (targetMd5File.exists()) {\n                            //String description = null;\n                            targetMD5 = UTF8.String(FileUtils.read(targetMd5File));\n                            final int pos = targetMD5.indexOf('\\n');\n                            if (pos >= 0) {\n                                //description = targetMD5.substring(pos + 1);\n                                targetMD5 = targetMD5.substring(0, pos);\n                            }\n\n                            // using the checksum as ETAG header\n                            header.put(HeaderFramework.ETAG, targetMD5);\n                        }\n                    } catch (final IOException e) {\n                        Log.logException(e);\n                    }\n\n                    if (requestHeader.containsKey(HeaderFramework.RANGE)) {\n                        final Object ifRange = requestHeader.ifRange();\n                        if ((ifRange == null)||\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\n                            final String rangeHeaderVal = requestHeader.get(HeaderFramework.RANGE).trim();\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\n                                final String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\n                                final String[] ranges = rangesVal.split(\",\");\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\n                                    rangeStartOffset = NumberTools.parseIntDecSubstring(ranges[0], 0, ranges[0].length() - 1);\n                                    statusCode = 206;\n                                    header.put(HeaderFramework.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\n                                }\n                            }\n                        }\n                    }\n\n                    // write the file to the client\n                    targetDate = new Date(targetFile.lastModified());\n                    // cache file for one month in browser (but most browsers won't cache for that long)\n                    final Date expireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    final long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\n                    final String contentEncoding  = (zipContent) ? \"gzip\" : null;\n                    final String transferEncoding = (httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) ? \"chunked\" : null;\n                    if (!httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\n\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, expireDate, header, contentEncoding, transferEncoding, nocache);\n\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        ChunkedOutputStream chunkedOut = null;\n                        GZIPOutputStream zipped = null;\n                        OutputStream newOut = out;\n\n                        if (transferEncoding != null) {\n                            chunkedOut = new ChunkedOutputStream(newOut);\n                            newOut = chunkedOut;\n                        }\n                        if (contentEncoding != null) {\n                            zipped = new GZIPOutputStream(newOut);\n                            newOut = zipped;\n                        }\n\n                        FileUtils.copyRange(targetFile, newOut, rangeStartOffset);\n\n                        if (zipped != null) {\n                            zipped.flush();\n                            zipped.finish();\n                        }\n                        if (chunkedOut != null) {\n                            chunkedOut.finish();\n                        }\n\n                        // flush all\n                        try {newOut.flush();}catch (final Exception e) {}\n                    }\n                }\n            } else {\n                HTTPDemon.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\n                return;\n            }\n        } catch (final Exception e) {\n            try {\n                // error handling\n                if (e instanceof NullPointerException) {\n                    Log.logException(e);\n                }\n                int httpStatusCode = 400;\n                final String httpStatusText = null;\n                final StringBuilder errorMessage = new StringBuilder(2000);\n                Exception errorExc = null;\n\n                final String errorMsg = e.getMessage();\n                if (\n                        (e instanceof InterruptedException) ||\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\n                   ) {\n                    errorMessage.append(\"Interruption detected while processing query.\");\n                    httpStatusCode = 503;\n                } else {\n                    if ((errorMsg != null) &&\n                        (\n                           errorMsg.contains(\"Broken pipe\") ||\n                           errorMsg.contains(\"Connection reset\") ||\n                           errorMsg.contains(\"Read timed out\") ||\n                           errorMsg.contains(\"Connection timed out\") ||\n                           errorMsg.contains(\"Software caused connection abort\")\n                       )) {\n                        // client closed the connection, so we just end silently\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\n                    } else {\n                        errorMessage.append(\"Unexpected error while processing query.\");\n                        httpStatusCode = 500;\n                        errorExc = e;\n                    }\n                }\n\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\n                            .append(\"\\nQuery:   \").append(path)\n                            .append(\"\\nClient:  \").append(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP))\n                            .append(\"\\nReason:  \").append(e.getMessage());\n\n                if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                    // sending back an error message to the client\n                    // if we have not already send an http header\n                    HTTPDemon.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(), errorExc);\n                } else {\n                    // otherwise we close the connection\n                    forceConnectionClose(conProp);\n                }\n\n                // if it is an unexpected error we log it\n                if (httpStatusCode == 500) {\n                    theLogger.logWarning(errorMessage.toString(), e);\n                }\n\n            } catch (final Exception ee) {\n                forceConnectionClose(conProp);\n            }\n\n        } finally {\n            try {out.flush();}catch (final Exception e) {}\n        }\n    }","commit_id":"8efc1c1078912d9537f15f69fc0ad43e9c7e4a39","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static final Object invokeServlet(final File targetClass, final RequestHeader request, final serverObjects args) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n        try {\n            return rewriteMethod(targetClass).invoke(null, new Object[] {request, args, switchboard});\n        } catch (final OutOfMemoryError e) {\n            Log.logException(e);\n            return null;\n        }\n    }","id":85321,"modified_method":"private static final Object invokeServlet(final File targetClass, final RequestHeader request, final serverObjects args) {\n        try {\n            return rewriteMethod(targetClass).invoke(null, new Object[] {request, args, switchboard});\n        } catch (final Throwable e) {\n            theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                            e.getMessage() +\n                            \" target exception at \" + targetClass + \": \" +\n                            \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\");\n            Log.logException(e);\n            Log.logException(e.getCause());\n            if (e instanceof InvocationTargetException) Log.logException(((InvocationTargetException) e).getTargetException());\n            return null;\n        }\n    }","commit_id":"8efc1c1078912d9537f15f69fc0ad43e9c7e4a39","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public J job(final J next) throws Exception {\n        J out = null;\n\n        // see if we got a poison pill to tell us to shut down\n        if (next == null) {\n            out = (J) WorkflowJob.poisonPill;\n        } else if (next == WorkflowJob.poisonPill || next.status == WorkflowJob.STATUS_POISON) {\n            out = next;\n        } else {\n            final long t = System.currentTimeMillis();\n\n            instantThreadCounter++;\n            //System.out.println(\"started job \" + this.handle + \": \" + this.getName());\n            jobs.put(this.handle, getName());\n\n            try {\n                out = (J) this.jobExecMethod.invoke(this.environment, new Object[]{next});\n            } catch (final IllegalAccessException e) {\n                Log.logSevere(BLOCKINGTHREAD, \"Internal Error in serverInstantThread.job: \" + e.getMessage());\n                Log.logSevere(BLOCKINGTHREAD, \"shutting down thread '\" + getName() + \"'\");\n                terminate(false);\n            } catch (final IllegalArgumentException e) {\n                Log.logSevere(BLOCKINGTHREAD, \"Internal Error in serverInstantThread.job: \" + e.getMessage());\n                Log.logSevere(BLOCKINGTHREAD, \"shutting down thread '\" + getName() + \"'\");\n                terminate(false);\n            } catch (final InvocationTargetException e) {\n                final String targetException = e.getTargetException().getMessage();\n                Log.logException(e);\n                Log.logException(e.getCause());\n                Log.logException(e.getTargetException());\n                if ((targetException != null) &&\n                        ((targetException.indexOf(\"heap space\",0) > 0) ||\n                        (targetException.indexOf(\"NullPointerException\",0) > 0))) {\n                    Log.logException(e.getTargetException());\n                }\n                Log.logSevere(BLOCKINGTHREAD, \"Runtime Error in serverInstantThread.job, thread '\" + getName() + \"': \" + e.getMessage() + \"; target exception: \" + targetException, e.getTargetException());\n            } catch (final OutOfMemoryError e) {\n                Log.logSevere(BLOCKINGTHREAD, \"OutOfMemory Error in serverInstantThread.job, thread '\" + getName() + \"': \" + e.getMessage());\n                Log.logException(e);\n            }\n            instantThreadCounter--;\n            jobs.remove(this.handle);\n            getManager().increaseJobTime(System.currentTimeMillis() - t);\n        }\n        return out;\n    }","id":85322,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public J job(final J next) throws Exception {\n        J out = null;\n\n        // see if we got a poison pill to tell us to shut down\n        if (next == null) {\n            out = (J) WorkflowJob.poisonPill;\n        } else if (next == WorkflowJob.poisonPill || next.status == WorkflowJob.STATUS_POISON) {\n            out = next;\n        } else {\n            final long t = System.currentTimeMillis();\n\n            instantThreadCounter++;\n            //System.out.println(\"started job \" + this.handle + \": \" + this.getName());\n            jobs.put(this.handle, getName());\n\n            try {\n                out = (J) this.jobExecMethod.invoke(this.environment, new Object[]{next});\n            } catch (final Throwable e) {\n                Log.logSevere(BLOCKINGTHREAD, \"Internal Error in serverInstantThread.job: \" + e.getMessage());\n                Log.logSevere(BLOCKINGTHREAD, \"shutting down thread '\" + getName() + \"'\");\n                final Throwable targetException = (e instanceof InvocationTargetException) ? ((InvocationTargetException) e).getTargetException() : null;\n                Log.logException(e);\n                Log.logException(e.getCause());\n                if (targetException != null) Log.logException(targetException);\n                Log.logSevere(BLOCKINGTHREAD, \"Runtime Error in serverInstantThread.job, thread '\" + getName() + \"': \" + e.getMessage());\n            }\n            instantThreadCounter--;\n            jobs.remove(this.handle);\n            getManager().increaseJobTime(System.currentTimeMillis() - t);\n        }\n        return out;\n    }","commit_id":"8efc1c1078912d9537f15f69fc0ad43e9c7e4a39","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public TransformerWriter(\n            final OutputStream outStream,\n            final Charset charSet,\n            final Scraper scraper,\n            final Transformer transformer,\n            final boolean passbyIfBinarySuspect\n    ) {\n    \tthis(outStream, charSet, scraper, transformer, passbyIfBinarySuspect, 4096);\n    }","id":85323,"modified_method":"public TransformerWriter(\n            final OutputStream outStream,\n            final Charset charSet,\n            final Scraper scraper,\n            final Transformer transformer,\n            final boolean passbyIfBinarySuspect\n    ) {\n    \tthis(outStream, charSet, scraper, transformer, passbyIfBinarySuspect, 64);\n    }","commit_id":"8efc1c1078912d9537f15f69fc0ad43e9c7e4a39","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static ContentScraper parseToScraper(\n            final MultiProtocolURI location,\n            final String documentCharset,\n            InputStream sourceStream,\n            final int maxLinks) throws Parser.Failure, IOException {\n\n        // make a scraper\n        String charset = null;\n\n        // ah, we are lucky, we got a character-encoding via HTTP-header\n        if (documentCharset != null) {\n            charset = patchCharsetEncoding(documentCharset);\n        }\n\n        // nothing found: try to find a meta-tag\n        if (charset == null) {\n            try {\n                final ScraperInputStream htmlFilter = new ScraperInputStream(sourceStream, documentCharset, location, null, false, maxLinks);\n                sourceStream = htmlFilter;\n                charset = htmlFilter.detectCharset();\n                htmlFilter.close();\n            } catch (final IOException e1) {\n                throw new Parser.Failure(\"Charset error:\" + e1.getMessage(), location);\n            }\n        }\n\n        // the author didn't tell us the encoding, try the mozilla-heuristic\n        if (charset == null) {\n            final CharsetDetector det = new CharsetDetector();\n            det.enableInputFilter(true);\n            final InputStream detStream = new BufferedInputStream(sourceStream);\n            det.setText(detStream);\n            charset = det.detect().getName();\n            sourceStream = detStream;\n        }\n\n        // wtf? still nothing, just take system-standard\n        if (charset == null) {\n            charset = Charset.defaultCharset().name();\n        }\n\n        Charset c;\n        try {\n            c = Charset.forName(charset);\n        } catch (final IllegalCharsetNameException e) {\n            c = Charset.defaultCharset();\n        } catch (final UnsupportedCharsetException e) {\n            c = Charset.defaultCharset();\n        }\n\n        // parsing the content\n        final ContentScraper scraper = new ContentScraper(location, maxLinks);\n        final TransformerWriter writer = new TransformerWriter(null,null,scraper,null,false, Math.max(4096, sourceStream.available()));\n        try {\n            FileUtils.copy(sourceStream, writer, c);\n        } catch (final IOException e) {\n            throw new Parser.Failure(\"IO error:\" + e.getMessage(), location);\n        } finally {\n            writer.flush();\n            sourceStream.close();\n            //writer.close();\n        }\n        //OutputStream hfos = new htmlFilterOutputStream(null, scraper, null, false);\n        //serverFileUtils.copy(sourceFile, hfos);\n        //hfos.close();\n        if (writer.binarySuspect()) {\n            final String errorMsg = \"Binary data found in resource\";\n            throw new Parser.Failure(errorMsg, location);\n        }\n        return scraper;\n    }","id":85324,"modified_method":"public static ContentScraper parseToScraper(\n            final MultiProtocolURI location,\n            final String documentCharset,\n            InputStream sourceStream,\n            final int maxLinks) throws Parser.Failure, IOException {\n\n        // make a scraper\n        String charset = null;\n\n        // ah, we are lucky, we got a character-encoding via HTTP-header\n        if (documentCharset != null) {\n            charset = patchCharsetEncoding(documentCharset);\n        }\n\n        // nothing found: try to find a meta-tag\n        if (charset == null) {\n            try {\n                final ScraperInputStream htmlFilter = new ScraperInputStream(sourceStream, documentCharset, location, null, false, maxLinks);\n                sourceStream = htmlFilter;\n                charset = htmlFilter.detectCharset();\n                htmlFilter.close();\n            } catch (final IOException e1) {\n                throw new Parser.Failure(\"Charset error:\" + e1.getMessage(), location);\n            }\n        }\n\n        // the author didn't tell us the encoding, try the mozilla-heuristic\n        if (charset == null) {\n            final CharsetDetector det = new CharsetDetector();\n            det.enableInputFilter(true);\n            final InputStream detStream = new BufferedInputStream(sourceStream);\n            det.setText(detStream);\n            charset = det.detect().getName();\n            sourceStream = detStream;\n        }\n\n        // wtf? still nothing, just take system-standard\n        if (charset == null) {\n            charset = Charset.defaultCharset().name();\n        }\n\n        Charset c;\n        try {\n            c = Charset.forName(charset);\n        } catch (final IllegalCharsetNameException e) {\n            c = Charset.defaultCharset();\n        } catch (final UnsupportedCharsetException e) {\n            c = Charset.defaultCharset();\n        }\n\n        // parsing the content\n        final ContentScraper scraper = new ContentScraper(location, maxLinks);\n        final TransformerWriter writer = new TransformerWriter(null,null,scraper,null,false, Math.max(64, Math.min(4096, sourceStream.available())));\n        try {\n            FileUtils.copy(sourceStream, writer, c);\n        } catch (final IOException e) {\n            throw new Parser.Failure(\"IO error:\" + e.getMessage(), location);\n        } finally {\n            writer.flush();\n            sourceStream.close();\n            //writer.close();\n        }\n        //OutputStream hfos = new htmlFilterOutputStream(null, scraper, null, false);\n        //serverFileUtils.copy(sourceFile, hfos);\n        //hfos.close();\n        if (writer.binarySuspect()) {\n            final String errorMsg = \"Binary data found in resource\";\n            throw new Parser.Failure(errorMsg, location);\n        }\n        return scraper;\n    }","commit_id":"8efc1c1078912d9537f15f69fc0ad43e9c7e4a39","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public EmbeddedSolrConnector(File storagePath, File solr_config) throws IOException {\n        super();\n        // copy the solrconfig.xml to the storage path\n        File conf = new File(storagePath, \"conf\");\n        conf.mkdirs();\n        File source, target;\n        for (String cf: confFiles) {\n            source = new File(solr_config, cf);\n            if (source.isDirectory()) {\n                target = new File(conf, cf);\n                target.mkdirs();\n                for (String cfl: source.list()) {\n                    Files.copy(new File(source, cfl), new File(target, cfl));\n                }\n            } else {\n                target = new File(conf, cf);\n                target.getParentFile().mkdirs();\n                Files.copy(source, target);\n            }\n        }\n        /*\n        try {\n            CheckIndex.main(new String[]{new File(new File(storagePath, \"data\"), \"index\").getAbsolutePath(), \"-fix\"});\n        } catch (InterruptedException e1) {\n            Log.logException(e1);\n        }\n        */\n        try {\n            this.cores = new CoreContainer(storagePath.getAbsolutePath(), new File(solr_config, \"solr.xml\"));\n        } catch (ParserConfigurationException e) {\n            throw new IOException(e.getMessage(), e);\n        } catch (SAXException e) {\n            throw new IOException(e.getMessage(), e);\n        }\n        this.defaultCoreName = this.cores.getDefaultCoreName();\n        this.defaultCore = this.cores.getCore(this.defaultCoreName); // should be \"collection1\"\n        final NamedList<Object> config = new NamedList<Object>();\n        this.requestHandler = new SearchHandler();\n        this.requestHandler.init(config);\n        this.requestHandler.inform(this.defaultCore);\n        super.init(new EmbeddedSolrServer(this.cores, this.defaultCoreName));\n    }","id":85325,"modified_method":"public EmbeddedSolrConnector(File storagePath, File solr_config) throws IOException {\n        super();\n        // copy the solrconfig.xml to the storage path\n        File conf = new File(storagePath, \"conf\");\n        conf.mkdirs();\n        File source, target;\n        for (String cf: confFiles) {\n            source = new File(solr_config, cf);\n            if (source.isDirectory()) {\n                target = new File(conf, cf);\n                target.mkdirs();\n                for (String cfl: source.list()) {\n                    try {\n                        Files.copy(new File(source, cfl), new File(target, cfl));\n                    } catch (IOException e) {\n                        Log.logException(e);\n                    }\n                }\n            } else {\n                target = new File(conf, cf);\n                target.getParentFile().mkdirs();\n                try {\n                    Files.copy(source, target);\n                } catch (IOException e) {\n                    Log.logException(e);\n                }\n            }\n        }\n        /*\n        try {\n            CheckIndex.main(new String[]{new File(new File(storagePath, \"data\"), \"index\").getAbsolutePath(), \"-fix\"});\n        } catch (InterruptedException e1) {\n            Log.logException(e1);\n        }\n        */\n        try {\n            this.cores = new CoreContainer(storagePath.getAbsolutePath(), new File(solr_config, \"solr.xml\"));\n        } catch (ParserConfigurationException e) {\n            throw new IOException(e.getMessage(), e);\n        } catch (SAXException e) {\n            throw new IOException(e.getMessage(), e);\n        }\n        this.defaultCoreName = this.cores.getDefaultCoreName();\n        this.defaultCore = this.cores.getCore(this.defaultCoreName); // should be \"collection1\"\n        final NamedList<Object> config = new NamedList<Object>();\n        this.requestHandler = new SearchHandler();\n        this.requestHandler.init(config);\n        this.requestHandler.inform(this.defaultCore);\n        super.init(new EmbeddedSolrServer(this.cores, this.defaultCoreName));\n    }","commit_id":"aab0b680c362284fe22b48d13c4b3fee820a3191","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void doResponse(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream out, final InputStream body) {\n\n        String path = null;\n        try {\n            // getting some connection properties\n            final String method = (String) conProp.get(HeaderFramework.CONNECTION_PROP_METHOD);\n            path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            String argsString = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // is null if no args were given\n            final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n            String clientIP = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); if (clientIP == null) clientIP = \"unknown-host\";\n\n            // check hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            path = UTF8.decodeURL(path);\n\n            // check against hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            // allow proper access to current peer via virtual directory\n            if (path.startsWith(\"/currentyacypeer/\")) {\n            \tpath = path.substring(16);\n            }\n\n            // cache settings\n            boolean nocache = path.contains(\"?\") || body != null;\n\n            // a bad patch to map the /xml/ path to /api/\n            if (path.startsWith(\"/xml/\")) {\n                path = \"/api/\" + path.substring(5);\n            }\n            // another bad patch to map the /util/ path to /api/util/ to support old yacybars\n            if (path.startsWith(\"/util/\")) {\n                path = \"/api/util/\" + path.substring(6);\n            }\n            // one more for bookmarks\n            if (path.startsWith(\"/bookmarks/\")) {\n                path = \"/api/bookmarks/\" + path.substring(11);\n            }\n\n            // these are the 5 cases where an access granted:\n            // (the alternative is that we deliver a 401 to request authorization)\n\n            // -1- the page is not protected; or\n            final boolean protectedPage = path.indexOf(\"_p.\",0) > 0;\n            boolean accessGranted = !protectedPage;\n\n            // -2- a password is not configured; or\n            final String adminAccountBase64MD5 = switchboard.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n            if (!accessGranted) {\n                accessGranted = adminAccountBase64MD5.isEmpty();\n            }\n\n            // -3- access from localhost is granted and access comes from localhost; or\n            final String refererHost = requestHeader.refererHost();\n            if (!accessGranted) {\n                final boolean adminAccountForLocalhost = sb.getConfigBool(\"adminAccountForLocalhost\", false);\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.isEmpty() || Domains.isLocalhost(refererHost));\n                accessGranted = adminAccountForLocalhost && accessFromLocalhost;\n            }\n\n            // -4- a password is configured and access comes from localhost\n            //     and the realm-value of a http-authentify String is equal to the stored base64MD5; or\n            String realmProp = requestHeader.get(RequestHeader.AUTHORIZATION);\n            if (realmProp != null && realmProp.isEmpty()) realmProp = null;\n            final String realmValue = realmProp == null ? null : realmProp.substring(6);\n            if (!accessGranted) {\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.isEmpty() || Domains.isLocalhost(refererHost));\n                accessGranted = accessFromLocalhost && realmValue != null && realmProp.length() > 6 && (adminAccountBase64MD5.equals(realmValue));\n                Log.logInfo(\"HTTPDFileHandler\", \"access from localhost blocked, clientIP=\" + clientIP);\n            }\n\n            // -5- a password is configured and access comes with matching http-authentify\n            if (!accessGranted) {\n                accessGranted = realmProp != null && realmValue != null && (sb.userDB.hasAdminRight(realmProp, requestHeader.getHeaderCookies()) || adminAccountBase64MD5.equals(Digest.encodeMD5Hex(realmValue)));\n            }\n\n            // in case that we are still not granted we ask for a password\n            if (!accessGranted) {\n                Log.logInfo(\"HTTPD\", \"Wrong log-in for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                final Integer attempts = serverCore.bfHost.get(clientIP);\n                if (attempts == null)\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                else\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n\n                final ResponseHeader responseHeader = getDefaultHeaders(path);\n                responseHeader.put(RequestHeader.WWW_AUTHENTICATE, \"Basic realm=\\\"\" + serverObjects.ADMIN_AUTHENTICATE_MSG + \"\\\"\");\n                final servletProperties tp=new servletProperties();\n                tp.put(\"returnto\", path);\n                HTTPDemon.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, responseHeader);\n                return;\n            }\n\n            // Authentication successful. remove brute-force flag\n            serverCore.bfHost.remove(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n\n            // parse arguments\n            serverObjects args = new serverObjects();\n            int argc = 0;\n            if (argsString == null) {\n                // no args here, maybe a POST with multipart extension\n                final int length = requestHeader.getContentLength();\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\n\n                /* don't parse body in case of a POST CGI call since it has to be\n                 * handed over to the CGI script unaltered and parsed by the script\n                 */\n                if (method.equals(HeaderFramework.METHOD_POST) &&\n                        !(switchboard.getConfigBool(\"cgi.allow\", false) &&\n                        matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)))\n                        ) {\n\n                    // if its a POST, it can be either multipart or as args in the body\n                    if ((requestHeader.containsKey(HeaderFramework.CONTENT_TYPE)) &&\n                            (requestHeader.get(HeaderFramework.CONTENT_TYPE).toLowerCase().startsWith(\"multipart\"))) {\n                        // parse multipart\n                        final Map<String, byte[]> files = HTTPDemon.parseMultipart(requestHeader, args, body);\n                        // integrate these files into the args\n                        if (files != null) {\n                            final Iterator<Map.Entry<String, byte[]>> fit = files.entrySet().iterator();\n                            Map.Entry<String, byte[]> entry;\n                            while (fit.hasNext()) {\n                                entry = fit.next();\n                                args.put(entry.getKey() + \"$file\", entry.getValue());\n                            }\n                        }\n                        argc = Integer.parseInt(requestHeader.get(\"ARGC\"));\n                    } else {\n                        // parse args in body\n                        argc = HTTPDemon.parseArgs(args, body, length);\n                    }\n                } else {\n                    // no args\n                    argsString = null;\n                    args = null;\n                    argc = 0;\n                }\n            } else {\n                // simple args in URL (stuff after the \"?\")\n                argc = HTTPDemon.parseArgs(args, argsString);\n            }\n\n            // check for cross site scripting - attacks in request arguments\n            if (args != null && argc > 0) {\n                // check all values for occurrences of script values\n                final Iterator<String> e = args.values().iterator(); // enumeration of values\n                String val;\n                while (e.hasNext()) {\n                    val = e.next();\n                    if ((val != null) && (val.indexOf(\"<script\",0) >= 0) && !path.equals(\"/Crawler_p.html\")) {\n                        // deny request\n                        HTTPDemon.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\n                        return;\n                    }\n                }\n            }\n\n            if (args != null) nocache = true;\n\n            // we are finished with parsing\n            // the result of value hand-over is in args and argc\n            if (path.isEmpty()) {\n                HTTPDemon.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\n                out.flush();\n                return;\n            }\n            File targetClass = null;\n\n            // locate the file\n            if (!path.isEmpty() && path.charAt(0) != '/' && path.charAt(0) != '\\\\') {\n                path = \"/\" + path; // attach leading slash\n            }\n            if (path.endsWith(\"index.html\")) {\n                path = path.substring(0, path.length() - 10);\n            }\n\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\n            if (args != null && (args.containsKey(\"language\"))) {\n                // TODO 9.11.06 Bost: a class with information about available languages is needed.\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\n                localeSelection = args.get(\"language\", localeSelection);\n                if (localeSelection.indexOf('.') != -1)\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf('.'));\n            }\n\n            File targetFile = getLocalizedFile(path, localeSelection);\n            String targetExt = (String) conProp.get(\"EXT\"); if (targetExt == null) targetExt = \"\";\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\n            if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n                String testpath;\n                // look for indexForward setting\n                if (indexForward.length() > 0 && (targetFile = getOverlayedFile(path + indexForward)).exists()) {\n                    testpath = path + indexForward;\n                    targetClass = getOverlayedClass(testpath);\n                    path = testpath;\n                } else {\n                    // attach default file name(s)\n                    for (final String defaultFile : defaultFiles) {\n                        testpath = path + defaultFile;\n                        targetFile = getOverlayedFile(testpath);\n                        targetClass = getOverlayedClass(testpath);\n                        if (targetFile.exists()) {\n                            path = testpath;\n                            break;\n                        }\n                    }\n                }\n                targetFile = getLocalizedFile(path, localeSelection);\n\n                //no defaultfile, send a dirlisting\n                if (targetFile == null || !targetFile.exists() || (targetFile.exists() && targetFile.isDirectory())) {\n                    final StringBuilder aBuffer = new StringBuilder();\n                    aBuffer.append(\"<html>\\n<head>\\n<\/head>\\n<body>\\n<h1>Index of \" + path + \"<\/h1>\\n  <ul>\\n\");\n                    String[] list = targetFile.list();\n                    if (list == null) list = new String[0]; // should not occur!\n                    File f;\n                    String size;\n                    long sz;\n                    String headline, author, description, publisher;\n                    int images, links;\n                    ContentScraper scraper;\n                    for (final String element : list) {\n                        f = new File(targetFile, element);\n                        if (f.isDirectory()) {\n                            aBuffer.append(\"    <li><a href=\\\"\" + path + element + \"/\\\">\" + element + \"/<\/a><br/><\/li>\\n\");\n                        } else {\n                            if (element.endsWith(\"html\") || (element.endsWith(\"htm\"))) {\n                                scraper = ContentScraper.parseResource(f, 10000);\n                                headline = scraper.getTitle();\n                                author = scraper.getAuthor();\n                                publisher = scraper.getPublisher();\n                                description = scraper.getDescription();\n                                images = scraper.getImages().size();\n                                links = scraper.getAnchors().size();\n                            } else {\n                                headline = null;\n                                author = null;\n                                publisher = null;\n                                description = null;\n                                images = 0;\n                                links = 0;\n                            }\n                            sz = f.length();\n                            if (sz < 1024) {\n                                size = sz + \" bytes\";\n                            } else if (sz < 1024 * 1024) {\n                                size = (sz / 1024) + \" KB\";\n                            } else {\n                                size = (sz / 1024 / 1024) + \" MB\";\n                            }\n                            aBuffer.append(\"    <li>\");\n                            if (headline != null && headline.length() > 0) aBuffer.append(\"<a href=\\\"\" + element + \"\\\"><b>\" + headline + \"<\/b><\/a><br/>\");\n                            aBuffer.append(\"<a href=\\\"\" + path + element + \"\\\">\" + element + \"<\/a><br/>\");\n                            if (author != null && author.length() > 0) aBuffer.append(\"Author: \" + author + \"<br/>\");\n                            if (publisher != null && publisher.length() > 0) aBuffer.append(\"Publisher: \" + publisher + \"<br/>\");\n                            if (description != null && description.length() > 0) aBuffer.append(\"Description: \" + description + \"<br/>\");\n                            aBuffer.append(GenericFormatter.SHORT_DAY_FORMATTER.format(new Date(f.lastModified())) + \", \" + size + ((images > 0) ? \", \" + images + \" images\" : \"\") + ((links > 0) ? \", \" + links + \" links\" : \"\") + \"<br/><\/li>\\n\");\n                        }\n                    }\n                    aBuffer.append(\"  <\/ul>\\n<\/body>\\n<\/html>\\n\");\n\n                    // write the list to the client\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, \"text/html; charset=UTF-8\", aBuffer.length(), new Date(targetFile.lastModified()), null, new ResponseHeader(200), null, null, true);\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        out.write(UTF8.getBytes(aBuffer.toString()));\n                    }\n                    return;\n                }\n            } else {\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\n                    if ( !(targetFile.exists()) &&\n                            !((path.endsWith(\"png\")||path.endsWith(\"gif\") || path.indexOf('.') < 0 ||\n                            matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) ||\n                            path.endsWith(\".stream\")) &&\n                            targetClass!=null ) ){\n                        targetFile = new File(htDocsPath, path);\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\n                    }\n            }\n\n            // implement proxy via url (not in servlet, because we need binary access on ouputStream)\n            if (path.equals(\"/proxy.html\")) {\n            \tfinal List<Pattern> urlProxyAccess = Domains.makePatterns(sb.getConfig(\"proxyURL.access\", Domains.LOCALHOST));\n                final UserDB.Entry user = sb.userDB.getUser(requestHeader);\n                final boolean user_may_see_proxyurl = Domains.matchesList(clientIP, urlProxyAccess) || (user!=null && user.hasRight(UserDB.AccessRight.PROXY_RIGHT));\n            \tif (sb.getConfigBool(\"proxyURL\", false) && user_may_see_proxyurl) {\n            \t\tdoURLProxy(conProp, requestHeader, out);\n            \t\treturn;\n            \t}\n                HTTPDemon.sendRespondError(conProp,out,3,403,\"Access denied\",null,null);\n            }\n\n            // track all files that had been accessed so far\n            if (targetFile != null && targetFile.exists()) {\n                if (args != null && !args.isEmpty()) sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), path));\n            }\n\n            //File targetClass = rewriteClassFile(targetFile);\n            //We need tp here\n            servletProperties templatePatterns = null;\n            Date targetDate;\n\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\n                // call an image-servlet to produce an on-the-fly - generated image\n                Object img = null;\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"png\");\n                // in case that there are no args given, args = null or empty hashmap\n                img = invokeServlet(targetClass, requestHeader, args, null);\n                if (img == null) {\n                    // error with image generation; send file-not-found\n                    HTTPDemon.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\n                } else {\n                    if (img instanceof RasterPlotter) {\n                        final RasterPlotter yp = (RasterPlotter) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = RasterPlotter.exportImage(yp.getImage(), targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    if (img instanceof EncodedImage) {\n                        final EncodedImage yp = (EncodedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = yp.getImage();\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    /*\n                    if (img instanceof BufferedImage) {\n                        final BufferedImage i = (BufferedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(); if (height < 0) height = 96; // bad hack\n                        final ByteBuffer result = RasterPlotter.exportImage(i, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    */\n                    if (img instanceof Image) {\n                        final Image i = (Image) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n                        final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null);\n                        final ByteBuffer result = RasterPlotter.exportImage(bi, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                }\n            // old-school CGI execution\n            } else if ((switchboard.getConfigBool(\"cgi.allow\", false) // check if CGI execution is allowed in config\n                    && matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) // \"right\" file extension?\n                    && path.substring(0, path.indexOf(targetFile.getName())).toUpperCase().contains(\"/CGI-BIN/\") // file in right directory?\n                    && targetFile.exists())\n                    ) {\n\n                if (!targetFile.canExecute()) {\n                    HTTPDemon.sendRespondError(\n                            conProp,\n                            out,\n                            -1,\n                            403,\n                            null,\n                            HeaderFramework.http1_1.get(\n                                    Integer.toString(403)),\n                            null);\n                    Log.logWarning(\n                            \"HTTPD\",\n                            \"CGI script \" + targetFile.getPath()\n                            + \" could not be executed due to \"\n                            + \"insufficient access rights.\");\n                } else {\n                    String mimeType = \"text/html\";\n                    int statusCode = 200;\n\n                    final ProcessBuilder pb =\n                            new ProcessBuilder(assembleCommandFromShebang(targetFile));\n                    pb.directory(targetFile.getParentFile());\n\n                    final String fileSeparator =\n                            System.getProperty(\"file.separator\", \"/\");\n\n                    // set environment variables\n                    final Map<String, String> env = pb.environment();\n                    env.put(\n                            \"SERVER_SOFTWARE\",\n                            getDefaultHeaders(path).get(HeaderFramework.SERVER));\n                    env.put(\"SERVER_NAME\", sb.peers.mySeed().getName());\n                    env.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n                    if (httpVersion != null) {\n                        env.put(\"SERVER_PROTOCOL\", httpVersion);\n                    }\n                    env.put(\"SERVER_PORT\", switchboard.getConfig(\"port\", \"8090\"));\n                    env.put(\"REQUEST_METHOD\", method);\n    //                env.put(\"PATH_INFO\", \"\");         // TODO: implement\n    //                env.put(\"PATH_TRANSLATED\", \"\");   // TODO: implement\n                    env.put(\"SCRIPT_NAME\", path);\n                    if (argsString != null) {\n                        env.put(\"QUERY_STRING\", argsString);\n                    }\n                    env.put(\"REMOTE_ADDR\", clientIP);\n    //                env.put(\"AUTH_TYPE\", \"\");         // TODO: implement\n    //                env.put(\"REMOTE_USER\", \"\");       // TODO: implement\n    //                env.put(\"REMOTE_IDENT\", \"\");      // I don't think we need this\n                    env.put(\n                            \"DOCUMENT_ROOT\",\n                            switchboard.getAppPath().getAbsolutePath()\n                            + fileSeparator + switchboard.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\n                    if (requestHeader.getContentType() != null) {\n                        env.put(\"CONTENT_TYPE\", requestHeader.getContentType());\n                    }\n                    if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST)\n                            && body != null) {\n                        env.put(\n                                \"CONTENT_LENGTH\",\n                                Integer.toString(requestHeader.getContentLength()));\n                    }\n\n                    /* add values from request header to environment\n                     * (see: http://hoohoo.ncsa.uiuc.edu/cgi/env.html#headers) */\n                    for (final Map.Entry<String, String> requestHeaderEntry\n                            : requestHeader.entrySet()) {\n                        env.put(\"HTTP_\"\n                            + requestHeaderEntry.getKey().toUpperCase().replace(\"-\", \"_\"),\n                            requestHeaderEntry.getValue());\n                    }\n\n                    int exitValue = 0;\n                    String cgiBody = null;\n                    final StringBuilder error = new StringBuilder(256);\n\n                    try {\n                        // start execution of script\n                        final Process p = pb.start();\n\n                        final OutputStream os =\n                                new BufferedOutputStream(p.getOutputStream());\n\n                        if (method.equalsIgnoreCase(\n                                HeaderFramework.METHOD_POST) && body != null) {\n                            final byte[] buffer = new byte[1024];\n                            int len = requestHeader.getContentLength();\n                            while (len > 0) {\n                                body.read(buffer);\n                                len = len - buffer.length;\n                                os.write(buffer);\n                            }\n                        }\n\n                        os.close();\n\n                        try {\n                            p.waitFor();\n                        } catch (final InterruptedException ex) {\n\n                        }\n\n                        exitValue = p.exitValue();\n\n                        final InputStream is =\n                                new BufferedInputStream(p.getInputStream());\n\n                        final InputStream es =\n                                new BufferedInputStream(p.getErrorStream());\n\n                        final StringBuilder processOutput =\n                                new StringBuilder(1024);\n\n                        while (is.available() > 0) {\n                            processOutput.append((char) is.read());\n                        }\n\n                        while (es.available() > 0) {\n                            error.append((char) es.read());\n                        }\n\n                        int indexOfDelimiter = processOutput.indexOf(\"\\n\\n\", 0);\n                        final String[] cgiHeader;\n                        if (indexOfDelimiter > -1) {\n                            cgiHeader =\n                                    processOutput.substring(\n                                            0, indexOfDelimiter).split(\"\\n\");\n                        } else {\n                            cgiHeader = new String[0];\n                        }\n                        cgiBody = processOutput.substring(indexOfDelimiter + 1);\n\n                        String key;\n                        String value;\n                        for (final String element : cgiHeader) {\n                            indexOfDelimiter = element.indexOf(':');\n                            key = element.substring(0, indexOfDelimiter).trim();\n                            value = element.substring(indexOfDelimiter + 1).trim();\n                            conProp.put(key, value);\n                            if (\"Cache-Control\".equals(key)\n                                    && \"no-cache\".equals(value)) {\n                                nocache = true;\n                            } else if (\"Content-type\".equals(key)) {\n                                mimeType = value;\n                            } else if (\"Status\".equals(key)) {\n                                if (key.length() > 2) {\n                                    try {\n                                        statusCode =\n                                                Integer.parseInt(\n                                                        value.substring(0, 3));\n                                    } catch (final NumberFormatException ex) {\n                                        Log.logWarning(\n                                                \"HTTPD\",\n                                                \"CGI script \" + targetFile.getPath()\n                                                + \" returned illegal status code \\\"\"\n                                                + value + \"\\\".\");\n                                    }\n                                }\n                            }\n                        }\n                    } catch (final IOException ex) {\n                        exitValue = -1;\n                    }\n\n                    /* did the script return an exit value != 0\n                     * and still there is supposed to be\n                     * everything right with the HTTP status?\n                     * -> change status to 500 since 200 would\n                     * be a lie\n                     */\n                    if (exitValue != 0 && statusCode == 200) {\n                        statusCode = 500;\n                    }\n\n                    targetDate = new Date(System.currentTimeMillis());\n\n                    if (cgiBody != null && !cgiBody.isEmpty()) {\n                        HTTPDemon.sendRespondHeader(\n                                conProp,\n                                out,\n                                httpVersion,\n                                statusCode,\n                                null,\n                                mimeType,\n                                cgiBody.length(),\n                                targetDate,\n                                null,\n                                null,\n                                null,\n                                null,\n                                nocache);\n                        out.write(UTF8.getBytes(cgiBody));\n                    } else {\n                        HTTPDemon.sendRespondError(\n                                conProp,\n                                out,\n                                exitValue,\n                                statusCode,\n                                null,\n                                HeaderFramework.http1_1.get(\n                                        Integer.toString(statusCode)),\n                                null);\n                        Log.logWarning(\n                                \"HTTPD\",\n                                \"CGI script \" + targetFile.getPath()\n                                + \" returned exit value \" + exitValue\n                                + \", body empty: \"\n                                + (cgiBody == null || cgiBody.isEmpty()));\n                        if (error.length() > 0) {\n                            Log.logWarning(\"HTTPD\", \"Reported error: \" + error);\n                        }\n                    }\n                }\n            } else if (targetClass != null && (path.endsWith(\".stream\") || path.indexOf('.') < 0)) {\n                // call rewrite-class\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.endsWith(\".stream\") ? \"stream\" : \"\");\n                //requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\n                //requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\n                ResponseHeader header = new ResponseHeader(200);\n                header.put(HeaderFramework.CONTENT_TYPE, \"text/xml\"); // this is a hack; the actual content type should be given by the servlet, but there is no handover process for that at this time\n                conProp.remove(HeaderFramework.CONNECTION_PROP_PERSISTENT);\n                HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, header);\n                invokeServlet(targetClass, requestHeader, args, out);\n                forceConnectionClose(conProp);\n                return;\n            } else if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n                // we have found a file that can be written to the client\n                // if this file uses templates, then we use the template\n                // re-write - method to create an result\n                String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                String ext = (String) conProp.get(\"EXT\"); if (ext == null) ext = \"\";\n                final boolean zipContent = requestHeader.acceptGzip() && HTTPDemon.shallTransportZipped(\".\" + ext);\n                if (path.endsWith(\"html\") ||\n                        path.endsWith(\"htm\") ||\n                        path.endsWith(\"xml\") ||\n                        path.endsWith(\"json\") ||\n                        path.endsWith(\"rdf\") ||\n                        path.endsWith(\"rss\") ||\n                        path.endsWith(\"csv\") ||\n                        path.endsWith(\"pac\") ||\n                        path.endsWith(\"src\") ||\n                        path.endsWith(\"vcf\") ||\n                        path.endsWith(\"kml\") ||\n                        path.endsWith(\"gpx\") ||\n                        path.endsWith(\"css\") ||\n                        path.endsWith(\"/\") ||\n                        path.equals(\"/robots.txt\")) {\n\n                    /*targetFile = getLocalizedFile(path);\n                    if (!(targetFile.exists())) {\n                        // try to find that file in the htDocsPath\n                        File trialFile = new File(htDocsPath, path);\n                        if (trialFile.exists()) targetFile = trialFile;\n                    }*/\n\n\n                    // call rewrite-class\n\n                    if (targetClass != null) {\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                        final int ep = path.lastIndexOf(\".\");\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.substring(ep + 1));\n                        // in case that there are no args given, args = null or empty hashmap\n                        final Object tmp = invokeServlet(targetClass, requestHeader, args, null);\n                        if (tmp == null) {\n                            // if no args given, then tp will be an empty Hashtable object (not null)\n                            templatePatterns = new servletProperties();\n                        } else if (tmp instanceof servletProperties) {\n                            templatePatterns = (servletProperties) tmp;\n                        } else {\n                            templatePatterns = new servletProperties((serverObjects) tmp);\n                        }\n                        // check if the servlets requests authentication\n                        if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\n                            // handle brute-force protection\n                            if (realmProp != null) {\n                                Log.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                                final Integer attempts = serverCore.bfHost.get(clientIP);\n                                if (attempts == null)\n                                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                                else\n                                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n                            }\n                            // send authentication request to browser\n                            final ResponseHeader headers = getDefaultHeaders(path);\n                            headers.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + templatePatterns.get(serverObjects.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\n                            HTTPDemon.sendRespondHeader(conProp,out,httpVersion,401,headers);\n                            return;\n                        } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\n                            String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\n                            if (location.isEmpty()) location = path;\n\n                            final ResponseHeader headers = getDefaultHeaders(path);\n                            headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\n                            headers.put(HeaderFramework.LOCATION,location);\n                            HTTPDemon.sendRespondHeader(conProp,out,httpVersion,302,headers);\n                            return;\n                        }\n                        // add the application version, the uptime and the client name to every rewrite table\n                        templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n                        templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n                        templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n                        templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, ((Switchboard) switchboard).peers.myID());\n                        templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n                        final Seed myPeer = sb.peers.mySeed();\n                        templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\n                        templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n                        //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\n                        nocache = true;\n                    }\n\n                    targetDate = new Date(targetFile.lastModified());\n                    Date expireDate = null;\n                    if (templatePatterns == null) {\n                    \t// if the file will not be changed, cache it in the browser\n                    \texpireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    }\n\n\n                    // rewrite the file\n                    InputStream fis = null;\n\n                    // read the file/template\n                    TemplateCacheEntry templateCacheEntry = null;\n                    final long fileSize = targetFile.length();\n                    if (useTemplateCache && fileSize <= 512 * 1024) {\n                        // read from cache\n                        SoftReference<TemplateCacheEntry> ref = templateCache.get(targetFile);\n                        if (ref != null) {\n                            templateCacheEntry = ref.get();\n                            if (templateCacheEntry == null) templateCache.remove(targetFile);\n                        }\n\n                        final Date targetFileDate = new Date(targetFile.lastModified());\n                        if (templateCacheEntry == null || targetFileDate.after(templateCacheEntry.lastModified)) {\n                            // loading the content of the template file into\n                            // a byte array\n                            templateCacheEntry = new TemplateCacheEntry();\n                            templateCacheEntry.lastModified = targetFileDate;\n                            templateCacheEntry.content = FileUtils.read(targetFile);\n\n                            // storing the content into the cache\n                            ref = new SoftReference<TemplateCacheEntry>(templateCacheEntry);\n                            if (MemoryControl.shortStatus()) templateCache.clear();\n                            templateCache.put(targetFile, ref);\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache MISS for file \" + targetFile);\n                        } else {\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache HIT for file \" + targetFile);\n                        }\n\n                        // creating an inputstream needed by the template\n                        // rewrite function\n                        fis = new ByteArrayInputStream(templateCacheEntry.content);\n                        templateCacheEntry = null;\n                    } else if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                        // read file completely into ram, avoid that too many files are open at the same time\n                        fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                    } else {\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\n                    }\n\n                    if (mimeType.startsWith(\"text\")) {\n                        // every text-file distributed by yacy is UTF-8\n                        if (!path.startsWith(\"/repository\")) {\n                            mimeType = mimeType + \"; charset=UTF-8\";\n                        } else {\n                            // detect charset of html-files\n                            if ((path.endsWith(\"html\") || path.endsWith(\"htm\"))) {\n                                // save position\n                                fis.mark(1000);\n                                // scrape document to look up charset\n                                final ScraperInputStream htmlFilter = new ScraperInputStream(fis, \"UTF-8\", new DigestURI(\"http://localhost\"), null, false, 10);\n                                final String charset = htmlParser.patchCharsetEncoding(htmlFilter.detectCharset());\n                                htmlFilter.close();\n                                if (charset != null) mimeType = mimeType + \"; charset=\"+charset;\n                                // reset position\n                                fis.reset();\n                            }\n                        }\n                    }\n\n                    // write the array to the client\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\n                    final boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\n                    final boolean chunked = !method.equals(HeaderFramework.METHOD_HEAD) && !yacyClient && httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1);\n                    if (chunked) {\n                        // send page in chunks and parse SSIs\n                        final ByteBuffer o = new ByteBuffer();\n                        // apply templates\n                        TemplateEngine.writeTemplate(fis, o, templatePatterns, UNRESOLVED_PATTERN);\n                        fis.close();\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        HTTPDemon.sendRespondHeader(conProp, out,\n                                httpVersion, rh.getStatusCode(), null, mimeType, -1,\n                                targetDate, expireDate, rh,\n                                null, \"chunked\", nocache);\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\n                        final ChunkedOutputStream chos = new ChunkedOutputStream(out);\n                        // GZIPOutputStream does not implement flush (this is a bug IMHO)\n                        // so we can't compress this stuff, without loosing the cool SSI trickle feature\n                        ServerSideIncludes.writeSSI(o, chos, realmProp, clientIP, requestHeader);\n                        //chos.write(result);\n                        chos.finish();\n                    } else {\n                        // send page as whole thing, SSIs are not possible\n                        final String contentEncoding = (zipContent) ? \"gzip\" : null;\n                        // apply templates\n                        final ByteBuffer o1 = new ByteBuffer();\n                        TemplateEngine.writeTemplate(fis, o1, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        final ByteBuffer o = new ByteBuffer();\n\n                        if (zipContent) {\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\n                            ServerSideIncludes.writeSSI(o1, zippedOut, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                            zippedOut.finish();\n                            zippedOut.flush();\n                            zippedOut.close();\n                            zippedOut = null;\n                        } else {\n                            ServerSideIncludes.writeSSI(o1, o, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                        }\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        if (method.equals(HeaderFramework.METHOD_HEAD)) {\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, o.length(),\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                        } else {\n                            final byte[] result = o.getBytes(); // this interrupts streaming (bad idea!)\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, result.length,\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                            FileUtils.copy(result, out);\n                        }\n                    }\n                } else { // no html\n\n                    int statusCode = 200;\n                    int rangeStartOffset = 0;\n                    final ResponseHeader header = new ResponseHeader(statusCode);\n\n                    // adding the accept ranges header\n                    header.put(HeaderFramework.ACCEPT_RANGES, \"bytes\");\n\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\n                    String targetMD5 = null;\n                    final File targetMd5File = new File(targetFile + \".md5\");\n                    try {\n                        if (targetMd5File.exists()) {\n                            //String description = null;\n                            targetMD5 = UTF8.String(FileUtils.read(targetMd5File));\n                            final int pos = targetMD5.indexOf('\\n');\n                            if (pos >= 0) {\n                                //description = targetMD5.substring(pos + 1);\n                                targetMD5 = targetMD5.substring(0, pos);\n                            }\n\n                            // using the checksum as ETAG header\n                            header.put(HeaderFramework.ETAG, targetMD5);\n                        }\n                    } catch (final IOException e) {\n                        Log.logException(e);\n                    }\n\n                    if (requestHeader.containsKey(HeaderFramework.RANGE)) {\n                        final Object ifRange = requestHeader.ifRange();\n                        if ((ifRange == null)||\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\n                            final String rangeHeaderVal = requestHeader.get(HeaderFramework.RANGE).trim();\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\n                                final String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\n                                final String[] ranges = rangesVal.split(\",\");\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\n                                    rangeStartOffset = NumberTools.parseIntDecSubstring(ranges[0], 0, ranges[0].length() - 1);\n                                    statusCode = 206;\n                                    header.put(HeaderFramework.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\n                                }\n                            }\n                        }\n                    }\n\n                    // write the file to the client\n                    targetDate = new Date(targetFile.lastModified());\n                    // cache file for one month in browser (but most browsers won't cache for that long)\n                    final Date expireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    final long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\n                    final String contentEncoding  = (zipContent) ? \"gzip\" : null;\n                    final String transferEncoding = (httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) ? \"chunked\" : null;\n                    if (!httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\n\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, expireDate, header, contentEncoding, transferEncoding, nocache);\n\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        ChunkedOutputStream chunkedOut = null;\n                        GZIPOutputStream zipped = null;\n                        OutputStream newOut = out;\n\n                        if (transferEncoding != null) {\n                            chunkedOut = new ChunkedOutputStream(newOut);\n                            newOut = chunkedOut;\n                        }\n                        if (contentEncoding != null) {\n                            zipped = new GZIPOutputStream(newOut);\n                            newOut = zipped;\n                        }\n\n                        FileUtils.copyRange(targetFile, newOut, rangeStartOffset);\n\n                        if (zipped != null) {\n                            zipped.flush();\n                            zipped.finish();\n                        }\n                        if (chunkedOut != null) {\n                            chunkedOut.finish();\n                        }\n\n                        // flush all\n                        try {newOut.flush();}catch (final Exception e) {}\n                    }\n                }\n            } else {\n                HTTPDemon.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\n                return;\n            }\n        } catch (final Exception e) {\n            try {\n                // error handling\n                if (e instanceof NullPointerException) {\n                    Log.logException(e);\n                }\n                int httpStatusCode = 400;\n                final String httpStatusText = null;\n                final StringBuilder errorMessage = new StringBuilder(2000);\n                Exception errorExc = null;\n\n                final String errorMsg = e.getMessage();\n                if (\n                        (e instanceof InterruptedException) ||\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\n                   ) {\n                    errorMessage.append(\"Interruption detected while processing query.\");\n                    httpStatusCode = 503;\n                } else {\n                    if ((errorMsg != null) &&\n                        (\n                           errorMsg.contains(\"Broken pipe\") ||\n                           errorMsg.contains(\"Connection reset\") ||\n                           errorMsg.contains(\"Read timed out\") ||\n                           errorMsg.contains(\"Connection timed out\") ||\n                           errorMsg.contains(\"Software caused connection abort\")\n                       )) {\n                        // client closed the connection, so we just end silently\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\n                    } else {\n                        errorMessage.append(\"Unexpected error while processing query.\");\n                        httpStatusCode = 500;\n                        errorExc = e;\n                    }\n                }\n\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\n                            .append(\"\\nQuery:   \").append(path)\n                            .append(\"\\nClient:  \").append(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP))\n                            .append(\"\\nReason:  \").append(e.getMessage());\n\n                if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                    // sending back an error message to the client\n                    // if we have not already send an http header\n                    HTTPDemon.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(), errorExc);\n                } else {\n                    // otherwise we close the connection\n                    forceConnectionClose(conProp);\n                }\n\n                // if it is an unexpected error we log it\n                if (httpStatusCode == 500) {\n                    theLogger.logWarning(errorMessage.toString(), e);\n                }\n\n            } catch (final Exception ee) {\n                forceConnectionClose(conProp);\n            }\n\n        } finally {\n            try {out.flush();}catch (final Exception e) {}\n        }\n    }","id":85326,"modified_method":"public static void doResponse(final HashMap<String, Object> conProp, final RequestHeader requestHeader, final OutputStream out, final InputStream body) {\n\n        String path = null;\n        try {\n            // getting some connection properties\n            final String method = (String) conProp.get(HeaderFramework.CONNECTION_PROP_METHOD);\n            path = (String) conProp.get(HeaderFramework.CONNECTION_PROP_PATH);\n            String argsString = (String) conProp.get(HeaderFramework.CONNECTION_PROP_ARGS); // is null if no args were given\n            final String httpVersion = (String) conProp.get(HeaderFramework.CONNECTION_PROP_HTTP_VER);\n            String clientIP = (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); if (clientIP == null) clientIP = \"unknown-host\";\n\n            // check hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            path = UTF8.decodeURL(path);\n\n            // check against hack attacks in path\n            if (path.indexOf(\"..\",0) >= 0) {\n                HTTPDemon.sendRespondError(conProp,out,4,403,null,\"Access not allowed\",null);\n                return;\n            }\n\n            // allow proper access to current peer via virtual directory\n            if (path.startsWith(\"/currentyacypeer/\")) {\n            \tpath = path.substring(16);\n            }\n\n            // cache settings\n            boolean nocache = path.contains(\"?\") || body != null;\n\n            // a bad patch to map the /xml/ path to /api/\n            if (path.startsWith(\"/xml/\")) {\n                path = \"/api/\" + path.substring(5);\n            }\n            // another bad patch to map the /util/ path to /api/util/ to support old yacybars\n            if (path.startsWith(\"/util/\")) {\n                path = \"/api/util/\" + path.substring(6);\n            }\n            // one more for bookmarks\n            if (path.startsWith(\"/bookmarks/\")) {\n                path = \"/api/bookmarks/\" + path.substring(11);\n            }\n\n            // these are the 5 cases where an access granted:\n            // (the alternative is that we deliver a 401 to request authorization)\n\n            // -1- the page is not protected; or\n            final boolean protectedPage = path.indexOf(\"_p.\",0) > 0;\n            boolean accessGranted = !protectedPage;\n\n            // -2- a password is not configured; or\n            final String adminAccountBase64MD5 = switchboard.getConfig(SwitchboardConstants.ADMIN_ACCOUNT_B64MD5, \"\");\n            if (!accessGranted) {\n                accessGranted = adminAccountBase64MD5.isEmpty();\n            }\n\n            // -3- access from localhost is granted and access comes from localhost; or\n            final String refererHost = requestHeader.refererHost();\n            if (!accessGranted) {\n                final boolean adminAccountForLocalhost = sb.getConfigBool(\"adminAccountForLocalhost\", false);\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.isEmpty() || Domains.isLocalhost(refererHost));\n                accessGranted = adminAccountForLocalhost && accessFromLocalhost;\n            }\n\n            // -4- a password is configured and access comes from localhost\n            //     and the realm-value of a http-authentify String is equal to the stored base64MD5; or\n            String realmProp = requestHeader.get(RequestHeader.AUTHORIZATION);\n            if (realmProp != null && realmProp.isEmpty()) realmProp = null;\n            final String realmValue = realmProp == null ? null : realmProp.substring(6);\n            if (!accessGranted) {\n                final boolean accessFromLocalhost = Domains.isLocalhost(clientIP) && (refererHost == null || refererHost.isEmpty() || Domains.isLocalhost(refererHost));\n                accessGranted = accessFromLocalhost && realmValue != null && realmProp.length() > 6 && (adminAccountBase64MD5.equals(realmValue));\n                Log.logInfo(\"HTTPDFileHandler\", \"access from localhost blocked, clientIP=\" + clientIP);\n            }\n\n            // -5- a password is configured and access comes with matching http-authentify\n            if (!accessGranted) {\n                accessGranted = realmProp != null && realmValue != null && (sb.userDB.hasAdminRight(realmProp, requestHeader.getHeaderCookies()) || adminAccountBase64MD5.equals(Digest.encodeMD5Hex(realmValue)));\n            }\n\n            // in case that we are still not granted we ask for a password\n            if (!accessGranted) {\n                Log.logInfo(\"HTTPD\", \"Wrong log-in for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                final Integer attempts = serverCore.bfHost.get(clientIP);\n                if (attempts == null)\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                else\n                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n\n                final ResponseHeader responseHeader = getDefaultHeaders(path);\n                responseHeader.put(RequestHeader.WWW_AUTHENTICATE, \"Basic realm=\\\"\" + serverObjects.ADMIN_AUTHENTICATE_MSG + \"\\\"\");\n                final servletProperties tp=new servletProperties();\n                tp.put(\"returnto\", path);\n                HTTPDemon.sendRespondError(conProp, out, 5, 401, \"Wrong Authentication\", \"\", new File(\"proxymsg/authfail.inc\"), tp, null, responseHeader);\n                return;\n            }\n\n            // Authentication successful. remove brute-force flag\n            serverCore.bfHost.remove(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n\n            // parse arguments\n            serverObjects args = new serverObjects();\n            int argc = 0;\n            if (argsString == null) {\n                // no args here, maybe a POST with multipart extension\n                final int length = requestHeader.getContentLength();\n                //System.out.println(\"HEADER: \" + requestHeader.toString()); // DEBUG\n\n                /* don't parse body in case of a POST CGI call since it has to be\n                 * handed over to the CGI script unaltered and parsed by the script\n                 */\n                if (method.equals(HeaderFramework.METHOD_POST) &&\n                        !(switchboard.getConfigBool(\"cgi.allow\", false) &&\n                        matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)))\n                        ) {\n\n                    // if its a POST, it can be either multipart or as args in the body\n                    if ((requestHeader.containsKey(HeaderFramework.CONTENT_TYPE)) &&\n                            (requestHeader.get(HeaderFramework.CONTENT_TYPE).toLowerCase().startsWith(\"multipart\"))) {\n                        // parse multipart\n                        final Map<String, byte[]> files = HTTPDemon.parseMultipart(requestHeader, args, body);\n                        // integrate these files into the args\n                        if (files != null) {\n                            final Iterator<Map.Entry<String, byte[]>> fit = files.entrySet().iterator();\n                            Map.Entry<String, byte[]> entry;\n                            while (fit.hasNext()) {\n                                entry = fit.next();\n                                args.put(entry.getKey() + \"$file\", entry.getValue());\n                            }\n                        }\n                        argc = Integer.parseInt(requestHeader.get(\"ARGC\"));\n                    } else {\n                        // parse args in body\n                        argc = HTTPDemon.parseArgs(args, body, length);\n                    }\n                } else {\n                    // no args\n                    argsString = null;\n                    args = null;\n                    argc = 0;\n                }\n            } else {\n                // simple args in URL (stuff after the \"?\")\n                argc = HTTPDemon.parseArgs(args, argsString);\n            }\n\n            // check for cross site scripting - attacks in request arguments\n            if (args != null && argc > 0) {\n                // check all values for occurrences of script values\n                final Iterator<String> e = args.values().iterator(); // enumeration of values\n                String val;\n                while (e.hasNext()) {\n                    val = e.next();\n                    if ((val != null) && (val.indexOf(\"<script\",0) >= 0) && !path.equals(\"/Crawler_p.html\")) {\n                        // deny request\n                        HTTPDemon.sendRespondError(conProp,out,4,403,null,\"bad post values\",null);\n                        return;\n                    }\n                }\n            }\n\n            if (args != null) nocache = true;\n\n            // we are finished with parsing\n            // the result of value hand-over is in args and argc\n            if (path.isEmpty()) {\n                HTTPDemon.sendRespondError(conProp,out,4,400,null,\"Bad Request\",null);\n                out.flush();\n                return;\n            }\n            File targetClass = null;\n\n            // locate the file\n            if (!path.isEmpty() && path.charAt(0) != '/' && path.charAt(0) != '\\\\') {\n                path = \"/\" + path; // attach leading slash\n            }\n            if (path.endsWith(\"index.html\")) {\n                path = path.substring(0, path.length() - 10);\n            }\n\n            // a different language can be desired (by i.e. ConfigBasic.html) than the one stored in the locale.language\n            String localeSelection = switchboard.getConfig(\"locale.language\",\"default\");\n            if (args != null && (args.containsKey(\"language\"))) {\n                // TODO 9.11.06 Bost: a class with information about available languages is needed.\n                // the indexOf(\".\") is just a workaround because there from ConfigLanguage.html commes \"de.lng\" and\n                // from ConfigBasic.html comes just \"de\" in the \"language\" parameter\n                localeSelection = args.get(\"language\", localeSelection);\n                if (localeSelection.indexOf('.') != -1)\n                    localeSelection = localeSelection.substring(0, localeSelection.indexOf('.'));\n            }\n\n            File targetFile = getLocalizedFile(path, localeSelection);\n            String targetExt = (String) conProp.get(\"EXT\"); if (targetExt == null) targetExt = \"\";\n            targetClass = rewriteClassFile(new File(htDefaultPath, path));\n            if (path.endsWith(\"/\") || path.endsWith(\"\\\\\")) {\n                String testpath;\n                // look for indexForward setting\n                if (indexForward.length() > 0 && (targetFile = getOverlayedFile(path + indexForward)).exists()) {\n                    testpath = path + indexForward;\n                    targetClass = getOverlayedClass(testpath);\n                    path = testpath;\n                } else {\n                    // attach default file name(s)\n                    for (final String defaultFile : defaultFiles) {\n                        testpath = path + defaultFile;\n                        targetFile = getOverlayedFile(testpath);\n                        targetClass = getOverlayedClass(testpath);\n                        if (targetFile.exists()) {\n                            path = testpath;\n                            break;\n                        }\n                    }\n                }\n                targetFile = getLocalizedFile(path, localeSelection);\n\n                //no defaultfile, send a dirlisting\n                if (targetFile == null || !targetFile.exists() || (targetFile.exists() && targetFile.isDirectory())) {\n                    final StringBuilder aBuffer = new StringBuilder();\n                    aBuffer.append(\"<html>\\n<head>\\n<\/head>\\n<body>\\n<h1>Index of \" + path + \"<\/h1>\\n  <ul>\\n\");\n                    String[] list = targetFile.list();\n                    if (list == null) list = new String[0]; // should not occur!\n                    File f;\n                    String size;\n                    long sz;\n                    String headline, author, description, publisher;\n                    int images, links;\n                    ContentScraper scraper;\n                    for (final String element : list) {\n                        f = new File(targetFile, element);\n                        if (f.isDirectory()) {\n                            aBuffer.append(\"    <li><a href=\\\"\" + path + element + \"/\\\">\" + element + \"/<\/a><br/><\/li>\\n\");\n                        } else {\n                            if (element.endsWith(\"html\") || (element.endsWith(\"htm\"))) {\n                                scraper = ContentScraper.parseResource(f, 10000);\n                                headline = scraper.getTitle();\n                                author = scraper.getAuthor();\n                                publisher = scraper.getPublisher();\n                                description = scraper.getDescription();\n                                images = scraper.getImages().size();\n                                links = scraper.getAnchors().size();\n                            } else {\n                                headline = null;\n                                author = null;\n                                publisher = null;\n                                description = null;\n                                images = 0;\n                                links = 0;\n                            }\n                            sz = f.length();\n                            if (sz < 1024) {\n                                size = sz + \" bytes\";\n                            } else if (sz < 1024 * 1024) {\n                                size = (sz / 1024) + \" KB\";\n                            } else {\n                                size = (sz / 1024 / 1024) + \" MB\";\n                            }\n                            aBuffer.append(\"    <li>\");\n                            if (headline != null && headline.length() > 0) aBuffer.append(\"<a href=\\\"\" + element + \"\\\"><b>\" + headline + \"<\/b><\/a><br/>\");\n                            aBuffer.append(\"<a href=\\\"\" + path + element + \"\\\">\" + element + \"<\/a><br/>\");\n                            if (author != null && author.length() > 0) aBuffer.append(\"Author: \" + author + \"<br/>\");\n                            if (publisher != null && publisher.length() > 0) aBuffer.append(\"Publisher: \" + publisher + \"<br/>\");\n                            if (description != null && description.length() > 0) aBuffer.append(\"Description: \" + description + \"<br/>\");\n                            aBuffer.append(GenericFormatter.SHORT_DAY_FORMATTER.format(new Date(f.lastModified())) + \", \" + size + ((images > 0) ? \", \" + images + \" images\" : \"\") + ((links > 0) ? \", \" + links + \" links\" : \"\") + \"<br/><\/li>\\n\");\n                        }\n                    }\n                    aBuffer.append(\"  <\/ul>\\n<\/body>\\n<\/html>\\n\");\n\n                    // write the list to the client\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, \"text/html; charset=UTF-8\", aBuffer.length(), new Date(targetFile.lastModified()), null, new ResponseHeader(200), null, null, true);\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        out.write(UTF8.getBytes(aBuffer.toString()));\n                    }\n                    return;\n                }\n            } else {\n                    //XXX: you cannot share a .png/.gif file with a name like a class in htroot.\n                    if ( !(targetFile.exists()) &&\n                            !((path.endsWith(\"png\")||path.endsWith(\"gif\") || path.indexOf('.') < 0 ||\n                            matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) ||\n                            path.endsWith(\".stream\")) &&\n                            targetClass!=null ) ){\n                        targetFile = new File(htDocsPath, path);\n                        targetClass = rewriteClassFile(new File(htDocsPath, path));\n                    }\n            }\n\n            // implement proxy via url (not in servlet, because we need binary access on ouputStream)\n            if (path.equals(\"/proxy.html\")) {\n            \tfinal List<Pattern> urlProxyAccess = Domains.makePatterns(sb.getConfig(\"proxyURL.access\", Domains.LOCALHOST));\n                final UserDB.Entry user = sb.userDB.getUser(requestHeader);\n                final boolean user_may_see_proxyurl = Domains.matchesList(clientIP, urlProxyAccess) || (user!=null && user.hasRight(UserDB.AccessRight.PROXY_RIGHT));\n            \tif (sb.getConfigBool(\"proxyURL\", false) && user_may_see_proxyurl) {\n            \t\tdoURLProxy(conProp, requestHeader, out);\n            \t\treturn;\n            \t}\n                HTTPDemon.sendRespondError(conProp,out,3,403,\"Access denied\",null,null);\n            }\n\n            // track all files that had been accessed so far\n            if (targetFile != null && targetFile.exists()) {\n                if (args != null && !args.isEmpty()) sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), path));\n            }\n\n            //File targetClass = rewriteClassFile(targetFile);\n            //We need tp here\n            servletProperties templatePatterns = null;\n            Date targetDate;\n\n            if ((targetClass != null) && (path.endsWith(\"png\"))) {\n                // call an image-servlet to produce an on-the-fly - generated image\n                Object img = null;\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, \"png\");\n                // in case that there are no args given, args = null or empty hashmap\n                img = invokeServlet(targetClass, requestHeader, args, null);\n                if (img == null) {\n                    // error with image generation; send file-not-found\n                    HTTPDemon.sendRespondError(conProp, out, 3, 404, \"File not Found\", null, null);\n                } else {\n                    if (img instanceof RasterPlotter) {\n                        final RasterPlotter yp = (RasterPlotter) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = RasterPlotter.exportImage(yp.getImage(), targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    if (img instanceof EncodedImage) {\n                        final EncodedImage yp = (EncodedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                        final ByteBuffer result = yp.getImage();\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    /*\n                    if (img instanceof BufferedImage) {\n                        final BufferedImage i = (BufferedImage) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = MimeTable.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(); if (height < 0) height = 96; // bad hack\n                        final ByteBuffer result = RasterPlotter.exportImage(i, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                    */\n                    if (img instanceof Image) {\n                        final Image i = (Image) img;\n                        // send an image to client\n                        targetDate = new Date(System.currentTimeMillis());\n                        nocache = true;\n                        final String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n\n                        // generate an byte array from the generated image\n                        int width = i.getWidth(null); if (width < 0) width = 96; // bad hack\n                        int height = i.getHeight(null); if (height < 0) height = 96; // bad hack\n                        final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n                        bi.createGraphics().drawImage(i, 0, 0, width, height, null);\n                        final ByteBuffer result = RasterPlotter.exportImage(bi, targetExt);\n\n                        // write the array to the client\n                        HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, null, mimeType, result.length(), targetDate, null, null, null, null, nocache);\n                        if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                            result.writeTo(out);\n                        }\n                    }\n                }\n            // old-school CGI execution\n            } else if ((switchboard.getConfigBool(\"cgi.allow\", false) // check if CGI execution is allowed in config\n                    && matchesSuffix(path, switchboard.getConfig(\"cgi.suffixes\", null)) // \"right\" file extension?\n                    && path.substring(0, path.indexOf(targetFile.getName())).toUpperCase().contains(\"/CGI-BIN/\") // file in right directory?\n                    && targetFile.exists())\n                    ) {\n\n                if (!targetFile.canExecute()) {\n                    HTTPDemon.sendRespondError(\n                            conProp,\n                            out,\n                            -1,\n                            403,\n                            null,\n                            HeaderFramework.http1_1.get(\n                                    Integer.toString(403)),\n                            null);\n                    Log.logWarning(\n                            \"HTTPD\",\n                            \"CGI script \" + targetFile.getPath()\n                            + \" could not be executed due to \"\n                            + \"insufficient access rights.\");\n                } else {\n                    String mimeType = \"text/html\";\n                    int statusCode = 200;\n\n                    final ProcessBuilder pb =\n                            new ProcessBuilder(assembleCommandFromShebang(targetFile));\n                    pb.directory(targetFile.getParentFile());\n\n                    final String fileSeparator =\n                            System.getProperty(\"file.separator\", \"/\");\n\n                    // set environment variables\n                    final Map<String, String> env = pb.environment();\n                    env.put(\n                            \"SERVER_SOFTWARE\",\n                            getDefaultHeaders(path).get(HeaderFramework.SERVER));\n                    env.put(\"SERVER_NAME\", sb.peers.mySeed().getName());\n                    env.put(\"GATEWAY_INTERFACE\", \"CGI/1.1\");\n                    if (httpVersion != null) {\n                        env.put(\"SERVER_PROTOCOL\", httpVersion);\n                    }\n                    env.put(\"SERVER_PORT\", switchboard.getConfig(\"port\", \"8090\"));\n                    env.put(\"REQUEST_METHOD\", method);\n    //                env.put(\"PATH_INFO\", \"\");         // TODO: implement\n    //                env.put(\"PATH_TRANSLATED\", \"\");   // TODO: implement\n                    env.put(\"SCRIPT_NAME\", path);\n                    if (argsString != null) {\n                        env.put(\"QUERY_STRING\", argsString);\n                    }\n                    env.put(\"REMOTE_ADDR\", clientIP);\n    //                env.put(\"AUTH_TYPE\", \"\");         // TODO: implement\n    //                env.put(\"REMOTE_USER\", \"\");       // TODO: implement\n    //                env.put(\"REMOTE_IDENT\", \"\");      // I don't think we need this\n                    env.put(\n                            \"DOCUMENT_ROOT\",\n                            switchboard.getAppPath().getAbsolutePath()\n                            + fileSeparator + switchboard.getConfig(\"htDocsPath\", \"DATA/HTDOCS\"));\n                    if (requestHeader.getContentType() != null) {\n                        env.put(\"CONTENT_TYPE\", requestHeader.getContentType());\n                    }\n                    if (method.equalsIgnoreCase(HeaderFramework.METHOD_POST)\n                            && body != null) {\n                        env.put(\n                                \"CONTENT_LENGTH\",\n                                Integer.toString(requestHeader.getContentLength()));\n                    }\n\n                    /* add values from request header to environment\n                     * (see: http://hoohoo.ncsa.uiuc.edu/cgi/env.html#headers) */\n                    for (final Map.Entry<String, String> requestHeaderEntry\n                            : requestHeader.entrySet()) {\n                        env.put(\"HTTP_\"\n                            + requestHeaderEntry.getKey().toUpperCase().replace(\"-\", \"_\"),\n                            requestHeaderEntry.getValue());\n                    }\n\n                    int exitValue = 0;\n                    String cgiBody = null;\n                    final StringBuilder error = new StringBuilder(256);\n\n                    try {\n                        // start execution of script\n                        final Process p = pb.start();\n\n                        final OutputStream os =\n                                new BufferedOutputStream(p.getOutputStream());\n\n                        if (method.equalsIgnoreCase(\n                                HeaderFramework.METHOD_POST) && body != null) {\n                            final byte[] buffer = new byte[1024];\n                            int len = requestHeader.getContentLength();\n                            while (len > 0) {\n                                body.read(buffer);\n                                len = len - buffer.length;\n                                os.write(buffer);\n                            }\n                        }\n\n                        os.close();\n\n                        try {\n                            p.waitFor();\n                        } catch (final InterruptedException ex) {\n\n                        }\n\n                        exitValue = p.exitValue();\n\n                        final InputStream is =\n                                new BufferedInputStream(p.getInputStream());\n\n                        final InputStream es =\n                                new BufferedInputStream(p.getErrorStream());\n\n                        final StringBuilder processOutput =\n                                new StringBuilder(1024);\n\n                        while (is.available() > 0) {\n                            processOutput.append((char) is.read());\n                        }\n\n                        while (es.available() > 0) {\n                            error.append((char) es.read());\n                        }\n\n                        int indexOfDelimiter = processOutput.indexOf(\"\\n\\n\", 0);\n                        final String[] cgiHeader;\n                        if (indexOfDelimiter > -1) {\n                            cgiHeader =\n                                    processOutput.substring(\n                                            0, indexOfDelimiter).split(\"\\n\");\n                        } else {\n                            cgiHeader = new String[0];\n                        }\n                        cgiBody = processOutput.substring(indexOfDelimiter + 1);\n\n                        String key;\n                        String value;\n                        for (final String element : cgiHeader) {\n                            indexOfDelimiter = element.indexOf(':');\n                            key = element.substring(0, indexOfDelimiter).trim();\n                            value = element.substring(indexOfDelimiter + 1).trim();\n                            conProp.put(key, value);\n                            if (\"Cache-Control\".equals(key)\n                                    && \"no-cache\".equals(value)) {\n                                nocache = true;\n                            } else if (\"Content-type\".equals(key)) {\n                                mimeType = value;\n                            } else if (\"Status\".equals(key)) {\n                                if (key.length() > 2) {\n                                    try {\n                                        statusCode =\n                                                Integer.parseInt(\n                                                        value.substring(0, 3));\n                                    } catch (final NumberFormatException ex) {\n                                        Log.logWarning(\n                                                \"HTTPD\",\n                                                \"CGI script \" + targetFile.getPath()\n                                                + \" returned illegal status code \\\"\"\n                                                + value + \"\\\".\");\n                                    }\n                                }\n                            }\n                        }\n                    } catch (final IOException ex) {\n                        exitValue = -1;\n                    }\n\n                    /* did the script return an exit value != 0\n                     * and still there is supposed to be\n                     * everything right with the HTTP status?\n                     * -> change status to 500 since 200 would\n                     * be a lie\n                     */\n                    if (exitValue != 0 && statusCode == 200) {\n                        statusCode = 500;\n                    }\n\n                    targetDate = new Date(System.currentTimeMillis());\n\n                    if (cgiBody != null && !cgiBody.isEmpty()) {\n                        HTTPDemon.sendRespondHeader(\n                                conProp,\n                                out,\n                                httpVersion,\n                                statusCode,\n                                null,\n                                mimeType,\n                                cgiBody.length(),\n                                targetDate,\n                                null,\n                                null,\n                                null,\n                                null,\n                                nocache);\n                        out.write(UTF8.getBytes(cgiBody));\n                    } else {\n                        HTTPDemon.sendRespondError(\n                                conProp,\n                                out,\n                                exitValue,\n                                statusCode,\n                                null,\n                                HeaderFramework.http1_1.get(\n                                        Integer.toString(statusCode)),\n                                null);\n                        Log.logWarning(\n                                \"HTTPD\",\n                                \"CGI script \" + targetFile.getPath()\n                                + \" returned exit value \" + exitValue\n                                + \", body empty: \"\n                                + (cgiBody == null || cgiBody.isEmpty()));\n                        if (error.length() > 0) {\n                            Log.logWarning(\"HTTPD\", \"Reported error: \" + error);\n                        }\n                    }\n                }\n            } else if (targetClass != null && (path.endsWith(\".stream\") || path.indexOf('.') < 0)) {\n                // call rewrite-class\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.endsWith(\".stream\") ? \"stream\" : \"\");\n                //requestHeader.put(httpHeader.CONNECTION_PROP_INPUTSTREAM, body);\n                //requestHeader.put(httpHeader.CONNECTION_PROP_OUTPUTSTREAM, out);\n                ResponseHeader header = new ResponseHeader(200);\n                header.put(HeaderFramework.CONTENT_TYPE, getMimeFromServlet(targetClass, requestHeader, args, \"text/xml\"));\n                conProp.remove(HeaderFramework.CONNECTION_PROP_PERSISTENT);\n                HTTPDemon.sendRespondHeader(conProp, out, httpVersion, 200, header);\n                invokeServlet(targetClass, requestHeader, args, out);\n                forceConnectionClose(conProp);\n                return;\n            } else if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\n                // we have found a file that can be written to the client\n                // if this file uses templates, then we use the template\n                // re-write - method to create an result\n                String mimeType = Classification.ext2mime(targetExt, \"text/html\");\n                String ext = (String) conProp.get(\"EXT\"); if (ext == null) ext = \"\";\n                final boolean zipContent = requestHeader.acceptGzip() && HTTPDemon.shallTransportZipped(\".\" + ext);\n                if (path.endsWith(\"html\") ||\n                        path.endsWith(\"htm\") ||\n                        path.endsWith(\"xml\") ||\n                        path.endsWith(\"json\") ||\n                        path.endsWith(\"rdf\") ||\n                        path.endsWith(\"rss\") ||\n                        path.endsWith(\"csv\") ||\n                        path.endsWith(\"pac\") ||\n                        path.endsWith(\"src\") ||\n                        path.endsWith(\"vcf\") ||\n                        path.endsWith(\"kml\") ||\n                        path.endsWith(\"gpx\") ||\n                        path.endsWith(\"css\") ||\n                        path.endsWith(\"/\") ||\n                        path.equals(\"/robots.txt\")) {\n\n                    /*targetFile = getLocalizedFile(path);\n                    if (!(targetFile.exists())) {\n                        // try to find that file in the htDocsPath\n                        File trialFile = new File(htDocsPath, path);\n                        if (trialFile.exists()) targetFile = trialFile;\n                    }*/\n\n\n                    // call rewrite-class\n\n                    if (targetClass != null) {\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_CLIENTIP, (String) conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP));\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_PATH, path);\n                        final int ep = path.lastIndexOf(\".\");\n                        requestHeader.put(HeaderFramework.CONNECTION_PROP_EXT, path.substring(ep + 1));\n                        // in case that there are no args given, args = null or empty hashmap\n                        final Object tmp = invokeServlet(targetClass, requestHeader, args, null);\n                        if (tmp == null) {\n                            // if no args given, then tp will be an empty Hashtable object (not null)\n                            templatePatterns = new servletProperties();\n                        } else if (tmp instanceof servletProperties) {\n                            templatePatterns = (servletProperties) tmp;\n                        } else {\n                            templatePatterns = new servletProperties((serverObjects) tmp);\n                        }\n                        // check if the servlets requests authentication\n                        if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\n                            // handle brute-force protection\n                            if (realmProp != null) {\n                                Log.logInfo(\"HTTPD\", \"dynamic log-in for account 'admin' in http file handler for path '\" + path + \"' from host '\" + clientIP + \"'\");\n                                final Integer attempts = serverCore.bfHost.get(clientIP);\n                                if (attempts == null)\n                                    serverCore.bfHost.put(clientIP, Integer.valueOf(1));\n                                else\n                                    serverCore.bfHost.put(clientIP, Integer.valueOf(attempts.intValue() + 1));\n                            }\n                            // send authentication request to browser\n                            final ResponseHeader headers = getDefaultHeaders(path);\n                            headers.put(RequestHeader.WWW_AUTHENTICATE,\"Basic realm=\\\"\" + templatePatterns.get(serverObjects.ACTION_AUTHENTICATE, \"\") + \"\\\"\");\n                            HTTPDemon.sendRespondHeader(conProp,out,httpVersion,401,headers);\n                            return;\n                        } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\n                            String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\n                            if (location.isEmpty()) location = path;\n\n                            final ResponseHeader headers = getDefaultHeaders(path);\n                            headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\n                            headers.put(HeaderFramework.LOCATION,location);\n                            HTTPDemon.sendRespondHeader(conProp,out,httpVersion,302,headers);\n                            return;\n                        }\n                        // add the application version, the uptime and the client name to every rewrite table\n                        templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\n                        templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() -  serverCore.startupTime) / 1000) / 60); // uptime in minutes\n                        templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\n                        templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, ((Switchboard) switchboard).peers.myID());\n                        templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\n                        final Seed myPeer = sb.peers.mySeed();\n                        templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\n                        templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\n                        //System.out.println(\"respond props: \" + ((tp == null) ? \"null\" : tp.toString())); // debug\n                        nocache = true;\n                    }\n\n                    targetDate = new Date(targetFile.lastModified());\n                    Date expireDate = null;\n                    if (templatePatterns == null) {\n                    \t// if the file will not be changed, cache it in the browser\n                    \texpireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    }\n\n\n                    // rewrite the file\n                    InputStream fis = null;\n\n                    // read the file/template\n                    TemplateCacheEntry templateCacheEntry = null;\n                    final long fileSize = targetFile.length();\n                    if (useTemplateCache && fileSize <= 512 * 1024) {\n                        // read from cache\n                        SoftReference<TemplateCacheEntry> ref = templateCache.get(targetFile);\n                        if (ref != null) {\n                            templateCacheEntry = ref.get();\n                            if (templateCacheEntry == null) templateCache.remove(targetFile);\n                        }\n\n                        final Date targetFileDate = new Date(targetFile.lastModified());\n                        if (templateCacheEntry == null || targetFileDate.after(templateCacheEntry.lastModified)) {\n                            // loading the content of the template file into\n                            // a byte array\n                            templateCacheEntry = new TemplateCacheEntry();\n                            templateCacheEntry.lastModified = targetFileDate;\n                            templateCacheEntry.content = FileUtils.read(targetFile);\n\n                            // storing the content into the cache\n                            ref = new SoftReference<TemplateCacheEntry>(templateCacheEntry);\n                            if (MemoryControl.shortStatus()) templateCache.clear();\n                            templateCache.put(targetFile, ref);\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache MISS for file \" + targetFile);\n                        } else {\n                            if (theLogger.isFinest()) theLogger.logFinest(\"Cache HIT for file \" + targetFile);\n                        }\n\n                        // creating an inputstream needed by the template\n                        // rewrite function\n                        fis = new ByteArrayInputStream(templateCacheEntry.content);\n                        templateCacheEntry = null;\n                    } else if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\n                        // read file completely into ram, avoid that too many files are open at the same time\n                        fis = new ByteArrayInputStream(FileUtils.read(targetFile));\n                    } else {\n                        fis = new BufferedInputStream(new FileInputStream(targetFile));\n                    }\n\n                    if (mimeType.startsWith(\"text\")) {\n                        // every text-file distributed by yacy is UTF-8\n                        if (!path.startsWith(\"/repository\")) {\n                            mimeType = mimeType + \"; charset=UTF-8\";\n                        } else {\n                            // detect charset of html-files\n                            if ((path.endsWith(\"html\") || path.endsWith(\"htm\"))) {\n                                // save position\n                                fis.mark(1000);\n                                // scrape document to look up charset\n                                final ScraperInputStream htmlFilter = new ScraperInputStream(fis, \"UTF-8\", new DigestURI(\"http://localhost\"), null, false, 10);\n                                final String charset = htmlParser.patchCharsetEncoding(htmlFilter.detectCharset());\n                                htmlFilter.close();\n                                if (charset != null) mimeType = mimeType + \"; charset=\"+charset;\n                                // reset position\n                                fis.reset();\n                            }\n                        }\n                    }\n\n                    // write the array to the client\n                    // we can do that either in standard mode (whole thing completely) or in chunked mode\n                    // since yacy clients do not understand chunked mode (yet), we use this only for communication with the administrator\n                    final boolean yacyClient = requestHeader.userAgent().startsWith(\"yacy\");\n                    final boolean chunked = !method.equals(HeaderFramework.METHOD_HEAD) && !yacyClient && httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1);\n                    if (chunked) {\n                        // send page in chunks and parse SSIs\n                        final ByteBuffer o = new ByteBuffer();\n                        // apply templates\n                        TemplateEngine.writeTemplate(fis, o, templatePatterns, UNRESOLVED_PATTERN);\n                        fis.close();\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        HTTPDemon.sendRespondHeader(conProp, out,\n                                httpVersion, rh.getStatusCode(), null, mimeType, -1,\n                                targetDate, expireDate, rh,\n                                null, \"chunked\", nocache);\n                        // send the content in chunked parts, see RFC 2616 section 3.6.1\n                        final ChunkedOutputStream chos = new ChunkedOutputStream(out);\n                        // GZIPOutputStream does not implement flush (this is a bug IMHO)\n                        // so we can't compress this stuff, without loosing the cool SSI trickle feature\n                        ServerSideIncludes.writeSSI(o, chos, realmProp, clientIP, requestHeader);\n                        //chos.write(result);\n                        chos.finish();\n                    } else {\n                        // send page as whole thing, SSIs are not possible\n                        final String contentEncoding = (zipContent) ? \"gzip\" : null;\n                        // apply templates\n                        final ByteBuffer o1 = new ByteBuffer();\n                        TemplateEngine.writeTemplate(fis, o1, templatePatterns, ASCII.getBytes(\"-UNRESOLVED_PATTERN-\"));\n                        fis.close();\n                        final ByteBuffer o = new ByteBuffer();\n\n                        if (zipContent) {\n                            GZIPOutputStream zippedOut = new GZIPOutputStream(o);\n                            ServerSideIncludes.writeSSI(o1, zippedOut, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, zippedOut, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                            zippedOut.finish();\n                            zippedOut.flush();\n                            zippedOut.close();\n                            zippedOut = null;\n                        } else {\n                            ServerSideIncludes.writeSSI(o1, o, realmProp, clientIP, requestHeader);\n                            //httpTemplate.writeTemplate(fis, o, tp, \"-UNRESOLVED_PATTERN-\".getBytes(\"UTF-8\"));\n                        }\n                        ResponseHeader rh = (templatePatterns == null) ? new ResponseHeader(200) : templatePatterns.getOutgoingHeader();\n                        if (method.equals(HeaderFramework.METHOD_HEAD)) {\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, o.length(),\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                        } else {\n                            final byte[] result = o.getBytes(); // this interrupts streaming (bad idea!)\n                            HTTPDemon.sendRespondHeader(conProp, out,\n                                    httpVersion, rh.getStatusCode(), null, mimeType, result.length,\n                                    targetDate, expireDate, rh,\n                                    contentEncoding, null, nocache);\n                            FileUtils.copy(result, out);\n                        }\n                    }\n                } else { // no html\n\n                    int statusCode = 200;\n                    int rangeStartOffset = 0;\n                    final ResponseHeader header = new ResponseHeader(statusCode);\n\n                    // adding the accept ranges header\n                    header.put(HeaderFramework.ACCEPT_RANGES, \"bytes\");\n\n                    // reading the files md5 hash if availabe and use it as ETAG of the resource\n                    String targetMD5 = null;\n                    final File targetMd5File = new File(targetFile + \".md5\");\n                    try {\n                        if (targetMd5File.exists()) {\n                            //String description = null;\n                            targetMD5 = UTF8.String(FileUtils.read(targetMd5File));\n                            final int pos = targetMD5.indexOf('\\n');\n                            if (pos >= 0) {\n                                //description = targetMD5.substring(pos + 1);\n                                targetMD5 = targetMD5.substring(0, pos);\n                            }\n\n                            // using the checksum as ETAG header\n                            header.put(HeaderFramework.ETAG, targetMD5);\n                        }\n                    } catch (final IOException e) {\n                        Log.logException(e);\n                    }\n\n                    if (requestHeader.containsKey(HeaderFramework.RANGE)) {\n                        final Object ifRange = requestHeader.ifRange();\n                        if ((ifRange == null)||\n                            (ifRange instanceof Date && targetFile.lastModified() == ((Date)ifRange).getTime()) ||\n                            (ifRange instanceof String && ifRange.equals(targetMD5))) {\n                            final String rangeHeaderVal = requestHeader.get(HeaderFramework.RANGE).trim();\n                            if (rangeHeaderVal.startsWith(\"bytes=\")) {\n                                final String rangesVal = rangeHeaderVal.substring(\"bytes=\".length());\n                                final String[] ranges = rangesVal.split(\",\");\n                                if ((ranges.length == 1)&&(ranges[0].endsWith(\"-\"))) {\n                                    rangeStartOffset = NumberTools.parseIntDecSubstring(ranges[0], 0, ranges[0].length() - 1);\n                                    statusCode = 206;\n                                    header.put(HeaderFramework.CONTENT_RANGE, \"bytes \" + rangeStartOffset + \"-\" + (targetFile.length()-1) + \"/\" + targetFile.length());\n                                }\n                            }\n                        }\n                    }\n\n                    // write the file to the client\n                    targetDate = new Date(targetFile.lastModified());\n                    // cache file for one month in browser (but most browsers won't cache for that long)\n                    final Date expireDate = new Date(new Date().getTime() + (31l * 24 * 60 * 60 * 1000));\n                    final long   contentLength    = (zipContent)?-1:targetFile.length()-rangeStartOffset;\n                    final String contentEncoding  = (zipContent) ? \"gzip\" : null;\n                    final String transferEncoding = (httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) ? \"chunked\" : null;\n                    if (!httpVersion.equals(HeaderFramework.HTTP_VERSION_1_1) && zipContent) forceConnectionClose(conProp);\n\n                    HTTPDemon.sendRespondHeader(conProp, out, httpVersion, statusCode, null, mimeType, contentLength, targetDate, expireDate, header, contentEncoding, transferEncoding, nocache);\n\n                    if (!method.equals(HeaderFramework.METHOD_HEAD)) {\n                        ChunkedOutputStream chunkedOut = null;\n                        GZIPOutputStream zipped = null;\n                        OutputStream newOut = out;\n\n                        if (transferEncoding != null) {\n                            chunkedOut = new ChunkedOutputStream(newOut);\n                            newOut = chunkedOut;\n                        }\n                        if (contentEncoding != null) {\n                            zipped = new GZIPOutputStream(newOut);\n                            newOut = zipped;\n                        }\n\n                        FileUtils.copyRange(targetFile, newOut, rangeStartOffset);\n\n                        if (zipped != null) {\n                            zipped.flush();\n                            zipped.finish();\n                        }\n                        if (chunkedOut != null) {\n                            chunkedOut.finish();\n                        }\n\n                        // flush all\n                        try {newOut.flush();}catch (final Exception e) {}\n                    }\n                }\n            } else {\n                HTTPDemon.sendRespondError(conProp,out,3,404,\"File not Found\",null,null);\n                return;\n            }\n        } catch (final Exception e) {\n            try {\n                // error handling\n                if (e instanceof NullPointerException) {\n                    Log.logException(e);\n                }\n                int httpStatusCode = 400;\n                final String httpStatusText = null;\n                final StringBuilder errorMessage = new StringBuilder(2000);\n                Exception errorExc = null;\n\n                final String errorMsg = e.getMessage();\n                if (\n                        (e instanceof InterruptedException) ||\n                        ((errorMsg != null) && (errorMsg.startsWith(\"Socket closed\")) && (Thread.currentThread().isInterrupted()))\n                   ) {\n                    errorMessage.append(\"Interruption detected while processing query.\");\n                    httpStatusCode = 503;\n                } else {\n                    if ((errorMsg != null) &&\n                        (\n                           errorMsg.contains(\"Broken pipe\") ||\n                           errorMsg.contains(\"Connection reset\") ||\n                           errorMsg.contains(\"Read timed out\") ||\n                           errorMsg.contains(\"Connection timed out\") ||\n                           errorMsg.contains(\"Software caused connection abort\")\n                       )) {\n                        // client closed the connection, so we just end silently\n                        errorMessage.append(\"Client unexpectedly closed connection while processing query.\");\n                    } else {\n                        errorMessage.append(\"Unexpected error while processing query.\");\n                        httpStatusCode = 500;\n                        errorExc = e;\n                    }\n                }\n\n                errorMessage.append(\"\\nSession: \").append(Thread.currentThread().getName())\n                            .append(\"\\nQuery:   \").append(path)\n                            .append(\"\\nClient:  \").append(conProp.get(HeaderFramework.CONNECTION_PROP_CLIENTIP))\n                            .append(\"\\nReason:  \").append(e.getMessage());\n\n                if (!conProp.containsKey(HeaderFramework.CONNECTION_PROP_PROXY_RESPOND_HEADER)) {\n                    // sending back an error message to the client\n                    // if we have not already send an http header\n                    HTTPDemon.sendRespondError(conProp,out, 4, httpStatusCode, httpStatusText, errorMessage.toString(), errorExc);\n                } else {\n                    // otherwise we close the connection\n                    forceConnectionClose(conProp);\n                }\n\n                // if it is an unexpected error we log it\n                if (httpStatusCode == 500) {\n                    theLogger.logWarning(errorMessage.toString(), e);\n                }\n\n            } catch (final Exception ee) {\n                forceConnectionClose(conProp);\n            }\n\n        } finally {\n            try {out.flush();}catch (final Exception e) {}\n        }\n    }","commit_id":"aab0b680c362284fe22b48d13c4b3fee820a3191","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static final Method rewriteMethod(final File classFile) throws InvocationTargetException {\n        Method m = null;\n        // now make a class out of the stream\n        try {\n            if (templateMethodCache != null) {\n                final SoftReference<Method> ref = templateMethodCache.get(classFile);\n                if (ref != null) {\n                    m = ref.get();\n                    if (m == null) {\n                        templateMethodCache.remove(classFile);\n                    } else {\n                        return m;\n                    }\n                }\n            }\n\n            final Class<?> c = provider.loadClass(classFile);\n            Class<?>[] params = new Class[] {\n                    RequestHeader.class,\n                    serverObjects.class,\n                    serverSwitch.class };\n            try {\n                m = c.getMethod(\"respond\", params);\n            } catch (NoSuchMethodException e) {\n                params = new Class[] {\n                    RequestHeader.class,\n                    serverObjects.class,\n                    serverSwitch.class,\n                    OutputStream.class};\n                m = c.getMethod(\"respond\", params);\n            }\n\n            if (MemoryControl.shortStatus()) {\n                templateMethodCache.clear();\n            } else {\n                // storing the method into the cache\n                final SoftReference<Method> ref = new SoftReference<Method>(m);\n                templateMethodCache.put(classFile, ref);\n            }\n\n        } catch (final ClassNotFoundException e) {\n            Log.logSevere(\"HTTPDFileHandler\", \"class \" + classFile + \" is missing:\" + e.getMessage());\n            throw new InvocationTargetException(e, \"class \" + classFile + \" is missing:\" + e.getMessage());\n        } catch (final NoSuchMethodException e) {\n            Log.logSevere(\"HTTPDFileHandler\", \"method 'respond' not found in class \" + classFile + \": \" + e.getMessage());\n            throw new InvocationTargetException(e, \"method 'respond' not found in class \" + classFile + \": \" + e.getMessage());\n        }\n        return m;\n    }","id":85327,"modified_method":"private static final Method rewriteMethod(final File classFile, final String methodName) throws InvocationTargetException {\n        Method m = null;\n        // now make a class out of the stream\n        try {\n            if (templateMethodCache != null && \"respond\".equals(methodName)) {\n                final SoftReference<Method> ref = templateMethodCache.get(classFile);\n                if (ref != null) {\n                    m = ref.get();\n                    if (m == null) {\n                        templateMethodCache.remove(classFile);\n                    } else {\n                        return m;\n                    }\n                }\n            }\n\n            final Class<?> c = provider.loadClass(classFile);\n            Class<?>[] params = new Class[] {\n                    RequestHeader.class,\n                    serverObjects.class,\n                    serverSwitch.class };\n            try {\n                m = c.getMethod(methodName, params);\n            } catch (NoSuchMethodException e) {\n                params = new Class[] {\n                    RequestHeader.class,\n                    serverObjects.class,\n                    serverSwitch.class,\n                    OutputStream.class};\n                m = c.getMethod(methodName, params);\n            }\n\n            if (MemoryControl.shortStatus()) {\n                templateMethodCache.clear();\n            } else {\n                // store the method into the cache\n                if (templateMethodCache != null && \"respond\".equals(methodName)) {\n                    templateMethodCache.put(classFile, new SoftReference<Method>(m));\n                }\n            }\n\n        } catch (final ClassNotFoundException e) {\n            Log.logSevere(\"HTTPDFileHandler\", \"class \" + classFile + \" is missing:\" + e.getMessage());\n            throw new InvocationTargetException(e, \"class \" + classFile + \" is missing:\" + e.getMessage());\n        } catch (final NoSuchMethodException e) {\n            Log.logSevere(\"HTTPDFileHandler\", \"method 'respond' not found in class \" + classFile + \": \" + e.getMessage());\n            throw new InvocationTargetException(e, \"method 'respond' not found in class \" + classFile + \": \" + e.getMessage());\n        }\n        return m;\n    }","commit_id":"aab0b680c362284fe22b48d13c4b3fee820a3191","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static final Object invokeServlet(final File targetClass, final RequestHeader request, final serverObjects args, final OutputStream os) {\n        try {\n            if (os == null) {\n                return rewriteMethod(targetClass).invoke(null, new Object[] {request, args, switchboard});\n            }\n            return rewriteMethod(targetClass).invoke(null, new Object[] {request, args, switchboard, os});\n        } catch (final Throwable e) {\n            theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                            e.getMessage() +\n                            \" target exception at \" + targetClass + \": \" +\n                            \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\");\n            Log.logException(e);\n            Log.logException(e.getCause());\n            if (e instanceof InvocationTargetException) Log.logException(((InvocationTargetException) e).getTargetException());\n            return null;\n        }\n    }","id":85328,"modified_method":"private static final Object invokeServlet(final File targetClass, final RequestHeader request, final serverObjects args, final OutputStream os) {\n        try {\n            if (os == null) {\n                return rewriteMethod(targetClass, \"respond\").invoke(null, new Object[] {request, args, switchboard});\n            }\n            return rewriteMethod(targetClass, \"respond\").invoke(null, new Object[] {request, args, switchboard, os});\n        } catch (final Throwable e) {\n            theLogger.logSevere(\"INTERNAL ERROR: \" + e.toString() + \":\" +\n                            e.getMessage() +\n                            \" target exception at \" + targetClass + \": \" +\n                            \"; java.awt.graphicsenv='\" + System.getProperty(\"java.awt.graphicsenv\",\"\") + \"'\");\n            Log.logException(e);\n            Log.logException(e.getCause());\n            if (e instanceof InvocationTargetException) Log.logException(((InvocationTargetException) e).getTargetException());\n            return null;\n        }\n    }","commit_id":"aab0b680c362284fe22b48d13c4b3fee820a3191","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n         *\r\n         *\r\n         * @see java.lang.Thread#run()\r\n         */\r\n        @Override\r\n        public void run()  {\r\n            this.runningsession = true;\r\n\r\n            try {\r\n                // setting the session startup time\r\n                this.start = System.currentTimeMillis();\r\n\r\n                // set the session identity\r\n                this.identity = \"-\";\r\n\r\n                // getting some client information\r\n                this.userAddress = this.controlSocket.getInetAddress();\r\n                this.userPort = this.controlSocket.getPort();\r\n                setName(\"Session_\" + this.userAddress.getHostAddress() + \":\" + this.controlSocket.getPort());\r\n\r\n                // TODO: check if we want to allow this socket to connect us\r\n\r\n                // getting input and output stream for communication with client\r\n                if (this.controlSocket.getInputStream() instanceof PushbackInputStream) {\r\n                    this.in = (PushbackInputStream) this.controlSocket.getInputStream();\r\n                } else {\r\n                    this.in = new PushbackInputStream(this.controlSocket.getInputStream());\r\n                }\r\n                this.out = this.controlSocket.getOutputStream();\r\n\r\n                // reseting the command counter\r\n                this.commandCounter = 0;\r\n\r\n                // listen for commands\r\n                listen();\r\n            } catch (final IOException e) {\r\n                Log.logException(e);\r\n            } catch (final Exception e) {\r\n                Log.logException(e);\r\n            } finally {\r\n                try {\r\n                    if ((this.controlSocket != null) && (! this.controlSocket.isClosed())) {\r\n                        // flush data\r\n                        this.out.flush();\r\n\r\n                        // maybe this doesn't work for all SSL socket implementations\r\n                        if (!(this.controlSocket instanceof SSLSocket)) {\r\n                            this.controlSocket.shutdownInput();\r\n                            this.controlSocket.shutdownOutput();\r\n                        }\r\n\r\n                        // close streams\r\n                        this.in.close();\r\n                        this.out.close();\r\n\r\n                        // close everything\r\n                        this.controlSocket.close();\r\n                    }\r\n                } catch (final IOException e) {\r\n                    Log.logException(e);\r\n                } finally {\r\n                    this.controlSocket = null;\r\n                }\r\n            }\r\n\r\n        }","id":85329,"modified_method":"/**\r\n         *\r\n         *\r\n         * @see java.lang.Thread#run()\r\n         */\r\n        @Override\r\n        public void run()  {\r\n            this.runningsession = true;\r\n\r\n            try {\r\n                // setting the session startup time\r\n                this.start = System.currentTimeMillis();\r\n\r\n                // set the session identity\r\n                this.identity = \"-\";\r\n\r\n                // getting some client information\r\n                this.userAddress = this.controlSocket.getInetAddress();\r\n                this.userPort = this.controlSocket.getPort();\r\n                setName(\"Session_\" + this.userAddress.getHostAddress() + \":\" + this.controlSocket.getPort());\r\n\r\n                // TODO: check if we want to allow this socket to connect us\r\n\r\n                // getting input and output stream for communication with client\r\n                if (this.controlSocket.getInputStream() instanceof PushbackInputStream) {\r\n                    this.in = (PushbackInputStream) this.controlSocket.getInputStream();\r\n                } else {\r\n                    this.in = new PushbackInputStream(this.controlSocket.getInputStream());\r\n                }\r\n                this.out = this.controlSocket.getOutputStream();\r\n\r\n                // reseting the command counter\r\n                this.commandCounter = 0;\r\n\r\n                // listen for commands\r\n                listen();\r\n            } catch (final IOException e) {\r\n                Log.logException(e);\r\n            } catch (final Throwable e) {\r\n                Log.logException(e);\r\n                final Throwable targetException = (e instanceof InvocationTargetException) ? ((InvocationTargetException) e).getTargetException() : null;\r\n                Log.logException(e.getCause());\r\n                if (targetException != null) Log.logException(targetException);\r\n            } finally {\r\n                try {\r\n                    if ((this.controlSocket != null) && (! this.controlSocket.isClosed())) {\r\n                        // flush data\r\n                        this.out.flush();\r\n\r\n                        // maybe this doesn't work for all SSL socket implementations\r\n                        if (!(this.controlSocket instanceof SSLSocket)) {\r\n                            this.controlSocket.shutdownInput();\r\n                            this.controlSocket.shutdownOutput();\r\n                        }\r\n\r\n                        // close streams\r\n                        this.in.close();\r\n                        this.out.close();\r\n\r\n                        // close everything\r\n                        this.controlSocket.close();\r\n                    }\r\n                } catch (final IOException e) {\r\n                    Log.logException(e);\r\n                } finally {\r\n                    this.controlSocket = null;\r\n                }\r\n            }\r\n\r\n        }","commit_id":"aab0b680c362284fe22b48d13c4b3fee820a3191","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void stop(BundleContext bundleContext) throws Exception {\n    }","id":85330,"modified_method":"public void stop(BundleContext bundleContext) throws Exception\n    {\n        uiService.getAccountRegWizardContainer()\n            .removeAccountRegistrationWizard(aimWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        AimAccountRegistrationWizard aimWizard\n            = new AimAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(aimWizard);\n    }","id":85331,"modified_method":"/**\n     * Starts this bundle.\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        uiService = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        aimWizard = new AimAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(aimWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     * @param bc the currently valid <tt>BundleContext<\/tt>.\n     */\n    public void start(BundleContext bc)\n    {\n        logger.info(\"Loading gibberish account wizard.\");\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        GibberishAccountRegistrationWizard gibberishWizard\n            = new GibberishAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(gibberishWizard);\n\n        logger.info(\"Gibberish account registration wizard [STARTED].\");\n    }","id":85332,"modified_method":"/**\n     * Starts this bundle.\n     * @param bc the currently valid <tt>BundleContext<\/tt>.\n     */\n    public void start(BundleContext bc)\n    {\n        logger.info(\"Loading gibberish account wizard.\");\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService = (UIService) bundleContext.getService(uiServiceRef);\n\n        wizardContainer = uiService.getAccountRegWizardContainer();\n\n        gibberishWizard\n            = new GibberishAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(gibberishWizard);\n\n        logger.info(\"Gibberish account registration wizard [STARTED].\");\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Called when this bundle is stopped so the Framework can perform the\n     * bundle-specific activities necessary to stop the bundle.\n     *\n     * @param context The execution context of the bundle being stopped.\n     */\n    public void stop(BundleContext context)\n    {\n\n    }","id":85333,"modified_method":"/**\n     * Called when this bundle is stopped so the Framework can perform the\n     * bundle-specific activities necessary to stop the bundle.\n     *\n     * @param context The execution context of the bundle being stopped.\n     */\n    public void stop(BundleContext bundleContext) throws Exception\n    {\n        wizardContainer.removeAccountRegistrationWizard(gibberishWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void stop(BundleContext bundleContext) throws Exception {\n    }","id":85334,"modified_method":"public void stop(BundleContext bundleContext) throws Exception\n    {\n        wizardContainer.removeAccountRegistrationWizard(icqWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        IcqAccountRegistrationWizard icqWizard\n            = new IcqAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(icqWizard);\n    }","id":85335,"modified_method":"/**\n     * Starts this bundle.\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        wizardContainer = uiService.getAccountRegWizardContainer();\n\n        icqWizard = new IcqAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(icqWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void stop(BundleContext bundleContext)\n        throws Exception\n    {\n    }","id":85336,"modified_method":"public void stop(BundleContext bundleContext)\n        throws Exception\n    {\n        wizardContainer.removeAccountRegistrationWizard(jabberWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        JabberAccountRegistrationWizard jabberWizard\n            = new JabberAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(jabberWizard);\n    }","id":85337,"modified_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        wizardContainer = uiService.getAccountRegWizardContainer();\n\n        jabberWizard = new JabberAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(jabberWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void stop(BundleContext bundleContext) throws Exception {\n    }","id":85338,"modified_method":"public void stop(BundleContext bundleContext) throws Exception\n    {\n        wizardContainer.removeAccountRegistrationWizard(msnWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        MsnAccountRegistrationWizard msnWizard\n            = new MsnAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(msnWizard);\n    }","id":85339,"modified_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        wizardContainer = uiService.getAccountRegWizardContainer();\n\n        msnWizard = new MsnAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(msnWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void stop(BundleContext bundleContext) throws Exception {\n    }","id":85340,"modified_method":"public void stop(BundleContext bundleContext) throws Exception\n    {\n        wizardContainer.removeAccountRegistrationWizard(sipWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        SIPAccountRegistrationWizard sipWizard\n            = new SIPAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(sipWizard);\n    }","id":85341,"modified_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        wizardContainer = uiService.getAccountRegWizardContainer();\n\n        sipWizard = new SIPAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(sipWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        AccountRegistrationWizardContainer wizardContainer\n            = uiService.getAccountRegWizardContainer();\n\n        YahooAccountRegistrationWizard yahooWizard\n            = new YahooAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(yahooWizard);\n    }","id":85342,"modified_method":"/**\n     * Starts this bundle.\n     * @param bc BundleContext\n     * @throws Exception\n     */\n    public void start(BundleContext bc) throws Exception {\n\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        UIService uiService\n            = (UIService) bundleContext.getService(uiServiceRef);\n\n        wizardContainer = uiService.getAccountRegWizardContainer();\n\n        yahooWizard = new YahooAccountRegistrationWizard(wizardContainer);\n\n        wizardContainer.addAccountRegistrationWizard(yahooWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void stop(BundleContext bundleContext) throws Exception {\n    }","id":85343,"modified_method":"public void stop(BundleContext bundleContext) throws Exception\n    {\n        wizardContainer.removeAccountRegistrationWizard(yahooWizard);\n    }","commit_id":"8bfa6d8d0eb68411048a5181f5c99df1d9a45137","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the bundleContext that we received when we were started.\n     *\n     * @return a currently valid instance of a bundleContext.\n     */\n    public BundleContext getBundleContext()\n    {\n        return bundleContext;\n    }","id":85344,"modified_method":"@Override\n    public void setBundleContext(BundleContext context)\n    {\n        bundleContext = context;\n    }","commit_id":"4dab0a4d3133e05dc0cace395fcffdeaee0415a5","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns the <tt>UIService<\/tt>.\n     *\n     * @return the <tt>UIService<\/tt>\n     */\n    public static UIService getUIService()\n    {\n        return uiService;\n    }","id":85345,"modified_method":"public static UIService getUIService()\n    {\n        return uiService;\n    }","commit_id":"4dab0a4d3133e05dc0cace395fcffdeaee0415a5","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Called when this bundle is stopped so the Framework can perform the\n     * bundle-specific activities necessary to stop the bundle.\n     *\n     * @param context The execution context of the bundle being stopped.\n     */\n    public void stop(BundleContext context)\n    {\n    }","id":85346,"modified_method":"public void stop(BundleContext bundleContext)\n    {\n    }","commit_id":"4dab0a4d3133e05dc0cace395fcffdeaee0415a5","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Test\n  public void search_for_project_qp() {\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Sonar way\");\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAtAsDate(new Date())\n      .setName(\"Another way\");\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n    qualityProfileDb.insertProjectWithQualityProfileAssociations(project, qualityProfileOnXoo1, qualityProfileOnXoo2);\n\n    String result = ws.newRequest()\n      .setParam(PARAM_PROJECT_KEY, project.key())\n      .execute().getInput();\n\n    assertThat(result)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n  }","id":85347,"modified_method":"@Test\n  public void search_for_project_qp() {\n    long time = DateUtils.parseDateTime(\"2016-12-22T19:10:03+0100\").getTime();\n    QualityProfileDto qualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-12345\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAt(\"2016-12-21T19:10:03+0100\")\n      .setLastUsed(time)\n      .setName(\"Sonar way\");\n    QualityProfileDto qualityProfileOnXoo2 = QualityProfileDto.createFor(\"sonar-way-xoo2-12345\")\n      .setLanguage(xoo2.getKey())\n      .setRulesUpdatedAt(\"2016-12-21T19:10:03+0100\")\n      .setLastUsed(time)\n      .setName(\"Sonar way\");\n    QualityProfileDto anotherQualityProfileOnXoo1 = QualityProfileDto.createFor(\"sonar-way-xoo1-45678\")\n      .setLanguage(xoo1.getKey())\n      .setRulesUpdatedAt(\"2016-12-21T19:10:03+0100\")\n      .setLastUsed(time)\n      .setName(\"Another way\");\n    ComponentDto project = newProjectDto(\"project-uuid\");\n    qualityProfileDb.insertQualityProfiles(qualityProfileOnXoo1, qualityProfileOnXoo2, anotherQualityProfileOnXoo1);\n    qualityProfileDb.insertProjectWithQualityProfileAssociations(project, qualityProfileOnXoo1, qualityProfileOnXoo2);\n\n    SearchWsResponse result = call(ws.newRequest().setParam(PARAM_PROJECT_KEY, project.key()));\n\n    assertThat(result.getProfilesList())\n      .hasSize(2)\n      .extracting(QualityProfile::getKey)\n      .contains(\"sonar-way-xoo1-12345\", \"sonar-way-xoo2-12345\")\n      .doesNotContain(\"sonar-way-xoo1-45678\");\n    assertThat(result.getProfilesList())\n      .extracting(QualityProfile::getRulesUpdatedAt, QualityProfile::getLastUsed)\n      .contains(tuple(\"2016-12-21T19:10:03+0100\", formatDateTime(time)));\n  }","commit_id":"4a903ae093c0744034e74ae6fab20f2b50a1250b","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void installUI(JComponent c) {\n    super.installUI(c);\n    tree.setDragEnabled(true);\n  }","id":85348,"modified_method":"@Override\n  public void installUI(JComponent c) {\n    super.installUI(c);\n    if (!GraphicsEnvironment.isHeadless()) {\n      tree.setDragEnabled(true);\n    }\n  }","commit_id":"3154459c2b50eff94b9bddbd7b4abaff771e52f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * initialize the table\n     */\n    protected void init() {\n        MemberRoleCellEditor ce = (MemberRoleCellEditor) getColumnModel().getColumn(0).getCellEditor();\n        setRowHeight(ce.getEditor().getPreferredSize().height);\n        setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n        setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n        putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n\n        // make ENTER behave like TAB\n        //\n        getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0, false), \"selectNextColumnCell\");\n\n        initHighlighting();\n\n        // install custom navigation actions\n        //\n        getActionMap().put(\"selectNextColumnCell\", new SelectNextColumnCellAction());\n        getActionMap().put(\"selectPreviousColumnCell\", new SelectPreviousColumnCellAction());\n\n        setTransferHandler(new MemberTransferHandler());\n        setFillsViewportHeight(true); // allow drop on empty table\n        setDragEnabled(true);\n        setDropMode(DropMode.INSERT_ROWS);\n    }","id":85349,"modified_method":"/**\n     * initialize the table\n     */\n    protected void init() {\n        MemberRoleCellEditor ce = (MemberRoleCellEditor) getColumnModel().getColumn(0).getCellEditor();\n        setRowHeight(ce.getEditor().getPreferredSize().height);\n        setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n        setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n        putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n\n        // make ENTER behave like TAB\n        //\n        getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(\n                KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0, false), \"selectNextColumnCell\");\n\n        initHighlighting();\n\n        // install custom navigation actions\n        //\n        getActionMap().put(\"selectNextColumnCell\", new SelectNextColumnCellAction());\n        getActionMap().put(\"selectPreviousColumnCell\", new SelectPreviousColumnCellAction());\n\n        if (!GraphicsEnvironment.isHeadless()) {\n            setTransferHandler(new MemberTransferHandler());\n            setFillsViewportHeight(true); // allow drop on empty table\n            setDragEnabled(true);\n            setDropMode(DropMode.INSERT_ROWS);\n        }\n    }","commit_id":"40173bd3fedcff64c956e1fd5d943e7a55804b37","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Builds the content panel for this dialog\n     */\n    protected void buildContentPanel() {\n        lstPrimitives = new JList<>(model);\n        lstPrimitives.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n        lstPrimitives.setSelectionModel(selectionModel);\n        lstPrimitives.setCellRenderer(new OsmPrimitivRenderer());\n        lstPrimitives.setTransferHandler(new SelectionTransferHandler());\n        lstPrimitives.setDragEnabled(true);\n\n        lstPrimitives.getSelectionModel().addListSelectionListener(actSelect);\n        lstPrimitives.getSelectionModel().addListSelectionListener(actShowHistory);\n\n        // the select action\n        final SideButton selectButton = new SideButton(actSelect);\n        selectButton.createArrow(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                SelectionHistoryPopup.launch(selectButton, model.getSelectionHistory());\n            }\n        });\n\n        // the search button\n        final SideButton searchButton = new SideButton(actSearch);\n        searchButton.createArrow(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                SearchPopupMenu.launch(searchButton);\n            }\n        });\n\n        createLayout(lstPrimitives, true, Arrays.asList(new SideButton[] {\n            selectButton, searchButton, new SideButton(actShowHistory)\n        }));\n    }","id":85350,"modified_method":"/**\n     * Builds the content panel for this dialog\n     */\n    protected void buildContentPanel() {\n        lstPrimitives = new JList<>(model);\n        lstPrimitives.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n        lstPrimitives.setSelectionModel(selectionModel);\n        lstPrimitives.setCellRenderer(new OsmPrimitivRenderer());\n        lstPrimitives.setTransferHandler(new SelectionTransferHandler());\n        if (!GraphicsEnvironment.isHeadless()) {\n            lstPrimitives.setDragEnabled(true);\n        }\n\n        lstPrimitives.getSelectionModel().addListSelectionListener(actSelect);\n        lstPrimitives.getSelectionModel().addListSelectionListener(actShowHistory);\n\n        // the select action\n        final SideButton selectButton = new SideButton(actSelect);\n        selectButton.createArrow(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                SelectionHistoryPopup.launch(selectButton, model.getSelectionHistory());\n            }\n        });\n\n        // the search button\n        final SideButton searchButton = new SideButton(actSearch);\n        searchButton.createArrow(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                SearchPopupMenu.launch(searchButton);\n            }\n        });\n\n        createLayout(lstPrimitives, true, Arrays.asList(new SideButton[] {\n            selectButton, searchButton, new SideButton(actShowHistory)\n        }));\n    }","commit_id":"40173bd3fedcff64c956e1fd5d943e7a55804b37","url":"https://github.com/openstreetmap/josm"},{"original_method":"@NotNull\n    public List<JetImportDirective> getImports() {\n        return Arrays.asList(getStubOrPsiChildren(JetStubElementTypes.IMPORT_DIRECTIVE, JetImportDirective.ARRAY_FACTORY));\n    }","id":85351,"modified_method":"@NotNull\n    public List<JetImportDirective> getImports() {\n        return getStubOrPsiChildrenAsList(JetStubElementTypes.IMPORT_DIRECTIVE);\n    }","commit_id":"1d3a3aea0970a826fa9bdfa090e2c080ff57d2cf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public List<JetParameter> getParameters() {\n        return Arrays.asList(getStubOrPsiChildren(JetStubElementTypes.VALUE_PARAMETER, JetParameter.ARRAY_FACTORY));\n    }","id":85352,"modified_method":"@NotNull\n    public List<JetParameter> getParameters() {\n        return getStubOrPsiChildrenAsList(JetStubElementTypes.VALUE_PARAMETER);\n    }","commit_id":"1d3a3aea0970a826fa9bdfa090e2c080ff57d2cf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetStubElementType(@NotNull @NonNls String debugName, @NotNull Class<PsiT> psiClass, @NotNull Class<?> stubClass) {\n        super(debugName, JetLanguage.INSTANCE);\n        try {\n            byNodeConstructor = psiClass.getConstructor(ASTNode.class);\n            byStubConstructor = psiClass.getConstructor(stubClass);\n        }\n        catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"Stub element type declaration for \" + psiClass.getSimpleName() + \" is missing required constructors\",e);\n        }\n    }","id":85353,"modified_method":"public JetStubElementType(@NotNull @NonNls String debugName, @NotNull final Class<PsiT> psiClass, @NotNull Class<?> stubClass) {\n        super(debugName, JetLanguage.INSTANCE);\n        try {\n            byNodeConstructor = psiClass.getConstructor(ASTNode.class);\n            byStubConstructor = psiClass.getConstructor(stubClass);\n        }\n        catch (NoSuchMethodException e) {\n            throw new RuntimeException(\"Stub element type declaration for \" + psiClass.getSimpleName() + \" is missing required constructors\",e);\n        }\n        //noinspection unchecked\n        emptyArray = (PsiT[]) Array.newInstance(psiClass, 0);\n        arrayFactory = new ArrayFactory<PsiT>() {\n            @NotNull\n            @Override\n            public PsiT[] create(int count) {\n                if (count == 0) {\n                    return emptyArray;\n                }\n                //noinspection unchecked\n                return (PsiT[]) Array.newInstance(psiClass, count);\n            }\n        };\n    }","commit_id":"1d3a3aea0970a826fa9bdfa090e2c080ff57d2cf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public List<JetTypeParameter> getParameters() {\n        return Arrays.asList(getStubOrPsiChildren(JetStubElementTypes.TYPE_PARAMETER, JetTypeParameter.ARRAY_FACTORY));\n    }","id":85354,"modified_method":"@NotNull\n    public List<JetTypeParameter> getParameters() {\n        return getStubOrPsiChildrenAsList(JetStubElementTypes.TYPE_PARAMETER);\n    }","commit_id":"1d3a3aea0970a826fa9bdfa090e2c080ff57d2cf","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void writeLoopCounter(int slot, int count, Location location) {\n        if (slot > -1) {\n            writeDebugInfo(location);\n            final Label end = new Label();\n\n            iinc(slot, -count);\n            visitVarInsn(Opcodes.ILOAD, slot);\n            push(0);\n            ifICmp(GeneratorAdapter.GT, end);\n            throwException(PAINLESS_ERROR_TYPE, \"The maximum number of statements that can be executed in a loop has been reached.\");\n            mark(end);\n        }\n    }","id":85355,"modified_method":"public void writeLoopCounter(int slot, int count, Location location) {\n        assert slot != -1;\n        writeDebugInfo(location);\n        final Label end = new Label();\n\n        iinc(slot, -count);\n        visitVarInsn(Opcodes.ILOAD, slot);\n        push(0);\n        ifICmp(GeneratorAdapter.GT, end);\n        throwException(PAINLESS_ERROR_TYPE, \"The maximum number of statements that can be executed in a loop has been reached.\");\n        mark(end);\n    }","commit_id":"f8c55a5e7bc1e12f78a4a270f92a74ff60393885","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void write(MethodWriter writer, Globals globals) {\n        writer.writeStatementOffset(location);\n\n        Label start = new Label();\n        Label begin = new Label();\n        Label end = new Label();\n\n        writer.mark(start);\n\n        block.continu = begin;\n        block.brake = end;\n        block.write(writer, globals);\n\n        writer.mark(begin);\n\n        condition.fals = end;\n        condition.write(writer, globals);\n\n        writer.writeLoopCounter(loopCounter.getSlot(), Math.max(1, block.statementCount), location);\n\n        writer.goTo(start);\n        writer.mark(end);\n    }","id":85356,"modified_method":"@Override\n    void write(MethodWriter writer, Globals globals) {\n        writer.writeStatementOffset(location);\n\n        Label start = new Label();\n        Label begin = new Label();\n        Label end = new Label();\n\n        writer.mark(start);\n\n        block.continu = begin;\n        block.brake = end;\n        block.write(writer, globals);\n\n        writer.mark(begin);\n\n        condition.fals = end;\n        condition.write(writer, globals);\n\n        if (loopCounter != null) {\n            writer.writeLoopCounter(loopCounter.getSlot(), Math.max(1, block.statementCount), location);\n        }\n\n        writer.goTo(start);\n        writer.mark(end);\n    }","commit_id":"f8c55a5e7bc1e12f78a4a270f92a74ff60393885","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void write(MethodWriter writer, Globals globals) {\n        writer.writeStatementOffset(location);\n\n        Label start = new Label();\n        Label begin = afterthought == null ? start : new Label();\n        Label end = new Label();\n\n        if (initializer instanceof SDeclBlock) {\n            ((SDeclBlock)initializer).write(writer, globals);\n        } else if (initializer instanceof AExpression) {\n            AExpression initializer = (AExpression)this.initializer;\n\n            initializer.write(writer, globals);\n            writer.writePop(initializer.expected.sort.size);\n        }\n\n        writer.mark(start);\n\n        if (condition != null) {\n            condition.fals = end;\n            condition.write(writer, globals);\n        }\n\n        boolean allEscape = false;\n\n        if (block != null) {\n            allEscape = block.allEscape;\n\n            int statementCount = Math.max(1, block.statementCount);\n\n            if (afterthought != null) {\n                ++statementCount;\n            }\n\n            writer.writeLoopCounter(loopCounter.getSlot(), statementCount, location);\n            block.write(writer, globals);\n        } else {\n            writer.writeLoopCounter(loopCounter.getSlot(), 1, location);\n        }\n\n        if (afterthought != null) {\n            writer.mark(begin);\n            afterthought.write(writer, globals);\n        }\n\n        if (afterthought != null || !allEscape) {\n            writer.goTo(start);\n        }\n\n        writer.mark(end);\n    }","id":85357,"modified_method":"@Override\n    void write(MethodWriter writer, Globals globals) {\n        writer.writeStatementOffset(location);\n\n        Label start = new Label();\n        Label begin = afterthought == null ? start : new Label();\n        Label end = new Label();\n\n        if (initializer instanceof SDeclBlock) {\n            ((SDeclBlock)initializer).write(writer, globals);\n        } else if (initializer instanceof AExpression) {\n            AExpression initializer = (AExpression)this.initializer;\n\n            initializer.write(writer, globals);\n            writer.writePop(initializer.expected.sort.size);\n        }\n\n        writer.mark(start);\n\n        if (condition != null) {\n            condition.fals = end;\n            condition.write(writer, globals);\n        }\n\n        boolean allEscape = false;\n\n        if (block != null) {\n            allEscape = block.allEscape;\n\n            int statementCount = Math.max(1, block.statementCount);\n\n            if (afterthought != null) {\n                ++statementCount;\n            }\n\n            if (loopCounter != null) {\n                writer.writeLoopCounter(loopCounter.getSlot(), statementCount, location);\n            }\n            block.write(writer, globals);\n        } else {\n            if (loopCounter != null) {\n                writer.writeLoopCounter(loopCounter.getSlot(), 1, location);\n            }\n        }\n\n        if (afterthought != null) {\n            writer.mark(begin);\n            afterthought.write(writer, globals);\n        }\n\n        if (afterthought != null || !allEscape) {\n            writer.goTo(start);\n        }\n\n        writer.mark(end);\n    }","commit_id":"f8c55a5e7bc1e12f78a4a270f92a74ff60393885","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    void write(MethodWriter writer, Globals globals) {\n        writer.writeStatementOffset(location);\n\n        Label begin = new Label();\n        Label end = new Label();\n\n        writer.mark(begin);\n\n        condition.fals = end;\n        condition.write(writer, globals);\n\n        if (block != null) {\n            writer.writeLoopCounter(loopCounter.getSlot(), Math.max(1, block.statementCount), location);\n\n            block.continu = begin;\n            block.brake = end;\n            block.write(writer, globals);\n        } else {\n            writer.writeLoopCounter(loopCounter.getSlot(), 1, location);\n        }\n\n        if (block == null || !block.allEscape) {\n            writer.goTo(begin);\n        }\n\n        writer.mark(end);\n    }","id":85358,"modified_method":"@Override\n    void write(MethodWriter writer, Globals globals) {\n        writer.writeStatementOffset(location);\n\n        Label begin = new Label();\n        Label end = new Label();\n\n        writer.mark(begin);\n\n        condition.fals = end;\n        condition.write(writer, globals);\n\n        if (block != null) {\n            if (loopCounter != null) {\n                writer.writeLoopCounter(loopCounter.getSlot(), Math.max(1, block.statementCount), location);\n            }\n\n            block.continu = begin;\n            block.brake = end;\n            block.write(writer, globals);\n        } else {\n            if (loopCounter != null) {\n                writer.writeLoopCounter(loopCounter.getSlot(), 1, location);\n            }\n        }\n\n        if (block == null || !block.allEscape) {\n            writer.goTo(begin);\n        }\n\n        writer.mark(end);\n    }","commit_id":"f8c55a5e7bc1e12f78a4a270f92a74ff60393885","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void applyDayNightMode() {\n\t\tif (nightMode) {\n\t\t\tlistBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_dark));\n\t\t\tDrawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_light));\n\t\t\tlistView.setDivider(d);\n\t\t\tlistView.setDividerHeight(dpToPx(1f));\n\t\t} else {\n\t\t\tlistBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_light));\n\t\t\tDrawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_dark));\n\t\t\tlistView.setDivider(d);\n\t\t\tlistView.setDividerHeight(dpToPx(1f));\n\t\t}\n\t}","id":85359,"modified_method":"private void applyDayNightMode() {\n\t\tif (nightMode) {\n\t\t\tif (listBackgroundView != null) {\n\t\t\t\tlistBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_dark));\n\t\t\t} else {\n\t\t\t\tlistView.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_dark));\n\t\t\t}\n\t\t\tDrawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_dark));\n\t\t\tlistView.setDivider(d);\n\t\t\tlistView.setDividerHeight(dpToPx(1f));\n\t\t} else {\n\t\t\tif (listBackgroundView != null) {\n\t\t\t\tlistBackgroundView.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_light));\n\t\t\t} else {\n\t\t\t\tlistView.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_light));\n\t\t\t}\n\t\t\tDrawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_light));\n\t\t\tlistView.setDivider(d);\n\t\t\tlistView.setDividerHeight(dpToPx(1f));\n\t\t}\n\t}","commit_id":"942cdd8bc46a6186a53077de4d173a00968dca3d","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void paint(Graphics2D g, int width) {\n    g.setColor(myColor);\n    g.fill(new Polygon(new int[]{0, 0, width, width}, new int[]{myStart1, myEnd1, myEnd2, myStart2}, 4));\n    g.setColor(Color.GRAY);\n    UIUtil.drawLine(g, 0, myStart1, width, myStart2);\n    UIUtil.drawLine(g, 0, myEnd1, width, myEnd2);\n  }","id":85360,"modified_method":"private void paint(Graphics2D g, int width) {\n    g.setColor(myColor);\n    g.fill(new Polygon(new int[]{0, 0, width, width}, new int[]{myStart1, myEnd1, myEnd2, myStart2}, 4));\n    g.setColor(FRAMING_LINE_COLOR);\n    UIUtil.drawLine(g, 0, myStart1, width, myStart2);\n    UIUtil.drawLine(g, 0, myEnd1, width, myEnd2);\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Color getColor() {\n    return myColor;\n  }","id":85361,"modified_method":"public Color getColor() {\n    return myColor;\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeEditor() {\n    if (myEditor != null) {\n      Editor releasedEditor = myEditor;\n      remove(myEditor.getComponent());\n      getEditorFactory().releaseEditor(myEditor);\n      myEditor = null;\n      fireEditorReleased(releasedEditor);\n    }\n  }","id":85362,"modified_method":"private void removeEditor() {\n    if (myEditor != null) {\n      myEditor.getScrollingModel().removeVisibleAreaListener(myVisibleAreaListener);\n      Editor releasedEditor = myEditor;\n      remove(myEditor.getComponent());\n      getEditorFactory().releaseEditor(myEditor);\n      myEditor = null;\n      fireEditorReleased(releasedEditor);\n    }\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createEditor() {\n    LOG.assertTrue(myEditor == null);\n    myEditor = myState.createEditor();\n    if (myEditor == null) return;\n    add(myEditor.getComponent(), BorderLayout.CENTER);\n    fireEditorCreated();\n  }","id":85363,"modified_method":"private void createEditor() {\n    LOG.assertTrue(myEditor == null);\n    myEditor = myState.createEditor();\n    if (myEditor == null) return;\n    add(myEditor.getComponent(), BorderLayout.CENTER);\n    myEditor.getScrollingModel().addVisibleAreaListener(myVisibleAreaListener);\n    myEditor.getCaretModel().addCaretListener(new CaretListener() {\n      @Override\n      public void caretPositionChanged(CaretEvent e) {\n        repaint();\n      }\n    });\n    repaint();\n    fireEditorCreated();\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EditorListener[] getListeners() {\n    EditorListener[] listeners = new EditorListener[myListeners.size()];\n    myListeners.toArray(listeners);\n    return listeners;\n  }","id":85364,"modified_method":"public EditorPlace(@NotNull MergePanel2.DiffEditorState state, @NotNull MergePanelColumn column, @NotNull MergePanel2 mergePanel) {\n    myState = state;\n    myColumn = column;\n    mySideInfo = SideInfo.convertFromColumn(mergePanel, myColumn);\n\n    setLayout(new BorderLayout());\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Editor getEditor(int index) {\n    return getEditorPlace(index).getEditor();\n  }","id":85365,"modified_method":"/**\n   * @deprecated Because it references by index.\n   */\n  @Deprecated\n  public Editor getEditor(int index) {\n    return getEditorPlace(index).getEditor();\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MergePanel2(DialogBuilder builder, Disposable parent) {\n    ArrayList<EditorPlace> editorPlaces = new ArrayList<EditorPlace>();\n    EditorPlace.EditorListener placeListener = new EditorPlace.EditorListener() {\n      public void onEditorCreated(EditorPlace place) {\n        if (myDuringCreation) return;\n        disposeMergeList();\n        myDuringCreation = true;\n        try {\n          tryInitView();\n        }\n        finally {\n          myDuringCreation = false;\n        }\n      }\n\n      public void onEditorReleased(Editor releasedEditor) {\n        LOG.assertTrue(!myDuringCreation);\n        disposeMergeList();\n      }\n    };\n    for (int i = 0; i < EDITORS_COUNT; i++) {\n      EditorPlace editorPlace = new EditorPlace(new DiffEditorState(i));\n      Disposer.register(parent, editorPlace);\n      editorPlaces.add(editorPlace);\n      editorPlace.addListener(placeListener);\n      myEditorsPanels[i] = new LabeledComponent();\n      myEditorsPanels[i].setLabelLocation(BorderLayout.NORTH);\n      myEditorsPanels[i].setComponent(editorPlace);\n    }\n    FontSizeSynchronizer.attachTo(editorPlaces);\n    myPanel = new DiffPanelOuterComponent(TextDiffType.MERGE_TYPES, createToolbar());\n    myPanel.insertDiffComponent(new ThreePanels(myEditorsPanels, myDividers), new MyScrollingPanel());\n    myProvider = new MyDataProvider();\n    myPanel.setDataProvider(myProvider);\n    myBuilder = builder;\n  }","id":85366,"modified_method":"public MergePanel2(DialogBuilder builder, Disposable parent) {\n    ArrayList<EditorPlace> editorPlaces = new ArrayList<EditorPlace>();\n    EditorPlace.EditorListener placeListener = new EditorPlace.EditorListener() {\n      public void onEditorCreated(EditorPlace place) {\n        if (myDuringCreation) return;\n        disposeMergeList();\n        myDuringCreation = true;\n        try {\n          tryInitView();\n        }\n        finally {\n          myDuringCreation = false;\n        }\n      }\n\n      public void onEditorReleased(Editor releasedEditor) {\n        LOG.assertTrue(!myDuringCreation);\n        disposeMergeList();\n      }\n    };\n    for (int i = 0; i < EDITORS_COUNT; i++) {\n      EditorPlace editorPlace = new EditorPlace(new DiffEditorState(i), indexToColumn(i), this);\n      Disposer.register(parent, editorPlace);\n      editorPlaces.add(editorPlace);\n      editorPlace.addListener(placeListener);\n      myEditorsPanels[i] = new LabeledComponent();\n      myEditorsPanels[i].setLabelLocation(BorderLayout.NORTH);\n      myEditorsPanels[i].setComponent(editorPlace);\n    }\n    FontSizeSynchronizer.attachTo(editorPlaces);\n    myPanel = new DiffPanelOuterComponent(TextDiffType.MERGE_TYPES, createToolbar());\n    myPanel.insertDiffComponent(new ThreePanels(myEditorsPanels, myDividers), new MyScrollingPanel());\n    myProvider = new MyDataProvider();\n    myPanel.setDataProvider(myProvider);\n    myBuilder = builder;\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getVersionTitle(int index) {\n    return myEditorsPanels[index].getRawText();\n  }","id":85367,"modified_method":"/**\n   * @deprecated Because it references by index.\n   */\n  @Deprecated\n  public String getVersionTitle(int index) {\n    return myEditorsPanels[index].getRawText();\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EditorPlace getEditorPlace(int index) {\n    return (EditorPlace)myEditorsPanels[index].getComponent();\n  }","id":85368,"modified_method":"/**\n   * @deprecated Because it references by index.\n   */\n  @Deprecated\n  public EditorPlace getEditorPlace(int index) {\n    return (EditorPlace)myEditorsPanels[index].getComponent();\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void tryInitView() {\n    if (!hasAllEditors()) return;\n    if (myMergeList != null) return;\n    try {\n      myMergeList = MergeList.create(myData);\n      myMergeList.addListener(myDividersRepainter);\n      myStatusUpdater = StatusUpdater.install(myMergeList, myPanel);\n      Editor left = getEditor(0);\n      Editor base = getEditor(1);\n      Editor right = getEditor(2);\n\n      myMergeList.setMarkups(left, base, right);\n      EditingSides[] sides = {new MyEditingSides(FragmentSide.SIDE1), new MyEditingSides(FragmentSide.SIDE2)};\n      myScrollSupport.install(sides);\n      for (int i = 0; i < myDividers.length; i++) {\n        myDividers[i].listenEditors(sides[i]);\n      }\n      if (myScrollToFirstDiff) {\n        myPanel.requestScrollEditors();\n      }\n    }\n    catch (final FilesTooBigForDiffException e) {\n      myPanel.insertTopComponent(new EditorNotificationPanel() {\n        {\n          myLabel.setText(e.getMessage());\n        }\n      });\n    }\n  }","id":85369,"modified_method":"private void tryInitView() {\n    if (!hasAllEditors()) return;\n    if (myMergeList != null) return;\n    try {\n      myMergeList = MergeList.create(myData);\n      myMergeList.addListener(myDividersRepainter);\n      myStatusUpdater = StatusUpdater.install(myMergeList, myPanel);\n      Editor left = getEditor(0);\n      Editor base = getEditor(1);\n      Editor right = getEditor(2);\n\n      myMergeList.setMarkups(left, base, right);\n      EditingSides[] sides = {getFirstEditingSide(), getSecondEditingSide()};\n      myScrollSupport.install(sides);\n      for (int i = 0; i < myDividers.length; i++) {\n        myDividers[i].listenEditors(sides[i]);\n      }\n      if (myScrollToFirstDiff) {\n        myPanel.requestScrollEditors();\n      }\n    }\n    catch (final FilesTooBigForDiffException e) {\n      myPanel.insertTopComponent(new EditorNotificationPanel() {\n        {\n          myLabel.setText(e.getMessage());\n        }\n      });\n    }\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public Editor createEditor() {\n      Document document = getDocument();\n      if (document == null) return null;\n      Project project = myData.getProject();\n      EditorEx editor = DiffUtil.createEditor(document, project, myIndex != 1);\n\n      if (editor == null) return editor;\n      //FileType type = getFileType();\n      //editor.setHighlighter(HighlighterFactory.createHighlighter(project, type));\n      if (myIndex == 0) editor.setVerticalScrollbarOrientation(EditorEx.VERTICAL_SCROLLBAR_LEFT);\n      if (myIndex != 1) ((EditorMarkupModel)editor.getMarkupModel()).setErrorStripeVisible(true);\n      editor.getSettings().setFoldingOutlineShown(false);\n      editor.getFoldingModel().setFoldingEnabled(false);\n      editor.getSettings().setLineMarkerAreaShown(false);\n      editor.getGutterComponentEx().setShowDefaultGutterPopup(false);\n      initEditorSettings(editor);\n\n      return editor;\n    }","id":85370,"modified_method":"@Nullable\n    public Editor createEditor() {\n      Document document = getDocument();\n      if (document == null) return null;\n      Project project = myData.getProject();\n      EditorEx editor = DiffUtil.createEditor(document, project, myIndex != 1);\n\n      if (editor == null) return editor;\n      //FileType type = getFileType();\n      //editor.setHighlighter(HighlighterFactory.createHighlighter(project, type));\n      if (myIndex == 0) editor.setVerticalScrollbarOrientation(EditorEx.VERTICAL_SCROLLBAR_LEFT);\n      if (myIndex != 1) ((EditorMarkupModel)editor.getMarkupModel()).setErrorStripeVisible(true);\n      editor.getSettings().setFoldingOutlineShown(false);\n      editor.getFoldingModel().setFoldingEnabled(false);\n      editor.getSettings().setLineMarkerAreaShown(false);\n      editor.getSettings().setFoldingOutlineShown(false);\n      editor.getGutterComponentEx().setShowDefaultGutterPopup(false);\n      initEditorSettings(editor);\n\n      return editor;\n    }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TextAttributes getTextAttributes(EditorColorsScheme scheme) {\n    TextAttributes originalAttrs = scheme.getAttributes(myAttributesKey);\n    if (!myApplied) {\n      return originalAttrs;\n    }\n    else {\n      TextAttributes overridingAttributes = new TextAttributes();\n      overridingAttributes.setBackgroundColor(scheme.getDefaultBackground());\n      return TextAttributes.merge(originalAttrs, overridingAttributes);\n    }\n  }","id":85371,"modified_method":"@Nullable\n  public TextAttributes getTextAttributes(EditorColorsScheme scheme) {\n    TextAttributes originalAttrs = scheme.getAttributes(myAttributesKey);\n    if (originalAttrs == null) {\n      return null;\n    }\n    TextAttributes overridingAttributes = new TextAttributes();\n    if (!myApplied) {\n        overridingAttributes.setBackgroundColor(getMiddle(originalAttrs.getBackgroundColor(), scheme.getDefaultBackground()));\n    }\n    else {\n      overridingAttributes.setBackgroundColor(scheme.getDefaultBackground());\n    }\n    return TextAttributes.merge(originalAttrs, overridingAttributes);\n  }","commit_id":"5614eacb5fee68803e82c8fffc058110ff875789","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        if (baseRequest.isHandled())\n            return;\n\n        boolean skipContentBody = false;\n\n        if(!HttpMethod.GET.is(request.getMethod()))\n        {\n            if(!HttpMethod.HEAD.is(request.getMethod()))\n            {\n                //try another handler\n                super.handle(target, baseRequest, request, response);\n                return;\n            }\n            skipContentBody = true;\n        }\n\n        Resource resource = getResource(request);\n        \n        if (LOG.isDebugEnabled())\n        { \n            if (resource==null)\n                LOG.debug(\"resource=null\");\n            else\n                LOG.debug(\"resource={} alias={} exists={}\",resource,resource.getAlias(),resource.exists());\n        }\n        \n        \n        // If resource is not found\n        if (resource==null || !resource.exists())\n        {\n            // inject the jetty-dir.css file if it matches\n            if (target.endsWith(\"/jetty-dir.css\"))\n            {\n                resource = getStylesheet();\n                if (resource==null)\n                    return;\n                response.setContentType(\"text/css\");\n            }\n            else\n            {\n                //no resource - try other handlers\n                super.handle(target, baseRequest, request, response);\n                return;\n            }\n        }\n\n        // We are going to serve something\n        baseRequest.setHandled(true);\n\n        // handle directories\n        if (resource.isDirectory())\n        {\n            if (!request.getPathInfo().endsWith(URIUtil.SLASH))\n            {\n                response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH)));\n                return;\n            }\n\n            Resource welcome=getWelcome(resource);\n            if (welcome!=null && welcome.exists())\n                resource=welcome;\n            else\n            {\n                doDirectory(request,response,resource);\n                baseRequest.setHandled(true);\n                return;\n            }\n        }\n\n        // Handle ETAGS\n        long last_modified=resource.lastModified();\n        String etag=null;\n        if (_etags)\n        {\n            // simple handling of only a single etag\n            String ifnm = request.getHeader(HttpHeader.IF_NONE_MATCH.asString());\n            etag=resource.getWeakETag();\n            if (ifnm!=null && resource!=null && ifnm.equals(etag))\n            {\n                response.setStatus(HttpStatus.NOT_MODIFIED_304);\n                baseRequest.getResponse().getHttpFields().put(HttpHeader.ETAG,etag);\n                return;\n            }\n        }\n        \n        // Handle if modified since \n        if (last_modified>0)\n        {\n            long if_modified=request.getDateHeader(HttpHeader.IF_MODIFIED_SINCE.asString());\n            if (if_modified>0 && last_modified/1000<=if_modified/1000)\n            {\n                response.setStatus(HttpStatus.NOT_MODIFIED_304);\n                return;\n            }\n        }\n\n        // set the headers\n        String mime=_mimeTypes.getMimeByExtension(resource.toString());\n        if (mime==null)\n            mime=_mimeTypes.getMimeByExtension(request.getPathInfo());\n        doResponseHeaders(response,resource,mime);\n        if (_etags)\n            baseRequest.getResponse().getHttpFields().put(HttpHeader.ETAG,etag);\n        \n        if(skipContentBody)\n            return;\n        \n        \n        // Send the content\n        OutputStream out =null;\n        try {out = response.getOutputStream();}\n        catch(IllegalStateException e) {out = new WriterOutputStream(response.getWriter());}\n\n        // Has the output been wrapped\n        if (!(out instanceof HttpOutput))\n            // Write content via wrapped output\n            resource.writeTo(out,0,resource.length());\n        else\n        {\n            // select async by size\n            int min_async_size=_minAsyncContentLength==0?response.getBufferSize():_minAsyncContentLength;\n            \n            if (request.isAsyncSupported() && \n                min_async_size>0 &&\n                resource.length()>=min_async_size)\n            {\n                final AsyncContext async = request.startAsync();\n                async.setTimeout(0);\n                Callback callback = new Callback()\n                {\n                    @Override\n                    public void succeeded()\n                    {\n                        async.complete();\n                    }\n\n                    @Override\n                    public void failed(Throwable x)\n                    {\n                        LOG.warn(x.toString());\n                        LOG.debug(x);\n                        async.complete();\n                    }   \n                };\n\n                // Can we use a memory mapped file?\n                if (_minMemoryMappedContentLength>0 && \n                    resource.length()>_minMemoryMappedContentLength &&\n                    resource.length()<Integer.MAX_VALUE &&\n                    resource instanceof FileResource)\n                {\n                    ByteBuffer buffer = BufferUtil.toMappedBuffer(resource.getFile());\n                    ((HttpOutput)out).sendContent(buffer,callback);\n                }\n                else  // Do a blocking write of a channel (if available) or input stream\n                {\n                    // Close of the channel/inputstream is done by the async sendContent\n                    ReadableByteChannel channel= resource.getReadableByteChannel();\n                    if (channel!=null)\n                        ((HttpOutput)out).sendContent(channel,callback);\n                    else\n                        ((HttpOutput)out).sendContent(resource.getInputStream(),callback);\n                }\n            }\n            else\n            {\n                // Can we use a memory mapped file?\n                if (_minMemoryMappedContentLength>0 && \n                    resource.length()>_minMemoryMappedContentLength &&\n                    resource instanceof FileResource)\n                {\n                    ByteBuffer buffer = BufferUtil.toMappedBuffer(resource.getFile());\n                    ((HttpOutput)out).sendContent(buffer);\n                }\n                else  // Do a blocking write of a channel (if available) or input stream\n                {\n                    ReadableByteChannel channel= resource.getReadableByteChannel();\n                    if (channel!=null)\n                        ((HttpOutput)out).sendContent(channel);\n                    else\n                        ((HttpOutput)out).sendContent(resource.getInputStream());\n                }\n            }\n        }\n    }","id":85372,"modified_method":"@Override\n    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException\n    {\n        if (baseRequest.isHandled())\n            return;\n\n        boolean skipContentBody = false;\n\n        if(!HttpMethod.GET.is(request.getMethod()))\n        {\n            if(!HttpMethod.HEAD.is(request.getMethod()))\n            {\n                //try another handler\n                super.handle(target, baseRequest, request, response);\n                return;\n            }\n            skipContentBody = true;\n        }\n\n        Resource resource = getResource(request);\n        \n        if (LOG.isDebugEnabled())\n        { \n            if (resource==null)\n                LOG.debug(\"resource=null\");\n            else\n                LOG.debug(\"resource={} alias={} exists={}\",resource,resource.getAlias(),resource.exists());\n        }\n        \n        \n        // If resource is not found\n        if (resource==null || !resource.exists())\n        {\n            // inject the jetty-dir.css file if it matches\n            if (target.endsWith(\"/jetty-dir.css\"))\n            {\n                resource = getStylesheet();\n                if (resource==null)\n                    return;\n                response.setContentType(\"text/css\");\n            }\n            else\n            {\n                //no resource - try other handlers\n                super.handle(target, baseRequest, request, response);\n                return;\n            }\n        }\n\n        // We are going to serve something\n        baseRequest.setHandled(true);\n\n        // handle directories\n        if (resource.isDirectory())\n        {\n            String pathInfo = request.getPathInfo();\n            boolean endsWithSlash=(pathInfo==null?request.getServletPath():pathInfo).endsWith(URIUtil.SLASH);\n            if (!endsWithSlash)\n            {\n                response.sendRedirect(response.encodeRedirectURL(URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH)));\n                return;\n            }\n\n            Resource welcome=getWelcome(resource);\n            if (welcome!=null && welcome.exists())\n                resource=welcome;\n            else\n            {\n                doDirectory(request,response,resource);\n                baseRequest.setHandled(true);\n                return;\n            }\n        }\n\n        // Handle ETAGS\n        long last_modified=resource.lastModified();\n        String etag=null;\n        if (_etags)\n        {\n            // simple handling of only a single etag\n            String ifnm = request.getHeader(HttpHeader.IF_NONE_MATCH.asString());\n            etag=resource.getWeakETag();\n            if (ifnm!=null && resource!=null && ifnm.equals(etag))\n            {\n                response.setStatus(HttpStatus.NOT_MODIFIED_304);\n                baseRequest.getResponse().getHttpFields().put(HttpHeader.ETAG,etag);\n                return;\n            }\n        }\n        \n        // Handle if modified since \n        if (last_modified>0)\n        {\n            long if_modified=request.getDateHeader(HttpHeader.IF_MODIFIED_SINCE.asString());\n            if (if_modified>0 && last_modified/1000<=if_modified/1000)\n            {\n                response.setStatus(HttpStatus.NOT_MODIFIED_304);\n                return;\n            }\n        }\n\n        // set the headers\n        String mime=_mimeTypes.getMimeByExtension(resource.toString());\n        if (mime==null)\n            mime=_mimeTypes.getMimeByExtension(request.getPathInfo());\n        doResponseHeaders(response,resource,mime);\n        if (_etags)\n            baseRequest.getResponse().getHttpFields().put(HttpHeader.ETAG,etag);\n        \n        if(skipContentBody)\n            return;\n        \n        \n        // Send the content\n        OutputStream out =null;\n        try {out = response.getOutputStream();}\n        catch(IllegalStateException e) {out = new WriterOutputStream(response.getWriter());}\n\n        // Has the output been wrapped\n        if (!(out instanceof HttpOutput))\n            // Write content via wrapped output\n            resource.writeTo(out,0,resource.length());\n        else\n        {\n            // select async by size\n            int min_async_size=_minAsyncContentLength==0?response.getBufferSize():_minAsyncContentLength;\n            \n            if (request.isAsyncSupported() && \n                min_async_size>0 &&\n                resource.length()>=min_async_size)\n            {\n                final AsyncContext async = request.startAsync();\n                async.setTimeout(0);\n                Callback callback = new Callback()\n                {\n                    @Override\n                    public void succeeded()\n                    {\n                        async.complete();\n                    }\n\n                    @Override\n                    public void failed(Throwable x)\n                    {\n                        LOG.warn(x.toString());\n                        LOG.debug(x);\n                        async.complete();\n                    }   \n                };\n\n                // Can we use a memory mapped file?\n                if (_minMemoryMappedContentLength>0 && \n                    resource.length()>_minMemoryMappedContentLength &&\n                    resource.length()<Integer.MAX_VALUE &&\n                    resource instanceof FileResource)\n                {\n                    ByteBuffer buffer = BufferUtil.toMappedBuffer(resource.getFile());\n                    ((HttpOutput)out).sendContent(buffer,callback);\n                }\n                else  // Do a blocking write of a channel (if available) or input stream\n                {\n                    // Close of the channel/inputstream is done by the async sendContent\n                    ReadableByteChannel channel= resource.getReadableByteChannel();\n                    if (channel!=null)\n                        ((HttpOutput)out).sendContent(channel,callback);\n                    else\n                        ((HttpOutput)out).sendContent(resource.getInputStream(),callback);\n                }\n            }\n            else\n            {\n                // Can we use a memory mapped file?\n                if (_minMemoryMappedContentLength>0 && \n                    resource.length()>_minMemoryMappedContentLength &&\n                    resource instanceof FileResource)\n                {\n                    ByteBuffer buffer = BufferUtil.toMappedBuffer(resource.getFile());\n                    ((HttpOutput)out).sendContent(buffer);\n                }\n                else  // Do a blocking write of a channel (if available) or input stream\n                {\n                    ReadableByteChannel channel= resource.getReadableByteChannel();\n                    if (channel!=null)\n                        ((HttpOutput)out).sendContent(channel);\n                    else\n                        ((HttpOutput)out).sendContent(resource.getInputStream());\n                }\n            }\n        }\n    }","commit_id":"25474ff7ab41a93d3c89de7ddc3f04b384c51762","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void doInit(CometSession cometSession) throws Exception {\n\t\tCometRequest cometRequest = cometSession.getCometRequest();\n\n\t\tString pollerRequestString = cometRequest.getParameter(\"pollerRequest\");\n\n\t\tPollerResponseWriter pollerResponseWriter =\n\t\t\tnew CometPollerResponseWriter(cometSession);\n\n\t\tList<PollerRequestHandlerListener> pollerRequestHandlerListeners =\n\t\t\tnew ArrayList<PollerRequestHandlerListener>(1);\n\n\t\tpollerRequestHandlerListeners.add(\n\t\t\tnew CometPollerRequestHandlerListener(cometSession));\n\n\t\t_pollerRequestHandler = new PollerRequestHandler(\n\t\t\tcometRequest.getPathInfo(), pollerRequestString,\n\t\t\tpollerResponseWriter, pollerRequestHandlerListeners);\n\n\t\t_pollerRequestHandler.processRequest();\n\t}","id":85373,"modified_method":"protected void doInit(CometSession cometSession) throws Exception {\n\t\tCometRequest cometRequest = cometSession.getCometRequest();\n\n\t\tString pollerRequestString = cometRequest.getParameter(\"pollerRequest\");\n\n\t\t_companyId = cometRequest.getCompanyId();\n\n\t\t_userId = cometRequest.getUserId();\n\n\t\tJSONObject pollerResponseHeader =\n\t\t\tPollerRequestHandlerUtil.processRequest(\n\t\t\t\tcometRequest.getPathInfo(), pollerRequestString);\n\n\t\t//for \"send\" requests will have null pollerResponseHeaders from which\n\t\t//we can immediately return.  \"send\" requests do not need comet.\n\t\tif (pollerResponseHeader != null) {\n\t\t\t _cometPollerChannelListener = new PollerCometChannelListener(\n\t\t\t\t\tgetCometSession(), pollerResponseHeader);\n\n\t\t\tChannelHubManagerUtil.registerChannelListener(\n\t\t\t\t_companyId, _userId, _cometPollerChannelListener);\n\t\t}\n\t\telse {\n\t\t\tgetCometSession().close();\n\t\t}\n\t}","commit_id":"863ed8930f8ae25a50fe681c4f406883f95de873","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doDestroy() throws Exception {\n\t\t_pollerRequestHandler.shutdown();\n\t}","id":85374,"modified_method":"protected void doDestroy() throws Exception {\n\t\tif (_cometPollerChannelListener != null) {\n\t\t\tChannelHubManagerUtil.unregisterChannelListener(\n\t\t\t\t_companyId, _userId, _cometPollerChannelListener);\n\t\t}\n\t}","commit_id":"863ed8930f8ae25a50fe681c4f406883f95de873","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    protected void doGet(\n            HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        AcceptHeader accept = new AcceptHeader(request.getHeader(\"Accept\"));\n        Representation representation = accept.resolve(REPRESENTATIONS);\n\n        Tree tree = (Tree) request.getAttribute(\"tree\");\n        representation.render(tree, response);\n    }","id":85375,"modified_method":"@Override\n    protected void doGet(\n            HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        AcceptHeader accept = new AcceptHeader(request.getHeader(\"Accept\"));\n        Representation representation = accept.resolve(REPRESENTATIONS);\n\n        String path = (String) request.getAttribute(\"path\");\n        if (path.isEmpty()) {\n            Tree tree = (Tree) request.getAttribute(\"tree\");\n            representation.render(tree, response);\n        } else {\n            // There was an extra path component that didn't match\n            // any existing nodes, so for now we just send a 404 response.\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }","commit_id":"fa55c5c0e4e250ac95afa8821dbf3664d950ab7e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected void service(\n            HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        try {\n            ContentSession session = repository.login(new GuestCredentials(), null);\n            try {\n                Root root = session.getLatestRoot();\n                Tree tree = root.getTree(request.getPathInfo());\n                request.setAttribute(\"root\", root);\n                request.setAttribute(\"tree\", tree);\n                super.service(request, response);\n            } finally {\n                session.close();\n            }\n        } catch (NoSuchWorkspaceException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        } catch (LoginException e) {\n            throw new ServletException(e);\n        }\n    }","id":85376,"modified_method":"@Override\n    protected void service(\n            HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        try {\n            ContentSession session = repository.login(null, null);\n            try {\n                Root root = session.getLatestRoot();\n                request.setAttribute(\"root\", root);\n\n                // Find the longest part of the given path that matches\n                // an existing node. The tail part might be used when\n                // creating new nodes or when exposing virtual resources.\n                // Note that we need to traverse the path in reverse\n                // direction as some parent nodes may be read-protected.\n                String head = request.getPathInfo();\n                String tail = \"\";\n                Tree tree = root.getTree(head);\n                while (tree == null) {\n                    int slash = head.lastIndexOf('/');\n                    tail = head.substring(slash) + tail;\n                    head = head.substring(0, slash - 1);\n                    tree = root.getTree(tail);\n                }\n                request.setAttribute(\"tree\", tree);\n                request.setAttribute(\"path\", tail);\n\n                super.service(request, response);\n            } finally {\n                session.close();\n            }\n        } catch (NoSuchWorkspaceException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n        } catch (LoginException e) {\n            throw new ServletException(e);\n        }\n    }","commit_id":"fa55c5c0e4e250ac95afa8821dbf3664d950ab7e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected void doPost(\n            HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        try {\n            Root root = (Root) request.getAttribute(\"root\");\n            Tree tree = (Tree) request.getAttribute(\"tree\");\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode node = mapper.readTree(request.getInputStream());\n            if (node.isObject()) {\n                post(node, tree);\n                root.commit();\n                doGet(request, response);\n            } else {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            }\n        } catch (CommitFailedException e) {\n            throw new ServletException(e);\n        }\n    }","id":85377,"modified_method":"@Override\n    protected void doPost(\n            HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        try {\n            Root root = (Root) request.getAttribute(\"root\");\n            Tree tree = (Tree) request.getAttribute(\"tree\");\n            String path = (String) request.getAttribute(\"path\");\n\n            for (String name : PathUtils.elements(path)) {\n                tree = tree.addChild(name);\n            }\n\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode node = mapper.readTree(request.getInputStream());\n            if (node.isObject()) {\n                post(node, tree);\n                root.commit();\n                doGet(request, response);\n            } else {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            }\n        } catch (CommitFailedException e) {\n            throw new ServletException(e);\n        }\n    }","commit_id":"fa55c5c0e4e250ac95afa8821dbf3664d950ab7e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void listConfigurations( PrintWriter pw, ConfigurationAdmin ca, boolean optionalMetaType, String locale )\n    {\n        try\n        {\n            // start with ManagedService instances\n            SortedMap optionsPlain = getServices( ManagedService.class.getName(), optionalMetaType, locale );\n\n            // add in existing configuration (not duplicating ManagedServices)\n            Configuration[] cfgs = ca.listConfigurations( null );\n            for ( int i = 0; cfgs != null && i < cfgs.length; i++ )\n            {\n\n                // ignore configuration object if an entry already exists in the\n                // map\n                String pid = cfgs[i].getPid();\n                if ( optionsPlain.containsKey( pid ) )\n                {\n                    continue;\n                }\n\n                // insert and entry for the pid\n                ObjectClassDefinition ocd = this.getObjectClassDefinition( cfgs[i], locale );\n                String name;\n                if ( ocd != null )\n                {\n                    name = ocd.getName() + \" (\";\n                    name += pid + \")\";\n                }\n                else\n                {\n                    name = pid;\n                }\n\n                if ( ocd != null || optionalMetaType )\n                {\n                    optionsPlain.put( pid, name );\n                }\n            }\n\n            printOptionsForm( pw, optionsPlain, \"configSelection_pid\", \"configure\", \"Configure\" );\n        }\n        catch ( Exception e )\n        {\n            // write a message or ignore\n        }\n    }","id":85378,"modified_method":"private void listConfigurations( PrintWriter pw, ConfigurationAdmin ca, String pidFilter, boolean optionalMetaType, String locale )\n    {\n        try\n        {\n            // start with ManagedService instances\n            SortedMap optionsPlain = getServices( ManagedService.class.getName(), pidFilter, optionalMetaType, locale );\n\n            // add in existing configuration (not duplicating ManagedServices)\n            Configuration[] cfgs = ca.listConfigurations( pidFilter );\n            for ( int i = 0; cfgs != null && i < cfgs.length; i++ )\n            {\n\n                // ignore configuration object if an entry already exists in the\n                // map\n                String pid = cfgs[i].getPid();\n                if ( optionsPlain.containsKey( pid ) )\n                {\n                    continue;\n                }\n\n                // insert and entry for the pid\n                ObjectClassDefinition ocd = this.getObjectClassDefinition( cfgs[i], locale );\n                String name;\n                if ( ocd != null )\n                {\n                    name = ocd.getName() + \" (\";\n                    name += pid + \")\";\n                }\n                else\n                {\n                    name = pid;\n                }\n\n                if ( ocd != null || optionalMetaType )\n                {\n                    optionsPlain.put( pid, name );\n                }\n            }\n\n            printOptionsForm( pw, optionsPlain, \"configSelection_pid\", \"configure\", \"Configure\" );\n        }\n        catch ( Exception e )\n        {\n            // write a message or ignore\n        }\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"public void renderContent( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n\n        // true if MetaType service information is not required\n        boolean optionalMetaType = false;\n\n        Locale loc = getLocale( request );\n        String locale = ( loc != null ) ? loc.toString() : null;\n\n        PrintWriter pw = response.getWriter();\n\n        String appRoot = (String) request.getAttribute( OsgiManager.ATTR_APP_ROOT );\n        pw.println( \"<script src='\" + appRoot + \"/res/ui/configmanager.js' language='JavaScript'><\/script>\" );\n\n        pw.println( \"<table class='content' cellpadding='0' cellspacing='0' width='100%'>\" );\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            pw.println( \"<tr class='content' id='configField'>\" );\n            pw.println( \"<td class='content'>&nbsp;<\/th>\" );\n            pw.println( \"<td class='content'>\" );\n            pw.print( \"Configuration Admin Service not available\" );\n            pw.println( \"<\/td>\" );\n            pw.println( \"<\/tr>\" );\n        }\n        else\n        {\n            pw.println( \"<tr class='content' id='configField'>\" );\n            pw.println( \"<td class='content'>Configurations<\/th>\" );\n            pw.println( \"<td class='content'>\" );\n            this.listConfigurations( pw, ca, optionalMetaType, locale );\n            pw.println( \"<\/td>\" );\n            pw.println( \"<\/tr>\" );\n\n            pw.println( \"<tr class='content' id='factoryField'>\" );\n            pw.println( \"<td class='content'>Factory Configurations<\/th>\" );\n            pw.println( \"<td class='content'>\" );\n            this.listFactoryConfigurations( pw, ca, optionalMetaType, locale );\n            pw.println( \"<\/td>\" );\n            pw.println( \"<\/tr>\" );\n        }\n\n        pw.println( \"<\/table>\" );\n\n        // if a configuration is addressed, display it immediately\n        Configuration config = getConfiguration( getConfigurationAdmin(), request.getPathInfo() );\n        if ( config != null )\n        {\n            Util.startScript( pw );\n\n            pw.println( \"var configuration=\" );\n            printConfigurationJson( pw, config.getPid(), config, getLocale( request ) );\n            pw.println( \";\" );\n\n            pw.println( \"displayConfigForm(configuration);\" );\n\n            Util.endScript( pw );\n        }\n    }","id":85379,"modified_method":"public void renderContent( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n\n        // true if MetaType service information is not required\n        boolean optionalMetaType = false;\n\n        // extract the configuration pid from the request path\n        String pid = request.getPathInfo();\n        pid = pid.substring( pid.lastIndexOf( '/' ) + 1 );\n        \n        // check whether the pid is actually a filter for the selection\n        // of configurations to display, if the filter correctly converts\n        // into an OSGi filter, we use it to select configurations\n        // to display\n        String pidFilter = request.getParameter( PID_FILTER );\n        if ( pidFilter == null )\n        {\n            pidFilter = pid;\n        }\n        try\n        {\n            getBundleContext().createFilter( pidFilter );\n            \n            // if the pidFilter was set from the pid, clear the pid\n            if ( pid == pidFilter )\n            {\n                pid = null;\n            }\n        }\n        catch ( InvalidSyntaxException ise )\n        {\n            // its ok, if the pid is just a single PID\n            pidFilter = null;\n        }\n\n        Locale loc = getLocale( request );\n        String locale = ( loc != null ) ? loc.toString() : null;\n\n        PrintWriter pw = response.getWriter();\n\n        String appRoot = (String) request.getAttribute( OsgiManager.ATTR_APP_ROOT );\n        pw.println( \"<script src='\" + appRoot + \"/res/ui/configmanager.js' language='JavaScript'><\/script>\" );\n\n        pw.println( \"<table class='content' cellpadding='0' cellspacing='0' width='100%'>\" );\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n        if ( ca == null )\n        {\n            pw.println( \"<tr class='content' id='configField'>\" );\n            pw.println( \"<td class='content'>&nbsp;<\/th>\" );\n            pw.println( \"<td class='content'>\" );\n            pw.print( \"Configuration Admin Service not available\" );\n            pw.println( \"<\/td>\" );\n            pw.println( \"<\/tr>\" );\n        }\n        else\n        {\n            pw.println( \"<tr class='content' id='configField'>\" );\n            pw.println( \"<td class='content'>Configurations<\/th>\" );\n            pw.println( \"<td class='content'>\" );\n            this.listConfigurations( pw, ca, pidFilter, optionalMetaType, locale );\n            pw.println( \"<\/td>\" );\n            pw.println( \"<\/tr>\" );\n\n            pw.println( \"<tr class='content' id='factoryField'>\" );\n            pw.println( \"<td class='content'>Factory Configurations<\/th>\" );\n            pw.println( \"<td class='content'>\" );\n            this.listFactoryConfigurations( pw, ca, pidFilter, optionalMetaType, locale );\n            pw.println( \"<\/td>\" );\n            pw.println( \"<\/tr>\" );\n        }\n\n        pw.println( \"<\/table>\" );\n\n        // if a configuration is addressed, display it immediately\n        Configuration config;\n        if ( request.getParameter( \"create\" ) != null && pid != null )\n        {\n            config = new PlaceholderConfiguration( pid );\n            pid = config.getPid();\n        }\n        else\n        {\n            config = getConfiguration( getConfigurationAdmin(), pid );\n        }\n        \n        if ( config != null )\n        {\n            Util.startScript( pw );\n\n            pw.println( \"var configuration=\" );\n            printConfigurationJson( pw, config.getPid(), config, pidFilter, getLocale( request ) );\n            pw.println( \";\" );\n\n            pw.println( \"displayConfigForm(configuration);\" );\n\n            Util.endScript( pw );\n        }\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"private void configForm( JSONWriter json, String pid, Configuration config, Locale loc ) throws IOException,\n        JSONException\n    {\n        String locale = ( loc == null ) ? null : loc.toString();\n\n        json.key( ConfigManager.PID );\n        json.value( pid );\n\n        if ( pid == PLACEHOLDER_PID )\n        {\n            json.key( ConfigManager.factoryPID );\n            json.value( config.getFactoryPid() );\n        }\n\n        Dictionary props = null;\n        ObjectClassDefinition ocd;\n        if ( config != null )\n        {\n            props = config.getProperties();\n            ocd = this.getObjectClassDefinition( config, locale );\n        }\n        else\n        {\n            ocd = this.getObjectClassDefinition( pid, locale );\n        }\n\n        props = this.mergeWithMetaType( props, ocd, json );\n\n        if ( props != null )\n        {\n\n            json.key( \"title\" );\n            json.value( pid );\n            json.key( \"description\" );\n            json\n                .value( \"Please enter configuration properties for this configuration in the field below. This configuration has no associated description\" );\n\n            json.key( \"propertylist\" );\n            json.value( \"properties\" );\n\n            json.key( \"properties\" );\n            json.object();\n            for ( Enumeration pe = props.keys(); pe.hasMoreElements(); )\n            {\n                Object key = pe.nextElement();\n\n                // ignore well known special properties\n                if ( !key.equals( Constants.SERVICE_PID ) && !key.equals( Constants.SERVICE_DESCRIPTION )\n                    && !key.equals( Constants.SERVICE_ID ) && !key.equals( Constants.SERVICE_RANKING )\n                    && !key.equals( Constants.SERVICE_VENDOR )\n                    && !key.equals( ConfigurationAdmin.SERVICE_BUNDLELOCATION )\n                    && !key.equals( ConfigurationAdmin.SERVICE_FACTORYPID ) )\n                {\n                    json.key( String.valueOf( key ) );\n                    json.value( props.get( key ) );\n                }\n            }\n            json.endObject();\n\n        }\n\n        if ( config != null )\n        {\n            this.addConfigurationInfo( config, json, locale );\n        }\n    }","id":85380,"modified_method":"private void configForm( JSONWriter json, String pid, Configuration config, String pidFilter, Locale loc )\n        throws JSONException\n    {\n        String locale = ( loc == null ) ? null : loc.toString();\n\n        json.key( ConfigManager.PID );\n        json.value( pid );\n\n        if ( pid == PLACEHOLDER_PID )\n        {\n            json.key( ConfigManager.factoryPID );\n            json.value( config.getFactoryPid() );\n        }\n        \n        if ( pidFilter != null )\n        {\n            json.key( PID_FILTER );\n            json.value( pidFilter );\n        }\n\n        Dictionary props = null;\n        ObjectClassDefinition ocd;\n        if ( config != null )\n        {\n            props = config.getProperties();\n            ocd = this.getObjectClassDefinition( config, locale );\n        }\n        else\n        {\n            ocd = this.getObjectClassDefinition( pid, locale );\n        }\n\n        props = this.mergeWithMetaType( props, ocd, json );\n\n        if ( props != null )\n        {\n\n            json.key( \"title\" );\n            json.value( pid );\n            json.key( \"description\" );\n            json\n                .value( \"Please enter configuration properties for this configuration in the field below. This configuration has no associated description\" );\n\n            json.key( \"propertylist\" );\n            json.value( \"properties\" );\n\n            json.key( \"properties\" );\n            json.object();\n            for ( Enumeration pe = props.keys(); pe.hasMoreElements(); )\n            {\n                Object key = pe.nextElement();\n\n                // ignore well known special properties\n                if ( !key.equals( Constants.SERVICE_PID ) && !key.equals( Constants.SERVICE_DESCRIPTION )\n                    && !key.equals( Constants.SERVICE_ID ) && !key.equals( Constants.SERVICE_RANKING )\n                    && !key.equals( Constants.SERVICE_VENDOR )\n                    && !key.equals( ConfigurationAdmin.SERVICE_BUNDLELOCATION )\n                    && !key.equals( ConfigurationAdmin.SERVICE_FACTORYPID ) )\n                {\n                    json.key( String.valueOf( key ) );\n                    json.value( props.get( key ) );\n                }\n            }\n            json.endObject();\n\n        }\n\n        if ( config != null )\n        {\n            this.addConfigurationInfo( config, json, locale );\n        }\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"private SortedMap getServices( String serviceClass, boolean optionalMetaType, String locale )\n        throws InvalidSyntaxException\n    {\n        // sorted map of options\n        SortedMap optionsFactory = new TreeMap( String.CASE_INSENSITIVE_ORDER );\n\n        // find all ManagedServiceFactories to get the factoryPIDs\n        ServiceReference[] refs = this.getBundleContext().getServiceReferences( serviceClass, null );\n        for ( int i = 0; refs != null && i < refs.length; i++ )\n        {\n            Object pidObject = refs[i].getProperty( Constants.SERVICE_PID );\n            if ( pidObject instanceof String )\n            {\n                String pid = ( String ) pidObject;\n                String name;\n                ObjectClassDefinition ocd = this.getObjectClassDefinition( refs[i].getBundle(), pid, locale );\n                if ( ocd != null )\n                {\n                    name = ocd.getName() + \" (\";\n                    name += pid + \")\";\n                }\n                else\n                {\n                    name = pid;\n                }\n\n                if ( ocd != null || optionalMetaType )\n                {\n                    optionsFactory.put( pid, name );\n                }\n            }\n        }\n\n        return optionsFactory;\n    }","id":85381,"modified_method":"private SortedMap getServices( String serviceClass, String serviceFilter, boolean optionalMetaType, String locale )\n        throws InvalidSyntaxException\n    {\n        // sorted map of options\n        SortedMap optionsFactory = new TreeMap( String.CASE_INSENSITIVE_ORDER );\n\n        // find all ManagedServiceFactories to get the factoryPIDs\n        ServiceReference[] refs = this.getBundleContext().getServiceReferences( serviceClass, serviceFilter );\n        for ( int i = 0; refs != null && i < refs.length; i++ )\n        {\n            Object pidObject = refs[i].getProperty( Constants.SERVICE_PID );\n            if ( pidObject instanceof String )\n            {\n                String pid = ( String ) pidObject;\n                String name;\n                ObjectClassDefinition ocd = this.getObjectClassDefinition( refs[i].getBundle(), pid, locale );\n                if ( ocd != null )\n                {\n                    name = ocd.getName() + \" (\";\n                    name += pid + \")\";\n                }\n                else\n                {\n                    name = pid;\n                }\n\n                if ( ocd != null || optionalMetaType )\n                {\n                    optionsFactory.put( pid, name );\n                }\n            }\n        }\n\n        return optionsFactory;\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"private Configuration getConfiguration( ConfigurationAdmin ca, String pid )\n    {\n        if ( ca != null )\n        {\n            // only use last part of the pathInfo\n            pid = pid.substring( pid.lastIndexOf( '/' ) + 1 );\n\n            try\n            {\n                // we use listConfigurations to not create configuration\n                // objects persistently without the user providing actual\n                // configuration\n                String filter = \"(\" + Constants.SERVICE_PID + \"=\" + pid + \")\";\n                Configuration[] configs = ca.listConfigurations( filter );\n                if ( configs != null && configs.length > 0 )\n                {\n                    return configs[0];\n                }\n            }\n            catch ( InvalidSyntaxException ise )\n            {\n                // should print message\n            }\n            catch ( IOException ioe )\n            {\n                // should print message\n            }\n        }\n\n        // fallback to no configuration at all\n        return null;\n    }","id":85382,"modified_method":"private Configuration getConfiguration( ConfigurationAdmin ca, String pid )\n    {\n        if ( ca != null && pid != null )\n        {\n            try\n            {\n                // we use listConfigurations to not create configuration\n                // objects persistently without the user providing actual\n                // configuration\n                String filter = \"(\" + Constants.SERVICE_PID + \"=\" + pid + \")\";\n                Configuration[] configs = ca.listConfigurations( filter );\n                if ( configs != null && configs.length > 0 )\n                {\n                    return configs[0];\n                }\n            }\n            catch ( InvalidSyntaxException ise )\n            {\n                // should print message\n            }\n            catch ( IOException ioe )\n            {\n                // should print message\n            }\n        }\n\n        // fallback to no configuration at all\n        return null;\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"private void printOptionsForm( PrintWriter pw, SortedMap options, String formId, String submitMethod,\n        String submitLabel )\n    {\n        pw.println( \"<select class='select' name='pid' id='\" + formId + \"' onChange='\" + submitMethod + \"();'>\" );\n        for ( Iterator ei = options.entrySet().iterator(); ei.hasNext(); )\n        {\n            Entry entry = ( Entry ) ei.next();\n            pw.print( \"<option value='\" + entry.getKey() + \"'>\" );\n            pw.print( entry.getValue() );\n            pw.println( \"<\/option>\" );\n        }\n        pw.println( \"<\/select>\" );\n        pw.println( \"&nbsp;&nbsp;\" );\n        pw.println( \"<input class='submit' type='button' value='\" + submitLabel + \"' onClick='\" + submitMethod\n            + \"();' />\" );\n\n    }","id":85383,"modified_method":"private void printOptionsForm( PrintWriter pw, SortedMap options, String formId, String submitMethod,\n        String submitLabel )\n    {\n        SortedSet set = new TreeSet();\n        for ( Iterator ei = options.entrySet().iterator(); ei.hasNext(); )\n        {\n            Entry entry = ( Entry ) ei.next();\n            set.add(entry.getValue().toString() + Character.MAX_VALUE + entry.getKey().toString());\n        }\n\n        pw.println( \"<select class='select' name='pid' id='\" + formId + \"' onChange='\" + submitMethod + \"();'>\" );\n        for ( Iterator ei = set.iterator(); ei.hasNext(); )\n        {\n            String entry = ( String ) ei.next();\n            int sep = entry.indexOf( Character.MAX_VALUE );\n            String value = entry.substring( 0, sep );\n            String key = entry.substring( sep + 1 );\n            pw.print( \"<option value='\" + key + \"'>\" );\n            pw.print( value );\n            pw.println( \"<\/option>\" );\n        }\n        pw.println( \"<\/select>\" );\n        pw.println( \"&nbsp;&nbsp;\" );\n        pw.println( \"<input class='submit' type='button' value='\" + submitLabel + \"' onClick='\" + submitMethod\n            + \"();' />\" );\n\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"protected void doPost( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        // needed multiple times below\n        String pid = request.getParameter( ConfigManager.PID );\n        if ( pid == null )\n        {\n            String info = request.getPathInfo();\n            pid = info.substring( info.lastIndexOf( '/' ) + 1 );\n        }\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n\n        // ignore this request if the pid and/or configuration admin is missing\n        if ( pid == null || ca == null )\n        {\n            // should log this here !!\n            return;\n        }\n\n        // the configuration to operate on (to be created or \"missing\")\n        Configuration config = null;\n\n        // should actually apply the configuration before redirecting\n        if ( request.getParameter( \"create\" ) != null )\n        {\n            config = new PlaceholderConfiguration( pid ); // ca.createFactoryConfiguration( pid, null );\n            pid = config.getPid();\n        }\n        else if ( request.getParameter( \"apply\" ) != null )\n        {\n            String redirect = applyConfiguration( request, ca, pid );\n            if ( redirect != null )\n            {\n                response.sendRedirect( redirect );\n            }\n\n            return;\n        }\n\n        if ( config == null )\n        {\n            config = getConfiguration( ca, pid );\n        }\n\n        // send the result\n        response.setContentType( \"text/javascript\" );\n        response.setCharacterEncoding( \"UTF-8\" );\n        printConfigurationJson( response.getWriter(), pid, config, getLocale( request ) );\n    }","id":85384,"modified_method":"protected void doPost( HttpServletRequest request, HttpServletResponse response ) throws IOException\n    {\n        // needed multiple times below\n        String pid = request.getParameter( ConfigManager.PID );\n        if ( pid == null )\n        {\n            String info = request.getPathInfo();\n            pid = info.substring( info.lastIndexOf( '/' ) + 1 );\n        }\n\n        // the filter to select part of the configurations\n        String pidFilter = request.getParameter( PID_FILTER );\n\n        ConfigurationAdmin ca = this.getConfigurationAdmin();\n\n        // ignore this request if the pid and/or configuration admin is missing\n        if ( pid == null || ca == null )\n        {\n            // should log this here !!\n            return;\n        }\n\n        // the configuration to operate on (to be created or \"missing\")\n        Configuration config = null;\n\n        // should actually apply the configuration before redirecting\n        if ( request.getParameter( \"create\" ) != null )\n        {\n            config = new PlaceholderConfiguration( pid ); // ca.createFactoryConfiguration( pid, null );\n            pid = config.getPid();\n        }\n        else if ( request.getParameter( \"apply\" ) != null )\n        {\n            String redirect = applyConfiguration( request, ca, pid );\n            if ( redirect != null )\n            {\n                if (pidFilter != null) {\n                    redirect += \"?\" + PID_FILTER + \"=\" + pidFilter;\n                }\n                \n                response.sendRedirect( redirect );\n            }\n\n            return;\n        }\n\n        if ( config == null )\n        {\n            config = getConfiguration( ca, pid );\n        }\n\n        // send the result\n        response.setContentType( \"text/javascript\" );\n        response.setCharacterEncoding( \"UTF-8\" );\n        printConfigurationJson( response.getWriter(), pid, config, pidFilter, getLocale( request ) );\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"private void listFactoryConfigurations( PrintWriter pw, ConfigurationAdmin ca, boolean optionalMetaType,\n        String locale )\n    {\n        try\n        {\n            SortedMap optionsFactory = getServices( ManagedServiceFactory.class.getName(), optionalMetaType, locale );\n            printOptionsForm( pw, optionsFactory, \"configSelection_factory\", \"create\", \"Create\" );\n        }\n        catch ( Exception e )\n        {\n            // write a message or ignore\n        }\n    }","id":85385,"modified_method":"private void listFactoryConfigurations( PrintWriter pw, ConfigurationAdmin ca, String pidFilter, boolean optionalMetaType,\n        String locale )\n    {\n        try\n        {\n            SortedMap optionsFactory = getServices( ManagedServiceFactory.class.getName(), pidFilter, optionalMetaType, locale );\n            printOptionsForm( pw, optionsFactory, \"configSelection_factory\", \"create\", \"Create\" );\n        }\n        catch ( Exception e )\n        {\n            // write a message or ignore\n        }\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"private String applyConfiguration( HttpServletRequest request, ConfigurationAdmin ca, String pid )\n        throws IOException\n    {\n        if ( request.getParameter( \"delete\" ) != null )\n        {\n            // only delete if the PID is not our place holder\n            if ( !PLACEHOLDER_PID.equals( pid ) )\n            {\n                // TODO: should log this here !!\n                Configuration config = ca.getConfiguration( pid, null );\n                config.delete();\n            }\n            return \"\"; // up a level\n        }\n\n        String factoryPid = request.getParameter( ConfigManager.factoryPID );\n        Configuration config = null;\n\n        String propertyList = request.getParameter( \"propertylist\" );\n        if ( propertyList == null )\n        {\n            String propertiesString = request.getParameter( \"properties\" );\n\n            if ( propertiesString != null )\n            {\n                byte[] propBytes = propertiesString.getBytes( \"ISO-8859-1\" );\n                ByteArrayInputStream bin = new ByteArrayInputStream( propBytes );\n                Properties props = new Properties();\n                props.load( bin );\n\n                config = getConfiguration( ca, pid, factoryPid );\n                config.update( props );\n            }\n        }\n        else\n        {\n            config = getConfiguration( ca, pid, factoryPid );\n\n            Dictionary props = config.getProperties();\n            if ( props == null )\n            {\n                props = new Hashtable();\n            }\n\n            Map adMap = this.getAttributeDefinitionMap( config, null );\n            if ( adMap != null )\n            {\n                StringTokenizer propTokens = new StringTokenizer( propertyList, \",\" );\n                while ( propTokens.hasMoreTokens() )\n                {\n                    String propName = propTokens.nextToken();\n                    AttributeDefinition ad = ( AttributeDefinition ) adMap.get( propName );\n                    if ( ad == null || ( ad.getCardinality() == 0 && ad.getType() == AttributeDefinition.STRING ) )\n                    {\n                        String prop = request.getParameter( propName );\n                        if ( prop != null )\n                        {\n                            props.put( propName, prop );\n                        }\n                    }\n                    else if ( ad.getCardinality() == 0 )\n                    {\n                        // scalar of non-string\n                        String prop = request.getParameter( propName );\n                        props.put( propName, this.toType( ad.getType(), prop ) );\n                    }\n                    else\n                    {\n                        // array or vector of any type\n                        Vector vec = new Vector();\n\n                        String[] properties = request.getParameterValues( propName );\n                        if ( properties != null )\n                        {\n                            for ( int i = 0; i < properties.length; i++ )\n                            {\n                                vec.add( this.toType( ad.getType(), properties[i] ) );\n                            }\n                        }\n\n                        // but ensure size\n                        int maxSize = Math.abs( ad.getCardinality() );\n                        if ( vec.size() > maxSize )\n                        {\n                            vec.setSize( maxSize );\n                        }\n\n                        if ( ad.getCardinality() < 0 )\n                        {\n                            // keep the vector\n                            props.put( propName, vec );\n                        }\n                        else\n                        {\n                            // convert to an array\n                            props.put( propName, this.toArray( ad.getType(), vec ) );\n                        }\n                    }\n                }\n            }\n\n            config.update( props );\n        }\n\n        // redirect to the new configuration (if existing)\n        return (config != null) ? config.getPid() : \"\";\n    }","id":85386,"modified_method":"private String applyConfiguration( HttpServletRequest request, ConfigurationAdmin ca, String pid )\n        throws IOException\n    {\n        if ( request.getParameter( \"delete\" ) != null )\n        {\n            // only delete if the PID is not our place holder\n            if ( !PLACEHOLDER_PID.equals( pid ) )\n            {\n                // TODO: should log this here !!\n                Configuration config = ca.getConfiguration( pid, null );\n                config.delete();\n            }\n            return request.getHeader( \"Referer\" );\n        }\n\n        String factoryPid = request.getParameter( ConfigManager.factoryPID );\n        Configuration config = null;\n\n        String propertyList = request.getParameter( \"propertylist\" );\n        if ( propertyList == null )\n        {\n            String propertiesString = request.getParameter( \"properties\" );\n\n            if ( propertiesString != null )\n            {\n                byte[] propBytes = propertiesString.getBytes( \"ISO-8859-1\" );\n                ByteArrayInputStream bin = new ByteArrayInputStream( propBytes );\n                Properties props = new Properties();\n                props.load( bin );\n\n                config = getConfiguration( ca, pid, factoryPid );\n                config.update( props );\n            }\n        }\n        else\n        {\n            config = getConfiguration( ca, pid, factoryPid );\n\n            Dictionary props = config.getProperties();\n            if ( props == null )\n            {\n                props = new Hashtable();\n            }\n\n            Map adMap = this.getAttributeDefinitionMap( config, null );\n            if ( adMap != null )\n            {\n                StringTokenizer propTokens = new StringTokenizer( propertyList, \",\" );\n                while ( propTokens.hasMoreTokens() )\n                {\n                    String propName = propTokens.nextToken();\n                    AttributeDefinition ad = ( AttributeDefinition ) adMap.get( propName );\n                    if ( ad == null || ( ad.getCardinality() == 0 && ad.getType() == AttributeDefinition.STRING ) )\n                    {\n                        String prop = request.getParameter( propName );\n                        if ( prop != null )\n                        {\n                            props.put( propName, prop );\n                        }\n                    }\n                    else if ( ad.getCardinality() == 0 )\n                    {\n                        // scalar of non-string\n                        String prop = request.getParameter( propName );\n                        props.put( propName, this.toType( ad.getType(), prop ) );\n                    }\n                    else\n                    {\n                        // array or vector of any type\n                        Vector vec = new Vector();\n\n                        String[] properties = request.getParameterValues( propName );\n                        if ( properties != null )\n                        {\n                            for ( int i = 0; i < properties.length; i++ )\n                            {\n                                vec.add( this.toType( ad.getType(), properties[i] ) );\n                            }\n                        }\n\n                        // but ensure size\n                        int maxSize = Math.abs( ad.getCardinality() );\n                        if ( vec.size() > maxSize )\n                        {\n                            vec.setSize( maxSize );\n                        }\n\n                        if ( ad.getCardinality() < 0 )\n                        {\n                            // keep the vector\n                            props.put( propName, vec );\n                        }\n                        else\n                        {\n                            // convert to an array\n                            props.put( propName, this.toArray( ad.getType(), vec ) );\n                        }\n                    }\n                }\n            }\n\n            config.update( props );\n        }\n\n        // redirect to the new configuration (if existing)\n        return (config != null) ? config.getPid() : \"\";\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"private void printConfigurationJson( PrintWriter pw, String pid, Configuration config, Locale locale )\n        throws IOException\n    {\n\n        JSONWriter result = new JSONWriter( pw );\n\n        if ( pid != null )\n        {\n            try\n            {\n                result.object();\n                this.configForm( result, pid, config, locale );\n                result.endObject();\n            }\n            catch ( Exception e )\n            {\n                // add message\n            }\n        }\n\n    }","id":85387,"modified_method":"private void printConfigurationJson( PrintWriter pw, String pid, Configuration config, String pidFilter,\n        Locale locale )\n    {\n\n        JSONWriter result = new JSONWriter( pw );\n\n        if ( pid != null )\n        {\n            try\n            {\n                result.object();\n                this.configForm( result, pid, config, pidFilter, locale );\n                result.endObject();\n            }\n            catch ( Exception e )\n            {\n                // add message\n            }\n        }\n\n    }","commit_id":"3b2f5fe8c13281b07b9604daac46f5617ee9a3ed","url":"https://github.com/apache/felix"},{"original_method":"@Override\n    protected void service(SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws IOException {\n\n        // if the request is logged in and the resource is not set (such\n        // as when requesting /system/sling/login from the browser with the\n        // browser sending credentials) or the resource is set to the login\n        // servlet as a result of authenticating after providing credentials\n        // through the login servlet), redirect to root now assuming we are\n        // authenticated.\n        if (request.getAuthType() != null) {\n            final String resourcePath = request.getParameter(\"resource\");\n            if (isSelf(resourcePath)) {\n                String redirectTarget = request.getContextPath() + \"/\";\n                log.warn(\n                    \"doGet: Redirecting to {} to prevent login loop for resource {}\",\n                    redirectTarget, resourcePath);\n                response.sendRedirect(redirectTarget);\n                return;\n            }\n        }\n\n        Authenticator authenticator = this.authenticator;\n        if (authenticator != null) {\n            try {\n                authenticator.login(request, response);\n                return;\n            } catch (IllegalStateException ise) {\n                log.error(\"doGet: Response already committed, cannot login\");\n                return;\n            } catch (NoAuthenticationHandlerException nahe) {\n                log.error(\"doGet: No AuthenticationHandler to login registered\");\n            }\n        } else {\n            log.error(\"doGet: Authenticator service missing, cannot login\");\n        }\n\n        // fall back to forbid access\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Cannot login\");\n    }","id":85388,"modified_method":"@Override\n    protected void service(SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws IOException {\n\n        final String resourcePath = request.getParameter(Authenticator.LOGIN_RESOURCE);\n\n        // if the request is logged in and the resource is not set (such\n        // as when requesting /system/sling/login from the browser with the\n        // browser sending credentials) or the resource is set to the login\n        // servlet as a result of authenticating after providing credentials\n        // through the login servlet), redirect to root now assuming we are\n        // authenticated.\n        if (request.getAuthType() != null) {\n            if (isSelf(resourcePath)) {\n                String redirectTarget = request.getContextPath() + \"/\";\n                log.warn(\n                    \"doGet: Redirecting to {} to prevent login loop for resource {}\",\n                    redirectTarget, resourcePath);\n                response.sendRedirect(redirectTarget);\n                return;\n            }\n        }\n\n        Authenticator authenticator = this.authenticator;\n        if (authenticator != null) {\n            try {\n\n                // set the login resource to select the authenticator\n                request.setAttribute(Authenticator.LOGIN_RESOURCE,\n                    (resourcePath != null) ? resourcePath : \"/\");\n\n                authenticator.login(request, response);\n                return;\n\n            } catch (IllegalStateException ise) {\n\n                log.error(\"doGet: Response already committed, cannot login\");\n                return;\n\n            } catch (NoAuthenticationHandlerException nahe) {\n\n                log.error(\"doGet: No AuthenticationHandler to login registered\");\n\n            }\n\n        } else {\n\n            log.error(\"doGet: Authenticator service missing, cannot login\");\n\n        }\n\n        // fall back to forbid access\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Cannot login\");\n    }","commit_id":"441665a9a99b5c6584fd3be7b94da2965022294e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Requests authentication information from the client. Returns\n     * <code>true<\/code> if the information has been requested and request\n     * processing can be terminated. Otherwise the request information could not\n     * be requested and the request should be terminated with a 403/FORBIDDEN\n     * response.\n     * <p>\n     * Any response sent by the handler is also handled by the error handler\n     * infrastructure.\n     *\n     * @param request The request object\n     * @param response The response object to which to send the request\n     * @throws IllegalStateException If response is already committed\n     * @throws NoAuthenticationHandlerException If no authentication handler\n     *             claims responsibility to authenticate the request.\n     */\n    public void login(HttpServletRequest request, HttpServletResponse response) {\n\n        // ensure the response is not committed yet\n        if (response.isCommitted()) {\n            throw new IllegalStateException(\"Response already committed\");\n        }\n\n        AuthenticationHandlerHolder[] handlerInfos = findApplicableAuthenticationHandlers(request);\n        boolean done = false;\n        for (int i = 0; !done && i < handlerInfos.length; i++) {\n            if ( request.getPathInfo().startsWith(handlerInfos[i].path) ) {\n                log.debug(\n                    \"login: requesting authentication using handler: {}\",\n                    handlerInfos[i]);\n\n                try {\n                    done = handlerInfos[i].requestAuthentication(request, response);\n                } catch (IOException ioe) {\n                    log.error(\n                        \"login: Failed sending authentication request through handler \"\n                            + handlerInfos[i] + \", access forbidden\", ioe);\n                    done = true;\n                }\n            }\n        }\n\n        // no handler could send an authentication request, throw\n        if (!done) {\n            log.info(\n                \"login: No handler for request ({} handlers available)\",\n                handlerInfos.length);\n            throw new NoAuthenticationHandlerException();\n        }\n    }","id":85389,"modified_method":"/**\n     * Requests authentication information from the client. Returns\n     * <code>true<\/code> if the information has been requested and request\n     * processing can be terminated. Otherwise the request information could not\n     * be requested and the request should be terminated with a 403/FORBIDDEN\n     * response.\n     * <p>\n     * Any response sent by the handler is also handled by the error handler\n     * infrastructure.\n     *\n     * @param request The request object\n     * @param response The response object to which to send the request\n     * @throws IllegalStateException If response is already committed\n     * @throws NoAuthenticationHandlerException If no authentication handler\n     *             claims responsibility to authenticate the request.\n     */\n    public void login(HttpServletRequest request, HttpServletResponse response) {\n\n        // ensure the response is not committed yet\n        if (response.isCommitted()) {\n            throw new IllegalStateException(\"Response already committed\");\n        }\n\n        // select path used for authentication handler selection\n        final Object loginPathO = request.getAttribute(Authenticator.LOGIN_RESOURCE);\n        String path = (loginPathO instanceof String)\n                ? (String) loginPathO\n                : request.getPathInfo();\n        if (path == null || path.length() == 0) {\n            path = \"/\";\n        }\n\n        AuthenticationHandlerHolder[] handlerInfos = findApplicableAuthenticationHandlers(request);\n        boolean done = false;\n        for (int i = 0; !done && i < handlerInfos.length; i++) {\n            if ( path.startsWith(handlerInfos[i].path) ) {\n                log.debug(\n                    \"login: requesting authentication using handler: {}\",\n                    handlerInfos[i]);\n\n                try {\n                    done = handlerInfos[i].requestAuthentication(request, response);\n                } catch (IOException ioe) {\n                    log.error(\n                        \"login: Failed sending authentication request through handler \"\n                            + handlerInfos[i] + \", access forbidden\", ioe);\n                    done = true;\n                }\n            }\n        }\n\n        // no handler could send an authentication request, throw\n        if (!done) {\n            log.info(\n                \"login: No handler for request ({} handlers available)\",\n                handlerInfos.length);\n            throw new NoAuthenticationHandlerException();\n        }\n    }","commit_id":"441665a9a99b5c6584fd3be7b94da2965022294e","url":"https://github.com/apache/sling"},{"original_method":"public static Balloon createBalloon(@NotNull final IdeFrame window, final Notification notification, final boolean showCallout, final boolean hideOnClickOutside) {\n    final JEditorPane text = new JEditorPane();\n    text.setEditorKit(UIUtil.getHTMLEditorKit());\n\n    final HyperlinkListener listener = NotificationsUtil.wrapListener(notification);\n    if (listener != null) {\n      text.addHyperlinkListener(listener);\n    }\n\n    final JLabel label = new JLabel(NotificationsUtil.buildHtml(notification, null));\n    text.setText(NotificationsUtil.buildHtml(notification, \"width:\" + Math.min(350, label.getPreferredSize().width) + \"px;\"));\n    text.setEditable(false);\n    text.setOpaque(false);\n\n    if (UIUtil.isUnderNimbusLookAndFeel()) {\n      text.setBackground(UIUtil.TRANSPARENT_COLOR);\n    }\n\n    text.setBorder(null);\n\n    final JPanel content = new NonOpaquePanel(new BorderLayout((int)(label.getIconTextGap() * 1.5), (int)(label.getIconTextGap() * 1.5)));\n\n    text.setCaretPosition(0);\n    JScrollPane pane = ScrollPaneFactory.createScrollPane(text,\n                                                          ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,\n                                                          ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    pane.setBorder(null);\n    pane.setOpaque(false);\n    pane.getViewport().setOpaque(false);\n    content.add(pane, BorderLayout.CENTER);\n\n    final NonOpaquePanel north = new NonOpaquePanel(new BorderLayout());\n    north.add(new JLabel(NotificationsUtil.getIcon(notification)), BorderLayout.NORTH);\n    content.add(north, BorderLayout.WEST);\n\n    content.setBorder(new EmptyBorder(2, 4, 2, 4));\n\n    Dimension preferredSize = text.getPreferredSize();\n    text.setSize(preferredSize);\n    \n    Dimension paneSize = new Dimension(text.getPreferredSize());\n    int maxHeight = Math.min(400, window.getComponent().getHeight() - 20);\n    int maxWidth = Math.min(600, window.getComponent().getWidth() - 20);\n    if (paneSize.height > maxHeight) {\n      pane.setPreferredSize(new Dimension(Math.min(maxWidth, paneSize.width + UIUtil.getScrollBarWidth()), maxHeight));\n    } else if (paneSize.width > maxWidth) {\n      pane.setPreferredSize(new Dimension(maxWidth, paneSize.height + UIUtil.getScrollBarWidth()));\n    }\n\n    final BalloonBuilder builder = JBPopupFactory.getInstance().createBalloonBuilder(content);\n    builder.setFillColor(new JBColor(Gray._234, Gray._92))\n      .setCloseButtonEnabled(true)\n      .setShowCallout(showCallout)\n      .setShadow(false)\n      .setHideOnClickOutside(hideOnClickOutside)\n      .setHideOnAction(hideOnClickOutside)\n      .setHideOnKeyOutside(hideOnClickOutside)\n      .setHideOnFrameResize(false)\n      .setBorderColor(new JBColor(Gray._180, Gray._110));\n\n    final Balloon balloon = builder.createBalloon();\n    balloon.setAnimationEnabled(false);\n    notification.setBalloon(balloon);\n    return balloon;\n  }","id":85390,"modified_method":"public static Balloon createBalloon(@NotNull final IdeFrame window, final Notification notification, final boolean showCallout, final boolean hideOnClickOutside) {\n    final JEditorPane text = new JEditorPane();\n    text.setEditorKit(UIUtil.getHTMLEditorKit());\n\n    final HyperlinkListener listener = NotificationsUtil.wrapListener(notification);\n    if (listener != null) {\n      text.addHyperlinkListener(listener);\n    }\n\n    final JLabel label = new JLabel(NotificationsUtil.buildHtml(notification, null));\n    text.setText(NotificationsUtil.buildHtml(notification, \"width:\" + Math.min(350, label.getPreferredSize().width) + \"px;\"));\n    text.setEditable(false);\n    text.setOpaque(false);\n\n    if (UIUtil.isUnderNimbusLookAndFeel()) {\n      text.setBackground(UIUtil.TRANSPARENT_COLOR);\n    }\n\n    text.setBorder(null);\n\n    final JPanel content = new NonOpaquePanel(new BorderLayout((int)(label.getIconTextGap() * 1.5), (int)(label.getIconTextGap() * 1.5)));\n\n    if (text.getCaret() != null) {\n      text.setCaretPosition(0);\n    }\n    JScrollPane pane = ScrollPaneFactory.createScrollPane(text,\n                                                          ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,\n                                                          ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    pane.setBorder(null);\n    pane.setOpaque(false);\n    pane.getViewport().setOpaque(false);\n    content.add(pane, BorderLayout.CENTER);\n\n    final NonOpaquePanel north = new NonOpaquePanel(new BorderLayout());\n    north.add(new JLabel(NotificationsUtil.getIcon(notification)), BorderLayout.NORTH);\n    content.add(north, BorderLayout.WEST);\n\n    content.setBorder(new EmptyBorder(2, 4, 2, 4));\n\n    Dimension preferredSize = text.getPreferredSize();\n    text.setSize(preferredSize);\n    \n    Dimension paneSize = new Dimension(text.getPreferredSize());\n    int maxHeight = Math.min(400, window.getComponent().getHeight() - 20);\n    int maxWidth = Math.min(600, window.getComponent().getWidth() - 20);\n    if (paneSize.height > maxHeight) {\n      pane.setPreferredSize(new Dimension(Math.min(maxWidth, paneSize.width + UIUtil.getScrollBarWidth()), maxHeight));\n    } else if (paneSize.width > maxWidth) {\n      pane.setPreferredSize(new Dimension(maxWidth, paneSize.height + UIUtil.getScrollBarWidth()));\n    }\n\n    final BalloonBuilder builder = JBPopupFactory.getInstance().createBalloonBuilder(content);\n    builder.setFillColor(new JBColor(Gray._234, Gray._92))\n      .setCloseButtonEnabled(true)\n      .setShowCallout(showCallout)\n      .setShadow(false)\n      .setHideOnClickOutside(hideOnClickOutside)\n      .setHideOnAction(hideOnClickOutside)\n      .setHideOnKeyOutside(hideOnClickOutside)\n      .setHideOnFrameResize(false)\n      .setBorderColor(new JBColor(Gray._180, Gray._110));\n\n    final Balloon balloon = builder.createBalloon();\n    balloon.setAnimationEnabled(false);\n    notification.setBalloon(balloon);\n    return balloon;\n  }","commit_id":"4c6ec523b20908cb1179ea3280bb46e75ba9bc50","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showMessageDetails(AbstractMessage aMessage) {\n    myDetailsPane.setText(new StringBuffer().append(aMessage.getMessage()).append(\"\\n\").append(aMessage.getThrowableText()).toString());\n    myDetailsPane.setCaretPosition(0);\n  }","id":85391,"modified_method":"private void showMessageDetails(AbstractMessage aMessage) {\n    myDetailsPane.setText(new StringBuffer().append(aMessage.getMessage()).append(\"\\n\").append(aMessage.getThrowableText()).toString());\n    if (myDetailsPane.getCaret() != null) { // Upon some strange circumstances caret may be missing from the text component making the following line fail with NPE.\n      myDetailsPane.setCaretPosition(0);\n    }\n  }","commit_id":"8180e00ddc2ad1cc3162b6020245d48d042a5b8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n      JPanel panel = new JPanel(new BorderLayout(15, 0));\n      if (myIcon != null) {\n        JLabel iconLabel = new JLabel(myIcon);\n        Container container = new Container();\n        container.setLayout(new BorderLayout());\n        container.add(iconLabel, BorderLayout.NORTH);\n        panel.add(container, BorderLayout.WEST);\n      }\n      if (myMessage != null) {\n        JLabel label = new JLabel();\n        final JTextPane messageComponent = new JTextPane();\n        messageComponent.setFont(label.getFont());\n        if (BasicHTML.isHTMLString(myMessage)) {\n          final HTMLEditorKit editorKit = new HTMLEditorKit();\n          editorKit.getStyleSheet().addRule(UIUtil.displayPropertiesToCSS(label.getFont(), label.getForeground()));\n          messageComponent.setEditorKit(editorKit);\n          messageComponent.setContentType(\"text/html\");\n        }\n        messageComponent.setText(myMessage);\n        messageComponent.setEditable(false);                                                         \n        messageComponent.setCaretPosition(0);\n        messageComponent.setBackground(UIUtil.getOptionPaneBackground());\n        messageComponent.setForeground(label.getForeground());\n\n        final Dimension screenSize = messageComponent.getToolkit().getScreenSize();\n        final Dimension textSize = messageComponent.getPreferredSize();\n        if (textSize.width > screenSize.width * 4 / 5 || textSize.height > screenSize.height / 2) {\n          final JScrollPane pane = ScrollPaneFactory.createScrollPane(messageComponent);\n          pane.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));\n          pane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n          pane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n          final int scrollSize = (int)new JScrollBar(JScrollBar.VERTICAL).getPreferredSize().getWidth();\n          final Dimension preferredSize =\n            new Dimension(Math.min(textSize.width, screenSize.width * 4 / 5) + scrollSize, Math.min(textSize.height, screenSize.height/2) + scrollSize);\n          pane.setPreferredSize(preferredSize);\n          panel.add(pane, BorderLayout.CENTER);\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              final Dimension textSize = messageComponent.getPreferredSize();\n              final Dimension preferredSize = new Dimension(Math.min(textSize.width, screenSize.width * 4 / 5) + scrollSize,\n                                                            Math.min(textSize.height, screenSize.height / 2) + scrollSize);\n              pane.setPreferredSize(preferredSize);\n              SwingUtilities.getWindowAncestor(pane).pack();\n            }\n          });\n        }\n        else {\n          panel.add(messageComponent, BorderLayout.CENTER);\n        }\n      }\n      return panel;\n    }","id":85392,"modified_method":"protected JComponent createCenterPanel() {\n      JPanel panel = new JPanel(new BorderLayout(15, 0));\n      if (myIcon != null) {\n        JLabel iconLabel = new JLabel(myIcon);\n        Container container = new Container();\n        container.setLayout(new BorderLayout());\n        container.add(iconLabel, BorderLayout.NORTH);\n        panel.add(container, BorderLayout.WEST);\n      }\n      if (myMessage != null) {\n        JLabel label = new JLabel();\n        final JTextPane messageComponent = new JTextPane();\n        messageComponent.setFont(label.getFont());\n        if (BasicHTML.isHTMLString(myMessage)) {\n          final HTMLEditorKit editorKit = new HTMLEditorKit();\n          editorKit.getStyleSheet().addRule(UIUtil.displayPropertiesToCSS(label.getFont(), label.getForeground()));\n          messageComponent.setEditorKit(editorKit);\n          messageComponent.setContentType(\"text/html\");\n        }\n        messageComponent.setText(myMessage);\n        messageComponent.setEditable(false);\n        if (messageComponent.getCaret() != null) {\n          messageComponent.setCaretPosition(0);\n        }\n        messageComponent.setBackground(UIUtil.getOptionPaneBackground());\n        messageComponent.setForeground(label.getForeground());\n\n        final Dimension screenSize = messageComponent.getToolkit().getScreenSize();\n        final Dimension textSize = messageComponent.getPreferredSize();\n        if (textSize.width > screenSize.width * 4 / 5 || textSize.height > screenSize.height / 2) {\n          final JScrollPane pane = ScrollPaneFactory.createScrollPane(messageComponent);\n          pane.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));\n          pane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);\n          pane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n          final int scrollSize = (int)new JScrollBar(JScrollBar.VERTICAL).getPreferredSize().getWidth();\n          final Dimension preferredSize =\n            new Dimension(Math.min(textSize.width, screenSize.width * 4 / 5) + scrollSize, Math.min(textSize.height, screenSize.height/2) + scrollSize);\n          pane.setPreferredSize(preferredSize);\n          panel.add(pane, BorderLayout.CENTER);\n          SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n              final Dimension textSize = messageComponent.getPreferredSize();\n              final Dimension preferredSize = new Dimension(Math.min(textSize.width, screenSize.width * 4 / 5) + scrollSize,\n                                                            Math.min(textSize.height, screenSize.height / 2) + scrollSize);\n              pane.setPreferredSize(preferredSize);\n              SwingUtilities.getWindowAncestor(pane).pack();\n            }\n          });\n        }\n        else {\n          panel.add(messageComponent, BorderLayout.CENTER);\n        }\n      }\n      return panel;\n    }","commit_id":"c63aa2f4c0c3858c5689f85cb4d79129774a553a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n\t * Gets last modified date of the given {@link URL}\r\n\t * \r\n\t * @param url\r\n\t * @return last modified timestamp\r\n\t * @throws IOException\r\n\t */\r\n\tpublic static long getLastModified(final URL url) throws IOException\r\n\t{\r\n\t\tURLConnection connection = url.openConnection();\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif (connection instanceof JarURLConnection)\r\n\t\t\t{\r\n\t\t\t\tJarURLConnection jarUrlConnection = (JarURLConnection)connection;\r\n\t\t\t\tURL jarFileUrl = jarUrlConnection.getJarFileURL();\r\n\t\t\t\tURLConnection jarFileConnection = jarFileUrl.openConnection();\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\treturn jarFileConnection.getLastModified();\r\n\t\t\t\t}\r\n\t\t\t\tfinally\r\n\t\t\t\t{\r\n\t\t\t\t\tclose(jarFileConnection);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn connection.getLastModified();\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tclose(connection);\r\n\t\t}\r\n\t}","id":85393,"modified_method":"/**\r\n\t * Gets last modified date of the given {@link URL}\r\n\t * \r\n\t * @param url\r\n\t * @return last modified timestamp or <code>null<\/code> if not available\r\n\t * @throws IOException\r\n\t */\r\n\tpublic static Time getLastModified(final URL url) throws IOException\r\n\t{\r\n\t\tURLConnection connection = url.openConnection();\r\n\r\n\t\tfinal long milliseconds;\r\n\t\t\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif (connection instanceof JarURLConnection)\r\n\t\t\t{\r\n\t\t\t\tJarURLConnection jarUrlConnection = (JarURLConnection)connection;\r\n\t\t\t\tURL jarFileUrl = jarUrlConnection.getJarFileURL();\r\n\t\t\t\tURLConnection jarFileConnection = jarFileUrl.openConnection();\r\n\t\t\t\t\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\t// get timestamp from JAR\r\n\t\t\t\t\tmilliseconds = jarFileConnection.getLastModified();\r\n\t\t\t\t}\r\n\t\t\t\tfinally\r\n\t\t\t\t{\r\n\t\t\t\t\tclose(jarFileConnection);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// get timestamp from URL\r\n\t\t\t\tmilliseconds = connection.getLastModified();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// return null if timestamp is unavailable\r\n\t\t\tif (milliseconds == 0)\r\n\t\t\t{\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// return UNIX timestamp\r\n\t\t\treturn Time.milliseconds(milliseconds);\r\n\t\t\t\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tclose(connection);\r\n\t\t}\r\n\t}","commit_id":"4ce2d18d445a8947eec39838a77ffda5c47e8ca1","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()\n\t * @return The last time this resource was modified\n\t */\n\t@Override\n\tpublic Time lastModifiedTime()\n\t{\n\t\ttry\n\t\t{\n\t\t\tStreamData data = getData(true);\n\n\t\t\tif (file != null)\n\t\t\t{\n\t\t\t\t// in case the file has been removed by now\n\t\t\t\tif (file.exists() == false)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tlong lastModified = file.lastModified();\n\n\t\t\t\t// if last modified changed update content length and last modified date\n\t\t\t\tif (lastModified != data.lastModified)\n\t\t\t\t{\n\t\t\t\t\tdata.lastModified = lastModified;\n\t\t\t\t\tsetContentLength();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong lastModified = Connections.getLastModified(url);\n\n\t\t\t\t// if last modified changed update content length and last modified date\n\t\t\t\tif (lastModified != data.lastModified)\n\t\t\t\t{\n\t\t\t\t\tdata.lastModified = lastModified;\n\n\t\t\t\t\tsetContentLength();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Time.milliseconds(data.lastModified);\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tif (url.toString().contains(\".jar!\"))\n\t\t\t{\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.warn(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n\t\t\t}\n\n\t\t\t// allow modification watcher to detect the problem\n\t\t\treturn null;\n\t\t}\n\t}","id":85394,"modified_method":"/**\n\t * @see org.apache.wicket.util.watch.IModifiable#lastModifiedTime()\n\t * @return The last time this resource was modified\n\t */\n\t@Override\n\tpublic Time lastModifiedTime()\n\t{\n\t\ttry\n\t\t{\n\t\t\tStreamData data = getData(true);\n\n\t\t\tfinal Time lastModified;\n\n\t\t\tif (file != null)\n\t\t\t{\n\t\t\t\t// get file modification timestamp\n\t\t\t\tlastModified = IOUtils.getLastModified(file);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// get url modification timestamp\n\t\t\t\tlastModified = Connections.getLastModified(url);\n\t\t\t}\n\n\t\t\t// if timestamp changed: update content length and last modified date\n\t\t\tif (Objects.equal(lastModified, data.lastModified) == false)\n\t\t\t{\n\t\t\t\tdata.lastModified = lastModified;\n\t\t\t\tsetContentLength();\n\t\t\t}\n\t\t\treturn data.lastModified;\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tif (url.toString().contains(\".jar!\"))\n\t\t\t{\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.warn(\"getLastModified for \" + url + \" failed: \" + e.getMessage());\n\t\t\t}\n\n\t\t\t// allow modification watcher to detect the problem\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"4ce2d18d445a8947eec39838a77ffda5c47e8ca1","url":"https://github.com/apache/wicket"},{"original_method":"private boolean isAlreadyInstalled(BundleContext context) {\n        final File dataFile = context.getDataFile(DATA_FILE);\n        if (dataFile != null && dataFile.exists()) {\n\n            FileInputStream fis = null;\n            try {\n\n                long selfStamp = getSelfTimestamp();\n                if (selfStamp > 0) {\n\n                    fis = new FileInputStream(dataFile);\n                    byte[] bytes = new byte[20];\n                    int len = fis.read(bytes);\n                    String value = new String(bytes, 0, len);\n\n                    long storedStamp = Long.parseLong(value);\n\n                    return storedStamp >= selfStamp;\n                }\n\n            } catch (NumberFormatException nfe) {\n                // probably still the old value, fallback to assume not\n                // installed\n\n            } catch (IOException ioe) {\n                logger.log(Logger.LOG_ERROR,\n                    \"IOException during reading of installed flag.\", ioe);\n\n            } finally {\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        }\n\n        // fallback assuming not installed yet\n        return false;\n    }","id":85395,"modified_method":"private boolean isAlreadyInstalled(BundleContext context,\n            File slingStartupDir) {\n        final File dataFile = context.getDataFile(DATA_FILE);\n        if (dataFile != null && dataFile.exists()) {\n\n            FileInputStream fis = null;\n            try {\n\n                long selfStamp = getSelfTimestamp(slingStartupDir);\n                if (selfStamp > 0) {\n\n                    fis = new FileInputStream(dataFile);\n                    byte[] bytes = new byte[20];\n                    int len = fis.read(bytes);\n                    String value = new String(bytes, 0, len);\n\n                    long storedStamp = Long.parseLong(value);\n\n                    return storedStamp >= selfStamp;\n                }\n\n            } catch (NumberFormatException nfe) {\n                // probably still the old value, fallback to assume not\n                // installed\n\n            } catch (IOException ioe) {\n                logger.log(Logger.LOG_ERROR,\n                    \"IOException during reading of installed flag.\", ioe);\n\n            } finally {\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (IOException ignore) {\n                    }\n                }\n            }\n        }\n\n        // fallback assuming not installed yet\n        return false;\n    }","commit_id":"2dc92a113c76619a7e0b76e9460aec6b6f1d183e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the time stamp of JAR file from which this class has been loaded\n     * or -1 if the timestamp cannot be resolved.\n     * <p>\n     * This method assumes that the ClassLoader of this class is an\n     * URLClassLoader and that the first URL entry of this class loader is the\n     * JAR providing this class. This is in fact true as the URLClassLoader has\n     * been created by the launcher from the launcher JAR file.\n     * \n     * @return The last modification time stamp of the launcher JAR file or -1\n     *         if the class loader of this class is not an URLClassLoader or the\n     *         class loader has no URL entries. Both situations are not really\n     *         expected.\n     * @throws IOException If an error occurrs reading accessing the last\n     *             modification time stampe.\n     */\n    private long getSelfTimestamp() throws IOException {\n\n        ClassLoader loader = getClass().getClassLoader();\n        if (loader instanceof URLClassLoader) {\n            URLClassLoader urlLoader = (URLClassLoader) loader;\n            URL[] urls = urlLoader.getURLs();\n            if (urls.length > 0) {\n                return urls[0].openConnection().getLastModified();\n            }\n        }\n\n        return -1;\n    }","id":85396,"modified_method":"/**\n     * Returns the time stamp of JAR file from which this class has been loaded\n     * or -1 if the timestamp cannot be resolved.\n     * <p>\n     * This method assumes that the ClassLoader of this class is an\n     * URLClassLoader and that the first URL entry of this class loader is the\n     * JAR providing this class. This is in fact true as the URLClassLoader has\n     * been created by the launcher from the launcher JAR file.\n     *\n     * @return The last modification time stamp of the launcher JAR file or -1\n     *         if the class loader of this class is not an URLClassLoader or the\n     *         class loader has no URL entries. Both situations are not really\n     *         expected.\n     * @throws IOException If an error occurrs reading accessing the last\n     *             modification time stampe.\n     */\n    private long getSelfTimestamp(File slingStartupDir) throws IOException {\n\n        // the timestamp of the launcher jar\n        long selfStamp = -1;\n        ClassLoader loader = getClass().getClassLoader();\n        if (loader instanceof URLClassLoader) {\n            URLClassLoader urlLoader = (URLClassLoader) loader;\n            URL[] urls = urlLoader.getURLs();\n            if (urls.length > 0) {\n                selfStamp = urls[0].openConnection().getLastModified();\n            }\n        }\n\n        // check whether any bundle is younger than the launcher jar\n        File[] directories = slingStartupDir.listFiles(DIRECTORY_FILTER);\n        for (File levelDir : directories) {\n\n            // iterate through all files in the startlevel dir\n            File[] jarFiles = levelDir.listFiles(JAR_FILE_FILTER);\n            for (File bundleJar : jarFiles) {\n                if (bundleJar.lastModified() > selfStamp) {\n                    selfStamp = bundleJar.lastModified();\n                }\n            }\n        }\n\n        // return the final stamp (may be -1 if launcher jar cannot be checked\n        // and there are no bundle jar files)\n        return selfStamp;\n    }","commit_id":"2dc92a113c76619a7e0b76e9460aec6b6f1d183e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the Manifrest from the JAR file in the given resource provided by\n     * the resource provider or <code>null<\/code> if the resource does not\n     * exists or is not a JAR file or has no Manifest.\n     * \n     * @param jarPath The path to the JAR file provided by the resource provider\n     *            of this instance.\n     */\n    private Manifest getManifest(String jarPath) {\n        InputStream ins = resourceProvider.getResourceAsStream(jarPath);\n        if (ins != null) {\n            try {\n                JarInputStream jar = new JarInputStream(ins);\n                return jar.getManifest();\n            } catch (IOException ioe) {\n                logger.log(Logger.LOG_ERROR, \"Failed to read manifest from \"\n                    + jarPath, ioe);\n            } finally {\n                try {\n                    ins.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n\n        return null;\n    }","id":85397,"modified_method":"/**\n     * Returns the Manifest from the JAR file in the given resource provided by\n     * the resource provider or <code>null<\/code> if the resource does not\n     * exists or is not a JAR file or has no Manifest.\n     *\n     * @param jarPath The path to the JAR file provided by the resource provider\n     *            of this instance.\n     */\n    private Manifest getManifest(File jar) {\n        try {\n            InputStream ins = new FileInputStream(jar);\n            if (ins != null) {\n                return getManifest(ins);\n            }\n        } catch (FileNotFoundException e) {\n            logger.log(Logger.LOG_WARNING, \"Could not get inputstream from file (\"+jar+\"):\"+e);\n            //throw new IllegalArgumentException(\"Could not get inputstream from file (\"+jar+\"):\"+e, e);\n        }\n        return null;\n    }","commit_id":"2dc92a113c76619a7e0b76e9460aec6b6f1d183e","url":"https://github.com/apache/sling"},{"original_method":"private void markInstalled(BundleContext context) {\n        final File dataFile = context.getDataFile(DATA_FILE);\n        try {\n            final FileOutputStream fos = new FileOutputStream(dataFile);\n            try {\n                fos.write(String.valueOf(getSelfTimestamp()).getBytes());\n            } finally {\n                try {\n                    fos.close();\n                } catch (IOException ignore) {\n                }\n            }\n        } catch (IOException ioe) {\n            logger.log(Logger.LOG_ERROR,\n                \"IOException during writing of installed flag.\", ioe);\n        }\n    }","id":85398,"modified_method":"private void markInstalled(BundleContext context, File slingStartupDir) {\n        final File dataFile = context.getDataFile(DATA_FILE);\n        try {\n            final FileOutputStream fos = new FileOutputStream(dataFile);\n            try {\n                fos.write(String.valueOf(getSelfTimestamp(slingStartupDir)).getBytes());\n            } finally {\n                try {\n                    fos.close();\n                } catch (IOException ignore) {\n                }\n            }\n        } catch (IOException ioe) {\n            logger.log(Logger.LOG_ERROR,\n                \"IOException during writing of installed flag.\", ioe);\n        }\n    }","commit_id":"2dc92a113c76619a7e0b76e9460aec6b6f1d183e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Install the Bundles from JAR files found in the given <code>parent<\/code>\n     * path.\n     * \n     * @param context The <code>BundleContext<\/code> used to install the new\n     *            Bundles.\n     * @param currentBundles The currently installed Bundles indexed by their\n     *            Bundle location.\n     * @param parent The path to the location in which to look for JAR files to\n     *            install. Only resources whose name ends with <em>.jar<\/em> are\n     *            considered for installation.\n     * @param installed The list of Bundles installed by this method. Each\n     *            Bundle successfully installed is added to this list.\n     */\n    private void installBundles(BundleContext context,\n            Map<String, Bundle> currentBundles, String parent,\n            List<Bundle> installed, StartLevel startLevelService, int startLevel) {\n\n        Iterator<String> res = resourceProvider.getChildren(parent);\n        while (res.hasNext()) {\n\n            String path = res.next();\n\n            if (path.endsWith(\".jar\")) {\n\n                // get the manifest for the bundle information\n                Manifest manifest = getManifest(path);\n                if (manifest == null) {\n                    logger.log(Logger.LOG_ERROR, \"Ignoring \" + path\n                        + \": Cannot read manifest\");\n                    continue;\n                }\n\n                // ensure a symbolic name in the jar file\n                String symbolicName = getBundleSymbolicName(manifest);\n                if (symbolicName == null) {\n                    logger.log(Logger.LOG_ERROR, \"Ignoring \" + path\n                        + \": Missing \" + Constants.BUNDLE_SYMBOLICNAME\n                        + \" in manifest\");\n                    continue;\n                }\n\n                // check for an nstalled Bundle with the symbolic name\n                Bundle installedBundle = currentBundles.get(symbolicName);\n                if (ignore(installedBundle, manifest)) {\n                    logger.log(Logger.LOG_INFO, \"Ignoring \" + path\n                        + \": More recent version already installed\");\n                    continue;\n                }\n\n                // try to access the JAR file, ignore if not possible\n                InputStream ins = resourceProvider.getResourceAsStream(path);\n                if (ins == null) {\n                    continue;\n                }\n\n                if (installedBundle != null) {\n\n                    try {\n                        installedBundle.update(ins);\n                        logger.log(Logger.LOG_INFO, \"Bundle \"\n                            + installedBundle.getSymbolicName()\n                            + \" updated from \" + path);\n                    } catch (BundleException be) {\n                        logger.log(Logger.LOG_ERROR, \"Bundle update from \"\n                            + path + \" failed\", be);\n                    }\n\n                } else {\n\n                    // install the JAR file as a bundle\n                    String location = SCHEME\n                        + path.substring(path.lastIndexOf('/') + 1);\n                    try {\n                        Bundle theBundle = context.installBundle(location, ins);\n                        logger.log(Logger.LOG_INFO, \"Bundle \"\n                            + theBundle.getSymbolicName() + \" installed from \"\n                            + location);\n\n                        // finally add the bundle to the list for later start\n                        installed.add(theBundle);\n\n                        // optionally set the start level\n                        if (startLevel > 0) {\n                            startLevelService.setBundleStartLevel(theBundle,\n                                startLevel);\n                        }\n\n                    } catch (BundleException be) {\n                        logger.log(Logger.LOG_ERROR,\n                            \"Bundle installation from \" + location + \" failed\",\n                            be);\n                    }\n                }\n            }\n        }\n    }","id":85399,"modified_method":"/**\n     * @param bundleJar the jar file for the bundle to install\n     * @param startLevel the start level to use for this bundle\n     * @param context The <code>BundleContext<\/code> used to install the new Bundles.\n     * @param currentBundles The currently installed Bundles indexed by their\n     *            Bundle location.\n     * @param installed The list of Bundles installed by this method. Each\n     *            Bundle successfully installed is added to this list.\n     * @param startLevelService the service which sets the start level\n     */\n    private void installBundle(File bundleJar, int startLevel,\n            BundleContext context, Map<String, Bundle> currentBundles,\n            List<Bundle> installed, StartLevel startLevelService) {\n        // get the manifest for the bundle information\n        Manifest manifest = getManifest(bundleJar);\n        if (manifest == null) {\n            logger.log(Logger.LOG_ERROR, \"Ignoring \" + bundleJar\n                + \": Cannot read manifest\");\n            return; // SHORT CIRCUIT\n        }\n\n        // ensure a symbolic name in the jar file\n        String symbolicName = getBundleSymbolicName(manifest);\n        if (symbolicName == null) {\n            logger.log(Logger.LOG_ERROR, \"Ignoring \" + bundleJar\n                + \": Missing \" + Constants.BUNDLE_SYMBOLICNAME\n                + \" in manifest\");\n            return; // SHORT CIRCUIT\n        }\n\n        // check for an installed Bundle with the symbolic name\n        Bundle installedBundle = currentBundles.get(symbolicName);\n        if (ignore(installedBundle, manifest)) {\n            logger.log(Logger.LOG_INFO, \"Ignoring \" + bundleJar\n                + \": More recent version already installed\");\n            return; // SHORT CIRCUIT\n        }\n\n        // try to access the JAR file, ignore if not possible\n        InputStream ins;\n        try {\n            ins = new FileInputStream(bundleJar);\n        } catch (FileNotFoundException e) {\n            return; // SHORT CIRCUIT\n        }\n\n        if (installedBundle != null) {\n            try {\n                installedBundle.update(ins);\n                logger.log(Logger.LOG_INFO, \"Bundle \"\n                    + installedBundle.getSymbolicName()\n                    + \" updated from \" + bundleJar);\n            } catch (BundleException be) {\n                logger.log(Logger.LOG_ERROR, \"Bundle update from \"\n                    + bundleJar + \" failed\", be);\n            }\n\n        } else {\n            // install the JAR file as a bundle\n            String path = bundleJar.getPath();\n            String location = SCHEME\n                + path.substring(path.lastIndexOf('/') + 1);\n            try {\n                Bundle theBundle = context.installBundle(location, ins);\n                logger.log(Logger.LOG_INFO, \"Bundle \"\n                    + theBundle.getSymbolicName() + \" installed from \"\n                    + location);\n\n                // finally add the bundle to the list for later start\n                installed.add(theBundle);\n\n                // optionally set the start level\n                if (startLevel > 0) {\n                    startLevelService.setBundleStartLevel(theBundle,\n                        startLevel);\n                }\n\n            } catch (BundleException be) {\n                logger.log(Logger.LOG_ERROR,\n                    \"Bundle installation from \" + location + \" failed\", be);\n            }\n        }\n    }","commit_id":"2dc92a113c76619a7e0b76e9460aec6b6f1d183e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Installs any Bundles missing in the current framework instance. The\n     * Bundles are verified by the Bundle location string. All missing Bundles\n     * are first installed and then started in the order of installation. Also\n     * install all deployment packages. This installation stuff is only\n     * performed during the first startup!\n     */\n    public void start(BundleContext context) throws Exception {\n        if (!isAlreadyInstalled(context)) {\n            // register deployment package support\n            final DeploymentPackageInstaller dpi = new DeploymentPackageInstaller(\n                context, logger, resourceProvider);\n            context.addFrameworkListener(dpi);\n            context.addServiceListener(dpi, \"(\" + Constants.OBJECTCLASS + \"=\"\n                + DeploymentPackageInstaller.DEPLOYMENT_ADMIN + \")\");\n\n            // list all existing bundles\n            Bundle[] bundles = context.getBundles();\n            Map<String, Bundle> bySymbolicName = new HashMap<String, Bundle>();\n            for (int i = 0; i < bundles.length; i++) {\n                bySymbolicName.put(bundles[i].getSymbolicName(), bundles[i]);\n            }\n\n            // the start level service to set the initial start level\n            ServiceReference ref = context.getServiceReference(StartLevel.class.getName());\n            StartLevel startLevelService = (ref != null)\n                    ? (StartLevel) context.getService(ref)\n                    : null;\n\n            // install bundles\n            List<Bundle> installed = new LinkedList<Bundle>();\n\n            Iterator<String> res = resourceProvider.getChildren(PATH_BUNDLES);\n            while (res.hasNext()) {\n                String path = res.next();\n                // only consider folders\n                if (path.endsWith(\"/\")) {\n\n                    // cut off trailing slash\n                    path = path.substring(0, path.length() - 1);\n\n                    // calculate the startlevel of bundles contained\n                    int startLevel = getStartLevel(path);\n                    if (startLevel != STARTLEVEL_NONE) {\n                        installBundles(context, bySymbolicName, path,\n                            installed, startLevelService, startLevel);\n                    }\n                }\n            }\n\n            // install old-style core bundles\n            installBundles(context, bySymbolicName, PATH_CORE_BUNDLES,\n                installed, startLevelService, STARTLEVEL_CORE_BUNDLES);\n\n            // install old-style bundles\n            installBundles(context, bySymbolicName, PATH_BUNDLES, installed,\n                startLevelService, STARTLEVEL_BUNDLES);\n\n            // release the start level service\n            if (ref != null) {\n                context.ungetService(ref);\n            }\n\n            // set start levels on the bundles and start them\n            startBundles(installed);\n\n            // mark everything installed\n            markInstalled(context);\n        }\n    }","id":85400,"modified_method":"/**\n     * https://issues.apache.org/jira/browse/SLING-922\n     * Handles the initial detection and installation of bundles into\n     * the Felix OSGi running in Sling\n     *\n     * Process:\n     * 1) Copy all bundles from enclosed resources (jar/war) to\n     *   ${sling.home}/startup. This gives something like\n     *   ${sling.home}/startup/0, /1, /10, /15, ...\n     *   Existing files are only replaced if the files\n     *   enclosed in the Sling launchpad jar/war file are newer.\n     * 2) Scan ${sling.home}/startup for bundles to install\n     *   in the same way as today the enclosed resources\n     *   are scanned directly.\n     *   So you could place your bundles in that structure and get them installed\n     *   at the requested start level (0 being \"default bundle start level\").\n     */\n    public void start(BundleContext context) throws Exception {\n        // get the startup location in sling home\n        String slingHome = context.getProperty(SharedConstants.SLING_HOME);\n        File slingStartupDir = getSlingStartupDir(slingHome);\n\n        if (!isAlreadyInstalled(context, slingStartupDir)) {\n            // only run the deployment package stuff and war/jar copies when this war/jar is new/changed\n\n            // register deployment package support\n            try {\n                final DeploymentPackageInstaller dpi = new DeploymentPackageInstaller(\n                    context, logger, resourceProvider);\n                context.addFrameworkListener(dpi);\n                context.addServiceListener(dpi, \"(\" + Constants.OBJECTCLASS\n                    + \"=\" + DeploymentPackageInstaller.DEPLOYMENT_ADMIN + \")\");\n            } catch (Throwable t) {\n                logger.log(\n                    Logger.LOG_WARNING,\n                    \"Cannot register Deployment Admin support, continuing without\",\n                    t);\n            }\n\n            // see if the loading of bundles from the package is disabled\n            String dpblString = context.getProperty(SharedConstants.DISABLE_PACKAGE_BUNDLE_LOADING);\n            Boolean disablePackageBundleLoading = Boolean.valueOf(dpblString);\n\n            if (disablePackageBundleLoading) {\n                logger.log(Logger.LOG_INFO, \"Package bundle loading is disabled so no bundles will be installed from the resources location in the sling jar/war\");\n            } else {\n                // get the bundles out of the jar/war and copy them to the startup location\n                Iterator<String> resources = resourceProvider.getChildren(PATH_BUNDLES);\n                while (resources.hasNext()) {\n                    String path = resources.next();\n                    // only consider folders\n                    if (path.endsWith(\"/\")) {\n\n                        // cut off trailing slash\n                        path = path.substring(0, path.length() - 1);\n\n                        // calculate the startlevel of bundles contained\n                        int startLevel = getStartLevel(path);\n                        if (startLevel != STARTLEVEL_NONE) {\n                            copyBundles(slingStartupDir, path, startLevel);\n                        }\n                    }\n                }\n\n                // copy old-style core bundles\n                copyBundles(slingStartupDir, PATH_CORE_BUNDLES, STARTLEVEL_CORE_BUNDLES);\n\n                // copy old-style bundles\n                copyBundles(slingStartupDir, PATH_BUNDLES, STARTLEVEL_BUNDLES);\n\n                // done with copying at this point\n            }\n\n            // get the set of all existing (installed) bundles by symbolic name\n            Bundle[] bundles = context.getBundles();\n            Map<String, Bundle> bySymbolicName = new HashMap<String, Bundle>();\n            for (int i = 0; i < bundles.length; i++) {\n                bySymbolicName.put(bundles[i].getSymbolicName(), bundles[i]);\n            }\n\n            // holds the bundles we install during this processing\n            List<Bundle> installed = new LinkedList<Bundle>();\n\n            // get all bundles from the startup location and install them\n            installBundles(slingStartupDir, context, bySymbolicName, installed);\n\n            // start all the newly installed bundles (existing bundles are not started if they are stopped)\n            startBundles(installed);\n\n            // mark everything installed\n            markInstalled(context, slingStartupDir);\n        }\n    }","commit_id":"2dc92a113c76619a7e0b76e9460aec6b6f1d183e","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the <i>Bundle-SymbolicName<\/i> header from the given manifest or\n     * <code>null<\/code> if no such header exists.\n     * <p>\n     * Note that bundles are not allowed to have no symbolic name any more.\n     * Therefore a bundle without a symbolic name header should not be\n     * installed.\n     * \n     * @param manifest The Manifest from which to extract the header.\n     */\n    private String getBundleSymbolicName(Manifest manifest) {\n        return manifest.getMainAttributes().getValue(\n            Constants.BUNDLE_SYMBOLICNAME);\n    }","id":85401,"modified_method":"/**\n     * Returns the <i>Bundle-SymbolicName<\/i> header from the given manifest or\n     * <code>null<\/code> if no such header exists.\n     * <p>\n     * Note that bundles are not allowed to have no symbolic name any more.\n     * Therefore a bundle without a symbolic name header should not be\n     * installed.\n     *\n     * @param manifest The Manifest from which to extract the header.\n     */\n    String getBundleSymbolicName(Manifest manifest) {\n        return manifest.getMainAttributes().getValue(\n            Constants.BUNDLE_SYMBOLICNAME);\n    }","commit_id":"2dc92a113c76619a7e0b76e9460aec6b6f1d183e","url":"https://github.com/apache/sling"},{"original_method":"/**\n\t * @see wicket.request.compound.IExceptionResponseStrategy#respond(wicket.RequestCycle,\n\t *      java.lang.RuntimeException)\n\t */\n\tpublic final void respond(final RequestCycle requestCycle, final RuntimeException e)\n\t{\n\t\t// If application doesn't want debug info showing up for users\n\t\tfinal Session session = requestCycle.getSession();\n\t\tfinal Application application = session.getApplication();\n\t\tfinal IExceptionSettings settings = application.getExceptionSettings();\n\t\tfinal Page responsePage = requestCycle.getResponsePage();\n\n\t\tPage override = onRuntimeException(responsePage, e);\n\t\tif (override != null)\n\t\t{\n\t\t\trequestCycle.setResponsePage(override);\n\t\t}\n\t\telse if (e instanceof AuthorizationException)\n\t\t{\n\t\t\t// are authorization exceptions always thrown before the real\n\t\t\t// render?\n\t\t\t// else we need to make a page (see below) or set it hard to a\n\t\t\t// redirect.\n\t\t\tClass<? extends Page> accessDeniedPageClass = application.getApplicationSettings()\n\t\t\t\t\t.getAccessDeniedPage();\n\n\t\t\tthrow new RestartResponseAtInterceptPageException(accessDeniedPageClass);\n\t\t}\n\t\telse if (settings.getUnexpectedExceptionDisplay() != UnexpectedExceptionDisplay.SHOW_NO_EXCEPTION_PAGE)\n\t\t{\n\t\t\tClass<? extends Page> internalErrorPageClass = application.getApplicationSettings()\n\t\t\t\t\t.getInternalErrorPage();\n\t\t\tClass responseClass = responsePage != null ? responsePage.getClass() : null;\n\n\t\t\tif (responseClass != internalErrorPageClass\n\t\t\t\t\t&& settings.getUnexpectedExceptionDisplay() == UnexpectedExceptionDisplay.SHOW_INTERNAL_ERROR_PAGE)\n\t\t\t{\n\t\t\t\t// Show internal error page\n\t\t\t\tfinal IPageFactory pageFactory;\n\t\t\t\tIRequestTarget requestTarget = requestCycle.getRequestTarget();\n\t\t\t\tif (requestTarget instanceof IPageRequestTarget)\n\t\t\t\t{\n\t\t\t\t\tpageFactory = session.getPageFactory(((IPageRequestTarget)requestTarget)\n\t\t\t\t\t\t\t.getPage());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpageFactory = session.getPageFactory();\n\t\t\t\t}\n\t\t\t\trequestCycle.setResponsePage(pageFactory.newPage(internalErrorPageClass));\n\t\t\t}\n\t\t\telse if (responseClass != ExceptionErrorPage.class)\n\t\t\t{\n\t\t\t\t// Show full details\n\t\t\t\trequestCycle.setResponsePage(new ExceptionErrorPage(e, responsePage));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up while we're ahead!\n\t\t\t\tthrow new WicketRuntimeException(\"Internal Error: Could not render error page \"\n\t\t\t\t\t\t+ internalErrorPageClass, e);\n\t\t\t}\n\t\t}\n\n\t\t// We generally want to redirect the response because we\n\t\t// were in the middle of rendering and the page may end up\n\t\t// looking like spaghetti otherwise. If responsePage == null,\n\t\t// than the Page constructor failed and we don't need to\n\t\t// redirect and this allows to reload the page when the\n\t\t// bug has been fixed.\n\t\tif (responsePage != null)\n\t\t{\n\t\t\trequestCycle.setRedirect(true);\n\t\t}\n\t}","id":85402,"modified_method":"/**\n\t * @see wicket.request.compound.IExceptionResponseStrategy#respond(wicket.RequestCycle,\n\t *      java.lang.RuntimeException)\n\t */\n\tpublic final void respond(final RequestCycle requestCycle, final RuntimeException e)\n\t{\n\t\t// If application doesn't want debug info showing up for users\n\t\tfinal Session session = requestCycle.getSession();\n\t\tfinal Application application = session.getApplication();\n\t\tfinal IExceptionSettings settings = application.getExceptionSettings();\n\t\tfinal Page responsePage = requestCycle.getResponsePage();\n\n\t\tPage override = onRuntimeException(responsePage, e);\n\t\tif (override != null)\n\t\t{\n\t\t\t// we do not want to redirect - we want to inline the error output\n\t\t\t// and preserve the url so when the refresh button is pressed we\n\t\t\t// rerun the code that caused the error\n\t\t\trequestCycle.setRedirect(false);\n\n\t\t\tthrow new RestartResponseException(override);\n\t\t}\n\t\telse if (e instanceof AuthorizationException)\n\t\t{\n\t\t\t// are authorization exceptions always thrown before the real render?\n\t\t\t// else we need to make a page (see below) or set it hard to a redirect.\n\t\t\tClass<? extends Page> accessDeniedPageClass = application.getApplicationSettings().getAccessDeniedPage();\n\n\t\t\tthrow new RestartResponseAtInterceptPageException(accessDeniedPageClass);\n\t\t}\n\t\telse if (settings.getUnexpectedExceptionDisplay() != UnexpectedExceptionDisplay.SHOW_NO_EXCEPTION_PAGE)\n\t\t{\n\t\t\t// we do not want to redirect - we want to inline the error output\n\t\t\t// and preserve the url so when the refresh button is pressed we\n\t\t\t// rerun the code that caused the error\n\t\t\trequestCycle.setRedirect(false);\n\t\t\t\n\t\t\t// figure out which error page to show\n\t\t\tClass<? extends Page>  internalErrorPageClass = application.getApplicationSettings().getInternalErrorPage();\t\t\t\n\t\t\tClass responseClass = responsePage != null ? responsePage.getClass() : null;\n\n\t\t\tif (responseClass != internalErrorPageClass\n\t\t\t\t\t&& settings.getUnexpectedExceptionDisplay() == UnexpectedExceptionDisplay.SHOW_INTERNAL_ERROR_PAGE)\n\t\t\t{\n\t\t\t\tthrow new RestartResponseException(internalErrorPageClass);\n\t\t\t}\n\t\t\telse if (responseClass != ExceptionErrorPage.class)\n\t\t\t{\n\t\t\t\t// Show full details\n\t\t\t\tthrow new RestartResponseException(new ExceptionErrorPage(e, responsePage));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up while we're ahead!\n\t\t\t\tthrow new WicketRuntimeException(\"Internal Error: Could not render error page \"\n\t\t\t\t\t\t+ internalErrorPageClass, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"07af9dced6863f736105a8aed309f3a84a64bf5b","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Verifies page factory bubbles AbortAndRespondException\n\t */\n\tpublic void testAbortAndRespondContract()\n\t{\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage1.class);\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage2.class);\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage2.class, new PageParameters());\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage3.class);\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage3.class, new PageParameters());\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\t}","id":85403,"modified_method":"/**\n\t * Verifies page factory bubbles AbortAndRespondException\n\t */\n\tpublic void testAbortAndRespondContract()\n\t{\n\t\tapplication.setupRequestAndResponse();\n\t\tapplication.createRequestCycle();\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage1.class);\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage2.class);\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage2.class, new PageParameters());\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage3.class);\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tpageFactory.newPage(AbortAndRespondPage3.class, new PageParameters());\n\t\t\tfail();\n\t\t}\n\t\tcatch (AbstractRestartResponseException e)\n\t\t{\n\t\t\t// noop\n\t\t}\n\t}","commit_id":"07af9dced6863f736105a8aed309f3a84a64bf5b","url":"https://github.com/apache/wicket"},{"original_method":"private boolean resolveFromModule(ClassNode type, boolean testModuleImports) {\n        final String name = type.getName();\n        ModuleNode module = currentClass.getModule();\n        if (module == null) return false;\n\n        Object res = module.resolveCache.get (name);\n        if (res == NONE)\n          return false;\n\n        if (res != null) {\n            type.setRedirect((ClassNode) res);\n            return true;\n        }\n\n        boolean newNameUsed = false;\n        // we add a package if there is none yet and the module has one. But we\n        // do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage\n        // hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.\n        // but since the prefix may have them and the code there does ignore that\n        // fact. We check here for ConstructedClassWithPackage.\n        if (!type.hasPackageName() && module.hasPackageName() && !(type instanceof ConstructedClassWithPackage)) {\n            type.setName(module.getPackageName() + name);\n            newNameUsed = true;\n        }\n        // look into the module node if there is a class with that name\n        List moduleClasses = module.getClasses();\n        for (Iterator iter = moduleClasses.iterator(); iter.hasNext();) {\n            ClassNode mClass = (ClassNode) iter.next();\n            if (mClass.getName().equals(type.getName())) {\n                if (mClass != type) {\n                    type.setRedirect(mClass);\n                }\n                module.resolveCache.put(name, type.redirect());\n                return true;\n            }\n        }\n        if (newNameUsed) type.setName(name);\n\n        if (testModuleImports) {\n            if (resolveAliasFromModule(type)) {\n                module.resolveCache.put(name, type.redirect());\n                return true;\n            }\n\n            if (module.hasPackageName()) {\n                // check package this class is defined in. The usage of ConstructedClassWithPackage here\n                // means, that the module package will not be involved when the\n                // compiler tries to find an inner class.\n                ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(module.getPackageName(),name);\n                if (resolve(tmp, false, false, false)) {\n                    type.setRedirect(tmp.redirect());\n                    module.resolveCache.put(name, type.redirect());\n                    return true;\n                }\n            }\n\n            // check module node imports packages\n            List packages = module.getImportPackages();\n            for (Iterator iter = packages.iterator(); iter.hasNext();) {\n                String packagePrefix = (String) iter.next();\n                // We limit the inner class lookups here by using ConstructedClassWithPackage.\n                // This way only the name will change, the packagePrefix will\n                // not be included in the lookup. The case where the\n                // packagePrefix is really a class is handled else where.\n                ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(packagePrefix,name);\n                if (resolve(tmp, false, false, true)) {\n                    ambiguousClass(type, tmp, name);\n                    type.setRedirect(tmp.redirect());\n                    module.resolveCache.put(name, type.redirect());\n                    return true;\n                }\n            }\n        }\n\n        if (type.hasPackageName())\n          module.resolveCache.put(name, NONE);\n\n        return false;\n    }","id":85404,"modified_method":"private boolean resolveFromModule(ClassNode type, boolean testModuleImports) {\n        String name = type.getName();\n        ModuleNode module = currentClass.getModule();\n        if (module == null) return false;\n\n        boolean newNameUsed = false;\n        // we add a package if there is none yet and the module has one. But we\n        // do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage\n        // hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.\n        // but since the prefix may have them and the code there does ignore that\n        // fact. We check here for ConstructedClassWithPackage.\n        if (!type.hasPackageName() && module.hasPackageName() && !(type instanceof ConstructedClassWithPackage)) {\n            type.setName(module.getPackageName() + name);\n            newNameUsed = true;\n        }\n        // look into the module node if there is a class with that name\n        List moduleClasses = module.getClasses();\n        for (Iterator iter = moduleClasses.iterator(); iter.hasNext();) {\n            ClassNode mClass = (ClassNode) iter.next();\n            if (mClass.getName().equals(type.getName())) {\n                if (mClass != type) type.setRedirect(mClass);\n                return true;\n            }\n        }\n        if (newNameUsed) type.setName(name);\n\n        if (testModuleImports) {\n            if (resolveAliasFromModule(type)) return true;\n\n            if (module.hasPackageName()) {\n                // check package this class is defined in. The usage of ConstructedClassWithPackage here\n                // means, that the module package will not be involved when the\n                // compiler tries to find an inner class.\n                ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(module.getPackageName(),name);\n                if (resolve(tmp, false, false, false)) {\n                    type.setRedirect(tmp.redirect());\n                    return true;\n                }\n            }\n\n            // check module node imports packages\n            List packages = module.getImportPackages();\n            for (Iterator iter = packages.iterator(); iter.hasNext();) {\n                String packagePrefix = (String) iter.next();\n                // We limit the inner class lookups here by using ConstructedClassWithPackage.\n                // This way only the name will change, the packagePrefix will\n                // not be included in the lookup. The case where the\n                // packagePrefix is really a class is handled else where.\n                ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(packagePrefix,name);\n                if (resolve(tmp, false, false, true)) {\n                    ambiguousClass(type, tmp, name);\n                    type.setRedirect(tmp.redirect());\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"8e98b30f14a83afafad90b37830e93ddd8e7835e","url":"https://github.com/apache/groovy"},{"original_method":"private boolean resolveFromDefaultImports(ClassNode type, boolean testDefaultImports) {\n        // test default imports\n        testDefaultImports &= !type.hasPackageName();\n        if (testDefaultImports) {\n\n            String name = type.getName();\n            final Object res = defaults.get(name);\n            if (res == NONE)\n              return false;\n\n            if (res == null) {\n                for (int i = 0, size = DEFAULT_IMPORTS.length; i < size; i++) {\n                    String packagePrefix = DEFAULT_IMPORTS[i];\n                    // We limit the inner class lookups here by using ConstructedClassWithPackage.\n                    // This way only the name will change, the packagePrefix will\n                    // not be included in the lookup. The case where the\n                    // packagePrefix is really a class is handled else where.\n                    // WARNING: This code does not expect a class that has an static\n                    //          inner class in DEFAULT_IMPORTS\n                    ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(packagePrefix,name);\n                    if (resolve(tmp, false, false, false)) {\n                        type.setRedirect(tmp.redirect());\n                        defaults.put(name, tmp.redirect());\n                        return true;\n                    }\n                }\n                defaults.put(name, NONE);\n            }\n            else {\n                type.setRedirect((ClassNode) res);\n                return true;\n            }\n        }\n        return false;\n    }","id":85405,"modified_method":"private boolean resolveFromDefaultImports(ClassNode type, boolean testDefaultImports) {\n        // test default imports\n        testDefaultImports &= !type.hasPackageName();\n        if (testDefaultImports) {\n            for (int i = 0, size = DEFAULT_IMPORTS.length; i < size; i++) {\n                String packagePrefix = DEFAULT_IMPORTS[i];\n                String name = type.getName();\n                // We limit the inner class lookups here by using ConstructedClassWithPackage.\n                // This way only the name will change, the packagePrefix will\n                // not be included in the lookup. The case where the\n                // packagePrefix is really a class is handled else where.\n                // WARNING: This code does not expect a class that has an static\n                //          inner class in DEFAULT_IMPORTS\n                ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(packagePrefix,name);\n                if (resolve(tmp, false, false, false)) {\n                    type.setRedirect(tmp.redirect());\n                    return true;\n                }\n            }\n            String name = type.getName();\n            if (name.equals(\"BigInteger\")) {\n                type.setRedirect(ClassHelper.BigInteger_TYPE);\n                return true;\n            } else if (name.equals(\"BigDecimal\")) {\n                type.setRedirect(ClassHelper.BigDecimal_TYPE);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"8e98b30f14a83afafad90b37830e93ddd8e7835e","url":"https://github.com/apache/groovy"},{"original_method":"protected Expression transformDeclarationExpression(DeclarationExpression de) {\n        Expression oldLeft = de.getLeftExpression();\n        Expression left = transform(oldLeft);\n        if (left instanceof ClassExpression) {\n            ClassExpression ce = (ClassExpression) left;\n            addError(\"you tried to assign a value to the class \" + ce.getType().getName(), oldLeft);\n            return de;\n        }\n        de.setLeftExpression(left);\n        de.setRightExpression(transform(de.getRightExpression()));\n        return de;\n    }","id":85406,"modified_method":"protected Expression transformDeclarationExpression(DeclarationExpression de) {\n        Expression oldLeft = de.getLeftExpression();\n        Expression left = transform(oldLeft);\n        if (left instanceof ClassExpression) {\n            ClassExpression ce = (ClassExpression) left;\n            addError(\"you tried to assign a value to the class \" + ce.getType().getName(), oldLeft);\n            return de;\n        }\n        Expression right = transform(de.getRightExpression());\n        if (right == de.getRightExpression()) return de;\n        DeclarationExpression newDeclExpr = new DeclarationExpression(left, de.getOperation(), right);\n        newDeclExpr.setSourcePosition(de);\n        return newDeclExpr;\n    }","commit_id":"8e98b30f14a83afafad90b37830e93ddd8e7835e","url":"https://github.com/apache/groovy"},{"original_method":"protected Expression transformMethodCallExpression(MethodCallExpression mce) {\n        mce.setArguments(transform(mce.getArguments()));\n        mce.setMethod(transform(mce.getMethod()));\n        mce.setObjectExpression(transform(mce.getObjectExpression()));\n        return mce;\n    }","id":85407,"modified_method":"protected Expression transformMethodCallExpression(MethodCallExpression mce) {\n        Expression args = transform(mce.getArguments());\n        Expression method = transform(mce.getMethod());\n        Expression object = transform(mce.getObjectExpression());\n\n        MethodCallExpression result = new MethodCallExpression(object, method, args);\n        result.setSafe(mce.isSafe());\n        result.setImplicitThis(mce.isImplicitThis());\n        result.setSpreadSafe(mce.isSpreadSafe());\n        result.setSourcePosition(mce);\n        return result;\n    }","commit_id":"8e98b30f14a83afafad90b37830e93ddd8e7835e","url":"https://github.com/apache/groovy"},{"original_method":"/**\n\t * @see wicket.request.compound.IExceptionResponseStrategy#respond(wicket.RequestCycle,\n\t *      java.lang.RuntimeException)\n\t */\n\tpublic final void respond(final RequestCycle requestCycle, final RuntimeException e)\n\t{\n\t\t// If application doesn't want debug info showing up for users\n\t\tfinal Session session = requestCycle.getSession();\n\t\tfinal Application application = session.getApplication();\n\t\tfinal IExceptionSettings settings = application.getExceptionSettings();\n\t\tfinal Page responsePage = requestCycle.getResponsePage();\n\n\t\tPage override = onRuntimeException(responsePage, e);\n\t\tif (override != null)\n\t\t{\n\t\t\trequestCycle.setResponsePage(override);\n\t\t}\n\t\telse if(e instanceof AuthorizationException)\n\t\t{\n\t\t\t// are authorization exceptions always thrown before the real render?\n\t\t\t// else we need to make a page (see below) or set it hard to a redirect.\n\t\t\tClass accessDeniedPageClass = application.getApplicationSettings().getAccessDeniedPage();\n\n\t\t\tthrow new RestartResponseAtInterceptPageException(accessDeniedPageClass);\n\t\t}\n\t\telse if (settings.getUnexpectedExceptionDisplay() != IExceptionSettings.SHOW_NO_EXCEPTION_PAGE)\n\t\t{\n\t\t\tClass internalErrorPageClass = application.getApplicationSettings().getInternalErrorPage();\n\t\t\tClass responseClass = responsePage != null ? responsePage.getClass() : null;\n\n\t\t\tif (responseClass != internalErrorPageClass\n\t\t\t\t\t&& settings.getUnexpectedExceptionDisplay() == IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE)\n\t\t\t{\n\t\t\t\t// Show internal error page\n\t\t\t\tfinal IPageFactory pageFactory;\n\t\t\t\tIRequestTarget requestTarget = requestCycle.getRequestTarget();\n\t\t\t\tif (requestTarget instanceof IPageRequestTarget)\n\t\t\t\t{\n\t\t\t\t\tpageFactory = session.getPageFactory(((IPageRequestTarget)requestTarget)\n\t\t\t\t\t\t\t.getPage());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpageFactory = session.getPageFactory();\n\t\t\t\t}\n\t\t\t\trequestCycle.setResponsePage(pageFactory.newPage(internalErrorPageClass));\n\t\t\t}\n\t\t\telse if (responseClass != ExceptionErrorPage.class)\n\t\t\t{\n\t\t\t\t// Show full details\n\t\t\t\trequestCycle.setResponsePage(new ExceptionErrorPage(e, responsePage));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up while we're ahead!\n\t\t\t\tthrow new WicketRuntimeException(\"Internal Error: Could not render error page \"\n\t\t\t\t\t\t+ internalErrorPageClass, e);\n\t\t\t}\n\t\t}\n\n\t\t// We generally want to redirect the response because we\n\t\t// were in the middle of rendering and the page may end up\n\t\t// looking like spaghetti otherwise. If responsePage == null,\n\t\t// than the Page constructor failed and we don't need to\n\t\t// redirect and this allows to reload the page when the\n\t\t// bug has been fixed.\n\t\tif (responsePage != null)\n\t\t{\n\t\t\trequestCycle.setRedirect(true);\n\t\t}\n\t}","id":85408,"modified_method":"/**\n\t * @see wicket.request.compound.IExceptionResponseStrategy#respond(wicket.RequestCycle,\n\t *      java.lang.RuntimeException)\n\t */\n\tpublic final void respond(final RequestCycle requestCycle, final RuntimeException e)\n\t{\n\t\t// If application doesn't want debug info showing up for users\n\t\tfinal Session session = requestCycle.getSession();\n\t\tfinal Application application = session.getApplication();\n\t\tfinal IExceptionSettings settings = application.getExceptionSettings();\n\t\tfinal Page responsePage = requestCycle.getResponsePage();\n\n\t\tPage override = onRuntimeException(responsePage, e);\n\t\tif (override != null)\n\t\t{\n\t\t\tthrow new RestartResponseException(override);\n\t\t}\n\t\telse if(e instanceof AuthorizationException)\n\t\t{\n\t\t\t// are authorization exceptions always thrown before the real render?\n\t\t\t// else we need to make a page (see below) or set it hard to a redirect.\n\t\t\tClass accessDeniedPageClass = application.getApplicationSettings().getAccessDeniedPage();\n\n\t\t\tthrow new RestartResponseAtInterceptPageException(accessDeniedPageClass);\n\t\t}\n\t\telse if (settings.getUnexpectedExceptionDisplay() != IExceptionSettings.SHOW_NO_EXCEPTION_PAGE)\n\t\t{\n\t\t\t// we do not want to redirect - we want to inline the error output\n\t\t\t// and preserve the url so when the refresh button is pressed we\n\t\t\t// rerun the code that caused the error\n\t\t\trequestCycle.setRedirect(false);\n\t\t\t\n\t\t\t// figure out which error page to show\n\t\t\tClass internalErrorPageClass = application.getApplicationSettings().getInternalErrorPage();\t\t\t\n\t\t\tClass responseClass = responsePage != null ? responsePage.getClass() : null;\n\n\t\t\tif (responseClass != internalErrorPageClass\n\t\t\t\t\t&& settings.getUnexpectedExceptionDisplay() == IExceptionSettings.SHOW_INTERNAL_ERROR_PAGE)\n\t\t\t{\n\t\t\t\tthrow new RestartResponseException(internalErrorPageClass);\n\t\t\t}\n\t\t\telse if (responseClass != ExceptionErrorPage.class)\n\t\t\t{\n\t\t\t\t// Show full details\n\t\t\t\tthrow new RestartResponseException(new ExceptionErrorPage(e, responsePage));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up while we're ahead!\n\t\t\t\tthrow new WicketRuntimeException(\"Internal Error: Could not render error page \"\n\t\t\t\t\t\t+ internalErrorPageClass, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c64c1f7957c617ac4ab65017224ea6bfafe269c4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n   * Preserve attribute on file matching that of the file status being sent\n   * as argument. Barring the block size, all the other attributes are preserved\n   * by this function\n   *\n   * @param targetFS - File system\n   * @param path - Path that needs to preserve original file status\n   * @param srcFileStatus - Original file status\n   * @param attributes - Attribute set that needs to be preserved\n   * @param preserveRawXattrs if true, raw.* xattrs should be preserved\n   * @throws IOException - Exception if any (particularly relating to group/owner\n   *                       change or any transient error)\n   */\n  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet<FileAttribute> attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    FileStatus targetFileStatus = targetFS.getFileStatus(path);\n    String group = targetFileStatus.getGroup();\n    String user = targetFileStatus.getOwner();\n    boolean chown = false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List<AclEntry> srcAcl = srcFileStatus.getAclEntries();\n      List<AclEntry> targetAcl = getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn't preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !=\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) &&\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs = attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS =\n          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n      Map<String, byte[]> srcXAttrs = srcFileStatus.getXAttrs();\n      Map<String, byte[]> targetXAttrs = getXAttrs(targetFS, path);\n      if (srcXAttrs != null && !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry<String, byte[]> entry : srcXAttrs.entrySet()) {\n          String xattrName = entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) && !targetFileStatus.isDirectory() &&\n        (srcFileStatus.getReplication() != targetFileStatus.getReplication())) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) &&\n        !group.equals(srcFileStatus.getGroup())) {\n      group = srcFileStatus.getGroup();\n      chown = true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) &&\n        !user.equals(srcFileStatus.getOwner())) {\n      user = srcFileStatus.getOwner();\n      chown = true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }","id":85409,"modified_method":"/**\n   * Preserve attribute on file matching that of the file status being sent\n   * as argument. Barring the block size, all the other attributes are preserved\n   * by this function\n   *\n   * @param targetFS - File system\n   * @param path - Path that needs to preserve original file status\n   * @param srcFileStatus - Original file status\n   * @param attributes - Attribute set that needs to be preserved\n   * @param preserveRawXattrs if true, raw.* xattrs should be preserved\n   * @throws IOException - Exception if any (particularly relating to group/owner\n   *                       change or any transient error)\n   */\n  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet<FileAttribute> attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    // If not preserving anything from FileStatus, don't bother fetching it.\n    FileStatus targetFileStatus = attributes.isEmpty() ? null :\n        targetFS.getFileStatus(path);\n    String group = targetFileStatus == null ? null :\n        targetFileStatus.getGroup();\n    String user = targetFileStatus == null ? null :\n        targetFileStatus.getOwner();\n    boolean chown = false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List<AclEntry> srcAcl = srcFileStatus.getAclEntries();\n      List<AclEntry> targetAcl = getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn't preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !=\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) &&\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs = attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS =\n          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n      Map<String, byte[]> srcXAttrs = srcFileStatus.getXAttrs();\n      Map<String, byte[]> targetXAttrs = getXAttrs(targetFS, path);\n      if (srcXAttrs != null && !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry<String, byte[]> entry : srcXAttrs.entrySet()) {\n          String xattrName = entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) && !targetFileStatus.isDirectory() &&\n        (srcFileStatus.getReplication() != targetFileStatus.getReplication())) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) &&\n        !group.equals(srcFileStatus.getGroup())) {\n      group = srcFileStatus.getGroup();\n      chown = true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) &&\n        !user.equals(srcFileStatus.getOwner())) {\n      user = srcFileStatus.getOwner();\n      chown = true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }","commit_id":"c918286b17e7f2a64735d0c972a8dd749e0bf6c4","url":"https://github.com/apache/hadoop"},{"original_method":"protected void updateLayoutSetPrototype(Layout layout, Date modifiedDate) {\n\t\ttry {\n\t\t\tGroup group = layout.getGroup();\n\n\t\t\tif (!group.isLayoutSetPrototype()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\tlayoutSetPrototype.setModifiedDate(modifiedDate);\n\n\t\t\tLayoutSetPrototypeUtil.update(layoutSetPrototype);\n\n\t\t\tLayoutSet layoutSet = layoutSetPrototype.getLayoutSet();\n\n\t\t\tlayoutSet.setModifiedDate(layout.getModifiedDate());\n\n\t\t\tUnicodeProperties settingsProperties =\n\t\t\t\tlayoutSet.getSettingsProperties();\n\n\t\t\tsettingsProperties.remove(Sites.MERGE_FAIL_COUNT);\n\n\t\t\tLayoutSetLocalServiceUtil.updateLayoutSet(layoutSet);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":85410,"modified_method":"protected void updateLayoutSetPrototype(Layout layout, Date modifiedDate) {\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tGroup group;\n\n\t\ttry {\n\t\t\t group = layout.getGroup();\n\n\t\t\tif (!group.isLayoutSetPrototype()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\tlayoutSetPrototype.setModifiedDate(modifiedDate);\n\n\t\t\tLayoutSetPrototypeUtil.update(layoutSetPrototype);\n\n\t\t\tLayoutSet layoutSet = layoutSetPrototype.getLayoutSet();\n\n\t\t\tlayoutSet.setModifiedDate(layout.getModifiedDate());\n\n\t\t\tUnicodeProperties settingsProperties =\n\t\t\t\tlayoutSet.getSettingsProperties();\n\n\t\t\tsettingsProperties.remove(Sites.MERGE_FAIL_COUNT);\n\n\t\t\tLayoutSetLocalServiceUtil.updateLayoutSet(layoutSet);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"e61bdc7c38687d96d89728eb105c0be3bde05839","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void updateLayoutSetPrototype(\n\t\tLayoutSet layoutSet, Date modifiedDate) {\n\n\t\ttry {\n\t\t\tGroup group = layoutSet.getGroup();\n\n\t\t\tif (!group.isLayoutSetPrototype()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\tlayoutSetPrototype.setModifiedDate(modifiedDate);\n\n\t\t\tUnicodeProperties settingsProperties =\n\t\t\t\tlayoutSet.getSettingsProperties();\n\n\t\t\tsettingsProperties.remove(\"merge-fail-count\");\n\n\t\t\tLayoutSetPrototypeUtil.update(layoutSetPrototype);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":85411,"modified_method":"protected void updateLayoutSetPrototype(\n\t\tLayoutSet layoutSet, Date modifiedDate) {\n\n\t\tif (layoutSet == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tGroup group;\n\n\t\ttry {\n\t\t\tgroup = layoutSet.getGroup();\n\n\t\t\tif (!group.isLayoutSetPrototype()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch(PortalException pe) {\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\t\tLayoutSetPrototypeLocalServiceUtil.getLayoutSetPrototype(\n\t\t\t\t\tgroup.getClassPK());\n\n\t\t\tlayoutSetPrototype.setModifiedDate(modifiedDate);\n\n\t\t\tUnicodeProperties settingsProperties =\n\t\t\t\tlayoutSet.getSettingsProperties();\n\n\t\t\tsettingsProperties.remove(\"merge-fail-count\");\n\n\t\t\tLayoutSetPrototypeUtil.update(layoutSetPrototype);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","commit_id":"7e5d8c29123816a6421b5eb7a2f6df97c6ff988a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public long getTotalStatusCode(int statusCode) {\n        Long count = dataStore.getStatusCodeCounts().get(statusCode);\n\n        if (count != null) {\n            return count;\n        } else {\n            return LONG_ZERO;\n        }\n    }","id":85412,"modified_method":"@Override\n    public long getTotalStatusCode(int statusCode) {\n\n       Long count = LONG_ZERO;\n       \n       for(Integer code: dataStore.getStatusCodeCounts().keySet()){\n          \n          if(code%statusCode < 100){\n             count += dataStore.getStatusCodeCounts().get(code);\n          }\n       }\n       \n       return count;\n    }","commit_id":"8ffe0800923cd2f5e9d9c57f0403fa80a73bbfc4","url":"https://github.com/rackerlabs/repose"},{"original_method":"public void removeSessionSubscriptions(SessionSubscriptionInfo info) {\n\t\t\tfor (String destination : info.getDestinations()) {\n\t\t\t\tunmapFromDestination(destination, info);\n\t\t\t}\n\t\t}","id":85413,"modified_method":"public void removeSessionSubscriptions(SessionSubscriptionInfo info) {\n\t\t\tsynchronized(this.monitor) {\n\t\t\t\tfor (String destination : info.getDestinations()) {\n\t\t\t\t\tfor (String cachedDestination : this.subscriptionsByDestination.keySet()) {\n\t\t\t\t\t\tif (this.pathMatcher.match(destination, cachedDestination)) {\n\t\t\t\t\t\t\tMultiValueMap<String, String> map = this.subscriptionsByDestination.get(cachedDestination);\n\t\t\t\t\t\t\tmap.remove(info.getSessionId());\n\t\t\t\t\t\t\tif (map.isEmpty()) {\n\t\t\t\t\t\t\t\tthis.subscriptionsByDestination.remove(cachedDestination);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"1054080b24d26ceb7d079a2a8089b062198d4223","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {\n\t\tMultiValueMap<String,String> result = this.destinationCache.getSubscriptions(destination);\n\t\tif (result.isEmpty()) {\n\t\t\tresult = new LinkedMultiValueMap<String, String>();\n\t\t\tfor (SessionSubscriptionInfo info : this.subscriptionRegistry.getAllSubscriptions()) {\n\t\t\t\tfor (String destinationPattern : info.getDestinations()) {\n\t\t\t\t\tif (this.pathMatcher.match(destinationPattern, destination)) {\n\t\t\t\t\t\tfor (String subscriptionId : info.getSubscriptions(destinationPattern)) {\n\t\t\t\t\t\t\tresult.add(info.sessionId, subscriptionId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":85414,"modified_method":"@Override\n\tprotected MultiValueMap<String, String> findSubscriptionsInternal(String destination, Message<?> message) {\n\t\tMultiValueMap<String,String> result;\n\t\tif (this.destinationCache.isCachedDestination(destination)) {\n\t\t\tresult = this.destinationCache.getSubscriptions(destination);\n\t\t}\n\t\telse {\n\t\t\tresult = new LinkedMultiValueMap<String, String>();\n\t\t\tfor (SessionSubscriptionInfo info : this.subscriptionRegistry.getAllSubscriptions()) {\n\t\t\t\tfor (String destinationPattern : info.getDestinations()) {\n\t\t\t\t\tif (this.pathMatcher.match(destinationPattern, destination)) {\n\t\t\t\t\t\tfor (String subscriptionId : info.getSubscriptions(destinationPattern)) {\n\t\t\t\t\t\t\tresult.add(info.sessionId, subscriptionId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!result.isEmpty()) {\n\t\t\t\tthis.destinationCache.addSubscriptions(destination, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"1054080b24d26ceb7d079a2a8089b062198d4223","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public MultiValueMap<String, String> getSubscriptions(String destination) {\n\t\t\tMultiValueMap<String, String> result = new LinkedMultiValueMap<String, String>();\n\t\t\tSet<SessionSubscriptionInfo> infos = this.subscriptionsByDestination.get(destination);\n\t\t\tif (infos != null) {\n\t\t\t\tfor (SessionSubscriptionInfo info : infos) {\n\t\t\t\t\tSet<String> subscriptions = info.getSubscriptions(destination);\n\t\t\t\t\tif (subscriptions != null) {\n\t\t\t\t\t\tfor (String subscription : subscriptions) {\n\t\t\t\t\t\t\tresult.add(info.getSessionId(), subscription);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}","id":85415,"modified_method":"public MultiValueMap<String, String> getSubscriptions(String destination) {\n\t\t\treturn this.subscriptionsByDestination.get(destination);\n\t\t}","commit_id":"1054080b24d26ceb7d079a2a8089b062198d4223","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void mapToDestination(String destination, SessionSubscriptionInfo info) {\n\t\t\tsynchronized(this.monitor) {\n\t\t\t\tSet<SessionSubscriptionInfo> registrations = this.subscriptionsByDestination.get(destination);\n\t\t\t\tif (registrations == null) {\n\t\t\t\t\tregistrations = new CopyOnWriteArraySet<SessionSubscriptionInfo>();\n\t\t\t\t\tthis.subscriptionsByDestination.put(destination, registrations);\n\t\t\t\t}\n\t\t\t\tregistrations.add(info);\n\t\t\t}\n\t\t}","id":85416,"modified_method":"public void mapToDestination(String destination, String sessionId, String subsId) {\n\t\t\tsynchronized(this.monitor) {\n\t\t\t\tfor (String cachedDestination : this.subscriptionsByDestination.keySet()) {\n\t\t\t\t\tif (this.pathMatcher.match(destination, cachedDestination)) {\n\t\t\t\t\t\tMultiValueMap<String, String> registrations = this.subscriptionsByDestination.get(cachedDestination);\n\t\t\t\t\t\tif (registrations == null) {\n\t\t\t\t\t\t\tregistrations = new LinkedMultiValueMap<String, String>();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregistrations.add(sessionId, subsId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"1054080b24d26ceb7d079a2a8089b062198d4223","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void unmapFromDestination(String destination, SessionSubscriptionInfo info) {\n\t\t\tsynchronized(this.monitor) {\n\t\t\t\tSet<SessionSubscriptionInfo> infos = this.subscriptionsByDestination.get(destination);\n\t\t\t\tif (infos != null) {\n\t\t\t\t\tinfos.remove(info);\n\t\t\t\t\tif (infos.isEmpty()) {\n\t\t\t\t\t\tthis.subscriptionsByDestination.remove(destination);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":85417,"modified_method":"public void unmapFromDestination(String destination, String sessionId, String subsId) {\n\t\t\tsynchronized(this.monitor) {\n\t\t\t\tfor (String cachedDestination : this.subscriptionsByDestination.keySet()) {\n\t\t\t\t\tif (this.pathMatcher.match(destination, cachedDestination)) {\n\t\t\t\t\t\tMultiValueMap<String, String> registrations = this.subscriptionsByDestination.get(cachedDestination);\n\t\t\t\t\t\tList<String> subscriptions = registrations.get(sessionId);\n\t\t\t\t\t\twhile(subscriptions.remove(subsId));\n\t\t\t\t\t\tif (subscriptions.isEmpty()) {\n\t\t\t\t\t\t\tregistrations.remove(sessionId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (registrations.isEmpty()) {\n\t\t\t\t\t\t\tthis.subscriptionsByDestination.remove(cachedDestination);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"1054080b24d26ceb7d079a2a8089b062198d4223","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected void addSubscriptionInternal(String sessionId, String subsId, String destination, Message<?> message) {\n\t\tSessionSubscriptionInfo info = this.subscriptionRegistry.addSubscription(sessionId, subsId, destination);\n\t\tif (!this.pathMatcher.isPattern(destination)) {\n\t\t\tthis.destinationCache.mapToDestination(destination, info);\n\t\t}\n\t}","id":85418,"modified_method":"@Override\n\tprotected void addSubscriptionInternal(String sessionId, String subsId, String destination, Message<?> message) {\n\t\tSessionSubscriptionInfo info = this.subscriptionRegistry.addSubscription(sessionId, subsId, destination);\n\t\tthis.destinationCache.mapToDestination(destination, sessionId, subsId);\n\t}","commit_id":"1054080b24d26ceb7d079a2a8089b062198d4223","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected void removeSubscriptionInternal(String sessionId, String subscriptionId, Message<?> message) {\n\t\tSessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId);\n\t\tif (info != null) {\n\t\t\tString destination = info.removeSubscription(subscriptionId);\n\t\t\tif (info.getSubscriptions(destination) == null) {\n\t\t\t\tthis.destinationCache.unmapFromDestination(destination, info);\n\t\t\t}\n\t\t}\n\t}","id":85419,"modified_method":"@Override\n\tprotected void removeSubscriptionInternal(String sessionId, String subsId, Message<?> message) {\n\t\tSessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId);\n\t\tif (info != null) {\n\t\t\tString destination = info.removeSubscription(subsId);\n\t\t\tif (info.getSubscriptions(destination) == null) {\n\t\t\t\tthis.destinationCache.unmapFromDestination(destination, sessionId, subsId);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1054080b24d26ceb7d079a2a8089b062198d4223","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public int getLimit() {\n        return limit;\n    }","id":85420,"modified_method":"public int getLimit() {\n        return this.limit;\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"public void setLimit(int lim) {\n        limit = lim;\n    }","id":85421,"modified_method":"public void setLimit(int lim) {\n        this.limit = lim;\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"public void setInMemThreshold(long t) {\n        threshold = t;\n    }","id":85422,"modified_method":"public void setInMemThreshold(long t) {\n        this.threshold = t;\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"public LoggingFeature() {\n        this.sender = new Slf4jEventSender();\n        prettyFilter = new PrettyLoggingFilter(sender);\n        in = new LoggingInInterceptor(prettyFilter);\n        out = new LoggingOutInterceptor(prettyFilter);\n    }","id":85423,"modified_method":"public LoggingFeature() {\n        this.sender = new Slf4jEventSender();\n        prettyFilter = new PrettyLoggingFilter(sender);\n        wireTapIn = new WireTapIn();\n        in = new LoggingInInterceptor(prettyFilter);\n        out = new LoggingOutInterceptor(prettyFilter);\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"public void setInMemThreshold(long inMemThreshold) {\n        in.setInMemThreshold(inMemThreshold);\n        out.setInMemThreshold(inMemThreshold);\n    }","id":85424,"modified_method":"public void setInMemThreshold(long inMemThreshold) {\n        in.setInMemThreshold(inMemThreshold);\n        out.setInMemThreshold(inMemThreshold);\n        wireTapIn.setThreshold(inMemThreshold);\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"public void setLimit(int lim) {\n        in.setLimit(limit);\n        out.setLimit(limit);\n    }","id":85425,"modified_method":"public void setLimit(int limit) {\n        in.setLimit(limit);\n        out.setLimit(limit);\n        wireTapIn.setLimit(limit);\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void initializeProvider(InterceptorProvider provider, Bus bus) {\n        WireTapIn wireTapIn = new WireTapIn(inMemThreshold, limit);\n        provider.getInInterceptors().add(wireTapIn);\n        provider.getInInterceptors().add(in);\n        provider.getInFaultInterceptors().add(in);\n\n        provider.getOutInterceptors().add(out);\n        provider.getOutFaultInterceptors().add(out);\n    }","id":85426,"modified_method":"@Override\n    protected void initializeProvider(InterceptorProvider provider, Bus bus) {\n        \n        provider.getInInterceptors().add(wireTapIn);\n        provider.getInInterceptors().add(in);\n        provider.getInFaultInterceptors().add(in);\n\n        provider.getOutInterceptors().add(out);\n        provider.getOutFaultInterceptors().add(out);\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"public String getPrettyMessage(String message) {\n        try {\n            Transformer serializer = transformerFactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n\n            StringWriter swriter = new StringWriter();\n            serializer.transform(new StreamSource(new StringReader(message)), new StreamResult(swriter));\n            return swriter.toString();\n        } catch (TransformerException e) {\n            return message;\n        }\n    }","id":85427,"modified_method":"public String getPrettyMessage(String message, String encoding) {\n        StringWriter swriter = new StringWriter();\n        try {\n            // Using XMLStreamWriter instead of Transformer as it works with non well formed xml\n            // that can occur when we set a limit and cur the rest off\n            XMLStreamWriter xwriter = StaxUtils.createXMLStreamWriter(swriter);\n            xwriter = new PrettyPrintXMLStreamWriter(xwriter, 2);\n            InputStream in = new ByteArrayInputStream(message.getBytes(encoding));\n            try {\n                StaxUtils.copy(new StreamSource(in), xwriter);\n            } catch (XMLStreamException xse) {\n                //ignore\n            } finally {\n                try {\n                    xwriter.flush();\n                    xwriter.close();\n                } catch (XMLStreamException xse2) {\n                    //ignore\n                }\n                in.close();\n            }\n        } catch (IOException e) {\n            LOG.debug(\"Error while pretty printing cxf message, returning what we got till now.\", e);\n        }\n        return swriter.toString();\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"private boolean shouldPrettyPrint(LogEvent event) {\n        return prettyLogging \n            && event.getContentType() != null \n            && event.getContentType().indexOf(\"xml\") >= 0 \n            && event.getPayload().length() > 0;\n    }","id":85428,"modified_method":"private boolean shouldPrettyPrint(LogEvent event) {\n        String contentType = event.getContentType(); \n        return prettyLogging \n            && contentType != null \n            && contentType.indexOf(\"xml\") >= 0\n            && contentType.toLowerCase().indexOf(\"multipart/related\") < 0\n            && event.getPayload().length() > 0;\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"public PrettyLoggingFilter(LogEventSender next) {\n        this.next = next;\n        this.prettyLogging = false;\n        transformerFactory = TransformerFactory.newInstance();\n    }","id":85429,"modified_method":"public PrettyLoggingFilter(LogEventSender next) {\n        this.next = next;\n        this.prettyLogging = false;\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void send(LogEvent event) {\n        if (shouldPrettyPrint(event)) {\n            event.setPayload(getPrettyMessage(event.getPayload()));\n        }\n        next.send(event);\n    }","id":85430,"modified_method":"@Override\n    public void send(LogEvent event) {\n        if (shouldPrettyPrint(event)) {\n            event.setPayload(getPrettyMessage(event.getPayload(), event.getEncoding()));\n        }\n        next.send(event);\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSlf4j() throws MalformedURLException {\n        TestService serviceImpl = new TestServiceImplementation();\n        LoggingFeature loggingFeature = new LoggingFeature();\n        loggingFeature.setPrettyLogging(true);\n        Endpoint ep = Endpoint.publish(SERVICE_URI, serviceImpl, loggingFeature);\n        TestService client = createTestClient(loggingFeature);\n        client.echo(\"test\");\n        ep.stop();\n    }","id":85431,"modified_method":"@Test\n    public void testSlf4j() throws MalformedURLException {\n        TestService serviceImpl = new TestServiceImplementation();\n        LoggingFeature loggingFeature = new LoggingFeature();\n        loggingFeature.setPrettyLogging(true);\n        // Setting the limit should omit parts of the body but the result should still be well formed xml\n        loggingFeature.setLimit(140);\n        Endpoint ep = Endpoint.publish(SERVICE_URI, serviceImpl, loggingFeature);\n        TestService client = createTestClient(loggingFeature);\n        client.echo(\"test\");\n        ep.stop();\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Instantiates a new WireTapIn\n     * @param limit \n     *\n     * @param logMessageContent the log message content\n     */\n    public WireTapIn(long threshold, int limit) {\n        super(Phase.RECEIVE);\n        this.threshold = threshold;\n        this.limit = limit;\n    }","id":85432,"modified_method":"/**\n     * Instantiates a new WireTapIn\n     * @param limit \n     *\n     * @param logMessageContent the log message content\n     */\n    public WireTapIn() {\n        super(Phase.RECEIVE);\n    }","commit_id":"24b4ed27bf096d657f11320b83ef8449ca366f63","url":"https://github.com/apache/cxf"},{"original_method":"/** Returns <code>text/html;charset=UTF-8<\/code>\n\t */\n\tpublic String getContentType() {\n\t\treturn \"text/html;charset=UTF-8\";\n\t}","id":85433,"modified_method":"/** Returns <code>text/html<\/code>\n\t */\n\tpublic String getContentType() {\n\t\treturn \"text/html\";\n\t}","commit_id":"792b1ec5d816c76abd5ecf18a78f07bbb27e608a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the content type (never null).\n\t * @since 3.0.0\n\t */\n\tpublic static final String outContentType(Page page) {\n\t\tfinal String contentType = ((PageCtrl)page).getContentType();\n\t\treturn contentType != null ? contentType:\n\t\t\tpage.getDesktop().getDevice().getContentType();\n\t}","id":85434,"modified_method":"/** Returns the content type (never null).\n\t * @since 3.0.0\n\t */\n\tpublic static final String outContentType(Page page) {\n\t\tString contentType = ((PageCtrl)page).getContentType();\n\t\tif (contentType == null) {\n\t\t\tcontentType = page.getDesktop().getDevice().getContentType();\n\t\t\tif (contentType == null) contentType = \"\";\n\t\t}\n\n\t\tfinal int j = contentType.indexOf(';');\n\t\tif (j < 0) {\n\t\t\tfinal String cs = page.getDesktop().getWebApp()\n\t\t\t\t.getConfiguration().getResponseCharset();\n\t\t\tif (cs != null && cs.length() > 0)\n\t\t\t\tcontentType += \";charset=\" + cs;\n\t\t}\n\n\t\treturn contentType;\n\t}","commit_id":"792b1ec5d816c76abd5ecf18a78f07bbb27e608a","url":"https://github.com/zkoss/zk"},{"original_method":"public Map<String, Integer> countPendingHints()\n    {\n        List<Row> rows = getHintsSlice(Integer.MAX_VALUE);\n\n        Map<String, Integer> result = new HashMap<String, Integer>();\n        Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();\n        for (Row r : rows)\n        {\n            if (r.cf == null) // ignore removed rows\n                continue;\n\n            int count = r.cf.getColumnCount();\n            if (count > 0)\n                result.put(tokenFactory.toString(r.key.token), count);\n        }\n        return result;\n    }","id":85435,"modified_method":"public Map<String, Integer> countPendingHints()\n    {\n        Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();\n\n        Map<String, Integer> result = new HashMap<String, Integer>();\n        for (Row row : getHintsSlice(Integer.MAX_VALUE))\n        {\n            if (row.cf == null) // ignore removed rows\n                continue;\n\n            int count = row.cf.getColumnCount();\n            if (count > 0)\n                result.put(tokenFactory.toString(row.key.token), count);\n        }\n        return result;\n    }","commit_id":"e752de96f7e3ae676b5dba0564e1321d6661a0cc","url":"https://github.com/apache/cassandra"},{"original_method":"public List<String> listEndpointsPendingHints()\n    {\n        List<Row> rows = getHintsSlice(1);\n\n        // Extract the keys as strings to be reported.\n        LinkedList<String> result = new LinkedList<String>();\n        for (Row r : rows)\n        {\n            if (r.cf != null) //ignore removed rows\n                result.addFirst(new String(r.key.key.array()));\n        }\n        return result;\n    }","id":85436,"modified_method":"public List<String> listEndpointsPendingHints()\n    {\n        Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();\n\n        // Extract the keys as strings to be reported.\n        LinkedList<String> result = new LinkedList<String>();\n        for (Row row : getHintsSlice(1))\n        {\n            if (row.cf != null) //ignore removed rows\n                result.addFirst(tokenFactory.toString(row.key.token));\n        }\n        return result;\n    }","commit_id":"e752de96f7e3ae676b5dba0564e1321d6661a0cc","url":"https://github.com/apache/cassandra"},{"original_method":"public List<String> listEndpointsPendingHints()\n    {\n        List<Row> rows = getHintsSlice(1);\n\n        // Extract the keys as strings to be reported.\n        LinkedList<String> result = new LinkedList<String>();\n        for (Row r : rows)\n        {\n            if (r.cf != null) //ignore removed rows\n                result.addFirst(new String(r.key.key.array()));\n        }\n        return result;\n    }","id":85437,"modified_method":"public List<String> listEndpointsPendingHints()\n    {\n        Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();\n\n        // Extract the keys as strings to be reported.\n        LinkedList<String> result = new LinkedList<String>();\n        for (Row row : getHintsSlice(1))\n        {\n            if (row.cf != null) //ignore removed rows\n                result.addFirst(tokenFactory.toString(row.key.token));\n        }\n        return result;\n    }","commit_id":"b03ae12cb58da9bc77dc88151da47d26223051de","url":"https://github.com/apache/cassandra"},{"original_method":"public Map<String, Integer> countPendingHints()\n    {\n        List<Row> rows = getHintsSlice(Integer.MAX_VALUE);\n\n        Map<String, Integer> result = new HashMap<String, Integer>();\n        Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();\n        for (Row r : rows)\n        {\n            if (r.cf == null) // ignore removed rows\n                continue;\n\n            int count = r.cf.getColumnCount();\n            if (count > 0)\n                result.put(tokenFactory.toString(r.key.token), count);\n        }\n        return result;\n    }","id":85438,"modified_method":"public Map<String, Integer> countPendingHints()\n    {\n        Token.TokenFactory tokenFactory = StorageService.getPartitioner().getTokenFactory();\n\n        Map<String, Integer> result = new HashMap<String, Integer>();\n        for (Row row : getHintsSlice(Integer.MAX_VALUE))\n        {\n            if (row.cf == null) // ignore removed rows\n                continue;\n\n            int count = row.cf.getColumnCount();\n            if (count > 0)\n                result.put(tokenFactory.toString(row.key.token), count);\n        }\n        return result;\n    }","commit_id":"b03ae12cb58da9bc77dc88151da47d26223051de","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testPreserveOriginal() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_ascii_folding.type\", \"asciifolding\")\n                .put(\"index.analysis.filter.my_ascii_folding.preserve_original\", true)\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_ascii_folding\");\n        String source = \"Ansprche\";\n        String[] expected = new String[]{\"Anspruche\", \"Ansprche\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85439,"modified_method":"@Test\n    public void testPreserveOriginal() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_ascii_folding.type\", \"asciifolding\")\n                .put(\"index.analysis.filter.my_ascii_folding.preserve_original\", true)\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_ascii_folding\");\n        String source = \"Ansprche\";\n        String[] expected = new String[]{\"Anspruche\", \"Ansprche\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_ascii_folding.type\", \"asciifolding\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_ascii_folding\");\n        String source = \"Ansprche\";\n        String[] expected = new String[]{\"Anspruche\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85440,"modified_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_ascii_folding.type\", \"asciifolding\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_ascii_folding\");\n        String source = \"Ansprche\";\n        String[] expected = new String[]{\"Anspruche\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void assertTokenFilter(String name, Class clazz) throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(name);\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo bar\"));\n        TokenStream stream = tokenFilter.create(tokenizer);\n        assertThat(stream, instanceOf(clazz));\n    }","id":85441,"modified_method":"private void assertTokenFilter(String name, Class clazz) throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                               .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)\n                               .put(\"path.home\", createTempDir().toString()).build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(name);\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo bar\"));\n        TokenStream stream = tokenFilter.create(tokenizer);\n        assertThat(stream, instanceOf(clazz));\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static AnalysisService createAnalysisServiceFromClassPath(String resource) {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .loadFromClasspath(resource).build();\n\n        return createAnalysisServiceFromSettings(settings);\n    }","id":85442,"modified_method":"public static AnalysisService createAnalysisServiceFromClassPath(Path baseDir, String resource) {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .loadFromClasspath(resource)\n                .put(\"path.home\", baseDir.toString())\n                .build();\n\n        return createAnalysisServiceFromSettings(settings);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Ignore\n    private void testNoStopwordsAfter(org.elasticsearch.Version noStopwordVersion, String type) throws IOException {\n        final int iters = scaledRandomIntBetween(10, 100);\n        org.elasticsearch.Version version = org.elasticsearch.Version.CURRENT;\n        for (int i = 0; i < iters; i++) {\n            ImmutableSettings.Builder builder = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.my_stop.type\", \"stop\");\n            if (version.onOrAfter(noStopwordVersion))  {\n                if (random().nextBoolean()) {\n                    builder.put(SETTING_VERSION_CREATED, version);\n                }\n            } else {\n                builder.put(SETTING_VERSION_CREATED, version);\n            }\n            builder.put(\"index.analysis.analyzer.foo.type\", type);\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(builder.build());\n            NamedAnalyzer analyzer = analysisService.analyzer(\"foo\");\n            if (version.onOrAfter(noStopwordVersion)) {\n                assertAnalyzesTo(analyzer, \"this is bogus\", new String[]{\"this\", \"is\", \"bogus\"});\n            } else {\n                assertAnalyzesTo(analyzer, \"this is bogus\", new String[]{\"bogus\"});\n            }\n            version = randomVersion();\n        }\n    }","id":85443,"modified_method":"@Ignore\n    private void testNoStopwordsAfter(org.elasticsearch.Version noStopwordVersion, String type) throws IOException {\n        final int iters = scaledRandomIntBetween(10, 100);\n        org.elasticsearch.Version version = org.elasticsearch.Version.CURRENT;\n        for (int i = 0; i < iters; i++) {\n            ImmutableSettings.Builder builder = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.my_stop.type\", \"stop\");\n            if (version.onOrAfter(noStopwordVersion))  {\n                if (random().nextBoolean()) {\n                    builder.put(SETTING_VERSION_CREATED, version);\n                }\n            } else {\n                builder.put(SETTING_VERSION_CREATED, version);\n            }\n            builder.put(\"index.analysis.analyzer.foo.type\", type);\n            builder.put(\"path.home\", createTempDir().toString());\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(builder.build());\n            NamedAnalyzer analyzer = analysisService.analyzer(\"foo\");\n            if (version.onOrAfter(noStopwordVersion)) {\n                assertAnalyzesTo(analyzer, \"this is bogus\", new String[]{\"this\", \"is\", \"bogus\"});\n            } else {\n                assertAnalyzesTo(analyzer, \"this is bogus\", new String[]{\"bogus\"});\n            }\n            version = randomVersion();\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testNoFlags() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_no_flags\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85444,"modified_method":"@Test\n    public void testNoFlags() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_no_flags\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testHanUnigramOnly() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_han_unigram_only\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\", \"\", \"\"  };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85445,"modified_method":"@Test\n    public void testHanUnigramOnly() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_han_unigram_only\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\", \"\", \"\"  };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_bigram\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85446,"modified_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_bigram\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testHanOnly() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_han_only\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\",  \"\", \"\",  \"\", \"\",  \"\", \"\", \"\"  };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85447,"modified_method":"@Test\n    public void testHanOnly() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"cjk_han_only\");\n        String source = \"\";\n        String[] expected = new String[]{\"\", \"\", \"\",  \"\", \"\",  \"\", \"\",  \"\", \"\", \"\"  };\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testQueryModeSettings() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_1.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_1.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_1.common_words\", \"the\", \"Or\", \"Not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .put(\"index.analysis.filter.common_grams_1.ignore_case\", true)\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_1\");\n            String source = \"the quick brown is a fox or noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox_or\", \"or_noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_2.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_2.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_2.common_words\", \"the\", \"Or\", \"noT\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .put(\"index.analysis.filter.common_grams_2.ignore_case\", false)\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_2\");\n            String source = \"the quick brown is a fox or why noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox\", \"or\", \"why_noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_3.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_3.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_3.common_words\", \"the\", \"Or\", \"noT\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_3\");\n            String source = \"the quick brown is a fox or why noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox\", \"or\", \"why_noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_4.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_4.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_4.common_words\", \"the\", \"or\", \"not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_4\");\n            String source = \"the quick brown is a fox Or noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox\", \"Or\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","id":85448,"modified_method":"@Test\n    public void testQueryModeSettings() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_1.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_1.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_1.common_words\", \"the\", \"Or\", \"Not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .put(\"index.analysis.filter.common_grams_1.ignore_case\", true)\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_1\");\n            String source = \"the quick brown is a fox or noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox_or\", \"or_noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_2.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_2.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_2.common_words\", \"the\", \"Or\", \"noT\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .put(\"index.analysis.filter.common_grams_2.ignore_case\", false)\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_2\");\n            String source = \"the quick brown is a fox or why noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox\", \"or\", \"why_noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_3.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_3.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_3.common_words\", \"the\", \"Or\", \"noT\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_3\");\n            String source = \"the quick brown is a fox or why noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox\", \"or\", \"why_noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_4.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_4.query_mode\", true)\n                    .putArray(\"index.analysis.filter.common_grams_4.common_words\", \"the\", \"or\", \"not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_4\");\n            String source = \"the quick brown is a fox Or noT\";\n            String[] expected = new String[] { \"the_quick\", \"quick\", \"brown_is\", \"is_a\", \"a_fox\", \"fox\", \"Or\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testQueryModeCommonGramsAnalysis() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder().loadFromClasspath(\"org/elasticsearch/index/analysis/commongrams/commongrams_query_mode.json\").build();\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick_brown\", \"brown_is\", \"is\", \"a_fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer_file\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick_brown\", \"brown_is\", \"is\", \"a_fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n    }","id":85449,"modified_method":"@Test\n    public void testQueryModeCommonGramsAnalysis() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .loadFromClasspath(\"org/elasticsearch/index/analysis/commongrams/commongrams_query_mode.json\")\n                .put(\"path.home\", createTempDir().toString())\n                .build();\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick_brown\", \"brown_is\", \"is\", \"a_fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer_file\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick_brown\", \"brown_is\", \"is\", \"a_fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDefault() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_default.type\", \"common_grams\").build();\n\n        try {\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Assert.fail(\"[common_words] or [common_words_path] is set\");\n        } catch (Exception e) {\n            assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));\n        }\n    }","id":85450,"modified_method":"@Test\n    public void testDefault() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                                .put(\"index.analysis.filter.common_grams_default.type\", \"common_grams\")\n                                .put(\"path.home\", createTempDir().toString())\n                                .build();\n\n        try {\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Assert.fail(\"[common_words] or [common_words_path] is set\");\n        } catch (Exception e) {\n            assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testWithoutCommonWordsMatch() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_default.type\", \"common_grams\")\n                     .putArray(\"index.analysis.filter.common_grams_default.common_words\", \"chromosome\", \"protein\")\n                     .build();\n\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            {\n                TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_default\");\n                String source = \"the quick brown is a fox Or noT\";\n                String[] expected = new String[] { \"the\", \"quick\", \"brown\", \"is\", \"a\", \"fox\", \"Or\", \"noT\" };\n                Tokenizer tokenizer = new WhitespaceTokenizer();\n                tokenizer.setReader(new StringReader(source));\n                assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n            }\n        }\n\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_default.type\", \"common_grams\")\n                     .put(\"index.analysis.filter.common_grams_default.query_mode\", false)\n                     .putArray(\"index.analysis.filter.common_grams_default.common_words\", \"chromosome\", \"protein\")\n                     .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            {\n                TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_default\");\n                String source = \"the quick brown is a fox Or noT\";\n                String[] expected = new String[] { \"the\", \"quick\", \"brown\", \"is\", \"a\", \"fox\", \"Or\", \"noT\" };\n                Tokenizer tokenizer = new WhitespaceTokenizer();\n                tokenizer.setReader(new StringReader(source));\n                assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n            }\n        }\n    }","id":85451,"modified_method":"@Test\n    public void testWithoutCommonWordsMatch() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_default.type\", \"common_grams\")\n                     .putArray(\"index.analysis.filter.common_grams_default.common_words\", \"chromosome\", \"protein\")\n                     .put(\"path.home\", createTempDir().toString())\n                     .build();\n\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            {\n                TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_default\");\n                String source = \"the quick brown is a fox Or noT\";\n                String[] expected = new String[] { \"the\", \"quick\", \"brown\", \"is\", \"a\", \"fox\", \"Or\", \"noT\" };\n                Tokenizer tokenizer = new WhitespaceTokenizer();\n                tokenizer.setReader(new StringReader(source));\n                assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n            }\n        }\n\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_default.type\", \"common_grams\")\n                     .put(\"index.analysis.filter.common_grams_default.query_mode\", false)\n                     .put(\"path.home\", createTempDir().toString())\n                     .putArray(\"index.analysis.filter.common_grams_default.common_words\", \"chromosome\", \"protein\")\n                     .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            {\n                TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_default\");\n                String source = \"the quick brown is a fox Or noT\";\n                String[] expected = new String[] { \"the\", \"quick\", \"brown\", \"is\", \"a\", \"fox\", \"Or\", \"noT\" };\n                Tokenizer tokenizer = new WhitespaceTokenizer();\n                tokenizer.setReader(new StringReader(source));\n                assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n            }\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSettings() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_1.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_1.ignore_case\", true)\n                    .putArray(\"index.analysis.filter.common_grams_1.common_words\", \"the\", \"Or\", \"Not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_1\");\n            String source = \"the quick brown is a fox or noT\";\n            String[] expected = new String[] { \"the\", \"the_quick\", \"quick\", \"brown\", \"brown_is\", \"is\", \"is_a\", \"a\", \"a_fox\", \"fox\", \"fox_or\", \"or\", \"or_noT\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_2.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_2.ignore_case\", false)\n                    .putArray(\"index.analysis.filter.common_grams_2.common_words\", \"the\", \"Or\", \"noT\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_2\");\n            String source = \"the quick brown is a fox or why noT\";\n            String[] expected = new String[] { \"the\", \"the_quick\", \"quick\", \"brown\", \"brown_is\", \"is\", \"is_a\", \"a\", \"a_fox\", \"fox\", \"or\", \"why\", \"why_noT\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_3.type\", \"common_grams\")\n                    .putArray(\"index.analysis.filter.common_grams_3.common_words\", \"the\", \"or\", \"not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_3\");\n            String source = \"the quick brown is a fox Or noT\";\n            String[] expected = new String[] { \"the\", \"the_quick\", \"quick\", \"brown\", \"brown_is\", \"is\", \"is_a\", \"a\", \"a_fox\", \"fox\", \"Or\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","id":85452,"modified_method":"@Test\n    public void testSettings() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_1.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_1.ignore_case\", true)\n                    .put(\"path.home\", createTempDir().toString())\n                    .putArray(\"index.analysis.filter.common_grams_1.common_words\", \"the\", \"Or\", \"Not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_1\");\n            String source = \"the quick brown is a fox or noT\";\n            String[] expected = new String[] { \"the\", \"the_quick\", \"quick\", \"brown\", \"brown_is\", \"is\", \"is_a\", \"a\", \"a_fox\", \"fox\", \"fox_or\", \"or\", \"or_noT\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_2.type\", \"common_grams\")\n                    .put(\"index.analysis.filter.common_grams_2.ignore_case\", false)\n                    .put(\"path.home\", createTempDir().toString())\n                    .putArray(\"index.analysis.filter.common_grams_2.common_words\", \"the\", \"Or\", \"noT\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_2\");\n            String source = \"the quick brown is a fox or why noT\";\n            String[] expected = new String[] { \"the\", \"the_quick\", \"quick\", \"brown\", \"brown_is\", \"is\", \"is_a\", \"a\", \"a_fox\", \"fox\", \"or\", \"why\", \"why_noT\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.common_grams_3.type\", \"common_grams\")\n                    .putArray(\"index.analysis.filter.common_grams_3.common_words\", \"the\", \"or\", \"not\", \"a\", \"is\", \"an\", \"they\", \"are\")\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"common_grams_3\");\n            String source = \"the quick brown is a fox Or noT\";\n            String[] expected = new String[] { \"the\", \"the_quick\", \"quick\", \"brown\", \"brown_is\", \"is\", \"is_a\", \"a\", \"a_fox\", \"fox\", \"Or\", \"noT\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCommonGramsAnalysis() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder().loadFromClasspath(\"org/elasticsearch/index/analysis/commongrams/commongrams.json\").build();\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick\", \"quick_brown\", \"brown\", \"brown_is\", \"is\", \"a\", \"a_fox\", \"fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer_file\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick\", \"quick_brown\", \"brown\", \"brown_is\", \"is\", \"a\", \"a_fox\", \"fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n    }","id":85453,"modified_method":"@Test\n    public void testCommonGramsAnalysis() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                     .loadFromClasspath(\"org/elasticsearch/index/analysis/commongrams/commongrams.json\")\n                     .put(\"path.home\", createTempDir().toString())\n                     .build();\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick\", \"quick_brown\", \"brown\", \"brown_is\", \"is\", \"a\", \"a_fox\", \"fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n        {\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Analyzer analyzer = analysisService.analyzer(\"commongramsAnalyzer_file\").analyzer();\n            String source = \"the quick brown is a fox or not\";\n            String[] expected = new String[] { \"the\", \"quick\", \"quick_brown\", \"brown\", \"brown_is\", \"is\", \"a\", \"a_fox\", \"fox\", \"fox_or\", \"or\", \"not\" };\n            assertTokenStreamContents(analyzer.tokenStream(\"test\", source), expected);\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Environment(Settings settings) {\n        this.settings = settings;\n        if (settings.get(\"path.home\") != null) {\n            homeFile = PathUtils.get(cleanPath(settings.get(\"path.home\")));\n        } else {\n            homeFile = PathUtils.get(System.getProperty(\"user.dir\"));\n        }\n\n        if (settings.get(\"path.conf\") != null) {\n            configFile = PathUtils.get(cleanPath(settings.get(\"path.conf\")));\n        } else {\n            configFile = homeFile.resolve(\"config\");\n        }\n\n        if (settings.get(\"path.plugins\") != null) {\n            pluginsFile = PathUtils.get(cleanPath(settings.get(\"path.plugins\")));\n        } else {\n            pluginsFile = homeFile.resolve(\"plugins\");\n        }\n\n        String[] dataPaths = settings.getAsArray(\"path.data\");\n        if (dataPaths.length > 0) {\n            dataFiles = new Path[dataPaths.length];\n            dataWithClusterFiles = new Path[dataPaths.length];\n            for (int i = 0; i < dataPaths.length; i++) {\n                dataFiles[i] = PathUtils.get(dataPaths[i]);\n                dataWithClusterFiles[i] = dataFiles[i].resolve(ClusterName.clusterNameFromSettings(settings).value());\n            }\n        } else {\n            dataFiles = new Path[]{homeFile.resolve(\"data\")};\n            dataWithClusterFiles = new Path[]{homeFile.resolve(\"data\").resolve(ClusterName.clusterNameFromSettings(settings).value())};\n        }\n\n        if (settings.get(\"path.logs\") != null) {\n            logsFile = PathUtils.get(cleanPath(settings.get(\"path.logs\")));\n        } else {\n            logsFile = homeFile.resolve(\"logs\");\n        }\n    }","id":85454,"modified_method":"public Environment(Settings settings) {\n        this.settings = settings;\n        if (settings.get(\"path.home\") != null) {\n            homeFile = PathUtils.get(cleanPath(settings.get(\"path.home\")));\n        } else {\n            throw new IllegalStateException(\"path.home is not configured\");\n        }\n\n        if (settings.get(\"path.conf\") != null) {\n            configFile = PathUtils.get(cleanPath(settings.get(\"path.conf\")));\n        } else {\n            configFile = homeFile.resolve(\"config\");\n        }\n\n        if (settings.get(\"path.plugins\") != null) {\n            pluginsFile = PathUtils.get(cleanPath(settings.get(\"path.plugins\")));\n        } else {\n            pluginsFile = homeFile.resolve(\"plugins\");\n        }\n\n        String[] dataPaths = settings.getAsArray(\"path.data\");\n        if (dataPaths.length > 0) {\n            dataFiles = new Path[dataPaths.length];\n            dataWithClusterFiles = new Path[dataPaths.length];\n            for (int i = 0; i < dataPaths.length; i++) {\n                dataFiles[i] = PathUtils.get(dataPaths[i]);\n                dataWithClusterFiles[i] = dataFiles[i].resolve(ClusterName.clusterNameFromSettings(settings).value());\n            }\n        } else {\n            dataFiles = new Path[]{homeFile.resolve(\"data\")};\n            dataWithClusterFiles = new Path[]{homeFile.resolve(\"data\").resolve(ClusterName.clusterNameFromSettings(settings).value())};\n        }\n\n        if (settings.get(\"path.logs\") != null) {\n            logsFile = PathUtils.get(cleanPath(settings.get(\"path.logs\")));\n        } else {\n            logsFile = homeFile.resolve(\"logs\");\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDedup() throws IOException {\n        Settings settings = settingsBuilder()\n                .put(\"path.conf\", getDataPath(\"/indices/analyze/conf_dir\"))\n                .put(\"index.analysis.filter.en_US.type\", \"hunspell\")\n                .put(\"index.analysis.filter.en_US.locale\", \"en_US\")\n                .build();\n\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"en_US\");\n        assertThat(tokenFilter, instanceOf(HunspellTokenFilterFactory.class));\n        HunspellTokenFilterFactory hunspellTokenFilter = (HunspellTokenFilterFactory) tokenFilter;\n        assertThat(hunspellTokenFilter.dedup(), is(true));\n\n        settings = settingsBuilder()\n                .put(\"path.conf\", getDataPath(\"/indices/analyze/conf_dir\"))\n                .put(\"index.analysis.filter.en_US.type\", \"hunspell\")\n                .put(\"index.analysis.filter.en_US.dedup\", false)\n                .put(\"index.analysis.filter.en_US.locale\", \"en_US\")\n                .build();\n\n        analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        tokenFilter = analysisService.tokenFilter(\"en_US\");\n        assertThat(tokenFilter, instanceOf(HunspellTokenFilterFactory.class));\n        hunspellTokenFilter = (HunspellTokenFilterFactory) tokenFilter;\n        assertThat(hunspellTokenFilter.dedup(), is(false));\n    }","id":85455,"modified_method":"@Test\n    public void testDedup() throws IOException {\n        Settings settings = settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"path.conf\", getDataPath(\"/indices/analyze/conf_dir\"))\n                .put(\"index.analysis.filter.en_US.type\", \"hunspell\")\n                .put(\"index.analysis.filter.en_US.locale\", \"en_US\")\n                .build();\n\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"en_US\");\n        assertThat(tokenFilter, instanceOf(HunspellTokenFilterFactory.class));\n        HunspellTokenFilterFactory hunspellTokenFilter = (HunspellTokenFilterFactory) tokenFilter;\n        assertThat(hunspellTokenFilter.dedup(), is(true));\n\n        settings = settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"path.conf\", getDataPath(\"/indices/analyze/conf_dir\"))\n                .put(\"index.analysis.filter.en_US.type\", \"hunspell\")\n                .put(\"index.analysis.filter.en_US.dedup\", false)\n                .put(\"index.analysis.filter.en_US.locale\", \"en_US\")\n                .build();\n\n        analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        tokenFilter = analysisService.tokenFilter(\"en_US\");\n        assertThat(tokenFilter, instanceOf(HunspellTokenFilterFactory.class));\n        hunspellTokenFilter = (HunspellTokenFilterFactory) tokenFilter;\n        assertThat(hunspellTokenFilter.dedup(), is(false));\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testKeepWordsPathSettings() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.analysis.filter.non_broken_keep_filter.type\", \"keep\")\n                .put(\"index.analysis.filter.non_broken_keep_filter.keep_words_path\", \"does/not/exists.txt\")\n                .build();\n        try {\n            // test our none existing setup is picked up\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            fail(\"expected an exception due to non existent keep_words_path\");\n        } catch (Throwable e) {\n            assertThat(e.getCause(), instanceOf(FailedToResolveConfigException.class));\n        }\n\n        settings = ImmutableSettings.settingsBuilder().put(settings)\n                .put(\"index.analysis.filter.non_broken_keep_filter.keep_words\", new String[]{\"test\"})\n                .build();\n        try {\n            // test our none existing setup is picked up\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            fail(\"expected an exception indicating that you can't use [keep_words_path] with [keep_words] \");\n        } catch (Throwable e) {\n            assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));\n        }\n\n    }","id":85456,"modified_method":"@Test\n    public void testKeepWordsPathSettings() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.non_broken_keep_filter.type\", \"keep\")\n                .put(\"index.analysis.filter.non_broken_keep_filter.keep_words_path\", \"does/not/exists.txt\")\n                .build();\n        try {\n            // test our none existing setup is picked up\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            fail(\"expected an exception due to non existent keep_words_path\");\n        } catch (Throwable e) {\n            assertThat(e.getCause(), instanceOf(FailedToResolveConfigException.class));\n        }\n\n        settings = ImmutableSettings.settingsBuilder().put(settings)\n                .put(\"index.analysis.filter.non_broken_keep_filter.keep_words\", new String[]{\"test\"})\n                .build();\n        try {\n            // test our none existing setup is picked up\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            fail(\"expected an exception indicating that you can't use [keep_words_path] with [keep_words] \");\n        } catch (Throwable e) {\n            assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));\n        }\n\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCaseInsensitiveMapping() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_keep_filter\");\n        assertThat(tokenFilter, instanceOf(KeepWordFilterFactory.class));\n        String source = \"hello small world\";\n        String[] expected = new String[]{\"hello\", \"world\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected, new int[]{1, 2});\n    }","id":85457,"modified_method":"@Test\n    public void testCaseInsensitiveMapping() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_keep_filter\");\n        assertThat(tokenFilter, instanceOf(KeepWordFilterFactory.class));\n        String source = \"hello small world\";\n        String[] expected = new String[]{\"hello\", \"world\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected, new int[]{1, 2});\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCaseSensitiveMapping() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_case_sensitive_keep_filter\");\n        assertThat(tokenFilter, instanceOf(KeepWordFilterFactory.class));\n        String source = \"Hello small world\";\n        String[] expected = new String[]{\"Hello\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected, new int[]{1});\n    }","id":85458,"modified_method":"@Test\n    public void testCaseSensitiveMapping() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_case_sensitive_keep_filter\");\n        assertThat(tokenFilter, instanceOf(KeepWordFilterFactory.class));\n        String source = \"Hello small world\";\n        String[] expected = new String[]{\"Hello\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected, new int[]{1});\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLoadWithoutSettings() {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"keep\");\n        Assert.assertNull(tokenFilter);\n    }","id":85459,"modified_method":"@Test\n    public void testLoadWithoutSettings() {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"keep\");\n        Assert.assertNull(tokenFilter);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLoadOverConfiguredSettings() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.analysis.filter.broken_keep_filter.type\", \"keep\")\n                .put(\"index.analysis.filter.broken_keep_filter.keep_words_path\", \"does/not/exists.txt\")\n                .put(\"index.analysis.filter.broken_keep_filter.keep_words\", \"[\\\"Hello\\\", \\\"worlD\\\"]\")\n                .build();\n        try {\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Assert.fail(\"path and array are configured\");\n        } catch (Exception e) {\n            assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));\n        }\n    }","id":85460,"modified_method":"@Test\n    public void testLoadOverConfiguredSettings() {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.broken_keep_filter.type\", \"keep\")\n                .put(\"index.analysis.filter.broken_keep_filter.keep_words_path\", \"does/not/exists.txt\")\n                .put(\"index.analysis.filter.broken_keep_filter.keep_words\", \"[\\\"Hello\\\", \\\"worlD\\\"]\")\n                .build();\n        try {\n            AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            Assert.fail(\"path and array are configured\");\n        } catch (Exception e) {\n            assertThat(e.getCause(), instanceOf(IllegalArgumentException.class));\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testKeepTypes() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.analysis.filter.keep_numbers.type\", \"keep_types\")\n                .putArray(\"index.analysis.filter.keep_numbers.types\", new String[] {\"<NUM>\", \"<SOMETHINGELSE>\"})\n                .build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"keep_numbers\");\n        assertThat(tokenFilter, instanceOf(KeepTypesFilterFactory.class));\n        String source = \"Hello 123 world\";\n        String[] expected = new String[]{\"123\"};\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected, new int[]{2});\n    }","id":85461,"modified_method":"@Test\n    public void testKeepTypes() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.keep_numbers.type\", \"keep_types\")\n                .putArray(\"index.analysis.filter.keep_numbers.types\", new String[] {\"<NUM>\", \"<SOMETHINGELSE>\"})\n                .build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"keep_numbers\");\n        assertThat(tokenFilter, instanceOf(KeepTypesFilterFactory.class));\n        String source = \"Hello 123 world\";\n        String[] expected = new String[]{\"123\"};\n        Tokenizer tokenizer = new StandardTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected, new int[]{2});\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSettings() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.limit_1.type\", \"limit\")\n                    .put(\"index.analysis.filter.limit_1.max_token_count\", 3).put(\"index.analysis.filter.limit_1.consume_all_tokens\", true)\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_1\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\", \"quick\", \"brown\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.limit_1.type\", \"limit\")\n                    .put(\"index.analysis.filter.limit_1.max_token_count\", 3).put(\"index.analysis.filter.limit_1.consume_all_tokens\", false)\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_1\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\", \"quick\", \"brown\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n\n        {\n            Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.limit_1.type\", \"limit\")\n                    .put(\"index.analysis.filter.limit_1.max_token_count\", 17).put(\"index.analysis.filter.limit_1.consume_all_tokens\", true)\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_1\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\", \"quick\", \"brown\", \"fox\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","id":85462,"modified_method":"@Test\n    public void testSettings() throws IOException {\n        {\n            Settings settings = ImmutableSettings.settingsBuilder()\n                    .put(\"index.analysis.filter.limit_1.type\", \"limit\")\n                    .put(\"index.analysis.filter.limit_1.max_token_count\", 3)\n                    .put(\"index.analysis.filter.limit_1.consume_all_tokens\", true)\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_1\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\", \"quick\", \"brown\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            Settings settings = ImmutableSettings.settingsBuilder()\n                    .put(\"index.analysis.filter.limit_1.type\", \"limit\")\n                    .put(\"index.analysis.filter.limit_1.max_token_count\", 3)\n                    .put(\"index.analysis.filter.limit_1.consume_all_tokens\", false)\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_1\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\", \"quick\", \"brown\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n\n        {\n            Settings settings = ImmutableSettings.settingsBuilder()\n                    .put(\"index.analysis.filter.limit_1.type\", \"limit\")\n                    .put(\"index.analysis.filter.limit_1.max_token_count\", 17)\n                    .put(\"index.analysis.filter.limit_1.consume_all_tokens\", true)\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_1\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\", \"quick\", \"brown\", \"fox\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDefault() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.limit_default.type\", \"limit\").build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        {\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_default\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","id":85463,"modified_method":"@Test\n    public void testDefault() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.analysis.filter.limit_default.type\", \"limit\")\n                .put(\"path.home\", createTempDir().toString())\n                .build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        {\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit_default\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n        {\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"limit\");\n            String source = \"the quick brown fox\";\n            String[] expected = new String[] { \"the\" };\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(source));\n            assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testInverseMapping() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle_inverse\");\n        assertThat(tokenFilter, instanceOf(ShingleTokenFilterFactory.class));\n        String source = \"the quick brown fox\";\n        String[] expected = new String[]{\"the_quick_brown\", \"quick_brown_fox\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85464,"modified_method":"@Test\n    public void testInverseMapping() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle_inverse\");\n        assertThat(tokenFilter, instanceOf(ShingleTokenFilterFactory.class));\n        String source = \"the quick brown fox\";\n        String[] expected = new String[]{\"the_quick_brown\", \"quick_brown_fox\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle\");\n        String source = \"the quick brown fox\";\n        String[] expected = new String[]{\"the\", \"the quick\", \"quick\", \"quick brown\", \"brown\", \"brown fox\", \"fox\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85465,"modified_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle\");\n        String source = \"the quick brown fox\";\n        String[] expected = new String[]{\"the\", \"the quick\", \"quick\", \"quick brown\", \"brown\", \"brown fox\", \"fox\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testInverseMappingNoShingles() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle_inverse\");\n        assertThat(tokenFilter, instanceOf(ShingleTokenFilterFactory.class));\n        String source = \"the quick\";\n        String[] expected = new String[]{\"the\", \"quick\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85466,"modified_method":"@Test\n    public void testInverseMappingNoShingles() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle_inverse\");\n        assertThat(tokenFilter, instanceOf(ShingleTokenFilterFactory.class));\n        String source = \"the quick\";\n        String[] expected = new String[]{\"the\", \"quick\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testFillerToken() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle_filler\");\n        String source = \"simon the sorcerer\";\n        String[] expected = new String[]{\"simon FILLER\", \"simon FILLER sorcerer\", \"FILLER sorcerer\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        TokenStream stream = new StopFilter(tokenizer, StopFilter.makeStopSet(\"the\"));\n        assertTokenStreamContents(tokenFilter.create(stream), expected);\n    }","id":85467,"modified_method":"@Test\n    public void testFillerToken() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromClassPath(createTempDir(), RESOURCE);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"shingle_filler\");\n        String source = \"simon the sorcerer\";\n        String[] expected = new String[]{\"simon FILLER\", \"simon FILLER sorcerer\", \"FILLER sorcerer\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        TokenStream stream = new StopFilter(tokenizer, StopFilter.makeStopSet(\"the\"));\n        assertTokenStreamContents(tokenFilter.create(stream), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPorter2BackwardsCompatibility() throws IOException {\n        int iters = scaledRandomIntBetween(20, 100);\n        for (int i = 0; i < iters; i++) {\n\n            Version v = VersionUtils.randomVersion(random());\n            Settings settings = ImmutableSettings.settingsBuilder()\n                    .put(\"index.analysis.filter.my_porter2.type\", \"stemmer\")\n                    .put(\"index.analysis.filter.my_porter2.language\", \"porter2\")\n                    .put(\"index.analysis.analyzer.my_porter2.tokenizer\",\"whitespace\")\n                    .put(\"index.analysis.analyzer.my_porter2.filter\",\"my_porter2\")\n                    .put(SETTING_VERSION_CREATED,v)\n                    .build();\n\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_porter2\");\n            assertThat(tokenFilter, instanceOf(StemmerTokenFilterFactory.class));\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(\"foo bar\"));\n            TokenStream create = tokenFilter.create(tokenizer);\n            NamedAnalyzer analyzer = analysisService.analyzer(\"my_porter2\");\n            assertThat(create, instanceOf(SnowballFilter.class));\n\n            if (v.onOrAfter(Version.V_1_3_0)) {\n                assertAnalyzesTo(analyzer, \"possibly\", new String[]{\"possibl\"});\n            } else {\n                assertAnalyzesTo(analyzer, \"possibly\", new String[]{\"possibli\"});\n            }\n        }\n\n    }","id":85468,"modified_method":"@Test\n    public void testPorter2BackwardsCompatibility() throws IOException {\n        int iters = scaledRandomIntBetween(20, 100);\n        for (int i = 0; i < iters; i++) {\n\n            Version v = VersionUtils.randomVersion(random());\n            Settings settings = ImmutableSettings.settingsBuilder()\n                    .put(\"index.analysis.filter.my_porter2.type\", \"stemmer\")\n                    .put(\"index.analysis.filter.my_porter2.language\", \"porter2\")\n                    .put(\"index.analysis.analyzer.my_porter2.tokenizer\",\"whitespace\")\n                    .put(\"index.analysis.analyzer.my_porter2.filter\",\"my_porter2\")\n                    .put(SETTING_VERSION_CREATED,v)\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_porter2\");\n            assertThat(tokenFilter, instanceOf(StemmerTokenFilterFactory.class));\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(\"foo bar\"));\n            TokenStream create = tokenFilter.create(tokenizer);\n            NamedAnalyzer analyzer = analysisService.analyzer(\"my_porter2\");\n            assertThat(create, instanceOf(SnowballFilter.class));\n\n            if (v.onOrAfter(Version.V_1_3_0)) {\n                assertAnalyzesTo(analyzer, \"possibly\", new String[]{\"possibl\"});\n            } else {\n                assertAnalyzesTo(analyzer, \"possibly\", new String[]{\"possibli\"});\n            }\n        }\n\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testEnglishBackwardsCompatibility() throws IOException {\n        int iters = scaledRandomIntBetween(20, 100);\n        for (int i = 0; i < iters; i++) {\n\n            Version v = VersionUtils.randomVersion(random());\n            Settings settings = ImmutableSettings.settingsBuilder()\n                    .put(\"index.analysis.filter.my_english.type\", \"stemmer\")\n                    .put(\"index.analysis.filter.my_english.language\", \"english\")\n                    .put(\"index.analysis.analyzer.my_english.tokenizer\",\"whitespace\")\n                    .put(\"index.analysis.analyzer.my_english.filter\",\"my_english\")\n                    .put(SETTING_VERSION_CREATED,v)\n                    .build();\n\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_english\");\n            assertThat(tokenFilter, instanceOf(StemmerTokenFilterFactory.class));\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(\"foo bar\"));\n            TokenStream create = tokenFilter.create(tokenizer);\n            NamedAnalyzer analyzer = analysisService.analyzer(\"my_english\");\n\n            if (v.onOrAfter(Version.V_1_3_0)) {\n                assertThat(create, instanceOf(PorterStemFilter.class));\n                assertAnalyzesTo(analyzer, \"consolingly\", new String[]{\"consolingli\"});\n            } else {\n                assertThat(create, instanceOf(SnowballFilter.class));\n                assertAnalyzesTo(analyzer, \"consolingly\", new String[]{\"consol\"});\n            }\n        }\n\n    }","id":85469,"modified_method":"@Test\n    public void testEnglishBackwardsCompatibility() throws IOException {\n        int iters = scaledRandomIntBetween(20, 100);\n        for (int i = 0; i < iters; i++) {\n\n            Version v = VersionUtils.randomVersion(random());\n            Settings settings = ImmutableSettings.settingsBuilder()\n                    .put(\"index.analysis.filter.my_english.type\", \"stemmer\")\n                    .put(\"index.analysis.filter.my_english.language\", \"english\")\n                    .put(\"index.analysis.analyzer.my_english.tokenizer\",\"whitespace\")\n                    .put(\"index.analysis.analyzer.my_english.filter\",\"my_english\")\n                    .put(SETTING_VERSION_CREATED,v)\n                    .put(\"path.home\", createTempDir().toString())\n                    .build();\n\n            AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n            TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_english\");\n            assertThat(tokenFilter, instanceOf(StemmerTokenFilterFactory.class));\n            Tokenizer tokenizer = new WhitespaceTokenizer();\n            tokenizer.setReader(new StringReader(\"foo bar\"));\n            TokenStream create = tokenFilter.create(tokenizer);\n            NamedAnalyzer analyzer = analysisService.analyzer(\"my_english\");\n\n            if (v.onOrAfter(Version.V_1_3_0)) {\n                assertThat(create, instanceOf(PorterStemFilter.class));\n                assertAnalyzesTo(analyzer, \"consolingly\", new String[]{\"consolingli\"});\n            } else {\n                assertThat(create, instanceOf(SnowballFilter.class));\n                assertAnalyzesTo(analyzer, \"consolingly\", new String[]{\"consol\"});\n            }\n        }\n\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDeprecatedPositionIncrementSettingWithVersions() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.my_stop.type\", \"stop\")\n                .put(\"index.analysis.filter.my_stop.enable_position_increments\", false).put(\"index.analysis.filter.my_stop.version\", \"4.3\")\n                .build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_stop\");\n        assertThat(tokenFilter, instanceOf(StopTokenFilterFactory.class));\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo bar\"));\n        TokenStream create = tokenFilter.create(tokenizer);\n        assertThat(create, instanceOf(Lucene43StopFilter.class));\n    }","id":85470,"modified_method":"@Test\n    public void testDeprecatedPositionIncrementSettingWithVersions() throws IOException {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.analysis.filter.my_stop.type\", \"stop\")\n                .put(\"index.analysis.filter.my_stop.enable_position_increments\", false)\n                .put(\"index.analysis.filter.my_stop.version\", \"4.3\")\n                .put(\"path.home\", createTempDir().toString())\n                .build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_stop\");\n        assertThat(tokenFilter, instanceOf(StopTokenFilterFactory.class));\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo bar\"));\n        TokenStream create = tokenFilter.create(tokenizer);\n        assertThat(create, instanceOf(Lucene43StopFilter.class));\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test(expected = ProvisionException.class)\n    public void testPositionIncrementSetting() throws IOException {\n        Builder builder = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.my_stop.type\", \"stop\")\n                .put(\"index.analysis.filter.my_stop.enable_position_increments\", false);\n        if (random().nextBoolean()) {\n            builder.put(\"index.analysis.filter.my_stop.version\", \"5.0\");\n        }\n        Settings settings = builder.build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        analysisService.tokenFilter(\"my_stop\");\n    }","id":85471,"modified_method":"@Test(expected = ProvisionException.class)\n    public void testPositionIncrementSetting() throws IOException {\n        Builder builder = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.my_stop.type\", \"stop\")\n                .put(\"index.analysis.filter.my_stop.enable_position_increments\", false);\n        if (random().nextBoolean()) {\n            builder.put(\"index.analysis.filter.my_stop.version\", \"5.0\");\n        }\n        builder.put(\"path.home\", createTempDir().toString());\n        Settings settings = builder.build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        analysisService.tokenFilter(\"my_stop\");\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testThatSuggestStopFilterWorks() throws Exception {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.analysis.filter.my_stop.type\", \"stop\")\n                .put(\"index.analysis.filter.my_stop.remove_trailing\", false)\n                .build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_stop\");\n        assertThat(tokenFilter, instanceOf(StopTokenFilterFactory.class));\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo an\"));\n        TokenStream create = tokenFilter.create(tokenizer);\n        assertThat(create, instanceOf(SuggestStopFilter.class));\n    }","id":85472,"modified_method":"@Test\n    public void testThatSuggestStopFilterWorks() throws Exception {\n        Settings settings = ImmutableSettings.settingsBuilder()\n                .put(\"index.analysis.filter.my_stop.type\", \"stop\")\n                .put(\"index.analysis.filter.my_stop.remove_trailing\", false)\n                .put(\"path.home\", createTempDir().toString())\n                .build();\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settings);\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_stop\");\n        assertThat(tokenFilter, instanceOf(StopTokenFilterFactory.class));\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo an\"));\n        TokenStream create = tokenFilter.create(tokenizer);\n        assertThat(create, instanceOf(SuggestStopFilter.class));\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCorrectPositionIncrementSetting() throws IOException {\n        Builder builder = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.my_stop.type\", \"stop\");\n        int thingToDo = random().nextInt(3);\n        if (thingToDo == 0) {\n            builder.put(\"index.analysis.filter.my_stop.version\", Version.LATEST);\n        } else if (thingToDo == 1) {\n            builder.put(\"index.analysis.filter.my_stop.version\", Version.LUCENE_4_0);\n            if (random().nextBoolean()) {\n                builder.put(\"index.analysis.filter.my_stop.enable_position_increments\", true);\n            }\n        } else {\n            // don't specify\n        }\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(builder.build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_stop\");\n        assertThat(tokenFilter, instanceOf(StopTokenFilterFactory.class));\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo bar\"));\n        TokenStream create = tokenFilter.create(tokenizer);\n        if (thingToDo == 1) {\n            assertThat(create, instanceOf(Lucene43StopFilter.class));\n        } else {\n            assertThat(create, instanceOf(StopFilter.class));\n        }\n    }","id":85473,"modified_method":"@Test\n    public void testCorrectPositionIncrementSetting() throws IOException {\n        Builder builder = ImmutableSettings.settingsBuilder().put(\"index.analysis.filter.my_stop.type\", \"stop\");\n        int thingToDo = random().nextInt(3);\n        if (thingToDo == 0) {\n            builder.put(\"index.analysis.filter.my_stop.version\", Version.LATEST);\n        } else if (thingToDo == 1) {\n            builder.put(\"index.analysis.filter.my_stop.version\", Version.LUCENE_4_0);\n            if (random().nextBoolean()) {\n                builder.put(\"index.analysis.filter.my_stop.enable_position_increments\", true);\n            }\n        } else {\n            // don't specify\n        }\n        builder.put(\"path.home\", createTempDir().toString());\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(builder.build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_stop\");\n        assertThat(tokenFilter, instanceOf(StopTokenFilterFactory.class));\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(\"foo bar\"));\n        TokenStream create = tokenFilter.create(tokenizer);\n        if (thingToDo == 1) {\n            assertThat(create, instanceOf(Lucene43StopFilter.class));\n        } else {\n            assertThat(create, instanceOf(StopFilter.class));\n        }\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSynonymsAnalysis() throws IOException {\n\n        Settings settings = settingsBuilder().\n                loadFromClasspath(\"org/elasticsearch/index/analysis/synonyms/synonyms.json\")\n                .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build();\n\n        Index index = new Index(\"test\");\n\n        Injector parentInjector = new ModulesBuilder().add(\n                new SettingsModule(settings),\n                new EnvironmentModule(new Environment(settings)),\n                new IndicesAnalysisModule())\n                .createInjector();\n        Injector injector = new ModulesBuilder().add(\n                new IndexSettingsModule(index, settings),\n                new IndexNameModule(index),\n                new AnalysisModule(settings, parentInjector.getInstance(IndicesAnalysisService.class)))\n                .createChildInjector(parentInjector);\n\n        analysisService = injector.getInstance(AnalysisService.class);\n\n        match(\"synonymAnalyzer\", \"kimchy is the dude abides\", \"shay is the elasticsearch man!\");\n        match(\"synonymAnalyzer_file\", \"kimchy is the dude abides\", \"shay is the elasticsearch man!\");\n        match(\"synonymAnalyzerWordnet\", \"abstain\", \"abstain refrain desist\");\n        match(\"synonymAnalyzerWordnet_file\", \"abstain\", \"abstain refrain desist\");\n        match(\"synonymAnalyzerWithsettings\", \"kimchy\", \"sha hay\");\n\n    }","id":85474,"modified_method":"@Test\n    public void testSynonymsAnalysis() throws IOException {\n        Settings settings = settingsBuilder().\n                loadFromClasspath(\"org/elasticsearch/index/analysis/synonyms/synonyms.json\")\n                .put(\"path.home\", createTempDir().toString())\n                .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build();\n\n        Index index = new Index(\"test\");\n\n        Injector parentInjector = new ModulesBuilder().add(\n                new SettingsModule(settings),\n                new EnvironmentModule(new Environment(settings)),\n                new IndicesAnalysisModule())\n                .createInjector();\n        Injector injector = new ModulesBuilder().add(\n                new IndexSettingsModule(index, settings),\n                new IndexNameModule(index),\n                new AnalysisModule(settings, parentInjector.getInstance(IndicesAnalysisService.class)))\n                .createChildInjector(parentInjector);\n\n        analysisService = injector.getInstance(AnalysisService.class);\n\n        match(\"synonymAnalyzer\", \"kimchy is the dude abides\", \"shay is the elasticsearch man!\");\n        match(\"synonymAnalyzer_file\", \"kimchy is the dude abides\", \"shay is the elasticsearch man!\");\n        match(\"synonymAnalyzerWordnet\", \"abstain\", \"abstain refrain desist\");\n        match(\"synonymAnalyzerWordnet_file\", \"abstain\", \"abstain refrain desist\");\n        match(\"synonymAnalyzerWithsettings\", \"kimchy\", \"sha hay\");\n\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"500\", \"42\", \"wi\", \"fi\", \"wi\", \"fi\", \"4000\", \"j\", \"2\", \"se\", \"O\", \"Neil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85475,"modified_method":"@Test\n    public void testDefault() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"500\", \"42\", \"wi\", \"fi\", \"wi\", \"fi\", \"4000\", \"j\", \"2\", \"se\", \"O\", \"Neil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCatenateAll() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"false\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_number_parts\", \"false\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_all\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"PowerShot\", \"50042\", \"wifi\", \"wifi4000\", \"j2se\", \"ONeil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85476,"modified_method":"@Test\n    public void testCatenateAll() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"false\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_number_parts\", \"false\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_all\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"PowerShot\", \"50042\", \"wifi\", \"wifi4000\", \"j2se\", \"ONeil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testStemEnglishPossessive() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.stem_english_possessive\", \"false\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"500\", \"42\", \"wi\", \"fi\", \"wi\", \"fi\", \"4000\", \"j\", \"2\", \"se\", \"O\", \"Neil\", \"s\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85477,"modified_method":"@Test\n    public void testStemEnglishPossessive() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.stem_english_possessive\", \"false\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"500\", \"42\", \"wi\", \"fi\", \"wi\", \"fi\", \"4000\", \"j\", \"2\", \"se\", \"O\", \"Neil\", \"s\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testPreserveOriginal() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.preserve_original\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"PowerShot\", \"Power\", \"Shot\", \"500-42\", \"500\", \"42\", \"wi-fi\", \"wi\", \"fi\", \"wi-fi-4000\", \"wi\", \"fi\", \"4000\", \"j2se\", \"j\", \"2\", \"se\", \"O'Neil's\", \"O\", \"Neil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85478,"modified_method":"@Test\n    public void testPreserveOriginal() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.preserve_original\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"PowerShot\", \"Power\", \"Shot\", \"500-42\", \"500\", \"42\", \"wi-fi\", \"wi\", \"fi\", \"wi-fi-4000\", \"wi\", \"fi\", \"4000\", \"j2se\", \"j\", \"2\", \"se\", \"O'Neil's\", \"O\", \"Neil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCatenateNumbers() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_number_parts\", \"false\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_numbers\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"50042\", \"wi\", \"fi\", \"wi\", \"fi\", \"4000\", \"j\", \"2\", \"se\", \"O\", \"Neil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85479,"modified_method":"@Test\n    public void testCatenateNumbers() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_number_parts\", \"false\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_numbers\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"50042\", \"wi\", \"fi\", \"wi\", \"fi\", \"4000\", \"j\", \"2\", \"se\", \"O\", \"Neil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testCatenateWords() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_words\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"false\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"PowerShot\", \"500\", \"42\", \"wifi\", \"wifi\", \"4000\", \"j\", \"2\", \"se\", \"ONeil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85480,"modified_method":"@Test\n    public void testCatenateWords() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_words\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"false\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot 500-42 wi-fi wi-fi-4000 j2se O'Neil's\";\n        String[] expected = new String[]{\"PowerShot\", \"500\", \"42\", \"wifi\", \"wifi\", \"4000\", \"j\", \"2\", \"se\", \"ONeil\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSplitOnCaseChange() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.split_on_case_change\", \"false\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot\";\n        String[] expected = new String[]{\"PowerShot\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85481,"modified_method":"@Test\n    public void testSplitOnCaseChange() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.split_on_case_change\", \"false\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot\";\n        String[] expected = new String[]{\"PowerShot\"};\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Back compat: \n     * old offset order when doing both parts and concatenation: PowerShot is a synonym of Shot */\n    @Test\n    public void testDeprecatedPartsAndCatenate() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_words\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.version\", \"4.7\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"PowerShot\" };\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85482,"modified_method":"/** Back compat: \n     * old offset order when doing both parts and concatenation: PowerShot is a synonym of Shot */\n    @Test\n    public void testDeprecatedPartsAndCatenate() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_words\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.version\", \"4.7\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot\";\n        String[] expected = new String[]{\"Power\", \"Shot\", \"PowerShot\" };\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Correct offset order when doing both parts and concatenation: PowerShot is a synonym of Power */\n    @Test\n    public void testPartsAndCatenate() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_words\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot\";\n        String[] expected = new String[]{\"Power\", \"PowerShot\", \"Shot\" };\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","id":85483,"modified_method":"/** Correct offset order when doing both parts and concatenation: PowerShot is a synonym of Power */\n    @Test\n    public void testPartsAndCatenate() throws IOException {\n        AnalysisService analysisService = AnalysisTestsHelper.createAnalysisServiceFromSettings(settingsBuilder()\n                .put(\"path.home\", createTempDir().toString())\n                .put(\"index.analysis.filter.my_word_delimiter.type\", \"word_delimiter\")\n                .put(\"index.analysis.filter.my_word_delimiter.catenate_words\", \"true\")\n                .put(\"index.analysis.filter.my_word_delimiter.generate_word_parts\", \"true\")\n                .build());\n        TokenFilterFactory tokenFilter = analysisService.tokenFilter(\"my_word_delimiter\");\n        String source = \"PowerShot\";\n        String[] expected = new String[]{\"Power\", \"PowerShot\", \"Shot\" };\n        Tokenizer tokenizer = new WhitespaceTokenizer();\n        tokenizer.setReader(new StringReader(source));\n        assertTokenStreamContents(tokenFilter.create(tokenizer), expected);\n    }","commit_id":"c0587cb24424138b5bd8a841d9229ff9dbbc3efd","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void onChange(List<ResourceChange> changes) {\n        for(final ResourceChange change : changes) {\n            log.trace(\"handleEvent: Detecting event {} for path '{}'\", change.getType(), change.getPath());\n\n            // if this change was on languageRootPath level this might change basename and locale as well, therefore\n            // invalidate everything\n            if (languageRootPaths.contains(change.getPath())) {\n                log.debug(\n                        \"handleEvent: Detected change of cached language root '{}', removing all cached ResourceBundles\",\n                        change.getPath());\n                scheduleReloadBundles(true);\n            } else {\n                // if it is only a change below a root path, only messages of one resource bundle can be affected!\n                for (final LanguageRoot root : languageRootPaths) {\n                    if (change.getPath().startsWith(root.path)) {\n                        // figure out which JcrResourceBundle from the cached ones is affected\n                        for (JcrResourceBundle bundle : resourceBundleCache.values()) {\n                            if (bundle.getLanguageRootPaths().contains(root)) {\n                                // reload it\n                                log.debug(\"handleEvent: Resource changes below '{}', reloading ResourceBundle '{}'\",\n                                        root, bundle);\n                                scheduleReloadBundle(bundle);\n                                return;\n                            }\n                        }\n                        log.debug(\"handleEvent: No cached resource bundle found with root '{}'\", root);\n                        break;\n                    }\n                }\n                // may be a completely new dictionary\n                if (isDictionaryResource(change)) {\n                    scheduleReloadBundles(true);\n                }\n            }\n        }\n    }","id":85484,"modified_method":"@Override\n    public void onChange(List<ResourceChange> changes) {\n        for(final ResourceChange change : changes) {\n            log.trace(\"handleEvent: Detecting event {} for path '{}'\", change.getType(), change.getPath());\n\n            // if this change was on languageRootPath level this might change basename and locale as well, therefore\n            // invalidate everything\n            if (languageRootPaths.contains(change.getPath())) {\n                log.debug(\n                        \"handleEvent: Detected change of cached language root '{}', removing all cached ResourceBundles\",\n                        change.getPath());\n                scheduleReloadBundles(true);\n            } else {\n                // if it is only a change below a root path, only messages of one resource bundle can be affected!\n                for (final String root : languageRootPaths) {\n                    if (change.getPath().startsWith(root)) {\n                        // figure out which JcrResourceBundle from the cached ones is affected\n                        for (JcrResourceBundle bundle : resourceBundleCache.values()) {\n                            if (bundle.getLanguageRootPaths().contains(root)) {\n                                // reload it\n                                log.debug(\"handleEvent: Resource changes below '{}', reloading ResourceBundle '{}'\",\n                                        root, bundle);\n                                scheduleReloadBundle(bundle);\n                                return;\n                            }\n                        }\n                        log.debug(\"handleEvent: No cached resource bundle found with root '{}'\", root);\n                        break;\n                    }\n                }\n                // may be a completely new dictionary\n                if (isDictionaryResource(change)) {\n                    scheduleReloadBundles(true);\n                }\n            }\n        }\n    }","commit_id":"e3444edbf41de86d43effe36179f9929d6ff5337","url":"https://github.com/apache/sling"},{"original_method":"private void registerResourceBundle(Key key, JcrResourceBundle resourceBundle) {\n        Dictionary<String, Object> serviceProps = new Hashtable<String, Object>();\n        if (key.baseName != null) {\n            serviceProps.put(\"baseName\", key.baseName);\n        }\n        serviceProps.put(\"locale\", key.locale.toString());\n        ServiceRegistration<ResourceBundle> serviceReg = bundleContext.registerService(ResourceBundle.class,\n                resourceBundle, serviceProps);\n        synchronized (this) {\n            bundleServiceRegistrations.put(key, serviceReg);\n        }\n\n        // register language root paths\n        final Set<String> languageRoots = resourceBundle.getLanguageRootPaths();\n        for(final String path : languageRoots) {\n            boolean found = this.languageRootPaths.contains(path);\n            if ( !found ) {\n                final Dictionary<String, Object> properties = new Hashtable<>();\n                properties.put(ResourceChangeListener.PATHS, path);\n                final ServiceRegistration<ResourceChangeListener> reg =\n                        this.bundleContext.registerService(ResourceChangeListener.class,\n                                this, properties);\n                final LanguageRoot root = new LanguageRoot(path, reg);\n                languageRootPaths.add(root);\n            }\n        }\n        log.debug(\"registerResourceBundle({}, ...): added service registration and language roots {}\", key, languageRoots);\n        log.info(\"Currently loaded dictionaries across all locales: {}\", languageRootPaths);\n    }","id":85485,"modified_method":"private void registerResourceBundle(Key key, JcrResourceBundle resourceBundle) {\n        Dictionary<String, Object> serviceProps = new Hashtable<String, Object>();\n        if (key.baseName != null) {\n            serviceProps.put(\"baseName\", key.baseName);\n        }\n        serviceProps.put(\"locale\", key.locale.toString());\n        ServiceRegistration<ResourceBundle> serviceReg = bundleContext.registerService(ResourceBundle.class,\n                resourceBundle, serviceProps);\n        synchronized (this) {\n            bundleServiceRegistrations.put(key, serviceReg);\n        }\n\n        // register language root paths\n        final Set<String> languageRoots = resourceBundle.getLanguageRootPaths();\n        this.languageRootPaths.addAll(languageRoots);\n\n        log.debug(\"registerResourceBundle({}, ...): added service registration and language roots {}\", key, languageRoots);\n        log.info(\"Currently loaded dictionaries across all locales: {}\", languageRootPaths);\n    }","commit_id":"e3444edbf41de86d43effe36179f9929d6ff5337","url":"https://github.com/apache/sling"},{"original_method":"private void clearCache() {\n        resourceBundleCache.clear();\n        for(final LanguageRoot root : this.languageRootPaths) {\n            root.registration.unregister();\n        }\n        languageRootPaths.clear();\n\n        synchronized (this) {\n            for (ServiceRegistration<ResourceBundle> serviceReg : bundleServiceRegistrations.values()) {\n                serviceReg.unregister();\n            }\n            bundleServiceRegistrations.clear();\n        }\n    }","id":85486,"modified_method":"private void clearCache() {\n        resourceBundleCache.clear();\n        languageRootPaths.clear();\n\n        synchronized (this) {\n            for (ServiceRegistration<ResourceBundle> serviceReg : bundleServiceRegistrations.values()) {\n                serviceReg.unregister();\n            }\n            bundleServiceRegistrations.clear();\n        }\n    }","commit_id":"e3444edbf41de86d43effe36179f9929d6ff5337","url":"https://github.com/apache/sling"},{"original_method":"public void foldIntoExisting(hudson.model.Queue.Item item, Task owner, List<Action> otherActions) {\n        CauseAction existing = item.getAction(CauseAction.class);\n        if (existing!=null) {\n            for (Cause c : this.causes) {\n                if (!existing.causes.contains(c)) existing.causes.add(c);\n            }\n            return;\n        }\n        // no CauseAction found, so add a copy of this one\n        item.getActions().add(new CauseAction(this));\n    }","id":85487,"modified_method":"public void foldIntoExisting(hudson.model.Queue.Item item, Task owner, List<Action> otherActions) {\n        CauseAction existing = item.getAction(CauseAction.class);\n        if (existing!=null) {\n            existing.causes.addAll(this.causes);\n            return;\n        }\n        // no CauseAction found, so add a copy of this one\n        item.getActions().add(new CauseAction(this));\n    }","commit_id":"a93e8517974c3ea5ce5a6b7ba59f652b74402c20","url":"https://github.com/kohsuke/hudson"},{"original_method":"public void testFoldableCauseAction() throws Exception {\n        final OneShotEvent buildStarted = new OneShotEvent();\n        final OneShotEvent buildShouldComplete = new OneShotEvent();\n\n        hudson.quietPeriod = 0;\n        FreeStyleProject project = createFreeStyleProject();\n        // Make build sleep a while so it blocks new builds\n        project.getBuildersList().add(new TestBuilder() {\n            public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n                buildStarted.signal();\n                buildShouldComplete.block();\n                return true;\n            }\n        });\n\n        // Start one build to block others\n        assertTrue(project.scheduleBuild(new UserCause()));\n        buildStarted.block(); // wait for the build to really start\n\n        // Schedule a new build, and trigger it many ways while it sits in queue\n        Future<FreeStyleBuild> fb = project.scheduleBuild2(0, new UserCause());\n        assertNotNull(fb);\n        assertFalse(project.scheduleBuild(new SCMTriggerCause()));\n        assertFalse(project.scheduleBuild(new UserCause()));\n        assertFalse(project.scheduleBuild(new TimerTriggerCause()));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"1.2.3.4\", \"test\")));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"4.3.2.1\", \"test\")));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"1.2.3.4\", \"test\")));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"1.2.3.4\", \"foo\")));\n        assertFalse(project.scheduleBuild(new SCMTriggerCause()));\n        assertFalse(project.scheduleBuild(new TimerTriggerCause()));\n\n        // Wait for 2nd build to finish\n        buildShouldComplete.signal();\n        FreeStyleBuild build = fb.get();\n\n        // make sure proper folding happened.\n        CauseAction ca = build.getAction(CauseAction.class);\n        assertNotNull(ca);\n        StringBuilder causes = new StringBuilder();\n        for (Cause c : ca.getCauses()) causes.append(c.getShortDescription() + \"\\n\");\n        assertEquals(\"Build causes should have only unique items\",\n                \"Started by user anonymous\\nStarted by an SCM change\\n\"\n                + \"Started by timer\\nStarted by remote host 1.2.3.4 with note: test\\n\"\n                + \"Started by remote host 4.3.2.1 with note: test\\n\"\n                + \"Started by remote host 1.2.3.4 with note: foo\\n\", causes.toString());\n    }","id":85488,"modified_method":"public void testFoldableCauseAction() throws Exception {\n        final OneShotEvent buildStarted = new OneShotEvent();\n        final OneShotEvent buildShouldComplete = new OneShotEvent();\n\n        hudson.quietPeriod = 0;\n        FreeStyleProject project = createFreeStyleProject();\n        // Make build sleep a while so it blocks new builds\n        project.getBuildersList().add(new TestBuilder() {\n            public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n                buildStarted.signal();\n                buildShouldComplete.block();\n                return true;\n            }\n        });\n\n        // Start one build to block others\n        assertTrue(project.scheduleBuild(new UserCause()));\n        buildStarted.block(); // wait for the build to really start\n\n        // Schedule a new build, and trigger it many ways while it sits in queue\n        Future<FreeStyleBuild> fb = project.scheduleBuild2(0, new UserCause());\n        assertNotNull(fb);\n        assertFalse(project.scheduleBuild(new SCMTriggerCause()));\n        assertFalse(project.scheduleBuild(new UserCause()));\n        assertFalse(project.scheduleBuild(new TimerTriggerCause()));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"1.2.3.4\", \"test\")));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"4.3.2.1\", \"test\")));\n        assertFalse(project.scheduleBuild(new SCMTriggerCause()));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"1.2.3.4\", \"test\")));\n        assertFalse(project.scheduleBuild(new RemoteCause(\"1.2.3.4\", \"foo\")));\n        assertFalse(project.scheduleBuild(new SCMTriggerCause()));\n        assertFalse(project.scheduleBuild(new TimerTriggerCause()));\n\n        // Wait for 2nd build to finish\n        buildShouldComplete.signal();\n        FreeStyleBuild build = fb.get();\n\n        // Make sure proper folding happened.\n        CauseAction ca = build.getAction(CauseAction.class);\n        assertNotNull(ca);\n        StringBuilder causes = new StringBuilder();\n        for (Cause c : ca.getCauses()) causes.append(c.getShortDescription() + \"\\n\");\n        assertEquals(\"Build causes should have all items, even duplicates\",\n                \"Started by user anonymous\\nStarted by an SCM change\\n\"\n                + \"Started by user anonymous\\nStarted by timer\\n\"\n                + \"Started by remote host 1.2.3.4 with note: test\\n\"\n                + \"Started by remote host 4.3.2.1 with note: test\\n\"\n                + \"Started by an SCM change\\n\"\n                + \"Started by remote host 1.2.3.4 with note: test\\n\"\n                + \"Started by remote host 1.2.3.4 with note: foo\\n\"\n                + \"Started by an SCM change\\nStarted by timer\\n\",\n                causes.toString());\n\n        // View for build should group duplicates\n        WebClient wc = new WebClient();\n        String buildPage = wc.getPage(build, \"\").asText();\n        assertTrue(\"Build page should combine duplicates and show counts: \" + buildPage,\n                   buildPage.contains(\"Started by user anonymous (2 times) \"\n                        + \"Started by an SCM change (3 times) \"\n                        + \"Started by timer (2 times) \"\n                        + \"Started by remote host 1.2.3.4 with note: test (2 times) \"\n                        + \"Started by remote host 4.3.2.1 with note: test \"\n                        + \"Started by remote host 1.2.3.4 with note: foo\"));\n    }","commit_id":"a93e8517974c3ea5ce5a6b7ba59f652b74402c20","url":"https://github.com/kohsuke/hudson"},{"original_method":"AuthSystem(final Database db, boolean enabled) {\n        AuthProvider ap = null;\n        LoginContext loginContext = null;\n        GSSManager gssManager = null;\n        byte [] principal = null;\n\n        m_enabled = enabled;\n        if (!m_enabled) {\n            m_authProvider = ap;\n            m_loginCtx = loginContext;\n            m_principalName = principal;\n            m_gssManager = null;\n            return;\n        }\n        m_authProvider = AuthProvider.fromProvider(db.getSecurityprovider());\n        if (m_authProvider == AuthProvider.KERBEROS) {\n            try {\n                loginContext = new LoginContext(VOLTDB_SERVICE_LOGIN_MODULE);\n            } catch (LoginException|SecurityException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"Cannot initialize JAAS LoginContext\", true, ex);\n            }\n            try {\n                loginContext.login();\n                principal = loginContext\n                        .getSubject()\n                        .getPrincipals()\n                        .iterator().next()\n                        .getName()\n                        .getBytes(Charsets.UTF_8)\n                        ;\n                gssManager = GSSManager.getInstance();\n            } catch (AccountExpiredException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB assigned service principal has expired\", true, ex);\n            } catch(CredentialExpiredException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB assigned service principal credentials have expired\", true, ex);\n            } catch(FailedLoginException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB failed to authenticate against kerberos\", true, ex);\n            }\n            catch (LoginException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB service principal failed to login\", true, ex);\n            }\n            catch (Exception ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"Unexpected exception occured during service authentication\", true, ex);\n            }\n        }\n        m_loginCtx = loginContext;\n        m_principalName = principal;\n        m_gssManager = gssManager;\n        /*\n         * First associate all users with groups and vice versa\n         */\n        for (org.voltdb.catalog.User catalogUser : db.getUsers()) {\n            String shadowPassword = catalogUser.getShadowpassword();\n            byte sha1ShadowPassword[] = null;\n            if (shadowPassword.length() == 40) {\n                /*\n                 * This is an old catalog with a SHA-1 password\n                 * Need to hex decode it\n                 */\n                sha1ShadowPassword = Encoder.hexDecode(shadowPassword);\n            } else if (shadowPassword.length() != 60) {\n                /*\n                 * If not 40 should be 60 since it is bcrypt\n                 */\n                VoltDB.crashGlobalVoltDB(\n                        \"Found a shadowPassword in the catalog that was in an unrecogized format\", true, null);\n            }\n\n            final AuthUser user = new AuthUser( sha1ShadowPassword, shadowPassword, catalogUser.getTypeName());\n            m_users.put(user.m_name, user);\n            for (org.voltdb.catalog.GroupRef catalogGroupRef : catalogUser.getGroups()) {\n                final org.voltdb.catalog.Group  catalogGroup = catalogGroupRef.getGroup();\n                AuthGroup group = null;\n                if (!m_groups.containsKey(catalogGroup.getTypeName())) {\n                    group = new AuthGroup(catalogGroup.getTypeName(), Permission.getPermissionSetForGroup(catalogGroup));\n                    m_groups.put(group.m_name, group);\n                } else {\n                    group = m_groups.get(catalogGroup.getTypeName());\n                }\n\n                for (Permission perm : group.m_permissions) {\n                    if (!user.m_permissions.contains(perm)) {\n                        user.m_permissions.add(perm);\n                    }\n                }\n\n                group.m_users.add(user);\n                user.m_groups.add(group);\n            }\n        }\n\n        for (org.voltdb.catalog.Group catalogGroup : db.getGroups()) {\n            AuthGroup group = null;\n            if (!m_groups.containsKey(catalogGroup.getTypeName())) {\n                group = new AuthGroup(catalogGroup.getTypeName(), Permission.getPermissionSetForGroup(catalogGroup));\n                m_groups.put(group.m_name, group);\n                //A group not associated with any users? Weird stuff.\n            } else {\n                group = m_groups.get(catalogGroup.getTypeName());\n            }\n        }\n\n        /*\n         * Then iterate through each procedure and and add it\n         * to the set of procedures for each specified user and for the members of\n         * each specified group.\n         */\n        for (org.voltdb.catalog.Procedure catalogProcedure : db.getProcedures()) {\n            for (org.voltdb.catalog.UserRef catalogUserRef : catalogProcedure.getAuthusers()) {\n                final org.voltdb.catalog.User catalogUser = catalogUserRef.getUser();\n                final AuthUser user = m_users.get(catalogUser.getTypeName());\n                if (user == null) {\n                    //Error case. Procedure has a user listed as authorized but no such user exists\n                } else {\n                    user.m_authorizedProcedures.add(catalogProcedure);\n                }\n            }\n\n            for (org.voltdb.catalog.GroupRef catalogGroupRef : catalogProcedure.getAuthgroups()) {\n                final org.voltdb.catalog.Group catalogGroup = catalogGroupRef.getGroup();\n                final AuthGroup group = m_groups.get(catalogGroup.getTypeName());\n                if (group == null) {\n                    //Error case. Procedure has a group listed as authorized but no such user exists\n                } else {\n                    for (AuthUser user : group.m_users) {\n                        user.m_authorizedProcedures.add(catalogProcedure);\n                    }\n                }\n            }\n        }\n\n        m_users = ImmutableMap.copyOf(m_users);\n        m_groups = ImmutableMap.copyOf(m_groups);\n        for (AuthUser user : m_users.values()) {\n            user.finish();\n        }\n        for (AuthGroup group : m_groups.values()) {\n            group.finish();\n        }\n    }","id":85489,"modified_method":"AuthSystem(final Database db, boolean enabled) {\n        AuthProvider ap = null;\n        LoginContext loginContext = null;\n        GSSManager gssManager = null;\n        byte [] principal = null;\n\n        m_enabled = enabled;\n        if (!m_enabled) {\n            m_authProvider = ap;\n            m_loginCtx = loginContext;\n            m_principalName = principal;\n            m_gssManager = null;\n            return;\n        }\n        m_authProvider = AuthProvider.fromProvider(db.getSecurityprovider());\n        if (m_authProvider == AuthProvider.KERBEROS) {\n            try {\n                loginContext = new LoginContext(VOLTDB_SERVICE_LOGIN_MODULE);\n            } catch (LoginException|SecurityException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"Cannot initialize JAAS LoginContext\", true, ex);\n            }\n            try {\n                loginContext.login();\n                principal = loginContext\n                        .getSubject()\n                        .getPrincipals()\n                        .iterator().next()\n                        .getName()\n                        .getBytes(Charsets.UTF_8)\n                        ;\n                gssManager = GSSManager.getInstance();\n            } catch (AccountExpiredException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB assigned service principal has expired\", true, ex);\n            } catch(CredentialExpiredException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB assigned service principal credentials have expired\", true, ex);\n            } catch(FailedLoginException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB failed to authenticate against kerberos\", true, ex);\n            }\n            catch (LoginException ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"VoltDB service principal failed to login\", true, ex);\n            }\n            catch (Exception ex) {\n                VoltDB.crashGlobalVoltDB(\n                        \"Unexpected exception occured during service authentication\", true, ex);\n            }\n        }\n        m_loginCtx = loginContext;\n        m_principalName = principal;\n        m_gssManager = gssManager;\n        /*\n         * First associate all users with groups and vice versa\n         */\n        for (org.voltdb.catalog.User catalogUser : db.getUsers()) {\n            String shadowPassword = catalogUser.getShadowpassword();\n            byte sha1ShadowPassword[] = null;\n            if (shadowPassword.length() == 40) {\n                /*\n                 * This is an old catalog with a SHA-1 password\n                 * Need to hex decode it\n                 */\n                sha1ShadowPassword = Encoder.hexDecode(shadowPassword);\n            } else if (shadowPassword.length() != 60) {\n                /*\n                 * If not 40 should be 60 since it is bcrypt\n                 */\n                VoltDB.crashGlobalVoltDB(\n                        \"Found a shadowPassword in the catalog that was in an unrecogized format\", true, null);\n            }\n\n            final AuthUser user = new AuthUser( sha1ShadowPassword, shadowPassword, catalogUser.getTypeName());\n            m_users.put(user.m_name, user);\n            for (org.voltdb.catalog.GroupRef catalogGroupRef : catalogUser.getGroups()) {\n                final org.voltdb.catalog.Group  catalogGroup = catalogGroupRef.getGroup();\n                AuthGroup group = null;\n                if (!m_groups.containsKey(catalogGroup.getTypeName())) {\n                    group = new AuthGroup(catalogGroup.getTypeName(), Permission.getPermissionSetForGroup(catalogGroup));\n                    m_groups.put(group.m_name, group);\n                } else {\n                    group = m_groups.get(catalogGroup.getTypeName());\n                }\n\n                user.m_permissions.addAll(group.m_permissions);\n\n                group.m_users.add(user);\n                user.m_groups.add(group);\n            }\n        }\n\n        for (org.voltdb.catalog.Group catalogGroup : db.getGroups()) {\n            AuthGroup group = null;\n            if (!m_groups.containsKey(catalogGroup.getTypeName())) {\n                group = new AuthGroup(catalogGroup.getTypeName(), Permission.getPermissionSetForGroup(catalogGroup));\n                m_groups.put(group.m_name, group);\n                //A group not associated with any users? Weird stuff.\n            } else {\n                group = m_groups.get(catalogGroup.getTypeName());\n            }\n        }\n\n        /*\n         * Then iterate through each procedure and and add it\n         * to the set of procedures for each specified user and for the members of\n         * each specified group.\n         */\n        for (org.voltdb.catalog.Procedure catalogProcedure : db.getProcedures()) {\n            for (org.voltdb.catalog.UserRef catalogUserRef : catalogProcedure.getAuthusers()) {\n                final org.voltdb.catalog.User catalogUser = catalogUserRef.getUser();\n                final AuthUser user = m_users.get(catalogUser.getTypeName());\n                if (user == null) {\n                    //Error case. Procedure has a user listed as authorized but no such user exists\n                } else {\n                    user.m_authorizedProcedures.add(catalogProcedure);\n                }\n            }\n\n            for (org.voltdb.catalog.GroupRef catalogGroupRef : catalogProcedure.getAuthgroups()) {\n                final org.voltdb.catalog.Group catalogGroup = catalogGroupRef.getGroup();\n                final AuthGroup group = m_groups.get(catalogGroup.getTypeName());\n                if (group == null) {\n                    //Error case. Procedure has a group listed as authorized but no such user exists\n                } else {\n                    for (AuthUser user : group.m_users) {\n                        user.m_authorizedProcedures.add(catalogProcedure);\n                    }\n                }\n            }\n        }\n\n        m_users = ImmutableMap.copyOf(m_users);\n        m_groups = ImmutableMap.copyOf(m_groups);\n        for (AuthUser user : m_users.values()) {\n            user.finish();\n        }\n        for (AuthGroup group : m_groups.values()) {\n            group.finish();\n        }\n    }","commit_id":"3959b17096b654f678b23558c8173edd9384d948","url":"https://github.com/VoltDB/voltdb"},{"original_method":"protected void releaseReader(IndexReader reader) {\n        try {\n            cachedReader.close();\n        } catch (IOException e) {\n            LOG.warn(\"Exception while closing lucene index: \" + e.getMessage(), e);\n        } finally {\n            cachedReader = null;\n        }\n    }","id":85490,"modified_method":"protected void releaseReader(IndexReader reader) {\n        if (reader != cachedReader)\n            throw new IllegalStateException(\"IndexReader was not obtained from getReader().\");\n        try {\n            cachedReader.close();\n        } catch (IOException e) {\n            LOG.warn(\"Exception while closing lucene index: \" + e.getMessage(), e);\n        } finally {\n            cachedReader = null;\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void releaseWriter(IndexWriter writer) {\n        try {\n            cachedWriter.close();\n        } catch (IOException e) {\n            LOG.warn(\"Exception while closing lucene index: \" + e.getMessage(), e);\n        } finally {\n            cachedWriter = null;\n        }\n    }","id":85491,"modified_method":"protected void releaseWriter(IndexWriter writer) {\n        if (writer != cachedWriter)\n            throw new IllegalStateException(\"IndexWriter was not obtained from getWriter().\");\n        try {\n            cachedWriter.close();\n        } catch (IOException e) {\n            LOG.warn(\"Exception while closing lucene index: \" + e.getMessage(), e);\n        } finally {\n            cachedWriter = null;\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"@Before\n    public void setup() {\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n\n            transact.commit(transaction);\n        } catch (Exception e) {\n            e.printStackTrace();\n            transact.abort(transaction);\n            fail(e.getMessage());\n        } finally {\n            if (pool != null)\n                pool.release(broker);\n        }\n    }","id":85492,"modified_method":"@Before\n    public void setup() {\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n\n            transact.commit(transaction);\n\n            Configuration config = BrokerPool.getInstance().getConfiguration();\n            savedConfig = (Boolean) config.getProperty(Indexer.PROPERTY_PRESERVE_WS_MIXED_CONTENT);\n            config.setProperty(Indexer.PROPERTY_PRESERVE_WS_MIXED_CONTENT, Boolean.TRUE);\n        } catch (Exception e) {\n            e.printStackTrace();\n            transact.abort(transaction);\n            fail(e.getMessage());\n        } finally {\n            if (pool != null)\n                pool.release(broker);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"@BeforeClass\n    public static void startDB() {\n        try {\n            File confFile = ConfigurationHelper.lookup(\"conf.xml\");\n            Configuration config = new Configuration(confFile.getAbsolutePath());\n            BrokerPool.configure(1, 5, config);\n            pool = BrokerPool.getInstance();\n        \tassertNotNull(pool);\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","id":85493,"modified_method":"@BeforeClass\n    public static void startDB() {\n        try {\n            File confFile = ConfigurationHelper.lookup(\"conf.xml\");\n            Configuration config = new Configuration(confFile.getAbsolutePath());\n            config.setProperty(Indexer.PROPERTY_SUPPRESS_WHITESPACE, \"none\");\n            config.setProperty(Indexer.PRESERVE_WS_MIXED_CONTENT_ATTRIBUTE, Boolean.TRUE);\n            BrokerPool.configure(1, 5, config);\n            pool = BrokerPool.getInstance();\n        \tassertNotNull(pool);\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"@Test\n    public void dropDocument() {\n        DocumentSet docs = configureAndStore(COLLECTION_CONFIG1, XML1, \"dropDocument.xml\");\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            System.out.println(\"Removing document dropDocument.xml\");\n            root.removeXMLResource(transaction, broker, XmldbURI.create(\"dropDocument.xml\"));\n            transact.commit(transaction);\n\n            checkIndex(docs, broker, null, null, 0);\n        } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","id":85494,"modified_method":"@Test\n    public void dropDocuments() {\n        System.out.println(\"Test removal of multiple documents ...\");\n        DocumentSet docs = configureAndStore(COLLECTION_CONFIG1, \"samples/shakespeare\");\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//LINE[ft:query(., 'bark')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            assertEquals(6, seq.getItemCount());\n\n            System.out.println(\"Removing document r_and_j.xml\");\n            root.removeXMLResource(transaction, broker, XmldbURI.create(\"r_and_j.xml\"));\n            transact.commit(transaction);\n\n            seq = xquery.execute(\"//LINE[ft:query(., 'bark')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            assertEquals(3, seq.getItemCount());\n\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Removing document hamlet.xml\");\n            root.removeXMLResource(transaction, broker, XmldbURI.create(\"hamlet.xml\"));\n            transact.commit(transaction);\n\n            seq = xquery.execute(\"//LINE[ft:query(., 'bark')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            assertEquals(1, seq.getItemCount());\n\n            System.out.println(\"Test PASSED.\");\n        } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"private Occurrences[] checkIndex(DocumentSet docs, DBBroker broker, QName[] qn, String term, int expected) throws PermissionDeniedException {\n        LuceneIndexWorker index = (LuceneIndexWorker)\n            broker.getIndexController().getWorkerByIndexId(LuceneIndex.ID);\n        Map hints = new HashMap();\n        if (term != null)\n            hints.put(OrderedValuesIndex.START_VALUE, term);\n        if (qn != null && qn.length > 0) {\n            List qnames = new ArrayList();\n            for (int i = 0; i < qn.length; i++) {\n                qnames.add(qn[i]);\n            }\n            hints.put(QNamedKeysIndex.QNAMES_KEY, qnames);\n        }\n        XQueryContext context = new XQueryContext(broker, AccessContext.TEST);\n        Occurrences[] occur = index.scanIndex(context, docs, docs.docsToNodeSet(), hints);\n        return occur;\n    }","id":85495,"modified_method":"private Occurrences[] checkIndex(DocumentSet docs, DBBroker broker, QName[] qn, String term, int expected) throws PermissionDeniedException {\n        LuceneIndexWorker index = (LuceneIndexWorker)\n            broker.getIndexController().getWorkerByIndexId(LuceneIndex.ID);\n        Map hints = new HashMap();\n        if (term != null)\n            hints.put(OrderedValuesIndex.START_VALUE, term);\n        if (qn != null && qn.length > 0) {\n            List qnames = new ArrayList();\n            for (int i = 0; i < qn.length; i++) {\n                qnames.add(qn[i]);\n            }\n            hints.put(QNamedKeysIndex.QNAMES_KEY, qnames);\n        }\n        XQueryContext context = new XQueryContext(broker, AccessContext.TEST);\n        Occurrences[] occur = index.scanIndex(context, docs, docs.docsToNodeSet(), hints);\n        if (expected != occur.length) {\n            for (int i = 0; i < occur.length; i++) {\n                System.out.println(\"term: \" + occur[i].getTerm());              \n            }\n        }\n        assertEquals(expected, occur.length);\n        return occur;\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"@After\n    public void cleanup() {\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            pool = BrokerPool.getInstance();\n            assertNotNull(pool);\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            Collection config = broker.getOrCreateCollection(transaction,\n                XmldbURI.create(CollectionConfigurationManager.CONFIG_COLLECTION + \"/db\"));\n            assertNotNull(config);\n            broker.removeCollection(transaction, config);\n\n            assertNotNull(root);\n            broker.removeCollection(transaction, root);\n\n            transact.commit(transaction);\n        } catch (Exception e) {\n        \ttransact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","id":85496,"modified_method":"@After\n    public void cleanup() {\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            pool = BrokerPool.getInstance();\n            assertNotNull(pool);\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            Collection collConfig = broker.getOrCreateCollection(transaction,\n                XmldbURI.create(CollectionConfigurationManager.CONFIG_COLLECTION + \"/db\"));\n            assertNotNull(collConfig);\n            broker.removeCollection(transaction, collConfig);\n\n            if (root != null) {\n                assertNotNull(root);\n                broker.removeCollection(transaction, root);\n            }\n            transact.commit(transaction);\n\n            Configuration config = BrokerPool.getInstance().getConfiguration();\n            config.setProperty(Indexer.PROPERTY_PRESERVE_WS_MIXED_CONTENT, savedConfig);\n        } catch (Exception e) {\n        \ttransact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"@Test\n    public void removeCollection() {\n        DocumentSet docs = configureAndStore(COLLECTION_CONFIG1, \"samples/shakespeare\");\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//SPEECH[ft:query(LINE, 'love')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            System.out.println(\"Found: \" + seq.getItemCount());\n            assertEquals(166, seq.getItemCount());\n\n            System.out.println(\"Removing collection\");\n            root.removeCollection(root.getURI());\n            transact.commit(transaction);\n\n            checkIndex(docs, broker, null, null, 0);\n        } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","id":85497,"modified_method":"@Test\n    public void removeCollection() {\n        System.out.println(\"Test removal of collection ...\");\n        DocumentSet docs = configureAndStore(COLLECTION_CONFIG1, \"samples/shakespeare\");\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n\n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//SPEECH[ft:query(LINE, 'love')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            System.out.println(\"Found: \" + seq.getItemCount());\n            assertEquals(166, seq.getItemCount());\n\n            System.out.println(\"Removing collection\");\n            broker.removeCollection(transaction, root);\n\n            root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            transact.commit(transaction);\n\n            root = null;\n            \n            checkIndex(docs, broker, null, null, 0);\n\n            System.out.println(\"Test PASSED.\");\n        } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"@Test\n    public void simpleQueries() {\n        DocumentSet docs = configureAndStore(COLLECTION_CONFIG1, XML1, \"test.xml\");\n        DBBroker broker = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n\n            checkIndex(docs, broker, new QName[] { new QName(\"head\", \"\") }, \"title\", 1);\n            checkIndex(docs, broker, new QName[] { new QName(\"p\", \"\") }, \"with\", 2);\n            checkIndex(docs, broker, null, \"in\", 2);\n            \n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"/section[ft:query(p, 'content')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            assertEquals(1, seq.getItemCount());\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","id":85498,"modified_method":"@Test\n    public void simpleQueries() {\n        System.out.println(\"Test simple queries ...\");\n        DocumentSet docs = configureAndStore(COLLECTION_CONFIG1, XML1, \"test.xml\");\n        DBBroker broker = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n\n            checkIndex(docs, broker, new QName[] { new QName(\"head\", \"\") }, \"title\", 1);\n            Occurrences[] o = checkIndex(docs, broker, new QName[]{new QName(\"p\", \"\")}, \"with\", 1);\n            assertEquals(2, o[0].getOccurrences());\n            checkIndex(docs, broker, new QName[] { new QName(\"hi\", \"\") }, \"just\", 1);\n            checkIndex(docs, broker, null, \"in\", 2);\n\n            QName attrQN = new QName(\"rend\", \"\");\n            attrQN.setNameType(ElementValue.ATTRIBUTE);\n            checkIndex(docs, broker, new QName[] { attrQN }, null, 2);\n            checkIndex(docs, broker, new QName[] { attrQN }, \"center\", 1);\n            checkIndex(docs, broker, new QName[] { attrQN }, \"right\", 1);\n\n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"/section[ft:query(p, 'content')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            assertEquals(1, seq.getItemCount());\n\n            seq = xquery.execute(\"/section[ft:query(p/@rend, 'center')]\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            assertEquals(1, seq.getItemCount());\n\n            System.out.println(\"Test PASSED.\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public void removeCollection(Collection collection, DBBroker broker) {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Removing collection \" + collection.getURI());\n        IndexReader reader = null;\n        try {\n            reader = index.getReader();\n            for (Iterator i = collection.iterator(broker); i.hasNext(); ) {\n                DocumentImpl doc = (DocumentImpl) i.next();\n                Term dt = new Term(\"docId\", Integer.toString(doc.getDocId()));\n                reader.deleteDocuments(dt);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            index.releaseReader(reader);\n        }\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Collection removed.\");\n    }","id":85499,"modified_method":"public void removeCollection(Collection collection, DBBroker broker) {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Removing collection \" + collection.getURI());\n        IndexReader reader = null;\n        try {\n            reader = index.getReader();\n            for (Iterator i = collection.iterator(broker); i.hasNext(); ) {\n                DocumentImpl doc = (DocumentImpl) i.next();\n                Term dt = new Term(\"docId\", Integer.toString(doc.getDocId()));\n                TermDocs td = reader.termDocs(dt);\n                while (td.next()) {\n                    reader.deleteDocument(td.doc());\n                }\n            }\n            reader.flush();\n        } catch (IOException e) {\n            LOG.warn(\"Error while removing lucene index: \" + e.getMessage(), e);\n        } finally {\n            index.releaseReader(reader);\n        }\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Collection removed.\");\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public void endElement(Txn transaction, ElementImpl element, NodePath path) {\n            if (mode != REMOVE_ALL_NODES && config != null && config.get(element.getQName()) != null) {\n                XMLString content = (XMLString) contentStack.pop();\n                indexText(element.getNodeId(), element.getQName(), content);\n            }\n            super.endElement(transaction, element, path);\n        }","id":85500,"modified_method":"public void endElement(Txn transaction, ElementImpl element, NodePath path) {\n            if (mode != REMOVE_ALL_NODES && config != null && config.get(element.getQName()) != null) {\n                if (mode == REMOVE_SOME_NODES) {\n                    nodesToRemove.add(element.getNodeId());\n                } else {\n                    XMLString content = (XMLString) contentStack.pop();\n                    indexText(element.getNodeId(), element.getQName(), content);\n                }\n            }\n            super.endElement(transaction, element, path);\n        }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public void flush() {\n        try {\n            switch (mode) {\n                case StreamListener.STORE:\n                    if (writer != null) {\n                        writer.flush();\n                        index.releaseWriter(writer);\n                    }\n                    writer = null;\n                    break;\n                case StreamListener.REMOVE_ALL_NODES:\n                    removeDocument(currentDoc.getDocId());\n                    break;\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Caught an exception while flushing lucene index: \" + e.getMessage(), e);\n        }\n    }","id":85501,"modified_method":"public void flush() {\n        try {\n            switch (mode) {\n                case StreamListener.STORE:\n                    if (writer != null) {\n                        writer.flush();\n                        index.releaseWriter(writer);\n                    }\n                    writer = null;\n                    break;\n                case StreamListener.REMOVE_ALL_NODES:\n                    removeDocument(currentDoc.getDocId());\n                    break;\n                case StreamListener.REMOVE_SOME_NODES:\n                    removeNodes();\n                    break;\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Caught an exception while flushing lucene index: \" + e.getMessage(), e);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void indexText(NodeId nodeId, QName qname, XMLString content) {\n        if (writer == null)\n            return;\n        Document doc = new Document();\n\n        // store the node id\n        int nodeIdLen = nodeId.size();\n        byte[] data = new byte[nodeIdLen + 2];\n        ByteConversion.shortToByte((short) nodeId.units(), data, 0);\n        nodeId.serialize(data, 2);\n\n        String contentField = encodeQName(qname);\n\n        doc.add(new Field(\"docId\", Integer.toString(currentDoc.getDocId()),\n                Field.Store.COMPRESS,  Field.Index.UN_TOKENIZED));\n        doc.add(new Field(\"nodeId\", data, Field.Store.YES));\n        doc.add(new Field(contentField, content.toString(), Field.Store.NO, Field.Index.TOKENIZED));\n\n        try {\n            writer.addDocument(doc);\n        } catch (IOException e) {\n            LOG.warn(\"An exception was caught while indexing document: \" + e.getMessage(), e);\n        }\n    }","id":85502,"modified_method":"/**\n     * Adds the passed character sequence to the lucene index. We\n     * create one lucene document per XML node, using 2 fields to identify\n     * the node:\n     *\n     * <ul>\n     *  <li>docId: eXist-internal document id of the node, stored as string.<\/li>\n     *  <li>nodeId: the id of the node, stored in binary compressed form.<\/li>\n     * <\/ul>\n     *\n     * The text is indexed into a field whose name encodes the qualified name of\n     * the node. The qualified name is stored as a hex sequence pointing into the\n     * global symbol table.\n     *\n     * @param nodeId\n     * @param qname\n     * @param content\n     */\n    protected void indexText(NodeId nodeId, QName qname, CharSequence content) {\n        if (writer == null)\n            return;\n        Document doc = new Document();\n\n        // store the node id\n        int nodeIdLen = nodeId.size();\n        byte[] data = new byte[nodeIdLen + 2];\n        ByteConversion.shortToByte((short) nodeId.units(), data, 0);\n        nodeId.serialize(data, 2);\n\n        String contentField = encodeQName(qname);\n\n        doc.add(new Field(\"docId\", Integer.toString(currentDoc.getDocId()),\n                Field.Store.COMPRESS,  Field.Index.UN_TOKENIZED));\n        doc.add(new Field(\"nodeId\", data, Field.Store.YES));\n        doc.add(new Field(contentField, content.toString(), Field.Store.NO, Field.Index.TOKENIZED));\n\n        try {\n            writer.addDocument(doc);\n        } catch (IOException e) {\n            LOG.warn(\"An exception was caught while indexing document: \" + e.getMessage(), e);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public Object configure(IndexController controller, NodeList configNodes, Map namespaces) throws DatabaseConfigurationException {\n        this.controller = controller;\n        LOG.debug(\"Configuring lucene index\");\n        // We use a map to store the QNames to be indexed\n        Map map = new TreeMap();\n        Node node;\n        for(int i = 0; i < configNodes.getLength(); i++) {\n            node = configNodes.item(i);\n            if(node.getNodeType() == Node.ELEMENT_NODE &&\n                    INDEX_ELEMENT.equals(node.getLocalName())) {\n                String qname = ((Element)node).getAttribute(QNAME_ATTR);\n                if (qname == null || qname.length() == 0)\n                    throw new DatabaseConfigurationException(\"Configuration error: element \" + node.getNodeName() +\n\t                \t\t\" must have an attribute \" + QNAME_ATTR);\n                LuceneIndexConfig config = new LuceneIndexConfig(namespaces, qname);\n                map.put(config.getQName(), config);\n            }\n        }\n        return map;\n    }","id":85503,"modified_method":"public Object configure(IndexController controller, NodeList configNodes, Map namespaces) throws DatabaseConfigurationException {\n        this.controller = controller;\n        LOG.debug(\"Configuring lucene index\");\n        // We use a map to store the QNames to be indexed\n        Map map = new TreeMap();\n        parseConfig(configNodes, namespaces, map);\n        return map;\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public void setMode(int mode) {\n        this.mode = mode;\n        try {\n            switch (mode) {\n                case StreamListener.STORE:\n                    writer = index.getWriter();\n                    break;\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Caught exception while preparing lucene index: \" + e.getMessage(), e);\n        }\n    }","id":85504,"modified_method":"public void setMode(int mode) {\n        this.mode = mode;\n        try {\n            switch (mode) {\n                case StreamListener.STORE:\n                    writer = index.getWriter();\n                    break;\n                case StreamListener.REMOVE_SOME_NODES:\n                    nodesToRemove = new TreeSet();\n                    break;\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Caught exception while preparing lucene index: \" + e.getMessage(), e);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void removeDocument(int docId) {\n        IndexReader reader = null;\n        try {\n            reader = index.getReader();\n            Term dt = new Term(\"docId\", Integer.toString(docId));\n            reader.deleteDocuments(dt);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            index.releaseReader(reader);\n        }\n    }","id":85505,"modified_method":"protected void removeDocument(int docId) {\n        IndexReader reader = null;\n        try {\n            reader = index.getReader();\n            Term dt = new Term(\"docId\", Integer.toString(docId));\n            reader.deleteDocuments(dt);\n        } catch (IOException e) {\n            LOG.warn(\"Error while removing lucene index: \" + e.getMessage(), e);\n        } finally {\n            index.releaseReader(reader);\n        }\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public NodeSet query(XQueryContext context, int contextId, DocumentSet docs, NodeSet contextSet,\n        List qnames, String queryStr, int axis)\n        throws IOException, ParseException {\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes(context.getBroker(), docs);\n        NodeSet resultSet = new NewArrayNodeSet();\n        boolean returnAncestor = axis == NodeSet.ANCESTOR;\n        IndexSearcher searcher = null;\n        try {\n            searcher = index.getSearcher();\n            for (int i = 0; i < qnames.size(); i++) {\n                QName qname = (QName) qnames.get(i);\n                String field = encodeQName(qname);\n                QueryParser parser = new QueryParser(field, index.getAnalyzer());\n                Query query = parser.parse(queryStr);\n                Hits hits = searcher.search(query);\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Found \" + hits.length());\n                for (int j = 0; j < hits.length(); j++) {\n                    Document doc = hits.doc(j);\n                    Field fDocId = doc.getField(\"docId\");\n                    int docId = Integer.parseInt(fDocId.stringValue());\n                    DocumentImpl storedDocument = docs.getDoc(docId);\n                    if (storedDocument == null)\n                        continue;\n                    NodeId nodeId = readNodeId(doc);\n                    NodeProxy storedNode = new NodeProxy(storedDocument, nodeId);\n                    // if a context set is specified, we can directly check if the\n                    // matching node is a descendant of one of the nodes\n                    // in the context set.\n                    if (contextSet != null) {\n                        int sizeHint = contextSet.getSizeHint(storedDocument);\n                        if (returnAncestor) {\n                            NodeProxy parentNode = contextSet.parentWithChild(storedNode, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);\n                            if (parentNode != null) {\n                                LuceneMatch match = new LuceneMatch(contextId, nodeId, query);\n                                match.setScore(hits.score(j));\n                                parentNode.addMatch(match);\n                                resultSet.add(parentNode, sizeHint);\n                                if (Expression.NO_CONTEXT_ID != contextId) {\n                                    parentNode.deepCopyContext(storedNode, contextId);\n                                } else\n                                    parentNode.copyContext(storedNode);\n                            }\n                        } else {\n                            LuceneMatch match = new LuceneMatch(contextId, nodeId, query);\n                            match.setScore(hits.score(j));\n                            storedNode.addMatch(match);\n                            resultSet.add(storedNode, sizeHint);\n                        }\n                    } else {\n                        LuceneMatch match = new LuceneMatch(contextId, nodeId, query);\n                        match.setScore(hits.score(j));\n                        storedNode.addMatch(match);\n                        resultSet.add(storedNode);\n                    }\n                }\n            }\n        } finally {\n            index.releaseSearcher(searcher);\n        }\n        return resultSet;\n    }","id":85506,"modified_method":"/**\n     * Query the index. Returns a node set containing all matching nodes. Each node\n     * in the node set has a {@link org.exist.indexing.lucene.LuceneIndexWorker.LuceneMatch}\n     * element attached, which stores the score and a link to the query which generated it.\n     *\n     * @param context current XQuery context\n     * @param contextId current context id, identify to track the position inside nested XPath predicates\n     * @param docs query will be restricted to documents in this set\n     * @param contextSet if specified, returned nodes will be descendants of the nodes in this set\n     * @param qnames query will be restricted to nodes with the qualified names given here\n     * @param queryStr a lucene query string\n     * @param axis which node is returned: the node in which a match was found or the corresponding ancestor\n     *  from the contextSet\n     * @return node set containing all matching nodes\n     * \n     * @throws IOException\n     * @throws ParseException\n     */\n    public NodeSet query(XQueryContext context, int contextId, DocumentSet docs, NodeSet contextSet,\n        List qnames, String queryStr, int axis)\n        throws IOException, ParseException {\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes(context.getBroker(), docs);\n        NodeSet resultSet = new NewArrayNodeSet();\n        boolean returnAncestor = axis == NodeSet.ANCESTOR;\n        IndexSearcher searcher = null;\n        try {\n            searcher = index.getSearcher();\n            for (int i = 0; i < qnames.size(); i++) {\n                QName qname = (QName) qnames.get(i);\n                String field = encodeQName(qname);\n                QueryParser parser = new QueryParser(field, index.getAnalyzer());\n                Query query = parser.parse(queryStr);\n                Hits hits = searcher.search(query);\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Found \" + hits.length());\n                for (int j = 0; j < hits.length(); j++) {\n                    Document doc = hits.doc(j);\n                    Field fDocId = doc.getField(\"docId\");\n                    int docId = Integer.parseInt(fDocId.stringValue());\n                    DocumentImpl storedDocument = docs.getDoc(docId);\n                    if (storedDocument == null)\n                        continue;\n                    NodeId nodeId = readNodeId(doc);\n                    NodeProxy storedNode = new NodeProxy(storedDocument, nodeId);\n                    // if a context set is specified, we can directly check if the\n                    // matching node is a descendant of one of the nodes\n                    // in the context set.\n                    if (contextSet != null) {\n                        int sizeHint = contextSet.getSizeHint(storedDocument);\n                        if (returnAncestor) {\n                            NodeProxy parentNode = contextSet.parentWithChild(storedNode, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);\n                            if (parentNode != null) {\n                                LuceneMatch match = new LuceneMatch(contextId, nodeId, query);\n                                match.setScore(hits.score(j));\n                                parentNode.addMatch(match);\n                                resultSet.add(parentNode, sizeHint);\n                                if (Expression.NO_CONTEXT_ID != contextId) {\n                                    parentNode.deepCopyContext(storedNode, contextId);\n                                } else\n                                    parentNode.copyContext(storedNode);\n                            }\n                        } else {\n                            LuceneMatch match = new LuceneMatch(contextId, nodeId, query);\n                            match.setScore(hits.score(j));\n                            storedNode.addMatch(match);\n                            resultSet.add(storedNode, sizeHint);\n                        }\n                    } else {\n                        LuceneMatch match = new LuceneMatch(contextId, nodeId, query);\n                        match.setScore(hits.score(j));\n                        storedNode.addMatch(match);\n                        resultSet.add(storedNode);\n                    }\n                }\n            }\n        } finally {\n            index.releaseSearcher(searcher);\n        }\n        return resultSet;\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public void startElement(Txn transaction, ElementImpl element, NodePath path) {\n            if (mode != REMOVE_ALL_NODES && config != null && config.get(element.getQName()) != null) {\n                if (contentStack == null) contentStack = new Stack();\n                XMLString contentBuf = new XMLString();\n                contentStack.push(contentBuf);\n            }\n            super.startElement(transaction, element, path);\n        }","id":85507,"modified_method":"public void startElement(Txn transaction, ElementImpl element, NodePath path) {\n            if (mode == STORE && config != null && config.get(element.getQName()) != null) {\n                if (contentStack == null) contentStack = new Stack();\n                XMLString contentBuf = new XMLString();\n                contentStack.push(contentBuf);\n            }\n            super.startElement(transaction, element, path);\n        }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public Occurrences[] scanIndex(XQueryContext context, DocumentSet docs, NodeSet contextSet, Map hints) {\n        List qnames = hints == null ? null : (List)hints.get(QNAMES_KEY);\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes(context.getBroker(), docs);\n        //Expects a StringValue\n    \tObject start = hints == null ? null : hints.get(START_VALUE);\n        Object end = hints == null ? null : hints.get(END_VALUE);\n        TreeMap map = new TreeMap();\n        IndexReader reader = null;\n        try {\n            reader = index.getReader();\n            for (int i = 0; i < qnames.size(); i++) {\n                QName qname = (QName) qnames.get(i);\n                String field = encodeQName(qname);\n                TermEnum terms;\n                if (start == null)\n                    terms = reader.terms();\n                else\n                    terms = reader.terms(new Term(field, start.toString()));\n                if (terms == null)\n                    continue;\n                Term term;\n                while((term = terms.term()) != null) {\n                    if (term.field().equals(field)) {\n                        if (end != null) {\n                            if (term.text().compareTo(start.toString()) > 0)\n                                break;\n                        } else if (!term.text().startsWith(start.toString()))\n                            break;\n                        TermDocs docsEnum = reader.termDocs(term);\n                        while (docsEnum.next()) {\n                            Document doc = reader.document(docsEnum.doc());\n                            Field fDocId = doc.getField(\"docId\");\n                            int docId = Integer.parseInt(fDocId.stringValue());\n                            DocumentImpl storedDocument = docs.getDoc(docId);\n                            if (storedDocument == null)\n                                continue;\n\n                            boolean include = true;\n                            if (contextSet != null) {\n                                NodeId nodeId = readNodeId(doc);\n                                NodeProxy parentNode = contextSet.parentWithChild(storedDocument, nodeId, false, true);\n                                include = (parentNode != null);\n                            }\n                            if (include) {\n                                Occurrences oc = (Occurrences) map.get(term);\n                                if (oc == null) {\n                                    oc = new Occurrences(term.text());\n                                    map.put(term, oc);\n                                }\n                                oc.addDocument(storedDocument);\n                                oc.addOccurrences(docsEnum.freq());\n                            }\n                        }\n                        docsEnum.close();\n                    }\n                    terms.next();\n                }\n                terms.close();\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Error while scanning lucene index entries: \" + e.getMessage(), e);\n        } finally {\n            index.releaseReader(reader);\n        }\n        Occurrences[] occur = new Occurrences[map.size()];\n        return (Occurrences[]) map.values().toArray(occur);\n    }","id":85508,"modified_method":"public Occurrences[] scanIndex(XQueryContext context, DocumentSet docs, NodeSet contextSet, Map hints) {\n        List qnames = hints == null ? null : (List)hints.get(QNAMES_KEY);\n        if (qnames == null || qnames.isEmpty())\n            qnames = getDefinedIndexes(context.getBroker(), docs);\n        //Expects a StringValue\n    \tObject start = hints == null ? null : hints.get(START_VALUE);\n        Object end = hints == null ? null : hints.get(END_VALUE);\n        TreeMap map = new TreeMap();\n        IndexReader reader = null;\n        try {\n            reader = index.getReader();\n            for (int i = 0; i < qnames.size(); i++) {\n                QName qname = (QName) qnames.get(i);\n                String field = encodeQName(qname);\n                TermEnum terms;\n                if (start == null)\n                    terms = reader.terms(new Term(field, \"\"));\n                else\n                    terms = reader.terms(new Term(field, start.toString()));\n                if (terms == null)\n                    continue;\n                Term term;\n                do {\n                    term = terms.term();\n                    if (term != null && term.field().equals(field)) {\n                        boolean include = true;\n                        if (end != null) {\n                            if (term.text().compareTo(start.toString()) > 0)\n                                include = false;\n                        } else if (start != null && !term.text().startsWith(start.toString()))\n                            include = false;\n                        if (include) {\n                            TermDocs docsEnum = reader.termDocs(term);\n                            while (docsEnum.next()) {\n                                if (reader.isDeleted(docsEnum.doc()))\n                                    continue;\n                                Document doc = reader.document(docsEnum.doc());\n                                Field fDocId = doc.getField(\"docId\");\n                                int docId = Integer.parseInt(fDocId.stringValue());\n                                DocumentImpl storedDocument = docs.getDoc(docId);\n                                if (storedDocument == null)\n                                    continue;\n\n                                if (contextSet != null) {\n                                    NodeId nodeId = readNodeId(doc);\n                                    NodeProxy parentNode = contextSet.parentWithChild(storedDocument, nodeId, false, true);\n                                    include = (parentNode != null);\n                                }\n                                if (include) {\n                                    Occurrences oc = (Occurrences) map.get(term);\n                                    if (oc == null) {\n                                        oc = new Occurrences(term.text());\n                                        map.put(term, oc);\n                                    }\n                                    oc.addDocument(storedDocument);\n                                    oc.addOccurrences(docsEnum.freq());\n                                }\n                            }\n                            docsEnum.close();\n                        }\n                    }\n                } while (terms.next());\n                terms.close();\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Error while scanning lucene index entries: \" + e.getMessage(), e);\n        } finally {\n            index.releaseReader(reader);\n        }\n        Occurrences[] occur = new Occurrences[map.size()];\n        return (Occurrences[]) map.values().toArray(occur);\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"public StoredNode getReindexRoot(StoredNode node, NodePath path, boolean includeSelf) {\n        return null;  //To change body of implemented methods use File | Settings | File Templates.\n    }","id":85509,"modified_method":"public StoredNode getReindexRoot(StoredNode node, NodePath path, boolean includeSelf) {\n        if (node.getNodeType() == Node.ATTRIBUTE_NODE)\n            return null;\n        if (config == null)\n            return null;\n        boolean reindexRequired = false;\n        int len = node.getNodeType() == Node.ELEMENT_NODE && !includeSelf ? path.length() - 1 : path.length();\n        for (int i = 0; i < len; i++) {\n            QName qn = path.getComponent(i);\n            if (config.get(qn) != null) {\n                reindexRequired = true;\n                break;\n            }\n        }\n        if (reindexRequired) {\n            StoredNode topMost = null;\n            StoredNode currentNode = node;\n            while (currentNode != null) {\n                if (config.get(currentNode.getQName()) != null)\n                    topMost = currentNode;\n                currentNode = currentNode.getParentStoredNode();\n            }\n            return topMost;\n        }\n        return null;\n    }","commit_id":"ca5206e42588f4d575f9463fef82621741c7f392","url":"https://github.com/eXist-db/exist"},{"original_method":"private Collection setupTestCollection() throws XMLDBException {\n\t\tCollection root = DatabaseManager.getCollection(URI);\n\t\tCollectionManagementService rootcms = (CollectionManagementService) root.getService(\"CollectionManagementService\", \"1.0\");\n\t\trootcms.removeCollection(\"test\");\n\t\trootcms.createCollection(\"test\");\n\t\tCollection c = DatabaseManager.getCollection(URI+\"/test\");\n\t\tassertNotNull(c);\n\t\treturn c;\n\t}","id":85510,"modified_method":"private Collection setupTestCollection() throws XMLDBException {\n\t\tCollection root = DatabaseManager.getCollection(URI);\n\t\tCollectionManagementService rootcms = (CollectionManagementService) root.getService(\"CollectionManagementService\", \"1.0\");\n\t\tCollection c = root.getChildCollection(\"test\");\n\t\tif(c != null)\n\t\t\trootcms.removeCollection(\"test\");\n\t\trootcms.createCollection(\"test\");\n\t\tc = DatabaseManager.getCollection(URI+\"/test\");\n\t\tassertNotNull(c);\n\t\treturn c;\n\t}","commit_id":"d546d77458cb061954f62fc2569a170b88bfdd7f","url":"https://github.com/eXist-db/exist"},{"original_method":"private void copyResource(DocumentImpl oldDoc, DocumentImpl newDoc) {\n\t\tLOG.debug(\"Copying document \" + oldDoc.getFileName() + \" to \" + newDoc.getCollection().getName());\n\t\tfinal long start = System.currentTimeMillis();\n\t\tIterator iterator;\n\t\tNodeList nodes = oldDoc.getChildNodes();\n\t\tNodeImpl n;\n\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n\t\t    n = (NodeImpl) nodes.item(i);\n\t\t    iterator =\n\t\t        getNodeIterator(\n\t\t                new NodeProxy(oldDoc, n.getGID(), n.getInternalAddress()));\n\t\t    iterator.next();\n\t\t    copyNodes(iterator, n, new NodePath(), newDoc, true);\n\t\t}\n\t\tflush();\n\t\tcloseDocument();\n\t\tLOG.debug(\"Copy took \" + (System.currentTimeMillis() - start) + \"ms.\");\n\t}","id":85511,"modified_method":"private void copyResource(DocumentImpl oldDoc, DocumentImpl newDoc) {\n\t\tLOG.debug(\"Copying document \" + oldDoc.getFileName() + \" to \" + \n\t\t\t\tnewDoc.getName());\n\t\tfinal long start = System.currentTimeMillis();\n\t\tIterator iterator;\n\t\tNodeList nodes = oldDoc.getChildNodes();\n\t\tNodeImpl n;\n\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n\t\t    n = (NodeImpl) nodes.item(i);\n\t\t    iterator =\n\t\t        getNodeIterator(\n\t\t                new NodeProxy(oldDoc, n.getGID(), n.getInternalAddress()));\n\t\t    iterator.next();\n\t\t    copyNodes(iterator, n, new NodePath(), newDoc, true);\n\t\t}\n\t\tflush();\n\t\tcloseDocument();\n\t\tLOG.debug(\"Copy took \" + (System.currentTimeMillis() - start) + \"ms.\");\n\t}","commit_id":"d546d77458cb061954f62fc2569a170b88bfdd7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public void copyResource(DocumentImpl doc, Collection destination, String newName) \n\tthrows PermissionDeniedException, LockException {\n\t\tif (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.READ))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.READ))\n\t    \tthrow new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot copy resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            collection.removeDocument(this, oldDoc.getFileName());\n\t        } else {\n\t        \tif(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        }\n\t        DocumentImpl newDoc = new DocumentImpl(this, newName, destination);\n\t        newDoc.copyOf(doc);\n\t        copyResource(doc, newDoc);\n\t        flush();\n\t        destination.addDocument(this, doc);\n\t        saveCollection(destination);\n\t\t} catch (TriggerException e) {\n\t\t\tthrow new PermissionDeniedException(e.getMessage());\n\t\t} finally {\n\t    \tlock.release();\n\t    }\n\t}","id":85512,"modified_method":"public void copyResource(DocumentImpl doc, Collection destination, String newName) \n\tthrows PermissionDeniedException, LockException {\n\t\tif (readOnly)\n\t\t\tthrow new PermissionDeniedException(DATABASE_IS_READ_ONLY);\n\t    Collection collection = doc.getCollection();\n\t    if(!collection.getPermissions().validate(user, Permission.READ))\n\t        throw new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(!doc.getPermissions().validate(user, Permission.READ))\n\t    \tthrow new PermissionDeniedException(\"Insufficient privileges to copy resource \" +\n\t                doc.getFileName());\n\t    if(newName == null) {\n            int p = doc.getFileName().lastIndexOf('/');\n            newName = doc.getFileName().substring(p + 1);\n        }\n\n\t    Lock lock = null;\n\t    try {\n\t        lock = collectionsDb.getLock();\n\t        lock.acquire(Lock.WRITE_LOCK);\n\t        // check if the move would overwrite a collection\n\t        if(getCollection(destination.getName() + '/' + newName) != null)\n\t            throw new PermissionDeniedException(\"A resource can not replace an existing collection\");\n\t        DocumentImpl oldDoc = destination.getDocument(this, newName);\n\t        if(oldDoc != null) {\n\t        \tif(doc.getDocId() == oldDoc.getDocId())\n\t            \tthrow new PermissionDeniedException(\"Cannot copy resource to itself\");\n\t            if(!destination.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            if(!oldDoc.getPermissions().validate(user, Permission.UPDATE))\n\t                throw new PermissionDeniedException(\"Resource with same name exists in target \" +\n\t                \t\t\"collection and update is denied\");\n\t            collection.removeDocument(this, oldDoc.getFileName());\n\t        } else {\n\t        \tif(!destination.getPermissions().validate(user, Permission.WRITE))\n\t    \t        throw new PermissionDeniedException(\"Insufficient privileges on target collection \" +\n\t    \t                destination.getName());\n\t        }\n\t        DocumentImpl newDoc = new DocumentImpl(this, newName, destination);\n\t        newDoc.copyOf(doc);\n\t        newDoc.setDocId(getNextDocId(destination));\n\t        copyResource(doc, newDoc);\n\t        destination.addDocument(this, newDoc);\n\t        updateDocument(newDoc);\n//\t        saveCollection(destination);\n\t\t} catch (TriggerException e) {\n\t\t\tthrow new PermissionDeniedException(e.getMessage());\n\t\t} finally {\n\t    \tlock.release();\n\t    }\n\t}","commit_id":"d546d77458cb061954f62fc2569a170b88bfdd7f","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testCollectionConfigurationService3() { \n        ResourceSet result; \n        try {\n            //Configure collection *manually*\n            storeConfiguration(CONF_COLL_URI, CollectionConfiguration.DEFAULT_COLLECTION_CONFIG_FILE_URI, CONFIG1);\n            \n            //... then index document \n            XMLResource doc = (XMLResource)\n            testCollection.createResource(TestConstants.TEST_XML_URI.toString(), \"XMLResource\" );\n            doc.setContent(DOCUMENT_CONTENT); testCollection.storeResource(doc);\n    \n            XPathQueryService service = (XPathQueryService)\n            testCollection.getService(\"XPathQueryService\", \"1.0\");\n   \n            //3 numeric values \n            result = service.query(\"util:index-key-occurrences(/test/a, 1)\"); \n            assertEquals(\"3\", result.getResource(0).getContent()); \n            //... but 1 string value \n            result = service.query(\"util:index-key-occurrences(/test/b, \\\"1\\\")\"); \n            assertEquals(\"1\", result.getResource(0).getContent());             \n\n            //3 numeric values \n            result = service.query(\"util:qname-index-lookup(xs:QName(\\\"a\\\"), 1 ) \"); \n            assertEquals(3, result.getSize()); \n            //... but 1 string value \n            result = service.query(\"util:qname-index-lookup(xs:QName(\\\"b\\\"), \\\"1\\\" ) \"); \n            assertEquals(1, result.getSize()); }\n        catch(Exception e) { \n            fail(e.getMessage());             \n        }\n   }","id":85513,"modified_method":"public void testCollectionConfigurationService3() { \n        ResourceSet result; \n        try {\n            //Configure collection *manually*\n            storeConfiguration(CONF_COLL_URI, CollectionConfiguration.DEFAULT_COLLECTION_CONFIG_FILE_URI, CONFIG1);\n            \n            //... then index document \n            XMLResource doc = (XMLResource)\n            testCollection.createResource(TestConstants.TEST_XML_URI.toString(), \"XMLResource\" );\n            doc.setContent(DOCUMENT_CONTENT); testCollection.storeResource(doc);\n    \n            XPathQueryService service = (XPathQueryService)\n            testCollection.getService(\"XPathQueryService\", \"1.0\");\n   \n            //3 numeric values \n            result = service.query(\"util:index-key-occurrences(/test/a, 1)\");\n            assertEquals(1, result.getSize());\n            assertEquals(\"3\", result.getResource(0).getContent()); \n            //... but 1 string value \n            result = service.query(\"util:index-key-occurrences(/test/b, \\\"1\\\")\");\n            assertEquals(1, result.getSize());\n            assertEquals(\"1\", result.getResource(0).getContent());             \n\n            //3 numeric values \n            result = service.query(\"util:qname-index-lookup(xs:QName(\\\"a\\\"), 1 ) \"); \n            assertEquals(3, result.getSize()); \n            //... but 1 string value \n            result = service.query(\"util:qname-index-lookup(xs:QName(\\\"b\\\"), \\\"1\\\" ) \"); \n            assertEquals(1, result.getSize()); }\n        catch(Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());             \n        }\n   }","commit_id":"b23e2e55a19ce39b5835ea8302070df0c4f00f01","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void tearDown() {\n        try {\n           \n            Collection root = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION, \"admin\", null);\n            CollectionManagementService service = (CollectionManagementService) root\n                    .getService(\"CollectionManagementService\", \"1.0\");\n            service.removeCollection(TEST_COLLECTION.toString());\n            testCollection = null;\n            \n            //Removes the collection config collection *manually*          \n            service.removeCollection(CONF_COLL_URI.toString());\n            \n            DatabaseInstanceManager mgr = (DatabaseInstanceManager) root.getService(\"DatabaseInstanceManager\", \"1.0\");\n            mgr.shutdown();\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n    }","id":85514,"modified_method":"protected void tearDown() {\n        try {\n           \n            Collection root = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION, \"admin\", null);\n            CollectionManagementService service = (CollectionManagementService) root\n                    .getService(\"CollectionManagementService\", \"1.0\");\n            service.removeCollection(TEST_COLLECTION.toString());\n            testCollection = null;\n            \n            //Removes the collection config collection *manually*\n            Collection confCol = DatabaseManager.getCollection(URI + CONF_COLL_URI, \"admin\", null);\n            if (confCol != null)\n                service.removeCollection(CONF_COLL_URI.toString());\n            \n            DatabaseInstanceManager mgr = (DatabaseInstanceManager) root.getService(\"DatabaseInstanceManager\", \"1.0\");\n            mgr.shutdown();\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n    }","commit_id":"b23e2e55a19ce39b5835ea8302070df0c4f00f01","url":"https://github.com/eXist-db/exist"},{"original_method":"public void createClient(@Observes Configuration config) {\n        KubernetesClient client;\n        String masterUrl = config.getMasterUrl();\n        if (Strings.isNotBlank(masterUrl)) {\n            client = new KubernetesClient(masterUrl);\n        } else {\n            client = new KubernetesClient();\n        }\n        kubernetesProducer.set(client);\n    }","id":85515,"modified_method":"public void createClient(@Observes Configuration config) {\n        if (!Strings.isNullOrBlank(config.getMasterUrl())) {\n            kubernetesProducer.set(new DefaultKubernetesClient(new DefaultKubernetesClient.ConfigBuilder().masterUrl(config.getMasterUrl()).build()));\n        } else {\n            kubernetesProducer.set(new DefaultKubernetesClient());\n        }\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void createController(@Observes KubernetesClient client) {\n        kubernetesControllerProducer.set(new Controller(client));\n    }","id":85516,"modified_method":"public void createController(@Observes KubernetesClient client) {\n        //TODO: do something for this cast.\n        kubernetesControllerProducer.set(new Controller((OpenShiftClient) client));\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        return client.getPods(session.getNamespace());\n    }","id":85517,"modified_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        return client.pods().inNamespace(session.getNamespace()).list();\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        return client.getReplicationControllers(session.getNamespace());\n    }","id":85518,"modified_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        return client.replicationControllers().inNamespace(session.getNamespace()).list();\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        for (ReplicationController replicationController : client.getReplicationControllers(session.getNamespace()).getItems()) {\n            if (qualifies(replicationController, qualifiers)) {\n                return replicationController;\n            }\n        }\n        return null;\n    }","id":85519,"modified_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        for (ReplicationController replicationController : client.replicationControllers().inNamespace(session.getNamespace()).list().getItems()) {\n            if (qualifies(replicationController, qualifiers)) {\n                return replicationController;\n            }\n        }\n        return null;\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        ServiceList services = client.getServices(session.getNamespace());\n        return services;\n    }","id":85520,"modified_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        ServiceList services = client.services().inNamespace(session.getNamespace()).list();\n        return services;\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        for (Service service : client.getServices(session.getNamespace()).getItems()) {\n            if ( qualifies(service, qualifiers) ) {\n                return service;\n            }\n        }\n        return null;\n    }","id":85521,"modified_method":"@Override\n    public Object lookup(ArquillianResource resource, Annotation... qualifiers) {\n        KubernetesClient client = this.clientInstance.get();\n        Session session = sessionInstance.get();\n        for (Service service : client.services().inNamespace(session.getNamespace()).list().getItems()) {\n            if ( qualifies(service, qualifiers) ) {\n                return service;\n            }\n        }\n        return null;\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void start(final @Observes Start event, final KubernetesClient client, Controller controller, Configuration configuration) throws Exception {\n        Session session = event.getSession();\n        final Logger log = session.getLogger();\n        String namespace = session.getNamespace();\n        System.setProperty(Constants.KUBERNETES_NAMESPACE, namespace);\n        \n        log.status(\"Creating kubernetes resources inside namespace: \" + namespace);\n        log.info(\"if you use OpenShift then type this switch namespaces:     osc namespace \" + namespace);\n        log.info(\"if you use kubernetes then type this to switch namespaces: kubectl namespace \" + namespace);\n        client.setNamespace(namespace);\n        controller.setNamespace(namespace);\n        controller.setThrowExceptionOnError(true);\n        controller.setRecreateMode(true);\n        controller.setIgnoreRunningOAuthClients(true);\n\n        Namespace namespaceDetails = session.getNamespaceDetails();\n        controller.applyNamespace(namespaceDetails);\n\n        shutdownHook = new ShutdownHook(client, session);\n        Runtime.getRuntime().addShutdownHook(shutdownHook);\n\n        try {\n            URL configUrl = configuration.getConfigUrl();\n            List<String> dependencies = !configuration.getDependencies().isEmpty() ? configuration.getDependencies() : Util.getMavenDependencies(session);\n            List<KubernetesList> kubeConfigs = new LinkedList<>();\n\n            for (String dependency : dependencies) {\n                log.info(\"Found dependency: \" + dependency);\n                loadDependency(log, kubeConfigs, dependency);\n            }\n\n            if (configUrl != null) {\n                log.status(\"Applying kubernetes configuration from: \" + configUrl);\n                Object dto = loadJson(readAsString(configUrl));\n                if (dto instanceof Template) {\n                    Template template = (Template) dto;\n                    KubernetesHelper.setNamespace(template, namespace);\n                    String parameterNamePrefix = \"\";\n                    overrideTemplateParameters(template, configuration.getProperties(), parameterNamePrefix);\n                    log.status(\"Applying template in namespace \" + namespace);\n                    dto = controller.processTemplate(template, configUrl.toString());\n                    if (dto == null) {\n                        throw new IllegalArgumentException(\"Failed to process Template!\");\n                    }\n                }\n                KubernetesList kubeList = KubernetesHelper.asKubernetesList(dto);\n                List<HasMetadata> items = kubeList.getItems();\n                kubeConfigs.add(kubeList);\n            }\n            if (applyConfiguration(client, controller, configuration, session, kubeConfigs)) {\n                displaySessionStatus(client, session);\n            } else {\n                throw new IllegalStateException(\"Failed to apply kubernetes configuration.\");\n            }\n        } catch (Exception e) {\n            try {\n                cleanupSession(client, session);\n            } catch (MultiException me) {\n                throw e;\n            } finally {\n                if (shutdownHook != null) {\n                    Runtime.getRuntime().removeShutdownHook(shutdownHook);\n                }\n            }\n            throw new RuntimeException(e);\n        }\n    }","id":85522,"modified_method":"public void start(final @Observes Start event, final KubernetesClient client, Controller controller, Configuration configuration) throws Exception {\n        Session session = event.getSession();\n        final Logger log = session.getLogger();\n        String namespace = session.getNamespace();\n        System.setProperty(Constants.KUBERNETES_NAMESPACE, namespace);\n        \n        log.status(\"Creating kubernetes resources inside namespace: \" + namespace);\n        log.info(\"if you use OpenShift then type this switch namespaces:     osc namespace \" + namespace);\n        log.info(\"if you use kubernetes then type this to switch namespaces: kubectl namespace \" + namespace);\n\n        controller.setNamespace(namespace);\n        controller.setThrowExceptionOnError(true);\n        controller.setRecreateMode(true);\n        controller.setIgnoreRunningOAuthClients(true);\n\n        Namespace namespaceDetails = session.getNamespaceDetails();\n        controller.applyNamespace(namespaceDetails);\n\n        shutdownHook = new ShutdownHook(client, session);\n        Runtime.getRuntime().addShutdownHook(shutdownHook);\n\n        try {\n            URL configUrl = configuration.getConfigUrl();\n            List<String> dependencies = !configuration.getDependencies().isEmpty() ? configuration.getDependencies() : Util.getMavenDependencies(session);\n            List<KubernetesList> kubeConfigs = new LinkedList<>();\n\n            for (String dependency : dependencies) {\n                log.info(\"Found dependency: \" + dependency);\n                loadDependency(log, kubeConfigs, dependency);\n            }\n\n            if (configUrl != null) {\n                log.status(\"Applying kubernetes configuration from: \" + configUrl);\n                Object dto = loadJson(readAsString(configUrl));\n                if (dto instanceof Template) {\n                    Template template = (Template) dto;\n                    KubernetesHelper.setNamespace(template, namespace);\n                    String parameterNamePrefix = \"\";\n                    overrideTemplateParameters(template, configuration.getProperties(), parameterNamePrefix);\n                    log.status(\"Applying template in namespace \" + namespace);\n                    dto = controller.processTemplate(template, configUrl.toString());\n                    if (dto == null) {\n                        throw new IllegalArgumentException(\"Failed to process Template!\");\n                    }\n                }\n                KubernetesList kubeList = KubernetesHelper.asKubernetesList(dto);\n                List<HasMetadata> items = kubeList.getItems();\n                kubeConfigs.add(kubeList);\n            }\n            if (applyConfiguration(client, controller, configuration, session, kubeConfigs)) {\n                displaySessionStatus(client, session);\n            } else {\n                throw new IllegalStateException(\"Failed to apply kubernetes configuration.\");\n            }\n        } catch (Exception e) {\n            try {\n                cleanupSession(client, session);\n            } catch (MultiException me) {\n                throw e;\n            } finally {\n                if (shutdownHook != null) {\n                    Runtime.getRuntime().removeShutdownHook(shutdownHook);\n                }\n            }\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Boolean call() throws Exception {\n        boolean result = true;\n        List<Pod> pods = kubernetesClient.getPods(session.getNamespace()).getItems();\n\n        if (pods.isEmpty()) {\n            result = false;\n            session.getLogger().warn(\"No pods are available yet, waiting...\");\n        }\n\n        for (Pod pod : pods) {\n            result = result && Objects.equal(PodStatusType.OK, KubernetesHelper.getPodStatus(pod));\n            if (!result) {\n                PodStatus podStatus = pod.getStatus();\n                if (podStatus != null) {\n                    List<ContainerStatus> containerStatuses = podStatus.getContainerStatuses();\n                    for (ContainerStatus containerStatus : containerStatuses) {\n                        ContainerState state = containerStatus.getState();\n                        if (state != null) {\n                            ContainerStateWaiting waiting = state.getWaiting();\n                            if (waiting != null) {\n                                String containerName = containerStatus.getName();\n                                session.getLogger().warn(\"Waiting for container:\" + containerName + \". Reason:\" + waiting.getReason());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","id":85523,"modified_method":"@Override\n    public Boolean call() throws Exception {\n        boolean result = true;\n        List<Pod> pods = kubernetesClient.pods().inNamespace(session.getNamespace()).list().getItems();\n\n        if (pods.isEmpty()) {\n            result = false;\n            session.getLogger().warn(\"No pods are available yet, waiting...\");\n        }\n\n        for (Pod pod : pods) {\n            result = result && Objects.equal(PodStatusType.OK, KubernetesHelper.getPodStatus(pod));\n            if (!result) {\n                PodStatus podStatus = pod.getStatus();\n                if (podStatus != null) {\n                    List<ContainerStatus> containerStatuses = podStatus.getContainerStatuses();\n                    for (ContainerStatus containerStatus : containerStatuses) {\n                        ContainerState state = containerStatus.getState();\n                        if (state != null) {\n                            ContainerStateWaiting waiting = state.getWaiting();\n                            if (waiting != null) {\n                                String containerName = containerStatus.getName();\n                                session.getLogger().warn(\"Waiting for container:\" + containerName + \". Reason:\" + waiting.getReason());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Checks if there is an endpoint for the service available.\n     * @param s The target service.\n     * @return  Returns true if a connection to at least one of the endpoints is possible.\n     */\n    private boolean isEndpointAvailable(Service s) {\n        String serviceStatus = null;\n        boolean result = false;\n        String sid = getName(s);\n        //String namespace = s.getMetadata().getNamespace();\n        String namespace = kubernetesClient.getNamespace();\n        Endpoints endpoints = kubernetesClient.endpointsForService(sid, namespace);\n        ServiceSpec spec = s.getSpec();\n        if (endpoints != null && spec != null) {\n            List<EndpointSubset> subsets = endpoints.getSubsets();\n            if (subsets != null) {\n                for (EndpointSubset subset : subsets) {\n                    List<EndpointAddress> addresses = subset.getAddresses();\n                    if (addresses != null) {\n                        for (EndpointAddress address : addresses) {\n                            String ip = address.getIp();\n                            String addr = ip;\n/*\n    TODO v1beta2...\n                            String addr = endpoit.substring(0, endpoit.indexOf(\":\"));\n                            Integer port = Integer.parseInt(endpoit.substring(endpoit.indexOf(\":\") + 1));\n*/\n                            List<ServicePort> ports = spec.getPorts();\n                            for (ServicePort port : ports) {\n                                Integer portNumber = port.getPort();\n                                if (portNumber != null && portNumber > 0) {\n                                    if (configuration.isConnectToServices()) {\n                                        try (Socket socket = new Socket()) {\n                                            socket.connect(new InetSocketAddress(ip, portNumber), configuration.getServiceConnectionTimeout());\n                                            serviceStatus = \"Service: \" + sid + \" is ready. Provider:\" + addr + \".\";\n                                            return true;\n                                        } catch (Exception e) {\n                                            serviceStatus = \"Service: \" + sid + \" is not ready! in namespace \" + namespace + \". Error: \" + e.getMessage();\n                                        } finally {\n                                            session.getLogger().warn(serviceStatus);\n                                        }\n                                    } else {\n                                        serviceStatus = \"Service: \" + sid + \" is ready. Not testing connecting to it!. Provider:\" + addr + \".\";\n                                        session.getLogger().warn(serviceStatus);\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","id":85524,"modified_method":"/**\n     * Checks if there is an endpoint for the service available.\n     * @param s The target service.\n     * @return  Returns true if a connection to at least one of the endpoints is possible.\n     */\n    private boolean isEndpointAvailable(Service s) {\n        String serviceStatus = null;\n        boolean result = false;\n        String sid = getName(s);\n        //String namespace = s.getMetadata().getNamespace();\n        String namespace = session.getNamespace();\n        Endpoints endpoints = kubernetesClient.endpoints().inNamespace(namespace).withName(sid).get();\n        ServiceSpec spec = s.getSpec();\n        if (endpoints != null && spec != null) {\n            List<EndpointSubset> subsets = endpoints.getSubsets();\n            if (subsets != null) {\n                for (EndpointSubset subset : subsets) {\n                    List<EndpointAddress> addresses = subset.getAddresses();\n                    if (addresses != null) {\n                        for (EndpointAddress address : addresses) {\n                            String ip = address.getIp();\n                            String addr = ip;\n/*\n    TODO v1beta2...\n                            String addr = endpoit.substring(0, endpoit.indexOf(\":\"));\n                            Integer port = Integer.parseInt(endpoit.substring(endpoit.indexOf(\":\") + 1));\n*/\n                            List<ServicePort> ports = spec.getPorts();\n                            for (ServicePort port : ports) {\n                                Integer portNumber = port.getPort();\n                                if (portNumber != null && portNumber > 0) {\n                                    if (configuration.isConnectToServices()) {\n                                        try (Socket socket = new Socket()) {\n                                            socket.connect(new InetSocketAddress(ip, portNumber), configuration.getServiceConnectionTimeout());\n                                            serviceStatus = \"Service: \" + sid + \" is ready. Provider:\" + addr + \".\";\n                                            return true;\n                                        } catch (Exception e) {\n                                            serviceStatus = \"Service: \" + sid + \" is not ready! in namespace \" + namespace + \". Error: \" + e.getMessage();\n                                        } finally {\n                                            session.getLogger().warn(serviceStatus);\n                                        }\n                                    } else {\n                                        serviceStatus = \"Service: \" + sid + \" is ready. Not testing connecting to it!. Provider:\" + addr + \".\";\n                                        session.getLogger().warn(serviceStatus);\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public Boolean call() throws Exception {\n        boolean result = true;\n        List<Service> services = kubernetesClient.getServices(session.getNamespace()).getItems();\n\n        if (services.isEmpty()) {\n            result = false;\n            session.getLogger().warn(\"No services are available yet, waiting...\");\n        } else if (configuration.isWaitForServiceConnection()) {\n            for (Service s : filterServices(services, configuration.getWaitForServices())) {\n                if (!isEndpointAvailable(s)) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        return result;\n    }","id":85525,"modified_method":"@Override\n    public Boolean call() throws Exception {\n        boolean result = true;\n        List<Service> services = kubernetesClient.services().inNamespace(session.getNamespace()).list().getItems();\n\n        if (services.isEmpty()) {\n            result = false;\n            session.getLogger().warn(\"No services are available yet, waiting...\");\n        } else if (configuration.isWaitForServiceConnection()) {\n            for (Service s : filterServices(services, configuration.getWaitForServices())) {\n                if (!isEndpointAvailable(s)) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        return result;\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static void cleanupAllMatching(KubernetesClient client, Session session, List<Throwable> errors) throws MultiException {\n\n        /**\n         * Lets use a loop to ensure we really do delete all the matching resources\n         */\n        for (int i = 0; i < 10; i++) {\n            try {\n                deleteReplicationControllers(client, session);\n            } catch (MultiException e) {\n                errors.addAll(Arrays.asList(e.getCauses()));\n            }\n\n            try {\n                deletePods(client, session);\n            } catch (MultiException e) {\n                errors.addAll(Arrays.asList(e.getCauses()));\n            }\n\n            try {\n                deleteServices(client, session);\n            } catch (MultiException e) {\n                errors.addAll(Arrays.asList(e.getCauses()));\n            }\n\n            // lets see if there are any matching podList left\n            List<Pod> filteredPods = client.getPods(session.getNamespace()).getItems();\n            if (filteredPods.isEmpty()) {\n                return;\n            } else {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }","id":85526,"modified_method":"public static void cleanupAllMatching(KubernetesClient client, Session session, List<Throwable> errors) throws MultiException {\n\n        /**\n         * Lets use a loop to ensure we really do delete all the matching resources\n         */\n        for (int i = 0; i < 10; i++) {\n            try {\n                client.replicationControllers().inNamespace(session.getNamespace()).delete();\n            } catch (KubernetesClientException e) {\n                errors.add(e);\n            }\n\n            try {\n                client.pods().inNamespace(session.getNamespace()).delete();\n            } catch (KubernetesClientException e) {\n                errors.add(e);\n            }\n\n            try {\n                client.services().inNamespace(session.getNamespace()).delete();\n            } catch (KubernetesClientException e) {\n                errors.add(e);\n            }\n\n            // lets see if there are any matching podList left\n            List<Pod> filteredPods = client.pods().inNamespace(session.getNamespace()).list().getItems();\n            if (filteredPods.isEmpty()) {\n                return;\n            } else {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static void displaySessionStatus(KubernetesClient client, Session session) throws MultiException {\n        for (ReplicationController replicationController : client.getReplicationControllers(session.getNamespace()).getItems()) {\n            session.getLogger().info(\"Replication controller:\" + KubernetesHelper.getName(replicationController));\n        }\n\n        for (Pod pod : client.getPods(session.getNamespace()).getItems()) {\n            session.getLogger().info(\"Pod:\" + KubernetesHelper.getName(pod) + \" Status:\" + pod.getStatus());\n        }\n        for (Service service : client.getServices(session.getNamespace()).getItems()) {\n            session.getLogger().info(\"Service:\" + KubernetesHelper.getName(service) + \" IP:\" + getPortalIP(service) + \" Port:\" + getPorts(service));\n        }\n\n    }","id":85527,"modified_method":"public static void displaySessionStatus(KubernetesClient client, Session session) throws MultiException {\n        for (ReplicationController replicationController : client.replicationControllers().inNamespace(session.getNamespace()).list().getItems()) {\n            session.getLogger().info(\"Replication controller:\" + KubernetesHelper.getName(replicationController));\n        }\n\n        for (Pod pod : client.pods().inNamespace(session.getNamespace()).list().getItems()) {\n            session.getLogger().info(\"Pod:\" + KubernetesHelper.getName(pod) + \" Status:\" + pod.getStatus());\n        }\n        for (Service service : client.services().inNamespace(session.getNamespace()).list().getItems()) {\n            session.getLogger().info(\"Service:\" + KubernetesHelper.getName(service) + \" IP:\" + getPortalIP(service) + \" Port:\" + getPorts(service));\n        }\n\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static void cleanupSession(KubernetesClient client, Session session) throws MultiException {\n        waitUntilWeCanDestroyNamespace(session);\n        List<Throwable> errors = new ArrayList<>();\n        cleanupAllMatching(client, session, errors);\n        try {\n            client.deleteNamespace(session.getNamespace());\n        } catch (Exception e) {\n            errors.add(e);\n        }\n        if (!errors.isEmpty()) {\n            throw new MultiException(\"Error while cleaning up session.\", errors);\n        }\n    }","id":85528,"modified_method":"public static void cleanupSession(KubernetesClient client, Session session) throws MultiException {\n        waitUntilWeCanDestroyNamespace(session);\n        List<Throwable> errors = new ArrayList<>();\n        cleanupAllMatching(client, session, errors);\n        try {\n            client.namespaces().withName(session.getNamespace()).delete();\n        } catch (Exception e) {\n            errors.add(e);\n        }\n        if (!errors.isEmpty()) {\n            throw new MultiException(\"Error while cleaning up session.\", errors);\n        }\n    }","commit_id":"145e0a86c2781115f6a64f775c2902045868e0e4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static BlogsEntry addBlogsEntry(\n\t\t\tGroup group, long userId, boolean approved)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\tString title = \"Title\";\n\t\tString description = \"Description\";\n\t\tString content = \"Content\";\n\t\tint displayDateMonth = 1;\n\t\tint displayDateDay = 1;\n\t\tint displayDateYear = 2012;\n\t\tint displayDateHour = 12;\n\t\tint displayDateMinute = 0;\n\t\tboolean allowPingbacks = true;\n\t\tboolean allowTrackbacks = true;\n\t\tString[] trackbacks = new String[0];\n\t\tboolean smallImage = false;\n\t\tString smallImageURL = StringPool.BLANK;\n\t\tString smallImageFileName = StringPool.BLANK;\n\t\tInputStream smallImageInputStream = null;\n\n\t\tBlogsEntry blogsEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\tuserId, title, description, content, displayDateMonth,\n\t\t\tdisplayDateDay, displayDateYear, displayDateHour, displayDateMinute,\n\t\t\tallowPingbacks, allowTrackbacks, trackbacks, smallImage,\n\t\t\tsmallImageURL, smallImageFileName, smallImageInputStream,\n\t\t\tserviceContext);\n\n\t\tif (approved) {\n\t\t\tBlogsEntryLocalServiceUtil.updateStatus(\n\t\t\t\tGetterUtil.getLong(PrincipalThreadLocal.getName()),\n\t\t\t\tblogsEntry.getEntryId(), WorkflowConstants.STATUS_APPROVED,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\treturn blogsEntry;\n\t}","id":85529,"modified_method":"public static BlogsEntry addBlogsEntry(\n\t\t\tGroup group, long userId, boolean approved)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\tString title = \"Title\";\n\t\tString description = \"Description\";\n\t\tString content = \"Content\";\n\t\tint displayDateMonth = 1;\n\t\tint displayDateDay = 1;\n\t\tint displayDateYear = 2012;\n\t\tint displayDateHour = 12;\n\t\tint displayDateMinute = 0;\n\t\tboolean allowPingbacks = true;\n\t\tboolean allowTrackbacks = true;\n\t\tString[] trackbacks = new String[0];\n\t\tboolean smallImage = false;\n\t\tString smallImageURL = StringPool.BLANK;\n\t\tString smallImageFileName = StringPool.BLANK;\n\t\tInputStream smallImageInputStream = null;\n\n\t\tBlogsEntry blogsEntry = BlogsEntryLocalServiceUtil.addEntry(\n\t\t\tuserId, title, description, content, displayDateMonth,\n\t\t\tdisplayDateDay, displayDateYear, displayDateHour, displayDateMinute,\n\t\t\tallowPingbacks, allowTrackbacks, trackbacks, smallImage,\n\t\t\tsmallImageURL, smallImageFileName, smallImageInputStream,\n\t\t\tserviceContext);\n\n\t\tif (approved) {\n\t\t\tBlogsEntryLocalServiceUtil.updateStatus(\n\t\t\t\tGetterUtil.getLong(PrincipalThreadLocal.getName()),\n\t\t\t\tblogsEntry.getEntryId(), WorkflowConstants.STATUS_APPROVED,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\treturn blogsEntry;\n\t}","commit_id":"4f3d0830f62055b2806d1213851cbd304ca01238","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchWithinDDMStructure() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModelWithDDMStructure(\n\t\t\tparentBaseModel,  getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","id":85530,"modified_method":"protected void searchWithinDDMStructure() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModelWithDDMStructure(\n\t\t\tparentBaseModel,  getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchComments() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setIncludeDiscussions(true);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, ServiceTestUtil.randomString(),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\taddComment(baseModel, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 2,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","id":85531,"modified_method":"protected void searchComments() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setIncludeDiscussions(true);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, ServiceTestUtil.randomString(),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\taddComment(baseModel, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 2,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchStatus() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tint initialBaseModelsCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.0\", searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, false, \"Version 1.0\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_PUBLISH);\n\n\t\tbaseModel = updateBaseModel(baseModel, \"Version 1.1\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.0\", searchContext));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.1\", searchContext));\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\tbaseModel = updateBaseModel(baseModel, \"Version 1.2\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.1\", searchContext));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.2\", searchContext));\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_PUBLISH);\n\n\t\tbaseModel = updateBaseModel(baseModel, \"Version 1.3\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.2\", searchContext));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.3\", searchContext));\n\t}","id":85532,"modified_method":"protected void searchStatus() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tint initialBaseModelsCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.0\", searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, false, \"Version 1.0\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_PUBLISH);\n\n\t\tbaseModel = updateBaseModel(baseModel, \"Version 1.1\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.0\", searchContext));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.1\", searchContext));\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\tbaseModel = updateBaseModel(baseModel, \"Version 1.2\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.1\", searchContext));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.2\", searchContext));\n\n\t\tserviceContext.setWorkflowAction(WorkflowConstants.ACTION_PUBLISH);\n\n\t\tbaseModel = updateBaseModel(baseModel, \"Version 1.3\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.2\", searchContext));\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), \"1.3\", searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchVersions() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tbaseModel = updateBaseModel(baseModel, \"liferay\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tbaseModel = updateBaseModel(baseModel, \"portal\", serviceContext);\n\n\t\tsearchContext.setKeywords(\"portal\");\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","id":85533,"modified_method":"protected void searchVersions() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tbaseModel = updateBaseModel(baseModel, \"liferay\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tbaseModel = updateBaseModel(baseModel, \"portal\", serviceContext);\n\n\t\tsearchContext.setKeywords(\"portal\");\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchExpireVersions(boolean expireAllVersions)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tbaseModel = updateBaseModel(baseModel, \"liferay\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\texpireBaseModelVersions(baseModel, expireAllVersions, serviceContext);\n\n\t\tif (expireAllVersions && isExpirableAllVersions()) {\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialBaseModelsCount,\n\t\t\t\tsearchBaseModelsCount(\n\t\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t\t}\n\t\telse {\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialBaseModelsCount + 1,\n\t\t\t\tsearchBaseModelsCount(\n\t\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t\t}\n\t}","id":85534,"modified_method":"protected void searchExpireVersions(boolean expireAllVersions)\n\t\tthrows Exception {\n\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\tbaseModel = updateBaseModel(baseModel, \"liferay\", serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsCount,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\texpireBaseModelVersions(baseModel, expireAllVersions, serviceContext);\n\n\t\tif (expireAllVersions && isExpirableAllVersions()) {\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialBaseModelsCount,\n\t\t\t\tsearchBaseModelsCount(\n\t\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t\t}\n\t\telse {\n\t\t\tAssert.assertEquals(\n\t\t\t\tinitialBaseModelsCount + 1,\n\t\t\t\tsearchBaseModelsCount(\n\t\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t\t}\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchAttachments() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setIncludeAttachments(true);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, ServiceTestUtil.randomString(),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\taddAttachment(baseModel);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 2,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","id":85535,"modified_method":"protected void searchAttachments() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setIncludeAttachments(true);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, ServiceTestUtil.randomString(),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\n\t\taddAttachment(baseModel);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 2,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchByDDMStructureField() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModelWithDDMStructure(\n\t\t\tparentBaseModel, getSearchKeywords(), serviceContext);\n\n\t\tsearchContext.setAttribute(\n\t\t\t\"ddmStructureFieldName\", getDDMStructureFieldName());\n\t\tsearchContext.setAttribute(\n\t\t\t\"ddmStructureFieldValue\", getSearchKeywords());\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","id":85536,"modified_method":"protected void searchByDDMStructureField() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModelWithDDMStructure(\n\t\t\tparentBaseModel, getSearchKeywords(), serviceContext);\n\n\t\tsearchContext.setAttribute(\n\t\t\t\"ddmStructureFieldName\", getDDMStructureFieldName());\n\t\tsearchContext.setAttribute(\n\t\t\t\"ddmStructureFieldValue\", getSearchKeywords());\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchBaseModel() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, ServiceTestUtil.randomString(),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","id":85537,"modified_method":"protected void searchBaseModel() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, ServiceTestUtil.randomString(),\n\t\t\tserviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void searchByKeywords() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext();\n\n\t\tserviceContext.setScopeGroupId(group.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","id":85538,"modified_method":"protected void searchByKeywords() throws Exception {\n\t\tServiceContext serviceContext = ServiceTestUtil.getServiceContext(\n\t\t\tgroup.getGroupId());\n\n\t\tSearchContext searchContext = ServiceTestUtil.getSearchContext(\n\t\t\tgroup.getGroupId());\n\n\t\tsearchContext.setKeywords(getSearchKeywords());\n\n\t\tint initialBaseModelsSearchCount = searchBaseModelsCount(\n\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext);\n\n\t\tBaseModel<?> parentBaseModel = getParentBaseModel(\n\t\t\tgroup, serviceContext);\n\n\t\tbaseModel = addBaseModel(\n\t\t\tparentBaseModel, true, getSearchKeywords(), serviceContext);\n\n\t\tAssert.assertEquals(\n\t\t\tinitialBaseModelsSearchCount + 1,\n\t\t\tsearchBaseModelsCount(\n\t\t\t\tgetBaseModelClass(), group.getGroupId(), searchContext));\n\t}","commit_id":"90a7d782a760c7c34781476cfab26e6bfc4fc093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!FileModificationService.getInstance().prepareFileForWrite(file)) return;\n    int offset = editor.getCaretModel().getOffset();\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    PsiElement element = findElement(file, offset);\n    PsiTryStatement tryStatement = (PsiTryStatement) element.getParent();\n    List<PsiClassType> unhandledExceptions = new ArrayList<PsiClassType>(ExceptionUtil.collectUnhandledExceptions(element, null));\n    ExceptionUtil.sortExceptionsByHierarchy(unhandledExceptions);\n\n    IdeDocumentHistory.getInstance(project).includeCurrentPlaceAsChangePlace();\n\n    PsiCodeBlock catchBlockToSelect = null;\n\n    try {\n      if (tryStatement.getFinallyBlock() == null && tryStatement.getCatchBlocks().length == 0) {\n        for (PsiClassType unhandledException : unhandledExceptions) {\n          addCatchStatement(tryStatement, unhandledException, file);\n        }\n        catchBlockToSelect = tryStatement.getCatchBlocks()[0];\n      }\n      else {\n        for (PsiClassType unhandledException : unhandledExceptions) {\n          PsiCodeBlock codeBlock = addCatchStatement(tryStatement, unhandledException, file);\n          if (catchBlockToSelect == null) catchBlockToSelect = codeBlock;\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    if (catchBlockToSelect != null) {\n      TextRange range = SurroundWithUtil.getRangeToSelect(catchBlockToSelect);\n      editor.getCaretModel().moveToOffset(range.getStartOffset());\n\n      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      editor.getSelectionModel().setSelection(range.getStartOffset(), range.getEndOffset());\n    }\n  }","id":85539,"modified_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!FileModificationService.getInstance().prepareFileForWrite(file)) return;\n    int offset = editor.getCaretModel().getOffset();\n\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    PsiElement element = findElement(file, offset);\n    if (element == null) return;\n\n    PsiTryStatement tryStatement = (PsiTryStatement)element.getParent();\n    List<PsiClassType> unhandledExceptions = new ArrayList<PsiClassType>(ExceptionUtil.collectUnhandledExceptions(element, null));\n    ExceptionUtil.sortExceptionsByHierarchy(unhandledExceptions);\n\n    IdeDocumentHistory.getInstance(project).includeCurrentPlaceAsChangePlace();\n\n    PsiCodeBlock catchBlockToSelect = null;\n\n    try {\n      if (tryStatement.getFinallyBlock() == null && tryStatement.getCatchBlocks().length == 0) {\n        for (PsiClassType unhandledException : unhandledExceptions) {\n          addCatchStatement(tryStatement, unhandledException, file);\n        }\n        catchBlockToSelect = tryStatement.getCatchBlocks()[0];\n      }\n      else {\n        for (PsiClassType unhandledException : unhandledExceptions) {\n          PsiCodeBlock codeBlock = addCatchStatement(tryStatement, unhandledException, file);\n          if (catchBlockToSelect == null) catchBlockToSelect = codeBlock;\n        }\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    if (catchBlockToSelect != null) {\n      TextRange range = SurroundWithUtil.getRangeToSelect(catchBlockToSelect);\n      editor.getCaretModel().moveToOffset(range.getStartOffset());\n\n      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      editor.getSelectionModel().setSelection(range.getStartOffset(), range.getEndOffset());\n    }\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiCodeBlock addCatchStatement(PsiTryStatement tryStatement, PsiClassType exceptionType, PsiFile file) throws IncorrectOperationException {\n    PsiElementFactory factory = JavaPsiFacade.getInstance(tryStatement.getProject()).getElementFactory();\n\n    if (tryStatement.getTryBlock() == null) {\n      addTryBlock(tryStatement, factory);\n    }\n\n    JavaCodeStyleManager styleManager = JavaCodeStyleManager.getInstance(tryStatement.getProject());\n    String name = styleManager.suggestVariableName(VariableKind.PARAMETER, null, null, exceptionType).names[0];\n    name = styleManager.suggestUniqueVariableName(name, tryStatement, false);\n\n    PsiCatchSection catchSection = factory.createCatchSection(exceptionType, name, file);\n\n    PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n    if (finallyBlock == null) {\n      tryStatement.add(catchSection);\n    }\n    else {\n      tryStatement.addBefore(catchSection, getFinallySectionStart(finallyBlock));\n    }\n\n    PsiParameter[] parameters = tryStatement.getCatchBlockParameters();\n    parameters[parameters.length - 1].getTypeElement().replace(factory.createTypeElement(exceptionType));\n    PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n\n    return catchBlocks[catchBlocks.length - 1];\n  }","id":85540,"modified_method":"private static PsiCodeBlock addCatchStatement(PsiTryStatement tryStatement,\n                                                PsiClassType exceptionType,\n                                                PsiFile file) throws IncorrectOperationException {\n    PsiElementFactory factory = JavaPsiFacade.getInstance(tryStatement.getProject()).getElementFactory();\n\n    if (tryStatement.getTryBlock() == null) {\n      addTryBlock(tryStatement, factory);\n    }\n\n    JavaCodeStyleManager styleManager = JavaCodeStyleManager.getInstance(tryStatement.getProject());\n    String name = styleManager.suggestVariableName(VariableKind.PARAMETER, null, null, exceptionType).names[0];\n    name = styleManager.suggestUniqueVariableName(name, tryStatement, false);\n\n    PsiCatchSection catchSection = factory.createCatchSection(exceptionType, name, file);\n\n    PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n    if (finallyBlock == null) {\n      tryStatement.add(catchSection);\n    }\n    else {\n      tryStatement.addBefore(catchSection, getFinallySectionStart(finallyBlock));\n    }\n\n    PsiParameter[] parameters = tryStatement.getCatchBlockParameters();\n    PsiTypeElement typeElement = parameters[parameters.length - 1].getTypeElement();\n    if (typeElement != null) {\n      JavaCodeStyleManager.getInstance(file.getProject()).shortenClassReferences(typeElement);\n    }\n\n    PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n    return catchBlocks[catchBlocks.length - 1];\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processUsage(final UsageInfo usage, final PsiTypeParameter[] originalTypeParameters, final boolean[] toRemoveParms)\n    throws IncorrectOperationException {\n    PsiElementFactory factory = JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory();\n    PsiJavaCodeReferenceElement referenceElement = (PsiJavaCodeReferenceElement)usage.getElement();\n    PsiSubstitutor usageSubstitutor = determineUsageSubstitutor(referenceElement);\n\n    PsiReferenceParameterList referenceParameterList = referenceElement.getParameterList();\n    PsiTypeElement[] oldValues = referenceParameterList.getTypeParameterElements();\n    if (oldValues.length != originalTypeParameters.length) return;\n    List<PsiTypeElement> newValues = new ArrayList<PsiTypeElement>();\n    for (final TypeParameterInfo info : myNewSignature) {\n      int oldIndex = info.getOldParameterIndex();\n      if (oldIndex >= 0) {\n        newValues.add(oldValues[oldIndex]);\n      }\n      else {\n        PsiType type = info.getDefaultValue().getType(myClass.getLBrace(), PsiManager.getInstance(myProject));\n\n        PsiTypeElement newValue = factory.createTypeElement(usageSubstitutor.substitute(type));\n        newValues.add(newValue);\n      }\n    }\n    ChangeSignatureUtil.synchronizeList(referenceParameterList, newValues, ReferenceParameterList.INSTANCE, toRemoveParms);\n  }","id":85541,"modified_method":"private void processUsage(UsageInfo usage, PsiTypeParameter[] original, boolean[] toRemove) throws IncorrectOperationException {\n    PsiElementFactory factory = JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory();\n    PsiJavaCodeReferenceElement referenceElement = (PsiJavaCodeReferenceElement)usage.getElement();\n    assert referenceElement != null : usage;\n    PsiSubstitutor usageSubstitutor = determineUsageSubstitutor(referenceElement);\n\n    PsiReferenceParameterList referenceParameterList = referenceElement.getParameterList();\n    assert referenceParameterList != null : referenceElement;\n    PsiTypeElement[] oldValues = referenceParameterList.getTypeParameterElements();\n    if (oldValues.length != original.length) return;\n    List<PsiTypeElement> newValues = new ArrayList<PsiTypeElement>();\n    for (final TypeParameterInfo info : myNewSignature) {\n      int oldIndex = info.getOldParameterIndex();\n      if (oldIndex >= 0) {\n        newValues.add(oldValues[oldIndex]);\n      }\n      else {\n        PsiType type = info.getDefaultValue().getType(myClass.getLBrace(), PsiManager.getInstance(myProject));\n\n        PsiTypeElement newValue = factory.createTypeElement(usageSubstitutor.substitute(type));\n        newValues.add(newValue);\n      }\n    }\n\n    ChangeSignatureUtil.synchronizeList(referenceParameterList, newValues, ReferenceParameterList.INSTANCE, toRemove);\n    JavaCodeStyleManager.getInstance(myProject).shortenClassReferences(referenceParameterList);\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean[] detectRemovedParameters(final PsiTypeParameter[] originaltypeParameters) {\n    final boolean[] toRemoveParms = new boolean[originaltypeParameters.length];\n    Arrays.fill(toRemoveParms, true);\n    for (final TypeParameterInfo info : myNewSignature) {\n      int oldParameterIndex = info.getOldParameterIndex();\n      if (oldParameterIndex >= 0) {\n        toRemoveParms[oldParameterIndex] = false;\n      }\n    }\n    return toRemoveParms;\n  }","id":85542,"modified_method":"private boolean[] detectRemovedParameters(final PsiTypeParameter[] original) {\n    final boolean[] toRemove = new boolean[original.length];\n    Arrays.fill(toRemove, true);\n    for (final TypeParameterInfo info : myNewSignature) {\n      int oldParameterIndex = info.getOldParameterIndex();\n      if (oldParameterIndex >= 0) {\n        toRemove[oldParameterIndex] = false;\n      }\n    }\n    return toRemove;\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void invoke(@NotNull final Project project, Editor editor, final PsiFile file) {\n    if (!FileModificationService.getInstance().prepareFileForWrite(file)) return;\n\n    final PsiTypeParameter[] typeParameters = myPsiClass.getTypeParameters();\n    final PsiSubstitutor psiSubstitutor = inferTypeArguments();\n    final PsiJavaCodeReferenceElement reference = myNewExpression.getClassOrAnonymousClassReference();\n    LOG.assertTrue(reference != null, myNewExpression);\n    final PsiReferenceParameterList parameterList = reference.getParameterList();\n    LOG.assertTrue(parameterList != null, myNewExpression);\n    PsiTypeElement[] elements = parameterList.getTypeParameterElements();\n    for (int i = elements.length - 1; i >= 0; i--) {\n      PsiTypeElement typeElement = elements[i];\n      final PsiType typeArg = psiSubstitutor.substitute(typeParameters[i]);\n      typeElement.replace(JavaPsiFacade.getElementFactory(project).createTypeElement(typeArg));\n    }\n  }","id":85543,"modified_method":"@Override\n  public void invoke(@NotNull final Project project, Editor editor, final PsiFile file) {\n    if (!FileModificationService.getInstance().prepareFileForWrite(file)) return;\n\n    final PsiTypeParameter[] typeParameters = myPsiClass.getTypeParameters();\n    final PsiSubstitutor psiSubstitutor = inferTypeArguments();\n    final PsiJavaCodeReferenceElement reference = myNewExpression.getClassOrAnonymousClassReference();\n    LOG.assertTrue(reference != null, myNewExpression);\n    final PsiReferenceParameterList parameterList = reference.getParameterList();\n    LOG.assertTrue(parameterList != null, myNewExpression);\n    PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n    PsiTypeElement[] elements = parameterList.getTypeParameterElements();\n    for (int i = elements.length - 1; i >= 0; i--) {\n      PsiType typeArg = assertNotNull(psiSubstitutor.substitute(typeParameters[i]));\n      PsiElement replaced = elements[i].replace(factory.createTypeElement(typeArg));\n      JavaCodeStyleManager.getInstance(file.getProject()).shortenClassReferences(replaced);\n    }\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void replaceNewOrType(final PsiNewExpression psiNewExpression, final PsiClassType superType) {\n    try {\n      if (psiNewExpression.getArrayDimensions().length == 0 && psiNewExpression.getArrayInitializer() == null) {\n        new InlineToAnonymousConstructorProcessor(myClass, psiNewExpression, superType).run();\n      }\n      else {\n        PsiJavaCodeReferenceElement element =\n          JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory().createClassReferenceElement(superType.resolve());\n        psiNewExpression.getClassReference().replace(element);        \n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":85544,"modified_method":"private void replaceNewOrType(final PsiNewExpression psiNewExpression, final PsiClassType superType) {\n    try {\n      if (psiNewExpression.getArrayDimensions().length == 0 && psiNewExpression.getArrayInitializer() == null) {\n        new InlineToAnonymousConstructorProcessor(myClass, psiNewExpression, superType).run();\n      }\n      else {\n        PsiClass target = superType.resolve();\n        assert target != null : superType;\n        PsiElementFactory factory = JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory();\n        PsiJavaCodeReferenceElement element = factory.createClassReferenceElement(target);\n        PsiJavaCodeReferenceElement reference = psiNewExpression.getClassReference();\n        assert reference != null : psiNewExpression;\n        reference.replace(element);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void replaceWithSuperType(final PsiTypeElement typeElement, final PsiClassType superType) {\n    PsiElementFactory factory = JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory();\n    PsiClassType psiType = (PsiClassType) typeElement.getType();\n    PsiClassType.ClassResolveResult classResolveResult = psiType.resolveGenerics();\n    PsiType substType = classResolveResult.getSubstitutor().substitute(superType);\n    assert classResolveResult.getElement() == myClass;\n    try {\n      typeElement.replace(factory.createTypeElement(substType));\n    }\n    catch(IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":85545,"modified_method":"private void replaceWithSuperType(final PsiTypeElement typeElement, final PsiClassType superType) {\n    PsiElementFactory factory = JavaPsiFacade.getInstance(myClass.getProject()).getElementFactory();\n    PsiClassType psiType = (PsiClassType) typeElement.getType();\n    PsiClassType.ClassResolveResult classResolveResult = psiType.resolveGenerics();\n    PsiType substType = classResolveResult.getSubstitutor().substitute(superType);\n    assert classResolveResult.getElement() == myClass;\n    try {\n      PsiElement replaced = typeElement.replace(factory.createTypeElement(substType));\n      JavaCodeStyleManager.getInstance(myProject).shortenClassReferences(replaced);\n    }\n    catch(IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void fixUsage() throws IncorrectOperationException {\n    if (myTypeElement.isValid()) {\n      final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(myTypeElement.getProject()).getElementFactory();\n      myTypeElement.replace(elementFactory.createTypeElement(myTargetClassType));\n    }\n  }","id":85546,"modified_method":"public void fixUsage() throws IncorrectOperationException {\n    if (myTypeElement.isValid()) {\n      Project project = myTypeElement.getProject();\n      PsiElementFactory elementFactory = JavaPsiFacade.getInstance(project).getElementFactory();\n      PsiElement replaced = myTypeElement.replace(elementFactory.createTypeElement(myTargetClassType));\n      JavaCodeStyleManager.getInstance(project).shortenClassReferences(replaced);\n    }\n  }","commit_id":"8207bd5650cc890652fd95fa434d2db459d72f7b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(method)) {\n        return;\n      }\n      super.visitMethod(method);\n      final PsiParameterList parameterList = method.getParameterList();\n      if (parameterList.getParametersCount() == 0) {\n        return;\n      }\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiParameter lastParameter =\n        parameters[parameters.length - 1];\n      final PsiType type = lastParameter.getType();\n      if (!(type instanceof PsiArrayType)) {\n        return;\n      }\n      if (type instanceof PsiEllipsisType) {\n        return;\n      }\n      final PsiArrayType arrayType = (PsiArrayType)type;\n      final PsiType componentType = arrayType.getComponentType();\n      if (componentType instanceof PsiArrayType) {\n        // don't report when it is multidimensional array\n        return;\n      }\n      if (ignoreByteAndShortArrayParameters) {\n        if (PsiType.BYTE.equals(componentType) ||\n            PsiType.SHORT.equals(componentType)) {\n          return;\n        }\n      }\n      registerMethodError(method);\n    }","id":85547,"modified_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(method)) {\n        return;\n      }\n      super.visitMethod(method);\n      final PsiParameterList parameterList = method.getParameterList();\n      if (parameterList.getParametersCount() == 0) {\n        return;\n      }\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiParameter lastParameter =\n        parameters[parameters.length - 1];\n      final PsiType type = lastParameter.getType();\n      if (!(type instanceof PsiArrayType)) {\n        return;\n      }\n      if (type instanceof PsiEllipsisType) {\n        return;\n      }\n      final PsiArrayType arrayType = (PsiArrayType)type;\n      final PsiType componentType = arrayType.getComponentType();\n      if (componentType instanceof PsiArrayType) {\n        // don't report when it is multidimensional array\n        return;\n      }\n      if (ignoreByteAndShortArrayParameters) {\n        if (PsiType.BYTE.equals(componentType) ||\n            PsiType.SHORT.equals(componentType)) {\n          return;\n        }\n      }\n      if (LibraryUtil.isOverrideOfLibraryMethod(method)) {\n        return;\n      }\n      registerMethodError(method);\n    }","commit_id":"4aeb6754292e6795c777cc75be84918624b277e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void doFix(Project project, ProblemDescriptor descriptor)\n      throws IncorrectOperationException {\n      final PsiElement element = descriptor.getPsiElement();\n      final PsiElement parent = element.getParent();\n      if (!(parent instanceof PsiMethod)) {\n        return;\n      }\n      final PsiMethod method = (PsiMethod)parent;\n      final PsiParameterList parameterList = method.getParameterList();\n      if (parameterList.getParametersCount() == 0) {\n        return;\n      }\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiParameter lastParameter =\n        parameters[parameters.length - 1];\n      final PsiType type = lastParameter.getType();\n      if (!(type instanceof PsiArrayType)) {\n        return;\n      }\n      final PsiArrayType arrayType = (PsiArrayType)type;\n      final PsiType componentType = arrayType.getComponentType();\n      final PsiElementFactory factory =\n        JavaPsiFacade.getElementFactory(project);\n      final PsiTypeElement newTypeElement =\n        factory.createTypeElementFromText(\n          componentType.getCanonicalText() + \"...\", method);\n      lastParameter.getTypeElement().replace(newTypeElement);\n    }","id":85548,"modified_method":"@Override\n    protected void doFix(Project project, ProblemDescriptor descriptor)\n      throws IncorrectOperationException {\n      final PsiElement element = descriptor.getPsiElement();\n      final PsiElement parent = element.getParent();\n      if (!(parent instanceof PsiMethod)) {\n        return;\n      }\n      final PsiMethod method = (PsiMethod)parent;\n      final PsiParameterList parameterList = method.getParameterList();\n      if (parameterList.getParametersCount() == 0) {\n        return;\n      }\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiParameter lastParameter =\n        parameters[parameters.length - 1];\n      final PsiType type = lastParameter.getType();\n      if (!(type instanceof PsiArrayType)) {\n        return;\n      }\n      final PsiArrayType arrayType = (PsiArrayType)type;\n      final PsiType componentType = arrayType.getComponentType();\n      final PsiElementFactory factory =\n        JavaPsiFacade.getElementFactory(project);\n      final PsiTypeElement newTypeElement =\n        factory.createTypeElementFromText(\n          componentType.getCanonicalText() + \"...\", method);\n      final PsiTypeElement typeElement = lastParameter.getTypeElement();\n      if (typeElement != null) {\n        typeElement.replace(newTypeElement);\n      }\n    }","commit_id":"4aeb6754292e6795c777cc75be84918624b277e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void handleTcpIp(final org.w3c.dom.Node node) {\n        final NamedNodeMap atts = node.getAttributes();\n        final Join join = config.getNetworkConfig().getJoin();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            final String value = getTextContent(att).trim();\n            if (att.getNodeName().equals(\"enabled\")) {\n                join.getTcpIpConfig().setEnabled(checkTrue(value));\n            } else if (att.getNodeName().equals(\"conn-timeout-seconds\")) {\n                join.getTcpIpConfig().setConnectionTimeoutSeconds(getIntegerValue(\"conn-timeout-seconds\", value, 5));\n            }\n        }\n        final NodeList nodelist = node.getChildNodes();\n        members:\n        for (int i = 0; i < nodelist.getLength(); i++) {\n            final org.w3c.dom.Node n = nodelist.item(i);\n            final String value = getTextContent(n).trim();\n            if (n.getNodeName().equalsIgnoreCase(\"required-member\")) {\n                join.getTcpIpConfig().setRequiredMember(value);\n            } else if (n.getNodeName().equalsIgnoreCase(\"hostname\")) {\n                join.getTcpIpConfig().addMember(value);\n            } else if (n.getNodeName().equalsIgnoreCase(\"address\")) {\n                int colonIndex = value.indexOf(':');\n                if (colonIndex == -1) {\n                    logger.log(Level.WARNING, \"Address should be in the form of ip:port. Address [\" + value + \"] is not valid.\");\n                } else {\n                    String hostStr = value.substring(0, colonIndex);\n                    String portStr = value.substring(colonIndex + 1);\n                    try {\n                        join.getTcpIpConfig().addAddress(new Address(hostStr, Integer.parseInt(portStr), true));\n                    } catch (UnknownHostException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } else if (\"interface\".equalsIgnoreCase(n.getNodeName())) {\n                final int indexStar = value.indexOf('*');\n                final int indexDash = value.indexOf('-');\n                if (indexStar == -1 && indexDash == -1) {\n                    join.getTcpIpConfig().addMember(value);\n                } else {\n                    final String first3 = value.substring(0, value.lastIndexOf('.'));\n                    final String lastOne = value.substring(value.lastIndexOf('.') + 1);\n                    if (first3.indexOf('*') != -1 && first3.indexOf('-') != -1) {\n                        String msg = \"First 3 parts of interface definition cannot contain '*' and '-'.\";\n                        msg += \"\\nPlease change the value '\" + value + \"' in the config file.\";\n                        logger.log(Level.WARNING, msg);\n                        continue members;\n                    }\n                    if (lastOne.equals(\"*\")) {\n                        for (int j = 0; j < 256; j++) {\n                            join.getTcpIpConfig().addMember(first3 + \".\" + String.valueOf(j));\n                        }\n                    } else if (lastOne.indexOf('-') != -1) {\n                        final int start = Integer.parseInt(lastOne.substring(0, lastOne\n                                .indexOf('-')));\n                        final int end = Integer.parseInt(lastOne\n                                .substring(lastOne.indexOf('-') + 1));\n                        for (int j = start; j <= end; j++) {\n                            join.getTcpIpConfig().addMember(first3 + \".\" + String.valueOf(j));\n                        }\n                    }\n                }\n            }\n        }\n    }","id":85549,"modified_method":"private void handleTcpIp(final org.w3c.dom.Node node) {\n        final NamedNodeMap atts = node.getAttributes();\n        final Join join = config.getNetworkConfig().getJoin();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            final String value = getTextContent(att).trim();\n            if (att.getNodeName().equals(\"enabled\")) {\n                join.getTcpIpConfig().setEnabled(checkTrue(value));\n            } else if (att.getNodeName().equals(\"conn-timeout-seconds\")) {\n                join.getTcpIpConfig().setConnectionTimeoutSeconds(getIntegerValue(\"conn-timeout-seconds\", value, 5));\n            }\n        }\n        final NodeList nodelist = node.getChildNodes();\n        members:\n        for (int i = 0; i < nodelist.getLength(); i++) {\n            final org.w3c.dom.Node n = nodelist.item(i);\n            final String value = getTextContent(n).trim();\n            if (cleanNodeName(n.getNodeName()).equals(\"required-member\")) {\n                join.getTcpIpConfig().setRequiredMember(value);\n            } else if (cleanNodeName(n.getNodeName()).equals(\"hostname\")) {\n                join.getTcpIpConfig().addMember(value);\n            } else if (cleanNodeName(n.getNodeName()).equals(\"address\")) {\n                int colonIndex = value.indexOf(':');\n                if (colonIndex == -1) {\n                    logger.log(Level.WARNING, \"Address should be in the form of ip:port. Address [\" + value + \"] is not valid.\");\n                } else {\n                    String hostStr = value.substring(0, colonIndex);\n                    String portStr = value.substring(colonIndex + 1);\n                    try {\n                        join.getTcpIpConfig().addAddress(new Address(hostStr, Integer.parseInt(portStr), true));\n                    } catch (UnknownHostException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } else if (\"interface\".equals(cleanNodeName(n.getNodeName()))) {\n                final int indexStar = value.indexOf('*');\n                final int indexDash = value.indexOf('-');\n                if (indexStar == -1 && indexDash == -1) {\n                    join.getTcpIpConfig().addMember(value);\n                } else {\n                    final String first3 = value.substring(0, value.lastIndexOf('.'));\n                    final String lastOne = value.substring(value.lastIndexOf('.') + 1);\n                    if (first3.indexOf('*') != -1 && first3.indexOf('-') != -1) {\n                        String msg = \"First 3 parts of interface definition cannot contain '*' and '-'.\";\n                        msg += \"\\nPlease change the value '\" + value + \"' in the config file.\";\n                        logger.log(Level.WARNING, msg);\n                        continue members;\n                    }\n                    if (lastOne.equals(\"*\")) {\n                        for (int j = 0; j < 256; j++) {\n                            join.getTcpIpConfig().addMember(first3 + \".\" + String.valueOf(j));\n                        }\n                    } else if (lastOne.indexOf('-') != -1) {\n                        final int start = Integer.parseInt(lastOne.substring(0, lastOne\n                                .indexOf('-')));\n                        final int end = Integer.parseInt(lastOne\n                                .substring(lastOne.indexOf('-') + 1));\n                        for (int j = start; j <= end; j++) {\n                            join.getTcpIpConfig().addMember(first3 + \".\" + String.valueOf(j));\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleTopic(final org.w3c.dom.Node node) {\n        final Node attName = node.getAttributes().getNamedItem(\"name\");\n        final String name = getTextContent(attName);\n        final TopicConfig tConfig = new TopicConfig();\n        tConfig.setName(name);\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            if (n.getNodeName().equalsIgnoreCase(\"global-ordering-enabled\")) {\n                tConfig.setGlobalOrderingEnabled(checkTrue(value));\n            }\n        }\n        config.getTopicConfigs().put(name, tConfig);\n    }","id":85550,"modified_method":"public void handleTopic(final org.w3c.dom.Node node) {\n        final Node attName = node.getAttributes().getNamedItem(\"name\");\n        final String name = getTextContent(attName);\n        final TopicConfig tConfig = new TopicConfig();\n        tConfig.setName(name);\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            if (cleanNodeName(n.getNodeName()).equals(\"global-ordering-enabled\")) {\n                tConfig.setGlobalOrderingEnabled(checkTrue(value));\n            }\n        }\n        config.getTopicConfigs().put(name, tConfig);\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void parse(final Config config) throws Exception {\n        this.config = config;\n        final DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc = null;\n        try {\n            doc = builder.parse(in);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            Util.streamXML(doc, baos);\n            final byte[] bytes = baos.toByteArray();\n            final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n            config.setXmlConfig(Util.inputStreamToString(bais));\n            if (\"true\".equals(System.getProperty(\"hazelcast.config.print\"))) {\n                logger.log(Level.INFO, \"Hazelcast config URL : \" + config.getConfigurationUrl());\n                logger.log(Level.INFO, \"=== Hazelcast config xml ===\");\n                logger.log(Level.INFO, config.getXmlConfig());\n                logger.log(Level.INFO, \"==============================\");\n                logger.log(Level.INFO, \"\");\n            }\n        } catch (final Exception e) {\n            String msgPart = \"config file '\" + config.getConfigurationFile() + \"' set as a system property.\";\n            if (!usingSystemConfig) {\n                msgPart = \"hazelcast-default.xml config file in the classpath.\";\n            }\n            String msg = \"Having problem parsing the \" + msgPart;\n            msg += \"\\nException: \" + e.getMessage();\n            msg += \"\\nHazelcast will start with default configuration.\";\n            logger.log(Level.WARNING, msg);\n            return;\n        }\n        final Element docElement = doc.getDocumentElement();\n        try {\n            docElement.getTextContent();\n        } catch (final Throwable e) {\n            domLevel3 = false;\n        }\n        for (org.w3c.dom.Node node : new IterableNodeList(docElement.getChildNodes())) {\n            final String nodeName = node.getNodeName();\n            if (\"network\".equals(nodeName)) {\n                handleNetwork(node);\n            } else if (\"group\".equals(nodeName)) {\n                handleGroup(node);\n            } else if (\"properties\".equals(nodeName)) {\n                handleProperties(node, config.getProperties());\n            } else if (\"executor-service\".equals(nodeName)) {\n                handleExecutor(node);\n            } else if (\"queue\".equals(nodeName)) {\n                handleQueue(node);\n            } else if (\"map\".equals(nodeName)) {\n                handleMap(node);\n            } else if (\"topic\".equals(nodeName)) {\n                handleTopic(node);\n            } else if (\"merge-policies\".equals(nodeName)) {\n                handleMergePolicies(node);\n            }\n        }\n    }","id":85551,"modified_method":"private void parse(final Config config) throws Exception {\n        this.config = config;\n        final DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        Document doc = null;\n        try {\n            doc = builder.parse(in);\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            Util.streamXML(doc, baos);\n            final byte[] bytes = baos.toByteArray();\n            final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n            config.setXmlConfig(Util.inputStreamToString(bais));\n            if (\"true\".equals(System.getProperty(\"hazelcast.config.print\"))) {\n                logger.log(Level.INFO, \"Hazelcast config URL : \" + config.getConfigurationUrl());\n                logger.log(Level.INFO, \"=== Hazelcast config xml ===\");\n                logger.log(Level.INFO, config.getXmlConfig());\n                logger.log(Level.INFO, \"==============================\");\n                logger.log(Level.INFO, \"\");\n            }\n        } catch (final Exception e) {\n            String msgPart = \"config file '\" + config.getConfigurationFile() + \"' set as a system property.\";\n            if (!usingSystemConfig) {\n                msgPart = \"hazelcast-default.xml config file in the classpath.\";\n            }\n            String msg = \"Having problem parsing the \" + msgPart;\n            msg += \"\\nException: \" + e.getMessage();\n            msg += \"\\nHazelcast will start with default configuration.\";\n            logger.log(Level.WARNING, msg);\n            return;\n        }\n        final Element docElement = doc.getDocumentElement();\n        try {\n            docElement.getTextContent();\n        } catch (final Throwable e) {\n            domLevel3 = false;\n        }\n        for (org.w3c.dom.Node node : new IterableNodeList(docElement.getChildNodes())) {\n            final String nodeName = cleanNodeName(node.getNodeName());\n            if (\"network\".equals(nodeName)) {\n                handleNetwork(node);\n            } else if (\"group\".equals(nodeName)) {\n                handleGroup(node);\n            } else if (\"properties\".equals(nodeName)) {\n                handleProperties(node, config.getProperties());\n            } else if (\"executor-service\".equals(nodeName)) {\n                handleExecutor(node);\n            } else if (\"queue\".equals(nodeName)) {\n                handleQueue(node);\n            } else if (\"map\".equals(nodeName)) {\n                handleMap(node);\n            } else if (\"topic\".equals(nodeName)) {\n                handleTopic(node);\n            } else if (\"merge-policies\".equals(nodeName)) {\n                handleMergePolicies(node);\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleExecutor(final org.w3c.dom.Node node) throws Exception {\n        final ExecutorConfig executorConfig = new ExecutorConfig();\n        handleViaReflection(node, config, executorConfig);\n    }","id":85552,"modified_method":"public void handleExecutor(final org.w3c.dom.Node node) throws Exception {\n        final ExecutorConfig executorConfig = new ExecutorConfig();\n        handleViaReflection(node, config, executorConfig);\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleGroup(final org.w3c.dom.Node node) {\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            final String nodeName = n.getNodeName().toLowerCase();\n            if (\"name\".equals(nodeName)) {\n                config.getGroupConfig().setName(value);\n            } else if (\"password\".equals(nodeName)) {\n                config.getGroupConfig().setPassword(value);\n            }\n        }\n    }","id":85553,"modified_method":"public void handleGroup(final org.w3c.dom.Node node) {\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            final String nodeName = cleanNodeName(n.getNodeName());\n            if (\"name\".equals(nodeName)) {\n                config.getGroupConfig().setName(value);\n            } else if (\"password\".equals(nodeName)) {\n                config.getGroupConfig().setPassword(value);\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleMergePolicies(final org.w3c.dom.Node node) throws Exception {\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = n.getNodeName().toLowerCase();\n            if (nodeName.equals(\"map-merge-policy\")) {\n                handleViaReflection(n, config, new MergePolicyConfig());\n            }\n        }\n    }","id":85554,"modified_method":"public void handleMergePolicies(final org.w3c.dom.Node node) throws Exception {\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = cleanNodeName(n.getNodeName());\n            if (nodeName.equals(\"map-merge-policy\")) {\n                handleViaReflection(n, config, new MergePolicyConfig());\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleJoin(final org.w3c.dom.Node node) {\n        for (org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {\n            final String name = child.getNodeName().toLowerCase();\n            if (\"multicast\".equals(name)) {\n                handleMulticast(child);\n            } else if (\"tcp-ip\".equals(name)) {\n                handleTcpIp(child);\n            }\n        }\n    }","id":85555,"modified_method":"private void handleJoin(final org.w3c.dom.Node node) {\n        for (org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {\n            final String name = cleanNodeName(child.getNodeName());\n            if (\"multicast\".equals(name)) {\n                handleMulticast(child);\n            } else if (\"tcp-ip\".equals(name)) {\n                handleTcpIp(child);\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private MapStoreConfig createMapStoreConfig(final org.w3c.dom.Node node) {\n        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n        final NamedNodeMap atts = node.getAttributes();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            final String value = getTextContent(att).trim();\n            if (att.getNodeName().equals(\"enabled\")) {\n                mapStoreConfig.setEnabled(checkTrue(value));\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = n.getNodeName().toLowerCase();\n            final String value = getTextContent(n).trim();\n            if (\"class-name\".equals(nodeName)) {\n                mapStoreConfig.setClassName(value);\n            } else if (\"write-delay-seconds\".equals(nodeName)) {\n                mapStoreConfig.setWriteDelaySeconds(getIntegerValue(\"write-delay-seconds\", value, MapStoreConfig.DEFAULT_WRITE_DELAY_SECONDS));\n            }\n        }\n        handleProperties(node, mapStoreConfig.getProperties());\n        return mapStoreConfig;\n    }","id":85556,"modified_method":"private MapStoreConfig createMapStoreConfig(final org.w3c.dom.Node node) {\n        MapStoreConfig mapStoreConfig = new MapStoreConfig();\n        final NamedNodeMap atts = node.getAttributes();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            final String value = getTextContent(att).trim();\n            if (att.getNodeName().equals(\"enabled\")) {\n                mapStoreConfig.setEnabled(checkTrue(value));\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = cleanNodeName(n.getNodeName());\n            final String value = getTextContent(n).trim();\n            if (\"class-name\".equals(nodeName)) {\n                mapStoreConfig.setClassName(value);\n            } else if (\"write-delay-seconds\".equals(nodeName)) {\n                mapStoreConfig.setWriteDelaySeconds(getIntegerValue(\"write-delay-seconds\", value, MapStoreConfig.DEFAULT_WRITE_DELAY_SECONDS));\n            }\n        }\n        handleProperties(node, mapStoreConfig.getProperties());\n        return mapStoreConfig;\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleViaReflection(final org.w3c.dom.Node node, Object parent, Object target) throws Exception {\n        final NamedNodeMap atts = node.getAttributes();\n        if (atts != null) {\n            for (int a = 0; a < atts.getLength(); a++) {\n                final org.w3c.dom.Node att = atts.item(a);\n                String methodName = \"set\" + getMethodName(att.getNodeName());\n                Method method = getMethod(target, methodName);\n                final String value = att.getNodeValue();\n                invoke(target, method, value);\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            String methodName = \"set\" + getMethodName(n.getNodeName());\n            Method method = getMethod(target, methodName);\n            invoke(target, method, value);\n        }\n        String mName = \"set\" + target.getClass().getSimpleName();\n        Method method = getMethod(parent, mName);\n        if (method == null) {\n            mName = \"add\" + target.getClass().getSimpleName();\n            method = getMethod(parent, mName);\n        }\n        method.invoke(parent, new Object[]{target});\n    }","id":85557,"modified_method":"private void handleViaReflection(final org.w3c.dom.Node node, Object parent, Object target) throws Exception {\n        final NamedNodeMap atts = node.getAttributes();\n        if (atts != null) {\n            for (int a = 0; a < atts.getLength(); a++) {\n                final org.w3c.dom.Node att = atts.item(a);\n                String methodName = \"set\" + getMethodName(att.getNodeName());\n                Method method = getMethod(target, methodName);\n                final String value = att.getNodeValue();\n                invoke(target, method, value);\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            String methodName = \"set\" + getMethodName(cleanNodeName(n.getNodeName()));\n            Method method = getMethod(target, methodName);\n            invoke(target, method, value);\n        }\n        String mName = \"set\" + target.getClass().getSimpleName();\n        Method method = getMethod(parent, mName);\n        if (method == null) {\n            mName = \"add\" + target.getClass().getSimpleName();\n            method = getMethod(parent, mName);\n        }\n        method.invoke(parent, new Object[]{target});\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleProperties(final org.w3c.dom.Node node, Properties properties) {\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            final String name = n.getNodeName().toLowerCase();\n            properties.setProperty(name, value);\n        }\n    }","id":85558,"modified_method":"public void handleProperties(final org.w3c.dom.Node node, Properties properties) {\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            final String name = cleanNodeName(n.getNodeName());\n            properties.setProperty(name, value);\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleQueue(final org.w3c.dom.Node node) {\n        final Node attName = node.getAttributes().getNamedItem(\"name\");\n        final String name = getTextContent(attName);\n        final QueueConfig qConfig = new QueueConfig();\n        qConfig.setName(name);\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = n.getNodeName().toLowerCase();\n            final String value = getTextContent(n).trim();\n            if (\"max-size-per-jvm\".equals(nodeName)) {\n                qConfig.setMaxSizePerJVM(getIntegerValue(\"max-size-per-jvm\", value, QueueConfig.DEFAULT_MAX_SIZE_PER_JVM));\n            } else if (\"time-to-live-seconds\".equals(nodeName)) {\n                qConfig.setTimeToLiveSeconds(getIntegerValue(\"time-to-live-seconds\", value, QueueConfig.DEFAULT_TTL_SECONDS));\n            }\n        }\n        this.config.getQConfigs().put(name, qConfig);\n    }","id":85559,"modified_method":"public void handleQueue(final org.w3c.dom.Node node) {\n        final Node attName = node.getAttributes().getNamedItem(\"name\");\n        final String name = getTextContent(attName);\n        final QueueConfig qConfig = new QueueConfig();\n        qConfig.setName(name);\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = cleanNodeName(n.getNodeName());\n            final String value = getTextContent(n).trim();\n            if (\"max-size-per-jvm\".equals(nodeName)) {\n                qConfig.setMaxSizePerJVM(getIntegerValue(\"max-size-per-jvm\", value, QueueConfig.DEFAULT_MAX_SIZE_PER_JVM));\n            } else if (\"time-to-live-seconds\".equals(nodeName)) {\n                qConfig.setTimeToLiveSeconds(getIntegerValue(\"time-to-live-seconds\", value, QueueConfig.DEFAULT_TTL_SECONDS));\n            }\n        }\n        this.config.getQConfigs().put(name, qConfig);\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleMulticast(final org.w3c.dom.Node node) {\n        final NamedNodeMap atts = node.getAttributes();\n        final Join join = config.getNetworkConfig().getJoin();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            final String value = getTextContent(att).trim();\n            if (\"enabled\".equalsIgnoreCase(att.getNodeName())) {\n                join.getMulticastConfig().setEnabled(checkTrue(value));\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            if (\"multicast-group\".equalsIgnoreCase(n.getNodeName())) {\n                join.getMulticastConfig().setMulticastGroup(value);\n            } else if (\"multicast-port\".equalsIgnoreCase(n.getNodeName())) {\n                join.getMulticastConfig().setMulticastPort(Integer.parseInt(value));\n            } else if (\"multicast-timeout-seconds\".equalsIgnoreCase(n.getNodeName())) {\n                join.getMulticastConfig().setMulticastTimeoutSeconds(Integer.parseInt(value));\n            }\n        }\n    }","id":85560,"modified_method":"private void handleMulticast(final org.w3c.dom.Node node) {\n        final NamedNodeMap atts = node.getAttributes();\n        final Join join = config.getNetworkConfig().getJoin();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            final String value = getTextContent(att).trim();\n            if (\"enabled\".equalsIgnoreCase(att.getNodeName())) {\n                join.getMulticastConfig().setEnabled(checkTrue(value));\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String value = getTextContent(n).trim();\n            if (\"multicast-group\".equals(cleanNodeName(n.getNodeName()))) {\n                join.getMulticastConfig().setMulticastGroup(value);\n            } else if (\"multicast-port\".equals(cleanNodeName(n.getNodeName()))) {\n                join.getMulticastConfig().setMulticastPort(Integer.parseInt(value));\n            } else if (\"multicast-timeout-seconds\".equals(cleanNodeName(n.getNodeName()))) {\n                join.getMulticastConfig().setMulticastTimeoutSeconds(Integer.parseInt(value));\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleNetwork(final org.w3c.dom.Node node) throws Exception {\n        for (org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = child.getNodeName();\n            if (\"port\".equals(nodeName)) {\n                handlePort(child);\n            } else if (\"join\".equals(nodeName)) {\n                handleJoin(child);\n            } else if (\"interfaces\".equals(nodeName)) {\n                handleInterfaces(child);\n            } else if (\"symmetric-encryption\".equals(nodeName)) {\n                handleViaReflection(child, config.getNetworkConfig(), new SymmetricEncryptionConfig());\n            } else if (\"asymmetric-encryption\".equals(nodeName)) {\n                handleViaReflection(child, config.getNetworkConfig(), new AsymmetricEncryptionConfig());\n            }\n        }\n    }","id":85561,"modified_method":"public void handleNetwork(final org.w3c.dom.Node node) throws Exception {\n        for (org.w3c.dom.Node child : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = cleanNodeName(child.getNodeName());\n            if (\"port\".equals(nodeName)) {\n                handlePort(child);\n            } else if (\"join\".equals(nodeName)) {\n                handleJoin(child);\n            } else if (\"interfaces\".equals(nodeName)) {\n                handleInterfaces(child);\n            } else if (\"symmetric-encryption\".equals(nodeName)) {\n                handleViaReflection(child, config.getNetworkConfig(), new SymmetricEncryptionConfig());\n            } else if (\"asymmetric-encryption\".equals(nodeName)) {\n                handleViaReflection(child, config.getNetworkConfig(), new AsymmetricEncryptionConfig());\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleInterfaces(final org.w3c.dom.Node node) {\n        final NamedNodeMap atts = node.getAttributes();\n        final Interfaces interfaces = config.getNetworkConfig().getInterfaces();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            if (\"enabled\".equals(att.getNodeName())) {\n                final String value = att.getNodeValue();\n                interfaces.setEnabled(checkTrue(value));\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            if (\"interface\".equalsIgnoreCase(n.getNodeName())) {\n                final String value = getTextContent(n).trim();\n                interfaces.addInterface(value);\n            }\n        }\n    }","id":85562,"modified_method":"private void handleInterfaces(final org.w3c.dom.Node node) {\n        final NamedNodeMap atts = node.getAttributes();\n        final Interfaces interfaces = config.getNetworkConfig().getInterfaces();\n        for (int a = 0; a < atts.getLength(); a++) {\n            final org.w3c.dom.Node att = atts.item(a);\n            if (\"enabled\".equals(att.getNodeName())) {\n                final String value = att.getNodeValue();\n                interfaces.setEnabled(checkTrue(value));\n            }\n        }\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            if (\"interface\".equalsIgnoreCase(cleanNodeName(n.getNodeName()))) {\n                final String value = getTextContent(n).trim();\n                interfaces.addInterface(value);\n            }\n        }\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void handleMap(final org.w3c.dom.Node node) throws Exception {\n        final Node attName = node.getAttributes().getNamedItem(\"name\");\n        final String name = getTextContent(attName);\n        final MapConfig mapConfig = new MapConfig();\n        mapConfig.setName(name);\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = n.getNodeName().toLowerCase();\n            final String value = getTextContent(n).trim();\n            if (\"backup-count\".equals(nodeName)) {\n                mapConfig.setBackupCount(getIntegerValue(\"backup-count\", value, MapConfig.DEFAULT_BACKUP_COUNT));\n            } else if (\"eviction-policy\".equals(nodeName)) {\n                mapConfig.setEvictionPolicy(value);\n            } else if (\"max-size\".equals(nodeName)) {\n                mapConfig.setMaxSize(getIntegerValue(\"max-size\", value,\n                        MapConfig.DEFAULT_MAX_SIZE));\n            } else if (\"eviction-percentage\".equals(nodeName)) {\n                mapConfig.setEvictionPercentage(getIntegerValue(\"eviction-percentage\", value,\n                        MapConfig.DEFAULT_EVICTION_PERCENTAGE));\n            } else if (\"eviction-delay-seconds\".equals(nodeName)) {\n                mapConfig.setEvictionDelaySeconds(getIntegerValue(\"eviction-delay-seconds\", value,\n                        MapConfig.DEFAULT_EVICTION_DELAY_SECONDS));\n            } else if (\"time-to-live-seconds\".equals(nodeName)) {\n                mapConfig.setTimeToLiveSeconds(getIntegerValue(\"time-to-live-seconds\", value,\n                        MapConfig.DEFAULT_TTL_SECONDS));\n            } else if (\"max-idle-seconds\".equals(nodeName)) {\n                mapConfig.setMaxIdleSeconds(getIntegerValue(\"max-idle-seconds\", value,\n                        MapConfig.DEFAULT_MAX_IDLE_SECONDS));\n            } else if (\"map-store\".equals(nodeName)) {\n                MapStoreConfig mapStoreConfig = createMapStoreConfig(n);\n                mapConfig.setMapStoreConfig(mapStoreConfig);\n            } else if (\"near-cache\".equals(nodeName)) {\n                handleViaReflection(n, mapConfig, new NearCacheConfig());\n            } else if (\"merge-policy\".equals(nodeName)) {\n                mapConfig.setMergePolicy(value);\n            }\n        }\n        this.config.getMapConfigs().put(name, mapConfig);\n    }","id":85563,"modified_method":"public void handleMap(final org.w3c.dom.Node node) throws Exception {\n        final Node attName = node.getAttributes().getNamedItem(\"name\");\n        final String name = getTextContent(attName);\n        final MapConfig mapConfig = new MapConfig();\n        mapConfig.setName(name);\n        for (org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes())) {\n            final String nodeName = cleanNodeName(n.getNodeName());\n            final String value = getTextContent(n).trim();\n            if (\"backup-count\".equals(nodeName)) {\n                mapConfig.setBackupCount(getIntegerValue(\"backup-count\", value, MapConfig.DEFAULT_BACKUP_COUNT));\n            } else if (\"eviction-policy\".equals(nodeName)) {\n                mapConfig.setEvictionPolicy(value);\n            } else if (\"max-size\".equals(nodeName)) {\n                mapConfig.setMaxSize(getIntegerValue(\"max-size\", value,\n                        MapConfig.DEFAULT_MAX_SIZE));\n            } else if (\"eviction-percentage\".equals(nodeName)) {\n                mapConfig.setEvictionPercentage(getIntegerValue(\"eviction-percentage\", value,\n                        MapConfig.DEFAULT_EVICTION_PERCENTAGE));\n            } else if (\"eviction-delay-seconds\".equals(nodeName)) {\n                mapConfig.setEvictionDelaySeconds(getIntegerValue(\"eviction-delay-seconds\", value,\n                        MapConfig.DEFAULT_EVICTION_DELAY_SECONDS));\n            } else if (\"time-to-live-seconds\".equals(nodeName)) {\n                mapConfig.setTimeToLiveSeconds(getIntegerValue(\"time-to-live-seconds\", value,\n                        MapConfig.DEFAULT_TTL_SECONDS));\n            } else if (\"max-idle-seconds\".equals(nodeName)) {\n                mapConfig.setMaxIdleSeconds(getIntegerValue(\"max-idle-seconds\", value,\n                        MapConfig.DEFAULT_MAX_IDLE_SECONDS));\n            } else if (\"map-store\".equals(nodeName)) {\n                MapStoreConfig mapStoreConfig = createMapStoreConfig(n);\n                mapConfig.setMapStoreConfig(mapStoreConfig);\n            } else if (\"near-cache\".equals(nodeName)) {\n                handleViaReflection(n, mapConfig, new NearCacheConfig());\n            } else if (\"merge-policy\".equals(nodeName)) {\n                mapConfig.setMergePolicy(value);\n            }\n        }\n        this.config.getMapConfigs().put(name, mapConfig);\n    }","commit_id":"cd4a6a8539f5afd273e1c2e4f2989b0c1ba420e8","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public DatasetContext(String namespaceId) {\n    this.namespaceId = namespaceId;\n  }","id":85564,"modified_method":"private DatasetContext(String namespaceId) {\n    this.namespaceId = namespaceId;\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized void addInstance(String datasetType, Id.DatasetInstance datasetInstanceId,\n                                       DatasetProperties props) throws InstanceConflictException, IOException {\n    if (instances.get(datasetInstanceId) != null) {\n      throw new InstanceConflictException(\"Dataset instance with name already exists: \" + datasetInstanceId);\n    }\n\n    DatasetDefinitionRegistry registry = getRegistryForType(datasetInstanceId.getNamespace(), datasetType);\n    Preconditions.checkArgument(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n    DatasetDefinition def = registry.get(datasetType);\n    DatasetSpecification spec = def.configure(datasetInstanceId.getId(), props);\n    def.getAdmin(new DatasetContext(datasetInstanceId.getNamespaceId()), null, spec).create();\n    instances.put(datasetInstanceId, spec);\n    LOG.info(\"Created dataset {} of type {}\", datasetInstanceId, datasetType);\n  }","id":85565,"modified_method":"@Override\n  public synchronized void addInstance(String datasetType, Id.DatasetInstance datasetInstanceId,\n                                       DatasetProperties props) throws InstanceConflictException, IOException {\n    if (instances.get(datasetInstanceId) != null) {\n      throw new InstanceConflictException(\"Dataset instance with name already exists: \" + datasetInstanceId);\n    }\n\n    DatasetDefinitionRegistry registry = getRegistryForType(datasetInstanceId.getNamespace(), datasetType);\n    Preconditions.checkArgument(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n    DatasetDefinition def = registry.get(datasetType);\n    DatasetSpecification spec = def.configure(datasetInstanceId.getId(), props);\n    def.getAdmin(new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(),\n                 null, spec).create();\n    instances.put(datasetInstanceId, spec);\n    LOG.info(\"Created dataset {} of type {}\", datasetInstanceId, datasetType);\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized <T extends Dataset> T getDataset(Id.DatasetInstance datasetInstanceId,\n                                                       Map<String, String> arguments,\n                                                       @Nullable ClassLoader classLoader) throws IOException {\n\n    DatasetSpecification spec = instances.get(datasetInstanceId);\n    if (spec == null) {\n      return null;\n    }\n    List<String> availableModuleClasses = getAvailableModuleClasses(datasetInstanceId.getNamespace());\n    DatasetDefinition def = createRegistry(availableModuleClasses, classLoader).get(spec.getType());\n    return (T) (def.getDataset(new DatasetContext(datasetInstanceId.getNamespaceId()), arguments, classLoader, spec));\n  }","id":85566,"modified_method":"@Override\n  public synchronized <T extends Dataset> T getDataset(Id.DatasetInstance datasetInstanceId,\n                                                       Map<String, String> arguments,\n                                                       @Nullable ClassLoader classLoader) throws IOException {\n\n    DatasetSpecification spec = instances.get(datasetInstanceId);\n    if (spec == null) {\n      return null;\n    }\n    List<String> availableModuleClasses = getAvailableModuleClasses(datasetInstanceId.getNamespace());\n    DatasetDefinition def = createRegistry(availableModuleClasses, classLoader).get(spec.getType());\n    return (T) (def.getDataset(new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(),\n                               arguments, classLoader, spec));\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized <T extends DatasetAdmin> T getAdmin(Id.DatasetInstance datasetInstanceId,\n                                                          @Nullable ClassLoader classLoader)\n    throws IOException {\n\n    DatasetSpecification spec = instances.get(datasetInstanceId);\n    if (spec == null) {\n      return null;\n    }\n    List<String> availableModuleClasses = getAvailableModuleClasses(datasetInstanceId.getNamespace());\n    DatasetDefinition impl = createRegistry(availableModuleClasses, classLoader).get(spec.getType());\n    return (T) impl.getAdmin(new DatasetContext(datasetInstanceId.getNamespaceId()), classLoader, spec);\n  }","id":85567,"modified_method":"@Override\n  public synchronized <T extends DatasetAdmin> T getAdmin(Id.DatasetInstance datasetInstanceId,\n                                                          @Nullable ClassLoader classLoader)\n    throws IOException {\n\n    DatasetSpecification spec = instances.get(datasetInstanceId);\n    if (spec == null) {\n      return null;\n    }\n    List<String> availableModuleClasses = getAvailableModuleClasses(datasetInstanceId.getNamespace());\n    DatasetDefinition impl = createRegistry(availableModuleClasses, classLoader).get(spec.getType());\n    return (T) impl.getAdmin(new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(),\n                             classLoader, spec);\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized void updateInstance(Id.DatasetInstance datasetInstanceId, DatasetProperties props)\n    throws InstanceConflictException, IOException {\n    DatasetSpecification oldSpec = instances.get(datasetInstanceId);\n    if (oldSpec == null) {\n      throw new InstanceConflictException(\"Dataset instance with name does not exist: \" + datasetInstanceId);\n    }\n    String datasetType = oldSpec.getType();\n    DatasetDefinitionRegistry registry = getRegistryForType(datasetInstanceId.getNamespace(), datasetType);\n    Preconditions.checkArgument(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n    DatasetDefinition def = registry.get(datasetType);\n    DatasetSpecification spec = def.configure(datasetInstanceId.getId(), props);\n    instances.put(datasetInstanceId, spec);\n    def.getAdmin(new DatasetContext(datasetInstanceId.getNamespaceId()), null, spec).upgrade();\n  }","id":85568,"modified_method":"@Override\n  public synchronized void updateInstance(Id.DatasetInstance datasetInstanceId, DatasetProperties props)\n    throws InstanceConflictException, IOException {\n    DatasetSpecification oldSpec = instances.get(datasetInstanceId);\n    if (oldSpec == null) {\n      throw new InstanceConflictException(\"Dataset instance with name does not exist: \" + datasetInstanceId);\n    }\n    String datasetType = oldSpec.getType();\n    DatasetDefinitionRegistry registry = getRegistryForType(datasetInstanceId.getNamespace(), datasetType);\n    Preconditions.checkArgument(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n    DatasetDefinition def = registry.get(datasetType);\n    DatasetSpecification spec = def.configure(datasetInstanceId.getId(), props);\n    instances.put(datasetInstanceId, spec);\n    def.getAdmin(new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(),\n                 null, spec).upgrade();\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized void deleteAllInstances(Id.Namespace namespaceId) throws DatasetManagementException, IOException {\n    for (DatasetSpecification spec : instances.values()) {\n      String datasetType = spec.getType();\n      DatasetDefinitionRegistry registry = getRegistryForType(namespaceId, datasetType);\n      Preconditions.checkState(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n      DatasetDefinition def = registry.get(spec.getType());\n      def.getAdmin(new DatasetContext(namespaceId.getId()), null, spec).drop();\n    }\n    instances.clear();\n  }","id":85569,"modified_method":"@Override\n  public synchronized void deleteAllInstances(Id.Namespace namespaceId) throws DatasetManagementException, IOException {\n    for (DatasetSpecification spec : instances.values()) {\n      String datasetType = spec.getType();\n      DatasetDefinitionRegistry registry = getRegistryForType(namespaceId, datasetType);\n      Preconditions.checkState(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n      DatasetDefinition def = registry.get(spec.getType());\n      def.getAdmin(new DatasetContext.Builder().setNamespaceId(namespaceId.getId()).build(), null, spec).drop();\n    }\n    instances.clear();\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized void deleteInstance(Id.DatasetInstance datasetInstanceId)\n    throws InstanceConflictException, IOException {\n    DatasetSpecification spec = instances.remove(datasetInstanceId);\n    String datasetType = spec.getType();\n    DatasetDefinitionRegistry registry = getRegistryForType(datasetInstanceId.getNamespace(), datasetType);\n    Preconditions.checkState(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n    DatasetDefinition def = registry.get(spec.getType());\n    def.getAdmin(new DatasetContext(datasetInstanceId.getNamespaceId()), null, spec).drop();\n  }","id":85570,"modified_method":"@Override\n  public synchronized void deleteInstance(Id.DatasetInstance datasetInstanceId)\n    throws InstanceConflictException, IOException {\n    DatasetSpecification spec = instances.remove(datasetInstanceId);\n    String datasetType = spec.getType();\n    DatasetDefinitionRegistry registry = getRegistryForType(datasetInstanceId.getNamespace(), datasetType);\n    Preconditions.checkState(registry != null, \"Dataset type '%s' is not registered\", datasetType);\n    DatasetDefinition def = registry.get(spec.getType());\n    def.getAdmin(new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(),\n                 null, spec).drop();\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void drop(Id.DatasetInstance datasetInstanceId, DatasetTypeMeta typeMeta,\n                   DatasetSpecification spec) throws Exception {\n    DatasetType type = client.getDatasetType(typeMeta, null);\n\n    if (type == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    DatasetAdmin admin = type.getAdmin(new DatasetContext(datasetInstanceId.getNamespaceId()), spec);\n    admin.drop();\n  }","id":85571,"modified_method":"@Override\n  public void drop(Id.DatasetInstance datasetInstanceId, DatasetTypeMeta typeMeta,\n                   DatasetSpecification spec) throws Exception {\n    DatasetType type = client.getDatasetType(typeMeta, null);\n\n    if (type == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    DatasetAdmin admin = type.getAdmin(\n      new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(), spec);\n    admin.drop();\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public DatasetSpecification create(Id.DatasetInstance datasetInstanceId, DatasetTypeMeta typeMeta,\n                                     DatasetProperties props)\n    throws Exception {\n\n    DatasetType type = client.getDatasetType(typeMeta, null);\n\n    if (type == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    // TODO: Note - for now, just sending the name. However, type likely needs to be namesapce-aware too.\n    DatasetSpecification spec = type.configure(datasetInstanceId.getId(), props);\n    DatasetAdmin admin = type.getAdmin(new DatasetContext(datasetInstanceId.getNamespaceId()), spec);\n    admin.create();\n\n    return spec;\n  }","id":85572,"modified_method":"@Override\n  public DatasetSpecification create(Id.DatasetInstance datasetInstanceId, DatasetTypeMeta typeMeta,\n                                     DatasetProperties props)\n    throws Exception {\n\n    DatasetType type = client.getDatasetType(typeMeta, null);\n\n    if (type == null) {\n      throw new IllegalArgumentException(\"Dataset type cannot be instantiated for provided type meta: \" + typeMeta);\n    }\n\n    // TODO: Note - for now, just sending the name. However, type likely needs to be namesapce-aware too.\n    DatasetSpecification spec = type.configure(datasetInstanceId.getId(), props);\n    DatasetAdmin admin = type.getAdmin(\n      new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(), spec);\n    admin.create();\n\n    return spec;\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetVersion() throws Exception {\n    // Verify new metric datasets are properly recognized as 2.8+ version from now on\n    HBaseMetricsTableDefinition definition =\n      new HBaseMetricsTableDefinition(\"foo\", testHBase.getConfiguration(), hBaseTableUtil,\n                                      new LocalLocationFactory(tmpFolder.newFolder()), CConfiguration.create());\n    DatasetSpecification spec = definition.configure(\"metricV2.8\", DatasetProperties.EMPTY);\n\n    DatasetAdmin admin = definition.getAdmin(new DatasetContext(Constants.SYSTEM_NAMESPACE), null, spec);\n    admin.create();\n\n    MetricHBaseTableUtil util = new MetricHBaseTableUtil(hBaseTableUtil);\n    HBaseAdmin hAdmin = testHBase.getHBaseAdmin();\n    HTableDescriptor desc = hAdmin.getTableDescriptor(Bytes.toBytes(spec.getName()));\n    Assert.assertEquals(MetricHBaseTableUtil.Version.VERSION_2_8_OR_HIGHER, util.getVersion(desc));\n\n    // Verify HBase table without coprocessor is properly recognized as 2.6- version\n    TableName table26 = TableName.valueOf(\"metricV2.6\");\n    hAdmin.createTable(new HTableDescriptor(table26));\n    desc = hAdmin.getTableDescriptor(table26);\n    Assert.assertEquals(MetricHBaseTableUtil.Version.VERSION_2_6_OR_LOWER, util.getVersion(desc));\n\n    // Verify HBase table with IncrementHandler coprocessor but without cdap.version on it is properly recognized as\n    // 2.7 version\n    TableName table27 = TableName.valueOf(\"metricV2.7\");\n    desc = new HTableDescriptor(table27);\n    desc.addCoprocessor(hBaseTableUtil.getIncrementHandlerClassForVersion().getName());\n    hAdmin.createTable(desc);\n    desc = hAdmin.getTableDescriptor(table27);\n    Assert.assertEquals(MetricHBaseTableUtil.Version.VERSION_2_7, util.getVersion(desc));\n  }","id":85573,"modified_method":"@Test\n  public void testGetVersion() throws Exception {\n    // Verify new metric datasets are properly recognized as 2.8+ version from now on\n    HBaseMetricsTableDefinition definition =\n      new HBaseMetricsTableDefinition(\"foo\", testHBase.getConfiguration(), hBaseTableUtil,\n                                      new LocalLocationFactory(tmpFolder.newFolder()), CConfiguration.create());\n    DatasetSpecification spec = definition.configure(\"metricV2.8\", DatasetProperties.EMPTY);\n\n    DatasetAdmin admin = definition.getAdmin(\n      new DatasetContext.Builder().setNamespaceId(Constants.SYSTEM_NAMESPACE).build(), null, spec);\n    admin.create();\n\n    MetricHBaseTableUtil util = new MetricHBaseTableUtil(hBaseTableUtil);\n    HBaseAdmin hAdmin = testHBase.getHBaseAdmin();\n    HTableDescriptor desc = hAdmin.getTableDescriptor(Bytes.toBytes(spec.getName()));\n    Assert.assertEquals(MetricHBaseTableUtil.Version.VERSION_2_8_OR_HIGHER, util.getVersion(desc));\n\n    // Verify HBase table without coprocessor is properly recognized as 2.6- version\n    TableName table26 = TableName.valueOf(\"metricV2.6\");\n    hAdmin.createTable(new HTableDescriptor(table26));\n    desc = hAdmin.getTableDescriptor(table26);\n    Assert.assertEquals(MetricHBaseTableUtil.Version.VERSION_2_6_OR_LOWER, util.getVersion(desc));\n\n    // Verify HBase table with IncrementHandler coprocessor but without cdap.version on it is properly recognized as\n    // 2.7 version\n    TableName table27 = TableName.valueOf(\"metricV2.7\");\n    desc = new HTableDescriptor(table27);\n    desc.addCoprocessor(hBaseTableUtil.getIncrementHandlerClassForVersion().getName());\n    hAdmin.createTable(desc);\n    desc = hAdmin.getTableDescriptor(table27);\n    Assert.assertEquals(MetricHBaseTableUtil.Version.VERSION_2_7, util.getVersion(desc));\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws IOException {\n    DatasetDefinition<? extends NoTxKeyValueTable, ? extends DatasetAdmin> def = getDefinition();\n    DatasetSpecification spec = def.configure(\"table\", DatasetProperties.EMPTY);\n\n    ClassLoader cl = NoTxKeyValueTable.class.getClassLoader();\n    DatasetContext datasetContext = new DatasetContext(namespaceId);\n    // create & exists\n    DatasetAdmin admin = def.getAdmin(datasetContext, cl, spec);\n    Assert.assertFalse(admin.exists());\n    admin.create();\n    Assert.assertTrue(admin.exists());\n\n    // put/get\n    NoTxKeyValueTable table = def.getDataset(datasetContext, NO_ARGS, cl, spec);\n    Assert.assertNull(table.get(KEY1));\n    table.put(KEY1, VALUE1);\n    Assert.assertArrayEquals(VALUE1, table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    // override\n    table.put(KEY1, VALUE2);\n    Assert.assertArrayEquals(VALUE2, table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    // delete & truncate\n    table.put(KEY2, VALUE1);\n    Assert.assertArrayEquals(VALUE2, table.get(KEY1));\n    Assert.assertArrayEquals(VALUE1, table.get(KEY2));\n    table.put(KEY2, null);\n    Assert.assertNull(table.get(KEY2));\n    Assert.assertArrayEquals(VALUE2, table.get(KEY1));\n\n    admin.truncate();\n    Assert.assertNull(table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    Assert.assertTrue(admin.exists());\n    admin.drop();\n    Assert.assertFalse(admin.exists());\n\n    // drop should cleanup data\n    admin.create();\n    Assert.assertTrue(admin.exists());\n    Assert.assertNull(table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    table.put(KEY1, VALUE1);\n    Assert.assertArrayEquals(VALUE1, table.get(KEY1));\n\n    admin.drop();\n    Assert.assertFalse(admin.exists());\n    admin.create();\n    Assert.assertTrue(admin.exists());\n    Assert.assertNull(table.get(KEY1));\n  }","id":85574,"modified_method":"@Test\n  public void test() throws IOException {\n    DatasetDefinition<? extends NoTxKeyValueTable, ? extends DatasetAdmin> def = getDefinition();\n    DatasetSpecification spec = def.configure(\"table\", DatasetProperties.EMPTY);\n\n    ClassLoader cl = NoTxKeyValueTable.class.getClassLoader();\n    DatasetContext datasetContext = new DatasetContext.Builder().setNamespaceId(namespaceId).build();\n    // create & exists\n    DatasetAdmin admin = def.getAdmin(datasetContext, cl, spec);\n    Assert.assertFalse(admin.exists());\n    admin.create();\n    Assert.assertTrue(admin.exists());\n\n    // put/get\n    NoTxKeyValueTable table = def.getDataset(datasetContext, NO_ARGS, cl, spec);\n    Assert.assertNull(table.get(KEY1));\n    table.put(KEY1, VALUE1);\n    Assert.assertArrayEquals(VALUE1, table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    // override\n    table.put(KEY1, VALUE2);\n    Assert.assertArrayEquals(VALUE2, table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    // delete & truncate\n    table.put(KEY2, VALUE1);\n    Assert.assertArrayEquals(VALUE2, table.get(KEY1));\n    Assert.assertArrayEquals(VALUE1, table.get(KEY2));\n    table.put(KEY2, null);\n    Assert.assertNull(table.get(KEY2));\n    Assert.assertArrayEquals(VALUE2, table.get(KEY1));\n\n    admin.truncate();\n    Assert.assertNull(table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    Assert.assertTrue(admin.exists());\n    admin.drop();\n    Assert.assertFalse(admin.exists());\n\n    // drop should cleanup data\n    admin.create();\n    Assert.assertTrue(admin.exists());\n    Assert.assertNull(table.get(KEY1));\n    Assert.assertNull(table.get(KEY2));\n\n    table.put(KEY1, VALUE1);\n    Assert.assertArrayEquals(VALUE1, table.get(KEY1));\n\n    admin.drop();\n    Assert.assertFalse(admin.exists());\n    admin.create();\n    Assert.assertTrue(admin.exists());\n    Assert.assertNull(table.get(KEY1));\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public <T extends Dataset> T getDataset(Id.DatasetInstance datasetInstanceId, Map<String, String> arguments,\n                                          ClassLoader classLoader) throws DatasetManagementException, IOException {\n    DatasetMeta instanceInfo = clientCache.getUnchecked(datasetInstanceId.getNamespace())\n      .getInstance(datasetInstanceId.getId());\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    DatasetType type = getDatasetType(instanceInfo.getType(), classLoader);\n    return (T) type.getDataset(new DatasetContext(datasetInstanceId.getNamespaceId()), instanceInfo.getSpec(),\n                               arguments);\n  }","id":85575,"modified_method":"@Override\n  public <T extends Dataset> T getDataset(Id.DatasetInstance datasetInstanceId, Map<String, String> arguments,\n                                          ClassLoader classLoader) throws DatasetManagementException, IOException {\n    DatasetMeta instanceInfo = clientCache.getUnchecked(datasetInstanceId.getNamespace())\n      .getInstance(datasetInstanceId.getId());\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    DatasetType type = getDatasetType(instanceInfo.getType(), classLoader);\n    return (T) type.getDataset(new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(),\n                               instanceInfo.getSpec(), arguments);\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public <T extends DatasetAdmin> T getAdmin(Id.DatasetInstance datasetInstanceId, ClassLoader classLoader)\n    throws DatasetManagementException, IOException {\n    DatasetMeta instanceInfo = clientCache.getUnchecked(datasetInstanceId.getNamespace())\n      .getInstance(datasetInstanceId.getId());\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    DatasetType type = getDatasetType(instanceInfo.getType(), classLoader);\n    return (T) type.getAdmin(new DatasetContext(datasetInstanceId.getNamespaceId()), instanceInfo.getSpec());\n  }","id":85576,"modified_method":"@Override\n  public <T extends DatasetAdmin> T getAdmin(Id.DatasetInstance datasetInstanceId, ClassLoader classLoader)\n    throws DatasetManagementException, IOException {\n    DatasetMeta instanceInfo = clientCache.getUnchecked(datasetInstanceId.getNamespace())\n      .getInstance(datasetInstanceId.getId());\n    if (instanceInfo == null) {\n      return null;\n    }\n\n    DatasetType type = getDatasetType(instanceInfo.getType(), classLoader);\n    return (T) type.getAdmin(new DatasetContext.Builder().setNamespaceId(datasetInstanceId.getNamespaceId()).build(),\n                             instanceInfo.getSpec());\n  }","commit_id":"5989fbb88caafd3a48308ccc1daa3abbbae94202","url":"https://github.com/caskdata/cdap"},{"original_method":"/** Confusion matrix\n   * @param model the ensemble used to classify\n   */\n  private CMTask(SpeeDRFModel model, int treesToUse, boolean computeOOB, float[] priorDist, float[] modelDist, Frame fr, Vec resp) {\n    _modelKey   = model._key;\n    _datakey    = model._dataKey;\n    _classcol   = fr.numCols() - 1; //model.test_frame == null ?  (model.fr.numCols() - 1) : (model.test_frame.numCols() - 1);\n    _treesUsed  = treesToUse;\n    _computeOOB = computeOOB;\n    _model = model;\n    _varimp = null;\n    _ss = 0.f;\n    _data = fr;\n    _priorDist = priorDist;\n    _modelDist = modelDist;\n    shared_init(resp);\n  }","id":85577,"modified_method":"/** Confusion matrix\n   * @param model the ensemble used to classify\n   */\n  private CMTask(SpeeDRFModel model, int treesToUse, boolean computeOOB, Frame fr, Vec resp) {\n    _modelKey   = model._key;\n    _datakey    = model._dataKey;\n    _classcol   = fr.numCols() - 1; //model.test_frame == null ?  (model.fr.numCols() - 1) : (model.test_frame.numCols() - 1);\n    _treesUsed  = treesToUse;\n    _computeOOB = computeOOB;\n    _model = model;\n    _varimp = null;\n    _ss = 0.f;\n    _data = fr;\n    shared_init(resp);\n  }","commit_id":"2511b659da1de6e61819874c6bd19eb2ea7df15d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public static CMTask scoreTask(SpeeDRFModel model, int treesToUse, boolean computeOOB, float[] priorDist, float[] modelDist, Frame fr, Vec resp) {\n    CMTask tsk = new CMTask(model, treesToUse, computeOOB, priorDist, modelDist, fr, resp);\n    tsk.doAll(fr);\n    return tsk;\n  }","id":85578,"modified_method":"public static CMTask scoreTask(SpeeDRFModel model, int treesToUse, boolean computeOOB, Frame fr, Vec resp) {\n    CMTask tsk = new CMTask(model, treesToUse, computeOOB, fr, resp);\n    tsk.doAll(fr);\n    return tsk;\n  }","commit_id":"2511b659da1de6e61819874c6bd19eb2ea7df15d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private static double[] stats(JsonElement json) {\n    if( json == null ) {\n      return null;\n    } else {\n      JsonObject obj = json.getAsJsonObject();\n      return new double[]{\n              obj.get(Constants.MIN).getAsDouble(),\n              obj.get(Constants.MEAN).getAsDouble(),\n              obj.get(Constants.MAX).getAsDouble()};\n    }\n  }","id":85579,"modified_method":"private static double[] stats(JsonElement json) {\n    if( json == null ) {\n      return null;\n    } else {\n      JsonObject obj = json.getAsJsonObject();\n      return new double[]{\n              Math.round(obj.get(Constants.MIN).getAsDouble() * 1000.0) / 1000.0,\n              Math.round(obj.get(Constants.MEAN).getAsDouble() * 1000.0) / 1000.0,\n              Math.round(obj.get(Constants.MAX).getAsDouble() * 1000.0) / 1000.0};\n    }\n  }","commit_id":"2511b659da1de6e61819874c6bd19eb2ea7df15d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void generateHTMLTreeStats(StringBuilder sb, JsonObject trees) {\n    DocGen.HTML.section(sb,\"Tree stats\");\n    DocGen.HTML.arrayHead(sb);\n    sb.append(\"<tr><th>&nbsp;<\/th>\").append(\"<th>Min<\/th><th>Mean<\/th><th>Max<\/th><\/tr>\");\n\n    TreeStats treeStats = new TreeStats();\n    double[] depth_stats = stats(trees.get(Constants.TREE_DEPTH));\n    double[] leaf_stats = stats(trees.get(Constants.TREE_LEAVES));\n\n    sb.append(\"<tr><th>Depth<\/th>\")\n            .append(\"<td>\").append(depth_stats != null ? depth_stats[0]  : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(depth_stats != null ? depth_stats[1] : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(depth_stats != null ? depth_stats[2] : NA).append(\"<\/td><\/tr>\");\n    sb.append(\"<th>Leaves<\/th>\")\n            .append(\"<td>\").append(leaf_stats != null ? leaf_stats[0]  : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(leaf_stats != null ? leaf_stats[1] : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(leaf_stats != null ? leaf_stats[2]  : NA).append(\"<\/td><\/tr>\");\n    DocGen.HTML.arrayTail(sb);\n\n    if(depth_stats != null && leaf_stats != null) {\n      treeStats.minDepth = (int)depth_stats[0];\n      treeStats.meanDepth = (float)depth_stats[1];\n      treeStats.maxDepth = (int)depth_stats[2];\n      treeStats.minLeaves = (int)leaf_stats[0];\n      treeStats.meanLeaves = (float)leaf_stats[1];\n      treeStats.maxLeaves = (int)leaf_stats[2];\n    } else {\n      treeStats = null;\n    }\n    this.treeStats = treeStats;\n  }","id":85580,"modified_method":"public void generateHTMLTreeStats(StringBuilder sb, JsonObject trees) {\n    DocGen.HTML.section(sb,\"Tree stats\");\n    DocGen.HTML.arrayHead(sb);\n    sb.append(\"<tr><th>&nbsp;<\/th>\").append(\"<th>Min<\/th><th>Mean<\/th><th>Max<\/th><\/tr>\");\n\n    TreeStats treeStats = new TreeStats();\n    double[] depth_stats = stats(trees.get(Constants.TREE_DEPTH));\n    double[] leaf_stats = stats(trees.get(Constants.TREE_LEAVES));\n\n    sb.append(\"<tr><th>Depth<\/th>\")\n            .append(\"<td>\").append(depth_stats != null ? (int)depth_stats[0]  : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(depth_stats != null ? depth_stats[1] : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(depth_stats != null ? (int)depth_stats[2] : NA).append(\"<\/td><\/tr>\");\n    sb.append(\"<th>Leaves<\/th>\")\n            .append(\"<td>\").append(leaf_stats != null ? (int)leaf_stats[0]  : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(leaf_stats != null ? leaf_stats[1] : NA).append(\"<\/td>\")\n            .append(\"<td>\").append(leaf_stats != null ? (int)leaf_stats[2]  : NA).append(\"<\/td><\/tr>\");\n    DocGen.HTML.arrayTail(sb);\n\n    if(depth_stats != null && leaf_stats != null) {\n      treeStats.minDepth = (int)depth_stats[0];\n      treeStats.meanDepth = (float)depth_stats[1];\n      treeStats.maxDepth = (int)depth_stats[2];\n      treeStats.minLeaves = (int)leaf_stats[0];\n      treeStats.meanLeaves = (float)leaf_stats[1];\n      treeStats.maxLeaves = (int)leaf_stats[2];\n    } else {\n      treeStats = null;\n    }\n    this.treeStats = treeStats;\n  }","commit_id":"2511b659da1de6e61819874c6bd19eb2ea7df15d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/** Internal computation of depth and number of leaves. */\n  public void find_leaves_depth() {\n    if( _tl != null ) return;\n    _td = new Counter();\n    _tl = new Counter();\n    for( Key tkey : t_keys ) {\n      long dl = Tree.depth_leaves(new AutoBuffer(DKV.get(tkey).memOrLoad()), regression);\n      _td.add((int) (dl >> 32));\n      _tl.add((int) dl);\n    }\n  }","id":85581,"modified_method":"/** Internal computation of depth and number of leaves. */\n  public void find_leaves_depth() {\n//    if( _tl != null ) return;\n    _td = new Counter();\n    _tl = new Counter();\n    for( Key tkey : t_keys ) {\n      long dl = Tree.depth_leaves(new AutoBuffer(DKV.get(tkey).memOrLoad()), regression);\n      _td.add((int) (dl >> 32));\n      _tl.add((int) dl);\n    }\n  }","commit_id":"2511b659da1de6e61819874c6bd19eb2ea7df15d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void scoreOnTrain(Frame fr, Vec modelResp) {\n    final CMTask cmTask = CMTask.scoreTask(this, treeCount(), oobee, priordist(), modeldist(), fr, modelResp);\n    if (regression) {\n      float mse = cmTask._ss / ( (float) (cmTask._rowcnt));\n      errs = Arrays.copyOf(errs, errs.length + 1);\n      errs[errs.length - 1] = mse;\n      cms = Arrays.copyOf(cms, cms.length + 1);\n      cms[cms.length - 1] = null;\n    } else {\n      _domain = cmTask.domain(modelResp);\n      confusion = CMTask.CMFinal.make(cmTask._matrix, this, _domain, cmTask._errorsPerTree, oobee, cmTask._sum, cmTask._cms);\n      this.cm = cmTask._matrix._matrix;\n      errorsPerTree = cmTask._errorsPerTree;\n      errs = Arrays.copyOf(errs, errs.length + 1);\n      errs[errs.length - 1] = confusion.mse();\n      cms = Arrays.copyOf(cms, cms.length + 1);\n      cms[cms.length - 1] = new ConfusionMatrix(confusion._matrix);\n\n      if (classes() == 2) validAUC =  makeAUC(toCMArray(confusion._cms), ModelUtils.DEFAULT_THRESHOLDS, cmDomain);\n      if (importance && !regression) varimp = doVarImpCalc(fr, this, modelResp);\n    }\n  }","id":85582,"modified_method":"private void scoreOnTrain(Frame fr, Vec modelResp) {\n    final CMTask cmTask = CMTask.scoreTask(this, treeCount(), oobee, fr, modelResp);\n    if (regression) {\n      float mse = cmTask._ss / ( (float) (cmTask._rowcnt));\n      errs = Arrays.copyOf(errs, errs.length + 1);\n      errs[errs.length - 1] = mse;\n      cms = Arrays.copyOf(cms, cms.length + 1);\n      cms[cms.length - 1] = null;\n    } else {\n      _domain = cmTask.domain(modelResp);\n      confusion = CMTask.CMFinal.make(cmTask._matrix, this, _domain, cmTask._errorsPerTree, oobee, cmTask._sum, cmTask._cms);\n      this.cm = cmTask._matrix._matrix;\n      errorsPerTree = cmTask._errorsPerTree;\n      errs = Arrays.copyOf(errs, errs.length + 1);\n      errs[errs.length - 1] = confusion.mse();\n      cms = Arrays.copyOf(cms, cms.length + 1);\n      cms[cms.length - 1] = new ConfusionMatrix(confusion._matrix);\n\n      if (classes() == 2) validAUC =  makeAUC(toCMArray(confusion._cms), ModelUtils.DEFAULT_THRESHOLDS, cmDomain);\n      if (importance && !regression) varimp = doVarImpCalc(fr, this, modelResp);\n    }\n  }","commit_id":"2511b659da1de6e61819874c6bd19eb2ea7df15d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n   protected void initialize(RProjectOptions options)\n   {\n      Label label = new Label(\n            \"Packrat is a dependency management tool that makes your \" +\n            \"R code more isolated, portable, and reproducible by \" +\n            \"giving your project its own privately managed package \" +\n            \"library.\"\n        );\n        spaced(label);\n        add(label);\n        \n        PackratContext context = options.getPackratContext();\n        RProjectPackratOptions packratOptions = options.getPackratOptions();\n        \n        // create the check boxes (we'll add them later if appropriate)    \n        chkAutoSnapshot_ = new CheckBox(\"Automatically snapshot local changes\");\n        chkAutoSnapshot_.setValue(packratOptions.getAutoSnapshot());\n        \n        String vcsName = session_.getSessionInfo().getVcsName();\n        chkVcsIgnoreLib_ = new CheckBox(vcsName + \" ignore packrat library\"); \n        chkVcsIgnoreLib_.setValue(packratOptions.getVcsIgnoreLib());\n        \n        chkVcsIgnoreSrc_ = new CheckBox(vcsName + \" ignore packrat sources\");\n        chkVcsIgnoreSrc_.setValue(packratOptions.getVcsIgnoreSrc());\n        \n        manageCheckBoxes();\n        \n        if (!context.isPackified())\n        {\n           ThemedButton button = new ThemedButton(\n              \"Use Packrat with this Project...\",\n              new ClickHandler() {\n   \n                 @Override\n                 public void onClick(ClickEvent event)\n                 {\n                    bootstrapPackrat();\n                 }\n                 \n              });\n           spaced(button);\n           button.getElement().getStyle().setMarginTop(10, Unit.PX);\n           add(button);\n        }\n        else\n        {\n           spaced(chkAutoSnapshot_);\n           add(chkAutoSnapshot_);\n           \n           spaced(chkVcsIgnoreLib_);\n           add(chkVcsIgnoreLib_);\n           \n           spaced(chkVcsIgnoreSrc_);\n           add(chkVcsIgnoreSrc_);\n        }\n        \n\n        HelpLink helpLink = new HelpLink(\"Learn more about Packrat\", \"packrat\");\n        helpLink.getElement().getStyle().setMarginTop(15, Unit.PX);\n        nudgeRight(helpLink);\n        add(helpLink);\n   }","id":85583,"modified_method":"@Override\n   protected void initialize(RProjectOptions options)\n   {\n      Label label = new Label(\n            \"Packrat is a dependency management tool that makes your \" +\n            \"R code more isolated, portable, and reproducible by \" +\n            \"giving your project its own privately managed package \" +\n            \"library.\"\n        );\n        spaced(label);\n        add(label);\n        \n        PackratContext context = options.getPackratContext();\n        RProjectPackratOptions packratOptions = options.getPackratOptions();\n               \n        usePackratButton_ = new ThemedButton(\n           \"Use Packrat with this Project...\",\n           new ClickHandler() {\n\n              @Override\n              public void onClick(ClickEvent event)\n              {\n                 bootstrapPackrat();\n              }\n              \n           });\n        spaced(usePackratButton_);\n        usePackratButton_.getElement().getStyle().setMarginTop(10, Unit.PX);\n        add(usePackratButton_);\n   \n        chkUsePackrat_ = new CheckBox(\"Use packrat with this project\");\n        chkUsePackrat_.setValue(true);\n        chkUsePackrat_.addValueChangeHandler(\n                                new ValueChangeHandler<Boolean>() {\n\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            confirmRemovePackrat();\n         }\n        });\n       \n        spaced(chkUsePackrat_);\n        add(chkUsePackrat_);\n        \n        chkAutoSnapshot_ = new CheckBox(\"Automatically snapshot local changes\");\n        chkAutoSnapshot_.setValue(packratOptions.getAutoSnapshot());\n        spaced(chkAutoSnapshot_);\n        add(chkAutoSnapshot_);\n        \n        String vcsName = session_.getSessionInfo().getVcsName();\n        chkVcsIgnoreLib_ = new CheckBox(vcsName + \" ignore packrat library\"); \n        chkVcsIgnoreLib_.setValue(packratOptions.getVcsIgnoreLib());\n        spaced(chkVcsIgnoreLib_);\n        add(chkVcsIgnoreLib_);\n        \n        chkVcsIgnoreSrc_ = new CheckBox(vcsName + \" ignore packrat sources\");\n        chkVcsIgnoreSrc_.setValue(packratOptions.getVcsIgnoreSrc());\n        spaced(chkVcsIgnoreSrc_);\n        add(chkVcsIgnoreSrc_);\n        \n        manageUI(context.isPackified());\n\n        HelpLink helpLink = new HelpLink(\"Learn more about Packrat\", \"packrat\");\n        helpLink.getElement().getStyle().setMarginTop(15, Unit.PX);\n        nudgeRight(helpLink);\n        add(helpLink);\n   }","commit_id":"edb365a0682b49485e6439a0faa16e2e031bb4f6","url":"https://github.com/rstudio/rstudio"},{"original_method":"private static void addChainedCallVariants(final PsiElement place, final LookupElement qualifierItem,\n                                             final CompletionResultSet result,\n                                             PsiType qualifierType,\n                                             final PsiType expectedType) throws IncorrectOperationException {\n    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(place.getProject()).getElementFactory();\n    final JavaCodeFragment block = elementFactory.createCodeBlockCodeFragment(qualifierType.getCanonicalText() + \" xxx;xxx.xxx;\", place, false);\n    final PsiExpressionStatement expressionStatement = (PsiExpressionStatement)block.getChildren()[1];\n    final PsiReferenceExpression mockRef = (PsiReferenceExpression) expressionStatement.getExpression();\n\n    final ElementFilter filter = getReferenceFilter(place, true, true);\n    for (final LookupElement item : JavaSmartCompletionContributor.completeReference(place, mockRef, filter, false)) {\n      if (shoudChain(place, qualifierType, expectedType, item)) {\n        result.addElement(new JavaChainLookupElement(qualifierItem, item));\n      }\n    }\n  }","id":85584,"modified_method":"private static void addChainedCallVariants(final PsiElement place, final LookupElement qualifierItem,\n                                             final CompletionResultSet result,\n                                             PsiType qualifierType,\n                                             final PsiType expectedType) throws IncorrectOperationException {\n    final PsiElementFactory elementFactory = JavaPsiFacade.getInstance(place.getProject()).getElementFactory();\n    final String typeText = qualifierType instanceof PsiEllipsisType ? ((PsiEllipsisType)qualifierType).getComponentType().getCanonicalText() + \"[]\" : qualifierType.getCanonicalText();\n    final JavaCodeFragment block = elementFactory.createCodeBlockCodeFragment(typeText + \" xxx;xxx.xxx;\", place, false);\n    final PsiElement secondChild = block.getChildren()[1];\n    if (!(secondChild instanceof PsiExpressionStatement)) {\n      LOG.error(typeText);;\n    }\n    final PsiExpressionStatement expressionStatement = (PsiExpressionStatement)secondChild;\n    final PsiReferenceExpression mockRef = (PsiReferenceExpression) expressionStatement.getExpression();\n\n    final ElementFilter filter = getReferenceFilter(place, true, true);\n    for (final LookupElement item : JavaSmartCompletionContributor.completeReference(place, mockRef, filter, false)) {\n      if (shoudChain(place, qualifierType, expectedType, item)) {\n        result.addElement(new JavaChainLookupElement(qualifierItem, item));\n      }\n    }\n  }","commit_id":"ff17be8dd9e975dfd65c4774d9876cafc28d1ba6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void handleElementRename(String newName, PsiReference ref, String fieldName) {\n    final String refText = ref.getCanonicalText();\n    String toRename;\n    if (fieldName.equals(refText)) {\n      toRename = newName;\n    }\n    else if (GroovyPropertyUtils.getGetterNameNonBoolean(fieldName).equals(refText)) {\n      toRename = GroovyPropertyUtils.getGetterNameNonBoolean(newName);\n    }\n    else if (GroovyPropertyUtils.getGetterNameBoolean(fieldName).equals(refText)) {\n      toRename = GroovyPropertyUtils.getGetterNameBoolean(newName);\n    }\n    else if (GroovyPropertyUtils.getSetterName(fieldName).equals(refText)) {\n      toRename = GroovyPropertyUtils.getSetterName(newName);\n    }\n    else {\n      toRename = newName;\n    }\n    ref.handleElementRename(toRename);\n  }","id":85585,"modified_method":"private static void handleElementRename(String newName, PsiReference ref, String fieldName) {\n    final String refText;\n\n    if (ref instanceof PsiQualifiedReference) {\n      refText = ((PsiQualifiedReference)ref).getReferenceName();\n    }\n    else {\n      refText = ref.getCanonicalText();\n    }\n\n    String toRename;\n    if (fieldName.equals(refText)) {\n      toRename = newName;\n    }\n    else if (GroovyPropertyUtils.getGetterNameNonBoolean(fieldName).equals(refText)) {\n      toRename = GroovyPropertyUtils.getGetterNameNonBoolean(newName);\n    }\n    else if (GroovyPropertyUtils.getGetterNameBoolean(fieldName).equals(refText)) {\n      toRename = GroovyPropertyUtils.getGetterNameBoolean(newName);\n    }\n    else if (GroovyPropertyUtils.getSetterName(fieldName).equals(refText)) {\n      toRename = GroovyPropertyUtils.getSetterName(newName);\n    }\n    else {\n      toRename = newName;\n    }\n    ref.handleElementRename(toRename);\n  }","commit_id":"659254634a2c1c88dbc67ca0ed2d0c911d152cfe","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void modifyCalls(PsiReference reference,\n                                   String arrayTypeText,\n                                   int indexOfFirstVarargArgument)\n      throws IncorrectOperationException {\n      final PsiReferenceExpression referenceExpression =\n        (PsiReferenceExpression)reference.getElement();\n      final PsiMethodCallExpression methodCallExpression =\n        (PsiMethodCallExpression)referenceExpression.getParent();\n      final PsiExpressionList argumentList =\n        methodCallExpression.getArgumentList();\n      final PsiExpression[] arguments = argumentList.getExpressions();\n      @NonNls final StringBuilder builder = new StringBuilder(\"new \");\n      builder.append(arrayTypeText);\n      builder.append(\"[]{\");\n      if (arguments.length > indexOfFirstVarargArgument) {\n        final PsiExpression firstArgument =\n          arguments[indexOfFirstVarargArgument];\n        final String firstArgumentText = firstArgument.getText();\n        builder.append(firstArgumentText);\n        for (int i = indexOfFirstVarargArgument + 1;\n             i < arguments.length; i++) {\n          builder.append(',');\n          builder.append(arguments[i].getText());\n        }\n      }\n      builder.append('}');\n      final Project project = referenceExpression.getProject();\n      final PsiElementFactory factory =\n        JavaPsiFacade.getElementFactory(project);\n      final PsiExpression arrayExpression =\n        factory.createExpressionFromText(builder.toString(),\n                                         referenceExpression);\n      if (arguments.length > indexOfFirstVarargArgument) {\n        final PsiExpression firstArgument =\n          arguments[indexOfFirstVarargArgument];\n        argumentList.deleteChildRange(firstArgument,\n                                      arguments[arguments.length - 1]);\n        argumentList.add(arrayExpression);\n      }\n      else {\n        argumentList.add(arrayExpression);\n      }\n      final CodeStyleManager codeStyleManager =\n        CodeStyleManager.getInstance(project);\n      final JavaCodeStyleManager javaCodeStyleManager =\n        JavaCodeStyleManager.getInstance(project);\n      javaCodeStyleManager.shortenClassReferences(argumentList);\n      codeStyleManager.reformat(argumentList);\n    }","id":85586,"modified_method":"public static void modifyCalls(PsiReference reference, String arrayTypeText, int indexOfFirstVarargArgument) {\n      final PsiReferenceExpression referenceExpression = (PsiReferenceExpression)reference.getElement();\n      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)referenceExpression.getParent();\n      final PsiExpressionList argumentList = methodCallExpression.getArgumentList();\n      final PsiExpression[] arguments = argumentList.getExpressions();\n      @NonNls final StringBuilder builder = new StringBuilder(\"new \");\n      builder.append(arrayTypeText);\n      builder.append(\"[]{\");\n      if (arguments.length > indexOfFirstVarargArgument) {\n        final PsiExpression firstArgument = arguments[indexOfFirstVarargArgument];\n        final String firstArgumentText = firstArgument.getText();\n        builder.append(firstArgumentText);\n        for (int i = indexOfFirstVarargArgument + 1; i < arguments.length; i++) {\n          builder.append(',').append(arguments[i].getText());\n        }\n      }\n      builder.append('}');\n      final Project project = referenceExpression.getProject();\n      final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n      final PsiExpression arrayExpression = factory.createExpressionFromText(builder.toString(), referenceExpression);\n      if (arguments.length > indexOfFirstVarargArgument) {\n        final PsiExpression firstArgument = arguments[indexOfFirstVarargArgument];\n        argumentList.deleteChildRange(firstArgument, arguments[arguments.length - 1]);\n        argumentList.add(arrayExpression);\n      }\n      else {\n        argumentList.add(arrayExpression);\n      }\n      final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n      final JavaCodeStyleManager javaCodeStyleManager = JavaCodeStyleManager.getInstance(project);\n      javaCodeStyleManager.shortenClassReferences(argumentList);\n      codeStyleManager.reformat(argumentList);\n    }","commit_id":"186fe4229ccf092f4d6b5d22146c03df9e03dac1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void doFix(Project project, ProblemDescriptor descriptor)\n      throws IncorrectOperationException {\n      final PsiElement element = descriptor.getPsiElement();\n      final PsiMethod method = (PsiMethod)element.getParent();\n      final PsiParameterList parameterList = method.getParameterList();\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiParameter lastParameter =\n        parameters[parameters.length - 1];\n      if (!lastParameter.isVarArgs()) {\n        return;\n      }\n      final PsiEllipsisType type =\n        (PsiEllipsisType)lastParameter.getType();\n      final Query<PsiReference> query = ReferencesSearch.search(method);\n      final PsiType componentType = type.getComponentType();\n      final String typeText = componentType.getCanonicalText();\n      final Collection<PsiReference> references = query.findAll();\n      for (PsiReference reference : references) {\n        modifyCalls(reference, typeText, parameters.length - 1);\n      }\n      final PsiType arrayType = type.toArrayType();\n      final PsiManager psiManager = lastParameter.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(psiManager.getProject()).getElementFactory();\n      final PsiTypeElement newTypeElement =\n        factory.createTypeElement(arrayType);\n      final PsiTypeElement typeElement =\n        lastParameter.getTypeElement();\n      typeElement.replace(newTypeElement);\n    }","id":85587,"modified_method":"@Override\n    protected void doFix(Project project, ProblemDescriptor descriptor) {\n      final PsiElement element = descriptor.getPsiElement();\n      final PsiMethod method = (PsiMethod)element.getParent();\n      final PsiParameterList parameterList = method.getParameterList();\n      final PsiParameter[] parameters = parameterList.getParameters();\n      final PsiParameter lastParameter = parameters[parameters.length - 1];\n      if (!lastParameter.isVarArgs()) {\n        return;\n      }\n      final PsiEllipsisType type = (PsiEllipsisType)lastParameter.getType();\n      final Query<PsiReference> query = ReferencesSearch.search(method);\n      final PsiType componentType = type.getComponentType();\n      final String typeText;\n      if (componentType instanceof PsiClassType) {\n        final PsiClassType classType = (PsiClassType)componentType;\n        typeText = classType.rawType().getCanonicalText();\n      } else {\n        typeText = componentType.getCanonicalText();\n      }\n      final Collection<PsiReference> references = query.findAll();\n      for (PsiReference reference : references) {\n        modifyCalls(reference, typeText, parameters.length - 1);\n      }\n      final PsiType arrayType = type.toArrayType();\n      final PsiManager psiManager = lastParameter.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(psiManager.getProject()).getElementFactory();\n      final PsiTypeElement newTypeElement = factory.createTypeElement(arrayType);\n      final PsiTypeElement typeElement = lastParameter.getTypeElement();\n      if (typeElement == null) {\n        return;\n      }\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(method, \"java.lang.SafeVarargs\");\n      if (annotation != null) {\n        annotation.delete();\n      }\n      typeElement.replace(newTypeElement);\n    }","commit_id":"186fe4229ccf092f4d6b5d22146c03df9e03dac1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Write the filebookmarks.html file.\n     * @param folder path to output folder\n     */\n    private void writeFileBookmarks(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"filebookmarks.html\"), \"UTF-8\"));\n            out.write(generateHead(\"File Bookmarks (\" + countFileBookmarks + \")\"));\n            String title = \"<h3>File Bookmarks (\" + countFileBookmarks + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Description\", \"File Name\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: fileBookmarks) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getName()).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for filebookmarks.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find filebookmarks.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing filebookmarks.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for filebookmarks.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85588,"modified_method":"/**\n     * Write the filebookmarks.html file.\n     * @param folder path to output folder\n     */\n    private void writeFileBookmarks(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"filebookmarks.html\"), \"UTF-8\"));\n            out.write(generateHead(\"File Bookmarks (\" + countFileBookmarks + \")\"));\n            String title = \"<h3>File Bookmarks (\" + countFileBookmarks + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Description\", \"File Name\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: fileBookmarks) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DESCRIPTION.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file != null ? file.getName() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for filebookmarks.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find filebookmarks.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing filebookmarks.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for filebookmarks.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the device.html file.\n     * @param folder path to output folder\n     */\n    private void writeDevice(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"devices.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Attached Device Artifacts (\" + countDevices + \")\"));\n            String title = \"<h3>Attached Devices (\" + countDevices + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Name\", \"Serial #\", \"Time\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: devices) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID())).append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for devices.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find devices.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing devices.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for devices.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85589,"modified_method":"/**\n     * Write the device.html file.\n     * @param folder path to output folder\n     */\n    private void writeDevice(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"devices.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Attached Device Artifacts (\" + countDevices + \")\"));\n            String title = \"<h3>Attached Devices (\" + countDevices + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Name\", \"Serial #\", \"Time\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: devices) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID())).append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for devices.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find devices.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing devices.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for devices.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the history.html file.\n     * @param folder path to output folder\n     */\n    private void writeHistory(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"history.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web History Artifacts (\" + countHistory + \")\"));\n            String title = \"<h3>Web History (\" + countHistory + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Date\", \"Referrer\", \"Name\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: history) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for history.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find history.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing history.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for history.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85590,"modified_method":"/**\n     * Write the history.html file.\n     * @param folder path to output folder\n     */\n    private void writeHistory(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"history.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web History Artifacts (\" + countHistory + \")\"));\n            String title = \"<h3>Web History (\" + countHistory + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Date\", \"Referrer\", \"Name\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: history) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_REFERRER.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for history.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find history.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing history.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for history.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the downloads.html file.\n     * @param folder path to output folder\n     */\n    private void writeDownload(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"downloads.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web Download Artifacts (\" + countDownloads + \")\"));\n            String title = \"<h3>Web Downloads (\" + countDownloads + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Source\", \"Time\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: downloads) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for downloads.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find downloads.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing downloads.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for downloads.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85591,"modified_method":"/**\n     * Write the downloads.html file.\n     * @param folder path to output folder\n     */\n    private void writeDownload(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"downloads.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web Download Artifacts (\" + countDownloads + \")\"));\n            String title = \"<h3>Web Downloads (\" + countDownloads + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Source\", \"Time\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: downloads) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PATH.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for downloads.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find downloads.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing downloads.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for downloads.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the installed.html file.\n     * @param folder path to output folder\n     */\n    private void writeInstalled(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"installed.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Installed Program Artifacts (\" + countInstalled + \")\"));\n            String title = \"<h3>Installed Programs (\" + countInstalled + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Program Name\", \"Install Date/Time\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: installed) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for installed.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find installed.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing installed.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for installed.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85592,"modified_method":"/**\n     * Write the installed.html file.\n     * @param folder path to output folder\n     */\n    private void writeInstalled(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"installed.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Installed Program Artifacts (\" + countInstalled + \")\"));\n            String title = \"<h3>Installed Programs (\" + countInstalled + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Program Name\", \"Install Date/Time\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: installed) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for installed.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find installed.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing installed.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for installed.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the recent.html file.\n     * @param folder path to output folder\n     */\n    private void writeRecent(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"recent.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Recent Document Artifacts (\" + countRecent + \")\"));\n            String title = \"<h3>Recent Documents (\" + countRecent + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Name\", \"Related Shortcut\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: recent) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(file != null ? file.getName() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for recent.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find recent.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing recent.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for recent.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85593,"modified_method":"/**\n     * Write the recent.html file.\n     * @param folder path to output folder\n     */\n    private void writeRecent(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"recent.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Recent Document Artifacts (\" + countRecent + \")\"));\n            String title = \"<h3>Recent Documents (\" + countRecent + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Name\", \"Related Shortcut\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: recent) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td><strong>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getName() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for recent.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find recent.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing recent.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for recent.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the exif.html file.\n     * @param folder path to output folder\n     */\n    private void writeExif(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"exif.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Exif Metadata Artifacts (\" + countExif + \")\"));\n            String title = \"<h3>Exif Metadata (\" + countExif + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"File Name\", \"Date Taken\", \"Device Manufacturer\", \"Device Model\", \"Latitude\", \"Longitude\", \"Altitude\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: exif) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(file != null ? file.getName() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MAKE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for exif.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find exif.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing exif.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for exif.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85594,"modified_method":"/**\n     * Write the exif.html file.\n     * @param folder path to output folder\n     */\n    private void writeExif(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"exif.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Exif Metadata Artifacts (\" + countExif + \")\"));\n            String title = \"<h3>Exif Metadata (\" + countExif + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"File Name\", \"Date Taken\", \"Device Manufacturer\", \"Device Model\", \"Latitude\", \"Longitude\", \"Altitude\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: exif) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(file != null ? file.getName() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MAKE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LATITUDE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_LONGITUDE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_GEO_ALTITUDE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for exif.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find exif.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing exif.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for exif.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the trackpoint.html file.\n     * @param folder path to output folder\n     */\n    private void writeTrackpoint(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"trackpoint.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Track Point Artifacts (\" + countTrackpoint + \")\"));\n            String title = \"<h3>Track Points (\" + countTrackpoint + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Object ID\", \"Name\", \"Size\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: trackpoint) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                Long fileSize = file.getSize();\n                \n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(objId.toString()).append(\"<\/td>\\n\");\n                row.append(\"<td><strong>\").append(file.getName().toString()).append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(fileSize.toString()).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for trackpoint.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find trackpoint.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing trackpoint.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for trackpoint.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85595,"modified_method":"/**\n     * Write the trackpoint.html file.\n     * @param folder path to output folder\n     */\n    private void writeTrackpoint(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"trackpoint.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Track Point Artifacts (\" + countTrackpoint + \")\"));\n            String title = \"<h3>Track Points (\" + countTrackpoint + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Object ID\", \"Name\", \"Size\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: trackpoint) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                Long fileSize = file.getSize();\n                \n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(objId.toString()).append(\"<\/td>\\n\");\n                row.append(\"<td><strong>\").append(file != null ? file.getName().toString() : \"\").append(\"<\/strong><\/td>\\n\");\n                row.append(\"<td>\").append(fileSize.toString()).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for trackpoint.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find trackpoint.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing trackpoint.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for trackpoint.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the cookies.html file.\n     * @param folder path to output folder\n     */\n    private void writeCookie(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"cookies.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web Cookie Artifacts (\" + countCookies + \")\"));\n            String title = \"<h3>Web Cookies (\" + countCookies + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Date\", \"Name\", \"Value\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: cookies) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for cookies.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find cookies.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing cookies.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for cookies.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n        \n    }","id":85596,"modified_method":"/**\n     * Write the cookies.html file.\n     * @param folder path to output folder\n     */\n    private void writeCookie(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"cookies.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web Cookie Artifacts (\" + countCookies + \")\"));\n            String title = \"<h3>Web Cookies (\" + countCookies + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Date\", \"Name\", \"Value\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: cookies) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_VALUE.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for cookies.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find cookies.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing cookies.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for cookies.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n        \n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the search.html file.\n     * @param folder path to output folder\n     */\n    private void writeSearch(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"search.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web Search Query Artifacts (\" + countSearch + \")\"));\n            String title = \"<h3>Web Search Queries (\" + countSearch + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Program Name\", \"Domain\", \"Text\", \"Last Modified\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: search) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for search.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find search.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing search.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for search.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85597,"modified_method":"/**\n     * Write the search.html file.\n     * @param folder path to output folder\n     */\n    private void writeSearch(String folder) {\n        Writer out = null;\n        try {\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"search.html\"), \"UTF-8\"));\n            out.write(generateHead(\"Web Search Query Artifacts (\" + countSearch + \")\"));\n            String title = \"<h3>Web Search Queries (\" + countSearch + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"Program Name\", \"Domain\", \"Text\", \"Last Modified\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: search) {\n                if (ReportFilter.cancel == true) { break; }\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DOMAIN.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_TEXT.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                out.write(row.toString());\n            }\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for search.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find search.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing search.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for search.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Write the bookmarks.html file.\n     * @param folder path to output folder\n     */\n    private void writeBookmark(String folder) {\n        Writer out = null;\n        try {\n            // Get the writer for the HTML file\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"bookmarks.html\"), \"UTF-8\"));\n            // Write the HTML title\n            out.write(generateHead(\"Web Bookmark Artifacts (\" + countBookmarks + \")\"));\n            // Write the title for the artifact and the top of the table\n            String title = \"<h3>Web Bookmarks (\" + countBookmarks + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Title\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            // For every artifact we have, add a row\n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: bookmarks) {\n                if (ReportFilter.cancel == true) { break; }\n                // Get the AbstractFile that belongs to this artifact\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                // Use the helper to get all the attributes for this artifact,\n                // and map them to their attribute_type_id\n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file.getUniquePath()).append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                // Write the row to file, so we don't get too cluttered\n                out.write(row.toString());\n            }\n            // Write the bottom of the table, and the end of the HTML page\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for bookmarks.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find bookmarks.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing bookmarks.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for bookmarks.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","id":85598,"modified_method":"/**\n     * Write the bookmarks.html file.\n     * @param folder path to output folder\n     */\n    private void writeBookmark(String folder) {\n        Writer out = null;\n        try {\n            // Get the writer for the HTML file\n            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(folder + \"bookmarks.html\"), \"UTF-8\"));\n            // Write the HTML title\n            out.write(generateHead(\"Web Bookmark Artifacts (\" + countBookmarks + \")\"));\n            // Write the title for the artifact and the top of the table\n            String title = \"<h3>Web Bookmarks (\" + countBookmarks + \")<\/h3>\\n\";\n            String tableHeader = getTableHead(\"URL\", \"Title\", \"Program\", \"Path\");\n            out.write(title);\n            out.write(tableHeader);\n            \n            // For every artifact we have, add a row\n            for(Entry<BlackboardArtifact, List<BlackboardAttribute>> entry: bookmarks) {\n                if (ReportFilter.cancel == true) { break; }\n                // Get the AbstractFile that belongs to this artifact\n                Long objId = entry.getKey().getObjectID();\n                AbstractFile file = getFile(objId);\n                \n                // Use the helper to get all the attributes for this artifact,\n                // and map them to their attribute_type_id\n                TreeMap<Integer, String> attributes = getAttributes(entry.getValue());\n                StringBuilder row = new StringBuilder();\n                row.append(\"<tr>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(attributes.get(BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID())).append(\"<\/td>\\n\");\n                row.append(\"<td>\").append(file !=null ? file.getUniquePath() : \"\").append(\"<\/td>\\n\");\n                row.append(\"<\/tr>\\n\");\n                // Write the row to file, so we don't get too cluttered\n                out.write(row.toString());\n            }\n            // Write the bottom of the table, and the end of the HTML page\n            out.write(TABLE_FOOT);\n            out.write(HTML_FOOT);\n        } catch (TskCoreException ex) {\n            logger.log(Level.SEVERE, \"Unable to get file's path for bookmarks.html.\");\n        } catch (FileNotFoundException ex) {\n            logger.log(Level.SEVERE, \"Could not find bookmarks.html file to write to.\");\n        } catch (UnsupportedEncodingException ex) {\n            logger.log(Level.SEVERE, \"Did not recognize encoding when writing bookmarks.hmtl.\");\n        } catch (IOException ex) {\n            logger.log(Level.SEVERE, \"Error creating Writer for bookmarks.html.\");\n        } finally {\n            try {\n                if(out != null) {\n                    out.flush();\n                    out.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }","commit_id":"ea8ffd6ccc52419aa8c278b567b68c48c11d750e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogAbout(final GUI main) {\r\n    super(main, ABOUTTITLE);\r\n\r\n    BaseXBack p = new BaseXBack(new BorderLayout(12, 0));\r\n    p.setBackground(Color.white);\r\n    p.setBorder(new CompoundBorder(new EtchedBorder(),\r\n        new EmptyBorder(10, 10, 15, 22)));\r\n\r\n    final BaseXLabel label = new BaseXLabel();\r\n    label.setIcon(BaseXLayout.icon(\"logo\"));\r\n    label.setVerticalAlignment(SwingConstants.TOP);\r\n    label.setCursor(GUIConstants.CURSORHAND);\r\n    label.addMouseListener(new MouseAdapter() {\r\n      @Override\r\n      public void mouseClicked(final MouseEvent e) {\r\n        Dialog.browse(gui, URL);\r\n      }\r\n    });\r\n\r\n    p.add(label, BorderLayout.WEST);\r\n\r\n    final BaseXBack pp = new BaseXBack(GUIConstants.Fill.NONE).layout(\r\n        new TableLayout(16, 1));\r\n\r\n    pp.add(new BaseXLabel(Text.TITLE, false, true));\r\n    pp.add(new BaseXLabel(Text.URL));\r\n    pp.add(Box.createVerticalStrut(7));\r\n    pp.add(new BaseXLabel(COPYRIGHT));\r\n    pp.add(new BaseXLabel(LICENSE));\r\n    pp.add(Box.createVerticalStrut(7));\r\n    pp.add(new BaseXLabel(DEVELOPER));\r\n    pp.add(Box.createVerticalStrut(7));\r\n    pp.add(new BaseXLabel(CONTRIBUTE1));\r\n    pp.add(new BaseXLabel(CONTRIBUTE2));\r\n    pp.add(new BaseXLabel(CONTRIBUTE3));\r\n    pp.add(Box.createVerticalStrut(7));\r\n    final String lang = main.context.mprop.get(MainProp.LANG);\r\n    pp.add(new BaseXLabel(TRANSLATION + \" (\" + lang + \"): \" +\r\n        DialogPrefs.creds(lang)));\r\n    p.add(pp, BorderLayout.EAST);\r\n    add(p, BorderLayout.NORTH);\r\n\r\n    p = new BaseXBack();\r\n    p.add(newButtons(this, BUTTONOK));\r\n    add(p, BorderLayout.EAST);\r\n\r\n    finish(null);\r\n  }","id":85599,"modified_method":"/**\r\n   * Default constructor.\r\n   * @param main reference to the main window\r\n   */\r\n  public DialogAbout(final GUI main) {\r\n    super(main, ABOUTTITLE);\r\n\r\n    BaseXBack p = new BaseXBack(new BorderLayout(12, 0));\r\n    p.setBackground(Color.white);\r\n    p.setBorder(new CompoundBorder(new EtchedBorder(),\r\n        new EmptyBorder(10, 10, 15, 22)));\r\n\r\n    final BaseXLabel label = new BaseXLabel();\r\n    label.setIcon(BaseXLayout.icon(\"logo\"));\r\n    label.setVerticalAlignment(SwingConstants.TOP);\r\n\r\n    p.add(label, BorderLayout.WEST);\r\n\r\n    final BaseXBack pp = new BaseXBack(GUIConstants.Fill.NONE).layout(\r\n        new TableLayout(16, 1));\r\n\r\n    pp.add(new BaseXLabel(Text.TITLE, false, true));\r\n    final BaseXLabel url = new BaseXLabel(\r\n        \"<html><u>\" + Text.URL + \"<\/u><\/html>\");\r\n    url.setForeground(GUIConstants.BLUE);\r\n    url.setCursor(GUIConstants.CURSORHAND);\r\n    url.addMouseListener(new MouseAdapter() {\r\n      @Override\r\n      public void mouseClicked(final MouseEvent e) {\r\n        Dialog.browse(gui, URL);\r\n      }\r\n    });\r\n\r\n    pp.add(url);\r\n    pp.add(Box.createVerticalStrut(7));\r\n    pp.add(new BaseXLabel(COPYRIGHT));\r\n    pp.add(new BaseXLabel(LICENSE));\r\n    pp.add(Box.createVerticalStrut(7));\r\n    pp.add(new BaseXLabel(DEVELOPER));\r\n    pp.add(Box.createVerticalStrut(7));\r\n    pp.add(new BaseXLabel(CONTRIBUTE1));\r\n    pp.add(new BaseXLabel(CONTRIBUTE2));\r\n    pp.add(new BaseXLabel(CONTRIBUTE3));\r\n    pp.add(Box.createVerticalStrut(7));\r\n    final String lang = main.context.mprop.get(MainProp.LANG);\r\n    pp.add(new BaseXLabel(TRANSLATION + \" (\" + lang + \"): \" +\r\n        DialogPrefs.creds(lang)));\r\n    p.add(pp, BorderLayout.EAST);\r\n    add(p, BorderLayout.NORTH);\r\n\r\n    p = new BaseXBack();\r\n    p.add(newButtons(this, BUTTONOK));\r\n    add(p, BorderLayout.EAST);\r\n\r\n    finish(null);\r\n  }","commit_id":"bd5f0589c50ed12c61ee7518e9ee5c23528ebbee","url":"https://github.com/BaseXdb/basex"},{"original_method":"public void mouseClicked(java.awt.event.MouseEvent e) {\n               if (e.getClickCount() != 2)\n                   return;\n               try {\n                   final JTextArea value = (JTextArea) e.getSource();\n                   String text = value.getText();\n                   if (text.startsWith(\"http://\") || text.startsWith(\"/\")) {\n                       e.consume();\n                       final Color c = value.getForeground();\n                       value.setForeground(Color.red);\n                       value.paintImmediately(0,0, value.getWidth(), value.getHeight());\n                       tufts.vue.VueUtil.openURL(text);\n                       GUI.invokeAfterAWT(new Runnable() {\n                               public void run() {\n                                   value.setForeground(c);\n                               }\n                           });\n                   }\n               } catch (Throwable t) {\n                   Log.error(t);\n               }\n           }","id":85600,"modified_method":"public void mouseClicked(java.awt.event.MouseEvent e) {\n            if (e.getClickCount() != 2)\n                return;\n            try {\n                final JTextArea value = (JTextArea) e.getSource();\n                if (value.getClientProperty(CAN_OPEN) == Boolean.TRUE) {\n                    e.consume();\n                    final Color c = value.getForeground();\n                    value.setForeground(Color.red);\n                    value.paintImmediately(0,0, value.getWidth(), value.getHeight());\n                    tufts.vue.VueUtil.openURL(value.getText());\n                    GUI.invokeAfterAWT(new Runnable() {\n                            public void run() {\n                                value.setForeground(c);\n                            }\n                        });\n                }\n            } catch (Throwable t) {\n                Log.error(t);\n            }\n        }","commit_id":"0757898fd161a3b94976fa434a7ec7a55b4ae21e","url":"https://github.com/VUE/VUE"},{"original_method":"private void loadRow(int row, String labelText, String valueText) {\n       if (DEBUG.RESOURCE && DEBUG.META) out(\"adding row \" + row + \" \" + labelText + \"=[\" + valueText + \"]\");\n\n       JLabel label = mLabels[row];\n       JTextArea value = mValues[row];       \n\n       label.setText(labelText + \":\");\n       value.setText(valueText);\n\n       if (valueText != null && (valueText.startsWith(\"http://\") || valueText.startsWith(\"/\")) ) {\n           value.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));\n           //value.setForeground(Color.blue);\n       } else {\n           //label.removeMouseListener(CommonURLListener);\n           value.setCursor(Cursor.getDefaultCursor());\n           //GUI.apply(GUI.ValueFace, mValues[i]);\n       }\n       \n       // if value has at least one space, use word wrap\n       if (valueText.indexOf(' ') >= 0)\n           value.setWrapStyleWord(true);\n       else\n           value.setWrapStyleWord(false);\n       \n       label.setVisible(true);\n       value.setVisible(true);\n       \n   }","id":85601,"modified_method":"private void loadRow(int row, final String labelText, final String valueText) {\n        if (DEBUG.RESOURCE && DEBUG.META) out(\"adding row \" + row + \" \" + labelText + \"=[\" + valueText + \"]\");\n\n        JLabel label = mLabels[row];\n        JTextArea value = mValues[row];       \n\n        label.setText(labelText + \":\");\n        value.setText(valueText);\n\n        if (Resource.isLikelyURLorFile(valueText)) {\n            value.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));\n            value.putClientProperty(CAN_OPEN, Boolean.TRUE);\n            if (DEBUG.Enabled) value.setForeground(Color.blue);\n        } else {\n            value.putClientProperty(CAN_OPEN, Boolean.FALSE);\n            if (DEBUG.Enabled) value.setForeground(Color.black);\n            //label.removeMouseListener(CommonURLListener);\n            value.setCursor(Cursor.getDefaultCursor());\n            //GUI.apply(GUI.ValueFace, mValues[i]);\n        }\n       \n        // if value has at least one space, use word wrap\n        if (valueText.indexOf(' ') >= 0)\n            value.setWrapStyleWord(true);\n        else\n            value.setWrapStyleWord(false);\n       \n        label.setVisible(true);\n        value.setVisible(true);\n       \n    }","commit_id":"0757898fd161a3b94976fa434a7ec7a55b4ae21e","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\n    protected void configure() {\n        bind(IndexService.class).to(InternalIndexService.class).asEagerSingleton();\n        bind(IndexServiceManagement.class).asEagerSingleton();\n    }","id":85602,"modified_method":"@Override\n    protected void configure() {\n        bind(IndexService.class).to(InternalIndexService.class).asEagerSingleton();\n        if (JmxService.shouldExport(settings)) {\n            bind(IndexServiceManagement.class).asEagerSingleton();\n        }\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void configure() {\n        bind(ShardId.class).toInstance(shardId);\n        bind(IndexShard.class).to(InternalIndexShard.class).asEagerSingleton();\n        bind(IndexShardManagement.class).asEagerSingleton();\n    }","id":85603,"modified_method":"@Override\n    protected void configure() {\n        bind(ShardId.class).toInstance(shardId);\n        bind(IndexShard.class).to(InternalIndexShard.class).asEagerSingleton();\n        if (JmxService.shouldExport(settings)) {\n            bind(IndexShardManagement.class).asEagerSingleton();\n        }\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public IndexShardModule(ShardId shardId) {\n        this.shardId = shardId;\n    }","id":85604,"modified_method":"public IndexShardModule(Settings settings, ShardId shardId) {\n        this.settings = settings;\n        this.shardId = shardId;\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public synchronized IndexShard createShard(int sShardId) throws ElasticSearchException {\n        if (closed) {\n            throw new ElasticSearchIllegalStateException(\"Can't create shard [\" + index.name() + \"][\" + sShardId + \"], closed\");\n        }\n        ShardId shardId = new ShardId(index, sShardId);\n        if (shardsInjectors.containsKey(shardId.id())) {\n            throw new IndexShardAlreadyExistsException(shardId + \" already exists\");\n        }\n\n        indicesLifecycle.beforeIndexShardCreated(shardId);\n\n        logger.debug(\"creating shard_id [{}]\", shardId.id());\n\n        ModulesBuilder modules = new ModulesBuilder();\n        modules.add(new ShardsPluginsModule(indexSettings, pluginsService));\n        modules.add(new IndexShardModule(shardId));\n        modules.add(new ShardIndexingModule());\n        modules.add(new ShardSearchModule());\n        modules.add(new ShardGetModule());\n        modules.add(new StoreModule(indexSettings, injector.getInstance(IndexStore.class)));\n        modules.add(new DeletionPolicyModule(indexSettings));\n        modules.add(new MergePolicyModule(indexSettings));\n        modules.add(new MergeSchedulerModule(indexSettings));\n        modules.add(new TranslogModule(indexSettings));\n        modules.add(new EngineModule(indexSettings));\n        modules.add(new IndexShardGatewayModule(injector.getInstance(IndexGateway.class)));\n\n        Injector shardInjector;\n        try {\n            shardInjector = modules.createChildInjector(injector);\n        } catch (CreationException e) {\n            throw new IndexShardCreationException(shardId, Injectors.getFirstErrorFailure(e));\n        }\n\n        shardsInjectors = newMapBuilder(shardsInjectors).put(shardId.id(), shardInjector).immutableMap();\n\n        IndexShard indexShard = shardInjector.getInstance(IndexShard.class);\n\n        indicesLifecycle.afterIndexShardCreated(indexShard);\n\n        shards = newMapBuilder(shards).put(shardId.id(), indexShard).immutableMap();\n\n        return indexShard;\n    }","id":85605,"modified_method":"@Override\n    public synchronized IndexShard createShard(int sShardId) throws ElasticSearchException {\n        if (closed) {\n            throw new ElasticSearchIllegalStateException(\"Can't create shard [\" + index.name() + \"][\" + sShardId + \"], closed\");\n        }\n        ShardId shardId = new ShardId(index, sShardId);\n        if (shardsInjectors.containsKey(shardId.id())) {\n            throw new IndexShardAlreadyExistsException(shardId + \" already exists\");\n        }\n\n        indicesLifecycle.beforeIndexShardCreated(shardId);\n\n        logger.debug(\"creating shard_id [{}]\", shardId.id());\n\n        ModulesBuilder modules = new ModulesBuilder();\n        modules.add(new ShardsPluginsModule(indexSettings, pluginsService));\n        modules.add(new IndexShardModule(indexSettings, shardId));\n        modules.add(new ShardIndexingModule());\n        modules.add(new ShardSearchModule());\n        modules.add(new ShardGetModule());\n        modules.add(new StoreModule(indexSettings, injector.getInstance(IndexStore.class)));\n        modules.add(new DeletionPolicyModule(indexSettings));\n        modules.add(new MergePolicyModule(indexSettings));\n        modules.add(new MergeSchedulerModule(indexSettings));\n        modules.add(new TranslogModule(indexSettings));\n        modules.add(new EngineModule(indexSettings));\n        modules.add(new IndexShardGatewayModule(injector.getInstance(IndexGateway.class)));\n\n        Injector shardInjector;\n        try {\n            shardInjector = modules.createChildInjector(injector);\n        } catch (CreationException e) {\n            throw new IndexShardCreationException(shardId, Injectors.getFirstErrorFailure(e));\n        }\n\n        shardsInjectors = newMapBuilder(shardsInjectors).put(shardId.id(), shardInjector).immutableMap();\n\n        IndexShard indexShard = shardInjector.getInstance(IndexShard.class);\n\n        indicesLifecycle.afterIndexShardCreated(indexShard);\n\n        shards = newMapBuilder(shards).put(shardId.id(), indexShard).immutableMap();\n\n        return indexShard;\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public synchronized IndexService createIndex(String sIndexName, Settings settings, String localNodeId) throws ElasticSearchException {\n        if (!lifecycle.started()) {\n            throw new ElasticSearchIllegalStateException(\"Can't create an index [\" + sIndexName + \"], node is closed\");\n        }\n        Index index = new Index(sIndexName);\n        if (indicesInjectors.containsKey(index.name())) {\n            throw new IndexAlreadyExistsException(index);\n        }\n\n        indicesLifecycle.beforeIndexCreated(index);\n\n        logger.debug(\"creating Index [{}], shards [{}]/[{}]\", sIndexName, settings.get(SETTING_NUMBER_OF_SHARDS), settings.get(SETTING_NUMBER_OF_REPLICAS));\n\n        Settings indexSettings = settingsBuilder()\n                .put(\"settingsType\", \"index\")\n                .put(this.settings)\n                .put(settings)\n                .classLoader(settings.getClassLoader())\n                .build();\n\n        ModulesBuilder modules = new ModulesBuilder();\n        modules.add(new IndexNameModule(index));\n        modules.add(new LocalNodeIdModule(localNodeId));\n        modules.add(new IndexSettingsModule(index, indexSettings));\n        modules.add(new IndexPluginsModule(indexSettings, pluginsService));\n        modules.add(new IndexStoreModule(indexSettings));\n        modules.add(new IndexEngineModule(indexSettings));\n        modules.add(new AnalysisModule(indexSettings, indicesAnalysisService));\n        modules.add(new SimilarityModule(indexSettings));\n        modules.add(new IndexCacheModule(indexSettings));\n        modules.add(new IndexQueryParserModule(indexSettings));\n        modules.add(new MapperServiceModule());\n        modules.add(new IndexAliasesServiceModule());\n        modules.add(new IndexGatewayModule(indexSettings, injector.getInstance(Gateway.class)));\n        modules.add(new IndexModule());\n        modules.add(new PercolatorModule());\n\n        Injector indexInjector;\n        try {\n            indexInjector = modules.createChildInjector(injector);\n        } catch (CreationException e) {\n            throw new IndexCreationException(index, Injectors.getFirstErrorFailure(e));\n        }\n\n        indicesInjectors.put(index.name(), indexInjector);\n\n        IndexService indexService = indexInjector.getInstance(IndexService.class);\n\n        indicesLifecycle.afterIndexCreated(indexService);\n\n        indices = newMapBuilder(indices).put(index.name(), indexService).immutableMap();\n\n        return indexService;\n    }","id":85606,"modified_method":"public synchronized IndexService createIndex(String sIndexName, Settings settings, String localNodeId) throws ElasticSearchException {\n        if (!lifecycle.started()) {\n            throw new ElasticSearchIllegalStateException(\"Can't create an index [\" + sIndexName + \"], node is closed\");\n        }\n        Index index = new Index(sIndexName);\n        if (indicesInjectors.containsKey(index.name())) {\n            throw new IndexAlreadyExistsException(index);\n        }\n\n        indicesLifecycle.beforeIndexCreated(index);\n\n        logger.debug(\"creating Index [{}], shards [{}]/[{}]\", sIndexName, settings.get(SETTING_NUMBER_OF_SHARDS), settings.get(SETTING_NUMBER_OF_REPLICAS));\n\n        Settings indexSettings = settingsBuilder()\n                .put(\"settingsType\", \"index\")\n                .put(this.settings)\n                .put(settings)\n                .classLoader(settings.getClassLoader())\n                .build();\n\n        ModulesBuilder modules = new ModulesBuilder();\n        modules.add(new IndexNameModule(index));\n        modules.add(new LocalNodeIdModule(localNodeId));\n        modules.add(new IndexSettingsModule(index, indexSettings));\n        modules.add(new IndexPluginsModule(indexSettings, pluginsService));\n        modules.add(new IndexStoreModule(indexSettings));\n        modules.add(new IndexEngineModule(indexSettings));\n        modules.add(new AnalysisModule(indexSettings, indicesAnalysisService));\n        modules.add(new SimilarityModule(indexSettings));\n        modules.add(new IndexCacheModule(indexSettings));\n        modules.add(new IndexQueryParserModule(indexSettings));\n        modules.add(new MapperServiceModule());\n        modules.add(new IndexAliasesServiceModule());\n        modules.add(new IndexGatewayModule(indexSettings, injector.getInstance(Gateway.class)));\n        modules.add(new IndexModule(indexSettings));\n        modules.add(new PercolatorModule());\n\n        Injector indexInjector;\n        try {\n            indexInjector = modules.createChildInjector(injector);\n        } catch (CreationException e) {\n            throw new IndexCreationException(index, Injectors.getFirstErrorFailure(e));\n        }\n\n        indicesInjectors.put(index.name(), indexInjector);\n\n        IndexService indexService = indexInjector.getInstance(IndexService.class);\n\n        indicesLifecycle.afterIndexCreated(indexService);\n\n        indices = newMapBuilder(indices).put(index.name(), indexService).immutableMap();\n\n        return indexService;\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void configure() {\n        JmxService jmxService = new JmxService(Loggers.getLogger(JmxService.class, settings.get(\"name\")), settings);\n        bind(JmxService.class).toInstance(jmxService);\n        bind(GetJmxServiceUrlAction.class).asEagerSingleton();\n        bindListener(Matchers.any(), new JmxExporterTypeListener(jmxService));\n    }","id":85607,"modified_method":"@Override\n    protected void configure() {\n        JmxService jmxService = new JmxService(Loggers.getLogger(JmxService.class, settings.get(\"name\")), settings);\n        bind(JmxService.class).toInstance(jmxService);\n        bind(GetJmxServiceUrlAction.class).asEagerSingleton();\n        if (JmxService.shouldExport(settings)) {\n            bindListener(Matchers.any(), new JmxExporterTypeListener(jmxService));\n        }\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void configure() {\n        bind(LocalTransport.class).asEagerSingleton();\n        bind(Transport.class).to(LocalTransport.class).asEagerSingleton();\n        bind(LocalTransportManagement.class).asEagerSingleton();\n    }","id":85608,"modified_method":"@Override\n    protected void configure() {\n        bind(LocalTransport.class).asEagerSingleton();\n        bind(Transport.class).to(LocalTransport.class).asEagerSingleton();\n        if (JmxService.shouldExport(settings)) {\n            bind(LocalTransportManagement.class).asEagerSingleton();\n        }\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void configure() {\n        bind(NettyTransport.class).asEagerSingleton();\n        bind(Transport.class).to(NettyTransport.class).asEagerSingleton();\n        bind(NettyTransportManagement.class).asEagerSingleton();\n    }","id":85609,"modified_method":"@Override\n    protected void configure() {\n        bind(NettyTransport.class).asEagerSingleton();\n        bind(Transport.class).to(NettyTransport.class).asEagerSingleton();\n        if (JmxService.shouldExport(settings)) {\n            bind(NettyTransportManagement.class).asEagerSingleton();\n        }\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void configure() {\n        bind(DirectoryService.class).to(indexStore.shardDirectory()).asEagerSingleton();\n        bind(StoreManagement.class).asEagerSingleton();\n        bind(Store.class).asEagerSingleton();\n    }","id":85610,"modified_method":"@Override\n    protected void configure() {\n        bind(DirectoryService.class).to(indexStore.shardDirectory()).asEagerSingleton();\n        bind(Store.class).asEagerSingleton();\n        if (JmxService.shouldExport(settings)) {\n            bind(StoreManagement.class).asEagerSingleton();\n        }\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void configure() {\n        bind(TransportService.class).asEagerSingleton();\n        bind(TransportServiceManagement.class).asEagerSingleton();\n    }","id":85611,"modified_method":"@Override\n    protected void configure() {\n        bind(TransportService.class).asEagerSingleton();\n        if (JmxService.shouldExport(settings)) {\n            bind(TransportServiceManagement.class).asEagerSingleton();\n        }\n    }","commit_id":"44a604029366f5983de181eeb2ac54bd1ad3b219","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\r\n\tprotected void onPause( )\r\n\t{\r\n\t\tsuper.onPause( );\r\n\t\tgraphics.view.onPause();\r\n\t}","id":85612,"modified_method":"@Override\r\n\tprotected void onPause( )\r\n\t{\r\n\t\tsuper.onPause( );\r\n\t\tif( graphics.view != null )\r\n\t\t\tgraphics.view.onPause();\r\n\t}","commit_id":"5a843ce3103a47b121a63e1f5e861c80594ec17c","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tprotected void onDestroy( )\r\n\t{\r\n\t\tif( listener != null )\r\n\t\t\tlistener.destroy();\r\n\t\tif( graphics.listener != null )\r\n\t\t\tgraphics.listener.dispose( this );\r\n\t}","id":85613,"modified_method":"@Override\r\n\tprotected void onDestroy( )\r\n\t{\r\n\t\tsuper.onDestroy();\r\n\t\tif( listener != null )\r\n\t\t\tlistener.destroy();\r\n\t\tif( graphics.listener != null )\r\n\t\t\tgraphics.listener.dispose( this );\r\n\t}","commit_id":"5a843ce3103a47b121a63e1f5e861c80594ec17c","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tprotected void onResume( )\r\n\t{\r\n\t\tsuper.onResume();\r\n\t\tgraphics.view.onResume();\r\n\t}","id":85614,"modified_method":"@Override\r\n\tprotected void onResume( )\r\n\t{\r\n\t\tsuper.onResume();\r\n\t\tif( graphics.view != null )\r\n\t\t\tgraphics.view.onResume();\r\n\t}","commit_id":"5a843ce3103a47b121a63e1f5e861c80594ec17c","url":"https://github.com/libgdx/libgdx"},{"original_method":"public AndroidGraphics( AndroidApplication activity, boolean useGL2IfAvailable )\r\n\t{\t\t\r\n\t\tactivity.requestWindowFeature(Window.FEATURE_NO_TITLE);        \r\n\t\tactivity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN );\r\n\t\t\r\n\t\tif( useGL2IfAvailable )\r\n\t\t{\r\n\t\t\tif( checkGL20( activity ) )\t\t\t\r\n\t\t\t\tview = new GLSurfaceView20( activity );\r\n\t\t\telse\r\n\t\t\t\tview = new GLSurfaceView( activity );\r\n\t\t}\r\n\t\telse\r\n\t\t\tview = new GLSurfaceView( activity );\r\n\t\tactivity.setContentView( view );\r\n\t}","id":85615,"modified_method":"public AndroidGraphics( AndroidApplication activity, boolean useGL2IfAvailable )\r\n\t{\t\t\r\n\t\tactivity.requestWindowFeature(Window.FEATURE_NO_TITLE);        \r\n\t\tactivity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN );\r\n\t\t\r\n\t\tif( useGL2IfAvailable )\r\n\t\t{\r\n\t\t\tif( checkGL20( activity ) )\t\t\t\r\n\t\t\t\tview = new GLSurfaceView20( activity );\r\n\t\t\telse\r\n\t\t\t\tview = new GLSurfaceView( activity );\r\n\t\t}\r\n\t\telse\r\n\t\t\tview = new GLSurfaceView( activity );\r\n\t\tview.setRenderer(this);\r\n\t\tactivity.setContentView( view );\r\n\t\tthis.app = activity;\r\n\t}","commit_id":"5a843ce3103a47b121a63e1f5e861c80594ec17c","url":"https://github.com/libgdx/libgdx"},{"original_method":"public AndroidGraphicsLiveWallpaper (AndroidLiveWallpaper app, AndroidApplicationConfiguration config, ResolutionStrategy resolutionStrategy) {\r\n\t\tthis.config = config;\r\n\t\tview = createGLSurfaceView(app, config.useGL20, resolutionStrategy);\r\n\t\tthis.app = app;\r\n\r\n\t}","id":85616,"modified_method":"public AndroidGraphicsLiveWallpaper (AndroidLiveWallpaper app, AndroidApplicationConfiguration config, ResolutionStrategy resolutionStrategy) {\r\n\t\tthis.config = config;\r\n\t\tthis.app = app;\r\n\t\tview = createGLSurfaceView(app.service, config.useGL20, resolutionStrategy);\r\n\t\tsetPreserveContext(view);\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void logConfig (EGLConfig config) {\r\n\t\tEGL10 egl = (EGL10)EGLContext.getEGL();\r\n\t\tEGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);\r\n\t\tint r = getAttrib(egl, display, config, EGL10.EGL_RED_SIZE, 0);\r\n\t\tint g = getAttrib(egl, display, config, EGL10.EGL_GREEN_SIZE, 0);\r\n\t\tint b = getAttrib(egl, display, config, EGL10.EGL_BLUE_SIZE, 0);\r\n\t\tint a = getAttrib(egl, display, config, EGL10.EGL_ALPHA_SIZE, 0);\r\n\t\tint d = getAttrib(egl, display, config, EGL10.EGL_DEPTH_SIZE, 0);\r\n\t\tint s = getAttrib(egl, display, config, EGL10.EGL_STENCIL_SIZE, 0);\r\n\t\tint samples = Math.max(getAttrib(egl, display, config, EGL10.EGL_SAMPLES, 0),\r\n\t\t\tgetAttrib(egl, display, config, GdxEglConfigChooser.EGL_COVERAGE_SAMPLES_NV, 0));\r\n\t\tboolean coverageSample = getAttrib(egl, display, config, GdxEglConfigChooser.EGL_COVERAGE_SAMPLES_NV, 0) != 0;\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"framebuffer: (\" + r + \", \" + g + \", \" + b + \", \" + a + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"depthbuffer: (\" + d + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"stencilbuffer: (\" + s + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"samples: (\" + samples + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"coverage sampling: (\" + coverageSample + \")\");\r\n\r\n\t\tbufferFormat = new BufferFormat(r, g, b, a, d, s, samples, coverageSample);\r\n\t}","id":85617,"modified_method":"private void logConfig (EGLConfig config) {\r\n\t\tEGL10 egl = (EGL10)EGLContext.getEGL();\r\n\t\tEGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);\r\n\t\tint r = getAttrib(egl, display, config, EGL10.EGL_RED_SIZE, 0);\r\n\t\tint g = getAttrib(egl, display, config, EGL10.EGL_GREEN_SIZE, 0);\r\n\t\tint b = getAttrib(egl, display, config, EGL10.EGL_BLUE_SIZE, 0);\r\n\t\tint a = getAttrib(egl, display, config, EGL10.EGL_ALPHA_SIZE, 0);\r\n\t\tint d = getAttrib(egl, display, config, EGL10.EGL_DEPTH_SIZE, 0);\r\n\t\tint s = getAttrib(egl, display, config, EGL10.EGL_STENCIL_SIZE, 0);\r\n\t\tint samples = Math.max(getAttrib(egl, display, config, EGL10.EGL_SAMPLES, 0),\r\n\t\t\tgetAttrib(egl, display, config, GdxEglConfigChooser.EGL_COVERAGE_SAMPLES_NV, 0));\r\n\t\tboolean coverageSample = getAttrib(egl, display, config, GdxEglConfigChooser.EGL_COVERAGE_SAMPLES_NV, 0) != 0;\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"framebuffer: (\" + r + \", \" + g + \", \" + b + \", \" + a + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"depthbuffer: (\" + d + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"stencilbuffer: (\" + s + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"samples: (\" + samples + \")\");\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"coverage sampling: (\" + coverageSample + \")\");\r\n\r\n\t\tbufferFormat = new BufferFormat(r, g, b, a, d, s, samples, coverageSample);\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void onSurfaceChanged (javax.microedition.khronos.opengles.GL10 gl, int width, int height) {\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tupdatePpi();\r\n\t\tgl.glViewport(0, 0, this.width, this.height);\r\n\t\tapp.getListener().resize(width, height);\r\n\t}","id":85618,"modified_method":"@Override\r\n\tpublic void onSurfaceChanged (javax.microedition.khronos.opengles.GL10 gl, int width, int height) {\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tupdatePpi();\r\n\t\tgl.glViewport(0, 0, this.width, this.height);\r\n\t\t\r\n\t\t// jw: moved from onSurfaceCreated (as in AndroidGraphics class)\r\n\t\tif (created == false) {\r\n\t\t\tapp.listener.create();\r\n\t\t\tcreated = true;\r\n\t\t\tsynchronized (this) {\r\n\t\t\t\trunning = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\tapp.listener.resize(width, height);\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic GL11 getGL11 () {\r\n\t\treturn gl11;\r\n\t}","id":85619,"modified_method":"/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic GL11 getGL11 () {\r\n\t\treturn gl11;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public GLBaseSurfaceViewLW getView () {\r\n\t\treturn view;\r\n\t}","id":85620,"modified_method":"public View getView () {\r\n\t\treturn view;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic int getHeight () {\r\n\t\treturn height;\r\n\t}","id":85621,"modified_method":"/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic int getHeight () {\r\n\t\treturn height;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void setContinuousRendering (boolean isContinuous) {\r\n\t\tif (view != null) {\r\n\t\t\tthis.isContinuous = isContinuous;\r\n\t\t\tint renderMode = isContinuous ? GLSurfaceView.RENDERMODE_CONTINUOUSLY : GLSurfaceView.RENDERMODE_WHEN_DIRTY;\r\n\t\t\tview.setRenderMode(renderMode);\r\n\t\t}\r\n\t}","id":85622,"modified_method":"@Override\r\n\tpublic void setContinuousRendering (boolean isContinuous) {\r\n\t\tif (view != null) {\r\n\t\t\tthis.isContinuous = isContinuous;\r\n\t\t\tint renderMode = isContinuous ? GLSurfaceView.RENDERMODE_CONTINUOUSLY : GLSurfaceView.RENDERMODE_WHEN_DIRTY;\r\n\t\t\t// jw: changed\r\n\t\t\t//view.setRenderMode(renderMode);\r\n\t\t\tif (view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)view).setRenderMode(renderMode);\r\n\t\t\telse if (view instanceof GLSurfaceView) ((GLSurfaceView)view).setRenderMode(renderMode);\r\n\t\t\telse throw new RuntimeException(\"unimplemented\");\r\n\t\t\tmean.clear();\r\n\t\t}\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic boolean isGL20Available () {\r\n\t\treturn gl20 != null;\r\n\t}","id":85623,"modified_method":"/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic boolean isGL20Available () {\r\n\t\treturn gl20 != null;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void clearManagedCaches () {\r\n\t\tMesh.clearAllMeshes(app);\r\n\t\tTexture.clearAllTextures(app);\r\n\t\tShaderProgram.clearAllShaderPrograms(app);\r\n\t\tFrameBuffer.clearAllFrameBuffers(app);\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", Mesh.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", Texture.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", ShaderProgram.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", FrameBuffer.getManagedStatus());\r\n\t}","id":85624,"modified_method":"public void clearManagedCaches () {\r\n\t\tMesh.clearAllMeshes(app);\r\n\t\tTexture.clearAllTextures(app);\r\n\t\tShaderProgram.clearAllShaderPrograms(app);\r\n\t\tFrameBuffer.clearAllFrameBuffers(app);\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", Mesh.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", Texture.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", ShaderProgram.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", FrameBuffer.getManagedStatus());\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic int getWidth () {\r\n\t\treturn width;\r\n\t}","id":85625,"modified_method":"/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic int getWidth () {\r\n\t\treturn width;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void onDrawFrame (javax.microedition.khronos.opengles.GL10 gl) {\r\n\r\n\t\tlong time = System.nanoTime();\r\n\t\tdeltaTime = (time - lastFrameTime) / 1000000000.0f;\r\n\t\tlastFrameTime = time;\r\n\t\tmean.addValue(deltaTime);\r\n\r\n\t\tboolean lrunning = false;\r\n\t\tboolean lpause = false;\r\n\t\tboolean ldestroy = false;\r\n\t\tboolean lresume = false;\r\n\r\n\t\tsynchronized (synch) {\r\n\t\t\tlrunning = running;\r\n\t\t\tlpause = pause;\r\n\t\t\tldestroy = destroy;\r\n\t\t\tlresume = resume;\r\n\r\n\t\t\tif (resume) {\r\n\t\t\t\tresume = false;\r\n\t\t\t}\r\n\r\n\t\t\tif (pause) {\r\n\t\t\t\tpause = false;\r\n\t\t\t\tsynch.notifyAll();\r\n\t\t\t}\r\n\r\n\t\t\tif (destroy) {\r\n\t\t\t\tdestroy = false;\r\n\t\t\t\tsynch.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lresume) {\r\n\t\t\tArray<LifecycleListener> listeners = app.lifecycleListeners;\r\n\t\t\tsynchronized(listeners) {\r\n\t\t\t\tfor(LifecycleListener listener: listeners) {\r\n\t\t\t\t\tlistener.resume();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tapp.getListener().resume();\r\n\t\t\tGdx.app.log(\"AndroidGraphics\", \"resumed\");\r\n\t\t}\r\n\r\n\t\t// HACK: added null check to handle set wallpaper from preview null\r\n\t\t// error in renderer\r\n\t\tif (lrunning && (Gdx.graphics.getGL10() != null || Gdx.graphics.getGL11() != null || Gdx.graphics.getGL20() != null)) {\r\n\r\n\t\t\tsynchronized (app.runnables) {\r\n\t\t\t\tfor (int i = 0; i < app.runnables.size; i++) {\r\n\t\t\t\t\tapp.runnables.get(i).run();\r\n\t\t\t\t}\r\n\t\t\t\tapp.runnables.clear();\r\n\t\t\t}\r\n\r\n\t\t\tapp.input.processEvents();\r\n\t\t\tapp.getListener().render();\r\n\t\t}\r\n\r\n\t\tif (lpause) {\r\n\t\t\tArray<LifecycleListener> listeners = app.lifecycleListeners;\r\n\t\t\tsynchronized(listeners) {\r\n\t\t\t\tfor(LifecycleListener listener: listeners) {\r\n\t\t\t\t\tlistener.pause();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tapp.getListener().pause();\r\n\t\t\t((AndroidAudio)app.getAudio()).pause();\r\n\t\t\tGdx.app.log(\"AndroidGraphics\", \"paused\");\r\n\t\t}\r\n\r\n\t\tif (ldestroy) {\r\n\t\t\tArray<LifecycleListener> listeners = app.lifecycleListeners;\r\n\t\t\tsynchronized(listeners) {\r\n\t\t\t\tfor(LifecycleListener listener: listeners) {\r\n\t\t\t\t\tlistener.dispose();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tapp.getListener().dispose();\r\n\t\t\t((AndroidAudio)app.getAudio()).dispose();\r\n\t\t\tGdx.app.log(\"AndroidGraphics\", \"destroyed\");\r\n\t\t}\r\n\r\n\t\tif (time - frameStart > 1000000000) {\r\n\t\t\tfps = frames;\r\n\t\t\tframes = 0;\r\n\t\t\tframeStart = time;\r\n\t\t}\r\n\t\tframes++;\r\n\t}","id":85626,"modified_method":"@Override\r\n\tpublic void onDrawFrame (javax.microedition.khronos.opengles.GL10 gl) {\r\n\t\tlong time = System.nanoTime();\r\n\t\tdeltaTime = (time - lastFrameTime) / 1000000000.0f;\r\n\t\tlastFrameTime = time;\r\n\t\t\r\n\t\t// jw: after pause deltaTime can have somewhat huge value and it destabilize mean, so I propose to just cut it of\r\n\t\tmean.addValue(resume ? 0.0f : deltaTime);\r\n\t\t//mean.addValue(deltaTime);\r\n\r\n\t\tboolean lrunning = false;\r\n\t\tboolean lpause = false;\r\n\t\tboolean ldestroy = false;\r\n\t\tboolean lresume = false;\r\n\r\n\t\tsynchronized (synch) {\r\n\t\t\tlrunning = running;\r\n\t\t\tlpause = pause;\r\n\t\t\tldestroy = destroy;\r\n\t\t\tlresume = resume;\r\n\r\n\t\t\tif (resume) {\r\n\t\t\t\tresume = false;\r\n\t\t\t}\r\n\r\n\t\t\tif (pause) {\r\n\t\t\t\tpause = false;\r\n\t\t\t\tsynch.notifyAll();\r\n\t\t\t}\r\n\r\n\t\t\tif (destroy) {\r\n\t\t\t\tdestroy = false;\r\n\t\t\t\tsynch.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (lresume) {\r\n\t\t\t((AndroidAudio)app.getAudio()).resume();\t// jw: added\r\n\t\t\tapp.listener.resume();\r\n\t\t\tGdx.app.log(\"AndroidGraphics\", \"resumed\");\r\n\t\t}\r\n\r\n\t\t// HACK: added null check to handle set wallpaper from preview null\r\n\t\t// error in renderer\r\n\t\t// jw: this hack is not working always, renderer ends with error for some devices - because of uninitialized gl context\r\n\t\t// jw: now its shouldn't be necessary - after wallpaper backend refactoring:)\r\n\t\tif (lrunning && (Gdx.graphics.getGL10() != null || Gdx.graphics.getGL11() != null || Gdx.graphics.getGL20() != null)) {\r\n\r\n\t\t\t// jw: changed\r\n\t\t\tsynchronized (app.runnables) {\r\n\t\t\t\tapp.executedRunnables.clear();\r\n\t\t\t\tapp.executedRunnables.addAll(app.runnables);\r\n\t\t\t\tapp.runnables.clear();\r\n\r\n\t\t\t\tfor (int i = 0; i < app.executedRunnables.size; i++) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tapp.executedRunnables.get(i).run();\r\n\t\t\t\t\t} catch (Throwable t) {\r\n\t\t\t\t\t\tt.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t/*\r\n\t\t\tsynchronized (app.runnables) {\r\n\t\t\t\tfor (int i = 0; i < app.runnables.size; i++) {\r\n\t\t\t\t\tapp.runnables.get(i).run();\r\n\t\t\t\t}\r\n\t\t\t\tapp.runnables.clear();\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t\r\n\r\n\t\t\tapp.input.processEvents();\r\n\t\t\tapp.listener.render();\r\n\t\t}\r\n\r\n\t\tif (lpause) {\r\n\t\t\tapp.listener.pause();\r\n\t\t\t((AndroidAudio)app.getAudio()).pause();\r\n\t\t\tGdx.app.log(\"AndroidGraphics\", \"paused\");\r\n\t\t}\r\n\r\n\t\tif (ldestroy) {\r\n\t\t\tapp.listener.dispose();\r\n\t\t\t((AndroidAudio)app.getAudio()).dispose();\r\n\t\t\tGdx.app.log(\"AndroidGraphics\", \"destroyed\");\r\n\t\t}\r\n\r\n\t\tif (time - frameStart > 1000000000) {\r\n\t\t\tfps = frames;\r\n\t\t\tframes = 0;\r\n\t\t\tframeStart = time;\r\n\t\t}\r\n\t\tframes++;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic GL20 getGL20 () {\r\n\t\treturn gl20;\r\n\t}","id":85627,"modified_method":"/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic GL20 getGL20 () {\r\n\t\treturn gl20;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic DisplayMode getDesktopDisplayMode () {\r\n\t\tDisplayMetrics metrics = new DisplayMetrics();\r\n\r\n\t\tfinal Display display = ((WindowManager)app.getService().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\r\n\t\tdisplay.getMetrics(metrics);\r\n\r\n\t\treturn new AndroidDisplayMode(metrics.widthPixels, metrics.heightPixels, 0, 0);\r\n\t}","id":85628,"modified_method":"@Override\r\n\tpublic DisplayMode getDesktopDisplayMode () {\r\n\t\tDisplayMetrics metrics = new DisplayMetrics();\r\n\t\tapp.getWindowManager().getDefaultDisplay().getMetrics(metrics);\r\n\t\treturn new AndroidDisplayMode(metrics.widthPixels, metrics.heightPixels, 0, 0);\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"private GLBaseSurfaceViewLW createGLSurfaceView (AndroidLiveWallpaper app, boolean useGL2,\r\n\t\tResolutionStrategy resolutionStrategy) {\r\n\t\tEGLConfigChooser configChooser = getEglConfigChooser();\r\n\r\n\t\tif (useGL2 && checkGL20()) {\r\n\t\t\tGLSurfaceView20LW view = new GLSurfaceView20LW(app.getEngine(), resolutionStrategy);\r\n\t\t\tif (configChooser != null) \r\n\t\t\t\tview.setEGLConfigChooser(configChooser);\r\n\t\t\telse\r\n\t\t\t\tview.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);\r\n\t\t\tview.setRenderer(this);\r\n\t\t\treturn view;\r\n\t\t} else {\r\n\t\t\t//GL1\r\n\t\t\tconfig.useGL20 = false;\r\n\t\t\tconfigChooser = getEglConfigChooser();\r\n\r\n\t\t\tGLBaseSurfaceViewLW view = new DefaultGLSurfaceViewLW(app.getEngine(), resolutionStrategy);\r\n\t\t\tif (configChooser != null) \r\n\t\t\t\tview.setEGLConfigChooser(configChooser);\r\n\t\t\telse\r\n\t\t\t\tview.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);\r\n\r\n\t\t\tview.setRenderer(this);\r\n\t\t\treturn view;\r\n\t\t}\r\n\t}","id":85629,"modified_method":"private View createGLSurfaceView (Context context, boolean useGL2, final ResolutionStrategy resolutionStrategy) {\r\n\t\tEGLConfigChooser configChooser = getEglConfigChooser();\r\n\r\n\t\tif (useGL2 && checkGL20()) {\r\n\t\t\tGLSurfaceView20 view = new GLSurfaceView20(context, resolutionStrategy) {\r\n\t\t\t\t// -> specific for live wallpapers\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic SurfaceHolder getHolder () {\r\n\t\t\t\t\treturn getSurfaceHolder();\r\n\t\t\t\t}\r\n\t\t\t\t// <- specific for live wallpapers\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (configChooser != null)\r\n\t\t\t\tview.setEGLConfigChooser(configChooser);\r\n\t\t\telse\r\n\t\t\t\tview.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);\r\n\t\t\tview.setRenderer(this);\r\n\t\t\treturn view;\r\n\t\t} else {\r\n\t\t\tconfig.useGL20 = false;\r\n\t\t\tconfigChooser = getEglConfigChooser();\r\n\t\t\tint sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);\r\n\r\n\t\t\tif (sdkVersion >= 11) {\r\n\t\t\t\tGLSurfaceView view = new GLSurfaceView(context) {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tprotected void onMeasure (int widthMeasureSpec, int heightMeasureSpec) {\r\n\t\t\t\t\t\tResolutionStrategy.MeasuredDimension measures = resolutionStrategy.calcMeasures(widthMeasureSpec,\r\n\t\t\t\t\t\t\theightMeasureSpec);\r\n\t\t\t\t\t\tsetMeasuredDimension(measures.width, measures.height);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// -> specific for live wallpapers\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic SurfaceHolder getHolder () {\r\n\t\t\t\t\t\treturn getSurfaceHolder();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// <- specific for live wallpapers\r\n\t\t\t\t};\r\n\t\t\t\tif (configChooser != null)\r\n\t\t\t\t\tview.setEGLConfigChooser(configChooser);\r\n\t\t\t\telse\r\n\t\t\t\t\tview.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);\r\n\t\t\t\tview.setRenderer(this);\r\n\t\t\t\treturn view;\r\n\t\t\t} else {\r\n\t\t\t\tGLSurfaceViewCupcake view = new GLSurfaceViewCupcake(context, resolutionStrategy) {\r\n\t\t\t\t\t// -> specific for live wallpapers\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic SurfaceHolder getHolder () {\r\n\t\t\t\t\t\treturn getSurfaceHolder();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// <- specific for live wallpapers\r\n\t\t\t\t};\r\n\t\t\t\tif (configChooser != null)\r\n\t\t\t\t\tview.setEGLConfigChooser(configChooser);\r\n\t\t\t\telse\r\n\t\t\t\t\tview.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);\r\n\t\t\t\tview.setRenderer(this);\r\n\t\t\t\treturn view;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic boolean isGL11Available () {\r\n\t\treturn gl11 != null;\r\n\t}","id":85630,"modified_method":"/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic boolean isGL11Available () {\r\n\t\treturn gl11 != null;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void updatePpi () {\r\n\t\tDisplayMetrics metrics = new DisplayMetrics();\r\n\r\n\t\tfinal Display display = ((WindowManager)app.getService().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\r\n\t\tdisplay.getMetrics(metrics);\r\n\r\n\t\tppiX = metrics.xdpi;\r\n\t\tppiY = metrics.ydpi;\r\n\t\tppcX = metrics.xdpi / 2.54f;\r\n\t\tppcY = metrics.ydpi / 2.54f;\r\n\t\tdensity = metrics.density;\r\n\t}","id":85631,"modified_method":"private void updatePpi () {\r\n\t\tDisplayMetrics metrics = new DisplayMetrics();\r\n\r\n\t\t// jw: changed\r\n\t\tapp.getWindowManager().getDefaultDisplay().getMetrics(metrics);\r\n\t\t//final Display display = ((WindowManager)app.getService().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\r\n\t\t//display.getMetrics(metrics);\r\n\r\n\t\tppiX = metrics.xdpi;\r\n\t\tppiY = metrics.ydpi;\r\n\t\tppcX = metrics.xdpi / 2.54f;\r\n\t\tppcY = metrics.ydpi / 2.54f;\r\n\t\tdensity = metrics.density;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** This instantiates the GL10, GL11 and GL20 instances. Includes the check for certain devices that pretend to support GL11 but\r\n\t * fuck up vertex buffer objects. This includes the pixelflinger which segfaults when buffers are deleted as well as the\r\n\t * Motorola CLIQ and the Samsung Behold II.\r\n\t * \r\n\t * @param gl */\r\n\tprivate void setupGL (javax.microedition.khronos.opengles.GL10 gl) {\r\n\t\tif (gl10 != null || gl20 != null) return;\r\n\r\n\t\tboolean isGL20 = checkGL20();\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"GL20: \" + isGL20);\r\n\r\n\t\tif (view instanceof GLSurfaceView20LW) {\r\n\t\t\tgl20 = new AndroidGL20();\r\n\t\t\tthis.gl = gl20;\r\n\t\t} else {\r\n\t\t\tgl10 = new AndroidGL10(gl);\r\n\t\t\tthis.gl = gl10;\r\n\t\t\tif (gl instanceof javax.microedition.khronos.opengles.GL11) {\r\n\t\t\t\tString renderer = gl.glGetString(GL10.GL_RENDERER);\r\n\t\t\t\tif(renderer != null) {\r\n\t\t\t\t\tif (!renderer.toLowerCase().contains(\"pixelflinger\")\r\n\t\t\t\t\t\t&& !(android.os.Build.MODEL.equals(\"MB200\") || android.os.Build.MODEL.equals(\"MB220\") || android.os.Build.MODEL\r\n\t\t\t\t\t\t\t.contains(\"Behold\"))) {\r\n\t\t\t\t\t\tgl11 = new AndroidGL11((javax.microedition.khronos.opengles.GL11)gl);\r\n\t\t\t\t\t\tgl10 = gl11;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.glu = new AndroidGLU();\r\n\r\n\t\tGdx.gl = this.gl;\r\n\t\tGdx.gl10 = gl10;\r\n\t\tGdx.gl11 = gl11;\r\n\t\tGdx.gl20 = gl20;\r\n\t\tGdx.glu = glu;\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL renderer: \" + gl.glGetString(GL10.GL_RENDERER));\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL vendor: \" + gl.glGetString(GL10.GL_VENDOR));\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL version: \" + gl.glGetString(GL10.GL_VERSION));\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL extensions: \" + gl.glGetString(GL10.GL_EXTENSIONS));\r\n\t}","id":85632,"modified_method":"/** This instantiates the GL10, GL11 and GL20 instances. Includes the check for certain devices that pretend to support GL11 but\r\n\t * fuck up vertex buffer objects. This includes the pixelflinger which segfaults when buffers are deleted as well as the\r\n\t * Motorola CLIQ and the Samsung Behold II.\r\n\t * \r\n\t * @param gl */\r\n\tprivate void setupGL (javax.microedition.khronos.opengles.GL10 gl) {\r\n\t\tif (gl10 != null || gl20 != null) return;\r\n\r\n\t\t// jw: disabled\r\n\t\t//boolean isGL20 = checkGL20();\r\n\t\t//Gdx.app.log(\"AndroidGraphics\", \"GL20: \" + isGL20);\r\n\r\n\t\t// jw: changed\r\n\t\t//if (view instanceof GLSurfaceView20LW) {\r\n\t\tif (view instanceof GLSurfaceView20) {\r\n\t\t\tgl20 = new AndroidGL20();\r\n\t\t\tthis.gl = gl20;\r\n\t\t} else {\r\n\t\t\tgl10 = new AndroidGL10(gl);\r\n\t\t\tthis.gl = gl10;\r\n\t\t\tif (gl instanceof javax.microedition.khronos.opengles.GL11) {\r\n\t\t\t\tString renderer = gl.glGetString(GL10.GL_RENDERER);\r\n\t\t\t\tif (renderer != null) { // silly GT-I7500\r\n\t\t\t\t\tif (!renderer.toLowerCase().contains(\"pixelflinger\")\r\n\t\t\t\t\t\t&& !(android.os.Build.MODEL.equals(\"MB200\") || android.os.Build.MODEL.equals(\"MB220\") || android.os.Build.MODEL\r\n\t\t\t\t\t\t\t.contains(\"Behold\"))) {\r\n\t\t\t\t\t\tgl11 = new AndroidGL11((javax.microedition.khronos.opengles.GL11)gl);\r\n\t\t\t\t\t\tgl10 = gl11;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.glu = new AndroidGLU();\r\n\r\n\t\tGdx.gl = this.gl;\r\n\t\tGdx.gl10 = gl10;\r\n\t\tGdx.gl11 = gl11;\r\n\t\tGdx.gl20 = gl20;\r\n\t\tGdx.glu = glu;\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL renderer: \" + gl.glGetString(GL10.GL_RENDERER));\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL vendor: \" + gl.glGetString(GL10.GL_VENDOR));\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL version: \" + gl.glGetString(GL10.GL_VERSION));\r\n\t\tGdx.app.log(\"AndroidGraphics\", \"OGL extensions: \" + gl.glGetString(GL10.GL_EXTENSIONS));\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void onSurfaceCreated (javax.microedition.khronos.opengles.GL10 gl, EGLConfig config) {\r\n\t\tsetupGL(gl);\r\n\t\tlogConfig(config);\r\n\t\tupdatePpi();\r\n\r\n\t\tMesh.invalidateAllMeshes(app);\r\n\t\tTexture.invalidateAllTextures(app);\r\n\t\tShaderProgram.invalidateAllShaderPrograms(app);\r\n\t\tFrameBuffer.invalidateAllFrameBuffers(app);\r\n\r\n\t\tfinal Display display = ((WindowManager)app.getService().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\r\n\r\n\t\tthis.width = display.getWidth();\r\n\t\tthis.height = display.getHeight();\r\n\t\tmean = new WindowedMean(5);\r\n\t\tthis.lastFrameTime = System.nanoTime();\r\n\r\n\t\tgl.glViewport(0, 0, this.width, this.height);\r\n\r\n\t\tif (created == false) {\r\n\t\t\tapp.getListener().create();\r\n\t\t\tcreated = true;\r\n\t\t\tsynchronized (this) {\r\n\t\t\t\trunning = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":85633,"modified_method":"@Override\r\n\tpublic void onSurfaceCreated (javax.microedition.khronos.opengles.GL10 gl, EGLConfig config) {\r\n\t\teglContext = ((EGL10)EGLContext.getEGL()).eglGetCurrentContext();\t// jw: added\r\n\t\tsetupGL(gl);\r\n\t\tlogConfig(config);\r\n\t\tupdatePpi();\r\n\r\n\t\tMesh.invalidateAllMeshes(app);\r\n\t\tTexture.invalidateAllTextures(app);\r\n\t\tShaderProgram.invalidateAllShaderPrograms(app);\r\n\t\tFrameBuffer.invalidateAllFrameBuffers(app);\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", Mesh.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", Texture.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", ShaderProgram.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", FrameBuffer.getManagedStatus());\r\n\t\t\r\n\t\tDisplay display = app.getWindowManager().getDefaultDisplay();\r\n\t\tthis.width = display.getWidth();\r\n\t\tthis.height = display.getHeight();\r\n\t\tmean = new WindowedMean(5);\r\n\t\tthis.lastFrameTime = System.nanoTime();\r\n\r\n\t\tgl.glViewport(0, 0, this.width, this.height);\r\n\r\n\t\t// jw: moved to onSurfaceChanged (as in AndroidGraphics class)\r\n\t\t/*if (created == false) {\r\n\t\t\tapp.getListener().create();\r\n\t\t\tcreated = true;\r\n\t\t\tsynchronized (this) {\r\n\t\t\t\trunning = true;\r\n\t\t\t}\r\n\t\t}*/\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void requestRendering () {\r\n\t\tif (view != null) {\r\n\t\t\tview.requestRender();\r\n\t\t}\r\n\r\n\t}","id":85634,"modified_method":"@Override\r\n\tpublic void requestRendering () {\r\n\t\tif (view != null) {\r\n\t\t\t// jw: changed\r\n\t\t\t//view.requestRender();\r\n\t\t\tif (view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)view).requestRender();\r\n\t\t\telse if (view instanceof GLSurfaceView) ((GLSurfaceView)view).requestRender();\r\n\t\t\telse throw new RuntimeException(\"unimplemented\");\r\n\t\t}\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic GL10 getGL10 () {\r\n\t\treturn gl10;\r\n\t}","id":85635,"modified_method":"/** {@inheritDoc} */\r\n\t@Override\r\n\tpublic GL10 getGL10 () {\r\n\t\treturn gl10;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic DisplayMode[] getDisplayModes () {\r\n\t\treturn new DisplayMode[0];\r\n\t}","id":85636,"modified_method":"@Override\r\n\tpublic DisplayMode[] getDisplayModes () {\r\n\t\treturn new DisplayMode[] {getDesktopDisplayMode()};\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void onDestroy() {\r\n\t\tgraphics.clearManagedCaches();\r\n\t\t// graphics.destroy();\r\n\t}","id":85637,"modified_method":"public void onDestroy() {\r\n\r\n\t\t// jw: do not call this method after onPaused had finished - it needs live gl GLThread and gl context, otherwise it will cause of deadlock\r\n\t\tif (graphics != null) {\r\n\t\t\tgraphics.clearManagedCaches();\r\n\t\t\tgraphics.destroy();\r\n\t\t}\r\n\t\t\r\n\t\t/*\r\n\t\t// jw: my earlier solution there, but it was never called, it should be called when GLThread is alive (in app.onPause -> but in wallpaper it is not clear if onPause invocation is the last one before shutdown)\r\n\t\t//graphics.clearManagedCaches();\r\n\t\t//graphics.destroy();\r\n\t\t\r\n\t\t// jw: new solution:\r\n\t\tif (graphics != null && graphics.view != null)\r\n\t\t{\r\n\t\t\t// do not invoke it there it was already invoked in AndroidLiveWallpaperService.onDestroy or onDeepPauseApplication\r\n\t\t\t//graphics.clearManagedCaches();\r\n\t\t\t\r\n\t\t\t//graphics.destroy();\t// will block application because GLBaseSurfaceViewLW.GLThread is stopped/paused already\r\n\t\t\t//graphics.requestRendering();  // it doesn't revive GLThread\r\n\t\t\t\r\n\t\t\t// note: graphics.destroy needs living GLThread to process destroying\r\n\t\t\tgraphics.view.onDestroy();\r\n\t\t}\r\n\t\t*/\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void onPause() {\r\n\t\tgraphics.pause();\r\n\t\tif (audio != null) audio.pause();\r\n\t\tinput.unregisterSensorListeners();\r\n\t}","id":85638,"modified_method":"public void onPause() {\r\n\t\tgraphics.pause();\r\n\t\t//if (audio != null) audio.pause();\t// jw: moved to AndroidGraphicsLiveWallpaper.onFrameRender\r\n\t\tinput.unregisterSensorListeners();\r\n\t\t\r\n\t\t// jw: moved from AndroidApplication\r\n\t\tif (graphics != null && graphics.view != null) {\r\n\t\t\tif (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)graphics.view).onPause();\r\n\t\t\telse if (graphics.view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)graphics.view).onPause();\r\n\t\t\telse throw new RuntimeException(\"unimplemented\");\r\n\t\t}\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public WallpaperService getService() {\r\n\t\treturn service;\r\n\t}","id":85639,"modified_method":"public AndroidLiveWallpaperService getService() {\r\n\t\treturn service;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void onResume() {\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\r\n\t\t((AndroidInput)getInput()).registerSensorListeners();\r\n\t\t\r\n\t\tif (audio != null) audio.resume();\t\t\r\n\t\tif (!firstResume)\r\n\t\t\tgraphics.resume();\r\n\t\telse\r\n\t\t\tfirstResume = false;\r\n\t}","id":85640,"modified_method":"public void onResume() {\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\r\n\t\t((AndroidInput)getInput()).registerSensorListeners();\r\n\t\t\r\n\t\t//if (audio != null) audio.resume();\t// jw: moved to AndroidGraphicsLiveWallpaper.onFrameRender\r\n\t\tif (!firstResume)\r\n\t\t{\r\n\t\t\t// jw: moved from AndroidApplication class\r\n\t\t\tif (graphics != null && graphics.view != null) {\r\n\t\t\t\tif (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)graphics.view).onResume();\r\n\t\t\t\telse if (graphics.view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)graphics.view).onResume();\r\n\t\t\t\telse throw new RuntimeException(\"unimplemented\");\r\n\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\tgraphics.resume();\r\n\t\t}\r\n\t\telse\r\n\t\t\tfirstResume = false;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void initialize(ApplicationListener listener, AndroidApplicationConfiguration config) {\r\n\t\tgraphics = new AndroidGraphicsLiveWallpaper(this, config, config.resolutionStrategy==null?new FillResolutionStrategy():config.resolutionStrategy);\r\n\t\tinput = AndroidInputFactory.newAndroidInput(this, this.getService(), null, config);\r\n\t\taudio = new AndroidAudio(this.getService(), config);\r\n\t\tfiles = new AndroidFiles(this.getService().getAssets(), this.getService().getFilesDir().getAbsolutePath());\r\n\t\tthis.listener = listener;\r\n\t\t\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t}","id":85641,"modified_method":"public void initialize(ApplicationListener listener, AndroidApplicationConfiguration config) {\r\n\t\tgraphics = new AndroidGraphicsLiveWallpaper(this, config, config.resolutionStrategy==null?new FillResolutionStrategy():config.resolutionStrategy);\r\n\t\t//input = new AndroidInput(this, this.getService(), null, config);\r\n\t\tinput = AndroidInputFactory.newAndroidInput(this, this.getService(), graphics.view, config);\r\n\t\taudio = new AndroidAudio(this.getService(), config);\r\n\t\t\r\n\t\t// jw: added initialization of android local storage: /data/data/<app package>/files/\r\n\t\tfiles = new AndroidFiles(this.getService().getAssets(), this.getService().getFilesDir().getAbsolutePath());\r\n\t\t\r\n\t\tthis.listener = listener;\r\n\t\t\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public AndroidLiveWallpaper(WallpaperService service, Engine engine) {\r\n\t\tthis.service = service;\r\n\t\tthis.engine = engine;\r\n\t}","id":85642,"modified_method":"public AndroidLiveWallpaper(AndroidLiveWallpaperService service) {\r\n\t\tthis.service = service;\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onTouchEvent (MotionEvent event) {\r\n\t\t\tapp.input.onTouch(null, event);\r\n\t\t}","id":85643,"modified_method":"@Override\r\n\t\tpublic void onTouchEvent (MotionEvent event) {\r\n\t\t\tif (linkedEngine == this) {\r\n\t\t\t\tapp.input.onTouch(null, event);\r\n\t\t\t}\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void onPause () {\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG) Log.d(AndroidLiveWallpaperService.this.TAG, \" > onPause() \" + hashCode() + \", running: \" + runningEngines);\r\n\t\t\tapp.onPause();\r\n\t\t\tview.onPause();\r\n\t\t}","id":85644,"modified_method":"public void onPause () {\r\n\t\t\tvisibleEngines --;\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onPause() \" + hashCode() + \", running: \" + engines + \", linked: \" + (linkedEngine == this) + \", visible: \" + visibleEngines);\r\n\t\r\n\t\t\tif (linkedEngine != null) {\r\n\t\t\t\tif (visibleEngines == 0)\r\n\t\t\t\t\tapp.onPause();\r\n\t\r\n\t\t\t\t//if (linkedEngine == this)\r\n\t\t\t\t//\tapp.graphics.view.surfaceDestroyed(getSurfaceHolder());\r\n\t\t\t}\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onVisibilityChanged (final boolean visible) {\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG)\r\n\t\t\t\tLog.d(AndroidLiveWallpaperService.this.TAG, \" > onVisibilityChanged(\" + visible + \") \" + hashCode());\r\n\t\t\tif (visible) {\r\n\t\t\t\tonResume();\r\n\t\t\t} else {\r\n\t\t\t\tonPause();\r\n\t\t\t}\r\n\r\n\t\t\tsuper.onVisibilityChanged(visible);\r\n\t\t}","id":85645,"modified_method":"/**\r\n\t\t * Called to inform you of the wallpaper becoming visible or hidden. It is very important that \r\n\t\t * a wallpaper only use CPU while it is visible..\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void onVisibilityChanged (final boolean visible) {\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onVisibilityChanged(\" + visible + \") \" + hashCode());\r\n\t\t\tsuper.onVisibilityChanged(visible);\r\n\t\t\t\r\n\t\t\tnotifyVisibilityChanged(visible);\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void onDestroy () {\r\n\t\tif (DEBUG) Log.d(TAG, \" > LibdgxWallpaperService - onDestroy()\");\r\n\t\tsuper.onDestroy();\r\n\t}","id":85646,"modified_method":"/**\r\n\t * Service is dying\r\n\t * You have to finish execution off all living threads there or short after there, \r\n\t * besides the new wallpaper service wouldn't be able to start.\r\n\t */\r\n\t@Override\r\n\tpublic void onDestroy () {\r\n\t\tif (DEBUG) Log.d(TAG, \" > AndroidLiveWallpaperService - onDestroy()\");\r\n\t\tsuper.onDestroy();\t// can call engine.onSurfaceDestroyed, must be before bellow code:\r\n\t\t\r\n\t\tif (app != null)\r\n\t\t{\r\n\t\t\t// it is too late co call app.onDestroy\r\n\t\t\tif (app.graphics != null)\r\n\t\t\t{\r\n\t\t\t\t// app.graphics.clearManagedCaches(); already called in onDeepPauseApplication\r\n\t\t\t\tif (app.graphics.view != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (app.graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)app.graphics.view).onResume();\r\n\t\t\t\t\telse if (app.graphics.view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)app.graphics.view).onResume();\r\n\t\t\t\t\telse throw new RuntimeException(\"unimplemented\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tapp = null;\r\n\t\t\tview = null;\r\n\t\t}\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onDestroy () {\r\n\t\t\trunningEngines--;\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG) Log.d(AndroidLiveWallpaperService.this.TAG, \" > onDestroy() \" + hashCode() + \", running: \" + runningEngines);\r\n\t\t\tview.onDestroy();\r\n\t\t\tif (listener != null)\r\n\t\t\t\tlistener.dispose();\r\n\t\t\tapp.onDestroy();\r\n\t\t\tsuper.onDestroy();\r\n\t\t}","id":85647,"modified_method":"@Override\r\n\t\tpublic void onDestroy () {\r\n\t\t\tsuper.onDestroy();\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic Engine onCreateEngine () {\r\n\t\treturn new AndroidWallpaperEngine();\r\n\t}","id":85648,"modified_method":"/**\r\n\t * One of wallpaper engines is starting. \r\n\t * Do not override this method, service manages them internally.\r\n\t */\r\n\t@Override\r\n\tpublic Engine onCreateEngine () {\r\n\t\tif (DEBUG) Log.d(TAG, \" > AndroidLiveWallpaperService - onCreateEngine()\");\r\n\t\t\r\n\t\treturn new AndroidWallpaperEngine();\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onOffsetsChanged (final float xOffset, final float yOffset, final float xOffsetStep, final float yOffsetStep, final int xPixelOffset,\r\n\t\t\tfinal int yPixelOffset) {\r\n\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG)\r\n\t\t\t\tLog.d(AndroidLiveWallpaperService.this.TAG, \" > onOffsetChanged(\" + xOffset + \" \" + yOffset + \" \" + xOffsetStep + \" \"\r\n\t\t\t\t\t+ yOffsetStep + \" \" + xPixelOffset + \" \" + yPixelOffset + \") \" + hashCode());\r\n\r\n\t\t\tapp.postRunnable(new Runnable() {\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void run () {\r\n\t\t\t\t\tAndroidLiveWallpaperService.this.offsetChange(listener, xOffset, yOffset, xOffsetStep, yOffsetStep, xPixelOffset, yPixelOffset);\t\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tsuper.onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixelOffset, yPixelOffset);\r\n\t\t}","id":85649,"modified_method":"@Override\r\n\t\tpublic void onOffsetsChanged (final float xOffset, final float yOffset, final float xOffsetStep, final float yOffsetStep, final int xPixelOffset,\r\n\t\t\tfinal int yPixelOffset) {\r\n\r\n\t\t\t// it spawns too frequent on some devices - its annoying!\r\n\t\t\t//if (DEBUG)\r\n\t\t\t//\tLog.d(TAG, \" > AndroidWallpaperEngine - onOffsetChanged(\" + xOffset + \" \" + yOffset + \" \" + xOffsetStep + \" \"\r\n\t\t\t//\t\t+ yOffsetStep + \" \" + xPixelOffset + \" \" + yPixelOffset + \") \" + hashCode() + \", linkedApp: \" + (linkedApp != null));\r\n\r\n\t\t\tthis.offsetsConsumed = false;\r\n\t\t\tthis.xOffset = xOffset;\r\n\t\t\tthis.yOffset = yOffset;\r\n\t\t\tthis.xOffsetStep = xOffsetStep;\r\n\t\t\tthis.yOffsetStep = yOffsetStep;\r\n\t\t\tthis.xPixelOffset = xPixelOffset;\r\n\t\t\tthis.yPixelOffset = yPixelOffset;\r\n\t\t\t\r\n\t\t\t// can fail if linkedApp == null, so we repeat it in Engine.onResume\r\n\t\t\tnotifyOffsetsChanged();\r\n\t\t\t\r\n\t\t\tsuper.onOffsetsChanged(xOffset, yOffset, xOffsetStep, yOffsetStep, xPixelOffset, yPixelOffset);\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void onResume () {\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG) Log.d(AndroidLiveWallpaperService.this.TAG, \" > onResume() \" + hashCode() + \", running: \" + runningEngines);\r\n\t\t\tapp.onResume();\r\n\t\t\tview.onResume();\r\n\t\t}","id":85650,"modified_method":"public void onResume () {\r\n\t\t\tvisibleEngines ++;\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onResume() \" + hashCode() + \", running: \" + engines + \", linked: \" + (linkedEngine == this) + \", visible: \" + visibleEngines);\r\n\t\t\t\r\n\t\t\tif (linkedEngine != null) {\r\n\t\t\t\tif (linkedEngine != this) {\r\n\t\t\t\t\tsetLinkedEngine(this);\r\n\t\t\t\t\tview.surfaceDestroyed(getSurfaceHolder());\t// force gl surface reload, new instance will be created on current surface holder\r\n\t\t\t\t\tview.surfaceCreated(getSurfaceHolder());\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (visibleEngines == 1)\r\n\t\t\t\t\tapp.onResume();\r\n\t\r\n\t\t\t\tif (waitingSurfaceChangedEvent != null)\r\n\t\t\t\t\twaitingSurfaceChangedEvent.run();\r\n\t\r\n\t\t\t\tnotifyPreviewState();\r\n\t\t\t\tnotifyOffsetsChanged();\r\n\t\t\t}\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onSurfaceCreated (final SurfaceHolder holder) {\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG) Log.d(AndroidLiveWallpaperService.this.TAG, \" > onSurfaceCreated() \" + hashCode() + \", running: \" + runningEngines);\r\n\t\t\tsuper.onSurfaceCreated(holder);\r\n\t\t}","id":85651,"modified_method":"/**\r\n\t\t * Called before surface holder callbacks (ex for GLSurfaceView)!\r\n\t\t * This is called immediately after the surface is first created. Implementations of this should start \r\n\t\t * up whatever rendering code they desire. Note that only one thread can ever draw into a Surface, \r\n\t\t * so you should not draw into the Surface here if your normal rendering will be in another thread.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void onSurfaceCreated (final SurfaceHolder holder) {\r\n\t\t\tengines ++;\r\n\t\t\tsetLinkedEngine(this);\r\n\t\t\t\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onSurfaceCreated() \" + hashCode() + \", running: \" + engines + \", linked: \" + (linkedEngine == this));\r\n\t\t\tsuper.onSurfaceCreated(holder);\r\n\t\r\n\t\t\tif (engines == 1) {\r\n\t\t\t\t// safeguard: recover attributes that could suffered by unexpected surfaceDestroy event\r\n\t\t\t\tvisibleEngines = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (engines == 1 && app == null) {\r\n\t\t\t\tapp = new AndroidLiveWallpaper(AndroidLiveWallpaperService.this);\r\n\t\t\t\t\r\n\t\t\t\tonCreateApplication();\r\n\t\t\t\tif (app.graphics == null)\r\n\t\t\t\t\tthrow new Error(\"You must override 'AndroidLiveWallpaperService.onCreateApplication' method and call 'initialize' from its body.\");\r\n\t\t\t\t\r\n\t\t\t\tview = (SurfaceHolder.Callback)app.graphics.view;\r\n\t\t\t\tthis.getSurfaceHolder().removeCallback(view);\t// we are going to call this events manually\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (engines == 1)\r\n\t\t\t\tview.surfaceCreated(holder);\r\n\t\t\telse {\r\n\t\t\t\tview.surfaceDestroyed(holder);\t// force gl surface reload, new instance will be created on current surface holder\r\n\t\t\t\tview.surfaceCreated(holder);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (waitingSurfaceChangedEvent != null)\r\n\t\t\t\twaitingSurfaceChangedEvent.run();\r\n\t\t\t\r\n\t\t\tnotifyPreviewState();\r\n\t\t\tnotifyOffsetsChanged();\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic Bundle onCommand (final String pAction, final int pX, final int pY, final int pZ, final Bundle pExtras,\r\n\t\t\tfinal boolean pResultRequested) {\r\n\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG)\r\n\t\t\t\tLog.d(TAG, \" > onCommand(\" + pAction + \" \" + pX + \" \" + pY + \" \" + pZ + \" \" + pExtras + \" \"\r\n\t\t\t\t\t+ pResultRequested + \")\");\r\n\r\n\t\t\t// FIXME\r\n//\t\t\tif (pAction.equals(WallpaperManager.COMMAND_TAP)) {\r\n//\t\t\t\tapp.input.onTap(pX, pY);\r\n//\t\t\t} else if (pAction.equals(WallpaperManager.COMMAND_DROP)) {\r\n//\t\t\t\tapp.input.onDrop(pX, pY);\r\n//\t\t\t}\r\n\t\t\treturn super.onCommand(pAction, pX, pY, pZ, pExtras, pResultRequested);\r\n\t\t}","id":85652,"modified_method":"@Override\r\n\t\tpublic Bundle onCommand (final String pAction, final int pX, final int pY, final int pZ, final Bundle pExtras,\r\n\t\t\tfinal boolean pResultRequested) {\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onCommand(\" + pAction + \" \" + pX + \" \" + pY + \" \" + pZ + \" \" + pExtras + \" \" + pResultRequested + \")\" + \", linked: \" + (linkedEngine == this));\r\n\r\n\t\t\t// FIXME\r\n\t\t\t/*if (linkedEngine == this) {\r\n\t\t\t\tif (pAction.equals(WallpaperManager.COMMAND_TAP)) {\r\n\t\t\t\t\t\tlinkedApp.input.onTap(pX, pY);\r\n\t\t\t\t} else if (pAction.equals(WallpaperManager.COMMAND_DROP)) {\r\n\t\t\t\t\t\tlinkedApp.input.onDrop(pX, pY);\r\n\t\t\t\t}\r\n\t\t\t}*/\r\n\t\t\t\r\n\t\t\treturn super.onCommand(pAction, pX, pY, pZ, pExtras, pResultRequested);\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onSurfaceDestroyed (final SurfaceHolder holder) {\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG) Log.d(AndroidLiveWallpaperService.this.TAG, \" > onSurfaceDestroyed() \" + hashCode()  + \", running: \" + runningEngines);\r\n\t\t\tsuper.onSurfaceDestroyed(holder);\r\n\t\t}","id":85653,"modified_method":"/**\r\n\t\t * Called after surface holder callbacks (ex for GLSurfaceView)!\r\n\t\t * This is called immediately before a surface is being destroyed. After returning from this call, \r\n\t\t * you should no longer try to access this surface. If you have a rendering thread that directly \r\n\t\t * accesses the surface, you must ensure that thread is no longer touching the Surface before \r\n\t\t * returning from this function.\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void onSurfaceDestroyed (final SurfaceHolder holder) {\r\n\t\t\tengines --;\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onSurfaceDestroyed() \" + hashCode()  + \", running: \" + engines + \" ,linked: \" + (linkedEngine == this) + \", isVisible: \" + isVisible);\r\n\r\n\t\t\t// application can be in resumed state at this moment if app surface had been lost just after it was created (wallpaper selected too fast from preview mode etc)\r\n\t\t\t// it is too late probably - calling on pause causes deadlock\r\n\t\t\t//notifyVisibilityChanged(false);\r\n\t\t\t\r\n\t\t\t// it is too late to call app.onDispose, just free native resources\r\n\t\t\tif (engines == 0)\r\n\t\t\t\tonDeepPauseApplication();\r\n\t\t\t\r\n\t\t\t// free surface if it belongs to this engine and if it was initialized\r\n\t\t\tif (linkedEngine == this && view != null)\r\n\t\t\t\tview.surfaceDestroyed(holder);\r\n\t\t\t//else\r\n\t\t\t//\tsave surface destroyed state for further processing\r\n\t\t\r\n\t\t\twaitingSurfaceChangedEvent = null;\r\n\t\t\t\r\n\t\t\t// safeguard for other engine callbacks\r\n\t\t\tif (engines == 0)\r\n\t\t\t\tlinkedEngine = null;\r\n\t\t\t\r\n\t\t\tsuper.onSurfaceDestroyed(holder);\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onSurfaceChanged (final SurfaceHolder holder, final int format, final int width, final int height) {\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG)\r\n\t\t\t\tLog.d(AndroidLiveWallpaperService.this.TAG, \" > onSurfaceChanged() \" + isPreview() + \" \" + hashCode() + \", running: \" + runningEngines);\r\n\t\t\tsuper.onSurfaceChanged(holder, format, width, height);\r\n\t\t}","id":85654,"modified_method":"/**\r\n\t\t * This is called immediately after any structural changes (format or size) have been made to the surface. \r\n\t\t * You should at this point update the imagery in the surface. This method is always called at least once, \r\n\t\t * after surfaceCreated(SurfaceHolder).\r\n\t\t */\r\n\t\t@Override\r\n\t\tpublic void onSurfaceChanged (final SurfaceHolder holder, final int format, final int width, final int height) {\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onSurfaceChanged() isPreview: \" + isPreview() + \", \" + hashCode() + \", running: \" + engines + \", linked: \" + (linkedEngine == this));\r\n\t\t\tsuper.onSurfaceChanged(holder, format, width, height);\r\n\t\t\t\r\n\t\t\tif (linkedEngine == this)\r\n\t\t\t\tview.surfaceChanged(holder, format, width, height);\r\n\t\t\telse {\r\n\t\t\t\t// save new surface holder format and call surfaceChanged when this engine will be linked again\r\n\t\t\t\twaitingSurfaceChangedEvent = new Runnable() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\tonSurfaceChanged(holder, format, width, height);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// it shouldn't be required there (as I studied original Android WallpaperService impl)\r\n\t\t\t//notifyPreviewState();\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void onCreate () {\r\n\t\tif (DEBUG) Log.d(TAG, \" > LibdgxWallpaperService - onCreate()\");\r\n\t\tsuper.onCreate();\r\n\t}","id":85655,"modified_method":"/**\r\n\t * Service is starting, libGDX application is shutdown now\r\n\t */\r\n\t@Override\r\n\tpublic void onCreate () {\r\n\t\tif (DEBUG) Log.d(TAG, \" > AndroidLiveWallpaperService - onCreate()\");\r\n\t\tsuper.onCreate();\r\n\t\t\r\n\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\t\tpublic void onCreate (final SurfaceHolder surfaceHolder) {\r\n\t\t\trunningEngines++;\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG) Log.d(TAG, \" > onCreate() \" + hashCode() + \", running: \" + runningEngines);\r\n\t\t\tsuper.onCreate(surfaceHolder);\r\n\t\t\tthis.app = new AndroidLiveWallpaper(AndroidLiveWallpaperService.this, this);\r\n\t\t\tAndroidApplicationConfiguration config = createConfig();\r\n\t\t\tlistener = createListener(isPreview());\r\n\t\t\tthis.app.initialize(listener, config);\r\n\t\t\tthis.view = ((AndroidGraphicsLiveWallpaper)app.getGraphics()).getView();\r\n\r\n\t\t\tif (config.getTouchEventsForLiveWallpaper && Integer.parseInt(android.os.Build.VERSION.SDK) < 9)\r\n\t\t\t\tthis.setTouchEventsEnabled(true);\r\n\t\t}","id":85656,"modified_method":"@Override\r\n\t\tpublic void onCreate (final SurfaceHolder surfaceHolder) {\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine - onCreate() \" + hashCode() + \" running: \" + engines + \", linked: \" + (linkedEngine == this) + \", thread: \" + Thread.currentThread().toString());\r\n\t\t\tsuper.onCreate(surfaceHolder);\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"public AndroidWallpaperEngine () {\r\n\t\t\tif (AndroidLiveWallpaperService.DEBUG) Log.d(AndroidLiveWallpaperService.this.TAG, \" > MyEngine() \" + hashCode());\r\n\t\t}","id":85657,"modified_method":"public AndroidWallpaperEngine () {\r\n\t\t\tif (DEBUG) Log.d(TAG, \" > AndroidWallpaperEngine() \" + hashCode());\r\n\t\t}","commit_id":"5a267035204f2663616d801ed5f2ed799b73fff4","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n\tpublic void onSuccess(FetchResult result, ClientGetter state) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\t// FIXME: Fortify thinks this is double-checked locking. Technically it is, but \n\t\t// since returnBucket is only set to non-null in this method and the constructor is it safe.\n\t\tassert(returnBucket == data || binaryBlob);\n\t\t// FIXME I don't think this is a problem in this case...? (Disk write while locked..)\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\n\t\t\t// completionTime is set here rather than in finish() for two reasons:\n\t\t\t// 1. It must be set inside the lock.\n\t\t\t// 2. It must be set before AllData is sent so it is consistent.\n            completionTime = System.currentTimeMillis();\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = returnBucket.size();\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null);\n\t\ttrySendAllDataMessage(null);\n\t\tfinish();\n\t\tif(client != null)\n\t\t\tclient.notifySuccess(this);\n\t}","id":85658,"modified_method":"@Override\n\tpublic void onSuccess(FetchResult result, ClientGetter state) {\n\t\tLogger.minor(this, \"Succeeded: \"+identifier);\n\t\tBucket data = result.asBucket();\n\t\tsynchronized(this) {\n\t\t\tif(succeeded) {\n\t\t\t\tLogger.error(this, \"onSuccess called twice for \"+this+\" (\"+identifier+ ')');\n\t\t\t\treturn; // We might be called twice; ignore it if so.\n\t\t\t}\n\t\t\tstarted = true;\n\t\t\tif(!binaryBlob)\n\t\t\t\tthis.foundDataMimeType = result.getMimeType();\n\t\t\telse\n\t\t\t\tthis.foundDataMimeType = BinaryBlob.MIME_TYPE;\n\n\t\t\t// completionTime is set here rather than in finish() for two reasons:\n\t\t\t// 1. It must be set inside the lock.\n\t\t\t// 2. It must be set before AllData is sent so it is consistent.\n            completionTime = System.currentTimeMillis();\n\t\t\tprogressPending = null;\n\t\t\tthis.foundDataLength = data.size();\n\t\t\tthis.succeeded = true;\n\t\t\tfinished = true;\n\t\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DIRECT)\n\t\t\t    returnBucketDirect = data;\n\t\t}\n\t\ttrySendDataFoundOrGetFailed(null);\n\t\ttrySendAllDataMessage(null);\n\t\tfinish();\n\t\tif(client != null)\n\t\t\tclient.notifySuccess(this);\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Create one for a global-queued request not made by FCP.\n\t * @throws IdentifierCollisionException\n\t * @throws NotAllowedException\n\t * @throws IOException\n\t */\n\tpublic ClientGet(FCPClient globalClient, FreenetURI uri, boolean dsOnly, boolean ignoreDS,\n\t\t\tboolean filterData, int maxSplitfileRetries, int maxNonSplitfileRetries,\n\t\t\tlong maxOutputLength, short returnType, boolean persistRebootOnly, String identifier, int verbosity,\n\t\t\tshort prioClass, File returnFilename, String charset, boolean writeToClientCache, boolean realTimeFlag, FCPServer server) throws IdentifierCollisionException, NotAllowedException, IOException {\n\t\tsuper(uri, identifier, verbosity, charset, null, globalClient,\n\t\t\t\tprioClass,\n\t\t\t\t(persistRebootOnly ? ClientRequest.PERSIST_REBOOT : ClientRequest.PERSIST_FOREVER), realTimeFlag, null, true);\n\n\t\tfctx = new FetchContext(server.defaultFetchContext, FetchContext.IDENTICAL_MASK);\n\t\tfctx.eventProducer.addEventListener(this);\n\t\tfctx.localRequestOnly = dsOnly;\n\t\tfctx.ignoreStore = ignoreDS;\n\t\tfctx.maxNonSplitfileRetries = maxNonSplitfileRetries;\n\t\tfctx.maxSplitfileBlockRetries = maxSplitfileRetries;\n\t\tfctx.filterData = filterData;\n\t\tfctx.maxOutputLength = maxOutputLength;\n\t\tfctx.maxTempLength = maxOutputLength;\n\t\tfctx.canWriteClientCache = writeToClientCache;\n\t\t// FIXME fctx.ignoreUSKDatehints = ignoreUSKDatehints;\n\t\tBucket ret = null;\n\t\tthis.returnType = returnType;\n\t\tbinaryBlob = false;\n\t\tString extensionCheck = null;\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\tthis.targetFile = returnFilename;\n\t\t\tif(!(server.core.allowDownloadTo(returnFilename)))\n\t\t\t\tthrow new NotAllowedException();\n\t\t\tret = new FileBucket(returnFilename, false, true, false, false, false);\n\t\t\tif(filterData) {\n\t\t\t\tString name = returnFilename.getName();\n\t\t\t\tint idx = name.lastIndexOf('.');\n\t\t\t\tif(idx != -1) {\n\t\t\t\t\tidx++;\n\t\t\t\t\tif(idx != name.length())\n\t\t\t\t\t\textensionCheck = name.substring(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\ttargetFile = null;\n\t\t\tret = new NullBucket();\n\t\t} else {\n\t\t    targetFile = null;\n\t\t    ret = null; // Let the ClientGetter allocate the Bucket later on.\n\t\t}\n\t\treturnBucket = ret;\n\t\t\tgetter = new ClientGetter(this, uri, fctx, priorityClass,\n\t\t\t\t\treturnBucket, null, false, null, extensionCheck);\n\t}","id":85659,"modified_method":"/**\n\t * Create one for a global-queued request not made by FCP.\n\t * @throws IdentifierCollisionException\n\t * @throws NotAllowedException\n\t * @throws IOException\n\t */\n\tpublic ClientGet(FCPClient globalClient, FreenetURI uri, boolean dsOnly, boolean ignoreDS,\n\t\t\tboolean filterData, int maxSplitfileRetries, int maxNonSplitfileRetries,\n\t\t\tlong maxOutputLength, short returnType, boolean persistRebootOnly, String identifier, int verbosity,\n\t\t\tshort prioClass, File returnFilename, String charset, boolean writeToClientCache, boolean realTimeFlag, FCPServer server) throws IdentifierCollisionException, NotAllowedException, IOException {\n\t\tsuper(uri, identifier, verbosity, charset, null, globalClient,\n\t\t\t\tprioClass,\n\t\t\t\t(persistRebootOnly ? ClientRequest.PERSIST_REBOOT : ClientRequest.PERSIST_FOREVER), realTimeFlag, null, true);\n\n\t\tfctx = new FetchContext(server.defaultFetchContext, FetchContext.IDENTICAL_MASK);\n\t\tfctx.eventProducer.addEventListener(this);\n\t\tfctx.localRequestOnly = dsOnly;\n\t\tfctx.ignoreStore = ignoreDS;\n\t\tfctx.maxNonSplitfileRetries = maxNonSplitfileRetries;\n\t\tfctx.maxSplitfileBlockRetries = maxSplitfileRetries;\n\t\tfctx.filterData = filterData;\n\t\tfctx.maxOutputLength = maxOutputLength;\n\t\tfctx.maxTempLength = maxOutputLength;\n\t\tfctx.canWriteClientCache = writeToClientCache;\n\t\t// FIXME fctx.ignoreUSKDatehints = ignoreUSKDatehints;\n\t\tBucket ret = null;\n\t\tthis.returnType = returnType;\n\t\tbinaryBlob = false;\n\t\tString extensionCheck = null;\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\tthis.targetFile = returnFilename;\n\t\t\tif(!(server.core.allowDownloadTo(returnFilename)))\n\t\t\t\tthrow new NotAllowedException();\n\t\t\tret = new FileBucket(returnFilename, false, true, false, false, false);\n\t\t\tif(filterData) {\n\t\t\t\tString name = returnFilename.getName();\n\t\t\t\tint idx = name.lastIndexOf('.');\n\t\t\t\tif(idx != -1) {\n\t\t\t\t\tidx++;\n\t\t\t\t\tif(idx != name.length())\n\t\t\t\t\t\textensionCheck = name.substring(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\ttargetFile = null;\n\t\t\tret = new NullBucket();\n\t\t} else {\n\t\t    targetFile = null;\n\t\t    ret = null; // Let the ClientGetter allocate the Bucket later on.\n\t\t}\n\t\t\tgetter = new ClientGetter(this, uri, fctx, priorityClass,\n\t\t\t\t\tret, null, false, null, extensionCheck);\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tprotected void freeData() {\n\t\tBucket data;\n\t\tsynchronized(this) {\n\t\t\tdata = returnBucket;\n\t\t\treturnBucket = null;\n\t\t}\n\t\tif(data != null) {\n\t\t\tdata.free();\n\t\t}\n\t}","id":85660,"modified_method":"@Override\n\tprotected void freeData() {\n\t\tBucket data;\n\t\tsynchronized(this) {\n\t\t\tdata = returnBucketDirect;\n\t\t\treturnBucketDirect = null;\n\t\t}\n\t\tif(data != null) {\n\t\t\tdata.free();\n\t\t}\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Must be called just after construction, but within a transaction.\n\t * @throws IdentifierCollisionException If the identifier is already in use.\n\t */\n\t@Override\n\tvoid register(boolean noTags) throws IdentifierCollisionException {\n\t\tif(client != null)\n\t\t\tassert(this.persistenceType == client.persistenceType);\n\t\tif(persistenceType != PERSIST_CONNECTION)\n\t\t\ttry {\n\t\t\t\tclient.register(this);\n\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\treturnBucket.free();\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif(persistenceType != PERSIST_CONNECTION && !noTags) {\n\t\t\t\tFCPMessage msg = persistentTagMessage();\n\t\t\t\tclient.queueClientRequestMessage(msg, 0);\n\t\t\t}\n\t}","id":85661,"modified_method":"/**\n\t * Must be called just after construction, but within a transaction.\n\t * @throws IdentifierCollisionException If the identifier is already in use.\n\t */\n\t@Override\n\tvoid register(boolean noTags) throws IdentifierCollisionException {\n\t\tif(client != null)\n\t\t\tassert(this.persistenceType == client.persistenceType);\n\t\tif(persistenceType != PERSIST_CONNECTION)\n\t\t\ttry {\n\t\t\t\tclient.register(this);\n\t\t\t} catch (IdentifierCollisionException e) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tif(persistenceType != PERSIST_CONNECTION && !noTags) {\n\t\t\t\tFCPMessage msg = persistentTagMessage();\n\t\t\t\tclient.queueClientRequestMessage(msg, 0);\n\t\t\t}\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"private synchronized AllDataMessage getAllDataMessage() {\n\t    if(returnType != ClientGetMessage.RETURN_TYPE_DIRECT)\n\t        return null;\n\t    AllDataMessage msg = new AllDataMessage(returnBucket, identifier, global, startupTime, \n\t            completionTime, foundDataMimeType);\n        if(persistenceType == PERSIST_CONNECTION)\n            msg.setFreeOnSent();\n        return msg;\n\t}","id":85662,"modified_method":"private synchronized AllDataMessage getAllDataMessage() {\n\t    if(returnType != ClientGetMessage.RETURN_TYPE_DIRECT)\n\t        return null;\n\t    AllDataMessage msg = new AllDataMessage(returnBucketDirect, identifier, global, startupTime, \n\t            completionTime, foundDataMimeType);\n        if(persistenceType == PERSIST_CONNECTION)\n            msg.setFreeOnSent();\n        return msg;\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void onResume(ClientContext context) {\n        super.onResume(context);\n        if(getter == null) {\n            if(returnBucket != null) returnBucket.onResume(context);\n        } // Otherwise the returnBucket is the ClientGetter's responsibility.\n    }","id":85663,"modified_method":"@Override\n    public void onResume(ClientContext context) {\n        super.onResume(context);\n        if(returnBucketDirect != null) returnBucketDirect.onResume(context);\n    }","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Returns the {@link Bucket} that contains the downloaded data.\n\t *\n\t * @return The data in a {@link Bucket}, or <code>null<\/code> if this\n\t *         isn&rsquo;t applicable\n\t */\n\tpublic Bucket getBucket() {\n\t\tsynchronized(this) {\n\t\t    return returnBucket;\n\t\t}\n\t}","id":85664,"modified_method":"/**\n\t * Returns the {@link Bucket} that contains the downloaded data.\n\t *\n\t * @return The data in a {@link Bucket}, or <code>null<\/code> if this\n\t *         isn&rsquo;t applicable\n\t */\n\tpublic Bucket getBucket() {\n\t    if(returnType == ClientGetMessage.RETURN_TYPE_DIRECT) {\n\t        synchronized(this) {\n\t            return returnBucketDirect;\n\t        }\n\t    } else if(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t        return new FileBucket(targetFile, true, false, false, false, false);\n\t    } else {\n\t        return null;\n\t    }\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"public Bucket getFinalBucket() {\n\t\tsynchronized(this) {\n\t\t\tif(!finished) return null;\n\t\t\tif(!succeeded) return null;\n\t\t\treturn returnBucket;\n\t\t}\n\t}","id":85665,"modified_method":"public Bucket getFinalBucket() {\n\t\tsynchronized(this) {\n\t\t\tif(!finished) return null;\n\t\t\tif(!succeeded) return null;\n\t\t\treturn returnBucketDirect;\n\t\t}\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"protected ClientGet() {\n\t    // For serialization.\n\t    fctx = null;\n\t    getter = null;\n\t    returnType = 0;\n\t    targetFile = null;\n\t    returnBucket = null;\n\t    binaryBlob = false;\n\t}","id":85666,"modified_method":"protected ClientGet() {\n\t    // For serialization.\n\t    fctx = null;\n\t    getter = null;\n\t    returnType = 0;\n\t    targetFile = null;\n\t    binaryBlob = false;\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"public ClientGet(FCPConnectionHandler handler, ClientGetMessage message, FCPServer server) throws IdentifierCollisionException, MessageInvalidException {\n\t\tsuper(message.uri, message.identifier, message.verbosity, message.charset, handler,\n\t\t\t\tmessage.priorityClass, message.persistenceType, message.realTimeFlag, message.clientToken, message.global);\n\t\t// Create a Fetcher directly in order to get more fine-grained control,\n\t\t// since the client may override a few context elements.\n\t\tfctx = new FetchContext(server.defaultFetchContext, FetchContext.IDENTICAL_MASK);\n\t\tfctx.eventProducer.addEventListener(this);\n\t\t// ignoreDS\n\t\tfctx.localRequestOnly = message.dsOnly;\n\t\tfctx.ignoreStore = message.ignoreDS;\n\t\tfctx.maxNonSplitfileRetries = message.maxRetries;\n\t\tfctx.maxSplitfileBlockRetries = message.maxRetries;\n\t\t// FIXME do something with verbosity !!\n\t\t// Has already been checked\n\t\tfctx.maxOutputLength = message.maxSize;\n\t\tfctx.maxTempLength = message.maxTempSize;\n\t\tfctx.canWriteClientCache = message.writeToClientCache;\n\t\tfctx.filterData = message.filterData;\n\t\tfctx.ignoreUSKDatehints = message.ignoreUSKDatehints;\n\n\t\tif(message.allowedMIMETypes != null) {\n\t\t\tfctx.allowedMIMETypes = new HashSet<String>();\n\t\t\tfor(String mime : message.allowedMIMETypes)\n\t\t\t\tfctx.allowedMIMETypes.add(mime);\n\t\t}\n\n\t\tthis.returnType = message.returnType;\n\t\tthis.binaryBlob = message.binaryBlob;\n\t\tBucket ret = null;\n\t\tString extensionCheck = null;\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\tthis.targetFile = message.diskFile;\n\t\t\tif(!server.core.allowDownloadTo(targetFile))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ACCESS_DENIED, \"Not allowed to download to \"+targetFile, identifier, global);\n\t\t\telse if(!(handler.allowDDAFrom(targetFile, true)))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.DIRECT_DISK_ACCESS_DENIED, \"Not allowed to download to \" + targetFile + \". You might need to do a \" + TestDDARequestMessage.NAME + \" first.\", identifier, global);\n\t\t\tret = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\tif(fctx.filterData) {\n\t\t\t\tString name = targetFile.getName();\n\t\t\t\tint idx = name.lastIndexOf('.');\n\t\t\t\tif(idx != -1) {\n\t\t\t\t\tidx++;\n\t\t\t\t\tif(idx != name.length())\n\t\t\t\t\t\textensionCheck = name.substring(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\ttargetFile = null;\n\t\t\tret = new NullBucket();\n        } else {\n            targetFile = null;\n            ret = null; // Let the ClientGetter allocate the Bucket later on.\n\t\t}\n\t\tif(ret == null)\n\t\t\tLogger.error(this, \"Impossible: ret = null in FCP constructor for \"+this, new Exception(\"debug\"));\n\t\treturnBucket = ret;\n\t\t\tgetter = new ClientGetter(this,\n\t\t\t\t\turi, fctx, priorityClass,\n\t\t\t\t\tbinaryBlob ? new NullBucket() : returnBucket, binaryBlob ? new BinaryBlobWriter(returnBucket) : null, false, message.getInitialMetadata(), extensionCheck);\n\t}","id":85667,"modified_method":"public ClientGet(FCPConnectionHandler handler, ClientGetMessage message, FCPServer server) throws IdentifierCollisionException, MessageInvalidException {\n\t\tsuper(message.uri, message.identifier, message.verbosity, message.charset, handler,\n\t\t\t\tmessage.priorityClass, message.persistenceType, message.realTimeFlag, message.clientToken, message.global);\n\t\t// Create a Fetcher directly in order to get more fine-grained control,\n\t\t// since the client may override a few context elements.\n\t\tfctx = new FetchContext(server.defaultFetchContext, FetchContext.IDENTICAL_MASK);\n\t\tfctx.eventProducer.addEventListener(this);\n\t\t// ignoreDS\n\t\tfctx.localRequestOnly = message.dsOnly;\n\t\tfctx.ignoreStore = message.ignoreDS;\n\t\tfctx.maxNonSplitfileRetries = message.maxRetries;\n\t\tfctx.maxSplitfileBlockRetries = message.maxRetries;\n\t\t// FIXME do something with verbosity !!\n\t\t// Has already been checked\n\t\tfctx.maxOutputLength = message.maxSize;\n\t\tfctx.maxTempLength = message.maxTempSize;\n\t\tfctx.canWriteClientCache = message.writeToClientCache;\n\t\tfctx.filterData = message.filterData;\n\t\tfctx.ignoreUSKDatehints = message.ignoreUSKDatehints;\n\n\t\tif(message.allowedMIMETypes != null) {\n\t\t\tfctx.allowedMIMETypes = new HashSet<String>();\n\t\t\tfor(String mime : message.allowedMIMETypes)\n\t\t\t\tfctx.allowedMIMETypes.add(mime);\n\t\t}\n\n\t\tthis.returnType = message.returnType;\n\t\tthis.binaryBlob = message.binaryBlob;\n\t\tBucket ret = null;\n\t\tString extensionCheck = null;\n\t\tif(returnType == ClientGetMessage.RETURN_TYPE_DISK) {\n\t\t\tthis.targetFile = message.diskFile;\n\t\t\tif(!server.core.allowDownloadTo(targetFile))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ACCESS_DENIED, \"Not allowed to download to \"+targetFile, identifier, global);\n\t\t\telse if(!(handler.allowDDAFrom(targetFile, true)))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.DIRECT_DISK_ACCESS_DENIED, \"Not allowed to download to \" + targetFile + \". You might need to do a \" + TestDDARequestMessage.NAME + \" first.\", identifier, global);\n\t\t\tret = new FileBucket(targetFile, false, true, false, false, false);\n\t\t\tif(fctx.filterData) {\n\t\t\t\tString name = targetFile.getName();\n\t\t\t\tint idx = name.lastIndexOf('.');\n\t\t\t\tif(idx != -1) {\n\t\t\t\t\tidx++;\n\t\t\t\t\tif(idx != name.length())\n\t\t\t\t\t\textensionCheck = name.substring(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(returnType == ClientGetMessage.RETURN_TYPE_NONE) {\n\t\t\ttargetFile = null;\n\t\t\tret = new NullBucket();\n        } else {\n            targetFile = null;\n            ret = null; // Let the ClientGetter allocate the Bucket later on.\n\t\t}\n\t\tif(ret == null)\n\t\t\tLogger.error(this, \"Impossible: ret = null in FCP constructor for \"+this, new Exception(\"debug\"));\n\t\t\tgetter = new ClientGetter(this,\n\t\t\t\t\turi, fctx, priorityClass,\n\t\t\t\t\tbinaryBlob ? new NullBucket() : ret, binaryBlob ? new BinaryBlobWriter(ret) : null, false, message.getInitialMetadata(), extensionCheck);\n\t}","commit_id":"34f72481990af13b5ea693af7c255627fcff5154","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * This should *only* be used for testing purposes.\n     */\n    public void initializeNodeUnsafe(InetAddress addr, UUID uuid, int generationNbr) {\n        /* initialize the heartbeat state for this localEndpoint */\n        EndpointState localState = endpointStateMap.get(addr);\n        if ( localState == null )\n        {\n            HeartBeatState hbState = new HeartBeatState(generationNbr);\n            localState = new EndpointState(hbState);\n            localState.markAlive();\n            endpointStateMap.put(addr, localState);\n        }\n        // always add the version state\n        localState.addApplicationState(ApplicationState.NET_VERSION, StorageService.instance.valueFactory.networkVersion());\n        localState.addApplicationState(ApplicationState.HOST_ID, StorageService.instance.valueFactory.hostId(uuid));\n    }","id":85668,"modified_method":"@VisibleForTesting\n    public void initializeNodeUnsafe(InetAddress addr, UUID uuid, int generationNbr)\n    {\n        HeartBeatState hbState = new HeartBeatState(generationNbr);\n        EndpointState localState = new EndpointState(hbState);\n        localState.markAlive();\n        endpointStateMap.putIfAbsent(addr, localState);\n\n        // always add the version state\n        localState.addApplicationState(ApplicationState.NET_VERSION, StorageService.instance.valueFactory.networkVersion());\n        localState.addApplicationState(ApplicationState.HOST_ID, StorageService.instance.valueFactory.hostId(uuid));\n    }","commit_id":"f5e3ae67c4a4fef6a541a8a06a9871810639a7ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * This should *only* be used for testing purposes\n     */\n    public void injectApplicationState(InetAddress endpoint, ApplicationState state, VersionedValue value)\n    {\n        EndpointState localState = endpointStateMap.get(endpoint);\n        localState.addApplicationState(state, value);\n    }","id":85669,"modified_method":"@VisibleForTesting\n    public void injectApplicationState(InetAddress endpoint, ApplicationState state, VersionedValue value)\n    {\n        EndpointState localState = endpointStateMap.get(endpoint);\n        localState.addApplicationState(state, value);\n    }","commit_id":"f5e3ae67c4a4fef6a541a8a06a9871810639a7ec","url":"https://github.com/apache/cassandra"},{"original_method":"public void maybeInitializeLocalState(int generationNbr)\n    {\n        EndpointState localState = endpointStateMap.get(FBUtilities.getBroadcastAddress());\n        if ( localState == null )\n        {\n            HeartBeatState hbState = new HeartBeatState(generationNbr);\n            localState = new EndpointState(hbState);\n            localState.markAlive();\n            endpointStateMap.put(FBUtilities.getBroadcastAddress(), localState);\n        }\n    }","id":85670,"modified_method":"public void maybeInitializeLocalState(int generationNbr)\n    {\n        HeartBeatState hbState = new HeartBeatState(generationNbr);\n        EndpointState localState = new EndpointState(hbState);\n        localState.markAlive();\n        endpointStateMap.putIfAbsent(FBUtilities.getBroadcastAddress(), localState);\n    }","commit_id":"f5e3ae67c4a4fef6a541a8a06a9871810639a7ec","url":"https://github.com/apache/cassandra"},{"original_method":"protected long getExpireTimeForEndpoint(InetAddress endpoint)\n    {\n        /* default expireTime is aVeryLongTime */\n        long expireTime = computeExpireTime();\n        if (expireTimeEndpointMap.containsKey(endpoint))\n        {\n            expireTime = expireTimeEndpointMap.get(endpoint);\n        }\n        return expireTime;\n    }","id":85671,"modified_method":"protected long getExpireTimeForEndpoint(InetAddress endpoint)\n    {\n        /* default expireTime is aVeryLongTime */\n        Long storedTime = expireTimeEndpointMap.get(endpoint);\n        return storedTime == null ? computeExpireTime() : storedTime;\n    }","commit_id":"f5e3ae67c4a4fef6a541a8a06a9871810639a7ec","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * adds a cf to internal structures, ends up creating disk files).\n     */\n    public void initCf(UUID cfId, String cfName, boolean loadSSTables)\n    {\n        if (columnFamilyStores.containsKey(cfId))\n        {\n            // this is the case when you reset local schema\n            // just reload metadata\n            ColumnFamilyStore cfs = columnFamilyStores.get(cfId);\n            assert cfs.getColumnFamilyName().equals(cfName);\n\n            cfs.metadata.reload();\n            cfs.reload();\n        }\n        else\n        {\n            columnFamilyStores.put(cfId, ColumnFamilyStore.createColumnFamilyStore(this, cfName, loadSSTables));\n        }\n    }","id":85672,"modified_method":"/**\n     * adds a cf to internal structures, ends up creating disk files).\n     */\n    public void initCf(UUID cfId, String cfName, boolean loadSSTables)\n    {\n        ColumnFamilyStore cfs = columnFamilyStores.get(cfId);\n\n        if (cfs == null)\n        {\n            // CFS being created for the first time, either on server startup or new CF being added.\n            // We don't worry about races here; startup is safe, and adding multiple idential CFs\n            // simultaneously is a \"don't do that\" scenario.\n            ColumnFamilyStore oldCfs = columnFamilyStores.putIfAbsent(cfId, ColumnFamilyStore.createColumnFamilyStore(this, cfName, loadSSTables));\n            // CFS mbean instantiation will error out before we hit this, but in case that changes...\n            if (oldCfs != null)\n                throw new IllegalStateException(\"added multiple mappings for cf id \" + cfId);\n        }\n        else\n        {\n            // re-initializing an existing CF.  This will happen if you cleared the schema\n            // on this node and it's getting repopulated from the rest of the cluster.\n            assert cfs.getColumnFamilyName().equals(cfName);\n            cfs.metadata.reload();\n            cfs.reload();\n        }\n    }","commit_id":"f5e3ae67c4a4fef6a541a8a06a9871810639a7ec","url":"https://github.com/apache/cassandra"},{"original_method":"public DomElementsToggleAction(final DomModelTreeView treeView, final Class aClass) {\n    myTreeView = treeView;\n    myClass = aClass;\n\n    Icon myIcon = ElementPresentationManager.getIcon(myClass);\n    if (myIcon == null) {\n      myIcon = AllIcons.Nodes.Pointcut;\n    }\n    this.myIcon = myIcon;\n\n    myText = TypePresentationService.getService().getTypePresentableName(myClass);\n\n    if(getHiders() == null) DomUtil.getFile(myTreeView.getRootElement()).putUserData(AbstractDomElementNode.TREE_NODES_HIDERS_KEY,\n                                                                                     new HashMap<>());\n\n    if(getHiders().get(myClass) == null) getHiders().put(myClass, true);\n  }","id":85673,"modified_method":"public DomElementsToggleAction(final DomModelTreeView treeView, final Class aClass) {\n    myTreeView = treeView;\n    myClass = aClass;\n\n    Icon myIcon = ElementPresentationManager.getIcon(myClass);\n    if (myIcon == null) {\n      myIcon = AllIcons.Nodes.Pointcut;\n    }\n    this.myIcon = myIcon;\n\n    myText = TypePresentationService.getService().getTypePresentableName(myClass);\n\n    if(getHiders() == null) DomUtil.getFile(myTreeView.getRootElement()).putUserData(AbstractDomElementNode.TREE_NODES_HIDERS_KEY,\n                                                                                     new HashMap<>());\n\n    getHiders().putIfAbsent(myClass, true);\n  }","commit_id":"cbfa5eb6f59b97868b4a5247d5a0d410c1d43e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private GitCheckAttrParser(@NotNull List<String> output) {\n    myAttributes = new HashMap<>();\n\n    for (String line : output) {\n      if (line.isEmpty()) {\n        continue;\n      }\n      List<String> split = StringUtil.split(line, \":\");\n      LOG.assertTrue(split.size() == 3, String.format(\"Output doesn't match the expected format. Line: %s%nAll output:%n%s\",\n                                                      line, StringUtil.join(output, \"\\n\")));\n      String file = split.get(0).trim();\n      String attribute = split.get(1).trim();\n      String info = split.get(2).trim();\n\n      GitAttribute attr = GitAttribute.forName(attribute);\n      if (attr == null || info.equalsIgnoreCase(UNSPECIFIED_VALUE)) {\n        // ignoring attributes that we are not interested in\n        continue;\n      }\n\n      if (myAttributes.get(file) == null) {\n        myAttributes.put(file, new ArrayList<>());\n      }\n      myAttributes.get(file).add(attr);\n    }\n  }","id":85674,"modified_method":"private GitCheckAttrParser(@NotNull List<String> output) {\n    myAttributes = new HashMap<>();\n\n    for (String line : output) {\n      if (line.isEmpty()) {\n        continue;\n      }\n      List<String> split = StringUtil.split(line, \":\");\n      LOG.assertTrue(split.size() == 3, String.format(\"Output doesn't match the expected format. Line: %s%nAll output:%n%s\",\n                                                      line, StringUtil.join(output, \"\\n\")));\n      String file = split.get(0).trim();\n      String attribute = split.get(1).trim();\n      String info = split.get(2).trim();\n\n      GitAttribute attr = GitAttribute.forName(attribute);\n      if (attr == null || info.equalsIgnoreCase(UNSPECIFIED_VALUE)) {\n        // ignoring attributes that we are not interested in\n        continue;\n      }\n\n      myAttributes.computeIfAbsent(file, f -> new ArrayList<>()).add(attr);\n    }\n  }","commit_id":"cbfa5eb6f59b97868b4a5247d5a0d410c1d43e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public KeyStroke get(String strokeText) {\n    String s = strokeText.trim();\n\n    assert s.length() > 0;\n\n    final String lowerCaseS = s.toLowerCase();\n    boolean hasModifiers = lowerCaseS.contains(\"shift\") || lowerCaseS.contains(\"control\") || lowerCaseS.contains(\"alt\") || lowerCaseS.contains(\"meta\");\n\n    String symbol = null;\n    int beforeSymbol = -1;\n    boolean haveSymbol = false;\n    KeyStroke symbolStroke = null;\n\n    if (hasModifiers) {\n      beforeSymbol =  s.lastIndexOf(\" \");\n      haveSymbol = beforeSymbol > 0;\n    } else {\n      symbol = s;\n      haveSymbol = true;\n    }\n\n    int modifiers = 0;\n    if (haveSymbol) {\n      if (symbol == null) {\n        symbol = s.substring(beforeSymbol + 1);\n      }\n\n      if (symbol.length() > 1) {\n        final Integer code = ReflectionUtil.getStaticFieldValue(KeyEvent.class, int.class, \"VK_\" + StringUtil.toUpperCase(symbol));\n        if (code == null) {\n          return throwUnrecognized(symbol);\n        }\n        symbolStroke = KeyStroke.getKeyStroke(code.intValue(), 0);\n      }\n\n      String modifierPlusA = s.substring(0, s.length() - (s.length() - beforeSymbol - 1)) + \"A\";\n      final KeyStroke modifierPlusAStroke = KeyStroke.getKeyStroke(modifierPlusA);\n\n      if (symbolStroke == null) {\n        symbol = String.valueOf(symbol.charAt(0));\n        symbolStroke = get(symbol.charAt(0));\n      }\n\n      modifiers = modifierPlusAStroke.getModifiers();\n      if ((symbolStroke.getModifiers() & KeyEvent.SHIFT_MASK) > 0) {\n        modifiers |= KeyEvent.SHIFT_MASK;\n      }\n    }\n\n    if (symbolStroke == null || symbolStroke.getKeyCode() == KeyEvent.VK_UNDEFINED) {\n      return throwUnrecognized(symbol);\n    }\n\n\n    return KeyStroke.getKeyStroke(symbolStroke.getKeyCode(), modifiers, false);\n  }","id":85675,"modified_method":"public KeyStroke get(String strokeText) {\n    String s = strokeText.trim();\n\n    assert s.length() > 0;\n\n    final String lowerCaseS = s.toLowerCase();\n    boolean hasModifiers = lowerCaseS.contains(\"shift\") || lowerCaseS.contains(\"control\") || lowerCaseS.contains(\"alt\") || lowerCaseS.contains(\"meta\");\n\n    String symbol = null;\n    int beforeSymbol = -1;\n    boolean haveSymbol;\n    KeyStroke symbolStroke = null;\n\n    if (hasModifiers) {\n      beforeSymbol =  s.lastIndexOf(\" \");\n      haveSymbol = beforeSymbol > 0;\n    } else {\n      symbol = s;\n      haveSymbol = true;\n    }\n\n    int modifiers = 0;\n    if (haveSymbol) {\n      if (symbol == null) {\n        symbol = s.substring(beforeSymbol + 1);\n      }\n\n      if (symbol.length() > 1) {\n        final Integer code = ReflectionUtil.getStaticFieldValue(KeyEvent.class, int.class, \"VK_\" + StringUtil.toUpperCase(symbol));\n        if (code == null) {\n          return throwUnrecognized(symbol);\n        }\n        symbolStroke = KeyStroke.getKeyStroke(code.intValue(), 0);\n      }\n\n      String modifierPlusA = s.substring(0, s.length() - (s.length() - beforeSymbol - 1)) + \"A\";\n      final KeyStroke modifierPlusAStroke = KeyStroke.getKeyStroke(modifierPlusA);\n\n      if (symbolStroke == null) {\n        symbol = String.valueOf(symbol.charAt(0));\n        symbolStroke = get(symbol.charAt(0));\n      }\n\n      modifiers = modifierPlusAStroke.getModifiers();\n      if ((symbolStroke.getModifiers() & KeyEvent.SHIFT_MASK) > 0) {\n        modifiers |= KeyEvent.SHIFT_MASK;\n      }\n    }\n\n    if (symbolStroke == null || symbolStroke.getKeyCode() == KeyEvent.VK_UNDEFINED) {\n      return throwUnrecognized(symbol);\n    }\n\n\n    return KeyStroke.getKeyStroke(symbolStroke.getKeyCode(), modifiers, false);\n  }","commit_id":"cbfa5eb6f59b97868b4a5247d5a0d410c1d43e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Map<Character, KeyStroke> generateKeyStrokeMappings() {\n    LOG.debug(\"Generating default keystroke mappings\");\n    // character, keycode, modifiers\n    int shift = InputEvent.SHIFT_MASK;\n    //int alt = InputEvent.ALT_MASK;\n    //int altg = InputEvent.ALT_GRAPH_MASK;\n    int ctrl = InputEvent.CTRL_MASK;\n    //int meta = InputEvent.META_MASK;\n    // These are assumed to be standard across all keyboards (?)\n    int[][] universalMappings = {{'\u001b', KeyEvent.VK_ESCAPE, 0}, // No escape sequence exists\n      {'\\b', KeyEvent.VK_BACK_SPACE, 0}, {'', KeyEvent.VK_DELETE, 0}, // None for this one either\n      {'\\n', KeyEvent.VK_ENTER, 0}, {'\\r', KeyEvent.VK_ENTER, 0},};\n    // Add to these as needed; note that this is based on a US keyboard\n    // mapping, and will likely fail for others.\n    int[][] mappings =\n      {{' ', KeyEvent.VK_SPACE, 0,}, {'\\t', KeyEvent.VK_TAB, 0,}, {'~', KeyEvent.VK_BACK_QUOTE, shift,}, {'`', KeyEvent.VK_BACK_QUOTE, 0,},\n        {'!', KeyEvent.VK_1, shift,}, {'@', KeyEvent.VK_2, shift,}, {'#', KeyEvent.VK_3, shift,}, {'$', KeyEvent.VK_4, shift,},\n        {'%', KeyEvent.VK_5, shift,}, {'^', KeyEvent.VK_6, shift,}, {'&', KeyEvent.VK_7, shift,}, {'*', KeyEvent.VK_8, shift,},\n        {'(', KeyEvent.VK_9, shift,}, {')', KeyEvent.VK_0, shift,}, {'-', KeyEvent.VK_MINUS, 0,}, {'_', KeyEvent.VK_MINUS, shift,},\n        {'=', KeyEvent.VK_EQUALS, 0,}, {'+', KeyEvent.VK_EQUALS, shift,}, {'[', KeyEvent.VK_OPEN_BRACKET, 0,},\n        {'{', KeyEvent.VK_OPEN_BRACKET, shift,},\n        // NOTE: The following does NOT produce a left brace\n        //{ '{', KeyEvent.VK_BRACELEFT, 0, },\n        {']', KeyEvent.VK_CLOSE_BRACKET, 0,}, {'}', KeyEvent.VK_CLOSE_BRACKET, shift,}, {'|', KeyEvent.VK_BACK_SLASH, shift,},\n        {';', KeyEvent.VK_SEMICOLON, 0,}, {':', KeyEvent.VK_SEMICOLON, shift,}, {',', KeyEvent.VK_COMMA, 0,},\n        {'<', KeyEvent.VK_COMMA, shift,}, {'.', KeyEvent.VK_PERIOD, 0,}, {'>', KeyEvent.VK_PERIOD, shift,}, {'/', KeyEvent.VK_SLASH, 0,},\n        {'?', KeyEvent.VK_SLASH, shift,}, {'\\\\', KeyEvent.VK_BACK_SLASH, 0,}, {'|', KeyEvent.VK_BACK_SLASH, shift,},\n        {'\\'', KeyEvent.VK_QUOTE, 0,}, {'\"', KeyEvent.VK_QUOTE, shift,},};\n    HashMap<Character, KeyStroke> map = new HashMap<>();\n    // Universal mappings\n    for (int i = 0; i < universalMappings.length; i++) {\n      int[] entry = universalMappings[i];\n      KeyStroke stroke = KeyStroke.getKeyStroke(entry[1], entry[2]);\n      map.put(new Character((char)entry[0]), stroke);\n    }\n\n    //// If the locale is not en_US/GB, provide only a very basic map and\n    //// rely on key_typed events instead\n    //Locale locale = Locale.getDefault();\n    //if (!Locale.US.equals(locale) && !Locale.UK.equals(locale)) {\n    //  LOG.debug(\"Not US: \" + locale);\n    //  return map;\n    //}\n\n    // Basic symbol/punctuation mappings\n    for (int i = 0; i < mappings.length; i++) {\n      int[] entry = mappings[i];\n      KeyStroke stroke = KeyStroke.getKeyStroke(entry[1], entry[2]);\n      map.put(new Character((char)entry[0]), stroke);\n    }\n    // Lowercase\n    for (int i = 'a'; i <= 'z'; i++) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_A + i - 'a', 0);\n      map.put(new Character((char)i), stroke);\n      // control characters\n      stroke = KeyStroke.getKeyStroke(KeyEvent.VK_A + i - 'a', ctrl);\n      Character key = new Character((char)(i - 'a' + 1));\n      // Make sure we don't overwrite something already there\n      if (map.get(key) == null) {\n        map.put(key, stroke);\n      }\n    }\n    // Capitals\n    for (int i = 'A'; i <= 'Z'; i++) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_A + i - 'A', shift);\n      map.put(new Character((char)i), stroke);\n    }\n    // digits\n    for (int i = '0'; i <= '9'; i++) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_0 + i - '0', 0);\n      map.put(new Character((char)i), stroke);\n    }\n    return map;\n  }","id":85676,"modified_method":"private static Map<Character, KeyStroke> generateKeyStrokeMappings() {\n    LOG.debug(\"Generating default keystroke mappings\");\n    // character, keycode, modifiers\n    int shift = InputEvent.SHIFT_MASK;\n    //int alt = InputEvent.ALT_MASK;\n    //int altg = InputEvent.ALT_GRAPH_MASK;\n    int ctrl = InputEvent.CTRL_MASK;\n    //int meta = InputEvent.META_MASK;\n    // These are assumed to be standard across all keyboards (?)\n    int[][] universalMappings = {{'\u001b', KeyEvent.VK_ESCAPE, 0}, // No escape sequence exists\n      {'\\b', KeyEvent.VK_BACK_SPACE, 0}, {'', KeyEvent.VK_DELETE, 0}, // None for this one either\n      {'\\n', KeyEvent.VK_ENTER, 0}, {'\\r', KeyEvent.VK_ENTER, 0},};\n    // Add to these as needed; note that this is based on a US keyboard\n    // mapping, and will likely fail for others.\n    int[][] mappings =\n      {{' ', KeyEvent.VK_SPACE, 0,}, {'\\t', KeyEvent.VK_TAB, 0,}, {'~', KeyEvent.VK_BACK_QUOTE, shift,}, {'`', KeyEvent.VK_BACK_QUOTE, 0,},\n        {'!', KeyEvent.VK_1, shift,}, {'@', KeyEvent.VK_2, shift,}, {'#', KeyEvent.VK_3, shift,}, {'$', KeyEvent.VK_4, shift,},\n        {'%', KeyEvent.VK_5, shift,}, {'^', KeyEvent.VK_6, shift,}, {'&', KeyEvent.VK_7, shift,}, {'*', KeyEvent.VK_8, shift,},\n        {'(', KeyEvent.VK_9, shift,}, {')', KeyEvent.VK_0, shift,}, {'-', KeyEvent.VK_MINUS, 0,}, {'_', KeyEvent.VK_MINUS, shift,},\n        {'=', KeyEvent.VK_EQUALS, 0,}, {'+', KeyEvent.VK_EQUALS, shift,}, {'[', KeyEvent.VK_OPEN_BRACKET, 0,},\n        {'{', KeyEvent.VK_OPEN_BRACKET, shift,},\n        // NOTE: The following does NOT produce a left brace\n        //{ '{', KeyEvent.VK_BRACELEFT, 0, },\n        {']', KeyEvent.VK_CLOSE_BRACKET, 0,}, {'}', KeyEvent.VK_CLOSE_BRACKET, shift,}, {'|', KeyEvent.VK_BACK_SLASH, shift,},\n        {';', KeyEvent.VK_SEMICOLON, 0,}, {':', KeyEvent.VK_SEMICOLON, shift,}, {',', KeyEvent.VK_COMMA, 0,},\n        {'<', KeyEvent.VK_COMMA, shift,}, {'.', KeyEvent.VK_PERIOD, 0,}, {'>', KeyEvent.VK_PERIOD, shift,}, {'/', KeyEvent.VK_SLASH, 0,},\n        {'?', KeyEvent.VK_SLASH, shift,}, {'\\\\', KeyEvent.VK_BACK_SLASH, 0,}, {'|', KeyEvent.VK_BACK_SLASH, shift,},\n        {'\\'', KeyEvent.VK_QUOTE, 0,}, {'\"', KeyEvent.VK_QUOTE, shift,},};\n    HashMap<Character, KeyStroke> map = new HashMap<>();\n    // Universal mappings\n    for (int[] entry : universalMappings) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(entry[1], entry[2]);\n      map.put(new Character((char)entry[0]), stroke);\n    }\n\n    //// If the locale is not en_US/GB, provide only a very basic map and\n    //// rely on key_typed events instead\n    //Locale locale = Locale.getDefault();\n    //if (!Locale.US.equals(locale) && !Locale.UK.equals(locale)) {\n    //  LOG.debug(\"Not US: \" + locale);\n    //  return map;\n    //}\n\n    // Basic symbol/punctuation mappings\n    for (int[] entry : mappings) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(entry[1], entry[2]);\n      map.put(new Character((char)entry[0]), stroke);\n    }\n    // Lowercase\n    for (int i = 'a'; i <= 'z'; i++) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_A + i - 'a', 0);\n      map.put(new Character((char)i), stroke);\n      // control characters\n      stroke = KeyStroke.getKeyStroke(KeyEvent.VK_A + i - 'a', ctrl);\n      Character key = new Character((char)(i - 'a' + 1));\n      // Make sure we don't overwrite something already there\n      map.putIfAbsent(key, stroke);\n    }\n    // Capitals\n    for (int i = 'A'; i <= 'Z'; i++) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_A + i - 'A', shift);\n      map.put(new Character((char)i), stroke);\n    }\n    // digits\n    for (int i = '0'; i <= '9'; i++) {\n      KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_0 + i - '0', 0);\n      map.put(new Character((char)i), stroke);\n    }\n    return map;\n  }","commit_id":"cbfa5eb6f59b97868b4a5247d5a0d410c1d43e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void fill(MatchResult r,Map<String,MatchResult> m) {\n    if (r.getName()!=null) {\n      if (m.get(r.getName()) == null) {\n        m.put(r.getName(), r);\n      }\n    }\n\n    if (!r.isScopeMatch() || !r.isMultipleMatch()) {\n      for (final MatchResult matchResult : r.getAllSons()) {\n        fill(matchResult, m);\n      }\n    } else if (r.hasSons()) {\n      final List<MatchResult> allSons = r.getAllSons();\n      if (allSons.size() > 0) {\n        fill(allSons.get(0),m);\n      }\n    }\n  }","id":85677,"modified_method":"private static void fill(MatchResult r,Map<String,MatchResult> m) {\n    if (r.getName()!=null) {\n      m.putIfAbsent(r.getName(), r);\n    }\n\n    if (!r.isScopeMatch() || !r.isMultipleMatch()) {\n      for (final MatchResult matchResult : r.getAllSons()) {\n        fill(matchResult, m);\n      }\n    } else if (r.hasSons()) {\n      final List<MatchResult> allSons = r.getAllSons();\n      if (allSons.size() > 0) {\n        fill(allSons.get(0),m);\n      }\n    }\n  }","commit_id":"cbfa5eb6f59b97868b4a5247d5a0d410c1d43e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean verifyMethod(final PsiElement element, final Set<PsiElement> victims, final PsiSearchHelper helper) {\n    PsiMethod method;\n    PsiParameter parameter = null;\n    int index = 0;\n\n    if (element instanceof PsiMethod) {\n      method = (PsiMethod)element;\n    }\n    else if (element instanceof PsiParameter) {\n      parameter = (PsiParameter)element;\n      method = (PsiMethod)parameter.getDeclarationScope();\n      index = method.getParameterList().getParameterIndex(parameter);\n    }\n    else {\n      LOG.error(\"Parameter or method expected, but found \" + (element == null ? \"null\" : element.getClass().getName()));\n      return false;\n    }\n\n    final PsiMethod superMethod = method.findDeepestSuperMethod();\n    PsiMethod keyMethod;\n    PsiParameter keyParameter = null;\n\n    if (superMethod != null) {\n      Boolean good = myMethodCache.get(superMethod);\n\n      if (good != null && !good.booleanValue()) {\n        return false;\n      }\n\n      final PsiElement e = parameter == null ? superMethod : superMethod.getParameterList().getParameters()[index];\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(superMethod, Boolean.FALSE);\n        return false;\n      }\n\n      keyMethod = superMethod;\n\n      myMethods.put(method, keyMethod);\n\n      if (parameter != null) {\n        keyParameter = (PsiParameter)e;\n      }\n    }\n    else {\n      Boolean good = myMethodCache.get(method);\n\n      if (good != null && good.booleanValue()) {\n        if (myMethods.get(method) == null) {\n          myMethods.put(method, method);\n        }\n\n        if (parameter != null && myParameters.get(parameter) == null) {\n          myParameters.put(parameter, parameter);\n        }\n\n        return true;\n      }\n\n      keyMethod = method;\n      keyParameter = parameter;\n    }\n\n    final PsiMethod[] overriders = OverridingMethodsSearch.search(keyMethod).toArray(PsiMethod.EMPTY_ARRAY);\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(keyMethod, Boolean.FALSE);\n        return false;\n      }\n    }\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      myMethods.put(overrider, keyMethod);\n\n      if (parameter != null) {\n        myParameters.put((PsiParameter)e, keyParameter);\n      }\n    }\n\n    myMethods.put(method, keyMethod);\n\n    if (parameter != null) {\n      myParameters.put(parameter, keyParameter);\n    }\n\n    myMethodCache.put(keyMethod, Boolean.TRUE);\n\n    return true;\n  }","id":85678,"modified_method":"private boolean verifyMethod(final PsiElement element, final Set<PsiElement> victims, final PsiSearchHelper helper) {\n    PsiMethod method;\n    PsiParameter parameter = null;\n    int index = 0;\n\n    if (element instanceof PsiMethod) {\n      method = (PsiMethod)element;\n    }\n    else if (element instanceof PsiParameter) {\n      parameter = (PsiParameter)element;\n      method = (PsiMethod)parameter.getDeclarationScope();\n      index = method.getParameterList().getParameterIndex(parameter);\n    }\n    else {\n      LOG.error(\"Parameter or method expected, but found \" + (element == null ? \"null\" : element.getClass().getName()));\n      return false;\n    }\n\n    final PsiMethod superMethod = method.findDeepestSuperMethod();\n    PsiMethod keyMethod;\n    PsiParameter keyParameter = null;\n\n    if (superMethod != null) {\n      Boolean good = myMethodCache.get(superMethod);\n\n      if (good != null && !good.booleanValue()) {\n        return false;\n      }\n\n      final PsiElement e = parameter == null ? superMethod : superMethod.getParameterList().getParameters()[index];\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(superMethod, Boolean.FALSE);\n        return false;\n      }\n\n      keyMethod = superMethod;\n\n      myMethods.put(method, keyMethod);\n\n      if (parameter != null) {\n        keyParameter = (PsiParameter)e;\n      }\n    }\n    else {\n      Boolean good = myMethodCache.get(method);\n\n      if (good != null && good.booleanValue()) {\n        myMethods.putIfAbsent(method, method);\n\n        if (parameter != null && myParameters.get(parameter) == null) {\n          myParameters.put(parameter, parameter);\n        }\n\n        return true;\n      }\n\n      keyMethod = method;\n      keyParameter = parameter;\n    }\n\n    final PsiMethod[] overriders = OverridingMethodsSearch.search(keyMethod).toArray(PsiMethod.EMPTY_ARRAY);\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      if (!victims.contains(e)) {\n        myMethodCache.put(keyMethod, Boolean.FALSE);\n        return false;\n      }\n    }\n\n    for (final PsiMethod overrider : overriders) {\n      final PsiElement e = parameter != null ? overrider.getParameterList().getParameters()[index] : overrider;\n\n      myMethods.put(overrider, keyMethod);\n\n      if (parameter != null) {\n        myParameters.put((PsiParameter)e, keyParameter);\n      }\n    }\n\n    myMethods.put(method, keyMethod);\n\n    if (parameter != null) {\n      myParameters.put(parameter, keyParameter);\n    }\n\n    myMethodCache.put(keyMethod, Boolean.TRUE);\n\n    return true;\n  }","commit_id":"cbfa5eb6f59b97868b4a5247d5a0d410c1d43e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Filter the specified collection of classes to return only ones that contain any of the specified values in the\n   * specified annotation parameter. For example, this method can be used to return all classes that contain all tesng\n   * annotations that are in the groups 'foo' or 'bar'.\n   */\n  public static Map<PsiClass, Collection<PsiMethod>> filterAnnotations(String parameter, Set<String> values, Collection<PsiClass> classes) {\n    Map<PsiClass, Collection<PsiMethod>> results = new HashMap<>();\n    Set<String> test = new HashSet<>(1);\n    test.add(TEST_ANNOTATION_FQN);\n    ContainerUtil.addAll(test, CONFIG_ANNOTATIONS_FQN);\n    for (PsiClass psiClass : classes) {\n      if (isBrokenPsiClass(psiClass)) continue;\n\n      PsiAnnotation annotation;\n      try {\n        annotation = AnnotationUtil.findAnnotation(psiClass, test);\n      }\n      catch (Exception e) {\n        LOGGER.error(\"Exception trying to findAnnotation on \" + psiClass.getClass().getName() + \".\\n\\n\" + e.getMessage());\n        annotation = null;\n      }\n      if (annotation != null) {\n        if (isAnnotatedWithParameter(annotation, parameter, values)) {\n          results.put(psiClass, new LinkedHashSet<>());\n        }\n      }\n      else {\n        Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n        for (String s : matches) {\n          if (values.contains(s)) {\n            results.put(psiClass, new LinkedHashSet<>());\n            break;\n          }\n        }\n      }\n\n      //we already have the class, no need to look through its methods\n      PsiMethod[] methods = psiClass.getMethods();\n      for (PsiMethod method : methods) {\n        if (method != null) {\n          annotation = AnnotationUtil.findAnnotation(method, test);\n          if (annotation != null) {\n            if (isAnnotatedWithParameter(annotation, parameter, values)) {\n              if (results.get(psiClass) == null) results.put(psiClass, new LinkedHashSet<>());\n              results.get(psiClass).add(method);\n            }\n          }\n          else {\n            Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n            for (String s : matches) {\n              if (values.contains(s)) {\n                results.get(psiClass).add(method);\n              }\n            }\n          }\n        }\n      }\n    }\n    return results;\n  }","id":85679,"modified_method":"/**\n   * Filter the specified collection of classes to return only ones that contain any of the specified values in the\n   * specified annotation parameter. For example, this method can be used to return all classes that contain all tesng\n   * annotations that are in the groups 'foo' or 'bar'.\n   */\n  public static Map<PsiClass, Collection<PsiMethod>> filterAnnotations(String parameter, Set<String> values, Collection<PsiClass> classes) {\n    Map<PsiClass, Collection<PsiMethod>> results = new HashMap<>();\n    Set<String> test = new HashSet<>(1);\n    test.add(TEST_ANNOTATION_FQN);\n    ContainerUtil.addAll(test, CONFIG_ANNOTATIONS_FQN);\n    for (PsiClass psiClass : classes) {\n      if (isBrokenPsiClass(psiClass)) continue;\n\n      PsiAnnotation annotation;\n      try {\n        annotation = AnnotationUtil.findAnnotation(psiClass, test);\n      }\n      catch (Exception e) {\n        LOGGER.error(\"Exception trying to findAnnotation on \" + psiClass.getClass().getName() + \".\\n\\n\" + e.getMessage());\n        annotation = null;\n      }\n      if (annotation != null) {\n        if (isAnnotatedWithParameter(annotation, parameter, values)) {\n          results.put(psiClass, new LinkedHashSet<>());\n        }\n      }\n      else {\n        Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n        for (String s : matches) {\n          if (values.contains(s)) {\n            results.put(psiClass, new LinkedHashSet<>());\n            break;\n          }\n        }\n      }\n\n      //we already have the class, no need to look through its methods\n      PsiMethod[] methods = psiClass.getMethods();\n      for (PsiMethod method : methods) {\n        if (method != null) {\n          annotation = AnnotationUtil.findAnnotation(method, test);\n          if (annotation != null) {\n            if (isAnnotatedWithParameter(annotation, parameter, values)) {\n              results.computeIfAbsent(psiClass, c -> new LinkedHashSet<>()).add(method);\n            }\n          }\n          else {\n            Collection<String> matches = extractAnnotationValuesFromJavaDoc(getTextJavaDoc(psiClass), parameter);\n            for (String s : matches) {\n              if (values.contains(s)) {\n                results.get(psiClass).add(method);\n              }\n            }\n          }\n        }\n      }\n    }\n    return results;\n  }","commit_id":"cbfa5eb6f59b97868b4a5247d5a0d410c1d43e0d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void loadState(State state) {\n    myState = state;\n    if (myState.TAB_STATES.get(MAIN_LOG_ID) == null) {\n      myState.TAB_STATES.put(MAIN_LOG_ID, myDeprecatedProperties.getState());\n    }\n  }","id":85680,"modified_method":"@Override\n  public void loadState(State state) {\n    myState = state;\n    myState.TAB_STATES.putIfAbsent(MAIN_LOG_ID, myDeprecatedProperties.getState());\n  }","commit_id":"3cbe07a12ed833099e10174c1ddcb608fb9ff821","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VcsLogUiProperties createProperties(@NotNull final String id) {\n    if (myState.TAB_STATES.get(id) == null) {\n      myState.TAB_STATES.put(id, new VcsLogUiPropertiesImpl.State());\n    }\n    return new VcsLogUiPropertiesImpl() {\n      @NotNull\n      @Override\n      public State getState() {\n        return myState.TAB_STATES.get(id);\n      }\n\n      @Override\n      public void loadState(State state) {\n        myState.TAB_STATES.put(id, state);\n      }\n    };\n  }","id":85681,"modified_method":"public VcsLogUiProperties createProperties(@NotNull final String id) {\n    myState.TAB_STATES.putIfAbsent(id, new VcsLogUiPropertiesImpl.State());\n    return new VcsLogUiPropertiesImpl() {\n      @NotNull\n      @Override\n      public State getState() {\n        return myState.TAB_STATES.get(id);\n      }\n\n      @Override\n      public void loadState(State state) {\n        myState.TAB_STATES.put(id, state);\n      }\n    };\n  }","commit_id":"3cbe07a12ed833099e10174c1ddcb608fb9ff821","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void invokeM () {\n\t\tp(\"public Object invoke(Method m, Object obj, Object[] params) {\");\n\t\tint subN = 0;\n\t\tint nDispatch = 0;\n\t\tfor (MethodStub stub : methodStubs) {\n\t\t\tif (stub.enclosingType == null) continue;\n\t\t\tif (stub.enclosingType.contains(\"[]\")) continue;\n\t\t\tif (stub.returnType == null) continue;\n\t\t\tif (stub.unused) continue;\n\t\t\tboolean paramsOk = true;\n\t\t\tfor (String paramType : stub.parameterTypes) {\n\t\t\t\tif (paramType == null) {\n\t\t\t\t\tparamsOk = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!paramsOk) continue;\n\t\t\tp(\"   if(m.methodId.equals(\\\"\" + stub.methodId + \"\\\")) {\");\n\t\t\tif (stub.returnType.equals(\"void\")) {\n\t\t\t\tpn(\"      \" + stub.methodId + \"(\");\n\t\t\t\taddParameters(stub);\n\t\t\t\tp(\");\");\n\t\t\t\tp(\"      return null;\");\n\t\t\t} else {\n\t\t\t\tpn(\"      return \" + stub.methodId + \"(\");\n\t\t\t\taddParameters(stub);\n\t\t\t\tpn(\");\");\n\t\t\t}\n\t\t\tp(\"   }\");\n\t\t\tnDispatch++;\n\t\t\tif (nDispatch > 1000) {\n\t\t\t\tsubN++;\n\t\t\t\tp(\"   return invoke\" + subN + \"(m, obj, params);\");\n\t\t\t\tp(\"}\");\n\t\t\t\tp(\"public Object invoke\" + subN + \"(Method m, Object obj, Object[] params) {\");\n\t\t\t\tnDispatch = 0;\n\t\t\t}\n\t\t}\n\n\t\tp(\"   return null;\");\n\t\tp(\"}\");\n\t}","id":85682,"modified_method":"private void invokeM () {\n\t\tp(\"public Object invoke(Method m, Object obj, Object[] params) {\");\n\t\tp(\"    String param = m.methodId;\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tint subN = 0;\n\t\tint nDispatch = 0;\n\t\tfor (MethodStub stub : methodStubs) {\n\t\t\tif (stub.enclosingType == null) continue;\n\t\t\tif (stub.enclosingType.contains(\"[]\")) continue;\n\t\t\tif (stub.returnType == null) continue;\n\t\t\tif (stub.unused) continue;\n\t\t\tboolean paramsOk = true;\n\t\t\tfor (String paramType : stub.parameterTypes) {\n\t\t\t\tif (paramType == null) {\n\t\t\t\t\tparamsOk = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!paramsOk) continue;\n\t\t\tbuffer.setLength(0);\n\t\t\tif (stub.returnType.equals(\"void\")) {\n\t\t\t\tpbn(\"      \" + stub.methodId + \"(\");\n\t\t\t\taddParameters(stub);\n\t\t\t\tpbn(\");\");\n\t\t\t\tpbn(\" return null;\");\n\t\t\t} else {\n\t\t\t\tpbn(\"      return \" + stub.methodId + \"(\");\n\t\t\t\taddParameters(stub);\n\t\t\t\tpbn(\");\");\n\t\t\t}\n\t\t\tpc.add(stub.methodId, buffer.toString());\n\t\t\tnDispatch++;\n\t\t\tif (nDispatch > 1000) {\n\t\t\t\tpc.print();\n\t\t\t\tpc = new SwitchedCodeBlocks();\n\t\t\t\tsubN++;\n\t\t\t\tp(\"   return invoke\" + subN + \"(m, obj, params, param);\");\n\t\t\t\tp(\"}\");\n\t\t\t\tp(\"public Object invoke\" + subN + \"(Method m, Object obj, Object[] params, String param) {\");\n\t\t\t\tnDispatch = 0;\n\t\t\t}\n\t\t}\n\n\t\tp(\"   return null;\");\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void newArrayC () {\n\t\tp(\"public Object newArray (Class componentType, int size) {\");\n\t\tp(\"    String typeName = componentType.getName().replace('$', '.');\");\n\t\tfor (JType type : types) {\n\t\t\tif (type.getQualifiedSourceName().equals(\"void\")) continue;\n\t\t\tif (type.getQualifiedSourceName().endsWith(\"Void\")) continue;\n\t\t\tString arrayType = type.getErasedType().getQualifiedSourceName() + \"[size]\";\n\t\t\tif (arrayType.contains(\"[]\")) {\n\t\t\t\tarrayType = type.getErasedType().getQualifiedSourceName();\n\t\t\t\tarrayType = arrayType.replaceFirst(\"\\\\[\\\\]\", \"[size]\") + \"[]\";\n\t\t\t}\n\t\t\tp(\"   if(typeName.equals(\\\"\" + type.getQualifiedSourceName() + \"\\\")) return new \" + arrayType + \";\");\n\t\t}\n\t\tp(\"\tthrow new RuntimeException(\\\"Couldn't create array with element type \\\" + componentType.getName());\");\n\t\tp(\"}\");\n\t}","id":85683,"modified_method":"private void newArrayC () {\n\t\tp(\"public Object newArray (Class componentType, int size) {\");\n\t\tp(\"    String param = componentType.getName().replace('$', '.');\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tfor (JType type : types) {\n\t\t\tif (type.getQualifiedSourceName().equals(\"void\")) continue;\n\t\t\tif (type.getQualifiedSourceName().endsWith(\"Void\")) continue;\n\t\t\tString arrayType = type.getErasedType().getQualifiedSourceName() + \"[size]\";\n\t\t\tif (arrayType.contains(\"[]\")) {\n\t\t\t\tarrayType = type.getErasedType().getQualifiedSourceName();\n\t\t\t\tarrayType = arrayType.replaceFirst(\"\\\\[\\\\]\", \"[size]\") + \"[]\";\n\t\t\t}\n\t\t\tpc.add(type.getQualifiedSourceName(), \"return new \" + arrayType + \";\");\n\t\t}\n\t\tpc.print();\n\t\tp(\"\tthrow new RuntimeException(\\\"Couldn't create array with element type \\\" + componentType.getName());\");\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void newInstanceT () {\n\t\tp(\"public Object newInstance (Type type) {\");\n\t\tfor (JType type : types) {\n\t\t\tif (type instanceof JClassType) {\n\t\t\t\tif (isInstantiableWithNewOperator((JClassType)type)) {\n\t\t\t\t\tp(\"if(type.getName().equals(\\\"\" + type.getErasedType().getQualifiedSourceName() + \"\\\")) return new \"\n\t\t\t\t\t\t+ type.getErasedType().getQualifiedSourceName() + \"();\");\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Type.INFO, \"No public default constructor for '\" + type.getQualifiedSourceName()\n\t\t\t\t\t\t+ \"', or type is an array, enum, abstract class or interface type\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.log(Type.INFO, \"No public default constructor for primitive type '\" + type.getQualifiedSourceName() + \"'\");\n\t\t\t}\n\t\t}\n\t\tp(\"return null;\");\n\t\tp(\"}\");\n\t}","id":85684,"modified_method":"private void newInstanceT () {\n\t\tp(\"public Object newInstance (Type type) {\");\n\t\tp(\"    String param = type.getName();\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tfor (JType type : types) {\n\t\t\tif (type instanceof JClassType) {\n\t\t\t\tif (isInstantiableWithNewOperator((JClassType)type)) {\n\t\t\t\t\tpc.add(type.getErasedType().getQualifiedSourceName(), \"return new \"+ type.getErasedType().getQualifiedSourceName() + \"();\");\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Type.INFO, \"No public default constructor for '\" + type.getQualifiedSourceName()\n\t\t\t\t\t\t+ \"', or type is an array, enum, abstract class or interface type\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlogger.log(Type.INFO, \"No public default constructor for primitive type '\" + type.getQualifiedSourceName() + \"'\");\n\t\t\t}\n\t\t}\n\t\tpc.print();\n\t\tp(\"return null;\");\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void getArrayLengthT () {\n\t\tp(\"public int getArrayLength(Type type, Object obj) {\");\n\t\tfor (JType type : types) {\n\t\t\tif (!(type instanceof JArrayType)) continue;\n\t\t\tp(\"   if(type.getName().equals(\\\"\" + type.getQualifiedSourceName() + \"\\\")) return ((\" + type.getQualifiedSourceName()\n\t\t\t\t+ \")obj).length;\");\n\t\t}\n\t\tp(\"\treturn 0;\");\n\t\tp(\"}\");\n\t}","id":85685,"modified_method":"private void getArrayLengthT () {\n\t\tp(\"public int getArrayLength(Type type, Object obj) {\");\n\t\tp(\"    String param = type.getName();\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tfor (JType type : types) {\n\t\t\tif (!(type instanceof JArrayType)) continue;\n\t\t\tpc.add(type.getQualifiedSourceName(), \"return ((\" + type.getQualifiedSourceName() + \")obj).length;\");\n\t\t}\n\t\tpc.print();\n\t\tp(\"\treturn 0;\");\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void getF () {\n\t\tp(\"public Object get(Field field, Object obj) throws IllegalAccessException {\");\n\t\tfor (SetterGetterStub stub : setterGetterStubs) {\n\t\t\tif (stub.enclosingType == null || stub.type == null || stub.unused) continue;\n\t\t\tp(\"   if(field.getter.equals(\\\"\" + stub.getter + \"\\\")) return \" + stub.getter + \"((\" + stub.enclosingType + \")obj);\");\n\t\t}\n\t\tp(\"   return null;\");\n\t\tp(\"}\");\n\t}","id":85686,"modified_method":"private void getF () {\n\t\tp(\"public Object get(Field field, Object obj) throws IllegalAccessException {\");\n\t\tp(\"    String param = field.getter;\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tfor (SetterGetterStub stub : setterGetterStubs) {\n\t\t\tif (stub.enclosingType == null || stub.type == null || stub.unused) continue;\n\t\t\tpc.add( stub.getter, \"return \" + stub.getter + \"((\" + stub.enclosingType + \")obj);\");\n\t\t}\n\t\tpc.print();\n\t\tp(\"   return null;\");\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void getArrayElementT () {\n\t\tp(\"public Object getArrayElement(Type type, Object obj, int i) {\");\n\t\tfor (JType type : types) {\n\t\t\tif (!(type instanceof JArrayType)) continue;\n\t\t\tp(\"   if(type.getName().equals(\\\"\" + type.getQualifiedSourceName() + \"\\\")) return ((\" + type.getQualifiedSourceName()\n\t\t\t\t+ \")obj)[i];\");\n\t\t}\n\t\tp(\"\treturn null;\");\n\t\tp(\"}\");\n\t}","id":85687,"modified_method":"private void getArrayElementT () {\n\t\tp(\"public Object getArrayElement(Type type, Object obj, int i) {\");\n\t\tp(\"    String param = type.getName();\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tfor (JType type : types) {\n\t\t\tif (!(type instanceof JArrayType)) continue;\n\t\t\tpc.add(type.getQualifiedSourceName(), \"return ((\" + type.getQualifiedSourceName() + \")obj)[i];\");\n\t\t}\n\t\tpc.print();\n\t\tp(\"\treturn null;\");\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void setF () {\n\t\tp(\"public void set(Field field, Object obj, Object value) throws IllegalAccessException {\");\n\t\tfor (SetterGetterStub stub : setterGetterStubs) {\n\t\t\tif (stub.enclosingType == null || stub.type == null || stub.isFinal || stub.unused) continue;\n\t\t\tp(\"   if(field.setter.equals(\\\"\" + stub.setter + \"\\\")) \" + stub.setter + \"((\" + stub.enclosingType + \")obj, value);\");\n\t\t}\n\t\tp(\"}\");\n\t}","id":85688,"modified_method":"private void setF () {\n\t\tp(\"public void set(Field field, Object obj, Object value) throws IllegalAccessException {\");\n\t\tp(\"    String param = field.setter;\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tfor (SetterGetterStub stub : setterGetterStubs) {\n\t\t\tif (stub.enclosingType == null || stub.type == null || stub.isFinal || stub.unused) continue;\n\t\t\tpc.add(stub.setter, stub.setter + \"((\" + stub.enclosingType + \")obj, value);\");\n\t\t}\n\t\tpc.print();\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void setArrayElementT () {\n\t\tp(\"public void setArrayElement(Type type, Object obj, int i, Object value) {\");\n\t\tfor (JType type : types) {\n\t\t\tif (!(type instanceof JArrayType)) continue;\n\t\t\tString value = ((JArrayType)type).getComponentType().getErasedType().getQualifiedSourceName();\n\t\t\tif (isPrimitive(value)) {\n\t\t\t\tvalue = castPrimitive(value, \"value\");\n\t\t\t} else {\n\t\t\t\tvalue = \"(\" + value + \")value\";\n\t\t\t}\n\t\t\tp(\"   if(type.getName().equals(\\\"\" + type.getQualifiedSourceName() + \"\\\")) ((\" + type.getQualifiedSourceName()\n\t\t\t\t+ \")obj)[i] = \" + value + \";\");\n\t\t}\n\t\tp(\"}\");\n\t}","id":85689,"modified_method":"private void setArrayElementT () {\n\t\tp(\"public void setArrayElement(Type type, Object obj, int i, Object value) {\");\n\t\tp(\"    String param = type.getName();\");\n\t\tSwitchedCodeBlocks pc = new SwitchedCodeBlocks();\n\t\tfor (JType type : types) {\n\t\t\tif (!(type instanceof JArrayType)) continue;\n\t\t\tString value = ((JArrayType)type).getComponentType().getErasedType().getQualifiedSourceName();\n\t\t\tif (isPrimitive(value)) {\n\t\t\t\tvalue = castPrimitive(value, \"value\");\n\t\t\t} else {\n\t\t\t\tvalue = \"(\" + value + \")value\";\n\t\t\t}\n\t\t\tpc.add(type.getQualifiedSourceName() , \"((\" + type.getQualifiedSourceName() + \")obj)[i] = \" + value + \";\");\n\t\t}\n\t\tpc.print();\n\t\tp(\"}\");\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void addParameters (MethodStub stub) {\n\t\tpn(\"(\" + stub.enclosingType + \")obj\" + (stub.parameterTypes.size() > 0 ? \",\" : \"\"));\n\t\tfor (int i = 0; i < stub.parameterTypes.size(); i++) {\n\t\t\tString paramType = stub.parameterTypes.get(i);\n\t\t\tif (isPrimitive(paramType)) {\n\t\t\t\tpn(castPrimitive(paramType, \"params[\" + i + \"]\") + (i < stub.parameterTypes.size() - 1 ? \", \" : \"\"));\n\t\t\t} else {\n\t\t\t\tpn(\"(\" + stub.parameterTypes.get(i) + \")params[\" + i + \"]\" + (i < stub.parameterTypes.size() - 1 ? \", \" : \"\"));\n\t\t\t}\n\t\t}\n\t}","id":85690,"modified_method":"private void addParameters (MethodStub stub) {\n\t\tpbn(\"(\" + stub.enclosingType + \")obj\" + (stub.parameterTypes.size() > 0 ? \",\" : \"\"));\n\t\tfor (int i = 0; i < stub.parameterTypes.size(); i++) {\n\t\t\tString paramType = stub.parameterTypes.get(i);\n\t\t\tif (isPrimitive(paramType)) {\n\t\t\t\tpbn(castPrimitive(paramType, \"params[\" + i + \"]\") + (i < stub.parameterTypes.size() - 1 ? \", \" : \"\"));\n\t\t\t} else {\n\t\t\t\tpbn(\"(\" + stub.parameterTypes.get(i) + \")params[\" + i + \"]\" + (i < stub.parameterTypes.size() - 1 ? \", \" : \"\"));\n\t\t\t}\n\t\t}\n\t}","commit_id":"fb56ae4a9cecdb911ac0ad74620ba357079096ec","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n    public void addGui(final DownloadDialog gui) {\n        JPanel dlg = new JPanel(new GridBagLayout());\n        gui.addDownloadAreaSelector(dlg, tr(\"Bookmarks\"));\n        GridBagConstraints gc = new GridBagConstraints();\n\n        bookmarks = new BookmarkList();\n        bookmarks.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n            @Override\n            public void valueChanged(ListSelectionEvent e) {\n                Bookmark b = bookmarks.getSelectedValue();\n                if (b != null) {\n                    gui.boundingBoxChanged(b.getArea(), BookmarkSelection.this);\n                }\n            }\n        });\n        bookmarks.addMouseListener(new DoubleClickAdapter());\n\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1.0;\n        gc.weighty = 0.0;\n        gc.gridwidth = 2;\n        dlg.add(buildDownloadAreaAddPanel(), gc);\n\n        gc.gridwidth = 1;\n        gc.gridx = 0;\n        gc.gridy = 1;\n        gc.fill = GridBagConstraints.VERTICAL;\n        gc.weightx = 0.0;\n        gc.weighty = 1.0;\n        dlg.add(buildButtonPanel(), gc);\n\n        gc.gridwidth = 1;\n        gc.gridx = 1;\n        gc.gridy = 1;\n        gc.fill = GridBagConstraints.BOTH;\n        gc.weightx = 1.0;\n        gc.weighty = 1.0;\n        gc.gridx = 1;\n        dlg.add(new JScrollPane(bookmarks), gc);\n\n        this.parent = gui;\n    }","id":85691,"modified_method":"@Override\n    public void addGui(final DownloadDialog gui) {\n        JPanel dlg = new JPanel(new GridBagLayout());\n        if (gui != null)\n            gui.addDownloadAreaSelector(dlg, tr(\"Bookmarks\"));\n        GridBagConstraints gc = new GridBagConstraints();\n\n        bookmarks = new BookmarkList();\n        bookmarks.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n            @Override\n            public void valueChanged(ListSelectionEvent e) {\n                Bookmark b = bookmarks.getSelectedValue();\n                if (b != null && gui != null) {\n                    gui.boundingBoxChanged(b.getArea(), BookmarkSelection.this);\n                }\n            }\n        });\n        bookmarks.addMouseListener(new DoubleClickAdapter());\n\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1.0;\n        gc.weighty = 0.0;\n        gc.gridwidth = 2;\n        dlg.add(buildDownloadAreaAddPanel(), gc);\n\n        gc.gridwidth = 1;\n        gc.gridx = 0;\n        gc.gridy = 1;\n        gc.fill = GridBagConstraints.VERTICAL;\n        gc.weightx = 0.0;\n        gc.weighty = 1.0;\n        dlg.add(buildButtonPanel(), gc);\n\n        gc.gridwidth = 1;\n        gc.gridx = 1;\n        gc.gridy = 1;\n        gc.fill = GridBagConstraints.BOTH;\n        gc.weightx = 1.0;\n        gc.weighty = 1.0;\n        gc.gridx = 1;\n        dlg.add(new JScrollPane(bookmarks), gc);\n\n        this.parent = gui;\n    }","commit_id":"4a73f7f640b2304d7503ff008ea3b722141aa66f","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void addGui(final DownloadDialog gui) {\n        buildDownloadAreaInputFields();\n        final JPanel dlg = new JPanel(new GridBagLayout());\n\n        tfOsmUrl.getDocument().addDocumentListener(new OsmUrlRefresher());\n\n        // select content on receiving focus. this seems to be the default in the\n        // windows look+feel but not for others. needs invokeLater to avoid strange\n        // side effects that will cancel out the newly made selection otherwise.\n        tfOsmUrl.addFocusListener(new SelectAllOnFocusHandler(tfOsmUrl));\n        tfOsmUrl.setLineWrap(true);\n        tfOsmUrl.setBorder(latlon[0].getBorder());\n\n        dlg.add(new JLabel(tr(\"min lat\")), GBC.std().insets(10, 20, 5, 0));\n        dlg.add(latlon[0], GBC.std().insets(0, 20, 0, 0));\n        dlg.add(new JLabel(tr(\"min lon\")), GBC.std().insets(10, 20, 5, 0));\n        dlg.add(latlon[1], GBC.eol().insets(0, 20, 0, 0));\n        dlg.add(new JLabel(tr(\"max lat\")), GBC.std().insets(10, 0, 5, 0));\n        dlg.add(latlon[2], GBC.std());\n        dlg.add(new JLabel(tr(\"max lon\")), GBC.std().insets(10, 0, 5, 0));\n        dlg.add(latlon[3], GBC.eol());\n\n        final JButton btnClear = new JButton(tr(\"Clear textarea\"));\n        btnClear.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent arg0) {\n                tfOsmUrl.setText(\"\");\n            }\n        });\n        dlg.add(btnClear, GBC.eol().insets(10, 20, 0, 0));\n\n        dlg.add(new JLabel(tr(\"URL from www.openstreetmap.org (you can paste an URL here to download the area)\")),\n                GBC.eol().insets(10, 5, 5, 0));\n        dlg.add(tfOsmUrl, GBC.eop().insets(10, 0, 5, 0).fill());\n        dlg.add(showUrl, GBC.eop().insets(10, 0, 5, 5));\n        showUrl.setEditable(false);\n        showUrl.setBackground(dlg.getBackground());\n        showUrl.addFocusListener(new SelectAllOnFocusHandler(showUrl));\n\n        gui.addDownloadAreaSelector(dlg, tr(\"Bounding Box\"));\n        this.parent = gui;\n    }","id":85692,"modified_method":"@Override\n    public void addGui(final DownloadDialog gui) {\n        buildDownloadAreaInputFields();\n        final JPanel dlg = new JPanel(new GridBagLayout());\n\n        tfOsmUrl.getDocument().addDocumentListener(new OsmUrlRefresher());\n\n        // select content on receiving focus. this seems to be the default in the\n        // windows look+feel but not for others. needs invokeLater to avoid strange\n        // side effects that will cancel out the newly made selection otherwise.\n        tfOsmUrl.addFocusListener(new SelectAllOnFocusHandler(tfOsmUrl));\n        tfOsmUrl.setLineWrap(true);\n        tfOsmUrl.setBorder(latlon[0].getBorder());\n\n        dlg.add(new JLabel(tr(\"min lat\")), GBC.std().insets(10, 20, 5, 0));\n        dlg.add(latlon[0], GBC.std().insets(0, 20, 0, 0));\n        dlg.add(new JLabel(tr(\"min lon\")), GBC.std().insets(10, 20, 5, 0));\n        dlg.add(latlon[1], GBC.eol().insets(0, 20, 0, 0));\n        dlg.add(new JLabel(tr(\"max lat\")), GBC.std().insets(10, 0, 5, 0));\n        dlg.add(latlon[2], GBC.std());\n        dlg.add(new JLabel(tr(\"max lon\")), GBC.std().insets(10, 0, 5, 0));\n        dlg.add(latlon[3], GBC.eol());\n\n        final JButton btnClear = new JButton(tr(\"Clear textarea\"));\n        btnClear.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent arg0) {\n                tfOsmUrl.setText(\"\");\n            }\n        });\n        dlg.add(btnClear, GBC.eol().insets(10, 20, 0, 0));\n\n        dlg.add(new JLabel(tr(\"URL from www.openstreetmap.org (you can paste an URL here to download the area)\")),\n                GBC.eol().insets(10, 5, 5, 0));\n        dlg.add(tfOsmUrl, GBC.eop().insets(10, 0, 5, 0).fill());\n        dlg.add(showUrl, GBC.eop().insets(10, 0, 5, 5));\n        showUrl.setEditable(false);\n        showUrl.setBackground(dlg.getBackground());\n        showUrl.addFocusListener(new SelectAllOnFocusHandler(showUrl));\n\n        if (gui != null)\n            gui.addDownloadAreaSelector(dlg, tr(\"Bounding Box\"));\n        this.parent = gui;\n    }","commit_id":"4a73f7f640b2304d7503ff008ea3b722141aa66f","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Adds a new tab to the download dialog in JOSM.\n     *\n     * This method is, for all intents and purposes, the constructor for this class.\n     */\n    @Override\n    public void addGui(final DownloadDialog gui) {\n        JPanel panel = new JPanel(new BorderLayout());\n        panel.add(buildSearchPanel(), BorderLayout.NORTH);\n\n        DefaultListSelectionModel selectionModel = new DefaultListSelectionModel();\n        model = new NamedResultTableModel(selectionModel);\n        columnmodel = new NamedResultTableColumnModel();\n        tblSearchResults = new JTable(model, columnmodel);\n        tblSearchResults.setSelectionModel(selectionModel);\n        JScrollPane scrollPane = new JScrollPane(tblSearchResults);\n        scrollPane.setPreferredSize(new Dimension(200, 200));\n        panel.add(scrollPane, BorderLayout.CENTER);\n\n        gui.addDownloadAreaSelector(panel, tr(\"Areas around places\"));\n\n        scrollPane.setPreferredSize(scrollPane.getPreferredSize());\n        tblSearchResults.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        tblSearchResults.getSelectionModel().addListSelectionListener(new ListSelectionHandler());\n        tblSearchResults.addMouseListener(new MouseAdapter() {\n            @Override public void mouseClicked(MouseEvent e) {\n                if (e.getClickCount() > 1) {\n                    SearchResult sr = model.getSelectedSearchResult();\n                    if (sr == null) return;\n                    parent.startDownload(sr.getDownloadArea());\n                }\n            }\n        });\n        parent = gui;\n    }","id":85693,"modified_method":"/**\n     * Adds a new tab to the download dialog in JOSM.\n     *\n     * This method is, for all intents and purposes, the constructor for this class.\n     */\n    @Override\n    public void addGui(final DownloadDialog gui) {\n        JPanel panel = new JPanel(new BorderLayout());\n        panel.add(buildSearchPanel(), BorderLayout.NORTH);\n\n        DefaultListSelectionModel selectionModel = new DefaultListSelectionModel();\n        model = new NamedResultTableModel(selectionModel);\n        columnmodel = new NamedResultTableColumnModel();\n        tblSearchResults = new JTable(model, columnmodel);\n        tblSearchResults.setSelectionModel(selectionModel);\n        JScrollPane scrollPane = new JScrollPane(tblSearchResults);\n        scrollPane.setPreferredSize(new Dimension(200, 200));\n        panel.add(scrollPane, BorderLayout.CENTER);\n\n        if (gui != null)\n            gui.addDownloadAreaSelector(panel, tr(\"Areas around places\"));\n\n        scrollPane.setPreferredSize(scrollPane.getPreferredSize());\n        tblSearchResults.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        tblSearchResults.getSelectionModel().addListSelectionListener(new ListSelectionHandler());\n        tblSearchResults.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                if (e.getClickCount() > 1) {\n                    SearchResult sr = model.getSelectedSearchResult();\n                    if (sr != null) {\n                        parent.startDownload(sr.getDownloadArea());\n                    }\n                }\n            }\n        });\n        parent = gui;\n    }","commit_id":"4a73f7f640b2304d7503ff008ea3b722141aa66f","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public Object getValueAt(int row, int column) {\n            if (data == null) return null;\n            return data.get(row);\n        }","id":85694,"modified_method":"@Override\n        public Object getValueAt(int row, int column) {\n            return data != null ? data.get(row) : null;\n        }","commit_id":"4a73f7f640b2304d7503ff008ea3b722141aa66f","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n        public int getRowCount() {\n            if (data == null) return 0;\n            return data.size();\n        }","id":85695,"modified_method":"@Override\n        public int getRowCount() {\n            return data != null ? data.size() : 0;\n        }","commit_id":"4a73f7f640b2304d7503ff008ea3b722141aa66f","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected final void createColumns() {\n            TableColumn col = null;\n            NamedResultCellRenderer renderer = new NamedResultCellRenderer();\n\n            // column 0 - Name\n            col = new TableColumn(0);\n            col.setHeaderValue(tr(\"Name\"));\n            col.setResizable(true);\n            col.setPreferredWidth(200);\n            col.setCellRenderer(renderer);\n            addColumn(col);\n\n            // column 1 - Version\n            col = new TableColumn(1);\n            col.setHeaderValue(tr(\"Type\"));\n            col.setResizable(true);\n            col.setPreferredWidth(100);\n            col.setCellRenderer(renderer);\n            addColumn(col);\n\n            // column 2 - Near\n            col3 = new TableColumn(2);\n            col3.setHeaderValue(SERVERS[0].thirdcol);\n            col3.setResizable(true);\n            col3.setPreferredWidth(100);\n            col3.setCellRenderer(renderer);\n            addColumn(col3);\n\n            // column 3 - Zoom\n            col4 = new TableColumn(3);\n            col4.setHeaderValue(SERVERS[0].fourthcol);\n            col4.setResizable(true);\n            col4.setPreferredWidth(50);\n            col4.setCellRenderer(renderer);\n            addColumn(col4);\n        }","id":85696,"modified_method":"protected final void createColumns() {\n            TableColumn col;\n            NamedResultCellRenderer renderer = new NamedResultCellRenderer();\n\n            // column 0 - Name\n            col = new TableColumn(0);\n            col.setHeaderValue(tr(\"Name\"));\n            col.setResizable(true);\n            col.setPreferredWidth(200);\n            col.setCellRenderer(renderer);\n            addColumn(col);\n\n            // column 1 - Version\n            col = new TableColumn(1);\n            col.setHeaderValue(tr(\"Type\"));\n            col.setResizable(true);\n            col.setPreferredWidth(100);\n            col.setCellRenderer(renderer);\n            addColumn(col);\n\n            // column 2 - Near\n            col3 = new TableColumn(2);\n            col3.setHeaderValue(SERVERS[0].thirdcol);\n            col3.setResizable(true);\n            col3.setPreferredWidth(100);\n            col3.setCellRenderer(renderer);\n            addColumn(col3);\n\n            // column 3 - Zoom\n            col4 = new TableColumn(3);\n            col4.setHeaderValue(SERVERS[0].fourthcol);\n            col4.setResizable(true);\n            col4.setPreferredWidth(50);\n            col4.setCellRenderer(renderer);\n            addColumn(col4);\n        }","commit_id":"4a73f7f640b2304d7503ff008ea3b722141aa66f","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void addGui(final DownloadDialog gui) {\n        gui.addDownloadAreaSelector(chooser, tr(\"Tile Numbers\"));\n        parent = gui;\n    }","id":85697,"modified_method":"@Override\n    public void addGui(final DownloadDialog gui) {\n        if (gui != null)\n            gui.addDownloadAreaSelector(chooser, tr(\"Tile Numbers\"));\n        parent = gui;\n    }","commit_id":"4a73f7f640b2304d7503ff008ea3b722141aa66f","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      Shortcut[] checkboxShortcuts = KeymapManager.getInstance().getActiveKeymap().getShortcuts(AddLanguageImport_Action.this.getActionId());\n      ImportHelper.addLanguageImport(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), new CustomShortcutSet(checkboxShortcuts));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddLanguageImport\", t);\n      }\n    }\n  }","id":85698,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ImportHelper.addLanguageImport(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), AddLanguageImport_Action.this);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddLanguageImport\", t);\n      }\n    }\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> initialText = new Wrappers._T<String>(\"\");\n\n      final EditorCell_Label errorLabel = AddModelImportByRoot_Action.this.getErrorCell(_params);\n      final SNode unresolvedReference = SNodeOperations.as(((SNode) MapSequence.fromMap(_params).get(\"node\")), \"jetbrains.mps.baseLanguage.structure.UnresolvedNameReference\");\n\n      if (errorLabel != null) {\n        initialText.value = errorLabel.getRenderedText();\n      } else if (unresolvedReference != null) {\n        initialText.value = SPropertyOperations.getString(unresolvedReference, \"resolveName\");\n      }\n\n      Shortcut[] checkboxShortcut = KeymapManager.getInstance().getActiveKeymap().getShortcuts(AddModelImportByRoot_Action.this.getActionId());\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), initialText.value, new CustomShortcutSet(checkboxShortcut), new ImportHelper.ModelImportByRootCallback() {\n        public void importForRootAdded(String rootName) {\n          String textToMatch = (rootName != null ?\n            rootName :\n            initialText.value\n          );\n          if (textToMatch.length() == 0) {\n            return;\n          }\n          NodeSubstituteInfo substituteInfo = null;\n          if (errorLabel != null) {\n            substituteInfo = errorLabel.getSubstituteInfo();\n          } else if (unresolvedReference != null && ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")) != null) {\n            substituteInfo = new DefaultChildSubstituteInfo(SNodeOperations.getParent(unresolvedReference), unresolvedReference, SNodeOperations.getContainingLinkDeclaration(unresolvedReference), ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")));\n            substituteInfo.setOriginalText(initialText.value);\n          }\n          if (substituteInfo == null) {\n            return;\n          }\n          substituteInfo.invalidateActions();\n          List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(textToMatch, true);\n          if ((int) ListSequence.fromList(matchingActions).count() == 1) {\n            ListSequence.fromList(matchingActions).first().substitute(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")), initialText.value);\n          }\n        }\n      });\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","id":85699,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<String> initialText = new Wrappers._T<String>(\"\");\n\n      final EditorCell_Label errorLabel = AddModelImportByRoot_Action.this.getErrorCell(_params);\n      final SNode unresolvedReference = SNodeOperations.as(((SNode) MapSequence.fromMap(_params).get(\"node\")), \"jetbrains.mps.baseLanguage.structure.UnresolvedNameReference\");\n\n      if (errorLabel != null) {\n        initialText.value = errorLabel.getRenderedText();\n      } else if (unresolvedReference != null) {\n        initialText.value = SPropertyOperations.getString(unresolvedReference, \"resolveName\");\n      }\n\n      ImportHelper.addModelImportByRoot(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), initialText.value, AddModelImportByRoot_Action.this, new ImportHelper.ModelImportByRootCallback() {\n        public void importForRootAdded(String rootName) {\n          String textToMatch = (rootName != null ?\n            rootName :\n            initialText.value\n          );\n          if (textToMatch.length() == 0) {\n            return;\n          }\n          NodeSubstituteInfo substituteInfo = null;\n          if (errorLabel != null) {\n            substituteInfo = errorLabel.getSubstituteInfo();\n          } else if (unresolvedReference != null && ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")) != null) {\n            substituteInfo = new DefaultChildSubstituteInfo(SNodeOperations.getParent(unresolvedReference), unresolvedReference, SNodeOperations.getContainingLinkDeclaration(unresolvedReference), ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")));\n            substituteInfo.setOriginalText(initialText.value);\n          }\n          if (substituteInfo == null) {\n            return;\n          }\n          substituteInfo.invalidateActions();\n          List<INodeSubstituteAction> matchingActions = substituteInfo.getMatchingActions(textToMatch, true);\n          if ((int) ListSequence.fromList(matchingActions).count() == 1) {\n            ListSequence.fromList(matchingActions).first().substitute(((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")), initialText.value);\n          }\n        }\n      });\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImportByRoot\", t);\n      }\n    }\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      Shortcut[] checkboxShortcuts = KeymapManager.getInstance().getActiveKeymap().getShortcuts(AddModelImport_Action.this.getActionId());\n      ImportHelper.addModelImport(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), new CustomShortcutSet(checkboxShortcuts));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImport\", t);\n      }\n    }\n  }","id":85700,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ImportHelper.addModelImport(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IModule) MapSequence.fromMap(_params).get(\"module\")), ((SModelDescriptor) MapSequence.fromMap(_params).get(\"model\")), AddModelImport_Action.this);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"AddModelImport\", t);\n      }\n    }\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void showSimpleNodeChooser(final List<SNode> nodes, final ChooserCallback<SNode> callback, final boolean willOpenEditor) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseNodeModel goToNodeModel = new BaseNodeModel(project) {\n      public NavigationItem doGetNavigationItem(final SNode node) {\n        return new BaseNodeItem(node) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getNode());\n          }\n        };\n      }\n\n      public SNode[] find(IScope scope) {\n        return nodes.toArray(new SNode[nodes.size()]);\n      }\n\n      @Override\n      public boolean willOpenEditor() {\n        return willOpenEditor;\n      }\n    };\n\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":85701,"modified_method":"public static void showSimpleNodeChooser(final List<SNode> nodes, final ChooserCallback<SNode> callback, final boolean willOpenEditor) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseNodeModel goToNodeModel = new BaseNodeModel(project) {\n      public NavigationItem doGetNavigationItem(final SNode node) {\n        return new BaseNodeItem(node) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getNode());\n          }\n        };\n      }\n\n      public SNode[] find(IScope scope) {\n        return nodes.toArray(new SNode[nodes.size()]);\n      }\n\n      @Override\n      public boolean willOpenEditor() {\n        return willOpenEditor;\n      }\n    };\n\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, null);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void showSimpleModuleChooser(final List<ModuleReference> modules, final String entityString, final ChooserCallback<ModuleReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseMPSChooseModel<ModuleReference> goToModuleModel = new BaseMPSChooseModel<ModuleReference>(project, entityString) {\n      public String doGetFullName(Object element) {\n        return ((BaseModuleItem) element).getModuleReference().getModuleFqName();\n      }\n\n      public String doGetObjectName(ModuleReference module) {\n        return module.getModuleFqName();\n      }\n\n      public NavigationItem doGetNavigationItem(final ModuleReference module) {\n        return new BaseModuleItem(module) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(module);\n          }\n        };\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        return (ModuleReference[]) modules.toArray();\n      }\n\n      @Override\n      public boolean willOpenEditor() {\n        return false;\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModuleModel);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":85702,"modified_method":"public static void showSimpleModuleChooser(final List<ModuleReference> modules, final String entityString, final ChooserCallback<ModuleReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseMPSChooseModel<ModuleReference> goToModuleModel = new BaseMPSChooseModel<ModuleReference>(project, entityString) {\n      public String doGetFullName(Object element) {\n        return ((BaseModuleItem) element).getModuleReference().getModuleFqName();\n      }\n\n      public String doGetObjectName(ModuleReference module) {\n        return module.getModuleFqName();\n      }\n\n      public NavigationItem doGetNavigationItem(final ModuleReference module) {\n        return new BaseModuleItem(module) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(module);\n          }\n        };\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        return (ModuleReference[]) modules.toArray();\n      }\n\n      @Override\n      public boolean willOpenEditor() {\n        return false;\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModuleModel, null);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void showSimpleModelChooser(final List<SModelReference> models, final ChooserCallback<SModelReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getModelReference());\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        return models.toArray(new SModelReference[models.size()]);\n      }\n    };\n\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":85703,"modified_method":"public static void showSimpleModelChooser(final List<SModelReference> models, final ChooserCallback<SModelReference> callback) {\n    DataContext dataContext = DataManager.getInstance().getDataContext();\n    final Project project = MPSDataKeys.PROJECT.getData(dataContext);\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            callback.execute(getModelReference());\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        return models.toArray(new SModelReference[models.size()]);\n      }\n    };\n\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel, null);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            ((NavigationItem) element).navigate(true);\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.model\");\n    //PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            final SModelDescriptor md = SModelRepository.getInstance().getModelDescriptor(modelReference);\n\n            VirtualFile modelFile = ModelAccess.instance().runReadAction(new Computable<VirtualFile>() {\n              public VirtualFile compute() {\n                return ModelUtil.getFileByModel(md.getSModel());\n              }\n            });\n\n            PsiElement modelElement = PsiManager.getInstance(project).findFile(modelFile);\n            new ProjectPaneSelectInTarget(project).select(modelElement, true);\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> result = new ArrayList<SModelReference>();\n        for (SModelDescriptor md : iter) {\n          result.add(md.getSModelReference());\n        }\n        return result.toArray(new SModelReference[result.size()]);\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel);\n    popup.setShowListForEmptyPattern(true);\n    popup.setCheckBoxShortcut(getShortcutSet());\n    popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n  }","id":85704,"modified_method":"public void doExecute(AnActionEvent e, Map<String, Object> _params) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    assert project != null;\n\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.model\");\n    //PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new BaseModelItem(modelReference) {\n          public void navigate(boolean requestFocus) {\n            final SModelDescriptor md = SModelRepository.getInstance().getModelDescriptor(modelReference);\n\n            VirtualFile modelFile = ModelAccess.instance().runReadAction(new Computable<VirtualFile>() {\n              public VirtualFile compute() {\n                return ModelUtil.getFileByModel(md.getSModel());\n              }\n            });\n\n            PsiElement modelElement = PsiManager.getInstance(project).findFile(modelFile);\n            new ProjectPaneSelectInTarget(project).select(modelElement, true);\n          }\n        };\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> result = new ArrayList<SModelReference>();\n        for (SModelDescriptor md : iter) {\n          result.add(md.getSModelReference());\n        }\n        return result.toArray(new SModelReference[result.size()]);\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel, null);\n    popup.setShowListForEmptyPattern(true);\n    popup.setCheckBoxShortcut(getShortcutSet());\n    popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Project project = event.getData(PlatformDataKeys.PROJECT);\n      assert project != null;\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.model\");\n      // PsiDocumentManager.getInstance(project).commitAllDocuments(); \n      BaseModelModel goToModelModel = new BaseModelModel(project) {\n        public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n          return new BaseModelItem(modelReference) {\n            public void navigate(boolean requestFocus) {\n              ProjectPane projectPane = ProjectPane.getInstance(project);\n              SModelDescriptor md = SModelRepository.getInstance().getModelDescriptor(modelReference);\n              projectPane.selectModel(md, true);\n            }\n          };\n        }\n\n        public SModelReference[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor) || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n          List<SModelReference> result = new ArrayList<SModelReference>();\n          for (SModelDescriptor md : iter) {\n            result.add(md.getSModelReference());\n          }\n          return result.toArray(new SModelReference[result.size()]);\n        }\n      };\n      ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel);\n      popup.setShowListForEmptyPattern(true);\n      Shortcut[] shortcuts = KeymapManager.getInstance().getActiveKeymap().getShortcuts(GoToModel_Action.this.getActionId());\n      popup.setCheckBoxShortcut(new CustomShortcutSet(shortcuts));\n\n      popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"GoToModel\", t);\n      }\n    }\n  }","id":85705,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Project project = event.getData(PlatformDataKeys.PROJECT);\n      assert project != null;\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.model\");\n      // PsiDocumentManager.getInstance(project).commitAllDocuments(); \n      BaseModelModel goToModelModel = new BaseModelModel(project) {\n        public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n          return new BaseModelItem(modelReference) {\n            public void navigate(boolean requestFocus) {\n              ProjectPane projectPane = ProjectPane.getInstance(project);\n              SModelDescriptor md = SModelRepository.getInstance().getModelDescriptor(modelReference);\n              projectPane.selectModel(md, true);\n            }\n          };\n        }\n\n        public SModelReference[] find(IScope scope) {\n          Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n            public boolean met(SModelDescriptor modelDescriptor) {\n              boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor) || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n              boolean hasModule = modelDescriptor.getModule() != null;\n              return rightStereotype && hasModule;\n            }\n          };\n          ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n          List<SModelReference> result = new ArrayList<SModelReference>();\n          for (SModelDescriptor md : iter) {\n            result.add(md.getSModelReference());\n          }\n          return result.toArray(new SModelReference[result.size()]);\n        }\n      };\n      ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel, GoToModel_Action.this);\n      popup.setShowListForEmptyPattern(true);\n\n      popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"GoToModel\", t);\n      }\n    }\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Project project = event.getData(PlatformDataKeys.PROJECT);\n      assert project != null;\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.module\");\n      // PsiDocumentManager.getInstance(project).commitAllDocuments(); \n      BaseModuleModel goToModuleModel = new BaseModuleModel(project, \"module\") {\n        public NavigationItem doGetNavigationItem(final ModuleReference ref) {\n          return new BaseModuleItem(ref) {\n            public void navigate(boolean requestFocus) {\n              ProjectPane projectPane = ProjectPane.getInstance(project);\n              IModule module = MPSModuleRepository.getInstance().getModule(ref);\n              projectPane.selectModule(module, true);\n            }\n          };\n        }\n\n        public ModuleReference[] find(IScope scope) {\n          List<ModuleReference> modules = new ArrayList<ModuleReference>();\n          for (IModule module : scope.getVisibleModules()) {\n            if (!((module instanceof Solution || module instanceof Language || module instanceof DevKit))) {\n              continue;\n            }\n            modules.add(module.getModuleReference());\n          }\n          return modules.toArray(new ModuleReference[modules.size()]);\n        }\n      };\n      ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModuleModel);\n      Shortcut[] shortcuts = KeymapManager.getInstance().getActiveKeymap().getShortcuts(GoToModule_Action.this.getActionId());\n      popup.setCheckBoxShortcut(new CustomShortcutSet(shortcuts));\n\n      popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"GoToModule\", t);\n      }\n    }\n  }","id":85706,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Project project = event.getData(PlatformDataKeys.PROJECT);\n      assert project != null;\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.module\");\n      // PsiDocumentManager.getInstance(project).commitAllDocuments(); \n      BaseModuleModel goToModuleModel = new BaseModuleModel(project, \"module\") {\n        public NavigationItem doGetNavigationItem(final ModuleReference ref) {\n          return new BaseModuleItem(ref) {\n            public void navigate(boolean requestFocus) {\n              ProjectPane projectPane = ProjectPane.getInstance(project);\n              IModule module = MPSModuleRepository.getInstance().getModule(ref);\n              projectPane.selectModule(module, true);\n            }\n          };\n        }\n\n        public ModuleReference[] find(IScope scope) {\n          List<ModuleReference> modules = new ArrayList<ModuleReference>();\n          for (IModule module : scope.getVisibleModules()) {\n            if (!((module instanceof Solution || module instanceof Language || module instanceof DevKit))) {\n              continue;\n            }\n            modules.add(module.getModuleReference());\n          }\n          return modules.toArray(new ModuleReference[modules.size()]);\n        }\n      };\n      ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModuleModel, GoToModule_Action.this);\n\n      popup.invoke(new NavigateCallback(), ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"GoToModule\", t);\n      }\n    }\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.rootNode\");\n\n      Project project = event.getData(PlatformDataKeys.PROJECT);\n      assert project != null;\n\n      MPSChooseSNodeDescriptor chooseSNodeResult = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex());\n      ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, chooseSNodeResult);\n      Shortcut[] shortcuts = KeymapManager.getInstance().getActiveKeymap().getShortcuts(GoToRootNode_Action.this.getActionId());\n      popup.setCheckBoxShortcut(new CustomShortcutSet(shortcuts));\n\n      popup.invoke(new ChooseByNamePopupComponent.Callback() {\n        public void onClose() {\n        }\n\n        public void elementChosen(Object element) {\n          ((NavigationItem) element).navigate(true);\n        }\n      }, ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"GoToRootNode\", t);\n      }\n    }\n  }","id":85707,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"navigation.goto.rootNode\");\n\n      Project project = event.getData(PlatformDataKeys.PROJECT);\n      assert project != null;\n\n      MPSChooseSNodeDescriptor chooseSNodeResult = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex());\n      ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, chooseSNodeResult, GoToRootNode_Action.this);\n\n      popup.invoke(new ChooseByNamePopupComponent.Callback() {\n        public void onClose() {\n        }\n\n        public void elementChosen(Object element) {\n          ((NavigationItem) element).navigate(true);\n        }\n      }, ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"GoToRootNode\", t);\n      }\n    }\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addLanguageImport(Project project, final IModule contextModule, final SModelDescriptor model,\n                                       @Nullable ShortcutSet checkboxShortcut) {\n    BaseLanguageModel goToLanguageModel = new BaseLanguageModel(project) {\n      public NavigationItem doGetNavigationItem(ModuleReference ref) {\n        return new AddLanguageItem(ref, contextModule, model);\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        ArrayList<ModuleReference> res = new ArrayList<ModuleReference>();\n        for (Language l : scope.getVisibleLanguages()) {\n          res.add(l.getModuleReference());\n        }\n        return res.toArray(new ModuleReference[res.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import language:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToLanguageModel);\n    if (checkboxShortcut != null) {\n      popup.setCheckBoxShortcut(checkboxShortcut);\n    }\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":85708,"modified_method":"public static void addLanguageImport(Project project, final IModule contextModule, final SModelDescriptor model,\n                                       @Nullable BaseAction parentAction) {\n    BaseLanguageModel goToLanguageModel = new BaseLanguageModel(project) {\n      public NavigationItem doGetNavigationItem(ModuleReference ref) {\n        return new AddLanguageItem(ref, contextModule, model);\n      }\n\n      public ModuleReference[] find(IScope scope) {\n        ArrayList<ModuleReference> res = new ArrayList<ModuleReference>();\n        for (Language l : scope.getVisibleLanguages()) {\n          res.add(l.getModuleReference());\n        }\n        return res.toArray(new ModuleReference[res.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import language:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToLanguageModel, parentAction);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText, @Nullable ShortcutSet checkboxShortcut, final ModelImportByRootCallback callback) {\n    BaseMPSChooseModel goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n      public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n        return new RootNodeElement(object) {\n          public void navigate(boolean requestFocus) {\n            ModelAccess.assertLegalRead();\n            SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n            LOG.assertLog(descriptor != null, \"Caches seems to be corrupted or the model was removed: model \" + object.getModelReference().getLongName() + \" does not exist. Please check model existence manually and specify it in bug report\");\n            SModel modelToImport = descriptor.getSModel();\n            SNodeId id = object.getId();\n            String idString = id == null ? \"\" : \" (id:\" + id.toString() + \")\";\n            String nameString = object.getNodeName() == null ? \"<no name>\" : object.getNodeName();\n            LOG.assertLog(object.getNode(modelToImport) != null, \"Caches seems to be corrupted or the node was removed: model \" + modelToImport.getLongName() + \" does not seem to contain node \" + nameString + idString + \". Please check node existence manually and specify it in bug report\");\n            new AddModelItem(project, model, modelToImport.getSModelReference(), contextModule).navigate(requestFocus);\n          }\n        };\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import model that contains root:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText);\n    if (checkboxShortcut != null) {\n      popup.setCheckBoxShortcut(checkboxShortcut);\n    }\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            NavigationItem navigationItem = (NavigationItem) element;\n            navigationItem.navigate(true);\n            callback.importForRootAdded(navigationItem.getPresentation().getPresentableText());\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":85709,"modified_method":"public static void addModelImportByRoot(final Project project, final IModule contextModule, final SModelDescriptor model,\n                                          String initialText, @Nullable BaseAction parentAction, final ModelImportByRootCallback callback) {\n    BaseMPSChooseModel goToNodeModel = new MPSChooseSNodeDescriptor(project, new RootNodeNameIndex()) {\n      public NavigationItem doGetNavigationItem(final BaseSNodeDescriptor object) {\n        return new RootNodeElement(object) {\n          public void navigate(boolean requestFocus) {\n            ModelAccess.assertLegalRead();\n            SModelDescriptor descriptor = GlobalScope.getInstance().getModelDescriptor(object.getModelReference());\n            LOG.assertLog(descriptor != null, \"Caches seems to be corrupted or the model was removed: model \" + object.getModelReference().getLongName() + \" does not exist. Please check model existence manually and specify it in bug report\");\n            SModel modelToImport = descriptor.getSModel();\n            SNodeId id = object.getId();\n            String idString = id == null ? \"\" : \" (id:\" + id.toString() + \")\";\n            String nameString = object.getNodeName() == null ? \"<no name>\" : object.getNodeName();\n            LOG.assertLog(object.getNode(modelToImport) != null, \"Caches seems to be corrupted or the node was removed: model \" + modelToImport.getLongName() + \" does not seem to contain node \" + nameString + idString + \". Please check node existence manually and specify it in bug report\");\n            new AddModelItem(project, model, modelToImport.getSModelReference(), contextModule).navigate(requestFocus);\n          }\n        };\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import model that contains root:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText, parentAction);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            NavigationItem navigationItem = (NavigationItem) element;\n            navigationItem.navigate(true);\n            callback.importForRootAdded(navigationItem.getPresentation().getPresentableText());\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImport(final Project project, final IModule module, final SModelDescriptor model,\n                                    @Nullable ShortcutSet checkboxShortcut) {\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new AddModelItem(project, model, modelReference, module);\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> filteredModelRefs = new ArrayList<SModelReference>();\n        for (SModelDescriptor md : iter) {\n          filteredModelRefs.add(md.getSModelReference());\n        }\n        return filteredModelRefs.toArray(new SModelReference[filteredModelRefs.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import model:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel);\n    if (checkboxShortcut != null) {\n      popup.setCheckBoxShortcut(checkboxShortcut);\n    }\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":85710,"modified_method":"public static void addModelImport(final Project project, final IModule module, final SModelDescriptor model,\n                                    @Nullable BaseAction parentAction) {\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new AddModelItem(project, model, modelReference, module);\n      }\n\n      public SModelReference[] find(IScope scope) {\n        Condition<SModelDescriptor> cond = new Condition<SModelDescriptor>() {\n          public boolean met(SModelDescriptor modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n              || SModelStereotype.isStubModelStereotype(modelDescriptor.getStereotype());\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModelDescriptor> iter = new ConditionalIterable<SModelDescriptor>(scope.getModelDescriptors(), cond);\n        List<SModelReference> filteredModelRefs = new ArrayList<SModelReference>();\n        for (SModelDescriptor md : iter) {\n          filteredModelRefs.add(md.getSModelReference());\n        }\n        return filteredModelRefs.toArray(new SModelReference[filteredModelRefs.size()]);\n      }\n\n      @Nullable\n      public String getPromptText() {\n        return \"Import model:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel, parentAction);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      public void elementChosen(final Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static ChooseByNamePopup createNodePopup(Project p, ChooseByNameModel m) {\n    return ChooseByNamePopup.createPopup(p, m, nodeProvider());\n  }","id":85711,"modified_method":"public static ChooseByNamePopup createNodePopup(Project p, ChooseByNameModel m, @Nullable BaseAction parentAction) {\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(p, m, nodeProvider());\n    setCheckboxShortcutFromAction(popup, parentAction);\n    return popup;\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static ChooseByNamePopup createNodePopup(Project p, ChooseByNameModel m, String initialText) {\n    return ChooseByNamePopup.createPopup(p, m, nodeProvider(), initialText);\n  }","id":85712,"modified_method":"public static ChooseByNamePopup createNodePopup(Project p, ChooseByNameModel m, String initialText, @Nullable BaseAction parentAction) {\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(p, m, nodeProvider(), initialText);\n    setCheckboxShortcutFromAction(popup, parentAction);\n    return popup;\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static ChooseByNamePopup createPackagePopup(Project p, ChooseByNameModel m) {\n    return ChooseByNamePopup.createPopup(p, m, packageProvider());\n  }","id":85713,"modified_method":"public static ChooseByNamePopup createPackagePopup(Project p, ChooseByNameModel m, @Nullable BaseAction parentAction) {\n    ChooseByNamePopup popup = ChooseByNamePopup.createPopup(p, m, packageProvider());\n    setCheckboxShortcutFromAction(popup, parentAction);\n    return popup;\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<IModule> modules = ListSequence.fromList(new ArrayList<IModule>());\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modules).addSequence(SetSequence.fromSet(MPSModuleRepository.getInstance().getAllModules()));\n        }\n      });\n      BaseModuleModel baseSolutionModel = new BaseModuleModel(((Project) MapSequence.fromMap(_params).get(\"project\")), \"runtime module\") {\n        public ModuleReference[] find(IScope p0) {\n          return ListSequence.fromList(modules).select(new ISelector<IModule, ModuleReference>() {\n            public ModuleReference select(IModule it) {\n              return it.getModuleReference();\n            }\n          }).toGenericArray(ModuleReference.class);\n        }\n\n        public NavigationItem doGetNavigationItem(final ModuleReference module) {\n          return new BaseModuleItem(module) {\n            public void navigate(boolean p0) {\n              if (module == null) {\n                return;\n              }\n              final Language language = (Language) ((IModule) MapSequence.fromMap(_params).get(\"contextModule\"));\n              language.getModuleDescriptor().getRuntimeModules().add(module);\n              final MPSTree mpsTree = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"treeNode\"))).getTree();\n              ModelAccess.instance().runWriteInEDT(new Runnable() {\n                public void run() {\n                  language.save();\n                  mpsTree.rebuildLater();\n                }\n              });\n            }\n          };\n        }\n      };\n      ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(((Project) MapSequence.fromMap(_params).get(\"project\")), baseSolutionModel);\n      popup.invoke(new ChooseByNamePopupComponent.Callback() {\n        public void elementChosen(Object p0) {\n          ((NavigationItem) p0).navigate(true);\n        }\n      }, ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewRuntimeModule\", t);\n      }\n    }\n  }","id":85714,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<IModule> modules = ListSequence.fromList(new ArrayList<IModule>());\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modules).addSequence(SetSequence.fromSet(MPSModuleRepository.getInstance().getAllModules()));\n        }\n      });\n      BaseModuleModel baseSolutionModel = new BaseModuleModel(((Project) MapSequence.fromMap(_params).get(\"project\")), \"runtime module\") {\n        public ModuleReference[] find(IScope p0) {\n          return ListSequence.fromList(modules).select(new ISelector<IModule, ModuleReference>() {\n            public ModuleReference select(IModule it) {\n              return it.getModuleReference();\n            }\n          }).toGenericArray(ModuleReference.class);\n        }\n\n        public NavigationItem doGetNavigationItem(final ModuleReference module) {\n          return new BaseModuleItem(module) {\n            public void navigate(boolean p0) {\n              if (module == null) {\n                return;\n              }\n              final Language language = (Language) ((IModule) MapSequence.fromMap(_params).get(\"contextModule\"));\n              language.getModuleDescriptor().getRuntimeModules().add(module);\n              final MPSTree mpsTree = ((MPSTreeNode) ((TreeNode) MapSequence.fromMap(_params).get(\"treeNode\"))).getTree();\n              ModelAccess.instance().runWriteInEDT(new Runnable() {\n                public void run() {\n                  language.save();\n                  mpsTree.rebuildLater();\n                }\n              });\n            }\n          };\n        }\n      };\n      ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(((Project) MapSequence.fromMap(_params).get(\"project\")), baseSolutionModel, NewRuntimeModule_Action.this);\n      popup.invoke(new ChooseByNamePopupComponent.Callback() {\n        public void elementChosen(Object p0) {\n          ((NavigationItem) p0).navigate(true);\n        }\n      }, ModalityState.current(), true);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewRuntimeModule\", t);\n      }\n    }\n  }","commit_id":"84a37e728d3b07b8c1724302961247114fcd0637","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n        public boolean equals (Object obj) {\n            if (obj == null) return false;\n            if (obj == this) return true;\n            if (obj instanceof ParsedColInfo == false) return false;\n            ParsedColInfo col = (ParsedColInfo) obj;\n            if (alias == col.alias && columnName == col.columnName && tableName == col.tableName\n                    && expression.equals(col.expression) && index == col.index && size == col.size\n                    && orderBy == col.orderBy && ascending == col.ascending && groupBy == col.groupBy\n                    && finalOutput == col.finalOutput) {\n                return true;\n            }\n            return false;\n        }","id":85715,"modified_method":"@Override\n        public boolean equals (Object obj) {\n            if (obj == null) return false;\n            if (obj == this) return true;\n            if (obj instanceof ParsedColInfo == false) return false;\n            ParsedColInfo col = (ParsedColInfo) obj;\n            if (alias.equals(col.alias ) && columnName.equals(col.columnName) && tableName.equals(col.tableName)\n                    && expression.equals(col.expression) && index == col.index && size == col.size\n                    && orderBy == col.orderBy && ascending == col.ascending && groupBy == col.groupBy\n                    && finalOutput == col.finalOutput) {\n                return true;\n            }\n            return false;\n        }","commit_id":"12f78d868c45851bb1ffc46a884641376dbebaf8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public boolean simpleEquals (Object obj) {\n            if (obj == null) return false;\n            if (obj == this) return true;\n            if (obj instanceof ParsedColInfo == false) return false;\n            ParsedColInfo col = (ParsedColInfo) obj;\n            if (alias == col.alias && columnName == col.columnName && tableName == col.tableName\n                    && expression.equals(col.expression) )\n                return true;\n            return false;\n        }","id":85716,"modified_method":"public boolean simpleEquals (Object obj) {\n            if (obj == null) return false;\n            if (obj == this) return true;\n            if (obj instanceof ParsedColInfo == false) return false;\n            ParsedColInfo col = (ParsedColInfo) obj;\n            if (alias.equals(col.alias ) && columnName.equals(col.columnName) && tableName.equals(col.tableName)\n                    && expression.equals(col.expression) )\n                return true;\n            return false;\n        }","commit_id":"12f78d868c45851bb1ffc46a884641376dbebaf8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    void parse(VoltXMLElement stmtNode) {\n        String node;\n\n        if ((node = stmtNode.attributes.get(\"limit\")) != null)\n            limit = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"offset\")) != null)\n            offset = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"limit_paramid\")) != null)\n            limitParameterId = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"offset_paramid\")) != null)\n            offsetParameterId = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"distinct\")) != null)\n            distinct = Boolean.parseBoolean(node);\n\n        // limit and offset can't have both value and parameter\n        if (limit != -1) assert limitParameterId == -1 : \"Parsed value and param. limit.\";\n        if (offset != 0) assert offsetParameterId == -1 : \"Parsed value and param. offset.\";\n\n        // I want to extract groupby, orderby first before processing displayColumns\n        // Because I may have a fancy complex display\n        for (VoltXMLElement child : stmtNode.children) {\n            if (child.name.equalsIgnoreCase(\"ordercolumns\"))\n                parseOrderColumns(child);\n            else if (child.name.equalsIgnoreCase(\"groupcolumns\")) {\n                parseGroupByColumns(child);\n            }\n        }\n        for (VoltXMLElement child : stmtNode.children) {\n            if (child.name.equalsIgnoreCase(\"columns\"))\n                parseDisplayColumns(child);\n        }\n\n        // Assume that we do not support group by Complex expressions right now\n        // Use parseAggColumns() to parse the group by ParsedColInfo when we want to support it\n        insertToAggResultColumns(groupByColumns);\n        //TODO(XIN): double check whether should we add orderColumns\n        // Assume that we do not support order by Complex expressions which do not appear in\n        // display columns right now\n        //insertToAggResultColumns(orderColumns);\n\n        // Generate New output Schema, replace Aggs with TVEs for group by and order by\n        evaluateColumns();\n    }","id":85717,"modified_method":"@Override\n    void parse(VoltXMLElement stmtNode) {\n        String node;\n\n        if ((node = stmtNode.attributes.get(\"limit\")) != null)\n            limit = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"offset\")) != null)\n            offset = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"limit_paramid\")) != null)\n            limitParameterId = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"offset_paramid\")) != null)\n            offsetParameterId = Long.parseLong(node);\n        if ((node = stmtNode.attributes.get(\"distinct\")) != null)\n            distinct = Boolean.parseBoolean(node);\n\n        // limit and offset can't have both value and parameter\n        if (limit != -1) assert limitParameterId == -1 : \"Parsed value and param. limit.\";\n        if (offset != 0) assert offsetParameterId == -1 : \"Parsed value and param. offset.\";\n\n        // I want to extract groupby, orderby first before processing displayColumns\n        // Because I may have a fancy complex display\n        for (VoltXMLElement child : stmtNode.children) {\n            if (child.name.equalsIgnoreCase(\"ordercolumns\"))\n                parseOrderColumns(child);\n            else if (child.name.equalsIgnoreCase(\"groupcolumns\")) {\n                parseGroupByColumns(child);\n            }\n        }\n        for (VoltXMLElement child : stmtNode.children) {\n            if (child.name.equalsIgnoreCase(\"columns\"))\n                parseDisplayColumns(child);\n        }\n\n        // Assume that we do not support group by Complex expressions right now\n        // Use parseAggColumns() to parse the group by ParsedColInfo when we want to support it\n        insertToAggResultColumns(groupByColumns);\n        //TODO(XIN): double check whether should we add orderColumns\n        // Assume that we do not support order by Complex expressions which do not appear in\n        // display columns right now\n        insertToAggResultColumns(orderColumns);\n\n        // Generate New output Schema, replace Aggs with TVEs for group by and order by\n        evaluateColumns();\n    }","commit_id":"12f78d868c45851bb1ffc46a884641376dbebaf8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n        orderByNode.addAndLinkChild(root);\n        orderByNode.generateOutputSchema(m_catalogDb);\n\n        // get all of the columns in the sort\n        List<AbstractExpression> orderExpressions = orderByNode.getSortExpressions();\n\n        // In theory, for every table in the query, there needs to exist a uniqueness constraint\n        // (primary key or other unique index) on some of the ORDER BY values regardless of whether\n        // the associated index is used in the selected plan.\n        // If the index scan was used at the top of the plan, and its sort order was valid\n        // -- meaning covering the entire ORDER BY clause --\n        // this function would have already returned without adding an orderByNode.\n        // The interesting cases, including issue ENG-3335, are\n        // -- when the index scan is in the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n        // -- when the index was not the one selected for the plan.\n        // -- when the index is defined on a left-most child of a join the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        boolean allScansAreDeterministic = true;\n        for (Table table : m_parsedSelect.tableList) {\n\n            allScansAreDeterministic = false;\n            // search indexes for one that makes the order by deterministic\n            for (Index index : table.getIndexes()) {\n                // skip non-unique indexes\n                if (!index.getUnique()) {\n                    continue;\n                }\n\n                // get the list of expressions for the index\n                List<AbstractExpression> indexExpressions = new ArrayList<AbstractExpression>();\n\n                String jsonExpr = index.getExpressionsjson();\n                // if this is a pure-column index...\n                if (jsonExpr.isEmpty()) {\n                    for (ColumnRef cref : index.getColumns()) {\n                        Column col = cref.getColumn();\n                        TupleValueExpression tve = new TupleValueExpression();\n                        tve.setColumnIndex(col.getIndex());\n                        tve.setColumnName(col.getName());\n                        tve.setExpressionType(ExpressionType.VALUE_TUPLE);\n                        tve.setHasAggregate(false);\n                        tve.setTableName(table.getTypeName());\n                        tve.setValueSize(col.getSize());\n                        tve.setValueType(VoltType.get((byte) col.getType()));\n                        indexExpressions.add(tve);\n                    }\n                }\n                // if this is a fancy expression-based index...\n                else {\n                    try {\n                        indexExpressions = AbstractExpression.fromJSONArrayString(jsonExpr, null);\n                    } catch (JSONException e) {\n                        e.printStackTrace(); // danger will robinson\n                        assert(false);\n                        return null;\n                    }\n                }\n\n                // If the sort covers the index, then it's a unique sort.\n                //TODO: The statement's equivalence sets would be handy here to recognize cases like\n                //    WHERE A.unique_id = 1 AND A.b_id = 2 and B.unique_id = A.b_id ORDER BY B.unique_id\n                if (orderExpressions.containsAll(indexExpressions)) {\n                    allScansAreDeterministic = true;\n                    break;\n                }\n            }\n\n            if ( ! allScansAreDeterministic) {\n                break;\n            }\n        }\n\n        if (allScansAreDeterministic) {\n            orderByNode.setOrderingByUniqueColumns();\n        }\n        return orderByNode;\n    }","id":85718,"modified_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n\n        AbstractPlanNode projectionNode = root;\n        if (m_parsedSelect.hasComplexAgg()) {\n            AbstractPlanNode aggNode = root.getChild(0);\n            projectionNode.clearChildren();\n            aggNode.clearParents();\n\n            orderByNode.addAndLinkChild(aggNode);\n            orderByNode.generateOutputSchema(m_catalogDb);\n            projectionNode.addAndLinkChild(orderByNode);\n\n        } else {\n            orderByNode.addAndLinkChild(root);\n            orderByNode.generateOutputSchema(m_catalogDb);\n        }\n\n        // get all of the columns in the sort\n        List<AbstractExpression> orderExpressions = orderByNode.getSortExpressions();\n\n        // In theory, for every table in the query, there needs to exist a uniqueness constraint\n        // (primary key or other unique index) on some of the ORDER BY values regardless of whether\n        // the associated index is used in the selected plan.\n        // If the index scan was used at the top of the plan, and its sort order was valid\n        // -- meaning covering the entire ORDER BY clause --\n        // this function would have already returned without adding an orderByNode.\n        // The interesting cases, including issue ENG-3335, are\n        // -- when the index scan is in the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n        // -- when the index was not the one selected for the plan.\n        // -- when the index is defined on a left-most child of a join the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        boolean allScansAreDeterministic = true;\n        for (Table table : m_parsedSelect.tableList) {\n\n            allScansAreDeterministic = false;\n            // search indexes for one that makes the order by deterministic\n            for (Index index : table.getIndexes()) {\n                // skip non-unique indexes\n                if (!index.getUnique()) {\n                    continue;\n                }\n\n                // get the list of expressions for the index\n                List<AbstractExpression> indexExpressions = new ArrayList<AbstractExpression>();\n\n                String jsonExpr = index.getExpressionsjson();\n                // if this is a pure-column index...\n                if (jsonExpr.isEmpty()) {\n                    for (ColumnRef cref : index.getColumns()) {\n                        Column col = cref.getColumn();\n                        TupleValueExpression tve = new TupleValueExpression();\n                        tve.setColumnIndex(col.getIndex());\n                        tve.setColumnName(col.getName());\n                        tve.setExpressionType(ExpressionType.VALUE_TUPLE);\n                        tve.setHasAggregate(false);\n                        tve.setTableName(table.getTypeName());\n                        tve.setValueSize(col.getSize());\n                        tve.setValueType(VoltType.get((byte) col.getType()));\n                        indexExpressions.add(tve);\n                    }\n                }\n                // if this is a fancy expression-based index...\n                else {\n                    try {\n                        indexExpressions = AbstractExpression.fromJSONArrayString(jsonExpr, null);\n                    } catch (JSONException e) {\n                        e.printStackTrace(); // danger will robinson\n                        assert(false);\n                        return null;\n                    }\n                }\n\n                // If the sort covers the index, then it's a unique sort.\n                //TODO: The statement's equivalence sets would be handy here to recognize cases like\n                //    WHERE A.unique_id = 1 AND A.b_id = 2 and B.unique_id = A.b_id ORDER BY B.unique_id\n                if (orderExpressions.containsAll(indexExpressions)) {\n                    allScansAreDeterministic = true;\n                    break;\n                }\n            }\n\n            if ( ! allScansAreDeterministic) {\n                break;\n            }\n        }\n\n        if (allScansAreDeterministic) {\n            orderByNode.setOrderingByUniqueColumns();\n        }\n\n        if (m_parsedSelect.hasComplexAgg()) {\n            return projectionNode;\n        }\n\n        return orderByNode;\n    }","commit_id":"12f78d868c45851bb1ffc46a884641376dbebaf8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Generate new output Schema and Place TVEs for display columns if needed.\n     * Place TVEs for order by columns always.\n     */\n    private void placeTVEsinColumns () {\n        // Build the association between the table column with its index\n        Map <AbstractExpression, Integer> aggTableIndexMap = new HashMap <AbstractExpression,Integer>();\n        Map <Integer, ParsedColInfo> indexToColumnMap = new HashMap <Integer, ParsedColInfo>();\n        int index = 0;\n        for (ParsedColInfo col: aggResultColumns) {\n            aggTableIndexMap.put(col.expression, index);\n            if (col.alias == \"\") {\n                // hack any unique string\n                col.alias = \"$$_\" + col.expression.getExpressionType().symbol() + \"_$$_\" + index;\n            }\n            indexToColumnMap.put(index, col);\n            index++;\n        }\n        // Replace TVE for display columns\n        newAggSchema = new NodeSchema();\n        for (ParsedColInfo col : displayColumns) {\n            AbstractExpression expr = col.expression.replaceWithTVE(aggTableIndexMap, indexToColumnMap);\n            SchemaColumn schema_col = new SchemaColumn(col.tableName, col.columnName, col.alias, expr);\n            newAggSchema.addColumn(schema_col);\n        }\n        // Replace TVE for order by columns\n        for (ParsedColInfo col : orderColumns) {\n            AbstractExpression expr = col.expression.replaceWithTVE(aggTableIndexMap, indexToColumnMap);\n            col.expression = expr;\n        }\n    }","id":85719,"modified_method":"/**\n     * Generate new output Schema and Place TVEs for display columns if needed.\n     * Place TVEs for order by columns always.\n     */\n    private void placeTVEsinColumns () {\n        // Build the association between the table column with its index\n        Map <AbstractExpression, Integer> aggTableIndexMap = new HashMap <AbstractExpression,Integer>();\n        Map <Integer, ParsedColInfo> indexToColumnMap = new HashMap <Integer, ParsedColInfo>();\n        int index = 0;\n        for (ParsedColInfo col: aggResultColumns) {\n            aggTableIndexMap.put(col.expression, index);\n            if ( col.alias == null) {\n                // hack any unique string\n                col.alias = \"$$_\" + col.expression.getExpressionType().symbol() + \"_$$_\" + index;\n            }\n            indexToColumnMap.put(index, col);\n            index++;\n        }\n        // Replace TVE for display columns\n        newAggSchema = new NodeSchema();\n        for (ParsedColInfo col : displayColumns) {\n            AbstractExpression expr = col.expression.replaceWithTVE(aggTableIndexMap, indexToColumnMap);\n            SchemaColumn schema_col = new SchemaColumn(col.tableName, col.columnName, col.alias, expr);\n            newAggSchema.addColumn(schema_col);\n        }\n        // Replace TVE for order by columns\n        for (ParsedColInfo col : orderColumns) {\n            AbstractExpression expr = col.expression.replaceWithTVE(aggTableIndexMap, indexToColumnMap);\n            col.expression = expr;\n        }\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * ParseDisplayColumns and ParseOrderColumns will call this function to add Aggregation expressions to aggResultColumns\n     * @param colCollection\n     * @param cookedCol\n     */\n    private void insertAggExpressionsToAggResultColumns (List<AbstractExpression> colCollection, ParsedColInfo cookedCol) {\n        // Why IF ELSE, because AggResultColumn care about its alias,tableName\n        if (colCollection.size() == 1 && cookedCol.expression.equals(colCollection.get(0))) {\n            ParsedColInfo col = new ParsedColInfo();\n            col.expression = (AbstractExpression) colCollection.get(0).clone();\n            col.alias = cookedCol.alias;\n            col.tableName = cookedCol.tableName;\n            col.columnName = cookedCol.columnName;\n            if (isNewtoAggResultColumn(col)) {\n                aggResultColumns.add(col);\n            }\n        } else if (colCollection.size() != 0) {\n            // Try to check complexAggs earlier\n            complexAggs = true;\n            for (AbstractExpression expr: colCollection) {\n                ParsedColInfo col = new ParsedColInfo();\n                col.expression = (AbstractExpression) expr.clone();\n                ExpressionUtil.finalizeValueTypes(col.expression);\n                // Aggregation column use the the hacky stuff\n                col.alias = \"\";\n                col.tableName = \"VOLT_TEMP_TABLE\";\n                col.columnName = \"\";\n                if (isNewtoAggResultColumn(col)) {\n                    aggResultColumns.add(col);\n                }\n            }\n        }\n    }","id":85720,"modified_method":"/**\n     * ParseDisplayColumns and ParseOrderColumns will call this function to add Aggregation expressions to aggResultColumns\n     * @param colCollection\n     * @param cookedCol\n     */\n    private void insertAggExpressionsToAggResultColumns (List<AbstractExpression> colCollection, ParsedColInfo cookedCol) {\n        // Why IF ELSE, because AggResultColumn care about its alias,tableName\n        if (colCollection.size() == 1 && cookedCol.expression.equals(colCollection.get(0))) {\n            ParsedColInfo col = new ParsedColInfo();\n            col.expression = (AbstractExpression) colCollection.get(0).clone();\n            col.alias = cookedCol.alias;\n            col.tableName = cookedCol.tableName;\n            col.columnName = cookedCol.columnName;\n            if (isNewtoAggResultColumn(col)) {\n                aggResultColumns.add(col);\n            }\n        } else if (colCollection.size() != 0) {\n            // Try to check complexAggs earlier\n            complexAggs = true;\n            for (AbstractExpression expr: colCollection) {\n                ParsedColInfo col = new ParsedColInfo();\n                col.expression = (AbstractExpression) expr.clone();\n                ExpressionUtil.finalizeValueTypes(col.expression);\n                // Aggregation column use the the hacky stuff\n                col.tableName = \"VOLT_TEMP_TABLE\";\n                col.columnName = \"\";\n                if (isNewtoAggResultColumn(col)) {\n                    aggResultColumns.add(col);\n                }\n            }\n        }\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Add a limit, pushed-down if possible, and return the new root.\n     * @param root top of the original plan\n     * @return new plan's root node\n     */\n    private AbstractPlanNode handleLimitOperator(AbstractPlanNode root)\n    {\n        int limitParamIndex = m_parsedSelect.getLimitParameterIndex();\n        int offsetParamIndex = m_parsedSelect.getOffsetParameterIndex();\n\n        // The coordinator's top limit graph fragment for a MP plan.\n        // If planning \"order by ... limit\", getNextSelectPlan()\n        // will have already added an order by to the coordinator frag.\n        // This is the only limit node in a SP plan\n        LimitPlanNode topLimit = new LimitPlanNode();\n        topLimit.setLimit((int)m_parsedSelect.limit);\n        topLimit.setOffset((int) m_parsedSelect.offset);\n        topLimit.setLimitParameterIndex(limitParamIndex);\n        topLimit.setOffsetParameterIndex(offsetParamIndex);\n\n        /*\n         * TODO: allow push down limit with distinct (select distinct C from T limit 5)\n         * or distinct in aggregates.\n         */\n        AbstractPlanNode sendNode = null;\n        // Whether or not we can push the limit node down\n        boolean canPushDown = ! m_parsedSelect.distinct;\n        if (canPushDown) {\n            sendNode = checkPushDownViability(root);\n            if (sendNode == null) {\n                canPushDown = false;\n            } else {\n                for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.displayColumns) {\n                    AbstractExpression rootExpr = col.expression;\n                    if (rootExpr instanceof AggregateExpression) {\n                        if (((AggregateExpression)rootExpr).isDistinct()) {\n                            canPushDown = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        /*\n         * Push down the limit plan node when possible even if offset is set. If\n         * the plan is for a partitioned table, do the push down. Otherwise,\n         * there is no need to do the push down work, the limit plan node will\n         * be run in the partition.\n         */\n        if (canPushDown) {\n            /*\n             * For partitioned table, the pushed-down limit plan node has a limit based\n             * on the combined limit and offset, which may require an expression if either of these\n             * was not a hard-coded constant and didn't get parameterized.\n             * The top level limit plan node remains the same, with the original limit and offset values.\n             */\n            LimitPlanNode distLimit = new LimitPlanNode();\n            // Offset on a pushed-down limit node makes no sense, just defaults to 0\n            // -- the original offset must be factored into the pushed-down limit as a pad on the limit.\n            if (m_parsedSelect.limit != -1) {\n                distLimit.setLimit((int) (m_parsedSelect.limit + m_parsedSelect.offset));\n            }\n\n            if (m_parsedSelect.hasLimitOrOffsetParameters()) {\n\n                AbstractExpression left = m_parsedSelect.getOffsetExpression();\n                assert (left != null);\n                AbstractExpression right = m_parsedSelect.getLimitExpression();\n                assert (right != null);\n                OperatorExpression expr = new OperatorExpression(ExpressionType.OPERATOR_PLUS, left, right);\n                expr.setValueType(VoltType.INTEGER);\n                expr.setValueSize(VoltType.INTEGER.getLengthInBytesForFixedTypes());\n                distLimit.setLimitExpression(expr);\n            }\n            // else let the parameterized forms of offset/limit default to unused/invalid.\n\n            // Disconnect the distributed parts of the plan below the SEND node\n            AbstractPlanNode distributedPlan = sendNode.getChild(0);\n            distributedPlan.clearParents();\n            sendNode.clearChildren();\n\n            // If the distributed limit must be performed on ordered input,\n            // ensure the order of the data on each partition.\n            distributedPlan = handleOrderBy(distributedPlan);\n\n            // Apply the distributed limit.\n            distLimit.addAndLinkChild(distributedPlan);\n\n            // Add the distributed work back to the plan\n            sendNode.addAndLinkChild(distLimit);\n        }\n\n        topLimit.addAndLinkChild(root);\n        topLimit.generateOutputSchema(m_catalogDb);\n        return topLimit;\n    }","id":85721,"modified_method":"/**\n     * Add a limit, pushed-down if possible, and return the new root.\n     * @param root top of the original plan\n     * @return new plan's root node\n     */\n    private AbstractPlanNode handleLimitOperator(AbstractPlanNode root)\n    {\n        int limitParamIndex = m_parsedSelect.getLimitParameterIndex();\n        int offsetParamIndex = m_parsedSelect.getOffsetParameterIndex();\n\n        // The coordinator's top limit graph fragment for a MP plan.\n        // If planning \"order by ... limit\", getNextSelectPlan()\n        // will have already added an order by to the coordinator frag.\n        // This is the only limit node in a SP plan\n        LimitPlanNode topLimit = new LimitPlanNode();\n        topLimit.setLimit((int)m_parsedSelect.limit);\n        topLimit.setOffset((int) m_parsedSelect.offset);\n        topLimit.setLimitParameterIndex(limitParamIndex);\n        topLimit.setOffsetParameterIndex(offsetParamIndex);\n\n        /*\n         * TODO: allow push down limit with distinct (select distinct C from T limit 5)\n         * or distinct in aggregates.\n         */\n        AbstractPlanNode sendNode = null;\n        // Whether or not we can push the limit node down\n        boolean canPushDown = ! m_parsedSelect.distinct;\n        if (canPushDown) {\n            sendNode = checkPushDownViability(root);\n            if (sendNode == null) {\n                canPushDown = false;\n            } else {\n                for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.displayColumns) {\n                    AbstractExpression rootExpr = col.expression;\n                    if (rootExpr instanceof AggregateExpression) {\n                        if (((AggregateExpression)rootExpr).isDistinct()) {\n                            canPushDown = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        /*\n         * Push down the limit plan node when possible even if offset is set. If\n         * the plan is for a partitioned table, do the push down. Otherwise,\n         * there is no need to do the push down work, the limit plan node will\n         * be run in the partition.\n         */\n        if (canPushDown) {\n            /*\n             * For partitioned table, the pushed-down limit plan node has a limit based\n             * on the combined limit and offset, which may require an expression if either of these\n             * was not a hard-coded constant and didn't get parameterized.\n             * The top level limit plan node remains the same, with the original limit and offset values.\n             */\n            LimitPlanNode distLimit = new LimitPlanNode();\n            // Offset on a pushed-down limit node makes no sense, just defaults to 0\n            // -- the original offset must be factored into the pushed-down limit as a pad on the limit.\n            if (m_parsedSelect.limit != -1) {\n                distLimit.setLimit((int) (m_parsedSelect.limit + m_parsedSelect.offset));\n            }\n\n            if (m_parsedSelect.hasLimitOrOffsetParameters()) {\n\n                AbstractExpression left = m_parsedSelect.getOffsetExpression();\n                assert (left != null);\n                AbstractExpression right = m_parsedSelect.getLimitExpression();\n                assert (right != null);\n                OperatorExpression expr = new OperatorExpression(ExpressionType.OPERATOR_PLUS, left, right);\n                expr.setValueType(VoltType.INTEGER);\n                expr.setValueSize(VoltType.INTEGER.getLengthInBytesForFixedTypes());\n                distLimit.setLimitExpression(expr);\n            }\n            // else let the parameterized forms of offset/limit default to unused/invalid.\n\n            // Disconnect the distributed parts of the plan below the SEND node\n            AbstractPlanNode distributedPlan = sendNode.getChild(0);\n            distributedPlan.clearParents();\n            sendNode.clearChildren();\n\n            // If the distributed limit must be performed on ordered input,\n            // ensure the order of the data on each partition.\n            distributedPlan = handleOrderBy(distributedPlan, false);\n\n            // Apply the distributed limit.\n            distLimit.addAndLinkChild(distributedPlan);\n\n            // Add the distributed work back to the plan\n            sendNode.addAndLinkChild(distLimit);\n        }\n\n        // Switch if has Complex aggregations\n        AbstractPlanNode projectionNode = root;\n        if (m_parsedSelect.hasComplexAgg()) {\n            AbstractPlanNode child = root.getChild(0);\n            projectionNode.clearChildren();\n            child.clearParents();\n\n            topLimit.addAndLinkChild(child);\n            topLimit.generateOutputSchema(m_catalogDb);\n            projectionNode.addAndLinkChild(topLimit);\n            return projectionNode;\n        } else {\n            topLimit.addAndLinkChild(root);\n            topLimit.generateOutputSchema(m_catalogDb);\n            return topLimit;\n        }\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private AbstractPlanNode getNextSelectPlan() {\n        assert (subAssembler != null);\n\n        AbstractPlanNode subSelectRoot = subAssembler.nextPlan();\n        if (subSelectRoot == null)\n            return null;\n\n        AbstractPlanNode root = subSelectRoot;\n\n        /*\n         * Establish the output columns for the sub select plan.\n         */\n        root.generateOutputSchema(m_catalogDb);\n        root = handleAggregationOperators(root);\n\n        root = handleOrderBy(root);\n\n        if ((root.getPlanNodeType() != PlanNodeType.AGGREGATE) &&\n            (root.getPlanNodeType() != PlanNodeType.HASHAGGREGATE) &&\n            (root.getPlanNodeType() != PlanNodeType.DISTINCT) &&\n            (root.getPlanNodeType() != PlanNodeType.PROJECTION)) {\n            root = addProjection(root);\n        }\n\n        if (m_parsedSelect.hasLimitOrOffset())\n        {\n            root = handleLimitOperator(root);\n        }\n        root.generateOutputSchema(m_catalogDb);\n\n        return root;\n    }","id":85722,"modified_method":"private AbstractPlanNode getNextSelectPlan() {\n        assert (subAssembler != null);\n\n        AbstractPlanNode subSelectRoot = subAssembler.nextPlan();\n        if (subSelectRoot == null)\n            return null;\n\n        AbstractPlanNode root = subSelectRoot;\n\n        /*\n         * Establish the output columns for the sub select plan.\n         */\n        root.generateOutputSchema(m_catalogDb);\n        root = handleAggregationOperators(root);\n\n        root = handleOrderBy(root, true);\n\n        if ((root.getPlanNodeType() != PlanNodeType.AGGREGATE) &&\n            (root.getPlanNodeType() != PlanNodeType.HASHAGGREGATE) &&\n            (root.getPlanNodeType() != PlanNodeType.DISTINCT) &&\n            (root.getPlanNodeType() != PlanNodeType.PROJECTION)) {\n            root = addProjection(root);\n        }\n\n        if (m_parsedSelect.hasLimitOrOffset())\n        {\n            root = handleLimitOperator(root);\n        }\n        root.generateOutputSchema(m_catalogDb);\n\n        return root;\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n\n        AbstractPlanNode projectionNode = root;\n        if (m_parsedSelect.hasComplexAgg()) {\n            AbstractPlanNode aggNode = root.getChild(0);\n            projectionNode.clearChildren();\n            aggNode.clearParents();\n\n            orderByNode.addAndLinkChild(aggNode);\n            orderByNode.generateOutputSchema(m_catalogDb);\n            projectionNode.addAndLinkChild(orderByNode);\n\n        } else {\n            orderByNode.addAndLinkChild(root);\n            orderByNode.generateOutputSchema(m_catalogDb);\n        }\n\n        // get all of the columns in the sort\n        List<AbstractExpression> orderExpressions = orderByNode.getSortExpressions();\n\n        // In theory, for every table in the query, there needs to exist a uniqueness constraint\n        // (primary key or other unique index) on some of the ORDER BY values regardless of whether\n        // the associated index is used in the selected plan.\n        // If the index scan was used at the top of the plan, and its sort order was valid\n        // -- meaning covering the entire ORDER BY clause --\n        // this function would have already returned without adding an orderByNode.\n        // The interesting cases, including issue ENG-3335, are\n        // -- when the index scan is in the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n        // -- when the index was not the one selected for the plan.\n        // -- when the index is defined on a left-most child of a join the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        boolean allScansAreDeterministic = true;\n        for (Table table : m_parsedSelect.tableList) {\n\n            allScansAreDeterministic = false;\n            // search indexes for one that makes the order by deterministic\n            for (Index index : table.getIndexes()) {\n                // skip non-unique indexes\n                if (!index.getUnique()) {\n                    continue;\n                }\n\n                // get the list of expressions for the index\n                List<AbstractExpression> indexExpressions = new ArrayList<AbstractExpression>();\n\n                String jsonExpr = index.getExpressionsjson();\n                // if this is a pure-column index...\n                if (jsonExpr.isEmpty()) {\n                    for (ColumnRef cref : index.getColumns()) {\n                        Column col = cref.getColumn();\n                        TupleValueExpression tve = new TupleValueExpression();\n                        tve.setColumnIndex(col.getIndex());\n                        tve.setColumnName(col.getName());\n                        tve.setExpressionType(ExpressionType.VALUE_TUPLE);\n                        tve.setHasAggregate(false);\n                        tve.setTableName(table.getTypeName());\n                        tve.setValueSize(col.getSize());\n                        tve.setValueType(VoltType.get((byte) col.getType()));\n                        indexExpressions.add(tve);\n                    }\n                }\n                // if this is a fancy expression-based index...\n                else {\n                    try {\n                        indexExpressions = AbstractExpression.fromJSONArrayString(jsonExpr, null);\n                    } catch (JSONException e) {\n                        e.printStackTrace(); // danger will robinson\n                        assert(false);\n                        return null;\n                    }\n                }\n\n                // If the sort covers the index, then it's a unique sort.\n                //TODO: The statement's equivalence sets would be handy here to recognize cases like\n                //    WHERE A.unique_id = 1 AND A.b_id = 2 and B.unique_id = A.b_id ORDER BY B.unique_id\n                if (orderExpressions.containsAll(indexExpressions)) {\n                    allScansAreDeterministic = true;\n                    break;\n                }\n            }\n\n            if ( ! allScansAreDeterministic) {\n                break;\n            }\n        }\n\n        if (allScansAreDeterministic) {\n            orderByNode.setOrderingByUniqueColumns();\n        }\n\n        if (m_parsedSelect.hasComplexAgg()) {\n            return projectionNode;\n        }\n\n        return orderByNode;\n    }","id":85723,"modified_method":"/**\n     * Create an order by node as required by the statement and make it a parent of root.\n     * @param root\n     * @return new orderByNode (the new root) or the original root if no orderByNode was required.\n     */\n    AbstractPlanNode handleOrderBy(AbstractPlanNode root, boolean expectedComplex) {\n        assert (m_parsedSelect != null);\n\n        // Only sort when the statement has an ORDER BY.\n        if ( ! m_parsedSelect.hasOrderByColumns()) {\n            return root;\n        }\n\n        // Ignore ORDER BY in cases where there can be at most one row.\n        if (m_parsedSelect.guaranteesUniqueRow()) {\n            return root;\n        }\n\n        // Skip the explicit ORDER BY plan step if an IndexScan is already providing the equivalent ordering.\n        // Note that even tree index scans that produce values in their own \"key order\" only report\n        // their sort direction != SortDirectionType.INVALID\n        // when they enforce an ordering equivalent to the one requested in the ORDER BY clause.\n        if (root.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            if (((IndexScanPlanNode) root).getSortDirection() != SortDirectionType.INVALID) {\n                return root;\n            }\n        }\n\n        OrderByPlanNode orderByNode = new OrderByPlanNode();\n        for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.orderColumns) {\n            orderByNode.addSort(col.expression,\n                                col.ascending ? SortDirectionType.ASC\n                                              : SortDirectionType.DESC);\n        }\n\n        AbstractPlanNode projectionNode = root;\n        if (m_parsedSelect.hasComplexAgg() && expectedComplex) {\n            AbstractPlanNode aggNode = root.getChild(0);\n            projectionNode.clearChildren();\n            aggNode.clearParents();\n\n            orderByNode.addAndLinkChild(aggNode);\n            orderByNode.generateOutputSchema(m_catalogDb);\n            projectionNode.addAndLinkChild(orderByNode);\n\n        } else {\n            orderByNode.addAndLinkChild(root);\n            orderByNode.generateOutputSchema(m_catalogDb);\n        }\n\n        // get all of the columns in the sort\n        List<AbstractExpression> orderExpressions = orderByNode.getSortExpressions();\n\n        // In theory, for every table in the query, there needs to exist a uniqueness constraint\n        // (primary key or other unique index) on some of the ORDER BY values regardless of whether\n        // the associated index is used in the selected plan.\n        // If the index scan was used at the top of the plan, and its sort order was valid\n        // -- meaning covering the entire ORDER BY clause --\n        // this function would have already returned without adding an orderByNode.\n        // The interesting cases, including issue ENG-3335, are\n        // -- when the index scan is in the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n        // -- when the index was not the one selected for the plan.\n        // -- when the index is defined on a left-most child of a join the distributed part of the plan\n        //    Then, the orderByNode is required to re-order the results at the coordinator.\n\n        // Start by eliminating joins since, in general, a join (one-to-many) may produce multiple joined rows for each unique input row.\n        // TODO: In theory, it is possible to analyze the join criteria and/or projected columns\n        // to determine whether the particular join preserves the uniqueness of its index-scanned input.\n        boolean allScansAreDeterministic = true;\n        for (Table table : m_parsedSelect.tableList) {\n\n            allScansAreDeterministic = false;\n            // search indexes for one that makes the order by deterministic\n            for (Index index : table.getIndexes()) {\n                // skip non-unique indexes\n                if (!index.getUnique()) {\n                    continue;\n                }\n\n                // get the list of expressions for the index\n                List<AbstractExpression> indexExpressions = new ArrayList<AbstractExpression>();\n\n                String jsonExpr = index.getExpressionsjson();\n                // if this is a pure-column index...\n                if (jsonExpr.isEmpty()) {\n                    for (ColumnRef cref : index.getColumns()) {\n                        Column col = cref.getColumn();\n                        TupleValueExpression tve = new TupleValueExpression();\n                        tve.setColumnIndex(col.getIndex());\n                        tve.setColumnName(col.getName());\n                        tve.setExpressionType(ExpressionType.VALUE_TUPLE);\n                        tve.setHasAggregate(false);\n                        tve.setTableName(table.getTypeName());\n                        tve.setValueSize(col.getSize());\n                        tve.setValueType(VoltType.get((byte) col.getType()));\n                        indexExpressions.add(tve);\n                    }\n                }\n                // if this is a fancy expression-based index...\n                else {\n                    try {\n                        indexExpressions = AbstractExpression.fromJSONArrayString(jsonExpr, null);\n                    } catch (JSONException e) {\n                        e.printStackTrace(); // danger will robinson\n                        assert(false);\n                        return null;\n                    }\n                }\n\n                // If the sort covers the index, then it's a unique sort.\n                //TODO: The statement's equivalence sets would be handy here to recognize cases like\n                //    WHERE A.unique_id = 1 AND A.b_id = 2 and B.unique_id = A.b_id ORDER BY B.unique_id\n                if (orderExpressions.containsAll(indexExpressions)) {\n                    allScansAreDeterministic = true;\n                    break;\n                }\n            }\n\n            if ( ! allScansAreDeterministic) {\n                break;\n            }\n        }\n\n        if (allScansAreDeterministic) {\n            orderByNode.setOrderingByUniqueColumns();\n        }\n\n        if (m_parsedSelect.hasComplexAgg() && expectedComplex) {\n            return projectionNode;\n        }\n\n        return orderByNode;\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testEdgeComplexCase() {\n        pns = compileToFragments(\"SELECT count(*)  FROM P1 order by PKEY\");\n        checkComplexAgg(pns, true);\n    }","id":85724,"modified_method":"public void testEdgeComplexCase() {\n        pns = compileToFragments(\"select PKEY+A1 from T1 Order by PKEY+A1\");\n        checkComplexAgg(pns, false);\n\n        pns = compileToFragments(\"SELECT count(*)  FROM P1 order by PKEY\");\n        checkComplexAgg(pns, true);\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testSimpleComplexCase() {\n        pns = compileToFragments(\"SELECT A1, sum(A1), sum(A1)+11 FROM P1 GROUP BY A1\");\n        checkComplexAgg(pns, true);\n\n        pns = compileToFragments(\"SELECT A1, SUM(PKEY) as A2, (SUM(PKEY) / 888) as A3, (SUM(PKEY) + 1) as A4 FROM P1 GROUP BY A1\");\n        checkComplexAgg(pns, true);\n\n        pns = compileToFragments(\"SELECT A1, count(*) as tag FROM P1 group by A1 order by tag, A1 limit 1\");\n        checkComplexAgg(pns, false);\n\n    }","id":85725,"modified_method":"public void testComplexAggCase() {\n        pns = compileToFragments(\"SELECT A1, sum(A1), sum(A1)+11 FROM P1 GROUP BY A1\");\n        checkComplexAgg(pns, true);\n\n        pns = compileToFragments(\"SELECT A1, SUM(PKEY) as A2, (SUM(PKEY) / 888) as A3, (SUM(PKEY) + 1) as A4 FROM P1 GROUP BY A1\");\n        checkComplexAgg(pns, true);\n\n        pns = compileToFragments(\"SELECT A1, count(*) as tag FROM P1 group by A1 order by tag, A1 limit 1\");\n        checkComplexAgg(pns, false);\n\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"static public junit.framework.Test suite() {\n        VoltServerConfig config = null;\n        MultiConfigSuiteBuilder builder = new MultiConfigSuiteBuilder(\n                TestPlansGroupByComplexSuite.class);\n        VoltProjectBuilder project = new VoltProjectBuilder();\n        final String literalSchema =\n                \"CREATE TABLE R1 ( \" +\n                \"ID INTEGER DEFAULT '0' NOT NULL, \" +\n                \"WAGE INTEGER, \" +\n                \"DEPT INTEGER, \" +\n                \"RATE FLOAT, \" +\n                \"PRIMARY KEY (ID) );\" +\n                \"CREATE TABLE P1 ( \" +\n                \"ID INTEGER DEFAULT '0' NOT NULL, \" +\n                \"WAGE INTEGER, \" +\n                \"DEPT INTEGER, \" +\n                \"RATE FLOAT, \" +\n                \"PRIMARY KEY (ID) );\";\n        try {\n            project.addLiteralSchema(literalSchema);\n        } catch (IOException e) {\n            assertFalse(true);\n        }\n        project.addPartitionInfo(\"P1\", \"ID\");\n        boolean success;\n        //project.addStmtProcedure(\"failedProcedure\", \"SELECT wage, SUM(wage) from R1 group by ID;\");\n\n        config = new LocalCluster(\"plansgroupby-onesite.jar\", 1, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n//        config = new LocalCluster(\"plansgroupby-hsql.jar\", 1, 1, 0, BackendTarget.HSQLDB_BACKEND);\n//        success = config.compile(project);\n//        assertTrue(success);\n//        builder.addServerConfig(config);\n//\n//        // Cluster\n//        config = new LocalCluster(\"plansgroupby-cluster.jar\", 2, 3, 1, BackendTarget.NATIVE_EE_JNI);\n//        success = config.compile(project);\n//        assertTrue(success);\n//        builder.addServerConfig(config);\n\n        return builder;\n    }","id":85726,"modified_method":"static public junit.framework.Test suite() {\n        VoltServerConfig config = null;\n        MultiConfigSuiteBuilder builder = new MultiConfigSuiteBuilder(\n                TestPlansGroupByComplexSuite.class);\n        VoltProjectBuilder project = new VoltProjectBuilder();\n        final String literalSchema =\n                \"CREATE TABLE R1 ( \" +\n                \"ID INTEGER DEFAULT '0' NOT NULL, \" +\n                \"WAGE INTEGER, \" +\n                \"DEPT INTEGER, \" +\n                \"RATE FLOAT, \" +\n                \"PRIMARY KEY (ID) );\" +\n                \"CREATE TABLE P1 ( \" +\n                \"ID INTEGER DEFAULT '0' NOT NULL, \" +\n                \"WAGE INTEGER, \" +\n                \"DEPT INTEGER, \" +\n                \"RATE FLOAT, \" +\n                \"PRIMARY KEY (ID) );\";\n        try {\n            project.addLiteralSchema(literalSchema);\n        } catch (IOException e) {\n            assertFalse(true);\n        }\n        project.addPartitionInfo(\"P1\", \"ID\");\n        boolean success;\n        //project.addStmtProcedure(\"failedProcedure\", \"SELECT wage, SUM(wage) from R1 group by ID;\");\n\n        config = new LocalCluster(\"plansgroupby-onesite.jar\", 1, 1, 0, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n        config = new LocalCluster(\"plansgroupby-hsql.jar\", 1, 1, 0, BackendTarget.HSQLDB_BACKEND);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n        // Cluster\n        config = new LocalCluster(\"plansgroupby-cluster.jar\", 2, 3, 1, BackendTarget.NATIVE_EE_JNI);\n        success = config.compile(project);\n        assertTrue(success);\n        builder.addServerConfig(config);\n\n        return builder;\n    }","commit_id":"7bf73ecb2094e0ccf3cb0b849bfb059132f66bf2","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Given a relatively complete plan-sub-graph, apply a trivial projection\n     * (filter) to it. If the root node can embed the projection do so. If not,\n     * add a new projection node.\n     *\n     * @param rootNode\n     *            The root of the plan-sub-graph to add the projection to.\n     * @return The new root of the plan-sub-graph (might be the same as the\n     *         input).\n     */\n    AbstractPlanNode addProjection(AbstractPlanNode rootNode) {\n        assert (m_parsedSelect != null);\n        assert (m_parsedSelect.displayColumns != null);\n\n        ProjectionPlanNode projectionNode =\n            new ProjectionPlanNode();\n        NodeSchema proj_schema = new NodeSchema();\n\n        // Build the output schema for the projection based on the display columns\n        for (ParsedSelectStmt.ParsedColInfo outputCol : m_parsedSelect.displayColumns)\n        {\n            assert(outputCol.expression != null);\n            SchemaColumn col = new SchemaColumn(outputCol.tableName,\n                                                outputCol.columnName,\n                                                outputCol.alias,\n                                                outputCol.expression);\n            proj_schema.addColumn(col);\n        }\n        projectionNode.setOutputSchema(proj_schema);\n\n        //@TODO pullexec prototype\n        // if the projection can be done inline...\n        //if (rootNode instanceof AbstractScanPlanNode) {\n        //    rootNode.addInlinePlanNode(projectionNode);\n        //    return rootNode;\n        //} else {\n            projectionNode.addAndLinkChild(rootNode);\n            projectionNode.generateOutputSchema(m_catalogDb);\n            return projectionNode;\n        //}\n    }","id":85727,"modified_method":"/**\n     * Given a relatively complete plan-sub-graph, apply a trivial projection\n     * (filter) to it. If the root node can embed the projection do so. If not,\n     * add a new projection node.\n     *\n     * @param rootNode\n     *            The root of the plan-sub-graph to add the projection to.\n     * @return The new root of the plan-sub-graph (might be the same as the\n     *         input).\n     */\n    AbstractPlanNode addProjection(AbstractPlanNode rootNode) {\n        assert (m_parsedSelect != null);\n        assert (m_parsedSelect.displayColumns != null);\n\n        ProjectionPlanNode projectionNode =\n            new ProjectionPlanNode();\n        NodeSchema proj_schema = new NodeSchema();\n\n        // Build the output schema for the projection based on the display columns\n        for (ParsedSelectStmt.ParsedColInfo outputCol : m_parsedSelect.displayColumns)\n        {\n            assert(outputCol.expression != null);\n            SchemaColumn col = new SchemaColumn(outputCol.tableName,\n                                                outputCol.columnName,\n                                                outputCol.alias,\n                                                outputCol.expression);\n            proj_schema.addColumn(col);\n        }\n        projectionNode.setOutputSchema(proj_schema);\n\n        // if the projection can be done inline...\n        if (rootNode instanceof AbstractScanPlanNode) {\n            rootNode.addInlinePlanNode(projectionNode);\n            return rootNode;\n        } else {\n            projectionNode.addAndLinkChild(rootNode);\n            projectionNode.generateOutputSchema(m_catalogDb);\n            return projectionNode;\n        }\n    }","commit_id":"60420122b58c72b46da6641f98d27b6ed0be0b4c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Initialize planner with physical schema info and a reference to HSQLDB parser.\n     *\n     * @param catalogCluster Catalog info about the physical layout of the cluster.\n     * @param catalogDb Catalog info about schema, metadata and procedures.\n     * @param HSQL HSQLInterface pointer used for parsing SQL into XML.\n     * @param useGlobalIds\n     */\n    public QueryPlanner(Cluster catalogCluster, Database catalogDb, boolean singlePartition,\n                        HSQLInterface HSQL, DatabaseEstimates estimates,\n                        boolean useGlobalIds, boolean suppressDebugOutput) {\n        assert(HSQL != null);\n        assert(catalogCluster != null);\n        assert(catalogDb != null);\n\n        m_HSQL = HSQL;\n        m_assembler = new PlanAssembler(catalogCluster, catalogDb, singlePartition);\n        m_db = catalogDb;\n        m_cluster = catalogCluster;\n        m_estimates = estimates;\n        m_useGlobalIds = useGlobalIds;\n        //m_quietPlanner = suppressDebugOutput;\n        //m_fullDebug = System.getProperties().contains(\"compilerdebug\");\n        m_quietPlanner = false;\n        m_fullDebug = true;\n    }","id":85728,"modified_method":"/**\n     * Initialize planner with physical schema info and a reference to HSQLDB parser.\n     *\n     * @param catalogCluster Catalog info about the physical layout of the cluster.\n     * @param catalogDb Catalog info about schema, metadata and procedures.\n     * @param HSQL HSQLInterface pointer used for parsing SQL into XML.\n     * @param useGlobalIds\n     */\n    public QueryPlanner(Cluster catalogCluster, Database catalogDb, boolean singlePartition,\n                        HSQLInterface HSQL, DatabaseEstimates estimates,\n                        boolean useGlobalIds, boolean suppressDebugOutput) {\n        assert(HSQL != null);\n        assert(catalogCluster != null);\n        assert(catalogDb != null);\n\n        m_HSQL = HSQL;\n        m_assembler = new PlanAssembler(catalogCluster, catalogDb, singlePartition);\n        m_db = catalogDb;\n        m_cluster = catalogCluster;\n        m_estimates = estimates;\n        m_useGlobalIds = useGlobalIds;\n        m_quietPlanner = suppressDebugOutput;\n        m_fullDebug = System.getProperties().contains(\"compilerdebug\");\n    }","commit_id":"60420122b58c72b46da6641f98d27b6ed0be0b4c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Get the best plan for the SQL statement given, assuming the given costModel.\n     *\n     * @param costModel The current cost model to evaluate plans with.\n     * @param sql SQL stmt text to be planned.\n     * @param sql Suggested join order to be used for the query\n     * @param stmtName The name of the sql statement to be planned.\n     * @param procName The name of the procedure containing the sql statement to be planned.\n     * @param singlePartition Is the stmt single-partition?\n     * @param paramHints\n     * @return The best plan found for the SQL statement or null if none can be found.\n     */\n    public CompiledPlan compilePlan(\n            AbstractCostModel costModel,\n            String sql,\n            String joinOrder,\n            String stmtName,\n            String procName,\n            int maxTablesPerJoin,\n            ScalarValueHints[] paramHints) {\n        assert(costModel != null);\n        assert(sql != null);\n        assert(stmtName != null);\n        assert(procName != null);\n\n        // reset any error message\n        m_recentErrorMsg = null;\n\n        // set the usage of global ids in the plan assembler\n        AbstractPlanNode.setUseGlobalIds(m_useGlobalIds);\n\n        // use HSQLDB to get XML that describes the semantics of the statement\n        // this is much easier to parse than SQL and is checked against the catalog\n        VoltXMLElement xmlSQL = null;\n        try {\n            xmlSQL = m_HSQL.getXMLCompiledStatement(sql);\n        } catch (HSQLParseException e) {\n            // XXXLOG probably want a real log message here\n            m_recentErrorMsg = e.getMessage();\n            return null;\n        }\n\n        if (!m_quietPlanner && m_fullDebug) {\n            outputCompiledStatement(stmtName, procName, xmlSQL);\n        }\n\n        // get a parsed statement from the xml\n        AbstractParsedStmt parsedStmt = null;\n        try {\n            parsedStmt = AbstractParsedStmt.parse(sql, xmlSQL, m_db, joinOrder);\n        }\n        catch (Exception e) {\n            m_recentErrorMsg = e.getMessage();\n            return null;\n        }\n        if (parsedStmt == null)\n        {\n            m_recentErrorMsg = \"Failed to parse SQL statement: \" + sql;\n            return null;\n        }\n        if ((parsedStmt.tableList.size() > maxTablesPerJoin) && (parsedStmt.joinOrder == null)) {\n            m_recentErrorMsg = \"Failed to parse SQL statement: \" + sql + \" because a join of > 5 tables was requested\"\n                               + \" without specifying a join order. See documentation for instructions on manually\" +\n                                 \" specifying a join order\";\n            return null;\n        }\n\n        if (!m_quietPlanner && m_fullDebug) {\n            outputParsedStatement(stmtName, procName, parsedStmt);\n        }\n\n        // get ready to find the plan with minimal cost\n        CompiledPlan rawplan = null;\n        CompiledPlan bestPlan = null;\n        String bestFilename = null;\n        double minCost = Double.MAX_VALUE;\n\n        // index of the plan currently being \"costed\"\n        int planCounter = 0;\n\n        PlanStatistics stats = null;\n\n        {   // XXX: remove this brace and reformat the code when ready to open a whole new can of whitespace diffs.\n            // set up the plan assembler for this statement\n            m_assembler.setupForNewPlans(parsedStmt);\n\n            // loop over all possible plans\n            while (true) {\n\n                try {\n                    rawplan = m_assembler.getNextPlan();\n                }\n                // on exception, set the error message and bail...\n                catch (PlanningErrorException e) {\n                    m_recentErrorMsg = e.getMessage();\n                    return null;\n                }\n\n                // stop this while loop when no more plans are generated\n                if (rawplan == null)\n                    break;\n\n                // run the set of microptimizations, which may return many plans (or not)\n                List<CompiledPlan> optimizedPlans = MicroOptimizationRunner.applyAll(rawplan);\n\n                // iterate through the subset of plans\n                for (CompiledPlan plan : optimizedPlans) {\n\n                    // add in the sql to the plan\n                    plan.sql = sql;\n\n                    // this plan is final, resolve all the column index references\n                    plan.fragments.get(0).planGraph.resolveColumnIndexes();\n\n                    // compute resource usage using the single stats collector\n                    stats = new PlanStatistics();\n                    AbstractPlanNode planGraph = plan.fragments.get(0).planGraph;\n\n                    // compute statistics about a plan\n                    boolean result = planGraph.computeEstimatesRecursively(stats, m_cluster, m_db, m_estimates, paramHints);\n                    assert(result);\n\n                    // compute the cost based on the resources using the current cost model\n                    plan.cost = costModel.getPlanCost(stats);\n\n                    // filename for debug output\n                    String filename = String.valueOf(planCounter++);\n\n                    // find the minimum cost plan\n                    if (plan.cost < minCost) {\n                        minCost = plan.cost;\n                        // free the PlanColumns held by the previous best plan\n                        bestPlan = plan;\n                        bestFilename = filename;\n                    }\n\n                    if (!m_quietPlanner) {\n                        if (m_fullDebug) {\n                            outputPlanFullDebug(plan, planGraph, stmtName, procName, filename);\n                        }\n\n                        // get the explained plan for the node\n                        plan.explainedPlan = planGraph.toExplainPlanString();\n                        outputExplainedPlan(stmtName, procName, plan, filename);\n                    }\n                }\n            }\n        }   // XXX: remove this brace and reformat the code when ready to open a whole new can of whitespace diffs.\n\n        // make sure we got a winner\n        if (bestPlan == null) {\n            m_recentErrorMsg = \"Unable to plan for statement. Error unknown.\";\n            return null;\n        }\n\n        // reset all the plan node ids for a given plan\n        // this makes the ids deterministic\n        bestPlan.resetPlanNodeIds();\n\n        if (!m_quietPlanner)\n        {\n            finalizeOutput(stmtName, procName, bestFilename, stats);\n        }\n\n        // split up the plan everywhere we see send/recieve into multiple plan fragments\n        bestPlan = Fragmentizer.fragmentize(bestPlan, m_db);\n\n        // DTXN/EE can't handle plans that have more than 2 fragments yet.\n        if (bestPlan.fragments.size() > 2) {\n            m_recentErrorMsg = \"Unable to plan for statement. Possibly \" +\n                \"joining partitioned tables in a multi-partition procedure \" +\n                \"using a column that is not the partitioning attribute \" +\n                \"or a non-equality operator. \" +\n                \"This is statement not supported at this time.\";\n            return null;\n        }\n\n        return bestPlan;\n    }","id":85729,"modified_method":"/**\n     * Get the best plan for the SQL statement given, assuming the given costModel.\n     *\n     * @param costModel The current cost model to evaluate plans with.\n     * @param sql SQL stmt text to be planned.\n     * @param sql Suggested join order to be used for the query\n     * @param stmtName The name of the sql statement to be planned.\n     * @param procName The name of the procedure containing the sql statement to be planned.\n     * @param singlePartition Is the stmt single-partition?\n     * @param paramHints\n     * @return The best plan found for the SQL statement or null if none can be found.\n     */\n    public CompiledPlan compilePlan(\n            AbstractCostModel costModel,\n            String sql,\n            String joinOrder,\n            String stmtName,\n            String procName,\n            int maxTablesPerJoin,\n            ScalarValueHints[] paramHints) {\n        assert(costModel != null);\n        assert(sql != null);\n        assert(stmtName != null);\n        assert(procName != null);\n\n        // reset any error message\n        m_recentErrorMsg = null;\n\n        // set the usage of global ids in the plan assembler\n        AbstractPlanNode.setUseGlobalIds(m_useGlobalIds);\n\n        // use HSQLDB to get XML that describes the semantics of the statement\n        // this is much easier to parse than SQL and is checked against the catalog\n        VoltXMLElement xmlSQL = null;\n        try {\n            xmlSQL = m_HSQL.getXMLCompiledStatement(sql);\n        } catch (HSQLParseException e) {\n            // XXXLOG probably want a real log message here\n            m_recentErrorMsg = e.getMessage();\n            return null;\n        }\n\n        if (!m_quietPlanner && m_fullDebug) {\n            outputCompiledStatement(stmtName, procName, xmlSQL);\n        }\n\n        // Get a parsed statement from the xml\n        // The callers of compilePlan are ready to catch any exceptions thrown here.\n        AbstractParsedStmt parsedStmt = AbstractParsedStmt.parse(sql, xmlSQL, m_db, joinOrder);\n        if (parsedStmt == null)\n        {\n            m_recentErrorMsg = \"Failed to parse SQL statement: \" + sql;\n            return null;\n        }\n        if ((parsedStmt.tableList.size() > maxTablesPerJoin) && (parsedStmt.joinOrder == null)) {\n            m_recentErrorMsg = \"Failed to parse SQL statement: \" + sql + \" because a join of > 5 tables was requested\"\n                               + \" without specifying a join order. See documentation for instructions on manually\" +\n                                 \" specifying a join order\";\n            return null;\n        }\n\n        if (!m_quietPlanner && m_fullDebug) {\n            outputParsedStatement(stmtName, procName, parsedStmt);\n        }\n\n        // get ready to find the plan with minimal cost\n        CompiledPlan rawplan = null;\n        CompiledPlan bestPlan = null;\n        String bestFilename = null;\n        double minCost = Double.MAX_VALUE;\n\n        // index of the plan currently being \"costed\"\n        int planCounter = 0;\n\n        PlanStatistics stats = null;\n\n        {   // XXX: remove this brace and reformat the code when ready to open a whole new can of whitespace diffs.\n            // set up the plan assembler for this statement\n            m_assembler.setupForNewPlans(parsedStmt);\n\n            // loop over all possible plans\n            while (true) {\n\n                try {\n                    rawplan = m_assembler.getNextPlan();\n                }\n                // on exception, set the error message and bail...\n                catch (PlanningErrorException e) {\n                    m_recentErrorMsg = e.getMessage();\n                    return null;\n                }\n\n                // stop this while loop when no more plans are generated\n                if (rawplan == null)\n                    break;\n\n                // run the set of microptimizations, which may return many plans (or not)\n                List<CompiledPlan> optimizedPlans = MicroOptimizationRunner.applyAll(rawplan);\n\n                // iterate through the subset of plans\n                for (CompiledPlan plan : optimizedPlans) {\n\n                    // add in the sql to the plan\n                    plan.sql = sql;\n\n                    // this plan is final, resolve all the column index references\n                    plan.fragments.get(0).planGraph.resolveColumnIndexes();\n\n                    // compute resource usage using the single stats collector\n                    stats = new PlanStatistics();\n                    AbstractPlanNode planGraph = plan.fragments.get(0).planGraph;\n\n                    // compute statistics about a plan\n                    boolean result = planGraph.computeEstimatesRecursively(stats, m_cluster, m_db, m_estimates, paramHints);\n                    assert(result);\n\n                    // compute the cost based on the resources using the current cost model\n                    plan.cost = costModel.getPlanCost(stats);\n\n                    // filename for debug output\n                    String filename = String.valueOf(planCounter++);\n\n                    // find the minimum cost plan\n                    if (plan.cost < minCost) {\n                        minCost = plan.cost;\n                        // free the PlanColumns held by the previous best plan\n                        bestPlan = plan;\n                        bestFilename = filename;\n                    }\n\n                    if (!m_quietPlanner) {\n                        if (m_fullDebug) {\n                            outputPlanFullDebug(plan, planGraph, stmtName, procName, filename);\n                        }\n\n                        // get the explained plan for the node\n                        plan.explainedPlan = planGraph.toExplainPlanString();\n                        outputExplainedPlan(stmtName, procName, plan, filename);\n                    }\n                }\n            }\n        }   // XXX: remove this brace and reformat the code when ready to open a whole new can of whitespace diffs.\n\n        // make sure we got a winner\n        if (bestPlan == null) {\n            m_recentErrorMsg = \"Unable to plan for statement. Error unknown.\";\n            return null;\n        }\n\n        // reset all the plan node ids for a given plan\n        // this makes the ids deterministic\n        bestPlan.resetPlanNodeIds();\n\n        if (!m_quietPlanner)\n        {\n            finalizeOutput(stmtName, procName, bestFilename, stats);\n        }\n\n        // split up the plan everywhere we see send/recieve into multiple plan fragments\n        bestPlan = Fragmentizer.fragmentize(bestPlan, m_db);\n\n        // DTXN/EE can't handle plans that have more than 2 fragments yet.\n        if (bestPlan.fragments.size() > 2) {\n            m_recentErrorMsg = \"Unable to plan for statement. Possibly \" +\n                \"joining partitioned tables in a multi-partition procedure \" +\n                \"using a column that is not the partitioning attribute \" +\n                \"or a non-equality operator. \" +\n                \"This is statement not supported at this time.\";\n            return null;\n        }\n\n        return bestPlan;\n    }","commit_id":"60420122b58c72b46da6641f98d27b6ed0be0b4c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void processConstructor(@NotNull GrMethod method, PsiAnnotation annotation) {\n      PsiClass builderClass = createBuilderClass(annotation, method.getParameters());\n      LightMethodBuilder builderMethod = createBuilderMethod(builderClass, annotation);\n      myMembers.getMethods().add(builderMethod);\n    }","id":85730,"modified_method":"private void processConstructor(@NotNull GrMethod method, PsiAnnotation annotation) {\n      PsiClass builderClass = createBuilderClass(annotation, method.getParameters());\n      myMembers.getMethods().add(createBuilderMethod(builderClass, annotation));\n      myMembers.getClasses().add(builderClass);\n    }","commit_id":"0abda35e8da9d1af5516507a76296101ceee574e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processFactoryMethod(@NotNull GrMethod method, PsiAnnotation annotation) {\n      PsiClass builderClass = createBuilderClass(annotation, method.getParameters(), method.getReturnType());\n      LightMethodBuilder builderMethod = createBuilderMethod(builderClass, annotation);\n      myMembers.getMethods().add(builderMethod);\n    }","id":85731,"modified_method":"private void processFactoryMethod(@NotNull GrMethod method, PsiAnnotation annotation) {\n      PsiClass builderClass = createBuilderClass(annotation, method.getParameters(), method.getReturnType());\n      myMembers.getMethods().add(createBuilderMethod(builderClass, annotation));\n      myMembers.getClasses().add(builderClass);\n    }","commit_id":"0abda35e8da9d1af5516507a76296101ceee574e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processTypeDefinition() {\n      final PsiAnnotation builderAnno = PsiImplUtil.getAnnotation(myContainingClass, BUILDER_FQN);\n      if (!isApplicable(builderAnno, DEFAULT_STRATEGY_NAME)) return;\n      final PsiClass builderClass = createBuilderClass(builderAnno, myContainingClass.getCodeFields());\n      final LightMethodBuilder builderMethod = createBuilderMethod(builderClass, builderAnno);\n      myMembers.getMethods().add(builderMethod);\n    }","id":85732,"modified_method":"private void processTypeDefinition() {\n      final PsiAnnotation builderAnno = PsiImplUtil.getAnnotation(myContainingClass, BUILDER_FQN);\n      if (!isApplicable(builderAnno, DEFAULT_STRATEGY_NAME)) return;\n      final PsiClass builderClass = createBuilderClass(builderAnno, myContainingClass.getCodeFields());\n      myMembers.getMethods().add(createBuilderMethod(builderClass, builderAnno));\n      myMembers.getClasses().add(builderClass);\n    }","commit_id":"0abda35e8da9d1af5516507a76296101ceee574e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processTypeDefinition() {\n      final PsiAnnotation builderAnno = PsiImplUtil.getAnnotation(myContainingClass, BUILDER_FQN);\n      if (!isApplicable(builderAnno, INITIALIZER_STRATEGY_NAME)) return;\n\n      final PsiClass builderClass = createBuilderClass(builderAnno, myContainingClass.getCodeFields());\n      myMembers.getMethods().add(createBuilderMethod(builderClass, builderAnno));\n      myMembers.getMethods().add(createBuilderConstructor(myContainingClass, builderClass, builderAnno));\n    }","id":85733,"modified_method":"private void processTypeDefinition() {\n      final PsiAnnotation builderAnno = PsiImplUtil.getAnnotation(myContainingClass, BUILDER_FQN);\n      if (!isApplicable(builderAnno, INITIALIZER_STRATEGY_NAME)) return;\n\n      final PsiClass builderClass = createBuilderClass(builderAnno, myContainingClass.getCodeFields());\n      myMembers.getMethods().add(createBuilderMethod(builderClass, builderAnno));\n      myMembers.getMethods().add(createBuilderConstructor(myContainingClass, builderClass, builderAnno));\n      myMembers.getClasses().add(builderClass);\n    }","commit_id":"0abda35e8da9d1af5516507a76296101ceee574e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processConstructor(@NotNull GrMethod method, PsiAnnotation annotation) {\n      PsiClass builderClass = createBuilderClass(annotation, method.getParameters());\n      myMembers.getMethods().add(createBuilderMethod(builderClass, annotation));\n      myMembers.getMethods().add(createBuilderConstructor(myContainingClass, builderClass, annotation));\n    }","id":85734,"modified_method":"private void processConstructor(@NotNull GrMethod method, PsiAnnotation annotation) {\n      PsiClass builderClass = createBuilderClass(annotation, method.getParameters());\n      myMembers.getMethods().add(createBuilderMethod(builderClass, annotation));\n      myMembers.getMethods().add(createBuilderConstructor(myContainingClass, builderClass, annotation));\n      myMembers.getClasses().add(builderClass);\n    }","commit_id":"0abda35e8da9d1af5516507a76296101ceee574e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testPositionCalculations() throws IOException {\n    init(\"llrr\");\n    \n    checkOffsetConversions(0, lP(0), vL(0), vR(0), xy(0));\n    checkOffsetConversions(1, lP(1), vL(1), vR(1), xy(10));\n    checkOffsetConversions(2, lP(2), vL(2), vL(4), xy(20), xy(40));\n    checkOffsetConversions(3, lP(3), vR(3), vL(3), xy(30));\n    checkOffsetConversions(4, lP(4), vR(2), vR(4), xy(20), xy(40));\n    \n    checkLPConversions(lP(0), 0, vL(0)); \n    checkLPConversions(lS(0), 0, vR(0)); \n    checkLPConversions(lP(1), 1, vL(1)); \n    checkLPConversions(lS(1), 1, vR(1)); \n    checkLPConversions(lP(2), 2, vL(2)); \n    checkLPConversions(lS(2), 2, vL(4)); \n    checkLPConversions(lP(3), 3, vR(3)); \n    checkLPConversions(lS(3), 3, vL(3)); \n    checkLPConversions(lP(4), 4, vR(2)); \n    checkLPConversions(lS(4), 4, vR(4)); \n    checkLPConversions(lP(5), 4, vL(5)); \n    checkLPConversions(lS(5), 4, vR(5)); \n    checkLPConversions(l(1, 0, false), 4, v(1, 0, false)); \n    checkLPConversions(l(1, 0, true), 4, v(1, 0, true)); \n    \n    checkVPConversions(vL(0), lP(0), xy(0));\n    checkVPConversions(vR(0), lS(0), xy(0));\n    checkVPConversions(vL(1), lP(1), xy(10));\n    checkVPConversions(vR(1), lS(1), xy(10));\n    checkVPConversions(vL(2), lP(2), xy(20));\n    checkVPConversions(vR(2), lP(4), xy(20));\n    checkVPConversions(vL(3), lS(3), xy(30));\n    checkVPConversions(vR(3), lP(3), xy(30));\n    checkVPConversions(vL(4), lS(2), xy(40));\n    checkVPConversions(vR(4), lS(4), xy(40));\n    checkVPConversions(vL(5), lP(5), xy(50));\n    checkVPConversions(vR(5), lS(5), xy(50));\n    checkVPConversions(v(1, 0, false), l(1, 0, false), xy(0, 10));\n    checkVPConversions(v(1, 0, true), l(1, 0, true), xy(0, 10));\n    \n    checkXYConversion(xy(0),  vR(0));\n    checkXYConversion(xy(12), vR(1));\n    checkXYConversion(xy(19), vL(2));\n    checkXYConversion(xy(21), vR(2));\n    checkXYConversion(xy(27), vL(3));\n    checkXYConversion(xy(39), vL(4));\n    checkXYConversion(xy(41), vR(4));\n    checkXYConversion(xy(51), vR(5));\n  }","id":85735,"modified_method":"public void testPositionCalculations() throws IOException {\n    init(\"llrr\");\n    \n    checkOffsetConversions(0, lP(0), vL(0), vR(0), xy(0));\n    checkOffsetConversions(1, lP(1), vL(1), vR(1), xy(10));\n    checkOffsetConversions(2, lP(2), vL(2), vL(4), xy(20), xy(40));\n    checkOffsetConversions(3, lP(3), vR(3), vL(3), xy(30));\n    checkOffsetConversions(4, lP(4), vR(2), vR(4), xy(20), xy(40));\n    \n    checkLPConversions(0, 0, vL(0), vR(0)); \n    checkLPConversions(1, 1, vL(1), vR(1)); \n    checkLPConversions(2, 2, vL(2), vL(4)); \n    checkLPConversions(3, 3, vR(3), vL(3)); \n    checkLPConversions(4, 4, vR(2), vR(4)); \n    checkLPConversions(5, 4, vL(5), vR(5)); \n    checkLPConversions(l(1, 0, false), 4, v(1, 0, false)); \n    checkLPConversions(l(1, 0, true), 4, v(1, 0, true)); \n    \n    checkVPConversions(vL(0), lP(0), xy(0));\n    checkVPConversions(vR(0), lS(0), xy(0));\n    checkVPConversions(vL(1), lP(1), xy(10));\n    checkVPConversions(vR(1), lS(1), xy(10));\n    checkVPConversions(vL(2), lP(2), xy(20));\n    checkVPConversions(vR(2), lP(4), xy(20));\n    checkVPConversions(vL(3), lS(3), xy(30));\n    checkVPConversions(vR(3), lP(3), xy(30));\n    checkVPConversions(vL(4), lS(2), xy(40));\n    checkVPConversions(vR(4), lS(4), xy(40));\n    checkVPConversions(vL(5), lP(5), xy(50));\n    checkVPConversions(vR(5), lS(5), xy(50));\n    checkVPConversions(v(1, 0, false), l(1, 0, false), xy(0, 10));\n    checkVPConversions(v(1, 0, true), l(1, 0, true), xy(0, 10));\n    \n    checkXYConversion(xy(0),  vR(0));\n    checkXYConversion(xy(12), vR(1));\n    checkXYConversion(xy(19), vL(2));\n    checkXYConversion(xy(21), vR(2));\n    checkXYConversion(xy(27), vL(3));\n    checkXYConversion(xy(39), vL(4));\n    checkXYConversion(xy(41), vR(4));\n    checkXYConversion(xy(51), vR(5));\n  }","commit_id":"ebea232d78228ea36cd2db5ee2b42f06480434ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFolding() throws IOException {\n    init(\"rrrrrr\");\n    addCollapsedFoldRegion(2, 4, \"...\");\n    \n    checkOffsetConversions(0, lP(0), vL(0), vL(2), xy(0), xy(20));\n    checkOffsetConversions(1, lP(1), vR(1), vL(1), xy(10));\n    checkOffsetConversions(2, lP(2), vR(0), vR(2), xy(0), xy(20));\n    checkOffsetConversions(3, lP(3), vR(2), vR(2), xy(20));\n    checkOffsetConversions(4, lP(4), vL(5), vL(7), xy(50), xy(70));\n    checkOffsetConversions(5, lP(5), vR(6), vL(6), xy(60));\n    checkOffsetConversions(6, lP(6), vR(5), vR(7), xy(50), xy(70));\n    \n    checkLPConversions(lP(0), 0, vL(0));\n    checkLPConversions(lS(0), 0, vL(2));\n    checkLPConversions(lP(1), 1, vR(1));\n    checkLPConversions(lS(1), 1, vL(1));\n    checkLPConversions(lP(2), 2, vR(0));\n    checkLPConversions(lS(2), 2, vR(2));\n    checkLPConversions(lP(3), 3, vR(2));\n    checkLPConversions(lS(3), 3, vR(2));\n    checkLPConversions(lP(4), 4, vL(5));\n    checkLPConversions(lS(4), 4, vL(7));\n    checkLPConversions(lP(5), 5, vR(6));\n    checkLPConversions(lS(5), 5, vL(6));\n    checkLPConversions(lP(6), 6, vR(5));\n    checkLPConversions(lS(6), 6, vR(7));\n    checkLPConversions(lP(7), 6, vL(8));\n    checkLPConversions(lS(7), 6, vR(8));\n    \n    checkVPConversions(vL(0), lP(0), xy(0));\n    checkVPConversions(vR(0), lP(2), xy(0));\n    checkVPConversions(vL(1), lS(1), xy(10));\n    checkVPConversions(vR(1), lP(1), xy(10));\n    checkVPConversions(vL(2), lS(0), xy(20));\n    checkVPConversions(vR(2), lS(2), xy(20));\n    checkVPConversions(vL(3), lS(2), xy(30));\n    checkVPConversions(vR(3), lS(2), xy(30));\n    checkVPConversions(vL(4), lS(2), xy(40));\n    checkVPConversions(vR(4), lS(2), xy(40));\n    checkVPConversions(vL(5), lP(4), xy(50));\n    checkVPConversions(vR(5), lP(6), xy(50));\n    checkVPConversions(vL(6), lS(5), xy(60));\n    checkVPConversions(vR(6), lP(5), xy(60));\n    checkVPConversions(vL(7), lS(4), xy(70));\n    checkVPConversions(vR(7), lS(6), xy(70));\n    checkVPConversions(vL(8), lP(7), xy(80));\n    checkVPConversions(vR(8), lS(7), xy(80));\n    \n    checkXYConversion(xy(1), vR(0));\n    checkXYConversion(xy(9), vL(1));\n    checkXYConversion(xy(19), vL(2));\n    checkXYConversion(xy(21), vR(2));\n    checkXYConversion(xy(30), vR(3));\n    checkXYConversion(xy(39), vL(4));\n    checkXYConversion(xy(41), vR(4));\n    checkXYConversion(xy(50), vR(5));\n    checkXYConversion(xy(59), vL(6));\n    checkXYConversion(xy(69), vL(7));\n    checkXYConversion(xy(71), vR(7));\n    checkXYConversion(xy(81), vR(8));\n  }","id":85736,"modified_method":"public void testFolding() throws IOException {\n    init(\"rrrrrr\");\n    addCollapsedFoldRegion(2, 4, \"...\");\n    \n    checkOffsetConversions(0, lP(0), vL(0), vL(2), xy(0), xy(20));\n    checkOffsetConversions(1, lP(1), vR(1), vL(1), xy(10));\n    checkOffsetConversions(2, lP(2), vR(0), vR(2), xy(0), xy(20));\n    checkOffsetConversions(3, lP(3), vR(2), vR(2), xy(20));\n    checkOffsetConversions(4, lP(4), vL(5), vL(7), xy(50), xy(70));\n    checkOffsetConversions(5, lP(5), vR(6), vL(6), xy(60));\n    checkOffsetConversions(6, lP(6), vR(5), vR(7), xy(50), xy(70));\n    \n    checkLPConversions(0, 0, vL(0), vL(2));\n    checkLPConversions(1, 1, vR(1), vL(1));\n    checkLPConversions(2, 2, vR(0), vR(2));\n    checkLPConversions(3, 3, vR(2), vR(2));\n    checkLPConversions(4, 4, vL(5), vL(7));\n    checkLPConversions(5, 5, vR(6), vL(6));\n    checkLPConversions(6, 6, vR(5), vR(7));\n    checkLPConversions(7, 6, vL(8), vR(8));\n    \n    checkVPConversions(vL(0), lP(0), xy(0));\n    checkVPConversions(vR(0), lP(2), xy(0));\n    checkVPConversions(vL(1), lS(1), xy(10));\n    checkVPConversions(vR(1), lP(1), xy(10));\n    checkVPConversions(vL(2), lS(0), xy(20));\n    checkVPConversions(vR(2), lS(2), xy(20));\n    checkVPConversions(vL(3), lS(2), xy(30));\n    checkVPConversions(vR(3), lS(2), xy(30));\n    checkVPConversions(vL(4), lS(2), xy(40));\n    checkVPConversions(vR(4), lS(2), xy(40));\n    checkVPConversions(vL(5), lP(4), xy(50));\n    checkVPConversions(vR(5), lP(6), xy(50));\n    checkVPConversions(vL(6), lS(5), xy(60));\n    checkVPConversions(vR(6), lP(5), xy(60));\n    checkVPConversions(vL(7), lS(4), xy(70));\n    checkVPConversions(vR(7), lS(6), xy(70));\n    checkVPConversions(vL(8), lP(7), xy(80));\n    checkVPConversions(vR(8), lS(7), xy(80));\n    \n    checkXYConversion(xy(1), vR(0));\n    checkXYConversion(xy(9), vL(1));\n    checkXYConversion(xy(19), vL(2));\n    checkXYConversion(xy(21), vR(2));\n    checkXYConversion(xy(30), vR(3));\n    checkXYConversion(xy(39), vL(4));\n    checkXYConversion(xy(41), vR(4));\n    checkXYConversion(xy(50), vR(5));\n    checkXYConversion(xy(59), vL(6));\n    checkXYConversion(xy(69), vL(7));\n    checkXYConversion(xy(71), vR(7));\n    checkXYConversion(xy(81), vR(8));\n  }","commit_id":"ebea232d78228ea36cd2db5ee2b42f06480434ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testNumberInsideRtlText() throws IOException {\n    init(\"rr12rr\");\n\n    checkOffsetConversions(0, lP(0), vL(0), vL(6), xy(0), xy(60));\n    checkOffsetConversions(1, lP(1), vR(5), vL(5), xy(50));\n    checkOffsetConversions(2, lP(2), vR(4), vR(2), xy(40), xy(20));\n    checkOffsetConversions(3, lP(3), vL(3), vR(3), xy(30));\n    checkOffsetConversions(4, lP(4), vL(4), vL(2), xy(40), xy(20));\n    checkOffsetConversions(5, lP(5), vR(1), vL(1), xy(10));\n    checkOffsetConversions(6, lP(6), vR(0), vR(6), xy(0), xy(60));\n    \n    checkLPConversions(lP(0), 0, vL(0));\n    checkLPConversions(lS(0), 0, vL(6));\n    checkLPConversions(lP(1), 1, vR(5));\n    checkLPConversions(lS(1), 1, vL(5));\n    checkLPConversions(lP(2), 2, vR(4));\n    checkLPConversions(lS(2), 2, vR(2));\n    checkLPConversions(lP(3), 3, vL(3));\n    checkLPConversions(lS(3), 3, vR(3));\n    checkLPConversions(lP(4), 4, vL(4));\n    checkLPConversions(lS(4), 4, vL(2));\n    checkLPConversions(lP(5), 5, vR(1));\n    checkLPConversions(lS(5), 5, vL(1));\n    checkLPConversions(lP(6), 6, vR(0));\n    checkLPConversions(lS(6), 6, vR(6));\n\n    checkVPConversions(vL(0), lP(0), xy(0));\n    checkVPConversions(vR(0), lP(6), xy(0));\n    checkVPConversions(vL(1), lS(5), xy(10));\n    checkVPConversions(vR(1), lP(5), xy(10));\n    checkVPConversions(vL(2), lS(4), xy(20));\n    checkVPConversions(vR(2), lS(2), xy(20));\n    checkVPConversions(vL(3), lP(3), xy(30));\n    checkVPConversions(vR(3), lS(3), xy(30));\n    checkVPConversions(vL(4), lP(4), xy(40));\n    checkVPConversions(vR(4), lP(2), xy(40));\n    checkVPConversions(vL(5), lS(1), xy(50));\n    checkVPConversions(vR(5), lP(1), xy(50));\n    checkVPConversions(vL(6), lS(0), xy(60));\n    checkVPConversions(vR(6), lS(6), xy(60));\n\n    checkXYConversion(xy(1), vR(0));\n    checkXYConversion(xy(9), vL(1));\n    checkXYConversion(xy(19), vL(2));\n    checkXYConversion(xy(21), vR(2));\n    checkXYConversion(xy(30), vR(3));\n    checkXYConversion(xy(39), vL(4));\n    checkXYConversion(xy(41), vR(4));\n    checkXYConversion(xy(50), vR(5));\n    checkXYConversion(xy(59), vL(6));\n    checkXYConversion(xy(61), vR(6));\n  }","id":85737,"modified_method":"public void testNumberInsideRtlText() throws IOException {\n    init(\"rr12rr\");\n\n    checkOffsetConversions(0, lP(0), vL(0), vL(6), xy(0), xy(60));\n    checkOffsetConversions(1, lP(1), vR(5), vL(5), xy(50));\n    checkOffsetConversions(2, lP(2), vR(4), vR(2), xy(40), xy(20));\n    checkOffsetConversions(3, lP(3), vL(3), vR(3), xy(30));\n    checkOffsetConversions(4, lP(4), vL(4), vL(2), xy(40), xy(20));\n    checkOffsetConversions(5, lP(5), vR(1), vL(1), xy(10));\n    checkOffsetConversions(6, lP(6), vR(0), vR(6), xy(0), xy(60));\n    \n    checkLPConversions(0, 0, vL(0), vL(6));\n    checkLPConversions(1, 1, vR(5), vL(5));\n    checkLPConversions(2, 2, vR(4), vR(2));\n    checkLPConversions(3, 3, vL(3), vR(3));\n    checkLPConversions(4, 4, vL(4), vL(2));\n    checkLPConversions(5, 5, vR(1), vL(1));\n    checkLPConversions(6, 6, vR(0), vR(6));\n\n    checkVPConversions(vL(0), lP(0), xy(0));\n    checkVPConversions(vR(0), lP(6), xy(0));\n    checkVPConversions(vL(1), lS(5), xy(10));\n    checkVPConversions(vR(1), lP(5), xy(10));\n    checkVPConversions(vL(2), lS(4), xy(20));\n    checkVPConversions(vR(2), lS(2), xy(20));\n    checkVPConversions(vL(3), lP(3), xy(30));\n    checkVPConversions(vR(3), lS(3), xy(30));\n    checkVPConversions(vL(4), lP(4), xy(40));\n    checkVPConversions(vR(4), lP(2), xy(40));\n    checkVPConversions(vL(5), lS(1), xy(50));\n    checkVPConversions(vR(5), lP(1), xy(50));\n    checkVPConversions(vL(6), lS(0), xy(60));\n    checkVPConversions(vR(6), lS(6), xy(60));\n\n    checkXYConversion(xy(1), vR(0));\n    checkXYConversion(xy(9), vL(1));\n    checkXYConversion(xy(19), vL(2));\n    checkXYConversion(xy(21), vR(2));\n    checkXYConversion(xy(30), vR(3));\n    checkXYConversion(xy(39), vL(4));\n    checkXYConversion(xy(41), vR(4));\n    checkXYConversion(xy(50), vR(5));\n    checkXYConversion(xy(59), vL(6));\n    checkXYConversion(xy(61), vR(6));\n  }","commit_id":"ebea232d78228ea36cd2db5ee2b42f06480434ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private BidiRun subRun(int targetStartOffset, int targetEndOffset) {\n      assert targetStartOffset < endOffset;\n      assert targetEndOffset > startOffset;\n      if (targetStartOffset <= startOffset && targetEndOffset >= this.endOffset) {\n        return this;\n      }\n      int start = Math.max(startOffset, targetStartOffset);\n      int end = Math.min(endOffset, targetEndOffset);\n      BidiRun run = new BidiRun(level, start, end);\n      int offset = 0;\n      for (LineFragment fragment : fragments) {\n        if (end <= offset) break;\n        int endOffset = offset + fragment.getLength();\n        if (start < endOffset) {\n          run.fragments.add(fragment.subFragment(Math.max(start, offset) - offset, Math.min(end, endOffset) - offset));\n        }\n        offset = endOffset;\n      }\n      return run;\n    }","id":85738,"modified_method":"private BidiRun subRun(int targetStartOffset, int targetEndOffset) {\n      assert targetStartOffset < endOffset;\n      assert targetEndOffset > startOffset;\n      if (targetStartOffset <= startOffset && targetEndOffset >= this.endOffset) {\n        return this;\n      }\n      int start = Math.max(startOffset, targetStartOffset);\n      int end = Math.min(endOffset, targetEndOffset);\n      BidiRun run = new BidiRun(level, start, end);\n      int offset = startOffset;\n      for (LineFragment fragment : fragments) {\n        if (end <= offset) break;\n        int endOffset = offset + fragment.getLength();\n        if (start < endOffset) {\n          run.fragments.add(fragment.subFragment(Math.max(start, offset) - offset, Math.min(end, endOffset) - offset));\n        }\n        offset = endOffset;\n      }\n      return run;\n    }","commit_id":"ebea232d78228ea36cd2db5ee2b42f06480434ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void openIssueInBrowser() {\n    final String ID = \"id\";\n    SAXBuilder saxBuilder = new SAXBuilder();\n    Document document = null;\n    try {\n      document = saxBuilder.build(new StringReader(myResult.getResponseString()));\n    } catch (Exception e) {\n      LOG.error(\"Can't open created issue\", e);\n      return;\n    }\n    Element responseXML = document.getRootElement();\n    String issueId = responseXML.getAttribute(ID).getValue();\n\n    BrowserUtil.launchBrowser(Command.ISSUE_URL + issueId);\n  }","id":85739,"modified_method":"private void openIssueInBrowser() {\n    final String ID = \"id\";\n    Element responseXML = responseXML();\n    if (responseXML != null) {\n      String issueId = responseXML.getAttribute(ID).getValue();\n      BrowserUtil.launchBrowser(Command.ISSUE_BASE_URL + issueId);\n    }\n  }","commit_id":"26be2e45d20705aa3ef287e351b1c6aa763fa033","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Query createQuery() {\n    return myAnonymousRadio.isSelected() ? Query.ANONYMOUS : new Query(myUsername.getText(), myPassword.getText());\n  }","id":85740,"modified_method":"private Query createQuery() {\n    return myAnonymousRadio.isSelected() || myUsername.getText().isEmpty() ? Query.ANONYMOUS : new Query(myUsername.getText(), myPassword.getText());\n  }","commit_id":"26be2e45d20705aa3ef287e351b1c6aa763fa033","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Poster poster = new Poster(myProject);\n    Query query = createQuery();\n    query.setIssue(title);\n    query.setDescription(description.toString());\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = \"Was unable to post the issue: \\n\" + myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        message += \"\\n\" + response;\n      }\n      JOptionPane.showMessageDialog(BlameDialog.this, message, \"Error\", JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","id":85741,"modified_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Poster poster = new Poster(myProject);\n    Query query = createQuery();\n    query.setIssue(title);\n    query.setDescription(description.toString());\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        Element responseXML = responseXML();\n        if (responseXML != null && \"error\".equalsIgnoreCase(responseXML.getName())) {\n          message += \". \" + responseXML.getText();\n        } else {\n          message += \". \" + response;\n        }\n      }\n      Messages.showErrorDialog(BlameDialog.this, message, \"Error\");\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","commit_id":"26be2e45d20705aa3ef287e351b1c6aa763fa033","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static Response postIssue(HttpClient c, String summary, String description) throws IOException {\n    PostMethod p = new PostMethod(TEAMSYS + POST_ISSUE);\n    p.addParameter(PROJECT_PARAM_NAME, PROJECT);\n    p.addParameter(SUMMARY_PARAM_NAME, summary);\n    p.addParameter(DESCRIPTION_PARAM_NAME, description);\n    p.addParameter(TYPE_PARAM_NAME, EXCEPTION);\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode == 200) {\n      return new Response(\"Issue posted\", responseString, true, null);\n    } else {\n      return new Response(\"Can't post issue\", responseString, false, null);\n    }\n  }","id":85742,"modified_method":"@NotNull\n  public static Response postIssue(HttpClient c, String summary, String description) throws IOException {\n    PostMethod p = new PostMethod(YOUTRACK_BASE_URL + POST_ISSUE);\n    p.addParameter(PROJECT_PARAM_NAME, PROJECT);\n    p.addParameter(SUMMARY_PARAM_NAME, summary);\n    p.addParameter(DESCRIPTION_PARAM_NAME, description);\n    p.addParameter(TYPE_PARAM_NAME, EXCEPTION);\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode == 200) {\n      return new Response(\"Issue posted\", responseString, true, null);\n    } else {\n      return new Response(\"Can't post issue\", responseString, false, null);\n    }\n  }","commit_id":"26be2e45d20705aa3ef287e351b1c6aa763fa033","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Response login(final HttpClient c, Query query) throws IOException {\n    PostMethod p = new PostMethod(TEAMSYS + LOGIN);\n    p.addParameter(LOGIN_PARAM_NAME, query.getUser());\n    p.addParameter(PASSWORD_PARAM_NAME, query.getPassword());\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode != 200 || responseString.indexOf(\"ok\") == -1) {\n      return new Response(\"Can't login into issue tracker (status \" + statusCode + \")\", responseString, false, null);\n    } else {\n      return new Response(\"Logged in correctly\", responseString, true, null);\n    }\n  }","id":85743,"modified_method":"public static Response login(final HttpClient c, Query query) throws IOException {\n    PostMethod p = new PostMethod(YOUTRACK_BASE_URL + LOGIN);\n    p.addParameter(LOGIN_PARAM_NAME, query.getUser());\n    p.addParameter(PASSWORD_PARAM_NAME, query.getPassword());\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode != 200 || !responseString.contains(\"ok\")) {\n      return new Response(\"Can't login into issue tracker\", responseString, false, null);\n    } else {\n      return new Response(\"Logged in correctly\", responseString, true, null);\n    }\n  }","commit_id":"26be2e45d20705aa3ef287e351b1c6aa763fa033","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected String getSiteURL() {\n    return Command.TEAMSYS + \"/issues/MPS\";\n  }","id":85744,"modified_method":"protected String getSiteURL() {\n    return Command.YOUTRACK_BASE_URL + \"/issues/MPS\";\n  }","commit_id":"26be2e45d20705aa3ef287e351b1c6aa763fa033","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addEx(Throwable ex) {\n    myEx.add(ex);\n    String text = myException.getText();\n    if (text != null && text.length() > 0) {\n      myException.setText(text + \"\\n\\n\" + ex2str(ex));\n    } else {\n      myException.setText(ex2str(ex));\n    }\n  }","id":85745,"modified_method":"public void addEx(Throwable ex) {\n    myEx.add(ex);\n    myExceptionContainer.setVisible(true);\n    String text = myException.getText();\n    if (text != null && text.length() > 0) {\n      myException.setText(text + \"\\n\\n\" + ex2str(ex));\n    } else {\n      myException.setText(ex2str(ex));\n    }\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void openIssueInBrowser() {\n    final String ID = \"id\";\n    Element responseXML = responseXML();\n    if (responseXML != null) {\n      String issueId = responseXML.getAttribute(ID).getValue();\n      BrowserUtil.launchBrowser(Command.ISSUE_BASE_URL + issueId);\n    }\n  }","id":85746,"modified_method":"private void openIssueInBrowser() {\n    String id = myResult.getIssueId();\n    if (id != null) {\n      BrowserUtil.launchBrowser(Command.ISSUE_BASE_URL + id);\n    }\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Query createQuery() {\n    return myAnonymousRadio.isSelected() || myUsername.getText().isEmpty() ? Query.ANONYMOUS : new Query(myUsername.getText(), myPassword.getText());\n  }","id":85747,"modified_method":"private Query createQuery() {\n    return myAnonymousRadio.isSelected() || myUsername.getText().isEmpty() ? Query.ANONYMOUS : new Query(myUsername.getText(), new String(myPassword.getPassword()));\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Poster poster = new Poster(myProject);\n    Query query = createQuery();\n    query.setIssue(title);\n    query.setDescription(description.toString());\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        Element responseXML = responseXML();\n        if (responseXML != null && \"error\".equalsIgnoreCase(responseXML.getName())) {\n          message += \". \" + responseXML.getText();\n        } else {\n          message += \". \" + response;\n        }\n      }\n      Messages.showErrorDialog(BlameDialog.this, message, \"Error\");\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","id":85748,"modified_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Poster poster = new Poster(myProject);\n    Query query = createQuery();\n    query.setIssueTitle(title);\n    query.setDescription(description.toString());\n    query.setFiles(myFilesToAttach.toArray(new File[myFilesToAttach.size()]));\n    query.setHidden(myHiddenCheckBox.isSelected());\n    query.setSubsystem(mySubsystem);\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        Element responseXml = myResult.getResponseXml();\n        if (responseXml != null && \"error\".equalsIgnoreCase(responseXml.getName())) {\n          message += \". \" + responseXml.getText();\n        } else {\n          message += \". \" + response;\n        }\n      }\n      Messages.showErrorDialog(BlameDialog.this, message, \"Error\");\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void init() {\n    setModal(true);\n\n    myAnonymousRadio.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean enabled = !myAnonymousRadio.getModel().isSelected();\n        myUsername.setEnabled(enabled);\n        myPassword.setEnabled(enabled);\n        myTestLoginButton.setEnabled(enabled);\n      }\n    });\n\n    myTestLoginButton.setAction(new AbstractAction(\"Test Login\") {\n      public void actionPerformed(ActionEvent e) {\n        Poster poster = new Poster(myProject);\n        Query query = createQuery();\n\n        Response response = poster.test(query);\n        if (response.isSuccess()) {\n          Messages.showMessageDialog(myProject, response.getMessage(), \"Test Login\", Messages.getInformationIcon());\n        } else {\n          Messages.showErrorDialog(myProject, response.getMessage(), \"Test Login Failed\");\n          LOG.warning(\"Submit failed: \" + response.getMessage() + \":\" + response.getResponseString(), response.getThrowable());\n        }\n      }\n    });\n  }","id":85749,"modified_method":"private void init() {\n    setModal(true);\n    myExceptionContainer.setVisible(false);\n\n    myAnonymousRadio.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean enabled = !myAnonymousRadio.getModel().isSelected();\n        myUsername.setEnabled(enabled);\n        myPassword.setEnabled(enabled);\n        myTestLoginButton.setEnabled(enabled);\n      }\n    });\n\n    myTestLoginButton.setAction(new AbstractAction(\"Test Login\") {\n      public void actionPerformed(ActionEvent e) {\n        Poster poster = new Poster(myProject);\n        Query query = createQuery();\n\n        Response response = poster.test(query);\n        if (response.isSuccess()) {\n          Messages.showMessageDialog(myProject, response.getMessage(), \"Test Login\", Messages.getInformationIcon());\n        } else {\n          Messages.showErrorDialog(myProject, response.getMessage(), \"Test Login Failed\");\n          LOG.warning(\"Submit failed: \" + response.getMessage() + \":\" + response.getResponseString(), response.getThrowable());\n        }\n      }\n    });\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    panel1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final Spacer spacer1 = new Spacer();\n    panel1.add(spacer1, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new GridLayoutManager(3, 3, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new GridConstraints(2, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new GridConstraints(2, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer2 = new Spacer();\n    panel1.add(spacer2, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new GridLayoutManager(6, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Optional Description:\");\n    panel2.add(label3, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer3 = new Spacer();\n    panel2.add(spacer3, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new GridConstraints(3, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    final JScrollPane scrollPane2 = new JScrollPane();\n    panel2.add(scrollPane2, new GridConstraints(5, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 220), null, 0, false));\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer4 = new Spacer();\n    panel2.add(spacer4, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    panel2.add(label5, new GridConstraints(4, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer5 = new Spacer();\n    panel2.add(spacer5, new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","id":85750,"modified_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    panel1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final Spacer spacer1 = new Spacer();\n    panel1.add(spacer1, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new GridLayoutManager(3, 3, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new GridConstraints(2, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new GridConstraints(2, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer2 = new Spacer();\n    panel1.add(spacer2, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new GridLayoutManager(8, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Description (what did you do,what happened instead of expected behavior):\");\n    panel2.add(label3, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer3 = new Spacer();\n    panel2.add(spacer3, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new GridConstraints(3, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer4 = new Spacer();\n    panel2.add(spacer4, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final Spacer spacer5 = new Spacer();\n    panel2.add(spacer5, new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    myHiddenCheckBox = new JCheckBox();\n    myHiddenCheckBox.setText(\"Visible only to MPS developers\");\n    myHiddenCheckBox.setToolTipText(\"Select this if you want this bug report will be visible only to you and MPS developers \");\n    panel2.add(myHiddenCheckBox, new GridConstraints(7, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myExceptionContainer = new JPanel();\n    myExceptionContainer.setLayout(new GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myExceptionContainer.setEnabled(true);\n    panel2.add(myExceptionContainer, new GridConstraints(6, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    myExceptionContainer.add(label5, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer6 = new Spacer();\n    myExceptionContainer.add(spacer6, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JScrollPane scrollPane2 = new JScrollPane();\n    myExceptionContainer.add(scrollPane2, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 220), null, 0, false));\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static Response postIssue(HttpClient c, String summary, String description) throws IOException {\n    PostMethod p = new PostMethod(YOUTRACK_BASE_URL + POST_ISSUE);\n    p.addParameter(PROJECT_PARAM_NAME, PROJECT);\n    p.addParameter(SUMMARY_PARAM_NAME, summary);\n    p.addParameter(DESCRIPTION_PARAM_NAME, description);\n    p.addParameter(TYPE_PARAM_NAME, EXCEPTION);\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode == 200) {\n      return new Response(\"Issue posted\", responseString, true, null);\n    } else {\n      return new Response(\"Can't post issue\", responseString, false, null);\n    }\n  }","id":85751,"modified_method":"@NotNull\n  public static Response postIssue(HttpClient c, String summary, String description, boolean hidden,  File... files) throws IOException {\n    PostMethod p = new PostMethod(YOUTRACK_BASE_URL + POST_ISSUE);\n    p.addParameter(PROJECT_PARAM_NAME, PROJECT);\n    p.addParameter(SUMMARY_PARAM_NAME, summary);\n    p.addParameter(DESCRIPTION_PARAM_NAME, description);\n    p.addParameter(TYPE_PARAM_NAME, EXCEPTION);\n    if (hidden) {\n      p.addParameter(PERMITTED_GROUP_PARAM_NAME, MPS_GROUP_NAME);\n    }\n    if (files.length != 0) {\n      List<Part> parts = new ArrayList<Part>();\n      for (NameValuePair nameValuePair : p.getParameters()) {\n        parts.add(new StringPart(nameValuePair.getName(), nameValuePair.getValue()));\n      }\n      for (File file : files) {\n        parts.add(new FilePart(file.getName(), file));\n      }\n      p.setRequestEntity(new MultipartRequestEntity(parts.toArray(new Part[parts.size()]), p.getParams()));\n    }\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode == 200) {\n      return new Response(\"Issue posted\", responseString, true, null);\n    } else {\n      return new Response(\"Can't post issue\", responseString, false, null);\n    }\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Response send(final Query query) {\n    Performable send = new Performable() {\n      @NotNull\n      public Response perform() throws Exception {\n        HttpClient client = new HttpClient();\n        setTimeouts(client);\n        Response r = Command.login(client, query);\n        if (r.isSuccess()) {\n          r = Command.postIssue(client, query.getIssue(), query.getDescription());\n        }\n        return r;\n      }\n    };\n    return myExecutor.execute(send);\n  }","id":85752,"modified_method":"@NotNull\n  public Response send(final Query query) {\n    Performable send = new Performable() {\n      @NotNull\n      public Response perform() throws Exception {\n        HttpClient client = new HttpClient();\n        setTimeouts(client);\n        Response r = Command.login(client, query);\n        if (r.isSuccess()) {\n          r = Command.postIssue(client, query.getIssueTitle(), query.getDescription(), query.isHidden(), query.getFiles());\n          String subsystem = query.getSubsystem();\n          String id = r.getIssueId();\n          if (r.isSuccess() && subsystem != null && id != null) {\n            Command.setIssueSubsystem(client, id, subsystem);\n          }\n        }\n        return r;\n      }\n    };\n    return myExecutor.execute(send);\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getIssue() {\n    return myIssue;\n  }","id":85753,"modified_method":"@NotNull\n  public String getIssueTitle() {\n    return myIssueTitle;\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setIssue(String issue) {\n    myIssue = issue;\n  }","id":85754,"modified_method":"public void setIssueTitle(@NotNull String issueTitle) {\n    myIssueTitle = issueTitle;\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Query(String user, String password) {\n    this(user, password, null, null);\n  }","id":85755,"modified_method":"public Query(@NotNull String user, @NotNull String password) {\n    myUser = user;\n    myPassword = password;\n  }","commit_id":"d81241882d86c8356e1192e5701afa3683d791e5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Query createQuery() {\n    return myAnonymousRadio.isSelected() || myUsername.getText().isEmpty() ? Query.ANONYMOUS : new Query(myUsername.getText(), myPassword.getText());\n  }","id":85756,"modified_method":"private Query createQuery() {\n    return myAnonymousRadio.isSelected() || myUsername.getText().isEmpty() ? Query.ANONYMOUS : new Query(myUsername.getText(), new String(myPassword.getPassword()));\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void init() {\n    setModal(true);\n\n    myAnonymousRadio.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean enabled = !myAnonymousRadio.getModel().isSelected();\n        myUsername.setEnabled(enabled);\n        myPassword.setEnabled(enabled);\n        myTestLoginButton.setEnabled(enabled);\n      }\n    });\n\n    myTestLoginButton.setAction(new AbstractAction(\"Test Login\") {\n      public void actionPerformed(ActionEvent e) {\n        Poster poster = new Poster(myProject);\n        Query query = createQuery();\n\n        Response response = poster.test(query);\n        if (response.isSuccess()) {\n          Messages.showMessageDialog(myProject, response.getMessage(), \"Test Login\", Messages.getInformationIcon());\n        } else {\n          Messages.showErrorDialog(myProject, response.getMessage(), \"Test Login Failed\");\n          LOG.warning(\"Submit failed: \" + response.getMessage() + \":\" + response.getResponseString(), response.getThrowable());\n        }\n      }\n    });\n  }","id":85757,"modified_method":"private void init() {\n    setModal(true);\n    myExceptionContainer.setVisible(false);\n\n    myAnonymousRadio.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        boolean enabled = !myAnonymousRadio.getModel().isSelected();\n        myUsername.setEnabled(enabled);\n        myPassword.setEnabled(enabled);\n        myTestLoginButton.setEnabled(enabled);\n      }\n    });\n\n    myTestLoginButton.setAction(new AbstractAction(\"Test Login\") {\n      public void actionPerformed(ActionEvent e) {\n        Poster poster = new Poster(myProject);\n        Query query = createQuery();\n\n        Response response = poster.test(query);\n        if (response.isSuccess()) {\n          Messages.showMessageDialog(myProject, response.getMessage(), \"Test Login\", Messages.getInformationIcon());\n        } else {\n          Messages.showErrorDialog(myProject, response.getMessage(), \"Test Login Failed\");\n          LOG.warning(\"Submit failed: \" + response.getMessage() + \":\" + response.getResponseString(), response.getThrowable());\n        }\n      }\n    });\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addEx(Throwable ex) {\n    myEx.add(ex);\n    String text = myException.getText();\n    if (text != null && text.length() > 0) {\n      myException.setText(text + \"\\n\\n\" + ex2str(ex));\n    } else {\n      myException.setText(ex2str(ex));\n    }\n  }","id":85758,"modified_method":"public void addEx(Throwable ex) {\n    myEx.add(ex);\n    myExceptionContainer.setVisible(true);\n    String text = myException.getText();\n    if (text != null && text.length() > 0) {\n      myException.setText(text + \"\\n\\n\" + ex2str(ex));\n    } else {\n      myException.setText(ex2str(ex));\n    }\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Poster poster = new Poster(myProject);\n    Query query = createQuery();\n    query.setIssue(title);\n    query.setDescription(description.toString());\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        Element responseXML = responseXML();\n        if (responseXML != null && \"error\".equalsIgnoreCase(responseXML.getName())) {\n          message += \". \" + responseXML.getText();\n        } else {\n          message += \". \" + response;\n        }\n      }\n      Messages.showErrorDialog(BlameDialog.this, message, \"Error\");\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","id":85759,"modified_method":"@Button(position = 0, name = \"Send\", mnemonic = 'S')\n  public void onSend() {\n    String title = getBuildString() + myTitleField.getText();\n\n    StringBuilder description = new StringBuilder(1000);\n    if (myTitleField.getText().trim().length() != 0) {\n      description.append(myTitleField.getText());\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(myDescription.getText());\n    if (description.length() != 0) {\n      description.append(\"\\n\\n\");\n    }\n\n    description.append(getAdditionalInfo());\n    description.append(\"\\n\\n\\n\");\n\n    for (Throwable ex : myEx) {\n      description.append(ex2str(ex)).append(\"\\n\\n\");\n    }\n\n    Poster poster = new Poster(myProject);\n    Query query = createQuery();\n    query.setIssueTitle(title);\n    query.setDescription(description.toString());\n    query.setFiles(myFilesToAttach.toArray(new File[myFilesToAttach.size()]));\n    query.setHidden(myHiddenCheckBox.isSelected());\n    query.setSubsystem(mySubsystem);\n    myResult = poster.send(query);\n\n    if (!myResult.isSuccess()) {\n      String message = myResult.getMessage();\n      String response = myResult.getResponseString();\n      if (response != null && !response.equals(\"\")) {\n        Element responseXml = myResult.getResponseXml();\n        if (responseXml != null && \"error\".equalsIgnoreCase(responseXml.getName())) {\n          message += \". \" + responseXml.getText();\n        } else {\n          message += \". \" + response;\n        }\n      }\n      Messages.showErrorDialog(BlameDialog.this, message, \"Error\");\n      return;\n    }\n\n    openIssueInBrowser();\n\n    myIsCancelled = false;\n    BlameDialogComponent.getInstance().loadState(getState());\n    dispose();\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    panel1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final Spacer spacer1 = new Spacer();\n    panel1.add(spacer1, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new GridLayoutManager(3, 3, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new GridConstraints(2, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new GridConstraints(2, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer2 = new Spacer();\n    panel1.add(spacer2, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new GridLayoutManager(6, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Optional Description:\");\n    panel2.add(label3, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer3 = new Spacer();\n    panel2.add(spacer3, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new GridConstraints(3, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    final JScrollPane scrollPane2 = new JScrollPane();\n    panel2.add(scrollPane2, new GridConstraints(5, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 220), null, 0, false));\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer4 = new Spacer();\n    panel2.add(spacer4, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    panel2.add(label5, new GridConstraints(4, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer5 = new Spacer();\n    panel2.add(spacer5, new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","id":85760,"modified_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    panel1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final Spacer spacer1 = new Spacer();\n    panel1.add(spacer1, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new GridLayoutManager(3, 3, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new GridConstraints(2, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword, new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new GridConstraints(2, 2, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer2 = new Spacer();\n    panel1.add(spacer2, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new GridLayoutManager(8, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Description (what did you do,what happened instead of expected behavior):\");\n    panel2.add(label3, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer3 = new Spacer();\n    panel2.add(spacer3, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new GridConstraints(3, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer4 = new Spacer();\n    panel2.add(spacer4, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final Spacer spacer5 = new Spacer();\n    panel2.add(spacer5, new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    myHiddenCheckBox = new JCheckBox();\n    myHiddenCheckBox.setText(\"Visible only to MPS developers\");\n    myHiddenCheckBox.setToolTipText(\"Select this if you want this bug report will be visible only to you and MPS developers \");\n    panel2.add(myHiddenCheckBox, new GridConstraints(7, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myExceptionContainer = new JPanel();\n    myExceptionContainer.setLayout(new GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myExceptionContainer.setEnabled(true);\n    panel2.add(myExceptionContainer, new GridConstraints(6, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    myExceptionContainer.add(label5, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer6 = new Spacer();\n    myExceptionContainer.add(spacer6, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0, false));\n    final JScrollPane scrollPane2 = new JScrollPane();\n    myExceptionContainer.add(scrollPane2, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 220), null, 0, false));\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void openIssueInBrowser() {\n    final String ID = \"id\";\n    Element responseXML = responseXML();\n    if (responseXML != null) {\n      String issueId = responseXML.getAttribute(ID).getValue();\n      BrowserUtil.launchBrowser(Command.ISSUE_BASE_URL + issueId);\n    }\n  }","id":85761,"modified_method":"private void openIssueInBrowser() {\n    String id = myResult.getIssueId();\n    if (id != null) {\n      BrowserUtil.launchBrowser(Command.ISSUE_BASE_URL + id);\n    }\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public static Response postIssue(HttpClient c, String summary, String description) throws IOException {\n    PostMethod p = new PostMethod(YOUTRACK_BASE_URL + POST_ISSUE);\n    p.addParameter(PROJECT_PARAM_NAME, PROJECT);\n    p.addParameter(SUMMARY_PARAM_NAME, summary);\n    p.addParameter(DESCRIPTION_PARAM_NAME, description);\n    p.addParameter(TYPE_PARAM_NAME, EXCEPTION);\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode == 200) {\n      return new Response(\"Issue posted\", responseString, true, null);\n    } else {\n      return new Response(\"Can't post issue\", responseString, false, null);\n    }\n  }","id":85762,"modified_method":"@NotNull\n  public static Response postIssue(HttpClient c, String summary, String description, boolean hidden,  File... files) throws IOException {\n    PostMethod p = new PostMethod(YOUTRACK_BASE_URL + POST_ISSUE);\n    p.addParameter(PROJECT_PARAM_NAME, PROJECT);\n    p.addParameter(SUMMARY_PARAM_NAME, summary);\n    p.addParameter(DESCRIPTION_PARAM_NAME, description);\n    p.addParameter(TYPE_PARAM_NAME, EXCEPTION);\n    if (hidden) {\n      p.addParameter(PERMITTED_GROUP_PARAM_NAME, MPS_GROUP_NAME);\n    }\n    if (files.length != 0) {\n      List<Part> parts = new ArrayList<Part>();\n      for (NameValuePair nameValuePair : p.getParameters()) {\n        parts.add(new StringPart(nameValuePair.getName(), nameValuePair.getValue()));\n      }\n      for (File file : files) {\n        parts.add(new FilePart(file.getName(), file));\n      }\n      p.setRequestEntity(new MultipartRequestEntity(parts.toArray(new Part[parts.size()]), p.getParams()));\n    }\n    c.executeMethod(p);\n\n    int statusCode = p.getStatusCode();\n    String responseString = p.getResponseBodyAsString();\n    if (statusCode == 200) {\n      return new Response(\"Issue posted\", responseString, true, null);\n    } else {\n      return new Response(\"Can't post issue\", responseString, false, null);\n    }\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  public Response send(final Query query) {\n    Performable send = new Performable() {\n      @NotNull\n      public Response perform() throws Exception {\n        HttpClient client = new HttpClient();\n        setTimeouts(client);\n        Response r = Command.login(client, query);\n        if (r.isSuccess()) {\n          r = Command.postIssue(client, query.getIssue(), query.getDescription());\n        }\n        return r;\n      }\n    };\n    return myExecutor.execute(send);\n  }","id":85763,"modified_method":"@NotNull\n  public Response send(final Query query) {\n    Performable send = new Performable() {\n      @NotNull\n      public Response perform() throws Exception {\n        HttpClient client = new HttpClient();\n        setTimeouts(client);\n        Response r = Command.login(client, query);\n        if (r.isSuccess()) {\n          r = Command.postIssue(client, query.getIssueTitle(), query.getDescription(), query.isHidden(), query.getFiles());\n          String subsystem = query.getSubsystem();\n          String id = r.getIssueId();\n          if (r.isSuccess() && subsystem != null && id != null) {\n            Command.setIssueSubsystem(client, id, subsystem);\n          }\n        }\n        return r;\n      }\n    };\n    return myExecutor.execute(send);\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Query(String user, String password) {\n    this(user, password, null, null);\n  }","id":85764,"modified_method":"public Query(@NotNull String user, @NotNull String password) {\n    myUser = user;\n    myPassword = password;\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getIssue() {\n    return myIssue;\n  }","id":85765,"modified_method":"@NotNull\n  public String getIssueTitle() {\n    return myIssueTitle;\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setIssue(String issue) {\n    myIssue = issue;\n  }","id":85766,"modified_method":"public void setIssueTitle(@NotNull String issueTitle) {\n    myIssueTitle = issueTitle;\n  }","commit_id":"edf27bd1738594dca20bf306619a2c56d6274e68","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public Request onRequestHeaders(final HeadersListener listener)\n    {\n        this.requestListeners.add(new HeadersListener()\n        {\n            @Override\n            public void onHeaders(Request request)\n            {\n                listener.onHeaders(request);\n            }\n        });\n        return this;\n    }","id":85767,"modified_method":"@Override\n    public Request onRequestHeaders(final HeadersListener listener)\n    {\n        return requestListener(new HeadersListener()\n        {\n            @Override\n            public void onHeaders(Request request)\n            {\n                listener.onHeaders(request);\n            }\n        });\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request onRequestBegin(final BeginListener listener)\n    {\n        this.requestListeners.add(new BeginListener()\n        {\n            @Override\n            public void onBegin(Request request)\n            {\n                listener.onBegin(request);\n            }\n        });\n        return this;\n    }","id":85768,"modified_method":"@Override\n    public Request onRequestBegin(final BeginListener listener)\n    {\n        return requestListener(new BeginListener()\n        {\n            @Override\n            public void onBegin(Request request)\n            {\n                listener.onBegin(request);\n            }\n        });\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request onRequestContent(final ContentListener listener)\n    {\n        this.requestListeners.add(new ContentListener()\n        {\n            @Override\n            public void onContent(Request request, ByteBuffer content)\n            {\n                listener.onContent(request, content);\n            }\n        });\n        return this;\n    }","id":85769,"modified_method":"@Override\n    public Request onRequestContent(final ContentListener listener)\n    {\n        return requestListener(new ContentListener()\n        {\n            @Override\n            public void onContent(Request request, ByteBuffer content)\n            {\n                listener.onContent(request, content);\n            }\n        });\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request onRequestCommit(final CommitListener listener)\n    {\n        this.requestListeners.add(new CommitListener()\n        {\n            @Override\n            public void onCommit(Request request)\n            {\n                listener.onCommit(request);\n            }\n        });\n        return this;\n    }","id":85770,"modified_method":"@Override\n    public Request onRequestCommit(final CommitListener listener)\n    {\n        return requestListener(new CommitListener()\n        {\n            @Override\n            public void onCommit(Request request)\n            {\n                listener.onCommit(request);\n            }\n        });\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request listener(Request.Listener listener)\n    {\n        this.requestListeners.add(listener);\n        return this;\n    }","id":85771,"modified_method":"@Override\n    public Request listener(Request.Listener listener)\n    {\n        return requestListener(listener);\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request onRequestFailure(final FailureListener listener)\n    {\n        this.requestListeners.add(new FailureListener()\n        {\n            @Override\n            public void onFailure(Request request, Throwable failure)\n            {\n                listener.onFailure(request, failure);\n            }\n        });\n        return this;\n    }","id":85772,"modified_method":"@Override\n    public Request onRequestFailure(final FailureListener listener)\n    {\n        return requestListener(new FailureListener()\n        {\n            @Override\n            public void onFailure(Request request, Throwable failure)\n            {\n                listener.onFailure(request, failure);\n            }\n        });\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request onRequestSuccess(final SuccessListener listener)\n    {\n        this.requestListeners.add(new SuccessListener()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                listener.onSuccess(request);\n            }\n        });\n        return this;\n    }","id":85773,"modified_method":"@Override\n    public Request onRequestSuccess(final SuccessListener listener)\n    {\n        return requestListener(new SuccessListener()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                listener.onSuccess(request);\n            }\n        });\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request onRequestQueued(final QueuedListener listener)\n    {\n        this.requestListeners.add(new QueuedListener()\n        {\n            @Override\n            public void onQueued(Request request)\n            {\n                listener.onQueued(request);\n            }\n        });\n        return this;\n    }","id":85774,"modified_method":"@Override\n    public Request onRequestQueued(final QueuedListener listener)\n    {\n        return requestListener(new QueuedListener()\n        {\n            @Override\n            public void onQueued(Request request)\n            {\n                listener.onQueued(request);\n            }\n        });\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Map<String, Object> getAttributes()\n    {\n        return attributes;\n    }","id":85775,"modified_method":"@Override\n    public Map<String, Object> getAttributes()\n    {\n        return attributes != null ? attributes : Collections.<String, Object>emptyMap();\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Request attribute(String name, Object value)\n    {\n        attributes.put(name, value);\n        return this;\n    }","id":85776,"modified_method":"@Override\n    public Request attribute(String name, Object value)\n    {\n        if (attributes == null)\n            attributes = new HashMap<>(4);\n        attributes.put(name, value);\n        return this;\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T extends RequestListener> List<T> getRequestListeners(Class<T> type)\n    {\n        // This method is invoked often in a request/response conversation,\n        // so we avoid allocation if there is no need to filter.\n        if (type == null)\n            return (List<T>)requestListeners;\n\n        ArrayList<T> result = new ArrayList<>();\n        for (RequestListener listener : requestListeners)\n            if (type.isInstance(listener))\n                result.add((T)listener);\n        return result;\n    }","id":85777,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T extends RequestListener> List<T> getRequestListeners(Class<T> type)\n    {\n        // This method is invoked often in a request/response conversation,\n        // so we avoid allocation if there is no need to filter.\n        if (type == null || requestListeners == null)\n            return requestListeners != null ? (List<T>)requestListeners : Collections.<T>emptyList();\n\n        ArrayList<T> result = new ArrayList<>();\n        for (RequestListener listener : requestListeners)\n            if (type.isInstance(listener))\n                result.add((T)listener);\n        return result;\n    }","commit_id":"fa51281546f4c33e6d6da8b08b202280e8f7df6b","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void allignbottom()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int max = -99999;\r\n\r\n        // First look for the maximum y coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.y > max) max = p.y;\r\n        }\r\n        \r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            element.setLocation(p.x, max);\r\n            after[i] = new Point(p.x, max);\r\n        }\r\n        \r\n        addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","id":85778,"modified_method":"public void allignbottom()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int max = -99999;\r\n\r\n        // First look for the maximum y coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.y > max) max = p.y;\r\n        }\r\n        \r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            element.setLocation(p.x, max);\r\n            after[i] = new Point(p.x, max);\r\n        }\r\n        \r\n        if (addUndoPositionInterface!=null) addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","commit_id":"96782f344a1fffee1fee0d29fa8705c54346f3a5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void distributehorizontal()\r\n    {\r\n        if (elements.size() <= 1) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n        int max = -99999;\r\n\r\n        int order[] = new int[elements.size()];\r\n\r\n        // First look for the minimum & maximum x coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.x < min) min = p.x;\r\n            if (p.x > max) max = p.x;\r\n            order[i] = i;\r\n        }\r\n\r\n        // Difficult to keep the steps in the correct order.\r\n        // If you just set the x-coordinates, you get special effects.\r\n        // Best is to keep the current order of things.\r\n        // First build an arraylist and store the order there.\r\n        // Then sort order[], based upon the coordinate of the step.\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            for (int j = 0; j < elements.size() - 1; j++)\r\n            {\r\n                Point p1 = ((GUIPositionInterface)elements.get(order[j])).getLocation();\r\n                Point p2 = ((GUIPositionInterface)elements.get(order[j+1])).getLocation();\r\n                if (p1.x > p2.x) // swap\r\n                {\r\n                    int dummy = order[j];\r\n                    order[j] = order[j + 1];\r\n                    order[j + 1] = dummy;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The distance between two steps becomes.\r\n        int distance = (max - min) / (elements.size() - 1);\r\n\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface)elements.get(order[i]);\r\n            \r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            p.x = min + (i * distance);\r\n            after[i] = new Point(p.x, p.y);\r\n        }\r\n\r\n        // Undo!\r\n        addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","id":85779,"modified_method":"public void distributehorizontal()\r\n    {\r\n        if (elements.size() <= 1) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n        int max = -99999;\r\n\r\n        int order[] = new int[elements.size()];\r\n\r\n        // First look for the minimum & maximum x coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.x < min) min = p.x;\r\n            if (p.x > max) max = p.x;\r\n            order[i] = i;\r\n        }\r\n\r\n        // Difficult to keep the steps in the correct order.\r\n        // If you just set the x-coordinates, you get special effects.\r\n        // Best is to keep the current order of things.\r\n        // First build an arraylist and store the order there.\r\n        // Then sort order[], based upon the coordinate of the step.\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            for (int j = 0; j < elements.size() - 1; j++)\r\n            {\r\n                Point p1 = ((GUIPositionInterface)elements.get(order[j])).getLocation();\r\n                Point p2 = ((GUIPositionInterface)elements.get(order[j+1])).getLocation();\r\n                if (p1.x > p2.x) // swap\r\n                {\r\n                    int dummy = order[j];\r\n                    order[j] = order[j + 1];\r\n                    order[j + 1] = dummy;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The distance between two steps becomes.\r\n        int distance = (max - min) / (elements.size() - 1);\r\n\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface)elements.get(order[i]);\r\n            \r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            p.x = min + (i * distance);\r\n            after[i] = new Point(p.x, p.y);\r\n        }\r\n\r\n        // Undo!\r\n        if (addUndoPositionInterface!=null) addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","commit_id":"96782f344a1fffee1fee0d29fa8705c54346f3a5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void snaptogrid(int size)\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        // First look for the minimum x coordinate...\r\n\r\n        GUIPositionInterface elemArray[] = new GUIPositionInterface[elements.size()];\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface positionInterface = (GUIPositionInterface)elements.get(i);\r\n\r\n            elemArray[i] = positionInterface;\r\n            Point p = positionInterface.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n\r\n            // What's the modulus ?\r\n            int dx = p.x % size;\r\n            int dy = p.y % size;\r\n\r\n            // Correct the location to the nearest grid line!\r\n            // This means for size = 10\r\n            // x = 3: dx=3, dx<=5 --> x=3-3 = 0;\r\n            // x = 7: dx=7, dx> 5 --> x=3+10-3 = 10;\r\n            // x = 10: dx=0, dx<=5 --> x=10-0 = 10;\r\n\r\n            if (dx > size / 2)\r\n                p.x += size - dx;\r\n            else\r\n                p.x -= dx;\r\n            if (dy > size / 2)\r\n                p.y += size - dy;\r\n            else\r\n                p.y -= dy;\r\n            after[i] = new Point(p.x, p.y);\r\n        }\r\n\r\n        addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","id":85780,"modified_method":"public void snaptogrid(int size)\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        // First look for the minimum x coordinate...\r\n\r\n        GUIPositionInterface elemArray[] = new GUIPositionInterface[elements.size()];\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface positionInterface = (GUIPositionInterface)elements.get(i);\r\n\r\n            elemArray[i] = positionInterface;\r\n            Point p = positionInterface.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n\r\n            // What's the modulus ?\r\n            int dx = p.x % size;\r\n            int dy = p.y % size;\r\n\r\n            // Correct the location to the nearest grid line!\r\n            // This means for size = 10\r\n            // x = 3: dx=3, dx<=5 --> x=3-3 = 0;\r\n            // x = 7: dx=7, dx> 5 --> x=3+10-3 = 10;\r\n            // x = 10: dx=0, dx<=5 --> x=10-0 = 10;\r\n\r\n            if (dx > size / 2)\r\n                p.x += size - dx;\r\n            else\r\n                p.x -= dx;\r\n            if (dy > size / 2)\r\n                p.y += size - dy;\r\n            else\r\n                p.y -= dy;\r\n            after[i] = new Point(p.x, p.y);\r\n        }\r\n\r\n        if (addUndoPositionInterface!=null) addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","commit_id":"96782f344a1fffee1fee0d29fa8705c54346f3a5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void allignright()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int max = -99999;\r\n\r\n        // First look for the maximum x coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.x > max) max = p.x;\r\n        }\r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface stepMeta = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = stepMeta.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            stepMeta.setLocation(max, p.y);\r\n            after[i] = new Point(max, p.y);\r\n        }\r\n        \r\n        addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","id":85781,"modified_method":"public void allignright()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int max = -99999;\r\n\r\n        // First look for the maximum x coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.x > max) max = p.x;\r\n        }\r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface stepMeta = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = stepMeta.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            stepMeta.setLocation(max, p.y);\r\n            after[i] = new Point(max, p.y);\r\n        }\r\n        \r\n        if (addUndoPositionInterface!=null) addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","commit_id":"96782f344a1fffee1fee0d29fa8705c54346f3a5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void allignleft()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n\r\n        // First look for the minimum x coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n            Point p = element.getLocation();\r\n            if (p.x < min) min = p.x;\r\n        }\r\n\r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            element.setLocation(min, p.y);\r\n            after[i] = new Point(min, p.y);\r\n        }\r\n        \r\n        addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","id":85782,"modified_method":"public void allignleft()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n\r\n        // First look for the minimum x coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n            Point p = element.getLocation();\r\n            if (p.x < min) min = p.x;\r\n        }\r\n\r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            element.setLocation(min, p.y);\r\n            after[i] = new Point(min, p.y);\r\n        }\r\n        \r\n        if (addUndoPositionInterface!=null) addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","commit_id":"96782f344a1fffee1fee0d29fa8705c54346f3a5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void distributevertical()\r\n    {\r\n        if (elements.size() <= 1) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n        int max = -99999;\r\n\r\n        int order[] = new int[elements.size()];\r\n\r\n        // First look for the minimum & maximum y coordinate...\r\n        int selnr = 0;\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.y < min) min = p.y;\r\n            if (p.y > max) max = p.y;\r\n            order[i] = i;\r\n            selnr++;\r\n        }\r\n\r\n        // Difficult to keep the steps in the correct order.\r\n        // If you just set the x-coordinates, you get special effects.\r\n        // Best is to keep the current order of things.\r\n        // First build an arraylist and store the order there.\r\n        // Then sort order[], based upon the coordinate of the step.\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            for (int j = 0; j < elements.size() - 1; j++)\r\n            {\r\n                Point p1 = ((GUIPositionInterface)elements.get(order[j])).getLocation();\r\n                Point p2 = ((GUIPositionInterface)elements.get(order[j+1])).getLocation();\r\n                if (p1.y > p2.y) // swap\r\n                {\r\n                    int dummy = order[j];\r\n                    order[j] = order[j + 1];\r\n                    order[j + 1] = dummy;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The distance between two steps becomes.\r\n        int distance = (max - min) / (elements.size() - 1);\r\n\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(order[i]);\r\n\r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            p.y = min + (i * distance);\r\n            after[i] = new Point(p.x, p.y);\r\n        }\r\n\r\n        // Undo!\r\n        addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","id":85783,"modified_method":"public void distributevertical()\r\n    {\r\n        if (elements.size() <= 1) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n        int max = -99999;\r\n\r\n        int order[] = new int[elements.size()];\r\n\r\n        // First look for the minimum & maximum y coordinate...\r\n        int selnr = 0;\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n\r\n            Point p = element.getLocation();\r\n            if (p.y < min) min = p.y;\r\n            if (p.y > max) max = p.y;\r\n            order[i] = i;\r\n            selnr++;\r\n        }\r\n\r\n        // Difficult to keep the steps in the correct order.\r\n        // If you just set the x-coordinates, you get special effects.\r\n        // Best is to keep the current order of things.\r\n        // First build an arraylist and store the order there.\r\n        // Then sort order[], based upon the coordinate of the step.\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            for (int j = 0; j < elements.size() - 1; j++)\r\n            {\r\n                Point p1 = ((GUIPositionInterface)elements.get(order[j])).getLocation();\r\n                Point p2 = ((GUIPositionInterface)elements.get(order[j+1])).getLocation();\r\n                if (p1.y > p2.y) // swap\r\n                {\r\n                    int dummy = order[j];\r\n                    order[j] = order[j + 1];\r\n                    order[j + 1] = dummy;\r\n                }\r\n            }\r\n        }\r\n\r\n        // The distance between two steps becomes.\r\n        int distance = (max - min) / (elements.size() - 1);\r\n\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(order[i]);\r\n\r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            p.y = min + (i * distance);\r\n            after[i] = new Point(p.x, p.y);\r\n        }\r\n\r\n        // Undo!\r\n        if (addUndoPositionInterface!=null) addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","commit_id":"96782f344a1fffee1fee0d29fa8705c54346f3a5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void alligntop()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n\r\n        // First look for the minimum y coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n            Point p = element.getLocation();\r\n            if (p.y < min) min = p.y;\r\n        }\r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n            \r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            element.setLocation(p.x, min);\r\n            after[i] = new Point(p.x, min);\r\n        }\r\n        \r\n        addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","id":85784,"modified_method":"public void alligntop()\r\n    {\r\n        if (elements.size() == 0) return;\r\n\r\n        GUIPositionInterface elemArray[] = (GUIPositionInterface[])elements.toArray(new GUIPositionInterface[elements.size()]);\r\n        \r\n        Point before[] = new Point[elements.size()];\r\n        Point after[] = new Point[elements.size()];\r\n\r\n        int min = 99999;\r\n\r\n        // First look for the minimum y coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n            Point p = element.getLocation();\r\n            if (p.y < min) min = p.y;\r\n        }\r\n        // Then apply the coordinate...\r\n        for (int i = 0; i < elements.size(); i++)\r\n        {\r\n            GUIPositionInterface element = (GUIPositionInterface) elements.get(i);\r\n            \r\n            Point p = element.getLocation();\r\n            before[i] = new Point(p.x, p.y);\r\n            element.setLocation(p.x, min);\r\n            after[i] = new Point(p.x, min);\r\n        }\r\n        \r\n        if (addUndoPositionInterface!=null) addUndoPositionInterface.addUndoPosition(elemArray, indices, before, after);\r\n        redrawable.redraw();\r\n    }","commit_id":"96782f344a1fffee1fee0d29fa8705c54346f3a5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Test\n    public void testReconcile() throws UnknownHostException\n    {\n        IColumn left;\n        IColumn right;\n        IColumn reconciled;\n\n        // tombstone + tombstone\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 1L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 2, 2L);\n\n        assert left.reconcile(right).timestamp() == right.timestamp();\n        assert right.reconcile(left).timestamp() == right.timestamp();\n        \n        // tombstone > live\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 1L);\n\n        assert left.reconcile(right) == left;\n\n        // tombstone < live last delete\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 1L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n\n        assert left.reconcile(right) == right;\n\n        // tombstone == live last delete\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n\n        assert left.reconcile(right) == right;\n\n        // tombstone > live last delete\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 4L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 9L, new byte[0], 1L);\n\n        reconciled = left.reconcile(right);\n        assert reconciled.name() == right.name();\n        assert reconciled.value() == right.value();\n        assert reconciled.timestamp() == right.timestamp();\n        assert ((CounterColumn)reconciled).partitionedCounter() == ((CounterColumn)right).partitionedCounter();\n        assert ((CounterColumn)reconciled).timestampOfLastDelete() == left.timestamp();\n\n        // live < tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 1L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n\n        assert left.reconcile(right) == right;\n\n        // live last delete > tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 1L);\n\n        assert left.reconcile(right) == left;\n\n        // live last delete == tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n\n        assert left.reconcile(right) == left;\n\n        // live last delete < tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 9L, new byte[0], 1L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 4L);\n\n        reconciled = left.reconcile(right);\n        assert reconciled.name() == left.name();\n        assert reconciled.value() == left.value();\n        assert reconciled.timestamp() == left.timestamp();\n        assert ((CounterColumn)reconciled).partitionedCounter() == ((CounterColumn)left).partitionedCounter();\n        assert ((CounterColumn)reconciled).timestampOfLastDelete() == right.timestamp();\n\n        // live + live\n        byte[] context;\n\n        context = new byte[0];\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(1)), 1L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(1)), 0L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(1)), 1L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(2)), 0L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(2)), 5L);\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), ByteBuffer.wrap(cc.total(context)), 9L, context, 1L);\n\n        context = new byte[0];\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(2)), 4L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(3)), 2L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), ByteBuffer.wrap(cc.total(context)), 3L, context, 4L);\n\n        reconciled = left.reconcile(right);\n        assert reconciled.name() == left.name();\n        assert 9L == reconciled.value().getLong(reconciled.value().arrayOffset());\n        assert reconciled.timestamp() == 9L;\n\n        context = ((CounterColumn)reconciled).partitionedCounter();\n        assert 3 * stepLength == context.length;\n\n        assert  1 == FBUtilities.byteArrayToInt(context,  0*stepLength);\n        assert 3L == FBUtilities.byteArrayToLong(context, 0*stepLength + idLength);\n        assert 2L == FBUtilities.byteArrayToLong(context, 0*stepLength + idLength + clockLength);\n\n        assert  2 == FBUtilities.byteArrayToInt(context,  1*stepLength);\n        assert 2L == FBUtilities.byteArrayToLong(context, 1*stepLength + idLength);\n        assert 5L == FBUtilities.byteArrayToLong(context, 1*stepLength + idLength + clockLength);\n\n        assert  3 == FBUtilities.byteArrayToInt(context,  2*stepLength);\n        assert 1L == FBUtilities.byteArrayToLong(context, 2*stepLength + idLength);\n        assert 2L == FBUtilities.byteArrayToLong(context, 2*stepLength + idLength + clockLength);\n\n        assert ((CounterColumn)reconciled).timestampOfLastDelete() == 4L;\n    }","id":85785,"modified_method":"@Test\n    public void testReconcile() throws UnknownHostException\n    {\n        IColumn left;\n        IColumn right;\n        IColumn reconciled;\n\n        // tombstone + tombstone\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 1L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 2, 2L);\n\n        assert left.reconcile(right).timestamp() == right.timestamp();\n        assert right.reconcile(left).timestamp() == right.timestamp();\n        \n        // tombstone > live\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 1L);\n\n        assert left.reconcile(right) == left;\n\n        // tombstone < live last delete\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 1L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n\n        assert left.reconcile(right) == right;\n\n        // tombstone == live last delete\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n\n        assert left.reconcile(right) == right;\n\n        // tombstone > live last delete\n        left  = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 4L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 9L, new byte[0], 1L);\n\n        reconciled = left.reconcile(right);\n        assert reconciled.name() == right.name();\n        assert reconciled.value() == right.value();\n        assert reconciled.timestamp() == right.timestamp();\n        assert ((CounterColumn)reconciled).partitionedCounter() == ((CounterColumn)right).partitionedCounter();\n        assert ((CounterColumn)reconciled).timestampOfLastDelete() == left.timestamp();\n\n        // live < tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 1L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n\n        assert left.reconcile(right) == right;\n\n        // live last delete > tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 1L);\n\n        assert left.reconcile(right) == left;\n\n        // live last delete == tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 4L, new byte[0], 2L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 2L);\n\n        assert left.reconcile(right) == left;\n\n        // live last delete < tombstone\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 9L, new byte[0], 1L);\n        right = new DeletedColumn(ByteBufferUtil.bytes(\"x\"), 1, 4L);\n\n        reconciled = left.reconcile(right);\n        assert reconciled.name() == left.name();\n        assert reconciled.value() == left.value();\n        assert reconciled.timestamp() == left.timestamp();\n        assert ((CounterColumn)reconciled).partitionedCounter() == ((CounterColumn)left).partitionedCounter();\n        assert ((CounterColumn)reconciled).timestampOfLastDelete() == right.timestamp();\n\n        // live + live\n        byte[] context;\n\n        context = new byte[0];\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(1)), 1L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(1)), 0L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(1)), 1L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(2)), 0L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(2)), 5L);\n        left  = new CounterColumn(ByteBufferUtil.bytes(\"x\"), ByteBuffer.wrap(cc.total(context)), 9L, context, 1L);\n\n        context = new byte[0];\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(2)), 4L);\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(3)), 2L);\n        right = new CounterColumn(ByteBufferUtil.bytes(\"x\"), ByteBuffer.wrap(cc.total(context)), 3L, context, 4L);\n\n        reconciled = left.reconcile(right);\n\n        assert reconciled.name() == left.name();\n        assert 9L == reconciled.value().getLong(reconciled.value().position());\n        assert reconciled.timestamp() == 9L;\n\n        context = ((CounterColumn)reconciled).partitionedCounter();\n        assert 3 * stepLength == context.length;\n\n        assert  1 == FBUtilities.byteArrayToInt(context,  0*stepLength);\n        assert 3L == FBUtilities.byteArrayToLong(context, 0*stepLength + idLength);\n        assert 2L == FBUtilities.byteArrayToLong(context, 0*stepLength + idLength + clockLength);\n\n        assert  2 == FBUtilities.byteArrayToInt(context,  1*stepLength);\n        assert 2L == FBUtilities.byteArrayToLong(context, 1*stepLength + idLength);\n        assert 5L == FBUtilities.byteArrayToLong(context, 1*stepLength + idLength + clockLength);\n\n        assert  3 == FBUtilities.byteArrayToInt(context,  2*stepLength);\n        assert 1L == FBUtilities.byteArrayToLong(context, 2*stepLength + idLength);\n        assert 2L == FBUtilities.byteArrayToLong(context, 2*stepLength + idLength + clockLength);\n\n        assert ((CounterColumn)reconciled).timestampOfLastDelete() == 4L;\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testUpdate() throws UnknownHostException\n    {\n        CounterColumn c = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 0L);\n        assert 0L == c.value().getLong(c.value().arrayOffset());\n\n        assert c.partitionedCounter().length == 0 : \"badly formatted initial context\";\n\n        c.value = FBUtilities.toByteBuffer(1L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(1)));\n        assert 1L == c.value().getLong(c.value().arrayOffset());\n\n        assert c.partitionedCounter().length == stepLength;\n\n        assert  1 == FBUtilities.byteArrayToInt( c.partitionedCounter(), 0*stepLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength + clockLength);\n\n        c.value = FBUtilities.toByteBuffer(3L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(2)));\n\n        c.value = FBUtilities.toByteBuffer(2L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(2)));\n\n        c.value = FBUtilities.toByteBuffer(9L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(2)));\n\n        assert 15L == c.value().getLong(c.value().arrayOffset());\n\n        assert c.partitionedCounter().length == (2 * stepLength);\n\n        assert   2 == FBUtilities.byteArrayToInt(c.partitionedCounter(),  0*stepLength);\n        assert  3L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength);\n        assert 14L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength + clockLength);\n\n        assert  1 == FBUtilities.byteArrayToInt(c.partitionedCounter(),  1*stepLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 1*stepLength + idLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 1*stepLength + idLength + clockLength);\n    }","id":85786,"modified_method":"@Test\n    public void testUpdate() throws UnknownHostException\n    {\n        CounterColumn c = new CounterColumn(ByteBufferUtil.bytes(\"x\"), FBUtilities.toByteBuffer(0L), 0L);\n        assert 0L == c.value().getLong(c.value().arrayOffset());\n\n        assert c.partitionedCounter().length == 0 : \"badly formatted initial context\";\n\n        c.value = FBUtilities.toByteBuffer(1L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(1)));\n        assert 1L == c.value().getLong(c.value().arrayOffset());\n\n        assert c.partitionedCounter().length == stepLength;\n\n        assert  1 == FBUtilities.byteArrayToInt( c.partitionedCounter(), 0*stepLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength + clockLength);\n\n        c.value = FBUtilities.toByteBuffer(3L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(2)));\n\n        c.value = FBUtilities.toByteBuffer(2L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(2)));\n\n        c.value = FBUtilities.toByteBuffer(9L);\n        c.update(InetAddress.getByAddress(FBUtilities.toByteArray(2)));\n\n        assert 15L == c.value().getLong(c.value().arrayOffset());\n\n        assert c.partitionedCounter().length == (2 * stepLength);\n\n        assert  1 == FBUtilities.byteArrayToInt(c.partitionedCounter(),  0*stepLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength);\n        assert 1L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 0*stepLength + idLength + clockLength);\n\n        assert   2 == FBUtilities.byteArrayToInt(c.partitionedCounter(),  1*stepLength);\n        assert  3L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 1*stepLength + idLength);\n        assert 14L == FBUtilities.byteArrayToLong(c.partitionedCounter(), 1*stepLength + idLength + clockLength);\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Determine the count relationship between two contexts.\n     *\n     * EQUAL:        Equal set of nodes and every count is equal.\n     * GREATER_THAN: Superset of nodes and every count is equal or greater than its corollary.\n     * LESS_THAN:    Subset of nodes and every count is equal or less than its corollary.\n     * DISJOINT:     Node sets are not equal and/or counts are not all greater or less than.\n     *\n     * Strategy:\n     *   compare node logical clocks (like a version vector).\n     *\n     * @param left\n     *            counter context.\n     * @param right\n     *            counter context.\n     * @return the ContextRelationship between the contexts.\n     */\n    public ContextRelationship diff(byte[] left, byte[] right)\n    {\n        left  = sortElementsById(left);\n        right = sortElementsById(right);\n\n        ContextRelationship relationship = ContextRelationship.EQUAL;\n\n        int leftIndex  = 0;\n        int rightIndex = 0;\n        while (leftIndex < left.length && rightIndex < right.length)\n        {\n            // compare id bytes\n            int compareId = FBUtilities.compareByteSubArrays(left, leftIndex, right, rightIndex, idLength);\n            if (compareId == 0)\n            {\n                long leftClock  = FBUtilities.byteArrayToLong(left,  leftIndex + idLength);\n                long rightClock = FBUtilities.byteArrayToLong(right, rightIndex + idLength);\n\n                // advance indexes\n                leftIndex  += stepLength;\n                rightIndex += stepLength;\n\n                // process clock comparisons\n                if (leftClock == rightClock)\n                {\n                    continue;\n                }\n                else if (leftClock > rightClock)\n                {\n                    if (relationship == ContextRelationship.EQUAL)\n                    {\n                        relationship = ContextRelationship.GREATER_THAN;\n                    }\n                    else if (relationship == ContextRelationship.GREATER_THAN)\n                    {\n                        continue;\n                    }\n                    else\n                    {\n                        // relationship == ContextRelationship.LESS_THAN\n                        return ContextRelationship.DISJOINT;\n                    }\n                }\n                else\n                // leftClock < rightClock\n                {\n                    if (relationship == ContextRelationship.EQUAL)\n                    {\n                        relationship = ContextRelationship.LESS_THAN;\n                    }\n                    else if (relationship == ContextRelationship.GREATER_THAN)\n                    {\n                        return ContextRelationship.DISJOINT;\n                    }\n                    else\n                    {\n                        // relationship == ContextRelationship.LESS_THAN\n                        continue;\n                    }\n                }\n            }\n            else if (compareId > 0)\n            {\n                // only advance the right context\n                rightIndex += stepLength;\n\n                if (relationship == ContextRelationship.EQUAL)\n                {\n                    relationship = ContextRelationship.LESS_THAN;\n                }\n                else if (relationship == ContextRelationship.GREATER_THAN)\n                {\n                    return ContextRelationship.DISJOINT;\n                }\n                else\n                {\n                    // relationship == ContextRelationship.LESS_THAN\n                    continue;\n                }\n            }\n            else\n            {\n                // compareId < 0\n                // only advance the left context\n                leftIndex += stepLength;\n\n                if (relationship == ContextRelationship.EQUAL)\n                {\n                    relationship = ContextRelationship.GREATER_THAN;\n                }\n                else if (relationship == ContextRelationship.GREATER_THAN)\n                {\n                    continue;\n                }\n                else\n                // relationship == ContextRelationship.LESS_THAN\n                {\n                    return ContextRelationship.DISJOINT;\n                }\n            }\n        }\n\n        // check final lengths\n        if (leftIndex < left.length)\n        {\n            if (relationship == ContextRelationship.EQUAL)\n            {\n                return ContextRelationship.GREATER_THAN;\n            }\n            else if (relationship == ContextRelationship.LESS_THAN)\n            {\n                return ContextRelationship.DISJOINT;\n            }\n        }\n        else if (rightIndex < right.length)\n        {\n            if (relationship == ContextRelationship.EQUAL)\n            {\n                return ContextRelationship.LESS_THAN;\n            }\n            else if (relationship == ContextRelationship.GREATER_THAN)\n            {\n                return ContextRelationship.DISJOINT;\n            }\n        }\n\n        return relationship;\n    }","id":85787,"modified_method":"/**\n     * Determine the count relationship between two contexts.\n     *\n     * EQUAL:        Equal set of nodes and every count is equal.\n     * GREATER_THAN: Superset of nodes and every count is equal or greater than its corollary.\n     * LESS_THAN:    Subset of nodes and every count is equal or less than its corollary.\n     * DISJOINT:     Node sets are not equal and/or counts are not all greater or less than.\n     *\n     * Strategy:\n     *   compare node logical clocks (like a version vector).\n     *\n     * @param left\n     *            counter context.\n     * @param right\n     *            counter context.\n     * @return the ContextRelationship between the contexts.\n     */\n    public ContextRelationship diff(byte[] left, byte[] right)\n    {\n        ContextRelationship relationship = ContextRelationship.EQUAL;\n\n        int leftIndex  = 0;\n        int rightIndex = 0;\n        while (leftIndex < left.length && rightIndex < right.length)\n        {\n            // compare id bytes\n            int compareId = FBUtilities.compareByteSubArrays(left, leftIndex, right, rightIndex, idLength);\n            if (compareId == 0)\n            {\n                long leftClock  = FBUtilities.byteArrayToLong(left,  leftIndex + idLength);\n                long rightClock = FBUtilities.byteArrayToLong(right, rightIndex + idLength);\n\n                // advance indexes\n                leftIndex  += stepLength;\n                rightIndex += stepLength;\n\n                // process clock comparisons\n                if (leftClock == rightClock)\n                {\n                    continue;\n                }\n                else if (leftClock > rightClock)\n                {\n                    if (relationship == ContextRelationship.EQUAL)\n                    {\n                        relationship = ContextRelationship.GREATER_THAN;\n                    }\n                    else if (relationship == ContextRelationship.GREATER_THAN)\n                    {\n                        continue;\n                    }\n                    else\n                    {\n                        // relationship == ContextRelationship.LESS_THAN\n                        return ContextRelationship.DISJOINT;\n                    }\n                }\n                else\n                // leftClock < rightClock\n                {\n                    if (relationship == ContextRelationship.EQUAL)\n                    {\n                        relationship = ContextRelationship.LESS_THAN;\n                    }\n                    else if (relationship == ContextRelationship.GREATER_THAN)\n                    {\n                        return ContextRelationship.DISJOINT;\n                    }\n                    else\n                    {\n                        // relationship == ContextRelationship.LESS_THAN\n                        continue;\n                    }\n                }\n            }\n            else if (compareId > 0)\n            {\n                // only advance the right context\n                rightIndex += stepLength;\n\n                if (relationship == ContextRelationship.EQUAL)\n                {\n                    relationship = ContextRelationship.LESS_THAN;\n                }\n                else if (relationship == ContextRelationship.GREATER_THAN)\n                {\n                    return ContextRelationship.DISJOINT;\n                }\n                else\n                {\n                    // relationship == ContextRelationship.LESS_THAN\n                    continue;\n                }\n            }\n            else\n            {\n                // compareId < 0\n                // only advance the left context\n                leftIndex += stepLength;\n\n                if (relationship == ContextRelationship.EQUAL)\n                {\n                    relationship = ContextRelationship.GREATER_THAN;\n                }\n                else if (relationship == ContextRelationship.GREATER_THAN)\n                {\n                    continue;\n                }\n                else\n                // relationship == ContextRelationship.LESS_THAN\n                {\n                    return ContextRelationship.DISJOINT;\n                }\n            }\n        }\n\n        // check final lengths\n        if (leftIndex < left.length)\n        {\n            if (relationship == ContextRelationship.EQUAL)\n            {\n                return ContextRelationship.GREATER_THAN;\n            }\n            else if (relationship == ContextRelationship.LESS_THAN)\n            {\n                return ContextRelationship.DISJOINT;\n            }\n        }\n        else if (rightIndex < right.length)\n        {\n            if (relationship == ContextRelationship.EQUAL)\n            {\n                return ContextRelationship.LESS_THAN;\n            }\n            else if (relationship == ContextRelationship.GREATER_THAN)\n            {\n                return ContextRelationship.DISJOINT;\n            }\n        }\n\n        return relationship;\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Return a context w/ an aggregated count for each node id.\n     *\n     * @param left\n     *            counter context.\n     * @param right\n     *            counter context.\n     */\n    public byte[] merge(byte[] left, byte[] right)\n    {\n        // strategy:\n        //   1) map id -> (clock, count)\n        //      a) local id:  sum clocks, counts\n        //      b) remote id: keep highest clock, count (reconcile)\n        //   2) create a context from sorted array\n        Map<FBUtilities.ByteArrayWrapper, CounterNode> contextsMap =\n            new HashMap<FBUtilities.ByteArrayWrapper, CounterNode>();\n\n        // map left context: id -> (clock, count)\n        for (int offset = 0; offset < left.length; offset += stepLength)\n        {\n            FBUtilities.ByteArrayWrapper id = new FBUtilities.ByteArrayWrapper(\n                ArrayUtils.subarray(left, offset, offset + idLength));\n            long clock = FBUtilities.byteArrayToLong(left, offset + idLength);\n            long count = FBUtilities.byteArrayToLong(left, offset + idLength + clockLength);\n\n            contextsMap.put(id, new CounterNode(clock, count));\n        }\n\n        // map right context: id -> (clock, count)\n        for (int offset = 0; offset < right.length; offset += stepLength)\n        {\n            FBUtilities.ByteArrayWrapper id = new FBUtilities.ByteArrayWrapper(\n                ArrayUtils.subarray(right, offset, offset + idLength));\n            long clock = FBUtilities.byteArrayToLong(right, offset + idLength);\n            long count = FBUtilities.byteArrayToLong(right, offset + idLength + clockLength);\n\n            if (!contextsMap.containsKey(id))\n            {\n                contextsMap.put(id, new CounterNode(clock, count));\n                continue;\n            }\n\n            CounterNode node = contextsMap.get(id);\n\n            // local id: sum clocks, counts\n            if (this.idWrapper.equals(id))\n            {\n                contextsMap.put(id, new CounterNode(\n                    clock + node.clock,\n                    count + node.count));\n                continue;\n            }\n\n            // remote id: keep highest clock and its count\n            if (node.clock < clock)\n            {\n                contextsMap.put(id, new CounterNode(clock, count));\n            }\n        }\n\n        // sort merged tuples\n        List<Map.Entry<FBUtilities.ByteArrayWrapper, CounterNode>> contextsList =\n            new ArrayList<Map.Entry<FBUtilities.ByteArrayWrapper, CounterNode>>(\n                    contextsMap.entrySet());\n        Collections.sort(\n            contextsList,\n            new Comparator<Map.Entry<FBUtilities.ByteArrayWrapper, CounterNode>>()\n            {\n                public int compare(\n                    Map.Entry<FBUtilities.ByteArrayWrapper, CounterNode> e1,\n                    Map.Entry<FBUtilities.ByteArrayWrapper, CounterNode> e2)\n                {\n                    // reversed\n                    return e2.getValue().compareClockTo(e1.getValue());\n                }\n            });\n\n        // create merged context\n        int length = contextsList.size();\n        byte[] merged = new byte[length * stepLength];\n        for (int i = 0; i < length; i++)\n        {\n            Map.Entry<FBUtilities.ByteArrayWrapper, CounterNode> entry = contextsList.get(i);\n            writeElementAtStepOffset(\n                merged,\n                i,\n                entry.getKey().data,\n                entry.getValue().clock,\n                entry.getValue().count);\n        }\n        return merged;\n    }","id":85788,"modified_method":"/**\n     * Return a context w/ an aggregated count for each node id.\n     *\n     * @param left\n     *            counter context.\n     * @param right\n     *            counter context.\n     */\n    public byte[] merge(byte[] left, byte[] right)\n    {\n        if (left.length > right.length)\n        {\n            byte[] tmp = right;\n            right = left;\n            left = tmp;\n        }\n\n        // Compute size of result\n        int size = 0;\n        int leftOffset  = 0;\n        int rightOffset = 0;\n        while ((leftOffset < left.length) && (rightOffset < right.length))\n        {\n            int cmp = FBUtilities.compareByteSubArrays(left, leftOffset, right, rightOffset, idLength);\n            if (cmp == 0)\n            {\n                ++size;\n                rightOffset += stepLength;\n                leftOffset += stepLength;\n            }\n            else if (cmp > 0)\n            {\n                ++size;\n                rightOffset += stepLength;\n            }\n            else // cmp < 0\n            {\n                ++size;\n                leftOffset += stepLength;\n            }\n        }\n        size += (left.length  - leftOffset)  / stepLength;\n        size += (right.length - rightOffset) / stepLength;\n\n        byte[] merged = new byte[size * stepLength];\n\n        // Do the actual merge:\n        //   a) local id:  sum clocks, counts\n        //   b) remote id: keep highest clock, count (reconcile)\n        int mergedOffset = 0; leftOffset = 0; rightOffset = 0;\n        while ((leftOffset < left.length) && (rightOffset < right.length))\n        {\n            int cmp = FBUtilities.compareByteSubArrays(left, leftOffset, right, rightOffset, idLength);\n            if (cmp == 0)\n            {\n                // sum for local id, keep highest othewise\n                long leftClock = FBUtilities.byteArrayToLong(left, leftOffset + idLength);\n                long rightClock = FBUtilities.byteArrayToLong(right, rightOffset + idLength);\n                if (FBUtilities.compareByteSubArrays(left, leftOffset, localId, 0, idLength) == 0)\n                {\n                    long leftCount = FBUtilities.byteArrayToLong(left, leftOffset + idLength + clockLength);\n                    long rightCount = FBUtilities.byteArrayToLong(right, rightOffset + idLength + clockLength);\n                    writeElementAtStepOffset(merged, mergedOffset / stepLength, localId, leftClock + rightClock, leftCount + rightCount);\n                }\n                else\n                {\n                    if (leftClock >= rightClock)\n                        System.arraycopy(left, leftOffset, merged, mergedOffset, stepLength);\n                    else\n                        System.arraycopy(right, rightOffset, merged, mergedOffset, stepLength);\n                }\n                mergedOffset += stepLength;\n                rightOffset += stepLength;\n                leftOffset += stepLength;\n            }\n            else if (cmp > 0)\n            {\n                System.arraycopy(right, rightOffset, merged, mergedOffset, stepLength);\n                mergedOffset += stepLength;\n                rightOffset += stepLength;\n            }\n            else // cmp < 0\n            {\n                System.arraycopy(left, leftOffset, merged, mergedOffset, stepLength);\n                mergedOffset += stepLength;\n                leftOffset += stepLength;\n            }\n        }\n        if (leftOffset < left.length)\n            System.arraycopy(\n                left,\n                leftOffset,\n                merged,\n                mergedOffset,\n                left.length - leftOffset);\n        if (rightOffset < right.length)\n            System.arraycopy(\n                right,\n                rightOffset,\n                merged,\n                mergedOffset,\n                right.length - rightOffset);\n\n        return merged;\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"public byte[] cleanNodeCounts(byte[] context, InetAddress node)\n    {\n        // calculate node id\n        byte[] nodeId = node.getAddress();\n\n        // look for this node id\n        for (int offset = 0; offset < context.length; offset += stepLength)\n        {\n            if (FBUtilities.compareByteSubArrays(context, offset, nodeId, 0, idLength) != 0)\n                continue;\n\n            // node id found: remove node count\n            byte[] truncatedContext = new byte[context.length - stepLength];\n            System.arraycopy(context, 0, truncatedContext, 0, offset);\n            System.arraycopy(\n                context,\n                offset + stepLength,\n                truncatedContext,\n                offset,\n                context.length - (offset + stepLength));\n            return truncatedContext;\n        }\n\n        return context;\n    }","id":85789,"modified_method":"public byte[] cleanNodeCounts(byte[] context, InetAddress node)\n    {\n        // calculate node id\n        byte[] nodeId = node.getAddress();\n\n        // look for this node id\n        for (int offset = 0; offset < context.length; offset += stepLength)\n        {\n            int cmp = FBUtilities.compareByteSubArrays(context, offset, nodeId, 0, idLength);\n            if (cmp < 0)\n                continue;\n            else if (cmp == 0)\n            {\n                // node id found: remove node count\n                byte[] truncatedContext = new byte[context.length - stepLength];\n                System.arraycopy(context, 0, truncatedContext, 0, offset);\n                System.arraycopy(\n                        context,\n                        offset + stepLength,\n                        truncatedContext,\n                        offset,\n                        context.length - (offset + stepLength));\n                return truncatedContext;\n            }\n            else // cmp > 0\n            {\n                break; // node id not present\n            }\n        }\n\n        return context;\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"public byte[] update(byte[] context, InetAddress node, long delta)\n    {\n        // calculate node id\n        byte[] nodeId = node.getAddress();\n\n        // look for this node id\n        for (int offset = 0; offset < context.length; offset += stepLength)\n        {\n            if (FBUtilities.compareByteSubArrays(nodeId, 0, context, offset, idLength) != 0)\n                continue;\n\n            // node id found: increment clock, update count; shift to front\n            long clock = FBUtilities.byteArrayToLong(context, offset + idLength);\n            long count = FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);\n\n            System.arraycopy(\n                context,\n                0,\n                context,\n                stepLength,\n                offset);\n            writeElement(context, nodeId, clock + 1L, count + delta);\n\n            return context;\n        }\n\n        // node id not found: widen context\n        byte[] previous = context;\n        context = new byte[previous.length + stepLength];\n\n        writeElement(context, nodeId, 1L, delta);\n        System.arraycopy(\n            previous,\n            0,\n            context,\n            stepLength,\n            previous.length);\n\n        return context;\n    }","id":85790,"modified_method":"public byte[] update(byte[] context, InetAddress node, long delta)\n    {\n        // calculate node id\n        byte[] nodeId = node.getAddress();\n        int idCount = context.length / stepLength;\n\n        // look for this node id\n        for (int stepOffset = 0; stepOffset < idCount; ++stepOffset)\n        {\n            int offset = stepOffset * stepLength;\n            int cmp = FBUtilities.compareByteSubArrays(nodeId, 0, context, offset, idLength);\n            if (cmp == 0)\n            {\n                // node id found: increment clock, update count; shift to front\n                long clock = FBUtilities.byteArrayToLong(context, offset + idLength);\n                long count = FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);\n\n                writeElementAtStepOffset(context, stepOffset, nodeId, clock + 1L, count + delta);\n                return context;\n            }\n            if (cmp < 0)\n            {\n                // id at offset is greater that the one we are updating, inserting\n                return insertElementAtStepOffset(context, stepOffset, nodeId, 1L, delta);\n            }\n        }\n\n        // node id not found: adding at the end\n        return insertElementAtStepOffset(context, idCount, nodeId, 1L, delta);\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testTotal()\n    {\n        byte[] left = new byte[4 * stepLength];\n        cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(1), 1L, 1L);\n        cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(2), 2L, 2L);\n        cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(4), 3L, 3L);\n        cc.writeElementAtStepOffset(\n            left,\n            3,\n            FBUtilities.getLocalAddress().getAddress(),\n            3L,\n            3L);\n\n        byte[] right = new byte[3 * stepLength];\n        cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(5), 5L, 5L);\n        cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(4), 4L, 4L);\n        cc.writeElementAtStepOffset(\n            right,\n            0,\n            FBUtilities.getLocalAddress().getAddress(),\n            9L,\n            9L);\n\n        byte[] merged = cc.merge(left, right);\n\n        // 127.0.0.1: 12 (3+9)\n        // 0.0.0.1:    1\n        // 0.0.0.2:    2\n        // 0.0.0.4:    4\n        // 0.0.0.5:    5\n\n        assertEquals(24L, FBUtilities.byteArrayToLong(cc.total(merged)));\n    }","id":85791,"modified_method":"@Test\n    public void testTotal()\n    {\n        byte[] left = new byte[4 * stepLength];\n        cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(1), 1L, 1L);\n        cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(2), 2L, 2L);\n        cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(4), 3L, 3L);\n        cc.writeElementAtStepOffset(\n            left,\n            3,\n            FBUtilities.getLocalAddress().getAddress(),\n            3L,\n            3L);\n\n        byte[] right = new byte[3 * stepLength];\n        cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(4), 4L, 4L);\n        cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(5), 5L, 5L);\n        cc.writeElementAtStepOffset(\n            right,\n            2,\n            FBUtilities.getLocalAddress().getAddress(),\n            9L,\n            9L);\n\n        byte[] merged = cc.merge(left, right);\n\n        // 127.0.0.1: 12 (3+9)\n        // 0.0.0.1:    1\n        // 0.0.0.2:    2\n        // 0.0.0.4:    4\n        // 0.0.0.5:    5\n\n        assertEquals(24L, FBUtilities.byteArrayToLong(cc.total(merged)));\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testUpdateNotPresent()\n    {\n        byte[] context = new byte[stepLength * 2];\n\n        for (int i = 0; i < 2; i++)\n        {\n            cc.writeElementAtStepOffset(\n                context,\n                i,\n                FBUtilities.toByteArray(i),\n                1L,\n                1L);\n        }\n\n        context = cc.update(context, idAddress, 328L);\n\n        assert context.length == stepLength * 3;\n        assert   1L == FBUtilities.byteArrayToLong(context, idLength);\n        assert 328L == FBUtilities.byteArrayToLong(context, idLength + clockLength);\n        for (int i = 1; i < 3; i++)\n        {\n            int offset = i * stepLength;\n            assert i-1 == FBUtilities.byteArrayToInt(context,  offset);\n            assert  1L == FBUtilities.byteArrayToLong(context, offset + idLength);\n            assert  1L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);\n        }\n    }","id":85792,"modified_method":"@Test\n    public void testUpdateNotPresent() throws UnknownHostException\n    {\n        byte[] context = new byte[stepLength * 3];\n\n        for (int i = 0; i < 3; i++)\n        {\n            cc.writeElementAtStepOffset(\n                context,\n                i,\n                FBUtilities.toByteArray(i * 2),\n                1L,\n                1L);\n        }\n\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(3)), 328L);\n\n        assert context.length == stepLength * 4;\n        int offset = 2 * stepLength;\n        assert   1L == FBUtilities.byteArrayToLong(context, offset + idLength);\n        assert 328L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);\n        for (int i = 1; i < 2; i++)\n        {\n            offset = i * stepLength;\n            assert 2 * i == FBUtilities.byteArrayToInt(context,  offset);\n            assert    1L == FBUtilities.byteArrayToLong(context, offset + idLength);\n            assert    1L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);\n        }\n        offset = 3 * stepLength;\n        assert  4 == FBUtilities.byteArrayToInt(context,  offset);\n        assert 1L == FBUtilities.byteArrayToLong(context, offset + idLength);\n        assert 1L == FBUtilities.byteArrayToLong(context, offset + idLength + clockLength);\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testMerge()\n    {\n        // note: local counts aggregated; remote counts are reconciled (i.e. take max)\n        byte[] left = new byte[4 * stepLength];\n        cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(1), 1L, 1L);\n        cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(2), 2L, 2L);\n        cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(4), 6L, 3L);\n        cc.writeElementAtStepOffset(\n            left,\n            3,\n            FBUtilities.getLocalAddress().getAddress(),\n            7L,\n            3L);\n\n        byte[] right = new byte[3 * stepLength];\n        cc.writeElementAtStepOffset(right, 2, FBUtilities.toByteArray(5), 5L, 5L);\n        cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(4), 4L, 4L);\n        cc.writeElementAtStepOffset(\n            right,\n            0,\n            FBUtilities.getLocalAddress().getAddress(),\n            2L,\n            9L);\n\n        byte[] merged = cc.merge(left, right);\n\n        // local node id's counts are aggregated\n        assertEquals(0, FBUtilities.compareUnsigned(\n            FBUtilities.getLocalAddress().getAddress(),\n            merged, \n            0,\n            0*stepLength,\n            4,\n            4));\n        assertEquals(  9L, FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength));\n        assertEquals(12L,  FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength + clockLength));\n\n        // remote node id counts are reconciled (i.e. take max)\n        assertEquals( 4,   FBUtilities.byteArrayToInt(merged,  1*stepLength));\n        assertEquals( 6L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength));\n        assertEquals( 3L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength + clockLength));\n\n        assertEquals( 5,   FBUtilities.byteArrayToInt(merged,  2*stepLength));\n        assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength));\n        assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength + clockLength));\n\n        assertEquals( 2,   FBUtilities.byteArrayToInt(merged,  3*stepLength));\n        assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength));\n        assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength + clockLength));\n\n        assertEquals( 1,   FBUtilities.byteArrayToInt(merged,  4*stepLength));\n        assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength));\n        assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength + clockLength));\n    }","id":85793,"modified_method":"@Test\n    public void testMerge()\n    {\n        // note: local counts aggregated; remote counts are reconciled (i.e. take max)\n        byte[] left = new byte[4 * stepLength];\n        cc.writeElementAtStepOffset(left, 0, FBUtilities.toByteArray(1), 1L, 1L);\n        cc.writeElementAtStepOffset(left, 1, FBUtilities.toByteArray(2), 2L, 2L);\n        cc.writeElementAtStepOffset(left, 2, FBUtilities.toByteArray(4), 6L, 3L);\n        cc.writeElementAtStepOffset(\n            left,\n            3,\n            FBUtilities.getLocalAddress().getAddress(),\n            7L,\n            3L);\n\n        byte[] right = new byte[3 * stepLength];\n        cc.writeElementAtStepOffset(right, 0, FBUtilities.toByteArray(4), 4L, 4L);\n        cc.writeElementAtStepOffset(right, 1, FBUtilities.toByteArray(5), 5L, 5L);\n        cc.writeElementAtStepOffset(\n            right,\n            2,\n            FBUtilities.getLocalAddress().getAddress(),\n            2L,\n            9L);\n\n        byte[] merged = cc.merge(left, right);\n\n        assertEquals(5 * stepLength, merged.length);\n        // local node id's counts are aggregated\n        assertEquals(0, FBUtilities.compareByteSubArrays(\n            FBUtilities.getLocalAddress().getAddress(),\n            0,\n            merged,\n            4*stepLength,\n            4));\n        assertEquals(  9L, FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength));\n        assertEquals(12L,  FBUtilities.byteArrayToLong(merged, 4*stepLength + idLength + clockLength));\n\n        // remote node id counts are reconciled (i.e. take max)\n        assertEquals( 4,   FBUtilities.byteArrayToInt(merged,  2*stepLength));\n        assertEquals( 6L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength));\n        assertEquals( 3L,  FBUtilities.byteArrayToLong(merged, 2*stepLength + idLength + clockLength));\n\n        assertEquals( 5,   FBUtilities.byteArrayToInt(merged,  3*stepLength));\n        assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength));\n        assertEquals( 5L,  FBUtilities.byteArrayToLong(merged, 3*stepLength + idLength + clockLength));\n\n        assertEquals( 2,   FBUtilities.byteArrayToInt(merged,  1*stepLength));\n        assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength));\n        assertEquals( 2L,  FBUtilities.byteArrayToLong(merged, 1*stepLength + idLength + clockLength));\n\n        assertEquals( 1,   FBUtilities.byteArrayToInt(merged,  0*stepLength));\n        assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength));\n        assertEquals( 1L,  FBUtilities.byteArrayToLong(merged, 0*stepLength + idLength + clockLength));\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testUpdatePresentReorder() throws UnknownHostException\n    {\n        byte[] context;\n\n        context = new byte[stepLength * defaultEntries];\n\n        for (int i = 0; i < defaultEntries - 1; i++)\n        {\n            cc.writeElementAtStepOffset(\n                context,\n                i,\n                FBUtilities.toByteArray(i),\n                1L,\n                1L);\n        }\n        cc.writeElementAtStepOffset(\n            context,\n            (defaultEntries - 1),\n            id,\n            2L,\n            3L);\n\n        context = cc.update(context, idAddress, 10L);\n\n        assertEquals(context.length, stepLength * defaultEntries);\n        assertEquals(  3L, FBUtilities.byteArrayToLong(context, idLength));\n        assertEquals( 13L, FBUtilities.byteArrayToLong(context, idLength + clockLength));\n        for (int i = 1; i < defaultEntries; i++)\n        {\n            int offset = i * stepLength;\n            assertEquals( i-1, FBUtilities.byteArrayToInt(context,  offset));\n            assertEquals(1L, FBUtilities.byteArrayToLong(context, offset + idLength));\n            assertEquals(1L, FBUtilities.byteArrayToLong(context, offset + idLength + clockLength));\n        }\n    }","id":85794,"modified_method":"@Test\n    public void testUpdatePresent() throws UnknownHostException\n    {\n        byte[] context;\n\n        context = new byte[stepLength * defaultEntries];\n\n        for (int i = 0; i < defaultEntries; i++)\n        {\n            cc.writeElementAtStepOffset(\n                context,\n                i,\n                FBUtilities.toByteArray(i),\n                1L,\n                1L);\n        }\n        context = cc.update(context, InetAddress.getByAddress(FBUtilities.toByteArray(defaultEntries - 1)), 10L);\n\n        assertEquals(context.length, stepLength * defaultEntries);\n        int offset = (defaultEntries - 1) * stepLength;\n        assertEquals(  2L, FBUtilities.byteArrayToLong(context, offset + idLength));\n        assertEquals( 11L, FBUtilities.byteArrayToLong(context, offset + idLength + clockLength));\n        for (int i = 0; i < defaultEntries - 1; i++)\n        {\n            offset = i * stepLength;\n            assertEquals( i, FBUtilities.byteArrayToInt(context,  offset));\n            assertEquals(1L, FBUtilities.byteArrayToLong(context, offset + idLength));\n            assertEquals(1L, FBUtilities.byteArrayToLong(context, offset + idLength + clockLength));\n        }\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testAddColumnIncrementCounter()\n    {\n        byte[] context;\n\n    \tSuperColumn sc = new SuperColumn(ByteBufferUtil.bytes(\"sc1\"), LongType.instance);\n\n        context = concatByteArrays(\n            FBUtilities.getLocalAddress().getAddress(), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(3L),\n            FBUtilities.toByteArray(1), FBUtilities.toByteArray(7L), FBUtilities.toByteArray(0L),\n            FBUtilities.toByteArray(2), FBUtilities.toByteArray(5L), FBUtilities.toByteArray(7L),\n            FBUtilities.toByteArray(4), FBUtilities.toByteArray(2L), FBUtilities.toByteArray(9L)\n            );\n    \tsc.addColumn(new CounterColumn(getBytes(1), ByteBuffer.wrap(cc.total(context)), 3L, context, 0L));\n        context = concatByteArrays(\n            FBUtilities.getLocalAddress().getAddress(), FBUtilities.toByteArray(9L), FBUtilities.toByteArray(5L),\n            FBUtilities.toByteArray(8), FBUtilities.toByteArray(9L), FBUtilities.toByteArray(0L),\n            FBUtilities.toByteArray(4), FBUtilities.toByteArray(4L), FBUtilities.toByteArray(1L),\n            FBUtilities.toByteArray(2), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(4L)\n            );\n    \tsc.addColumn(new CounterColumn(getBytes(1), ByteBuffer.wrap(cc.total(context)), 10L, context, 0L));\n\n        context = concatByteArrays(\n            FBUtilities.toByteArray(3), FBUtilities.toByteArray(6L), FBUtilities.toByteArray(0L),\n            FBUtilities.toByteArray(7), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(0L),\n            FBUtilities.toByteArray(2), FBUtilities.toByteArray(1L), FBUtilities.toByteArray(0L)\n            );\n    \tsc.addColumn(new CounterColumn(getBytes(2), ByteBuffer.wrap(cc.total(context)), 9L, context, 0L));\n                    \n    \tassertNotNull(sc.getSubColumn(getBytes(1)));\n    \tassertNull(sc.getSubColumn(getBytes(3)));\n\n        // column: 1\n    \tbyte[] c1 = concatByteArrays(\n                FBUtilities.getLocalAddress().getAddress(), FBUtilities.toByteArray(12L), FBUtilities.toByteArray(8L),\n                FBUtilities.toByteArray(8), FBUtilities.toByteArray(9L), FBUtilities.toByteArray(0L),\n                FBUtilities.toByteArray(1), FBUtilities.toByteArray(7L), FBUtilities.toByteArray(0L),\n                FBUtilities.toByteArray(2), FBUtilities.toByteArray(5L), FBUtilities.toByteArray(7L),\n                FBUtilities.toByteArray(4), FBUtilities.toByteArray(4L), FBUtilities.toByteArray(1L)\n                );\n        assert 0 == FBUtilities.compareByteSubArrays(\n            ((CounterColumn)sc.getSubColumn(getBytes(1))).partitionedCounter(),\n            0,\n            c1,\n            0,\n            c1.length);\n\n        // column: 2\n        byte[] c2 = concatByteArrays(\n                FBUtilities.toByteArray(3), FBUtilities.toByteArray(6L), FBUtilities.toByteArray(0L),\n                FBUtilities.toByteArray(7), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(0L),\n                FBUtilities.toByteArray(2), FBUtilities.toByteArray(1L), FBUtilities.toByteArray(0L)\n                );\n        assert 0 == FBUtilities.compareByteSubArrays(\n            ((CounterColumn)sc.getSubColumn(getBytes(2))).partitionedCounter(),\n            0,\n            c2,\n            0,\n            c2.length);\n\n    \tassertNotNull(sc.getSubColumn(getBytes(1)));\n    \tassertNotNull(sc.getSubColumn(getBytes(2)));\n    \tassertNull(sc.getSubColumn(getBytes(3)));\n    }","id":85795,"modified_method":"@Test\n    public void testAddColumnIncrementCounter()\n    {\n        byte[] context;\n\n    \tSuperColumn sc = new SuperColumn(ByteBufferUtil.bytes(\"sc1\"), LongType.instance);\n\n        context = concatByteArrays(\n            FBUtilities.toByteArray(1), FBUtilities.toByteArray(7L), FBUtilities.toByteArray(0L),\n            FBUtilities.toByteArray(2), FBUtilities.toByteArray(5L), FBUtilities.toByteArray(7L),\n            FBUtilities.toByteArray(4), FBUtilities.toByteArray(2L), FBUtilities.toByteArray(9L),\n            FBUtilities.getLocalAddress().getAddress(), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(3L)\n            );\n    \tsc.addColumn(new CounterColumn(getBytes(1), ByteBuffer.wrap(cc.total(context)), 3L, context, 0L));\n        context = concatByteArrays(\n            FBUtilities.toByteArray(2), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(4L),\n            FBUtilities.toByteArray(4), FBUtilities.toByteArray(4L), FBUtilities.toByteArray(1L),\n            FBUtilities.toByteArray(8), FBUtilities.toByteArray(9L), FBUtilities.toByteArray(0L),\n            FBUtilities.getLocalAddress().getAddress(), FBUtilities.toByteArray(9L), FBUtilities.toByteArray(5L)\n            );\n    \tsc.addColumn(new CounterColumn(getBytes(1), ByteBuffer.wrap(cc.total(context)), 10L, context, 0L));\n\n        context = concatByteArrays(\n            FBUtilities.toByteArray(2), FBUtilities.toByteArray(1L), FBUtilities.toByteArray(0L),\n            FBUtilities.toByteArray(3), FBUtilities.toByteArray(6L), FBUtilities.toByteArray(0L),\n            FBUtilities.toByteArray(7), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(0L)\n            );\n    \tsc.addColumn(new CounterColumn(getBytes(2), ByteBuffer.wrap(cc.total(context)), 9L, context, 0L));\n                    \n    \tassertNotNull(sc.getSubColumn(getBytes(1)));\n    \tassertNull(sc.getSubColumn(getBytes(3)));\n\n        // column: 1\n    \tbyte[] c1 = concatByteArrays(\n                FBUtilities.toByteArray(1), FBUtilities.toByteArray(7L), FBUtilities.toByteArray(0L),\n                FBUtilities.toByteArray(2), FBUtilities.toByteArray(5L), FBUtilities.toByteArray(7L),\n                FBUtilities.toByteArray(4), FBUtilities.toByteArray(4L), FBUtilities.toByteArray(1L),\n                FBUtilities.toByteArray(8), FBUtilities.toByteArray(9L), FBUtilities.toByteArray(0L),\n                FBUtilities.getLocalAddress().getAddress(), FBUtilities.toByteArray(12L), FBUtilities.toByteArray(8L)\n                );\n        assert 0 == FBUtilities.compareByteSubArrays(\n            ((CounterColumn)sc.getSubColumn(getBytes(1))).partitionedCounter(),\n            0,\n            c1,\n            0,\n            c1.length);\n\n        // column: 2\n        byte[] c2 = concatByteArrays(\n                FBUtilities.toByteArray(2), FBUtilities.toByteArray(1L), FBUtilities.toByteArray(0L),\n                FBUtilities.toByteArray(3), FBUtilities.toByteArray(6L), FBUtilities.toByteArray(0L),\n                FBUtilities.toByteArray(7), FBUtilities.toByteArray(3L), FBUtilities.toByteArray(0L)\n                );\n        assert 0 == FBUtilities.compareByteSubArrays(\n            ((CounterColumn)sc.getSubColumn(getBytes(2))).partitionedCounter(),\n            0,\n            c2,\n            0,\n            c2.length);\n\n    \tassertNotNull(sc.getSubColumn(getBytes(1)));\n    \tassertNotNull(sc.getSubColumn(getBytes(2)));\n    \tassertNull(sc.getSubColumn(getBytes(3)));\n    }","commit_id":"9ef94ebc6d8da1afff6d1a6d6c154999c45ead4b","url":"https://github.com/apache/cassandra"},{"original_method":"public DeepSeaKraken(UUID ownerId) {\r\n        super(ownerId, 56, \"Deep-Sea Kraken\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{7}{U}{U}{U}\");\r\n        this.expansionSetCode = \"TSP\";\r\n        this.subtype.add(\"Kraken\");\r\n\r\n        this.power = new MageInt(6);\r\n        this.toughness = new MageInt(6);\r\n\r\n        // Deep-Sea Kraken can't be blocked.\r\n        this.addAbility(new CantBeBlockedSourceAbility());\r\n        // Suspend 9-{2}{U}\r\n        this.addAbility(new SuspendAbility(9, new ManaCostsImpl(\"{2}{U}\"), this));\r\n        // Whenever an opponent casts a spell, if Deep-Sea Kraken is suspended, remove a time counter from it.\r\n        this.addAbility(new ConditionalTriggeredAbility(\r\n                new SpellCastAllTriggeredAbility(Zone.EXILED, new RemoveCounterSourceEffect(CounterType.TIME.createInstance()), filter, false, false), SuspendedCondition.getInstance(),\r\n                \"Whenever an opponent casts a spell, if Deep-Sea Kraken is suspended, remove a time counter from it.\", false));\r\n    }","id":85796,"modified_method":"public DeepSeaKraken(UUID ownerId) {\r\n        super(ownerId, 56, \"Deep-Sea Kraken\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{7}{U}{U}{U}\");\r\n        this.expansionSetCode = \"TSP\";\r\n        this.subtype.add(\"Kraken\");\r\n\r\n        this.power = new MageInt(6);\r\n        this.toughness = new MageInt(6);\r\n\r\n        // Deep-Sea Kraken can't be blocked.\r\n        this.addAbility(new CantBeBlockedSourceAbility());\r\n        // Suspend 9-{2}{U}\r\n        this.addAbility(new SuspendAbility(9, new ManaCostsImpl(\"{2}{U}\"), this));\r\n        // Whenever an opponent casts a spell, if Deep-Sea Kraken is suspended, remove a time counter from it.\r\n        this.addAbility(new ConditionalTriggeredAbility(\r\n                new SpellCastAllTriggeredAbility(Zone.EXILED, new RemoveCounterSourceEffect(CounterType.TIME.createInstance()), filter, false, null), SuspendedCondition.getInstance(),\r\n                \"Whenever an opponent casts a spell, if Deep-Sea Kraken is suspended, remove a time counter from it.\", false));\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public Dovescape(UUID ownerId) {\r\n        super(ownerId, 143, \"Dovescape\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{W/U}{W/U}{W/U}\");\r\n        this.expansionSetCode = \"DIS\";\r\n\r\n\r\n        // Whenever a player casts a noncreature spell, counter that spell. That player puts X 1/1 white and blue Bird creature tokens with flying onto the battlefield, where X is the spell's converted mana cost.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new DovescapeEffect(), filter, false, true));\r\n    }","id":85797,"modified_method":"public Dovescape(UUID ownerId) {\r\n        super(ownerId, 143, \"Dovescape\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{W/U}{W/U}{W/U}\");\r\n        this.expansionSetCode = \"DIS\";\r\n\r\n\r\n        // Whenever a player casts a noncreature spell, counter that spell. That player puts X 1/1 white and blue Bird creature tokens with flying onto the battlefield, where X is the spell's converted mana cost.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new DovescapeEffect(), filter, false, SetTargetPointer.SPELL));\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public HornOfPlenty(UUID ownerId) {\r\n        super(ownerId, 298, \"Horn of Plenty\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{6}\");\r\n        this.expansionSetCode = \"MMQ\";\r\n\r\n        // Whenever a player casts a spell, he or she may pay {1}. If that player does, he or she draws a card at the beginning of the next end step.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new HornOfPlentyEffect(), new FilterSpell(\"a spell\"), false, true));\r\n    }","id":85798,"modified_method":"public HornOfPlenty(UUID ownerId) {\r\n        super(ownerId, 298, \"Horn of Plenty\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{6}\");\r\n        this.expansionSetCode = \"MMQ\";\r\n\r\n        // Whenever a player casts a spell, he or she may pay {1}. If that player does, he or she draws a card at the beginning of the next end step.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new HornOfPlentyEffect(), new FilterSpell(\"a spell\"), false, SetTargetPointer.PLAYER));\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));\r\n        Player caster = null;\r\n        if (spell != null) {\r\n            caster = game.getPlayer(spell.getControllerId());\r\n        }\r\n        if (caster != null) {\r\n            if (caster.chooseUse(Outcome.DrawCard, \"Pay {1} to draw a card at the beginning of the next end step?\", source, game)) {\r\n                Cost cost = new ManaCostsImpl(\"{1}\");\r\n                if (cost.pay(source, game, source.getSourceId(), caster.getId(), false)) {\r\n                    Effect effect = new DrawCardTargetEffect(1);\r\n                    effect.setTargetPointer(new FixedTarget(caster.getId()));\r\n                    return new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect, TargetController.ANY)).apply(game, source);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":85799,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player caster = game.getPlayer(targetPointer.getFirst(game, source));\r\n        if (caster != null) {\r\n            if (caster.chooseUse(Outcome.DrawCard, \"Pay {1} to draw a card at the beginning of the next end step?\", source, game)) {\r\n                Cost cost = new ManaCostsImpl(\"{1}\");\r\n                if (cost.pay(source, game, source.getSourceId(), caster.getId(), false)) {\r\n                    Effect effect = new DrawCardTargetEffect(1);\r\n                    effect.setTargetPointer(new FixedTarget(caster.getId()));\r\n                    return new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect, TargetController.ANY)).apply(game, source);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public InTheEyeOfChaos(UUID ownerId) {\r\n        super(ownerId, 61, \"In the Eye of Chaos\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{2}{U}\");\r\n        this.expansionSetCode = \"LEG\";\r\n        this.supertype.add(\"World\");\r\n\r\n\r\n        // Whenever a player casts an instant spell, counter it unless that player pays {X}, where X is its converted mana cost.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(Zone.BATTLEFIELD, new InTheEyeOfChaosEffect(), filter, false, true));\r\n    }","id":85800,"modified_method":"public InTheEyeOfChaos(UUID ownerId) {\r\n        super(ownerId, 61, \"In the Eye of Chaos\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{2}{U}\");\r\n        this.expansionSetCode = \"LEG\";\r\n        this.supertype.add(\"World\");\r\n\r\n\r\n        // Whenever a player casts an instant spell, counter it unless that player pays {X}, where X is its converted mana cost.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(Zone.BATTLEFIELD, new InTheEyeOfChaosEffect(), filter, false, SetTargetPointer.SPELL));\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public NetherVoid(UUID ownerId) {\r\n        super(ownerId, 27, \"Nether Void\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{B}\");\r\n        this.expansionSetCode = \"LEG\";\r\n        this.supertype.add(\"World\");\r\n\r\n        // Whenever a player casts a spell, counter it unless that player pays {3}.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new CounterUnlessPaysEffect(new GenericManaCost(3)), new FilterSpell(\"a spell\"), false, true));\r\n    }","id":85801,"modified_method":"public NetherVoid(UUID ownerId) {\r\n        super(ownerId, 27, \"Nether Void\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{B}\");\r\n        this.expansionSetCode = \"LEG\";\r\n        this.supertype.add(\"World\");\r\n\r\n        // Whenever a player casts a spell, counter it unless that player pays {3}.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new CounterUnlessPaysEffect(new GenericManaCost(3)), new FilterSpell(\"a spell\"), false, SetTargetPointer.SPELL));\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));\r\n        Player caster = null;\r\n        if (spell != null) {\r\n            caster = game.getPlayer(spell.getControllerId());\r\n        }\r\n        if (caster != null) {\r\n            caster.loseLife(1, game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":85802,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player caster = game.getPlayer(targetPointer.getFirst(game, source));\r\n        if (caster != null) {\r\n            caster.loseLife(1, game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public SootImp(UUID ownerId) {\r\n        super(ownerId, 43, \"Soot Imp\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}{B}\");\r\n        this.expansionSetCode = \"EVE\";\r\n        this.subtype.add(\"Imp\");\r\n\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n        \r\n        // Whenever a player casts a nonblack spell, that player loses 1 life.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new SootImpEffect(), filter, false, true));\r\n        \r\n    }","id":85803,"modified_method":"public SootImp(UUID ownerId) {\r\n        super(ownerId, 43, \"Soot Imp\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{B}{B}\");\r\n        this.expansionSetCode = \"EVE\";\r\n        this.subtype.add(\"Imp\");\r\n\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // Flying\r\n        this.addAbility(FlyingAbility.getInstance());\r\n\r\n        // Whenever a player casts a nonblack spell, that player loses 1 life.\r\n        this.addAbility(new SpellCastAllTriggeredAbility(new SootImpEffect(), filter, false, SetTargetPointer.PLAYER));\r\n\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        Spell spell = game.getStack().getSpell(event.getTargetId());\r\n        if (spell != null && filter.match(spell, getControllerId(), game)) {\r\n            if (rememberSource) {\r\n                this.getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":85804,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        Spell spell = game.getStack().getSpell(event.getTargetId());\r\n        if (spell != null && filter.match(spell, getControllerId(), game)) {\r\n            if (!setTargetPointer.equals(SetTargetPointer.NONE)) {\r\n                for (Effect effect : this.getEffects()) {\r\n                    switch(setTargetPointer) {\r\n                        case SPELL:\r\n                            effect.setTargetPointer(new FixedTarget(spell.getId()));\r\n                            break;\r\n                        case PLAYER:\r\n                            effect.setTargetPointer(new FixedTarget(spell.getControllerId()));\r\n                            break;\r\n                    }\r\n\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public SpellCastAllTriggeredAbility(Effect effect, FilterSpell filter, boolean optional, String rule) {\r\n        this(effect, filter, optional, false);\r\n        this.rule = rule;\r\n    }","id":85805,"modified_method":"public SpellCastAllTriggeredAbility(Effect effect, FilterSpell filter, boolean optional, String rule) {\r\n        this(effect, filter, optional, SetTargetPointer.NONE);\r\n        this.rule = rule;\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public SpellCastAllTriggeredAbility(Effect effect, FilterSpell filter, boolean optional) {\r\n        this(effect, filter, optional, false);\r\n    }","id":85806,"modified_method":"public SpellCastAllTriggeredAbility(Effect effect, FilterSpell filter, boolean optional) {\r\n        this(effect, filter, optional, SetTargetPointer.NONE);\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public SpellCastAllTriggeredAbility(final SpellCastAllTriggeredAbility ability) {\r\n        super(ability);\r\n        filter = ability.filter;\r\n        this.rememberSource = ability.rememberSource;\r\n        this.rule = ability.rule;\r\n    }","id":85807,"modified_method":"public SpellCastAllTriggeredAbility(final SpellCastAllTriggeredAbility ability) {\r\n        super(ability);\r\n        filter = ability.filter;\r\n        this.setTargetPointer = ability.setTargetPointer;\r\n        this.rule = ability.rule;\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public SpellCastAllTriggeredAbility(Zone zone, Effect effect, FilterSpell filter, boolean optional, boolean rememberSource) {\r\n        super(zone, effect, optional);\r\n        this.filter = filter;\r\n        this.rememberSource = rememberSource;\r\n    }","id":85808,"modified_method":"public SpellCastAllTriggeredAbility(Zone zone, Effect effect, FilterSpell filter, boolean optional, SetTargetPointer setTargetPointer) {\r\n        super(zone, effect, optional);\r\n        this.filter = filter;\r\n        this.setTargetPointer = setTargetPointer;\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public SpellCastAllTriggeredAbility(Effect effect, boolean optional) {\r\n        this(Zone.BATTLEFIELD, effect, spellCard, optional, false);\r\n    }","id":85809,"modified_method":"public SpellCastAllTriggeredAbility(Effect effect, boolean optional) {\r\n        this(Zone.BATTLEFIELD, effect, spellCard, optional, SetTargetPointer.NONE);\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public SpellCastAllTriggeredAbility(Effect effect, FilterSpell filter, boolean optional, boolean rememberSource) {\r\n        this(Zone.BATTLEFIELD, effect, filter, optional, rememberSource);\r\n    }","id":85810,"modified_method":"public SpellCastAllTriggeredAbility(Effect effect, FilterSpell filter, boolean optional, SetTargetPointer setTargetPointer) {\r\n        this(Zone.BATTLEFIELD, effect, filter, optional, setTargetPointer);\r\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public UnifyingTheory(UUID ownerId) {\n        super(ownerId, 112, \"Unifying Theory\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{1}{U}\");\n        this.expansionSetCode = \"ODY\";\n\n\n        // Whenever a player casts a spell, that player may pay {2}. If the player does, he or she draws a card.\n        this.addAbility(new SpellCastAllTriggeredAbility(new UnifyingTheoryEffect() , new FilterSpell(\"a spell\"), false, true));\n    }","id":85811,"modified_method":"public UnifyingTheory(UUID ownerId) {\n        super(ownerId, 112, \"Unifying Theory\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{1}{U}\");\n        this.expansionSetCode = \"ODY\";\n\n\n        // Whenever a player casts a spell, that player may pay {2}. If the player does, he or she draws a card.\n        this.addAbility(new SpellCastAllTriggeredAbility(new UnifyingTheoryEffect() , new FilterSpell(\"a spell\"), false, SetTargetPointer.PLAYER));\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));\n        Player caster = null;\n        if (spell != null) {\n            caster = game.getPlayer(spell.getControllerId());\n        }\n        if (caster != null) {\n            if (caster.chooseUse(Outcome.DrawCard, \"Pay {2} to draw a card?\", source, game)) {\n                Cost cost = new ManaCostsImpl(\"{2}\");\n                if (cost.pay(source, game, source.getSourceId(), caster.getId(), false)) {\n                    caster.drawCards(1, game);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":85812,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player caster = game.getPlayer(targetPointer.getFirst(game, source));\n        if (caster != null) {\n            if (caster.chooseUse(Outcome.DrawCard, \"Pay {2} to draw a card?\", source, game)) {\n                Cost cost = new ManaCostsImpl(\"{2}\");\n                if (cost.pay(source, game, source.getSourceId(), caster.getId(), false)) {\n                    caster.drawCards(1, game);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"d922efc52877832335e6bf3bce497b99d2fab6e9","url":"https://github.com/magefree/mage"},{"original_method":"public Mindsparker(UUID ownerId) {\r\n        super(ownerId, 146, \"Mindsparker\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{R}{R}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Elemental\");\r\n\r\n        this.color.setRed(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // First strike\r\n        this.addAbility(FirstStrikeAbility.getInstance());\r\n\r\n        // Whenever an opponent casts a white or blue instant or sorcery spell, Mindsparker deals 2 damage to that player.\r\n        this.addAbility(new OpponentCastsSpellTriggeredAbility(Zone.BATTLEFIELD, new MindsparkerEffect(), filter, false));\r\n\r\n    }","id":85813,"modified_method":"public Mindsparker(UUID ownerId) {\r\n        super(ownerId, 146, \"Mindsparker\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{1}{R}{R}\");\r\n        this.expansionSetCode = \"M14\";\r\n        this.subtype.add(\"Elemental\");\r\n\r\n        this.color.setRed(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(2);\r\n\r\n        // First strike\r\n        this.addAbility(FirstStrikeAbility.getInstance());\r\n\r\n        // Whenever an opponent casts a white or blue instant or sorcery spell, Mindsparker deals 2 damage to that player.\r\n        this.addAbility(new OpponentCastsSpellTriggeredAbility(Zone.BATTLEFIELD, new MindsparkerEffect(), filter, false, true));\r\n\r\n    }","commit_id":"14bf4c8d331c020ff1707f2830e58322343b18ac","url":"https://github.com/magefree/mage"},{"original_method":"public OpponentCastsSpellTriggeredAbility(final OpponentCastsSpellTriggeredAbility ability) {\n        super(ability);\n        filter = ability.filter;\n        this.setTargetPointerPlayer = ability.setTargetPointerPlayer;\n    }","id":85814,"modified_method":"public OpponentCastsSpellTriggeredAbility(final OpponentCastsSpellTriggeredAbility ability) {\n        super(ability);\n        this.filter = ability.filter;\n        this.setTargetPointerPlayer = ability.setTargetPointerPlayer;\n    }","commit_id":"14bf4c8d331c020ff1707f2830e58322343b18ac","url":"https://github.com/magefree/mage"},{"original_method":"public OpponentCastsSpellTriggeredAbility(Zone zone, Effect effect, FilterCard filter, boolean optional) {\n        super(zone, effect, optional);\n        this.filter = filter;\n    }","id":85815,"modified_method":"public OpponentCastsSpellTriggeredAbility(Zone zone, Effect effect, FilterCard filter, boolean optional) {\n        this(zone, effect, filter, optional, false);\n    }","commit_id":"14bf4c8d331c020ff1707f2830e58322343b18ac","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (event.getType() == GameEvent.EventType.SPELL_CAST && game.getOpponents(controllerId).contains(event.getPlayerId())) {\n            Spell spell = game.getStack().getSpell(event.getTargetId());\n            if (spell != null && filter.match(spell, game) && !setTargetPointerPlayer) {\n                this.getEffects().get(0).setTargetPointer(new FixedTarget(event.getTargetId()));\n                return true;\n            } else {\n                this.getEffects().get(0).setTargetPointer(new FixedTarget(event.getPlayerId()));\n                return true;\n            }\n        }\n        return false;\n    }","id":85816,"modified_method":"@Override\n    public boolean checkTrigger(GameEvent event, Game game) {\n        if (event.getType() == GameEvent.EventType.SPELL_CAST && game.getOpponents(controllerId).contains(event.getPlayerId())) {\n            Spell spell = game.getStack().getSpell(event.getTargetId());\n            if (spell != null && filter.match(spell, game)) {\n                if (setTargetPointerPlayer) {\n                    for (Effect effect: this.getEffects()) {\n                        effect.setTargetPointer(new FixedTarget(event.getPlayerId()));\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"14bf4c8d331c020ff1707f2830e58322343b18ac","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        Set<UUID> opponents = game.getOpponents(this.getControllerId());\r\n        if (opponents.contains(event.getPlayerId())) {\r\n            Effect effect = this.getEffects().get(0);\r\n            effect.setTargetPointer(new FixedTarget(event.getPlayerId()));\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":85817,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        Set<UUID> opponents = game.getOpponents(this.getControllerId());\r\n        if (opponents.contains(event.getPlayerId())) {\r\n            for (Effect effect : this.getEffects()) {\r\n                effect.setValue(\"lostLife\", event.getAmount());\r\n                effect.setTargetPointer(new FixedTarget(event.getPlayerId()));\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"77def0a112e2e6439a2f535c42823ce80628a3a8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));\r\n        if (targetPlayer != null) {\r\n            Integer amount = (Integer) getValue(\"amount\");\r\n            if (amount == null) {\r\n                amount = 0;\r\n            }\r\n            targetPlayer.moveCards(targetPlayer.getLibrary().getTopCards(game, amount), Zone.LIBRARY, Zone.GRAVEYARD, source, game);\r\n        }\r\n        return true;\r\n    }","id":85818,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));\r\n        if (targetPlayer != null) {\r\n            Integer amount = (Integer) getValue(\"lostLife\");\r\n            if (amount == null) {\r\n                amount = 0;\r\n            }\r\n            targetPlayer.moveCards(targetPlayer.getLibrary().getTopCards(game, amount), Zone.LIBRARY, Zone.GRAVEYARD, source, game);\r\n        }\r\n        return true;\r\n    }","commit_id":"77def0a112e2e6439a2f535c42823ce80628a3a8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n  public Item item(final QueryContext ctx, final InputInfo ii)\n      throws QueryException {\n\n    checkAdmin(ctx);\n    final RepoManager repoMng = new RepoManager(ctx.context.repo);\n    // either path to package or package name\n    final String pkg = string(checkStr(expr[0], ctx));\n    switch(def) {\n      case _PKG_INSTALL:\n        repoMng.install(pkg, ii);\n        return null;\n      case _PKG_DELETE:\n        repoMng.delete(pkg, ii);\n        return null;\n      default:\n        return super.item(ctx, ii);\n    }\n  }","id":85819,"modified_method":"@Override\n  public Item item(final QueryContext ctx, final InputInfo ii)\n      throws QueryException {\n\n    checkAdmin(ctx);\n    final RepoManager repoMng = new RepoManager(ctx.context.repo);\n    // either path to package or package name\n    final String pkg = expr.length == 0 ? null : string(checkStr(expr[0], ctx));\n    switch(def) {\n      case _PKG_INSTALL:\n        repoMng.install(pkg, ii);\n        return null;\n      case _PKG_DELETE:\n        repoMng.delete(pkg, ii);\n        return null;\n      default:\n        return super.item(ctx, ii);\n    }\n  }","commit_id":"949f9f40389df335af3c27db155ff4befc85f74c","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   * @param drawX drawn axis is x axis\r\n   */\r\n  private void drawAxis(final Graphics g, final boolean drawX) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.back);\r\n    \r\n    final int novalue = noValueSize();\r\n    // the painting space provided for items which lack no value\r\n    final int pWidth = plotWidth - novalue;\r\n    final int pHeight = plotHeight - novalue;\r\n    \r\n    final PlotAxis axis = drawX ? plotData.xAxis : plotData.yAxis;\r\n    // drawing horizontal axis line\r\n    if(drawX) {\r\n      g.drawLine(MARGIN[1], h - MARGIN[2], w - MARGIN[3], h - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pWidth);\r\n    } else {\r\n      // drawing vertical axis line\r\n      g.drawLine(MARGIN[1], MARGIN[0], MARGIN[1], getHeight() - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pHeight);\r\n    }\r\n    \r\n    // getting some axis specific data\r\n    final Kind type = axis.type;\r\n    final int nrCaptions = axis.nrCaptions/* > 1 ? axis.nrCaptions : 3*/;\r\n    final double step = axis.captionStep;\r\n    final double capRange = 1.0d / (nrCaptions - 1);\r\n\r\n    g.setFont(GUIConstants.font);\r\n    \r\n    \r\n    // determine axis caption for TEXT / INT / DBL data\r\n    if(type == Kind.TEXT) {\r\n//      final int nrCats = axis.nrCats; \r\n      final double[] coSorted = Arrays.copyOf(axis.co, axis.co.length);\r\n      // draw min / max caption\r\n      drawCaptionAndGrid(g, drawX, string(axis.firstCat), 0);\r\n      drawCaptionAndGrid(g, drawX, string(axis.lastCat), 1);\r\n      // return if insufficient plot space\r\n      if(nrCaptions == 0) return;\r\n      \r\n      // get sorted axis item coordinates\r\n      Arrays.sort(coSorted);\r\n      // optimum caption position\r\n      double op = capRange;\r\n      final int cl = coSorted.length;\r\n      int i = 0;\r\n      // find first non .0d coordinate value\r\n      while(i < cl && coSorted[i] == 0) i++;\r\n      // find nearest position for next axis caption\r\n      while(i < cl && op < 1.0d - 0.4d * capRange) {\r\n        if(coSorted[i] > op) {\r\n          final double distL = Math.abs(coSorted[i - 1] - op);\r\n          final double distG = Math.abs(coSorted[i] - op);\r\n          op = distL < distG ? coSorted[i - 1] : coSorted[i];\r\n          \r\n          int j = 0;\r\n          // find value for given plot position\r\n          while(j < axis.co.length && axis.co[j] != op) j++;\r\n          drawCaptionAndGrid(g, drawX, \r\n              string(axis.getValue(plotData.pres[j])), op);\r\n          // increase to next optimum caption position\r\n          op += capRange;\r\n        }\r\n        i++;\r\n      }\r\n      \r\n    } else {\r\n      int i = 1;\r\n      // draw min/max caption\r\n      drawCaptionAndGrid(g, drawX, formatString(axis.min, drawX), 0);\r\n      drawCaptionAndGrid(g, drawX, formatString(axis.max, drawX), 1);\r\n      // return if insufficient plot space\r\n      if(nrCaptions == 0) return;\r\n\r\n\r\n      // draw captions between min and max\r\n//      <LK> ugly workaround - will be fixed\r\n      if(nrCaptions < 0) return;\r\n      while(i < nrCaptions - 1) {\r\n        drawCaptionAndGrid(g, drawX, \r\n            formatString(axis.min + i * step, drawX), capRange * i);\r\n        i++;\r\n      }\r\n    }\r\n  }","id":85820,"modified_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   * @param drawX drawn axis is x axis\r\n   */\r\n  private void drawAxis(final Graphics g, final boolean drawX) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.back);\r\n    \r\n    final int novalue = noValueSize();\r\n    // the painting space provided for items which lack no value\r\n    final int pWidth = plotWidth - novalue;\r\n    final int pHeight = plotHeight - novalue;\r\n    \r\n    final PlotAxis axis = drawX ? plotData.xAxis : plotData.yAxis;\r\n    // drawing horizontal axis line\r\n    if(drawX) {\r\n      g.drawLine(MARGIN[1], h - MARGIN[2], w - MARGIN[3], h - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pWidth);\r\n    } else {\r\n      // drawing vertical axis line\r\n      g.drawLine(MARGIN[1], MARGIN[0], MARGIN[1], getHeight() - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pHeight);\r\n    }\r\n    \r\n    // getting some axis specific data\r\n    final Kind type = axis.type;\r\n    final int nrCaptions = axis.nrCaptions/* > 1 ? axis.nrCaptions : 3*/;\r\n    final double step = axis.captionStep;\r\n    final double capRange = 1.0d / (nrCaptions - 1);\r\n\r\n    g.setFont(GUIConstants.font);\r\n    \r\n    \r\n    // determine axis caption for TEXT / INT / DBL data\r\n    if(type == Kind.TEXT) {\r\n      final int nrCats = axis.nrCats;\r\n      final double[] coSorted = Arrays.copyOf(axis.co, axis.co.length);\r\n      // draw min / max caption\r\n      drawCaptionAndGrid(g, drawX, nrCats > 1 ? string(axis.firstCat) : \"\", 0);\r\n      drawCaptionAndGrid(g, drawX, nrCats > 1 ? string(axis.lastCat) : \"\", 1);\r\n      // return if insufficient plot space\r\n      if(nrCaptions == 0) return;\r\n      \r\n      // get sorted axis item coordinates\r\n      Arrays.sort(coSorted);\r\n      // optimum caption position\r\n      double op = capRange;\r\n      final int cl = coSorted.length;\r\n      int i = 0;\r\n      // find first non .0d coordinate value\r\n      while(i < cl && coSorted[i] == 0) i++;\r\n      // find nearest position for next axis caption\r\n      while(i < cl && op < 1.0d - 0.4d * capRange) {\r\n        if(coSorted[i] > op) {\r\n          final double distL = Math.abs(coSorted[i - 1] - op);\r\n          final double distG = Math.abs(coSorted[i] - op);\r\n          op = distL < distG ? coSorted[i - 1] : coSorted[i];\r\n          \r\n          int j = 0;\r\n          // find value for given plot position\r\n          while(j < axis.co.length && axis.co[j] != op) j++;\r\n          drawCaptionAndGrid(g, drawX, \r\n              string(axis.getValue(plotData.pres[j])), op);\r\n          // increase to next optimum caption position\r\n          op += capRange;\r\n        }\r\n        i++;\r\n      }\r\n      if(nrCats == 1) {\r\n        op = .5d;\r\n        int j = 0;\r\n        // find value for given plot position\r\n        while(j < axis.co.length && axis.co[j] != op) j++;\r\n        drawCaptionAndGrid(g, drawX, \r\n            string(axis.getValue(plotData.pres[j])), op);\r\n      }\r\n      \r\n    } else {\r\n      int i = 1;\r\n      // draw min/max caption\r\n      drawCaptionAndGrid(g, drawX, formatString(axis.min, drawX), 0);\r\n      drawCaptionAndGrid(g, drawX, formatString(axis.max, drawX), 1);\r\n      // return if insufficient plot space\r\n      if(nrCaptions == 0) return;\r\n\r\n\r\n      // draw captions between min and max\r\n//      <LK> ugly workaround - will be fixed\r\n      if(nrCaptions < 0) return;\r\n      while(i < nrCaptions - 1) {\r\n        drawCaptionAndGrid(g, drawX, \r\n            formatString(axis.min + i * step, drawX), capRange * i);\r\n        i++;\r\n      }\r\n    }\r\n  }","commit_id":"e84849f480a84e0b0fa142e053fcdb50e568f24e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Reads the next byte.\n   * @return next byte\n   */\n  private int read() {\n    final Buffer bf = buffer(off == IO.BLOCKSIZE);\n    return bf.data[off++] & 0xFF;\n  }","id":85821,"modified_method":"/**\n   * Reads the next byte.\n   * @return next byte\n   */\n  public int read() {\n    final Buffer bf = buffer(off == IO.BLOCKSIZE);\n    return bf.data[off++] & 0xFF;\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Writes the next byte.\n   * @param b byte to be written\n   */\n  private void write(final int b) {\n    final Buffer bf = buffer(off == IO.BLOCKSIZE);\n    bf.dirty = true;\n    bf.data[off++] = (byte) b;\n    final long nl = bf.pos + off;\n    if(nl > len) length(nl);\n  }","id":85822,"modified_method":"/**\n   * Writes the next byte.\n   * @param b byte to be written\n   */\n  public void write(final int b) {\n    final Buffer bf = buffer(off == IO.BLOCKSIZE);\n    bf.dirty = true;\n    bf.data[off++] = (byte) b;\n    final long nl = bf.pos + off;\n    if(nl > len) length(nl);\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor, initializing the file reader.\n   * @param f the file to be read\n   * @throws IOException I/O Exception\n   */\n  public DataAccess(final IOFile f) throws IOException {\n    file = new RandomAccessFile(f.file(), \"rw\");\n    len = file.length();\n    cursor(0);\n  }","id":85823,"modified_method":"/**\n   * Constructor, initializing the file reader.\n   * @param fl the file to be read\n   * @throws IOException I/O Exception\n   */\n  public DataAccess(final IOFile fl) throws IOException {\n    RandomAccessFile f = null;\n    try {\n      f = new RandomAccessFile(fl.file(), \"rw\");\n      len = f.length();\n    } catch(final IOException ex) {\n      if(f != null) f.close();\n      throw ex;\n    }\n    file = f;\n    cursor(0);\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Writes binary items to a file.\n   * @param append append flag\n   * @param ctx query context\n   * @return result\n   * @throws QueryException query exception\n   * @throws IOException I/O exception\n   */\n  private synchronized Item writeBinary(final boolean append, final QueryContext ctx)\n      throws QueryException, IOException {\n\n    final File path = check(checkFile(0, ctx));\n    final Iter ir = expr[1].iter(ctx);\n    final BufferOutput out = new BufferOutput(new FileOutputStream(path, append));\n    try {\n      for(Item it; (it = ir.next()) != null;) {\n        if(!(it instanceof Bin)) BINARYTYPE.thrw(info, it.type);\n        final InputStream is = it.input(info);\n        try {\n          for(int i; (i = is.read()) != -1;)  out.write(i);\n        } finally {\n          is.close();\n        }\n      }\n    } finally {\n      out.close();\n    }\n    return null;\n  }","id":85824,"modified_method":"/**\n   * Writes binary items to a file.\n   * @param append append flag\n   * @param ctx query context\n   * @return result\n   * @throws QueryException query exception\n   * @throws IOException I/O exception\n   */\n  private synchronized Item writeBinary(final boolean append, final QueryContext ctx)\n      throws QueryException, IOException {\n\n    final File path = check(checkFile(0, ctx));\n    final Bin bin = checkBinary(expr[1], ctx);\n    final long off = expr.length > 2 ? checkItr(expr[2], ctx) : 0;\n\n    // write full file\n    if(expr.length == 2) {\n      final BufferOutput out = new BufferOutput(new FileOutputStream(path, append));\n      try {\n        final InputStream is = bin.input(info);\n        try {\n          for(int i; (i = is.read()) != -1;)  out.write(i);\n        } finally {\n          is.close();\n        }\n      } finally {\n        out.close();\n      }\n    }\n\n    // write file chunk\n    final RandomAccessFile raf = new RandomAccessFile(path, \"rw\");\n    try {\n      final long dlen = raf.length();\n      if(off < 0 || off > dlen) FILE_BOUNDS.thrw(info, off, dlen);\n      raf.seek(off);\n      raf.write(bin.binary(info));\n    } finally {\n      raf.close();\n    }\n    return null;\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the size of the specified path.\n   * @param ctx query context\n   * @return result\n   * @throws QueryException query exception\n   */\n  private Item size(final QueryContext ctx) throws QueryException {\n    final File path = checkFile(0, ctx);\n    if(!path.exists()) FILE_WHICH.thrw(info, path.getAbsolutePath());\n    if(path.isDirectory()) FILE_DIR.thrw(info, path.getAbsolutePath());\n    return Int.get(path.length());\n  }","id":85825,"modified_method":"/**\n   * Returns the size of the specified path.\n   * @param ctx query context\n   * @return result\n   * @throws QueryException query exception\n   */\n  private Item size(final QueryContext ctx) throws QueryException {\n    final File path = checkFile(0, ctx);\n    if(!path.exists()) FILE_WHICH.thrw(info, path.getAbsolutePath());\n    return Int.get(path.length());\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates a temporary file or directory.\n   * @param ctx query context\n   * @param dir create a directory instead of a file\n   * @return path of created file or directory\n   * @throws QueryException query exception\n   * @throws IOException I/O exception\n   */\n  private synchronized Item createTemp(final boolean dir, final QueryContext ctx)\n      throws QueryException, IOException {\n\n    final String pref = string(checkStr(expr[0], ctx));\n    final String suf = string(checkStr(expr[1], ctx));\n    final File root;\n    if(expr.length > 2) {\n      root = checkFile(2, ctx);\n      if(root.isFile()) FILE_NODIR.thrw(info, root);\n    } else {\n      root = new File(Prop.TMP);\n    }\n\n    // choose non-existing file path\n    final Random rnd = new Random();\n    File file;\n    do {\n      file = new File(root, pref + rnd.nextLong() + suf);\n    } while(file.exists());\n\n    // create directory or file\n    String path = file.getPath();\n    if(dir) {\n      if(!file.mkdirs()) FILE_CREATE.thrw(info, file);\n      path = dir(path);\n    } else {\n      new IOFile(file).write(EMPTY);\n    }\n    return Str.get(path);\n  }","id":85826,"modified_method":"/**\n   * Creates a temporary file or directory.\n   * @param ctx query context\n   * @param dir create a directory instead of a file\n   * @return path of created file or directory\n   * @throws QueryException query exception\n   * @throws IOException I/O exception\n   */\n  private synchronized Item createTemp(final boolean dir, final QueryContext ctx)\n      throws QueryException, IOException {\n\n    final String pref = string(checkStr(expr[0], ctx));\n    final String suf = expr.length > 1 ? string(checkStr(expr[1], ctx)) : \"\";\n    final File root;\n    if(expr.length > 2) {\n      root = checkFile(2, ctx);\n      if(root.isFile()) FILE_NODIR.thrw(info, root);\n    } else {\n      root = new File(Prop.TMP);\n    }\n\n    // choose non-existing file path\n    final Random rnd = new Random();\n    File file;\n    do {\n      file = new File(root, pref + rnd.nextLong() + suf);\n    } while(file.exists());\n\n    // create directory or file\n    String path = file.getPath();\n    if(dir) {\n      if(!file.mkdirs()) FILE_CREATE.thrw(info, file);\n      path = dir(path);\n    } else {\n      new IOFile(file).write(EMPTY);\n    }\n    return Str.get(path);\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Reads the contents of a binary file.\n   * @param ctx query context\n   * @return Base64Binary\n   * @throws QueryException query exception\n   */\n  private B64Stream readBinary(final QueryContext ctx) throws QueryException {\n    final File path = checkFile(0, ctx);\n    if(!path.exists()) FILE_WHICH.thrw(info, path.getAbsolutePath());\n    if(path.isDirectory()) FILE_DIR.thrw(info, path.getAbsolutePath());\n    return new B64Stream(new IOFile(path), FILE_IO);\n  }","id":85827,"modified_method":"/**\n   * Reads the contents of a binary file.\n   * @param ctx query context\n   * @return Base64Binary\n   * @throws QueryException query exception\n   * @throws IOException I/O exception\n   */\n  private B64 readBinary(final QueryContext ctx) throws QueryException, IOException {\n    final File path = checkFile(0, ctx);\n    final long off = expr.length > 1 ? checkItr(expr[1], ctx) : 0;\n    long len = expr.length > 2 ? checkItr(expr[2], ctx) : 0;\n\n    if(!path.exists()) FILE_WHICH.thrw(info, path.getAbsolutePath());\n    if(path.isDirectory()) FILE_DIR.thrw(info, path.getAbsolutePath());\n\n    // read full file\n    if(expr.length == 1) return new B64Stream(new IOFile(path), FILE_IO);\n\n    // read file chunk\n    final DataAccess da = new DataAccess(new IOFile(path));\n    try {\n      final long dlen = da.length();\n      if(expr.length == 2) len = dlen - off;\n      if(off < 0 || off > dlen || len < 0 || off + len > dlen)\n        FILE_BOUNDS.thrw(info, off, off + len);\n      da.cursor(off);\n      return new B64(da.readBytes((int) len));\n    } finally {\n      da.close();\n    }\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Test method. */\n  @Test\n  public void writeBinary() {\n    final String bin = \"xs:base64Binary('MA==')\";\n    error(_FILE_WRITE_BINARY.args(PATH, bin), Err.FILE_DIR);\n    error(_FILE_WRITE_BINARY.args(PATH1, \"NoBinary\"), Err.BINARYTYPE);\n\n    query(_FILE_WRITE_BINARY.args(PATH1, bin));\n    query(_FILE_SIZE.args(PATH1), \"1\");\n    query(_FILE_WRITE_BINARY.args(PATH1, bin));\n    query(_FILE_SIZE.args(PATH1), \"1\");\n    query(_FILE_DELETE.args(PATH1));\n  }","id":85828,"modified_method":"/** Test method. */\n  @Test\n  public void writeBinary() {\n    // check errors\n    final String bin = \"xs:base64Binary('MA==')\";\n    error(_FILE_WRITE_BINARY.args(PATH, bin), Err.FILE_DIR);\n    error(_FILE_WRITE_BINARY.args(PATH1, \"NoBinary\"), Err.BINARYTYPE);\n    // write file and check size\n    query(_FILE_WRITE_BINARY.args(PATH1, bin));\n    query(_FILE_SIZE.args(PATH1), \"1\");\n    query(_FILE_WRITE_BINARY.args(PATH1, bin));\n    query(_FILE_SIZE.args(PATH1), \"1\");\n    // write data to specific offset and check size\n    error(_FILE_WRITE_BINARY.args(PATH1, bin, 2), Err.FILE_BOUNDS);\n    query(_FILE_WRITE_BINARY.args(PATH1, bin, 0));\n    query(_FILE_READ_TEXT.args(PATH1), \"0\");\n    query(_FILE_WRITE_BINARY.args(PATH1, bin, 1));\n    query(_FILE_READ_TEXT.args(PATH1), \"00\");\n    // delete size\n    query(_FILE_DELETE.args(PATH1));\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Test method. */\n  @Test\n  public void readBinary() {\n    error(_FILE_READ_BINARY.args(PATH1), Err.FILE_WHICH);\n    error(_FILE_READ_BINARY.args(PATH), Err.FILE_DIR);\n    query(_FILE_WRITE.args(PATH1, \"0\"));\n    query(_FILE_READ_BINARY.args(PATH1), \"MA==\");\n    query(_FILE_WRITE.args(PATH1, \"a\\u00e4\"));\n    query(_FILE_READ_BINARY.args(PATH1), \"YcOk\");\n    query(_FILE_WRITE_BINARY.args(PATH1, _CONVERT_STRING_TO_BASE64.args(\"a\\u00e4\")));\n    query(_FILE_READ_BINARY.args(PATH1), \"YcOk\");\n    query(_FILE_DELETE.args(PATH1));\n  }","id":85829,"modified_method":"/** Test method. */\n  @Test\n  public void readBinary() {\n    // check errors\n    error(_FILE_READ_BINARY.args(PATH1), Err.FILE_WHICH);\n    error(_FILE_READ_BINARY.args(PATH), Err.FILE_DIR);\n    // file with single codepoint\n    query(_FILE_WRITE.args(PATH1, \"0\"));\n    query(_FILE_READ_BINARY.args(PATH1), \"MA==\");\n    query(_FILE_READ_BINARY.args(PATH1, 0), \"MA==\");\n    query(_FILE_READ_BINARY.args(PATH1, 0, 1), \"MA==\");\n    query(_FILE_READ_BINARY.args(PATH1, 1), \"\");\n    query(_FILE_READ_BINARY.args(PATH1, 1, 0), \"\");\n    query(_FILE_READ_BINARY.args(PATH1, 0, 0), \"\");\n    error(_FILE_READ_BINARY.args(PATH1, -1), Err.FILE_BOUNDS);\n    error(_FILE_READ_BINARY.args(PATH1, 2), Err.FILE_BOUNDS);\n    error(_FILE_READ_BINARY.args(PATH1, 0, -1), Err.FILE_BOUNDS);\n    error(_FILE_READ_BINARY.args(PATH1, 0, 2), Err.FILE_BOUNDS);\n    error(_FILE_READ_BINARY.args(PATH1, 2, 1), Err.FILE_BOUNDS);\n    // file with two codepoints\n    query(_FILE_WRITE.args(PATH1, \"a\\u00e4\"));\n    query(_FILE_READ_BINARY.args(PATH1), \"YcOk\");\n    // file with two codepoints\n    query(_FILE_WRITE_BINARY.args(PATH1, _CONVERT_STRING_TO_BASE64.args(\"a\\u00e4\")));\n    query(_FILE_READ_BINARY.args(PATH1), \"YcOk\");\n    // delete file\n    query(_FILE_DELETE.args(PATH1));\n  }","commit_id":"640f45084df928e242e9e760fc3035be66db82a6","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void paintComponent(final Graphics g) {\r\n    final Data data = GUI.context.data();\r\n    if(data == null) return;\r\n\r\n    super.paintComponent(g);\r\n    BaseXLayout.antiAlias(g);\r\n    \r\n    final int w = getWidth();\r\n    final int h = getHeight();\r\n    //final boolean nostats = !data.tags.uptodate;\r\n\r\n    final int novalue = noValueSize();\r\n    final int minSize = novalue * 8;\r\n    if(w < minSize || h < minSize) {\r\n      g.setFont(GUIConstants.font);\r\n      g.setColor(Color.black);\r\n      BaseXLayout.drawCenter(g, NOSPACE, getWidth(), h / 2);\r\n      return;\r\n    }\r\n    \r\n    if(scatterData == null) {\r\n      refreshInit();\r\n      return;\r\n    }\r\n    \r\n    if(w + h != viewDimension) {\r\n      viewDimension = w + h;\r\n      plotChanged = true;\r\n    }\r\n\r\n    plotWidth = w - (MARGIN[1] + MARGIN[3]);\r\n    plotHeight = h - (MARGIN[0] + MARGIN[2]);\r\n    \r\n    // overdraw plot background\r\n    g.setColor(GUIConstants.back);\r\n    g.fillRect(MARGIN[1] + novalue, MARGIN[0],\r\n        plotWidth - novalue, plotHeight - novalue);\r\n    \r\n    // draw axis and grid\r\n    drawAxis(g, true);\r\n    drawAxis(g, false);\r\n\r\n    // draw items\r\n    if(scatterData.size == 0) return;\r\n    if(plotImg == null || plotChanged)\r\n      plotImg = createPlotImage();\r\n    g.drawImage(plotImg, 0, 0, this);\r\n    \r\n    // draw marked items\r\n    final Nodes marked = GUI.context.marked();\r\n    if(marked.size() > 0) {\r\n      for(int i = 0; i < marked.size(); i++) {\r\n        final int prePos = scatterData.findPre(marked.nodes[i]);\r\n        if(prePos > -1)\r\n          drawItem(g, scatterData.xAxis.co[prePos], \r\n              scatterData.yAxis.co[prePos], false, true);\r\n      }\r\n    }\r\n\r\n    // draw focused item\r\n    final int f = scatterData.findPre(focused);\r\n    if(f > -1) {\r\n      if(!dragging) {\r\n        final double x1 = scatterData.xAxis.co[f];\r\n        final double y1 = scatterData.yAxis.co[f];\r\n        drawItem(g, x1, y1, true, false);\r\n        // draw focused x and y value\r\n        g.setFont(GUIConstants.font);\r\n        final String x = string(scatterData.xAxis.getValue(focused));\r\n        final String y = string(scatterData.yAxis.getValue(focused));\r\n        final String label = (x.length() > 15 ? x.substring(0, 15) : x) + \" / \" \r\n            + (y.length() > 15 ? y.substring(0, 15) : y);\r\n        final int tw = BaseXLayout.width(g, label);\r\n        final int th = g.getFontMetrics().getHeight();\r\n        final int xx = Math.min(getWidth() - tw - 8, calcCoordinate(true, x1));\r\n        g.setColor(GUIConstants.COLORS[10]);\r\n        g.fillRect(xx - 1, calcCoordinate(false, y1) - th, tw + 4, th);\r\n        g.setColor(GUIConstants.color1);\r\n        g.drawString(label, xx, calcCoordinate(false, y1) - 4);\r\n      }\r\n    }\r\n    \r\n    // draw selection box\r\n    if(dragging) {\r\n      g.setColor(GUIConstants.back);\r\n      final int selW = selectionBox.getWidth();\r\n      final int selH = selectionBox.getHeight();\r\n      final int x1 = selectionBox.x1;\r\n      final int y1 = selectionBox.y1;\r\n      g.fillRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH, \r\n          Math.abs(selW), Math.abs(selH));\r\n      g.setColor(GUIConstants.frame);\r\n      g.drawRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH, \r\n          Math.abs(selW), Math.abs(selH));\r\n    }\r\n    plotChanged = false;\r\n  }","id":85830,"modified_method":"@Override\r\n  public void paintComponent(final Graphics g) {\r\n    final Data data = GUI.context.data();\r\n    if(data == null) return;\r\n\r\n    super.paintComponent(g);\r\n    BaseXLayout.antiAlias(g);\r\n    \r\n    final int w = getWidth();\r\n    final int h = getHeight();\r\n    //final boolean nostats = !data.tags.uptodate;\r\n\r\n    final int novalue = noValueSize();\r\n    final int minSize = novalue * 8;\r\n    if(w < minSize || h < minSize) {\r\n      g.setFont(GUIConstants.font);\r\n      g.setColor(Color.black);\r\n      BaseXLayout.drawCenter(g, NOSPACE, getWidth(), h / 2);\r\n      return;\r\n    }\r\n    \r\n    if(scatterData == null) {\r\n      refreshInit();\r\n      return;\r\n    }\r\n    \r\n    if(w + h != viewDimension) {\r\n      viewDimension = w + h;\r\n      plotChanged = true;\r\n    }\r\n\r\n    plotWidth = w - (MARGIN[1] + MARGIN[3]);\r\n    plotHeight = h - (MARGIN[0] + MARGIN[2]);\r\n    \r\n    // overdraw plot background\r\n    g.setColor(GUIConstants.back);\r\n    g.fillRect(MARGIN[1] + novalue, MARGIN[0],\r\n        plotWidth - novalue, plotHeight - novalue);\r\n    \r\n    // draw axis and grid\r\n    drawAxis(g, true);\r\n    drawAxis(g, false);\r\n\r\n    // draw items\r\n    if(scatterData.size == 0) return;\r\n    if(plotImg == null || plotChanged)\r\n      plotImg = createPlotImage();\r\n    g.drawImage(plotImg, 0, 0, this);\r\n    \r\n    // draw marked items\r\n    final Nodes marked = GUI.context.marked();\r\n    if(marked.size() > 0) {\r\n      for(int i = 0; i < marked.size(); i++) {\r\n        final int prePos = scatterData.findPre(marked.nodes[i]);\r\n        if(prePos > -1)\r\n          drawItem(g, scatterData.xAxis.co[prePos], \r\n              scatterData.yAxis.co[prePos], false, true);\r\n      }\r\n    }\r\n\r\n    // draw focused item\r\n    final int f = scatterData.findPre(focused);\r\n    if(f > -1) {\r\n      if(!dragging) {\r\n        final double x1 = scatterData.xAxis.co[f];\r\n        final double y1 = scatterData.yAxis.co[f];\r\n        drawItem(g, x1, y1, true, false);\r\n        // draw focused x and y value\r\n        g.setFont(GUIConstants.font);\r\n        // strings are formatted if deepfs\r\n        String x = \"\";\r\n        byte[] tVal = scatterData.xAxis.getValue(focused);\r\n        Kind numType = scatterData.xAxis.numType;\r\n        if(tVal.length > 0)\r\n          x = !(numType == Kind.TEXT || numType == Kind.CAT) ? \r\n              formatString(toDouble(scatterData.xAxis.getValue(focused)), \r\n                  true) : string(scatterData.xAxis.getValue(focused));\r\n        \r\n        String y = \"\";\r\n        tVal = scatterData.yAxis.getValue(focused);\r\n        numType = scatterData.yAxis.numType;\r\n        if(tVal.length > 0)\r\n          y = !(numType == Kind.TEXT || numType == Kind.CAT) ? \r\n              formatString(toDouble(scatterData.yAxis.getValue(focused)), \r\n                  false) : string(scatterData.yAxis.getValue(focused));\r\n        \r\n        final String label = (x.length() > 16 ? x.substring(0, 16) : x) + \" / \" \r\n            + (y.length() > 15 ? y.substring(0, 15) : y);\r\n        final int tw = BaseXLayout.width(g, label);\r\n        final int th = g.getFontMetrics().getHeight();\r\n        final int xx = Math.min(getWidth() - tw - 8, calcCoordinate(true, x1));\r\n        g.setColor(GUIConstants.COLORS[10]);\r\n        g.fillRect(xx - 1, calcCoordinate(false, y1) - th, tw + 4, th);\r\n        g.setColor(GUIConstants.color1);\r\n        g.drawString(label, xx, calcCoordinate(false, y1) - 4);\r\n      }\r\n    }\r\n    \r\n    // draw selection box\r\n    if(dragging) {\r\n      g.setColor(GUIConstants.back);\r\n      final int selW = selectionBox.getWidth();\r\n      final int selH = selectionBox.getHeight();\r\n      final int x1 = selectionBox.x1;\r\n      final int y1 = selectionBox.y1;\r\n      g.fillRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH, \r\n          Math.abs(selW), Math.abs(selH));\r\n      g.setColor(GUIConstants.frame);\r\n      g.drawRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH, \r\n          Math.abs(selW), Math.abs(selH));\r\n    }\r\n    plotChanged = false;\r\n  }","commit_id":"2a726e6ffd71cd0fdf30886ffc7dbe223c7dbaac","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   * @param drawX drawn axis is x axis\r\n   */\r\n  private void drawAxis(final Graphics g, final boolean drawX) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    \r\n    final int novalue = noValueSize();\r\n    final int textH = g.getFontMetrics().getHeight();\r\n    // the painting space provided for items which lack no value\r\n    final int pWidth = plotWidth - novalue;\r\n    final int pHeight = plotHeight - novalue;\r\n    \r\n    final ScatterAxis axis = drawX ? scatterData.xAxis : scatterData.yAxis;\r\n    // drawing horizontal axis line\r\n    if(drawX) {\r\n      g.drawLine(MARGIN[1], h - MARGIN[2], w - MARGIN[3], h - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pWidth);\r\n    } else {\r\n      // drawing vertical axis line\r\n      g.drawLine(MARGIN[1], MARGIN[0], MARGIN[1], getHeight() - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pHeight);\r\n    }\r\n    \r\n    final boolean numeric = axis.numeric;\r\n    final int nrCaptions = axis.nrCaptions;\r\n    final double step = axis.captionStep;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    final Kind type = axis.numType;\r\n    final int fs = GUIProp.fontsize;\r\n    \r\n    g.setFont(GUIConstants.font);\r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      String caption = \"\";\r\n      if(numeric) {\r\n        final double min = axis.min;\r\n        final double captionValue = i == nrCaptions - 1 ? axis.max : \r\n          min + (i * step);\r\n          \r\n        if(type == Kind.INT)\r\n          caption = Integer.toString((int) captionValue);\r\n        else\r\n          caption = string(chopNumber(token(captionValue)));\r\n\r\n        // category data, each category is displayed as a caption \r\n      } else {\r\n          caption = string(axis.cats[i]);\r\n      }\r\n      \r\n      // if assignment consists of more than 10 characters the caption string\r\n      // is chopped to the length 10 to avoid layout issues\r\n      if(caption.length() > 10) {\r\n        caption = caption.substring(0, 10);\r\n        caption += \"...\";\r\n      }\r\n\r\n      // caption labels are rotated, for both x and y axis. first a buffered\r\n      // image is created which displays the rotated label ...\r\n      final int imgW = BaseXLayout.width(g, caption) + fs;\r\n      final int imgH = 160;\r\n      final BufferedImage img = new BufferedImage(imgW, imgH, \r\n          Transparency.BITMASK);\r\n      Graphics2D g2d = img.createGraphics();\r\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n          RenderingHints.VALUE_ANTIALIAS_ON);\r\n      g2d.rotate(ROTATE, imgW, 0 + textH);\r\n      g2d.setFont(GUIConstants.font);\r\n      g2d.setColor(Color.black);\r\n      g2d.drawString(caption, fs, fs);\r\n\r\n      // ... after that\r\n      // the image is drawn beside x / y axis\r\n      g.setColor(GUIConstants.color1);\r\n      if(drawX) {\r\n        final int x = MARGIN[1] + novalue + (int) (i * range * pWidth);\r\n        final int y = h - MARGIN[2];\r\n        g.drawImage(img, x - imgW + textH - fs, y + fs / 4, this);\r\n        g.drawLine(x, MARGIN[0], x, y + fs / 2);\r\n      } else {\r\n        final int y = h - MARGIN[2] - novalue - (int) (i * range * pHeight);\r\n        g.drawImage(img, MARGIN[1] - imgW - fs, y - fs, this);\r\n        g.drawLine(MARGIN[1] - fs / 2, y, w - MARGIN[3], y);\r\n      }\r\n    }\r\n  }","id":85831,"modified_method":"/**\r\n   * Draws the x axis of the plot.\r\n   * @param g graphics reference\r\n   * @param drawX drawn axis is x axis\r\n   */\r\n  private void drawAxis(final Graphics g, final boolean drawX) {\r\n    final int h = getHeight();\r\n    final int w = getWidth();\r\n    g.setColor(GUIConstants.color1);\r\n    \r\n    final int novalue = noValueSize();\r\n    final int textH = g.getFontMetrics().getHeight();\r\n    // the painting space provided for items which lack no value\r\n    final int pWidth = plotWidth - novalue;\r\n    final int pHeight = plotHeight - novalue;\r\n    \r\n    final ScatterAxis axis = drawX ? scatterData.xAxis : scatterData.yAxis;\r\n    // drawing horizontal axis line\r\n    if(drawX) {\r\n      g.drawLine(MARGIN[1], h - MARGIN[2], w - MARGIN[3], h - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pWidth);\r\n    } else {\r\n      // drawing vertical axis line\r\n      g.drawLine(MARGIN[1], MARGIN[0], MARGIN[1], getHeight() - MARGIN[2]);\r\n      if(plotChanged) axis.calcCaption(pHeight);\r\n    }\r\n    \r\n    final boolean numeric = axis.numeric;\r\n    final int nrCaptions = axis.nrCaptions;\r\n    final double step = axis.captionStep;\r\n    final double range = 1.0d / (nrCaptions - 1);\r\n    final int fs = GUIProp.fontsize;\r\n    \r\n    g.setFont(GUIConstants.font);\r\n    for(int i = 0; i < nrCaptions; i++) {\r\n      String caption = \"\";\r\n      if(numeric) {\r\n        final double min = axis.min;\r\n        final double captionValue = i == nrCaptions - 1 ? axis.max : \r\n          min + (i * step);\r\n\r\n        caption = formatString(captionValue, drawX);\r\n\r\n        // category data, each category is displayed as a caption \r\n      } else {\r\n          caption = string(axis.cats[i]);\r\n      }\r\n      \r\n      // if assignment consists of more than 10 characters the caption string\r\n      // is chopped to the length 10 to avoid layout issues\r\n      if(caption.length() > 10) {\r\n        caption = caption.substring(0, 10);\r\n        caption += \"...\";\r\n      }\r\n\r\n      // caption labels are rotated, for both x and y axis. first a buffered\r\n      // image is created which displays the rotated label ...\r\n      final int imgW = BaseXLayout.width(g, caption) + fs;\r\n      final int imgH = 160;\r\n      final BufferedImage img = new BufferedImage(imgW, imgH, \r\n          Transparency.BITMASK);\r\n      Graphics2D g2d = img.createGraphics();\r\n      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \r\n          RenderingHints.VALUE_ANTIALIAS_ON);\r\n      g2d.rotate(ROTATE, imgW, 0 + textH);\r\n      g2d.setFont(GUIConstants.font);\r\n      g2d.setColor(Color.black);\r\n      g2d.drawString(caption, fs, fs);\r\n\r\n      // ... after that\r\n      // the image is drawn beside x / y axis\r\n      g.setColor(GUIConstants.color1);\r\n      if(drawX) {\r\n        final int x = MARGIN[1] + novalue + (int) (i * range * pWidth);\r\n        final int y = h - MARGIN[2];\r\n        g.drawImage(img, x - imgW + textH - fs, y + fs / 4, this);\r\n        g.drawLine(x, MARGIN[0], x, y + fs / 2);\r\n      } else {\r\n        final int y = h - MARGIN[2] - novalue - (int) (i * range * pHeight);\r\n        g.drawImage(img, MARGIN[1] - imgW - fs, y - fs, this);\r\n        g.drawLine(MARGIN[1] - fs / 2, y, w - MARGIN[3], y);\r\n      }\r\n    }\r\n  }","commit_id":"2a726e6ffd71cd0fdf30886ffc7dbe223c7dbaac","url":"https://github.com/BaseXdb/basex"},{"original_method":"public boolean launch() {\n    Collection<LanguageAccess> _values = this.languages.values();\n    final Function1<LanguageAccess, Boolean> _function = new Function1<LanguageAccess, Boolean>() {\n      @Override\n      public Boolean apply(final LanguageAccess it) {\n        return Boolean.valueOf(it.isLinksAgainstJava());\n      }\n    };\n    final boolean needsJava = IterableExtensions.<LanguageAccess>exists(_values, _function);\n    boolean _equals = Objects.equal(this.baseDir, null);\n    if (_equals) {\n      String _property = System.getProperty(\"user.dir\");\n      this.baseDir = _property;\n      StandaloneBuilder.LOG.warn(((\"Property baseDir not set. Using \\'\" + this.baseDir) + \"\\'\"));\n    }\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Using common types.\");\n    }\n    final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n    boolean _notEquals = (!Objects.equal(this.encoding, null));\n    if (_notEquals) {\n      this.forceDebugLog(\"Setting encoding.\");\n      Collection<LanguageAccess> _values_1 = this.languages.values();\n      this.fileEncodingSetup(_values_1, this.encoding);\n    }\n    StandaloneBuilder.LOG.info(\"Collecting source models.\");\n    final long startedAt = System.currentTimeMillis();\n    Iterable<String> rootsToTravers = this.classPathEntries;\n    boolean _notEquals_1 = (!Objects.equal(this.classPathLookUpFilter, null));\n    if (_notEquals_1) {\n      StandaloneBuilder.LOG.info(\"Class path look up filter is active.\");\n      final Pattern cpLookUpFilter = Pattern.compile(this.classPathLookUpFilter);\n      final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n        @Override\n        public Boolean apply(final String root) {\n          Matcher _matcher = cpLookUpFilter.matcher(root);\n          return Boolean.valueOf(_matcher.matches());\n        }\n      };\n      Iterable<String> _filter = IterableExtensions.<String>filter(this.classPathEntries, _function_1);\n      rootsToTravers = _filter;\n      final Iterable<String> _converted_rootsToTravers = (Iterable<String>)rootsToTravers;\n      int _length = ((Object[])Conversions.unwrapArray(_converted_rootsToTravers, Object.class)).length;\n      String _plus = (\"Investigating \" + Integer.valueOf(_length));\n      String _plus_1 = (_plus + \" of \");\n      int _length_1 = ((Object[])Conversions.unwrapArray(this.classPathEntries, Object.class)).length;\n      String _plus_2 = (_plus_1 + Integer.valueOf(_length_1));\n      String _plus_3 = (_plus_2 + \" class path entries.\");\n      StandaloneBuilder.LOG.info(_plus_3);\n    }\n    final List<URI> sourceResourceURIs = this.collectResources(this.sourceDirs, resourceSet);\n    List<URI> _collectResources = this.collectResources(rootsToTravers, resourceSet);\n    final Iterable<URI> allResourcesURIs = Iterables.<URI>concat(sourceResourceURIs, _collectResources);\n    long _currentTimeMillis = System.currentTimeMillis();\n    long _minus = (_currentTimeMillis - startedAt);\n    String _plus_4 = (\"Finished collecting source models. Took: \" + Long.valueOf(_minus));\n    String _plus_5 = (_plus_4 + \" ms.\");\n    this.forceDebugLog(_plus_5);\n    final Iterable<String> allClassPathEntries = Iterables.<String>concat(this.sourceDirs, this.classPathEntries);\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Installing type provider.\");\n      this.installTypeProvider(allClassPathEntries, resourceSet, null);\n    }\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals_2 = (!Objects.equal(this.clusteringConfig, null));\n    if (_notEquals_2) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        StandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function_2 = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = StandaloneBuilder.this.clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function_2);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    ArrayList<IResourceDescription> _newArrayList = CollectionLiterals.<IResourceDescription>newArrayList();\n    ResourceDescriptionsData index = new ResourceDescriptionsData(_newArrayList);\n    Iterator<URI> allResourceIterator = allResourcesURIs.iterator();\n    while (allResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((allResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = allResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            this.fillIndex(uri, resource, index);\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    this.installIndex(resourceSet, index);\n    if (needsJava) {\n      File _generateStubs = this.generateStubs(index, sourceResourceURIs);\n      final String stubsClasses = this.compileStubs(_generateStubs);\n      StandaloneBuilder.LOG.info(\"Installing type provider for stubs.\");\n      ArrayList<String> _newArrayList_1 = CollectionLiterals.<String>newArrayList(stubsClasses);\n      Iterable<String> _plus_6 = Iterables.<String>concat(allClassPathEntries, _newArrayList_1);\n      this.installTypeProvider(_plus_6, resourceSet, this.jvmTypeAccess);\n    }\n    StandaloneBuilder.LOG.info(\"Validate and generate.\");\n    final Iterator<URI> sourceResourceIterator = sourceResourceURIs.iterator();\n    boolean isErrorFree = true;\n    while (sourceResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((sourceResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = sourceResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            resource.getContents();\n            EcoreUtil2.resolveLazyCrossReferences(resource, CancelIndicator.NullImpl);\n            boolean _validate = this.validate(resource);\n            isErrorFree = _validate;\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        boolean _and = false;\n        if (!this.failOnValidationError) {\n          _and = false;\n        } else {\n          _and = (!isErrorFree);\n        }\n        if (_and) {\n          return isErrorFree;\n        }\n        this.generate(resources);\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    return isErrorFree;\n  }","id":85832,"modified_method":"/**\n   * @return <code>false<\/code> if some of processed resources contains severe validation issues. <code>true<\/code> otherwise\n   */\n  public boolean launch() {\n    Collection<LanguageAccess> _values = this.languages.values();\n    final Function1<LanguageAccess, Boolean> _function = new Function1<LanguageAccess, Boolean>() {\n      @Override\n      public Boolean apply(final LanguageAccess it) {\n        return Boolean.valueOf(it.isLinksAgainstJava());\n      }\n    };\n    final boolean needsJava = IterableExtensions.<LanguageAccess>exists(_values, _function);\n    boolean _equals = Objects.equal(this.baseDir, null);\n    if (_equals) {\n      String _property = System.getProperty(\"user.dir\");\n      this.baseDir = _property;\n      StandaloneBuilder.LOG.warn(((\"Property baseDir not set. Using \\'\" + this.baseDir) + \"\\'\"));\n    }\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Using common types.\");\n    }\n    final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n    boolean _notEquals = (!Objects.equal(this.encoding, null));\n    if (_notEquals) {\n      this.forceDebugLog(\"Setting encoding.\");\n      Collection<LanguageAccess> _values_1 = this.languages.values();\n      this.fileEncodingSetup(_values_1, this.encoding);\n    }\n    StandaloneBuilder.LOG.info(\"Collecting source models.\");\n    final long startedAt = System.currentTimeMillis();\n    Iterable<String> rootsToTravers = this.classPathEntries;\n    boolean _notEquals_1 = (!Objects.equal(this.classPathLookUpFilter, null));\n    if (_notEquals_1) {\n      StandaloneBuilder.LOG.info(\"Class path look up filter is active.\");\n      final Pattern cpLookUpFilter = Pattern.compile(this.classPathLookUpFilter);\n      final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n        @Override\n        public Boolean apply(final String root) {\n          Matcher _matcher = cpLookUpFilter.matcher(root);\n          return Boolean.valueOf(_matcher.matches());\n        }\n      };\n      Iterable<String> _filter = IterableExtensions.<String>filter(this.classPathEntries, _function_1);\n      rootsToTravers = _filter;\n      final Iterable<String> _converted_rootsToTravers = (Iterable<String>)rootsToTravers;\n      int _length = ((Object[])Conversions.unwrapArray(_converted_rootsToTravers, Object.class)).length;\n      String _plus = (\"Investigating \" + Integer.valueOf(_length));\n      String _plus_1 = (_plus + \" of \");\n      int _length_1 = ((Object[])Conversions.unwrapArray(this.classPathEntries, Object.class)).length;\n      String _plus_2 = (_plus_1 + Integer.valueOf(_length_1));\n      String _plus_3 = (_plus_2 + \" class path entries.\");\n      StandaloneBuilder.LOG.info(_plus_3);\n    }\n    final List<URI> sourceResourceURIs = this.collectResources(this.sourceDirs, resourceSet);\n    List<URI> _collectResources = this.collectResources(rootsToTravers, resourceSet);\n    final Iterable<URI> allResourcesURIs = Iterables.<URI>concat(sourceResourceURIs, _collectResources);\n    long _currentTimeMillis = System.currentTimeMillis();\n    long _minus = (_currentTimeMillis - startedAt);\n    String _plus_4 = (\"Finished collecting source models. Took: \" + Long.valueOf(_minus));\n    String _plus_5 = (_plus_4 + \" ms.\");\n    this.forceDebugLog(_plus_5);\n    final Iterable<String> allClassPathEntries = Iterables.<String>concat(this.sourceDirs, this.classPathEntries);\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Installing type provider.\");\n      this.installTypeProvider(allClassPathEntries, resourceSet, null);\n    }\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals_2 = (!Objects.equal(this.clusteringConfig, null));\n    if (_notEquals_2) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        StandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function_2 = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = StandaloneBuilder.this.clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function_2);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    ArrayList<IResourceDescription> _newArrayList = CollectionLiterals.<IResourceDescription>newArrayList();\n    ResourceDescriptionsData index = new ResourceDescriptionsData(_newArrayList);\n    Iterator<URI> allResourceIterator = allResourcesURIs.iterator();\n    while (allResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((allResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = allResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            this.fillIndex(uri, resource, index);\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    this.installIndex(resourceSet, index);\n    if (needsJava) {\n      File _generateStubs = this.generateStubs(index, sourceResourceURIs);\n      final String stubsClasses = this.compileStubs(_generateStubs);\n      StandaloneBuilder.LOG.info(\"Installing type provider for stubs.\");\n      ArrayList<String> _newArrayList_1 = CollectionLiterals.<String>newArrayList(stubsClasses);\n      Iterable<String> _plus_6 = Iterables.<String>concat(allClassPathEntries, _newArrayList_1);\n      this.installTypeProvider(_plus_6, resourceSet, this.jvmTypeAccess);\n    }\n    StandaloneBuilder.LOG.info(\"Validate and generate.\");\n    final Iterator<URI> sourceResourceIterator = sourceResourceURIs.iterator();\n    boolean hasValidationErrors = false;\n    while (sourceResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((sourceResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = sourceResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            resource.getContents();\n            EcoreUtil2.resolveLazyCrossReferences(resource, CancelIndicator.NullImpl);\n            boolean _or = false;\n            boolean _validate = this.validate(resource);\n            boolean _not = (!_validate);\n            if (_not) {\n              _or = true;\n            } else {\n              _or = hasValidationErrors;\n            }\n            hasValidationErrors = _or;\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not_1 = (!_continueProcessing);\n            if (_not_1) {\n              continue_ = false;\n            }\n          }\n        }\n        boolean _and = false;\n        if (!this.failOnValidationError) {\n          _and = false;\n        } else {\n          _and = hasValidationErrors;\n        }\n        if (_and) {\n          return (!hasValidationErrors);\n        }\n        this.generate(resources);\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    return (!hasValidationErrors);\n  }","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void installTypeProvider(final Iterable<String> classPathRoots, final XtextResourceSet resSet, final IndexedJvmTypeAccess typeAccess) {\n    final URLClassLoader classLoader = this.createURLClassLoader(classPathRoots);\n    new ClasspathTypeProvider(classLoader, resSet, typeAccess);\n    resSet.setClasspathURIContext(classLoader);\n  }","id":85833,"modified_method":"protected void installTypeProvider(final Iterable<String> classPathRoots, final XtextResourceSet resSet, final IndexedJvmTypeAccess typeAccess) {\n    final URLClassLoader classLoader = this.createURLClassLoader(classPathRoots);\n    new ClasspathTypeProvider(classLoader, resSet, typeAccess, null);\n    resSet.setClasspathURIContext(classLoader);\n  }","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Injector internalCreateInjector() {\n\t\tnew BuilderTestLanguageStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\treturn Guice.createInjector(new StandaloneBuilderModule());\n\t}","id":85834,"modified_method":"protected Injector internalCreateInjector() {\n\t\tnew BuilderTestLanguageStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\treturn Guice.createInjector(new StandaloneBuilderModule() {\n\t\t\t@Override\n\t\t\tprotected void configure() {\n\t\t\t\tsuper.configure();\n\t\t\t\tbind(StandaloneBuilder.class).to(bindStandaloneBuilder());\n\t\t\t}\n\n\t\t\tprotected Class<? extends StandaloneBuilder> bindStandaloneBuilder() {\n\t\t\t\treturn TestableStandaloneBuilder.class;\n\t\t\t}\n\n\t\t});\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testDuplicateSourceEntries() {\n\t\tTestLanguageConfiguration config = new TestLanguageConfiguration(false);\n\t\tconfig.setJavaSupport(true);\n\t\tinitBuilder(config);\n\t\tbuilder.setJavaSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src2\").getPath()));\n\t\tbuilder.setTempDir(TMP_DIR);\n\t\tbuilder.setDebugLog(true);\n\t\tassertTrue(\"Builder launch returned false\", builder.launch());\n\t\tFile compiledClazz = getFile(\"tmp/classes/JavaClass.class\");\n\t\tassertTrue(\"java compilation failed\", compiledClazz.exists());\n\n\t}","id":85835,"modified_method":"@Test\n\tpublic void testDuplicateSourceEntries() {\n\t\tTestLanguageConfiguration config = new TestLanguageConfiguration(false);\n\t\tconfig.setJavaSupport(true);\n\t\tinitBuilder(config);\n\t\ttestBuilder.setJavaSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src2\").getPath()));\n\t\ttestBuilder.setTempDir(TMP_DIR);\n\t\ttestBuilder.setDebugLog(true);\n\t\tassertTrue(\"Builder launch returned false\", testBuilder.launch());\n\t\tFile compiledClazz = getFile(\"tmp/classes/JavaClass.class\");\n\t\tassertTrue(\"java compilation failed\", compiledClazz.exists());\n\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testDifferentOutputFolders() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85836,"modified_method":"@Test\n\tpublic void testDifferentOutputFolders() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testNoWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tbuilder.setWriteStorageResources(false);\n\t\tassertTrue(builder.launch());\n\t\t\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertFalse(generatedFile.exists());\n\t}","id":85837,"modified_method":"@Test\n\tpublic void testNoWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\ttestBuilder.setWriteStorageResources(false);\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertFalse(generatedFile.exists());\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testJarToPlatformMapping() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tbuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone.with.reference/model\"));\n\t\tbuilder.setClassPathEntries(ImmutableList.of(\"test-data/standalone.with.reference/target/classes/\",\n\t\t\t\t\"test-data/model.in.eclipse.project.jar\"));\n\n\t\tassertTrue(\"Builder launch returned false\", builder.launch());\n\t\tURI uri = EcorePlugin.getPlatformResourceMap().get(\"model.in.eclipse.project\");\n\t\tassertNotNull(\"No platform mapping found for 'model.in.eclipse.project'\", uri);\n\t\tassertTrue(\"Platform mapping is archive\", uri.toString().startsWith(\"archive:file:/\"));\n\t\tassertTrue(\"Platform mapping points to jared project\",\n\t\t\t\turi.toString().endsWith(\"test-data/model.in.eclipse.project.jar!/\"));\n\t}","id":85838,"modified_method":"@Test\n\tpublic void testJarToPlatformMapping() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\ttestBuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone.with.reference/model\"));\n\t\ttestBuilder.setClassPathEntries(ImmutableList.of(\"test-data/standalone.with.reference/target/classes/\",\n\t\t\t\t\"test-data/model.in.eclipse.project.jar\"));\n\n\t\tassertTrue(\"Builder launch returned false\", testBuilder.launch());\n\t\tURI uri = EcorePlugin.getPlatformResourceMap().get(\"model.in.eclipse.project\");\n\t\tassertNotNull(\"No platform mapping found for 'model.in.eclipse.project'\", uri);\n\t\tassertTrue(\"Platform mapping is archive\", uri.toString().startsWith(\"archive:file:/\"));\n\t\tassertTrue(\"Platform mapping points to jared project\",\n\t\t\t\turi.toString().endsWith(\"test-data/model.in.eclipse.project.jar!/\"));\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tbuilder.setWriteStorageResources(true);\n\t\tassertTrue(builder.launch());\n\t\t\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertTrue(generatedFile.exists());\n\t}","id":85839,"modified_method":"@Test\n\tpublic void testWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\ttestBuilder.setWriteStorageResources(true);\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertTrue(generatedFile.exists());\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testOnlyOneSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tbuilder.setSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src\").getAbsolutePath()));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85840,"modified_method":"@Test\n\tpublic void testOnlyOneSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\ttestBuilder.setSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src\").getAbsolutePath()));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testRelativeSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tbuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone/src\"));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85841,"modified_method":"@Test\n\tpublic void testRelativeSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\ttestBuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone/src\"));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"private StandaloneBuilder initBuilder(ILanguageConfiguration config) {\n\t\tString sourceDir1 = new File(PROJECT_DIR, \"src\").getAbsolutePath();\n\t\tString sourceDir2 = new File(PROJECT_DIR, \"src2\").getAbsolutePath();\n\t\tbuilder.setSourceDirs(ImmutableList.of(sourceDir1, sourceDir2));\n\t\tMap<String, LanguageAccess> languages = new LanguageAccessFactory().createLanguageAccess(\n\t\t\t\tImmutableList.of(config), getClass().getClassLoader());\n\t\tbuilder.setBaseDir(PROJECT_DIR.getAbsolutePath());\n\t\tbuilder.setLanguages(languages);\n\t\tbuilder.setClassPathEntries(ImmutableList.<String> of());\n\t\treturn builder;\n\t}","id":85842,"modified_method":"private StandaloneBuilder initBuilder(ILanguageConfiguration config) {\n\t\treturn initBuilder(config, \"src\", \"src2\");\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testSameOutputFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85843,"modified_method":"@Test\n\tpublic void testSameOutputFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"08b5829fa82391c70a8eb65524bec298a37a28be","url":"https://github.com/eclipse/xtext"},{"original_method":"public static Injector createGuiceInjector(CConfiguration cConf, Configuration hConf) {\n    return Guice.createInjector(new ConfigModule(cConf, hConf),\n                                new IOModule(),\n                                new ZKClientModule(),\n                                new KafkaClientModule(),\n                                new DiscoveryRuntimeModule().getDistributedModules(),\n                                new LocationRuntimeModule().getDistributedModules(),\n                                new DataFabricModules(cConf, hConf).getDistributedModules(),\n                                new PrivateModule() {\n                                  @Override\n                                  protected void configure() {\n                                    install(new MetricsProcessorModule());\n                                    bind(MetricsTableFactory.class).to(DefaultMetricsTableFactory.class)\n                                      .in(Scopes.SINGLETON);\n                                    bind(MessageCallbackFactory.class).to(MetricsMessageCallbackFactory.class);\n                                    bind(TableMigrator.class).to(MetricsTableMigrator_2_0_to_2_1.class);\n                                    install(new FactoryModuleBuilder()\n                                              .build(KafkaMetricsProcessorServiceFactory.class));\n\n                                    expose(TableMigrator.class);\n                                    expose(KafkaMetricsProcessorServiceFactory.class);\n                                  }\n\n                                  @Provides\n                                  @Named(MetricsConstants.ConfigKeys.KAFKA_CONSUMER_PERSIST_THRESHOLD)\n                                  public int providesConsumerPersistThreshold(CConfiguration cConf) {\n                                    return cConf.getInt(MetricsConstants.ConfigKeys.KAFKA_CONSUMER_PERSIST_THRESHOLD,\n                                                        MetricsConstants.DEFAULT_KAFKA_CONSUMER_PERSIST_THRESHOLD);\n                                  }\n\n                                  @Provides\n                                  @Named(MetricsConstants.ConfigKeys.KAFKA_TOPIC_PREFIX)\n                                  public String providesKafkaTopicPrefix(CConfiguration cConf) {\n                                    return cConf.get(MetricsConstants.ConfigKeys.KAFKA_TOPIC_PREFIX,\n                                                     MetricsConstants.DEFAULT_KAFKA_TOPIC_PREFIX);\n                                  }\n\n                                  @Provides\n                                  @Singleton\n                                  public KafkaConsumerMetaTable providesKafkaConsumerMetaTable(MetricsTableFactory\n                                                                                                 tableFactory) {\n                                    return tableFactory.createKafkaConsumerMeta(\"default\");\n                                  }\n                                });\n  }","id":85844,"modified_method":"public static Injector createGuiceInjector(CConfiguration cConf, Configuration hConf) {\n    return Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new IOModule(),\n      new ZKClientModule(),\n      new KafkaClientModule(),\n      new DiscoveryRuntimeModule().getDistributedModules(),\n      new LocationRuntimeModule().getDistributedModules(),\n      new DataFabricModules(cConf, hConf).getDistributedModules(),\n      new KafkaMetricsProcessorModule()\n     );\n  }","commit_id":"5c3642d7552096321a4c57f2890b1d90589ff8c4","url":"https://github.com/caskdata/cdap"},{"original_method":"public boolean launch() {\n    Collection<LanguageAccess> _values = this.languages.values();\n    final Function1<LanguageAccess, Boolean> _function = new Function1<LanguageAccess, Boolean>() {\n      @Override\n      public Boolean apply(final LanguageAccess it) {\n        return Boolean.valueOf(it.isLinksAgainstJava());\n      }\n    };\n    final boolean needsJava = IterableExtensions.<LanguageAccess>exists(_values, _function);\n    boolean _equals = Objects.equal(this.baseDir, null);\n    if (_equals) {\n      String _property = System.getProperty(\"user.dir\");\n      this.baseDir = _property;\n      StandaloneBuilder.LOG.warn(((\"Property baseDir not set. Using \\'\" + this.baseDir) + \"\\'\"));\n    }\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Using common types.\");\n    }\n    final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n    boolean _notEquals = (!Objects.equal(this.encoding, null));\n    if (_notEquals) {\n      this.forceDebugLog(\"Setting encoding.\");\n      Collection<LanguageAccess> _values_1 = this.languages.values();\n      this.fileEncodingSetup(_values_1, this.encoding);\n    }\n    StandaloneBuilder.LOG.info(\"Collecting source models.\");\n    final long startedAt = System.currentTimeMillis();\n    Iterable<String> rootsToTravers = this.classPathEntries;\n    boolean _notEquals_1 = (!Objects.equal(this.classPathLookUpFilter, null));\n    if (_notEquals_1) {\n      StandaloneBuilder.LOG.info(\"Class path look up filter is active.\");\n      final Pattern cpLookUpFilter = Pattern.compile(this.classPathLookUpFilter);\n      final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n        @Override\n        public Boolean apply(final String root) {\n          Matcher _matcher = cpLookUpFilter.matcher(root);\n          return Boolean.valueOf(_matcher.matches());\n        }\n      };\n      Iterable<String> _filter = IterableExtensions.<String>filter(this.classPathEntries, _function_1);\n      rootsToTravers = _filter;\n      final Iterable<String> _converted_rootsToTravers = (Iterable<String>)rootsToTravers;\n      int _length = ((Object[])Conversions.unwrapArray(_converted_rootsToTravers, Object.class)).length;\n      String _plus = (\"Investigating \" + Integer.valueOf(_length));\n      String _plus_1 = (_plus + \" of \");\n      int _length_1 = ((Object[])Conversions.unwrapArray(this.classPathEntries, Object.class)).length;\n      String _plus_2 = (_plus_1 + Integer.valueOf(_length_1));\n      String _plus_3 = (_plus_2 + \" class path entries.\");\n      StandaloneBuilder.LOG.info(_plus_3);\n    }\n    final List<URI> sourceResourceURIs = this.collectResources(this.sourceDirs, resourceSet);\n    List<URI> _collectResources = this.collectResources(rootsToTravers, resourceSet);\n    final Iterable<URI> allResourcesURIs = Iterables.<URI>concat(sourceResourceURIs, _collectResources);\n    long _currentTimeMillis = System.currentTimeMillis();\n    long _minus = (_currentTimeMillis - startedAt);\n    String _plus_4 = (\"Finished collecting source models. Took: \" + Long.valueOf(_minus));\n    String _plus_5 = (_plus_4 + \" ms.\");\n    this.forceDebugLog(_plus_5);\n    final Iterable<String> allClassPathEntries = Iterables.<String>concat(this.sourceDirs, this.classPathEntries);\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Installing type provider.\");\n      this.installTypeProvider(allClassPathEntries, resourceSet, null);\n    }\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals_2 = (!Objects.equal(this.clusteringConfig, null));\n    if (_notEquals_2) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        StandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function_2 = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = StandaloneBuilder.this.clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function_2);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    ArrayList<IResourceDescription> _newArrayList = CollectionLiterals.<IResourceDescription>newArrayList();\n    ResourceDescriptionsData index = new ResourceDescriptionsData(_newArrayList);\n    Iterator<URI> allResourceIterator = allResourcesURIs.iterator();\n    while (allResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((allResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = allResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            this.fillIndex(uri, resource, index);\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    this.installIndex(resourceSet, index);\n    if (needsJava) {\n      File _generateStubs = this.generateStubs(index, sourceResourceURIs);\n      final String stubsClasses = this.compileStubs(_generateStubs);\n      StandaloneBuilder.LOG.info(\"Installing type provider for stubs.\");\n      ArrayList<String> _newArrayList_1 = CollectionLiterals.<String>newArrayList(stubsClasses);\n      Iterable<String> _plus_6 = Iterables.<String>concat(allClassPathEntries, _newArrayList_1);\n      this.installTypeProvider(_plus_6, resourceSet, this.jvmTypeAccess);\n    }\n    StandaloneBuilder.LOG.info(\"Validate and generate.\");\n    final Iterator<URI> sourceResourceIterator = sourceResourceURIs.iterator();\n    boolean isErrorFree = true;\n    while (sourceResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((sourceResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = sourceResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            resource.getContents();\n            EcoreUtil2.resolveLazyCrossReferences(resource, CancelIndicator.NullImpl);\n            boolean _validate = this.validate(resource);\n            isErrorFree = _validate;\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        boolean _and = false;\n        if (!this.failOnValidationError) {\n          _and = false;\n        } else {\n          _and = (!isErrorFree);\n        }\n        if (_and) {\n          return isErrorFree;\n        }\n        this.generate(resources);\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    return isErrorFree;\n  }","id":85845,"modified_method":"/**\n   * @return <code>false<\/code> if some of processed resources contains severe validation issues. <code>true<\/code> otherwise\n   */\n  public boolean launch() {\n    Collection<LanguageAccess> _values = this.languages.values();\n    final Function1<LanguageAccess, Boolean> _function = new Function1<LanguageAccess, Boolean>() {\n      @Override\n      public Boolean apply(final LanguageAccess it) {\n        return Boolean.valueOf(it.isLinksAgainstJava());\n      }\n    };\n    final boolean needsJava = IterableExtensions.<LanguageAccess>exists(_values, _function);\n    boolean _equals = Objects.equal(this.baseDir, null);\n    if (_equals) {\n      String _property = System.getProperty(\"user.dir\");\n      this.baseDir = _property;\n      StandaloneBuilder.LOG.warn(((\"Property baseDir not set. Using \\'\" + this.baseDir) + \"\\'\"));\n    }\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Using common types.\");\n    }\n    final XtextResourceSet resourceSet = this.resourceSetProvider.get();\n    boolean _notEquals = (!Objects.equal(this.encoding, null));\n    if (_notEquals) {\n      this.forceDebugLog(\"Setting encoding.\");\n      Collection<LanguageAccess> _values_1 = this.languages.values();\n      this.fileEncodingSetup(_values_1, this.encoding);\n    }\n    StandaloneBuilder.LOG.info(\"Collecting source models.\");\n    final long startedAt = System.currentTimeMillis();\n    Iterable<String> rootsToTravers = this.classPathEntries;\n    boolean _notEquals_1 = (!Objects.equal(this.classPathLookUpFilter, null));\n    if (_notEquals_1) {\n      StandaloneBuilder.LOG.info(\"Class path look up filter is active.\");\n      final Pattern cpLookUpFilter = Pattern.compile(this.classPathLookUpFilter);\n      final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n        @Override\n        public Boolean apply(final String root) {\n          Matcher _matcher = cpLookUpFilter.matcher(root);\n          return Boolean.valueOf(_matcher.matches());\n        }\n      };\n      Iterable<String> _filter = IterableExtensions.<String>filter(this.classPathEntries, _function_1);\n      rootsToTravers = _filter;\n      final Iterable<String> _converted_rootsToTravers = (Iterable<String>)rootsToTravers;\n      int _length = ((Object[])Conversions.unwrapArray(_converted_rootsToTravers, Object.class)).length;\n      String _plus = (\"Investigating \" + Integer.valueOf(_length));\n      String _plus_1 = (_plus + \" of \");\n      int _length_1 = ((Object[])Conversions.unwrapArray(this.classPathEntries, Object.class)).length;\n      String _plus_2 = (_plus_1 + Integer.valueOf(_length_1));\n      String _plus_3 = (_plus_2 + \" class path entries.\");\n      StandaloneBuilder.LOG.info(_plus_3);\n    }\n    final List<URI> sourceResourceURIs = this.collectResources(this.sourceDirs, resourceSet);\n    List<URI> _collectResources = this.collectResources(rootsToTravers, resourceSet);\n    final Iterable<URI> allResourcesURIs = Iterables.<URI>concat(sourceResourceURIs, _collectResources);\n    long _currentTimeMillis = System.currentTimeMillis();\n    long _minus = (_currentTimeMillis - startedAt);\n    String _plus_4 = (\"Finished collecting source models. Took: \" + Long.valueOf(_minus));\n    String _plus_5 = (_plus_4 + \" ms.\");\n    this.forceDebugLog(_plus_5);\n    final Iterable<String> allClassPathEntries = Iterables.<String>concat(this.sourceDirs, this.classPathEntries);\n    if (needsJava) {\n      StandaloneBuilder.LOG.info(\"Installing type provider.\");\n      this.installTypeProvider(allClassPathEntries, resourceSet, null);\n    }\n    IResourceClusteringPolicy _xifexpression = null;\n    boolean _notEquals_2 = (!Objects.equal(this.clusteringConfig, null));\n    if (_notEquals_2) {\n      DynamicResourceClusteringPolicy _xblockexpression = null;\n      {\n        StandaloneBuilder.LOG.info(\"Clustering configured.\");\n        DynamicResourceClusteringPolicy _dynamicResourceClusteringPolicy = new DynamicResourceClusteringPolicy();\n        final Procedure1<DynamicResourceClusteringPolicy> _function_2 = new Procedure1<DynamicResourceClusteringPolicy>() {\n          @Override\n          public void apply(final DynamicResourceClusteringPolicy it) {\n            long _minimumFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumFreeMemory();\n            long _multiply = (_minimumFreeMemory * 1024);\n            long _multiply_1 = (_multiply * 1024);\n            it.setMinimumFreeMemory(_multiply_1);\n            int _minimumClusterSize = StandaloneBuilder.this.clusteringConfig.getMinimumClusterSize();\n            it.setMinimumClusterSize(_minimumClusterSize);\n            long _minimumPercentFreeMemory = StandaloneBuilder.this.clusteringConfig.getMinimumPercentFreeMemory();\n            it.setMinimumPercentFreeMemory(_minimumPercentFreeMemory);\n          }\n        };\n        _xblockexpression = ObjectExtensions.<DynamicResourceClusteringPolicy>operator_doubleArrow(_dynamicResourceClusteringPolicy, _function_2);\n      }\n      _xifexpression = _xblockexpression;\n    } else {\n      _xifexpression = new DisabledClusteringPolicy();\n    }\n    final IResourceClusteringPolicy strategy = _xifexpression;\n    ArrayList<IResourceDescription> _newArrayList = CollectionLiterals.<IResourceDescription>newArrayList();\n    ResourceDescriptionsData index = new ResourceDescriptionsData(_newArrayList);\n    Iterator<URI> allResourceIterator = allResourcesURIs.iterator();\n    while (allResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((allResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = allResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            this.fillIndex(uri, resource, index);\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not = (!_continueProcessing);\n            if (_not) {\n              continue_ = false;\n            }\n          }\n        }\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    this.installIndex(resourceSet, index);\n    if (needsJava) {\n      File _generateStubs = this.generateStubs(index, sourceResourceURIs);\n      final String stubsClasses = this.compileStubs(_generateStubs);\n      StandaloneBuilder.LOG.info(\"Installing type provider for stubs.\");\n      ArrayList<String> _newArrayList_1 = CollectionLiterals.<String>newArrayList(stubsClasses);\n      Iterable<String> _plus_6 = Iterables.<String>concat(allClassPathEntries, _newArrayList_1);\n      this.installTypeProvider(_plus_6, resourceSet, this.jvmTypeAccess);\n    }\n    StandaloneBuilder.LOG.info(\"Validate and generate.\");\n    final Iterator<URI> sourceResourceIterator = sourceResourceURIs.iterator();\n    boolean hasValidationErrors = false;\n    while (sourceResourceIterator.hasNext()) {\n      {\n        List<Resource> resources = CollectionLiterals.<Resource>newArrayList();\n        int clusterIndex = 0;\n        boolean continue_ = true;\n        while ((sourceResourceIterator.hasNext() && continue_)) {\n          {\n            final URI uri = sourceResourceIterator.next();\n            final Resource resource = resourceSet.getResource(uri, true);\n            resources.add(resource);\n            resource.getContents();\n            EcoreUtil2.resolveLazyCrossReferences(resource, CancelIndicator.NullImpl);\n            boolean _or = false;\n            boolean _validate = this.validate(resource);\n            boolean _not = (!_validate);\n            if (_not) {\n              _or = true;\n            } else {\n              _or = hasValidationErrors;\n            }\n            hasValidationErrors = _or;\n            clusterIndex++;\n            boolean _continueProcessing = strategy.continueProcessing(resourceSet, null, clusterIndex);\n            boolean _not_1 = (!_continueProcessing);\n            if (_not_1) {\n              continue_ = false;\n            }\n          }\n        }\n        boolean _and = false;\n        if (!this.failOnValidationError) {\n          _and = false;\n        } else {\n          _and = hasValidationErrors;\n        }\n        if (_and) {\n          return (!hasValidationErrors);\n        }\n        this.generate(resources);\n        if ((!continue_)) {\n          this.clearResourceSet(resourceSet);\n        }\n      }\n    }\n    return (!hasValidationErrors);\n  }","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void installTypeProvider(final Iterable<String> classPathRoots, final XtextResourceSet resSet, final IndexedJvmTypeAccess typeAccess) {\n    final URLClassLoader classLoader = this.createURLClassLoader(classPathRoots);\n    new ClasspathTypeProvider(classLoader, resSet, typeAccess);\n    resSet.setClasspathURIContext(classLoader);\n  }","id":85846,"modified_method":"protected void installTypeProvider(final Iterable<String> classPathRoots, final XtextResourceSet resSet, final IndexedJvmTypeAccess typeAccess) {\n    final URLClassLoader classLoader = this.createURLClassLoader(classPathRoots);\n    new ClasspathTypeProvider(classLoader, resSet, typeAccess, null);\n    resSet.setClasspathURIContext(classLoader);\n  }","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Injector internalCreateInjector() {\n\t\tnew BuilderTestLanguageStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\treturn Guice.createInjector(new StandaloneBuilderModule());\n\t}","id":85847,"modified_method":"protected Injector internalCreateInjector() {\n\t\tnew BuilderTestLanguageStandaloneSetup().createInjectorAndDoEMFRegistration();\n\t\treturn Guice.createInjector(new StandaloneBuilderModule() {\n\t\t\t@Override\n\t\t\tprotected void configure() {\n\t\t\t\tsuper.configure();\n\t\t\t\tbind(StandaloneBuilder.class).to(bindStandaloneBuilder());\n\t\t\t}\n\n\t\t\tprotected Class<? extends StandaloneBuilder> bindStandaloneBuilder() {\n\t\t\t\treturn TestableStandaloneBuilder.class;\n\t\t\t}\n\n\t\t});\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testRelativeSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tbuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone/src\"));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85848,"modified_method":"@Test\n\tpublic void testRelativeSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\ttestBuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone/src\"));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tbuilder.setWriteStorageResources(true);\n\t\tassertTrue(builder.launch());\n\t\t\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertTrue(generatedFile.exists());\n\t}","id":85849,"modified_method":"@Test\n\tpublic void testWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\ttestBuilder.setWriteStorageResources(true);\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertTrue(generatedFile.exists());\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testJarToPlatformMapping() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tbuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone.with.reference/model\"));\n\t\tbuilder.setClassPathEntries(ImmutableList.of(\"test-data/standalone.with.reference/target/classes/\",\n\t\t\t\t\"test-data/model.in.eclipse.project.jar\"));\n\n\t\tassertTrue(\"Builder launch returned false\", builder.launch());\n\t\tURI uri = EcorePlugin.getPlatformResourceMap().get(\"model.in.eclipse.project\");\n\t\tassertNotNull(\"No platform mapping found for 'model.in.eclipse.project'\", uri);\n\t\tassertTrue(\"Platform mapping is archive\", uri.toString().startsWith(\"archive:file:/\"));\n\t\tassertTrue(\"Platform mapping points to jared project\",\n\t\t\t\turi.toString().endsWith(\"test-data/model.in.eclipse.project.jar!/\"));\n\t}","id":85850,"modified_method":"@Test\n\tpublic void testJarToPlatformMapping() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\ttestBuilder.setSourceDirs(ImmutableList.of(\"test-data/standalone.with.reference/model\"));\n\t\ttestBuilder.setClassPathEntries(ImmutableList.of(\"test-data/standalone.with.reference/target/classes/\",\n\t\t\t\t\"test-data/model.in.eclipse.project.jar\"));\n\n\t\tassertTrue(\"Builder launch returned false\", testBuilder.launch());\n\t\tURI uri = EcorePlugin.getPlatformResourceMap().get(\"model.in.eclipse.project\");\n\t\tassertNotNull(\"No platform mapping found for 'model.in.eclipse.project'\", uri);\n\t\tassertTrue(\"Platform mapping is archive\", uri.toString().startsWith(\"archive:file:/\"));\n\t\tassertTrue(\"Platform mapping points to jared project\",\n\t\t\t\turi.toString().endsWith(\"test-data/model.in.eclipse.project.jar!/\"));\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"private StandaloneBuilder initBuilder(ILanguageConfiguration config) {\n\t\tString sourceDir1 = new File(PROJECT_DIR, \"src\").getAbsolutePath();\n\t\tString sourceDir2 = new File(PROJECT_DIR, \"src2\").getAbsolutePath();\n\t\tbuilder.setSourceDirs(ImmutableList.of(sourceDir1, sourceDir2));\n\t\tMap<String, LanguageAccess> languages = new LanguageAccessFactory().createLanguageAccess(\n\t\t\t\tImmutableList.of(config), getClass().getClassLoader());\n\t\tbuilder.setBaseDir(PROJECT_DIR.getAbsolutePath());\n\t\tbuilder.setLanguages(languages);\n\t\tbuilder.setClassPathEntries(ImmutableList.<String> of());\n\t\treturn builder;\n\t}","id":85851,"modified_method":"private StandaloneBuilder initBuilder(ILanguageConfiguration config) {\n\t\treturn initBuilder(config, \"src\", \"src2\");\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testOnlyOneSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tbuilder.setSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src\").getAbsolutePath()));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85852,"modified_method":"@Test\n\tpublic void testOnlyOneSourceFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\ttestBuilder.setSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src\").getAbsolutePath()));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testDifferentOutputFolders() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85853,"modified_method":"@Test\n\tpublic void testDifferentOutputFolders() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testNoWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\tbuilder.setWriteStorageResources(false);\n\t\tassertTrue(builder.launch());\n\t\t\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertFalse(generatedFile.exists());\n\t}","id":85854,"modified_method":"@Test\n\tpublic void testNoWriteStorageResource() {\n\t\tinitBuilder(new TestLanguageConfiguration(true));\n\t\ttestBuilder.setWriteStorageResources(false);\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/.Foo.buildertestlanguagebin\");\n\t\tassertFalse(generatedFile.exists());\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testDuplicateSourceEntries() {\n\t\tTestLanguageConfiguration config = new TestLanguageConfiguration(false);\n\t\tconfig.setJavaSupport(true);\n\t\tinitBuilder(config);\n\t\tbuilder.setJavaSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src2\").getPath()));\n\t\tbuilder.setTempDir(TMP_DIR);\n\t\tbuilder.setDebugLog(true);\n\t\tassertTrue(\"Builder launch returned false\", builder.launch());\n\t\tFile compiledClazz = getFile(\"tmp/classes/JavaClass.class\");\n\t\tassertTrue(\"java compilation failed\", compiledClazz.exists());\n\n\t}","id":85855,"modified_method":"@Test\n\tpublic void testDuplicateSourceEntries() {\n\t\tTestLanguageConfiguration config = new TestLanguageConfiguration(false);\n\t\tconfig.setJavaSupport(true);\n\t\tinitBuilder(config);\n\t\ttestBuilder.setJavaSourceDirs(ImmutableList.of(new File(PROJECT_DIR, \"src2\").getPath()));\n\t\ttestBuilder.setTempDir(TMP_DIR);\n\t\ttestBuilder.setDebugLog(true);\n\t\tassertTrue(\"Builder launch returned false\", testBuilder.launch());\n\t\tFile compiledClazz = getFile(\"tmp/classes/JavaClass.class\");\n\t\tassertTrue(\"java compilation failed\", compiledClazz.exists());\n\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n\tpublic void testSameOutputFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tassertTrue(builder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","id":85856,"modified_method":"@Test\n\tpublic void testSameOutputFolder() {\n\t\tinitBuilder(new TestLanguageConfiguration(false));\n\t\tassertTrue(testBuilder.launch());\n\n\t\tFile generatedFile = getFile(\"src-gen/Foo.txt\");\n\t\tassertTrue(generatedFile.exists());\n\t\tgeneratedFile = getFile(\"src-gen/Bar.txt\");\n\t\tassertTrue(generatedFile.exists());\n\n\t\tFile unexpectedFile = getFile(\"src2-gen/Bar.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t\tunexpectedFile = getFile(\"src2-gen/Foo.txt\");\n\t\tassertFalse(unexpectedFile.exists());\n\t}","commit_id":"ddd633f61f169bd4d38ea066e09947eab341d2d7","url":"https://github.com/eclipse/xtext"},{"original_method":"public InboundHandler(ClientBootstrap clientBootstrap, final ServiceLookup serviceLookup) {\n    this.clientBootstrap = clientBootstrap;\n    this.serviceLookup = serviceLookup;\n  }","id":85857,"modified_method":"public InboundHandler(ClientBootstrap clientBootstrap, final RouterServiceLookup serviceLookup) {\n    this.clientBootstrap = clientBootstrap;\n    this.serviceLookup = serviceLookup;\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"public ServiceLookup getServiceLookup() {\n    return serviceLookup;\n  }","id":85858,"modified_method":"public RouterServiceLookup getServiceLookup() {\n    return serviceLookup;\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setStrings(Constants.Router.FORWARD, forwards.toArray(new String[forwards.size()]));\n      router = new NettyRouter(cConf, InetAddresses.forString(hostname),\n                               new RouterServiceLookup((DiscoveryServiceClient) discoveryService,\n                                                       new Provider<Iterable<WeaveRunner.LiveInfo>>() {\n                                                         @Override\n                                                         public Iterable<WeaveRunner.LiveInfo> get() {\n                                                           return ImmutableSet.of();\n                                                         }\n                                                       }\n                               ));\n      router.startAndWait();\n\n      for (Map.Entry<Integer, String> entry : router.getServiceLookup().getServiceMap().entrySet()) {\n        serviceMap.put(entry.getValue(), entry.getKey());\n      }\n    }","id":85859,"modified_method":"@Override\n    protected void before() throws Throwable {\n      CConfiguration cConf = CConfiguration.create();\n      cConf.set(Constants.Router.ADDRESS, hostname);\n      cConf.setStrings(Constants.Router.FORWARD, forwards.toArray(new String[forwards.size()]));\n      router =\n        new NettyRouter(cConf, InetAddresses.forString(hostname),\n                        new RouterServiceLookup((DiscoveryServiceClient) discoveryService, new DiscoveryNameFinder() {\n                          @Override\n                          public String findDiscoveryServiceName(Type type, String name) {\n                            return name;\n                          }\n                        }\n                        ));\n      router.startAndWait();\n\n      for (Map.Entry<Integer, String> entry : router.getServiceLookup().getServiceMap().entrySet()) {\n        serviceMap.put(entry.getValue(), entry.getKey());\n      }\n    }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"static Injector createGuiceInjector(CConfiguration cConf, ZKClientService zkClientService) {\n    return Guice.createInjector(\n      new ConfigModule(cConf),\n      new LocationRuntimeModule().getDistributedModules(),\n      new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n          bind(WeaveRunnerService.class).to(YarnWeaveRunnerService.class);\n          bind(new TypeLiteral<Iterable<WeaveRunner.LiveInfo>>() {}).toProvider(WeaveLiveInfoProvider.class);\n        }\n\n        @Provides\n        @Named(Constants.Router.ADDRESS)\n        public final InetAddress providesHostname(CConfiguration cConf) {\n          return Networks.resolve(cConf.get(Constants.Router.ADDRESS),\n                                  new InetSocketAddress(\"localhost\", 0).getAddress());\n        }\n\n        @Singleton\n        @Provides\n        private YarnWeaveRunnerService provideYarnWeaveRunnerService(CConfiguration configuration,\n                                                                     YarnConfiguration yarnConfiguration,\n                                                                     LocationFactory locationFactory) {\n          String zkNamespace = configuration.get(Constants.CFG_WEAVE_ZK_NAMESPACE, \"/weave\");\n          return new YarnWeaveRunnerService(yarnConfiguration,\n                                            configuration.get(Constants.Zookeeper.QUORUM) + zkNamespace,\n                                            LocationFactories.namespace(locationFactory, \"weave\"));\n        }\n      }\n    );\n  }","id":85860,"modified_method":"static Injector createGuiceInjector(CConfiguration cConf, ZKClientService zkClientService) {\n    return Guice.createInjector(\n      new ConfigModule(cConf),\n      new LocationRuntimeModule().getDistributedModules(),\n      new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n      new RouterModules().getDistributedModules()\n    );\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Map<Integer, String> getServiceMap() {\n    return ImmutableMap.copyOf(serviceMapRef.get());\n  }","id":85861,"modified_method":"/**\n     * @return the port to service name map for all services.\n     */\n  public Map<Integer, String> getServiceMap() {\n    return ImmutableMap.copyOf(serviceMapRef.get());\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Discoverable getDiscoverable(int port, Supplier<String> hostHeaderSupplier) throws Exception {\n    String service = serviceMapRef.get().get(port);\n    if (service == null) {\n      LOG.debug(\"No service found for port {}\", port);\n      return null;\n    }\n\n    String host;\n    if (service.contains(\"$HOST\")) {\n      host = hostHeaderSupplier.get();\n      if (host == null) {\n        LOG.debug(\"Cannot find host header for service {} on port {}\", service, port);\n        return null;\n      }\n      host = Networks.normalizeHost(host);\n      service = service.replace(\"$HOST\", host);\n    }\n\n    Discoverable discoverable = discoverableCache.get(service).pick();\n    if (discoverable == null) {\n      // Another app may have replaced as the server to serve $HOST\n      LOG.debug(\"Refreshing cache for service {}\", service);\n      discoverableCache.refresh(service);\n\n      // Try again\n      discoverable = discoverableCache.get(service).pick();\n      if (discoverable == null) {\n        LOG.warn(\"No discoverable endpoints found for service {}\", service);\n      }\n    }\n\n    return discoverable;\n  }","id":85862,"modified_method":"/**\n     * Returns the discoverable mapped to the given port.\n     *\n     * @param port port to lookup.\n     * @param hostHeaderSupplier supplies the Host header for the lookup.\n     * @return discoverable based on port and host header.\n     */\n  public Discoverable getDiscoverable(int port, Supplier<String> hostHeaderSupplier) throws Exception {\n    String service = serviceMapRef.get().get(port);\n    if (service == null) {\n      LOG.debug(\"No service found for port {}\", port);\n      return null;\n    }\n\n    String host;\n    if (service.contains(\"$HOST\")) {\n      host = hostHeaderSupplier.get();\n      if (host == null) {\n        LOG.debug(\"Cannot find host header for service {} on port {}\", service, port);\n        return null;\n      }\n      host = Networks.normalizeHost(host);\n      service = service.replace(\"$HOST\", host);\n    }\n\n    Discoverable discoverable = discoverableCache.get(service).pick();\n    if (discoverable == null) {\n      // Another app may have replaced as the server to serve $HOST\n      LOG.debug(\"Refreshing cache for service {}\", service);\n      discoverableCache.refresh(service);\n\n      // Try again\n      discoverable = discoverableCache.get(service).pick();\n      if (discoverable == null) {\n        LOG.warn(\"No discoverable endpoints found for service {}\", service);\n      }\n    }\n\n    return discoverable;\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String getService(int port) {\n    return serviceMapRef.get().get(port);\n  }","id":85863,"modified_method":"/**\n     * Lookup service name given port.\n     *\n     * @param port port to lookup.\n     * @return service name based on port.\n     */\n  public String getService(int port) {\n    return serviceMapRef.get().get(port);\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public RouterServiceLookup(final DiscoveryServiceClient discoveryServiceClient,\n                             final Provider<Iterable<WeaveRunner.LiveInfo>> liveAppsProvider) {\n\n    this.discoverableCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .build(new CacheLoader<String, EndpointStrategy>() {\n        @Override\n        public EndpointStrategy load(String serviceName) throws Exception {\n          // Find the accountId and appId for the service name.\n          for (WeaveRunner.LiveInfo liveInfo : liveAppsProvider.get()) {\n            String appName = liveInfo.getApplicationName();\n            LOG.debug(\"Got application name {}\", appName);\n\n            if (appName.endsWith(\".\" + serviceName)) {\n              String [] splits = Iterables.toArray(Splitter.on('.').split(appName), String.class);\n              if (splits.length > 3) {\n                serviceName = String.format(\"webapp.%s.%s.%s\", splits[1], splits[2], serviceName);\n                break;\n              }\n            }\n          }\n\n          LOG.debug(\"Looking up service name {}\", serviceName);\n          return new RandomEndpointStrategy(discoveryServiceClient.discover(serviceName));\n        }\n      });\n  }","id":85864,"modified_method":"@Inject\n  public RouterServiceLookup(final DiscoveryServiceClient discoveryServiceClient,\n                             final DiscoveryNameFinder discoveryNameFinder) {\n\n    this.discoverableCache = CacheBuilder.newBuilder()\n      .expireAfterAccess(1, TimeUnit.HOURS)\n      .build(new CacheLoader<String, EndpointStrategy>() {\n        @Override\n        public EndpointStrategy load(String serviceName) throws Exception {\n          serviceName = discoveryNameFinder.findDiscoveryServiceName(Type.WEBAPP, serviceName);\n          LOG.debug(\"Looking up service name {}\", serviceName);\n          return new RandomEndpointStrategy(discoveryServiceClient.discover(serviceName));\n        }\n      });\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"private static List<Module> createPersistentModules(CConfiguration configuration, Configuration hConf) {\n    configuration.setIfUnset(Constants.CFG_DATA_LEVELDB_DIR, Constants.DEFAULT_DATA_LEVELDB_DIR);\n\n    String environment =\n      configuration.get(Constants.CFG_APPFABRIC_ENVIRONMENT, Constants.DEFAULT_APPFABRIC_ENVIRONMENT);\n    if (environment.equals(\"vpc\")) {\n      System.err.println(\"Reactor Environment : \" + environment);\n    }\n\n    configuration.set(Constants.CFG_DATA_INMEMORY_PERSISTENCE, Constants.InMemoryPersistenceType.LEVELDB.name());\n    configuration.setBoolean(Constants.CFG_DATA_LEVELDB_ENABLED, true);\n\n    return ImmutableList.of(\n      new ConfigModule(configuration, hConf),\n      new IOModule(),\n      new DiscoveryRuntimeModule().getSingleNodeModules(),\n      new LocationRuntimeModule().getSingleNodeModules(),\n      new AppFabricServiceRuntimeModule().getSingleNodeModules(),\n      new ProgramRunnerRuntimeModule().getSingleNodeModules(),\n      new GatewayModules().getSingleNodeModules(),\n      new DataFabricModules().getSingleNodeModules(configuration),\n      new MetricsClientRuntimeModule().getSingleNodeModules(),\n      new LoggingModules().getSingleNodeModules()\n    );\n  }","id":85865,"modified_method":"private static List<Module> createPersistentModules(CConfiguration configuration, Configuration hConf) {\n    configuration.setIfUnset(Constants.CFG_DATA_LEVELDB_DIR, Constants.DEFAULT_DATA_LEVELDB_DIR);\n\n    String environment =\n      configuration.get(Constants.CFG_APPFABRIC_ENVIRONMENT, Constants.DEFAULT_APPFABRIC_ENVIRONMENT);\n    if (environment.equals(\"vpc\")) {\n      System.err.println(\"Reactor Environment : \" + environment);\n    }\n\n    configuration.set(Constants.CFG_DATA_INMEMORY_PERSISTENCE, Constants.InMemoryPersistenceType.LEVELDB.name());\n    configuration.setBoolean(Constants.CFG_DATA_LEVELDB_ENABLED, true);\n\n    return ImmutableList.of(\n      new ConfigModule(configuration, hConf),\n      new IOModule(),\n      new DiscoveryRuntimeModule().getSingleNodeModules(),\n      new LocationRuntimeModule().getSingleNodeModules(),\n      new AppFabricServiceRuntimeModule().getSingleNodeModules(),\n      new ProgramRunnerRuntimeModule().getSingleNodeModules(),\n      new GatewayModules().getSingleNodeModules(),\n      new DataFabricModules().getSingleNodeModules(configuration),\n      new MetricsClientRuntimeModule().getSingleNodeModules(),\n      new LoggingModules().getSingleNodeModules(),\n      new RouterModules().getSingleNodeModules()\n    );\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Shutdown the service.\n   */\n  public void shutDown() {\n    try {\n      webCloudAppService.stopAndWait();\n      flumeCollector.stopAndWait();\n      gatewayV2.stopAndWait();\n      appFabricServer.stopAndWait();\n      transactionManager.stopAndWait();\n      zookeeper.stopAndWait();\n    } catch (Exception e) {\n      LOG.error(e.getMessage(), e);\n    }\n  }","id":85866,"modified_method":"/**\n   * Shutdown the service.\n   */\n  public void shutDown() {\n    try {\n      webCloudAppService.stopAndWait();\n      flumeCollector.stopAndWait();\n      router.stopAndWait();\n      gatewayV2.stopAndWait();\n      appFabricServer.stopAndWait();\n      transactionManager.stopAndWait();\n      zookeeper.stopAndWait();\n    } catch (Exception e) {\n      LOG.error(e.getMessage(), e);\n    }\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"private static List<Module> createInMemoryModules(CConfiguration configuration, Configuration hConf) {\n\n    configuration.set(Constants.CFG_DATA_INMEMORY_PERSISTENCE, Constants.InMemoryPersistenceType.MEMORY.name());\n\n    return ImmutableList.of(\n      new ConfigModule(configuration, hConf),\n      new IOModule(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new AppFabricServiceRuntimeModule().getInMemoryModules(),\n      new ProgramRunnerRuntimeModule().getInMemoryModules(),\n      new GatewayModules().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new MetricsClientRuntimeModule().getInMemoryModules(),\n      new LoggingModules().getInMemoryModules()\n    );\n  }","id":85867,"modified_method":"private static List<Module> createInMemoryModules(CConfiguration configuration, Configuration hConf) {\n\n    configuration.set(Constants.CFG_DATA_INMEMORY_PERSISTENCE, Constants.InMemoryPersistenceType.MEMORY.name());\n\n    return ImmutableList.of(\n      new ConfigModule(configuration, hConf),\n      new IOModule(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new AppFabricServiceRuntimeModule().getInMemoryModules(),\n      new ProgramRunnerRuntimeModule().getInMemoryModules(),\n      new GatewayModules().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new MetricsClientRuntimeModule().getInMemoryModules(),\n      new LoggingModules().getInMemoryModules(),\n      new RouterModules().getInMemoryModules()\n    );\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"public SingleNodeMain(List<Module> modules, CConfiguration configuration, String webAppPath) {\n    this.configuration = configuration;\n    this.webCloudAppService = new WebCloudAppService(webAppPath);\n\n    Injector injector = Guice.createInjector(modules);\n    transactionManager = injector.getInstance(InMemoryTransactionManager.class);\n    gatewayV2 = injector.getInstance(Gateway.class);\n    flumeCollector = injector.getInstance(NettyFlumeCollector.class);\n    appFabricServer = injector.getInstance(AppFabricServer.class);\n    logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        webCloudAppService.stopAndWait();\n        try {\n          transactionManager.stopAndWait();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to shutdown transaction manager.\", e);\n          // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n          System.err.println(\"Failed to shutdown transaction manager: \" + e.getMessage());\n          e.printStackTrace(System.err);\n        }\n      }\n    });\n  }","id":85868,"modified_method":"public SingleNodeMain(List<Module> modules, CConfiguration configuration, String webAppPath) {\n    this.configuration = configuration;\n    this.webCloudAppService = new WebCloudAppService(webAppPath);\n\n    Injector injector = Guice.createInjector(modules);\n    transactionManager = injector.getInstance(InMemoryTransactionManager.class);\n    router = injector.getInstance(NettyRouter.class);\n    gatewayV2 = injector.getInstance(Gateway.class);\n    flumeCollector = injector.getInstance(NettyFlumeCollector.class);\n    appFabricServer = injector.getInstance(AppFabricServer.class);\n    logAppenderInitializer = injector.getInstance(LogAppenderInitializer.class);\n\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n      @Override\n      public void run() {\n        webCloudAppService.stopAndWait();\n        try {\n          transactionManager.stopAndWait();\n        } catch (Throwable e) {\n          LOG.error(\"Failed to shutdown transaction manager.\", e);\n          // because shutdown hooks execute concurrently, the logger may be closed already: thus also print it.\n          System.err.println(\"Failed to shutdown transaction manager: \" + e.getMessage());\n          e.printStackTrace(System.err);\n        }\n      }\n    });\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Start the service.\n   */\n  protected void startUp(String[] args) throws Exception {\n    logAppenderInitializer.initialize();\n\n    File zkDir = new File(configuration.get(Constants.CFG_LOCAL_DATA_DIR) + \"/zookeeper\");\n    //noinspection ResultOfMethodCallIgnored\n    zkDir.mkdir();\n    zookeeper = InMemoryZKServer.builder().setDataDir(zkDir).build();\n    zookeeper.startAndWait();\n\n    configuration.set(Constants.Zookeeper.QUORUM, zookeeper.getConnectionStr());\n\n    // Start all the services.\n    transactionManager.startAndWait();\n    metricsCollectionService.startAndWait();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric.\");\n    }\n\n    gatewayV2.startAndWait();\n    flumeCollector.startAndWait();\n    webCloudAppService.startAndWait();\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    System.out.println(\"Continuuity Reactor (tm) started successfully\");\n    System.out.println(\"Connect to dashboard at http://\" + hostname + \":9999\");\n  }","id":85869,"modified_method":"/**\n   * Start the service.\n   */\n  protected void startUp(String[] args) throws Exception {\n    logAppenderInitializer.initialize();\n\n    File zkDir = new File(configuration.get(Constants.CFG_LOCAL_DATA_DIR) + \"/zookeeper\");\n    //noinspection ResultOfMethodCallIgnored\n    zkDir.mkdir();\n    zookeeper = InMemoryZKServer.builder().setDataDir(zkDir).build();\n    zookeeper.startAndWait();\n\n    configuration.set(Constants.Zookeeper.QUORUM, zookeeper.getConnectionStr());\n\n    // Start all the services.\n    transactionManager.startAndWait();\n    metricsCollectionService.startAndWait();\n\n    Service.State state = appFabricServer.startAndWait();\n    if (state != Service.State.RUNNING) {\n      throw new Exception(\"Failed to start Application Fabric.\");\n    }\n\n    gatewayV2.startAndWait();\n    router.startAndWait();\n    flumeCollector.startAndWait();\n    webCloudAppService.startAndWait();\n\n    String hostname = InetAddress.getLocalHost().getHostName();\n    System.out.println(\"Continuuity Reactor (tm) started successfully\");\n    System.out.println(\"Connect to dashboard at http://\" + hostname + \":9999\");\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * The root of all goodness!\n   *\n   * @param args Our cmdline arguments\n   */\n  public static void main(String[] args) {\n    CConfiguration configuration = CConfiguration.create();\n\n    // Single node use persistent data fabric by default\n    boolean inMemory = false;\n    String webAppPath = WebCloudAppService.WEB_APP;\n\n    if (args.length > 0) {\n      if (\"--help\".equals(args[0]) || \"-h\".equals(args[0])) {\n        usage(false);\n        return;\n      } else if (\"--in-memory\".equals(args[0])) {\n        inMemory = true;\n      } else if (\"--leveldb-disable\".equals(args[0])) {\n        // this option overrides a setting that tells if level db can be used for persistence\n        configuration.setBoolean(Constants.CFG_DATA_LEVELDB_ENABLED, false);\n      } else if (\"--web-app-path\".equals(args[0])) {\n        webAppPath = args[1];\n      } else {\n        usage(true);\n      }\n    }\n\n\n    // This is needed to use LocalJobRunner with fixes (we have it in app-fabric).\n    // For the modified local job runner\n    Configuration hConf = new Configuration();\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n\n    List<Module> modules = inMemory ? createInMemoryModules(configuration, hConf)\n                                    : createPersistentModules(configuration, hConf);\n\n    SingleNodeMain main = new SingleNodeMain(modules, configuration, webAppPath);\n    try {\n      main.startUp(args);\n    } catch (Exception e) {\n      System.err.println(\"Failed to start server. \" + e.getMessage());\n      LOG.error(\"Failed to start server\", e);\n      main.shutDown();\n      System.exit(-2);\n    }\n  }","id":85870,"modified_method":"/**\n   * The root of all goodness!\n   *\n   * @param args Our cmdline arguments\n   */\n  public static void main(String[] args) {\n    CConfiguration configuration = CConfiguration.create();\n\n    // Single node use persistent data fabric by default\n    boolean inMemory = false;\n    String webAppPath = WebCloudAppService.WEB_APP;\n\n    if (args.length > 0) {\n      if (\"--help\".equals(args[0]) || \"-h\".equals(args[0])) {\n        usage(false);\n        return;\n      } else if (\"--in-memory\".equals(args[0])) {\n        inMemory = true;\n      } else if (\"--leveldb-disable\".equals(args[0])) {\n        // this option overrides a setting that tells if level db can be used for persistence\n        configuration.setBoolean(Constants.CFG_DATA_LEVELDB_ENABLED, false);\n      } else if (\"--web-app-path\".equals(args[0])) {\n        webAppPath = args[1];\n      } else {\n        usage(true);\n      }\n    }\n\n\n    // This is needed to use LocalJobRunner with fixes (we have it in app-fabric).\n    // For the modified local job runner\n    Configuration hConf = new Configuration();\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n\n    //Run gateway on random port and forward using router.\n    configuration.setInt(Constants.Gateway.PORT, 0);\n\n    List<Module> modules = inMemory ? createInMemoryModules(configuration, hConf)\n                                    : createPersistentModules(configuration, hConf);\n\n    SingleNodeMain main = new SingleNodeMain(modules, configuration, webAppPath);\n    try {\n      main.startUp(args);\n    } catch (Exception e) {\n      System.err.println(\"Failed to start server. \" + e.getMessage());\n      LOG.error(\"Failed to start server\", e);\n      main.shutDown();\n      System.exit(-2);\n    }\n  }","commit_id":"76ca5aca52f0609431ade705b54fca95a889c438","url":"https://github.com/caskdata/cdap"},{"original_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n\t\tDeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\t\tLOG.info(\"Processing DeleteStorageVolume request for volume \" + volumeId);\n\t\t\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo();\n\t\tvolumeInfo.setVolumeId(volumeId);\n\t\tList<VolumeInfo> volumeList = db.query(volumeInfo);\n\n\t\treply.set_return(Boolean.FALSE);\n\t\tif(volumeList.size() > 0) {\n\t\t\tVolumeInfo foundVolume = volumeList.get(0);\n\t\t\t//check its status\n\t\t\tString status = foundVolume.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || \n\t\t\t\t\tstatus.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\tfoundVolume.setStatus(StorageProperties.Status.deleting.toString());\n\t\t\t\treply.set_return(Boolean.TRUE);\n\t\t\t}\n\t\t} \n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":85871,"modified_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n\t\tDeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\t\tLOG.info(\"Processing DeleteStorageVolume request for volume \" + volumeId);\n\t\t\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo();\n\t\tvolumeInfo.setVolumeId(volumeId);\n\t\tList<VolumeInfo> volumeList = db.query(volumeInfo);\n\n\t\tif(volumeList.size() > 0) {\n\t\t\tVolumeInfo foundVolume = volumeList.get(0);\n\t\t\t//check its status\n\t\t\tString status = foundVolume.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || \n\t\t\t\t\tstatus.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\tfoundVolume.setStatus(StorageProperties.Status.deleting.toString());\n\t\t\t}\n\t\t} \n\t\tdb.commit();\n\t\t// Always set the response element to true as multiple delete requests may be received here. Its okay to allow multiple delete requests when\n\t\t// 1. Volume to be deleted does not exist, it might have already been deleted.\n\t\t// 2. Volume to be deleted is already marked for deletion\n\t\treply.set_return(Boolean.TRUE);\n\t\treturn reply;\n\t}","commit_id":"22a33368190b82a393ba4b63ba943329d239f819","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n\t\tDeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo();\n\t\tvolumeInfo.setVolumeId(volumeId);\n\t\tList<VolumeInfo> volumeList = db.query(volumeInfo);\n\n\t\treply.set_return(Boolean.FALSE);\n\t\tif(volumeList.size() > 0) {\n\t\t\tVolumeInfo foundVolume = volumeList.get(0);\n\t\t\t//check its status\n\t\t\tString status = foundVolume.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\tVolumeDeleter volumeDeleter = new VolumeDeleter(volumeId);\n\t\t\t\tvolumeService.add(volumeDeleter);\n\t\t\t\treply.set_return(Boolean.TRUE);\n\t\t\t}\n\t\t} \n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":85872,"modified_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n\t\tDeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo();\n\t\tvolumeInfo.setVolumeId(volumeId);\n\t\tList<VolumeInfo> volumeList = db.query(volumeInfo);\n\n\t\t//always return true. \n\t\treply.set_return(Boolean.TRUE);\n\t\tif(volumeList.size() > 0) {\n\t\t\tVolumeInfo foundVolume = volumeList.get(0);\n\t\t\t//check its status\n\t\t\tString status = foundVolume.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\tVolumeDeleter volumeDeleter = new VolumeDeleter(volumeId);\n\t\t\t\tvolumeService.add(volumeDeleter);\n\t\t\t} \n\t\t} \n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3a4e57a149c8610035879cdfb9c7e3fd6afe89c5","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void deleteRecording(Recording r) {\n\t\trecordings.unregisterObject(r.lat, r.lon, r);\n\t\trecordingByFileName.remove(r.file.getName());\n\t\tAlgorithms.removeAllFiles(r.file);\n\t\tactivity.getMapLayers().getContextMenuLayer().setLocation(null, \"\");\n\t\tactivity.getMapView().refreshMap();\n\t}","id":85873,"modified_method":"public void deleteRecording(Recording r) {\n\t\trecordings.unregisterObject(r.lat, r.lon, r);\n\t\trecordingByFileName.remove(r.file.getName());\n\t\tAlgorithms.removeAllFiles(r.file);\n\t\tif (activity != null) {\n\t\t\tactivity.getMapLayers().getContextMenuLayer().setLocation(null, \"\");\n\t\t\tactivity.getMapView().refreshMap();\n\t\t}\n\t}","commit_id":"83af9ac05205319561875327cf28cc0b1c002f27","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\tsetContentView(R.layout.audio_video_notes_all);\n\n\t\tColorDrawable color = new ColorDrawable(getResources().getColor(R.color.actionbar_color));\n\t\tActionBar actionBar = getSupportActionBar();\n\t\tactionBar.setTitle(R.string.audionotes_plugin_name);\n\t\tactionBar.setBackgroundDrawable(color);\n\t\tactionBar.setIcon(android.R.color.transparent);\n\t\tactionBar.setHomeButtonEnabled(true);\n\t\tactionBar.setDisplayHomeAsUpEnabled(true);\n\t}","id":85874,"modified_method":"@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\titems = new ArrayList<AudioVideoNotesPlugin.Recording>(plugin.getAllRecordings());\n\t\tlistAdapter = new NotesAdapter(items);\n\t\tsetListAdapter(listAdapter);\n\t}","commit_id":"83af9ac05205319561875327cf28cc0b1c002f27","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setupNotes() {\n\t\tView mainView = getView();\n\t\tif (mainView == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (plugin == null){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\n\t\tList<AudioVideoNotesPlugin.Recording> notes = new ArrayList<AudioVideoNotesPlugin.Recording>(plugin.getAllRecordings());\n\t\tif (notes.size() == 0){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout notesLayout = (LinearLayout) mainView.findViewById(R.id.notes);\n\t\tnotesLayout.removeAllViews();\n\t\tif (notes.size() > 3 && !allNotes){\n\t\t\twhile (notes.size() != 3){\n\t\t\t\tnotes.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tfor (final AudioVideoNotesPlugin.Recording recording : notes){\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_note_item, null, false);\n\n\t\t\tif (recording.name != null){\n\t\t\t\t((TextView) view.findViewById(R.id.name)).setText(recording.name);\n\t\t\t\t((TextView) view.findViewById(R.id.descr)).setText(recording.getDescription(getActivity()));\n\t\t\t} else {\n\t\t\t\t((TextView) view.findViewById(R.id.name)).setText(recording.getDescription(getActivity()));\n\t\t\t\tview.findViewById(R.id.descr).setVisibility(View.GONE);\n\t\t\t}\n\n\t\t\tImageView icon = (ImageView) view.findViewById(R.id.icon);\n\t\t\tif (recording.isAudio()){\n\t\t\t\ticon.setImageResource(R.drawable.ic_type_audio);\n\t\t\t} else if (recording.isVideo()){\n\t\t\t\ticon.setImageResource(R.drawable.ic_type_video);\n\t\t\t} else {\n\t\t\t\ticon.setImageResource(R.drawable.ic_type_img);\n\t\t\t}\n\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tgetMyApplication().getSettings().setMapLocationToShow(recording.getLatitude(), recording.getLongitude(), 15, null,\n\t\t\t\t\t\t\trecording.name != null ? recording.name : recording.getDescription(getActivity()),\n\t\t\t\t\t\t\trecording); //$NON-NLS-1$\n\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(getActivity());\n\t\t\t\t}\n\t\t\t});\n\t\t\tview.findViewById(R.id.play).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tplugin.playRecording(getActivity(), recording);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t//int height = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, getResources().getDisplayMetrics());\n\n\t\t\t//LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, height);\n\t\t\t//view.setLayoutParams(lp);\n\t\t\tnotesLayout.addView(view);\n\t\t}\n\t}","id":85875,"modified_method":"public void setupNotes() {\n\t\tView mainView = getView();\n\t\tif (mainView == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (plugin == null){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\n\t\tList<AudioVideoNotesPlugin.Recording> notes = new ArrayList<AudioVideoNotesPlugin.Recording>(plugin.getAllRecordings());\n\t\tif (notes.size() == 0){\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t}\n\n\t\tLinearLayout notesLayout = (LinearLayout) mainView.findViewById(R.id.notes);\n\t\tnotesLayout.removeAllViews();\n\t\tif (notes.size() > 3){\n\t\t\twhile (notes.size() != 3){\n\t\t\t\tnotes.remove(3);\n\t\t\t}\n\t\t}\n\n\t\tfor (final AudioVideoNotesPlugin.Recording recording : notes){\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_note_item, null, false);\n\n\t\t\tgetNoteView(recording, view, getActivity(), plugin);\n\t\t\tview.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tgetMyApplication().getSettings().setMapLocationToShow(recording.getLatitude(), recording.getLongitude(), 15, null,\n\t\t\t\t\t\t\trecording.name != null ? recording.name : recording.getDescription(getActivity()),\n\t\t\t\t\t\t\trecording); //$NON-NLS-1$\n\t\t\t\t\tMapActivity.launchMapActivityMoveToTop(getActivity());\n\t\t\t\t}\n\t\t\t});\n\t\t\tnotesLayout.addView(view);\n\t\t}\n\t}","commit_id":"83af9ac05205319561875327cf28cc0b1c002f27","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n\t\tplugin = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_audio_video_notes_plugin, container, false);\n\t\tallNotes = getActivity() instanceof DashAudioVideoNotesActivity;\n\t\tif (allNotes) {\n\t\t\tview.findViewById(R.id.header_layout).setVisibility(View.GONE);\n\t\t} else {\n\t\t\tTypeface typeface = FontCache.getRobotoMedium(getActivity());\n\t\t\t((TextView) view.findViewById(R.id.notes_text)).setTypeface(typeface);\n\t\t\t((Button) view.findViewById(R.id.show_all)).setTypeface(typeface);\n\n\t\t\t(view.findViewById(R.id.show_all)).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View view) {\n\t\t\t\t\tActivity activity = getActivity();\n\t\t\t\t\tfinal Intent favorites = new Intent(activity, DashAudioVideoNotesActivity.class);\n\t\t\t\t\tfavorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\t\tactivity.startActivity(favorites);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn view;\n\t}","id":85876,"modified_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n\t\tplugin = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_audio_video_notes_plugin, container, false);\n\t\tTypeface typeface = FontCache.getRobotoMedium(getActivity());\n\t\t((TextView) view.findViewById(R.id.notes_text)).setTypeface(typeface);\n\t\t((Button) view.findViewById(R.id.show_all)).setTypeface(typeface);\n\n\t\t(view.findViewById(R.id.show_all)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tActivity activity = getActivity();\n\t\t\t\tfinal Intent favorites = new Intent(activity, DashAudioVideoNotesActivity.class);\n\t\t\t\tfavorites.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);\n\t\t\t\tactivity.startActivity(favorites);\n\t\t\t}\n\t\t});\n\t\treturn view;\n\t}","commit_id":"83af9ac05205319561875327cf28cc0b1c002f27","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void collectObjectsFromPoint(PointF point, List<Object> o) {\n\t}","id":85877,"modified_method":"@Override\n\tpublic void collectObjectsFromPoint(PointF point, List<Object> o) {\n\t\tgetParkingFromPoint(point, o);\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String getObjectName(Object o) {\n\t\treturn map.getString(R.string.osmand_parking_position_name);\n\t}","id":85878,"modified_method":"@Override\n\tpublic String getObjectName(Object o) {\n\t\treturn view.getContext().getString(R.string.osmand_parking_position_name);\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public boolean isLocationVisible(double latitude, double longitude){\n\t\tif(parkingPoint == null || view == null){\n\t\t\treturn false;\n\t\t}\n\t\treturn view.isPointOnTheRotatedMap(latitude, longitude);\n\t}","id":85879,"modified_method":"/**\n\t * @param latitude\n\t * @param longitude\n\t * @return true if the parking point is located on a visible part of map\n\t */\n\tprivate boolean isLocationVisible(double latitude, double longitude){\n\t\tif(parkingPoint == null || view == null){\n\t\t\treturn false;\n\t\t}\n\t\treturn view.isPointOnTheRotatedMap(latitude, longitude);\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String getObjectDescription(Object o) {\t\t\n\t\treturn \"tra-ta-ta\";\n\t}","id":85880,"modified_method":"@Override\n\tpublic String getObjectDescription(Object o) {\t\t\n\t\treturn view.getContext().getString(R.string.osmand_parking_position_description);\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onLongPressEvent(PointF point) {\n\t\tif (isParkingPointPressed(point)) {\n\t\t\tBuilder confirm = new AlertDialog.Builder(map);\n\t\t\tconfirm.setPositiveButton(R.string.default_buttons_yes,\n\t\t\t\t\tnew DialogInterface.OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\tsettings.clearParkingPosition();\n\t\t\t\t\t\t\trefreshMap();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\tconfirm.setCancelable(true);\n\t\t\tconfirm.setNegativeButton(R.string.default_buttons_cancel, null);\n\t\t\tconfirm.setMessage(\"Do you want to remove the parking position?\");\n\t\t\tconfirm.show();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":85881,"modified_method":"@Override\n\tpublic boolean onLongPressEvent(PointF point) {\n\t\treturn false;\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onSingleTap(PointF point) {\n\t\tif(isParkingPointPressed(point)){\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tres.append(view.getContext().getString(R.string.osmand_parking_position_toast));\n\t\t\tAccessibleToast.makeText(view.getContext(), res.toString(), Toast.LENGTH_LONG).show();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":85882,"modified_method":"@Override\n\tpublic boolean onSingleTap(PointF point) {\n\t\tList <LatLon> parkPos = new ArrayList<LatLon>();\n\t\tgetParkingFromPoint(point, parkPos);\n\t\tif(!parkPos.isEmpty()){\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tres.append(view.getContext().getString(R.string.osmand_parking_position_description));\n\t\t\tAccessibleToast.makeText(view.getContext(), res.toString(), Toast.LENGTH_LONG).show();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setParkingPoint(LatLon point) {\n\t\tthis.parkingPoint = point;\n\t\trefreshMap();\n\t}","id":85883,"modified_method":"public void setParkingPoint(LatLon point) {\n\t\tthis.parkingPoint = point;\n\t\tif (view != null && view.getLayers().contains(ParkingPositionLayer.this)) {\n\t\t\tview.refreshMap();\n\t\t}\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic LatLon getObjectLocation(Object o) {\n\t\treturn settings.getParkingPosition();\n\t}","id":85884,"modified_method":"@Override\n\tpublic LatLon getObjectLocation(Object o) {\n\t\treturn parkingPoint;\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private TextInfoControl createParkingPlaceInfoControl() {\n\t\tparkingPlaceControl = new TextInfoControl(map, 0, paintText, paintSubText) {\n\t\t\tprivate float[] calculations = new float[1];\n\t\t\tprivate int cachedMeters = 0;\t\t\t\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\tif( parkingPoint != null) {\n\t\t\t\t\tint d = 0;\n\t\t\t\t\tif (map.getRoutingHelper().isRouterEnabled()) {\n\t\t\t\t\t\td = map.getRoutingHelper().getLeftDistance();\n\t\t\t\t\t}\n\t\t\t\t\tif (d == 0) {\n\t\t\t\t\t\tLocation.distanceBetween(view.getLatitude(), view.getLongitude(), parkingPoint.getLatitude(), parkingPoint.getLongitude(), calculations);\n\t\t\t\t\t\td = (int) calculations[0];\n\t\t\t\t\t}\n\t\t\t\t\tif (distChanged(cachedMeters, d)) {\n\t\t\t\t\t\tcachedMeters = d;\n\t\t\t\t\t\tif (cachedMeters <= 20) {\n\t\t\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\t\t\tsetText(null, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString ds = OsmAndFormatter.getFormattedDistance(cachedMeters, map);\n\t\t\t\t\t\t\tint ls = ds.lastIndexOf(' ');\n\t\t\t\t\t\t\tif (ls == -1) {\n\t\t\t\t\t\t\t\tsetText(ds, null);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetText(ds.substring(0, ls), ds.substring(ls + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (cachedMeters != 0) {\n\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\tsetText(null, null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tparkingPlaceControl.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tAnimateDraggingMapThread thread = view.getAnimatedDraggingThread();\n\t\t\t\tLatLon parkingPoint = view.getSettings().getParkingPosition();\n\t\t\t\tif (parkingPoint != null) {\n\t\t\t\t\tint fZoom = view.getZoom() < 15 ? 15 : view.getZoom();\n\t\t\t\t\tthread.startMoving(parkingPoint.getLatitude(), parkingPoint.getLongitude(), fZoom, true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tparkingPlaceControl.setText(null, null);\n\t\tparkingPlaceControl.setImageDrawable(view.getResources().getDrawable(R.drawable.poi_parking_pos_info));\n\t\treturn parkingPlaceControl;\n\t}","id":85885,"modified_method":"/**\n\t * @return the control to be added on a MapInfoLayer \n\t * that shows a distance between \n\t * the current position on the map \n\t * and the location of the parked car\n\t */\n\tprivate TextInfoControl createParkingPlaceInfoControl() {\n\t\tparkingPlaceControl = new TextInfoControl(map, 0, paintText, paintSubText) {\n\t\t\tprivate float[] calculations = new float[1];\n\t\t\tprivate int cachedMeters = 0;\t\t\t\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic boolean updateInfo() {\n\t\t\t\tif( parkingPoint != null) {\n\t\t\t\t\tint d = 0;\n\t\t\t\t\tif (map.getRoutingHelper().isRouterEnabled()) {\n\t\t\t\t\t\td = map.getRoutingHelper().getLeftDistance();\n\t\t\t\t\t}\n\t\t\t\t\tif (d == 0) {\n\t\t\t\t\t\tLocation.distanceBetween(view.getLatitude(), view.getLongitude(), parkingPoint.getLatitude(), parkingPoint.getLongitude(), calculations);\n\t\t\t\t\t\td = (int) calculations[0];\n\t\t\t\t\t}\n\t\t\t\t\tif (distChanged(cachedMeters, d)) {\n\t\t\t\t\t\tcachedMeters = d;\n\t\t\t\t\t\tif (cachedMeters <= 20) {\n\t\t\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\t\t\tsetText(null, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString ds = OsmAndFormatter.getFormattedDistance(cachedMeters, map);\n\t\t\t\t\t\t\tint ls = ds.lastIndexOf(' ');\n\t\t\t\t\t\t\tif (ls == -1) {\n\t\t\t\t\t\t\t\tsetText(ds, null);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetText(ds.substring(0, ls), ds.substring(ls + 1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if (cachedMeters != 0) {\n\t\t\t\t\tcachedMeters = 0;\n\t\t\t\t\tsetText(null, null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\t\t\n\t\t\t\n\t\t\t/**\n\t\t\t * Utility method.\n\t\t\t * @param oldDist\n\t\t\t * @param dist\n\t\t\t * @return\n\t\t\t */\n\t\t\tprivate boolean distChanged(int oldDist, int dist){\n\t\t\t\tif(oldDist != 0 && oldDist - dist < 100 && Math.abs(((float) dist - oldDist)/oldDist) < 0.01){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tparkingPlaceControl.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tAnimateDraggingMapThread thread = view.getAnimatedDraggingThread();\n\t\t\t\tLatLon parkingPoint = view.getSettings().getParkingPosition();\n\t\t\t\tif (parkingPoint != null) {\n\t\t\t\t\tint fZoom = view.getZoom() < 15 ? 15 : view.getZoom();\n\t\t\t\t\tthread.startMoving(parkingPoint.getLatitude(), parkingPoint.getLongitude(), fZoom, true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tparkingPlaceControl.setText(null, null);\n\t\tparkingPlaceControl.setImageDrawable(view.getResources().getDrawable(R.drawable.poi_parking_pos_info));\n\t\treturn parkingPlaceControl;\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String getName() {\n\t\treturn app.getString(R.string.osmand_parking_position_name);\n\t}","id":85886,"modified_method":"@Override\n\tpublic String getName() {\n\t\treturn app.getString(R.string.osmand_parking_plugin_name);\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void registerMapContextMenuActions(final MapActivity mapActivity, final double latitude, final double longitude, ContextMenuAdapter adapter, Object selectedObj) {\n\t\tOnContextMenuClick listener = new OnContextMenuClick() {\n\t\t\t@Override\n\t\t\tpublic void onContextMenuClick(int resId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\tif (resId == R.string.context_menu_item_add_parking_point){\n\t\t\t\t\tsettings.setParkingPosition(latitude, longitude);\n\t\t\t\t\tif (mapActivity.getMapView().getLayers().contains(parkingLayer))\n\t\t\t\t\t\tparkingLayer.setParkingPoint(settings.getParkingPosition());\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tadapter.registerItem(R.string.context_menu_item_add_parking_point, 0, listener, -1);\n\t}","id":85887,"modified_method":"@Override\n\tpublic void registerMapContextMenuActions(final MapActivity mapActivity, final double latitude, final double longitude, ContextMenuAdapter adapter, Object selectedObj) {\n\t\tOnContextMenuClick addListener = new OnContextMenuClick() {\n\t\t\t@Override\n\t\t\tpublic void onContextMenuClick(int resId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\tif (resId == R.string.context_menu_item_add_parking_point) {\n\t\t\t\t\tsettings.setParkingPosition(latitude, longitude);\n\t\t\t\t\tif (mapActivity.getMapView().getLayers().contains(parkingLayer))\n\t\t\t\t\t\tparkingLayer.setParkingPoint(settings.getParkingPosition());\n\t\t\t\t} else if ((resId == R.string.context_menu_item_delete_parking_point)){\n\t\t\t\t\tparkingLayer.showDeleteDialog();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tadapter.registerItem(R.string.context_menu_item_add_parking_point, 0, addListener, -1);\n\t\tif (settings.getParkingPosition() != null)\n\t\t\tadapter.registerItem(R.string.context_menu_item_delete_parking_point, 0, addListener, -1);\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String getDescription() {\n\t\treturn app.getString(R.string.osmand_parking_position_description);\n\t}","id":85888,"modified_method":"@Override\n\tpublic String getDescription() {\n\t\treturn app.getString(R.string.osmand_parking_plugin_description);\n\t}","commit_id":"439e65aa4026aacaee66c6abf5e918ad83762937","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onCreate(final Bundle icicle) {\n\t\tBundle bundle = this.getIntent().getExtras();\n\t\tString filterId = bundle.getString(AMENITY_FILTER);\n\t\thelper = ((OsmandApplication)getApplication()).getPoiFilters();\n\t\tfilter = helper.getFilterById(filterId);\n\t\tsuper.onCreate(icicle);\n\t\t\n\t\t\n\t\tsetContentView(R.layout.editing_poi_filter);\n\t\tgetSupportActionBar().setTitle(R.string.filterpoi_activity);\n\t\tgetSupportActionBar().setIcon(R.drawable.tab_search_poi_icon);\n\t\t\n\t\tgetSupportActionBar().setSubtitle(filter.getName());\n\t\tsetListAdapter(new AmenityAdapter(AmenityType.getCategories()));\n\t}","id":85889,"modified_method":"@Override\n\tpublic void onCreate(final Bundle icicle) {\n\t\tBundle bundle = this.getIntent().getExtras();\n\t\tString filterId = bundle.getString(AMENITY_FILTER);\n\t\thelper = ((OsmandApplication) getApplication()).getPoiFilters();\n\t\tfilter = helper.getFilterById(filterId);\n\t\tsuper.onCreate(icicle);\n\n\t\tsetContentView(R.layout.editing_poi_filter);\n\t\tgetSupportActionBar().setTitle(R.string.filterpoi_activity);\n\t\tgetSupportActionBar().setIcon(R.drawable.tab_search_poi_icon);\n\n\t\tif (filter != null) {\n\t\t\tgetSupportActionBar().setSubtitle(filter.getName());\n\t\t\tsetListAdapter(new AmenityAdapter(AmenityType.getCategories()));\n\t\t} else {\n\t\t\tsetListAdapter(new AmenityAdapter(new AmenityType[0]));\n\t\t}\n\n\t}","commit_id":"c7f352da989e2214a961cdfb86eb005b0e14b6a4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tcreateMenuItem(menu, SAVE_FILTER, R.string.edit_filter_save_as_menu_item, \n\t\t\t\tR.drawable.ic_action_gsave_light, R.drawable.ic_action_gsave_dark ,\n\t\t\t\tMenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\tcreateMenuItem(menu, FILTER, R.string.filter_current_poiButton, \n\t\t\t\t0, 0,\n\t\t\t\t//R.drawable.a_1_navigation_accept_light, R.drawable.a_1_navigation_accept_dark,\n\t\t\t\tMenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_ALWAYS);\n\t\tif(!filter.isStandardFilter()){\n\t\t\tcreateMenuItem(menu, DELETE_FILTER, R.string.edit_filter_delete_menu_item, \n\t\t\t\t\tR.drawable.ic_action_gdiscard_light, R.drawable.ic_action_gdiscard_dark,\n\t\t\t\t\tMenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t}\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}","id":85890,"modified_method":"@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tif(filter == null) {\n\t\t\treturn super.onCreateOptionsMenu(menu);\n\t\t}\n\t\tcreateMenuItem(menu, SAVE_FILTER, R.string.edit_filter_save_as_menu_item, \n\t\t\t\tR.drawable.ic_action_gsave_light, R.drawable.ic_action_gsave_dark ,\n\t\t\t\tMenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\tcreateMenuItem(menu, FILTER, R.string.filter_current_poiButton, \n\t\t\t\t0, 0,\n\t\t\t\t//R.drawable.a_1_navigation_accept_light, R.drawable.a_1_navigation_accept_dark,\n\t\t\t\tMenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_ALWAYS);\n\t\tif(!filter.isStandardFilter()){\n\t\t\tcreateMenuItem(menu, DELETE_FILTER, R.string.edit_filter_delete_menu_item, \n\t\t\t\t\tR.drawable.ic_action_gdiscard_light, R.drawable.ic_action_gdiscard_dark,\n\t\t\t\t\tMenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t}\n\t\treturn super.onCreateOptionsMenu(menu);\n\t}","commit_id":"c7f352da989e2214a961cdfb86eb005b0e14b6a4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void switchRotateMapMode(){\n\t\tint vl = (settings.ROTATE_MAP.get() + 1) % 3;\n\t\tsettings.ROTATE_MAP.set(vl);\n\t\tint resId = R.string.rotate_map_none_opt;\n\t\tif(settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_COMPASS){\n\t\t\tresId = R.string.rotate_map_compass_opt;\n\t\t} else if(settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_BEARING){\n\t\t\tresId = R.string.rotate_map_bearing_opt;\n\t\t}\n\t\tapp.showShortToastMessage(resId);\n\t\tupdateSettings();\n\t\tmapView.refreshMap();\n\t}","id":85891,"modified_method":"public void switchRotateMapMode(){\n\t\tint vl = (settings.ROTATE_MAP.get() + 1) % 3;\n\t\tsettings.ROTATE_MAP.set(vl);\n\t\tint resId = R.string.rotate_map_none_opt;\n\t\tif(settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_COMPASS){\n\t\t\tresId = R.string.rotate_map_compass_opt;\n\t\t} else if(settings.ROTATE_MAP.get() == OsmandSettings.ROTATE_MAP_BEARING){\n\t\t\tresId = R.string.rotate_map_bearing_opt;\n\t\t}\n\t\tapp.showShortToastMessage(resId);\n\t\tupdateSettings();\n\t\tif(mapView != null) {\n\t\t\tmapView.refreshMap();\n\t\t}\n\t}","commit_id":"c7f352da989e2214a961cdfb86eb005b0e14b6a4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private List<String> checkAssets(IProgress progress) {\n\t\tif (!Version.getFullVersion(context)\n\t\t\t\t.equalsIgnoreCase(context.getSettings().PREVIOUS_INSTALLED_VERSION.get())) {\n\t\t\tFile applicationDataDir = context.getAppPath(null);\n\t\t\tapplicationDataDir.mkdirs();\n\t\t\tif(applicationDataDir.canWrite()){\n\t\t\t\ttry {\n\t\t\t\t\tprogress.startTask(context.getString(R.string.installing_new_resources), -1); \n\t\t\t\t\tAssetManager assetManager = context.getAssets();\n\t\t\t\t\tboolean isFirstInstall = context.getSettings().PREVIOUS_INSTALLED_VERSION.get().equals(\"\");\n\t\t\t\t\tunpackBundledAssets(assetManager, applicationDataDir, progress, isFirstInstall);\n\t\t\t\t\tcontext.getSettings().PREVIOUS_INSTALLED_VERSION.set(Version.getFullVersion(context));\n\t\t\t\t\t\n\t\t\t\t\tcontext.getPoiFilters().updateFilters(false);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","id":85892,"modified_method":"private List<String> checkAssets(IProgress progress) {\n\t\tif (!Version.getFullVersion(context)\n\t\t\t\t.equalsIgnoreCase(context.getSettings().PREVIOUS_INSTALLED_VERSION.get())) {\n\t\t\tFile applicationDataDir = context.getAppPath(null);\n\t\t\tapplicationDataDir.mkdirs();\n\t\t\tif(applicationDataDir.canWrite()){\n\t\t\t\ttry {\n\t\t\t\t\tprogress.startTask(context.getString(R.string.installing_new_resources), -1); \n\t\t\t\t\tAssetManager assetManager = context.getAssets();\n\t\t\t\t\tboolean isFirstInstall = context.getSettings().PREVIOUS_INSTALLED_VERSION.get().equals(\"\");\n\t\t\t\t\tunpackBundledAssets(assetManager, applicationDataDir, progress, isFirstInstall);\n\t\t\t\t\tcontext.getSettings().PREVIOUS_INSTALLED_VERSION.set(Version.getFullVersion(context));\n\t\t\t\t\t\n\t\t\t\t\tcontext.getPoiFilters().updateFilters(false);\n\t\t\t\t} catch (SQLiteException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","commit_id":"c7f352da989e2214a961cdfb86eb005b0e14b6a4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    public void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tgetSupportActionBar().setTitle(R.string.av_settings);\n\t\tPreferenceScreen grp = getPreferenceScreen();\n\t\tAudioVideoNotesPlugin p = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\t\tif (p != null) {\n\t\t\tString[] entries;\n\t\t\tInteger[] intValues;\n\n\t\t\tentries = new String[] { getString(R.string.av_def_action_choose), getString(R.string.av_def_action_audio),\n\t\t\t\t\tgetString(R.string.av_def_action_video), getString(R.string.av_def_action_picture) };\n\t\t\tintValues = new Integer[] { AV_DEFAULT_ACTION_CHOOSE, AV_DEFAULT_ACTION_AUDIO, AV_DEFAULT_ACTION_VIDEO,\n\t\t\t\t\tAV_DEFAULT_ACTION_TAKEPICTURE };\n\t\t\tListPreference defAct = createListPreference(p.AV_DEFAULT_ACTION, entries, intValues, R.string.av_widget_action,\n\t\t\t\t\tR.string.av_widget_action_descr);\n\t\t\tgrp.addPreference(defAct);\n\t\t\tfinal Camera cam = openCamera();\n\t\t\tif (cam != null) {\n\t\t\t\t// camera type settings:\n\t\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_PHOTO_CAM, R.string.av_use_external_camera,\n\t\t\t\t\t\tR.string.av_use_external_camera_descr));\n\t\t\t\t// focus mode settings:\n\t\t\t\t// show in menu only suppoted modes:\n\n\t\t\t\tParameters parameters = cam.getParameters();\n\t\t\t\tList<String> sfm = parameters.getSupportedFocusModes();\n\t\t\t\tList<String> items = new ArrayList<String>();\n\t\t\t\tList<Integer> itemsValues = new ArrayList<Integer>();\n\t\t\t\t// filtering known types for translate and set index:\n\t\t\t\tfor (int index = 0; index < sfm.size(); index++) {\n\t\t\t\t\tif (sfm.get(index).equals(\"auto\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_auto));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_AUTO);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"fixed\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_hiperfocal));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_HIPERFOCAL);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"edof\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_edof));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_EDOF);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"infinity\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_infinity));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_INFINITY);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"macro\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_macro));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_MACRO);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"continuous-picture\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_continuous));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_CONTINUOUS);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentries = items.toArray(entries);\n\t\t\t\tintValues = itemsValues.toArray(intValues);\n\t\t\t\tif (entries.length > 0) {\n\t\t\t\t\tListPreference camFocus = createListPreference(p.AV_CAMERA_FOCUS_TYPE, entries, intValues, R.string.av_camera_focus,\n\t\t\t\t\t\t\tR.string.av_camera_focus_descr);\n\t\t\t\t\tgrp.addPreference(camFocus);\n\t\t\t\t}\n\t\t\t\t// play sound on success photo:\n\t\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_PHOTO_PLAY_SOUND, R.string.av_photo_play_sound,\n\t\t\t\t\t\tR.string.av_photo_play_sound_descr));\n\t\t\t\tcam.release();\n\t\t\t}\n\t\t\t// video settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_RECORDER, R.string.av_use_external_recorder,\n\t\t\t\t\tR.string.av_use_external_recorder_descr));\n\t\t\t\n\t\t\tentries = new String[] { \"3GP\", \"MP4\" };\n\t\t\tintValues = new Integer[] { VIDEO_OUTPUT_3GP, VIDEO_OUTPUT_MP4 };\n\t\t\tListPreference lp = createListPreference(p.AV_VIDEO_FORMAT, entries, intValues, R.string.av_video_format,\n\t\t\t\t\tR.string.av_video_format_descr);\n\t\t\tgrp.addPreference(lp);\n\t\t}\n\t}","id":85893,"modified_method":"@Override\n    public void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tgetSupportActionBar().setTitle(R.string.av_settings);\n\t\tPreferenceScreen grp = getPreferenceScreen();\n\t\tAudioVideoNotesPlugin p = OsmandPlugin.getEnabledPlugin(AudioVideoNotesPlugin.class);\n\t\tif (p != null) {\n\t\t\tString[] entries;\n\t\t\tInteger[] intValues;\n\n\t\t\tentries = new String[] { getString(R.string.av_def_action_choose), getString(R.string.av_def_action_audio),\n\t\t\t\t\tgetString(R.string.av_def_action_video), getString(R.string.av_def_action_picture) };\n\t\t\tintValues = new Integer[] { AV_DEFAULT_ACTION_CHOOSE, AV_DEFAULT_ACTION_AUDIO, AV_DEFAULT_ACTION_VIDEO,\n\t\t\t\t\tAV_DEFAULT_ACTION_TAKEPICTURE };\n\t\t\tListPreference defAct = createListPreference(p.AV_DEFAULT_ACTION, entries, intValues, R.string.av_widget_action,\n\t\t\t\t\tR.string.av_widget_action_descr);\n\t\t\tgrp.addPreference(defAct);\n\t\t\tfinal Camera cam = openCamera();\n\t\t\tif (cam != null) {\n\t\t\t\t// camera type settings:\n\t\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_PHOTO_CAM, R.string.av_use_external_camera,\n\t\t\t\t\t\tR.string.av_use_external_camera_descr));\n\t\t\t\t// focus mode settings:\n\t\t\t\t// show in menu only suppoted modes:\n\n\t\t\t\tParameters parameters = cam.getParameters();\n\t\t\t\tList<String> sfm = parameters.getSupportedFocusModes();\n\t\t\t\tList<String> items = new ArrayList<String>();\n\t\t\t\tList<Integer> itemsValues = new ArrayList<Integer>();\n\t\t\t\t// filtering known types for translate and set index:\n\t\t\t\tfor (int index = 0; index < sfm.size(); index++) {\n\t\t\t\t\tif (sfm.get(index).equals(\"auto\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_auto));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_AUTO);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"fixed\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_hiperfocal));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_HIPERFOCAL);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"edof\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_edof));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_EDOF);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"infinity\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_infinity));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_INFINITY);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"macro\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_macro));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_MACRO);\n\t\t\t\t\t} else if (sfm.get(index).equals(\"continuous-picture\")) {\n\t\t\t\t\t\titems.add(getString(R.string.av_camera_focus_continuous));\n\t\t\t\t\t\titemsValues.add(AV_CAMERA_FOCUS_CONTINUOUS);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentries = items.toArray(new String[items.size()]);\n\t\t\t\tintValues = itemsValues.toArray(new Integer[itemsValues.size()]);\n\t\t\t\tif (entries.length > 0) {\n\t\t\t\t\tListPreference camFocus = createListPreference(p.AV_CAMERA_FOCUS_TYPE, entries, intValues, R.string.av_camera_focus,\n\t\t\t\t\t\t\tR.string.av_camera_focus_descr);\n\t\t\t\t\tgrp.addPreference(camFocus);\n\t\t\t\t}\n\t\t\t\t// play sound on success photo:\n\t\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_PHOTO_PLAY_SOUND, R.string.av_photo_play_sound,\n\t\t\t\t\t\tR.string.av_photo_play_sound_descr));\n\t\t\t\tcam.release();\n\t\t\t}\n\t\t\t// video settings:\n\t\t\tgrp.addPreference(createCheckBoxPreference(p.AV_EXTERNAL_RECORDER, R.string.av_use_external_recorder,\n\t\t\t\t\tR.string.av_use_external_recorder_descr));\n\t\t\t\n\t\t\tentries = new String[] { \"3GP\", \"MP4\" };\n\t\t\tintValues = new Integer[] { VIDEO_OUTPUT_3GP, VIDEO_OUTPUT_MP4 };\n\t\t\tListPreference lp = createListPreference(p.AV_VIDEO_FORMAT, entries, intValues, R.string.av_video_format,\n\t\t\t\t\tR.string.av_video_format_descr);\n\t\t\tgrp.addPreference(lp);\n\t\t}\n\t}","commit_id":"c7f352da989e2214a961cdfb86eb005b0e14b6a4","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void executeStartupTasks() {\n    ComponentContainer startupContainer = servicesContainer.createChild();\n    startupContainer.addSingleton(GwtPublisher.class);\n    startupContainer.addSingleton(RegisterMetrics.class);\n    startupContainer.addSingleton(RegisterRules.class);\n    startupContainer.addSingleton(RegisterNewProfiles.class);\n    startupContainer.addSingleton(JdbcDriverDeployer.class);\n    startupContainer.addSingleton(RegisterTechnicalDebtModel.class);\n    startupContainer.addSingleton(DeleteDeprecatedMeasures.class);\n    startupContainer.addSingleton(GeneratePluginIndex.class);\n    startupContainer.addSingleton(GenerateBootstrapIndex.class);\n    startupContainer.addSingleton(RegisterNewMeasureFilters.class);\n    startupContainer.addSingleton(RegisterNewDashboards.class);\n    startupContainer.addSingleton(RegisterPermissionTemplates.class);\n    startupContainer.addSingleton(RenameDeprecatedPropertyKeys.class);\n    startupContainer.addSingleton(LogServerId.class);\n    startupContainer.addSingleton(RegisterServletFilters.class);\n    startupContainer.addSingleton(CleanDryRunCache.class);\n    startupContainer.startComponents();\n\n    startupContainer.getComponentByType(ServerLifecycleNotifier.class).notifyStart();\n\n    // Do not put the following statements in a finally block.\n    // It would hide the possible exception raised during startup\n    // See SONAR-3107\n    startupContainer.stopComponents();\n    servicesContainer.removeChild();\n    servicesContainer.getComponentByType(DatabaseSessionFactory.class).clear();\n  }","id":85894,"modified_method":"private void executeStartupTasks() {\n    ComponentContainer startupContainer = servicesContainer.createChild();\n    startupContainer.addSingleton(GwtPublisher.class);\n    startupContainer.addSingleton(RegisterMetrics.class);\n    startupContainer.addSingleton(DeprecatedRuleDefinitions.class);\n    startupContainer.addSingleton(RegisterRules.class);\n    startupContainer.addSingleton(RegisterNewProfiles.class);\n    startupContainer.addSingleton(JdbcDriverDeployer.class);\n    startupContainer.addSingleton(RegisterTechnicalDebtModel.class);\n    startupContainer.addSingleton(DeleteDeprecatedMeasures.class);\n    startupContainer.addSingleton(GeneratePluginIndex.class);\n    startupContainer.addSingleton(GenerateBootstrapIndex.class);\n    startupContainer.addSingleton(RegisterNewMeasureFilters.class);\n    startupContainer.addSingleton(RegisterNewDashboards.class);\n    startupContainer.addSingleton(RegisterPermissionTemplates.class);\n    startupContainer.addSingleton(RenameDeprecatedPropertyKeys.class);\n    startupContainer.addSingleton(LogServerId.class);\n    startupContainer.addSingleton(RegisterServletFilters.class);\n    startupContainer.addSingleton(CleanDryRunCache.class);\n    startupContainer.startComponents();\n\n    startupContainer.getComponentByType(ServerLifecycleNotifier.class).notifyStart();\n\n    // Do not put the following statements in a finally block.\n    // It would hide the possible exception raised during startup\n    // See SONAR-3107\n    startupContainer.stopComponents();\n    servicesContainer.removeChild();\n    servicesContainer.getComponentByType(DatabaseSessionFactory.class).clear();\n  }","commit_id":"f5521caa09810aac91e1dbb86dee52e435f4bbd5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_rule_parameters() {\n    RuleDefinitions.NewRepository newFindbugs = context.newRepository(\"findbugs\", \"java\");\n    RuleDefinitions.NewRule newNpe = newFindbugs.newRule(\"NPE\");\n    newNpe.newParam(\"level\").setDefaultValue(\"LOW\").setName(\"Level\").setDescription(\"The level\");\n    newNpe.newParam(\"effort\");\n    newFindbugs.done();\n\n    RuleDefinitions.Rule rule = context.repository(\"findbugs\").rule(\"NPE\");\n    assertThat(rule.params()).hasSize(2);\n\n    RuleDefinitions.Param level = rule.param(\"level\");\n    assertThat(level.key()).isEqualTo(\"level\");\n    assertThat(level.name()).isEqualTo(\"Level\");\n    assertThat(level.description()).isEqualTo(\"The level\");\n    assertThat(level.defaultValue()).isEqualTo(\"LOW\");\n\n    RuleDefinitions.Param effort = rule.param(\"effort\");\n    assertThat(effort.key()).isEqualTo(\"effort\").isEqualTo(effort.name());\n    assertThat(effort.description()).isNull();\n    assertThat(effort.defaultValue()).isNull();\n\n    // test equals() and hashCode()\n    assertThat(level).isEqualTo(level).isNotEqualTo(effort).isNotEqualTo(\"level\").isNotEqualTo(null);\n    assertThat(level.hashCode()).isEqualTo(level.hashCode());\n  }","id":85895,"modified_method":"@Test\n  public void define_rule_parameters() {\n    RuleDefinitions.NewRepository newFindbugs = context.newRepository(\"findbugs\", \"java\");\n    RuleDefinitions.NewRule newNpe = newFindbugs.newRule(\"NPE\").setName(\"NPE\").setHtmlDescription(\"NPE\");\n    newNpe.newParam(\"level\").setDefaultValue(\"LOW\").setName(\"Level\").setDescription(\"The level\").setType(RuleParamType.INTEGER);\n    newNpe.newParam(\"effort\");\n    newFindbugs.done();\n\n    RuleDefinitions.Rule rule = context.repository(\"findbugs\").rule(\"NPE\");\n    assertThat(rule.params()).hasSize(2);\n\n    RuleDefinitions.Param level = rule.param(\"level\");\n    assertThat(level.key()).isEqualTo(\"level\");\n    assertThat(level.name()).isEqualTo(\"Level\");\n    assertThat(level.description()).isEqualTo(\"The level\");\n    assertThat(level.defaultValue()).isEqualTo(\"LOW\");\n    assertThat(level.type()).isEqualTo(RuleParamType.INTEGER);\n\n    RuleDefinitions.Param effort = rule.param(\"effort\");\n    assertThat(effort.key()).isEqualTo(\"effort\").isEqualTo(effort.name());\n    assertThat(effort.description()).isNull();\n    assertThat(effort.defaultValue()).isNull();\n    assertThat(effort.type()).isEqualTo(RuleParamType.STRING);\n\n    // test equals() and hashCode()\n    assertThat(level).isEqualTo(level).isNotEqualTo(effort).isNotEqualTo(\"level\").isNotEqualTo(null);\n    assertThat(level.hashCode()).isEqualTo(level.hashCode());\n  }","commit_id":"f5521caa09810aac91e1dbb86dee52e435f4bbd5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void extend_repository() {\n    assertThat(context.extendedRepositories()).isEmpty();\n\n    // for example fb-contrib\n    RuleDefinitions.NewExtendedRepository newFindbugs = context.extendRepository(\"findbugs\");\n    newFindbugs.newRule(\"NPE\");\n    newFindbugs.done();\n\n    assertThat(context.repositories()).isEmpty();\n    assertThat(context.extendedRepositories()).hasSize(1);\n    assertThat(context.extendedRepositories(\"other\")).isEmpty();\n    assertThat(context.extendedRepositories(\"findbugs\")).hasSize(1);\n\n    RuleDefinitions.ExtendedRepository findbugs = context.extendedRepositories(\"findbugs\").get(0);\n    assertThat(findbugs.rule(\"NPE\")).isNotNull();\n  }","id":85896,"modified_method":"@Test\n  public void extend_repository() {\n    assertThat(context.extendedRepositories()).isEmpty();\n\n    // for example fb-contrib\n    RuleDefinitions.NewExtendedRepository newFindbugs = context.extendRepository(\"findbugs\");\n    newFindbugs.newRule(\"NPE\").setName(\"NPE\").setHtmlDescription(\"NPE\");\n    newFindbugs.done();\n\n    assertThat(context.repositories()).isEmpty();\n    assertThat(context.extendedRepositories()).hasSize(1);\n    assertThat(context.extendedRepositories(\"other\")).isEmpty();\n    assertThat(context.extendedRepositories(\"findbugs\")).hasSize(1);\n\n    RuleDefinitions.ExtendedRepository findbugs = context.extendedRepositories(\"findbugs\").get(0);\n    assertThat(findbugs.rule(\"NPE\")).isNotNull();\n  }","commit_id":"f5521caa09810aac91e1dbb86dee52e435f4bbd5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_rules() {\n    RuleDefinitions.NewRepository newFindbugs = context.newRepository(\"findbugs\", \"java\");\n    newFindbugs.newRule(\"NPE\")\n      .setName(\"Detect NPE\")\n      .setHtmlDescription(\"Detect <code>java.lang.NullPointerException<\/code>\")\n      .setDefaultSeverity(Severity.BLOCKER)\n      .setMetadata(\"/something\")\n      .setTags(\"one\", \"two\")\n      .addTags(\"two\", \"three\", \"four\");\n    newFindbugs.newRule(\"ABC\");\n    newFindbugs.done();\n\n    RuleDefinitions.Repository findbugs = context.repository(\"findbugs\");\n    assertThat(findbugs.rules()).hasSize(2);\n\n    RuleDefinitions.Rule npeRule = findbugs.rule(\"NPE\");\n    assertThat(npeRule.key()).isEqualTo(\"NPE\");\n    assertThat(npeRule.name()).isEqualTo(\"Detect NPE\");\n    assertThat(npeRule.defaultSeverity()).isEqualTo(Severity.BLOCKER);\n    assertThat(npeRule.htmlDescription()).isEqualTo(\"Detect <code>java.lang.NullPointerException<\/code>\");\n    assertThat(npeRule.tags()).containsOnly(\"one\", \"two\", \"three\", \"four\");\n    assertThat(npeRule.params()).isEmpty();\n    assertThat(npeRule.metadata()).isEqualTo(\"/something\");\n    assertThat(npeRule.toString()).isEqualTo(\"[repository=findbugs, key=NPE]\");\n\n    // test equals() and hashCode()\n    RuleDefinitions.Rule otherRule = findbugs.rule(\"ABC\");\n    assertThat(npeRule).isEqualTo(npeRule).isNotEqualTo(otherRule).isNotEqualTo(\"NPE\").isNotEqualTo(null);\n    assertThat(npeRule.hashCode()).isEqualTo(npeRule.hashCode());\n  }","id":85897,"modified_method":"@Test\n  public void define_rules() {\n    RuleDefinitions.NewRepository newFindbugs = context.newRepository(\"findbugs\", \"java\");\n    newFindbugs.newRule(\"NPE\")\n      .setName(\"Detect NPE\")\n      .setHtmlDescription(\"Detect <code>NPE<\/code>\")\n      .setHtmlDescription(\"Detect <code>java.lang.NullPointerException<\/code>\")\n      .setDefaultSeverity(Severity.BLOCKER)\n      .setMetadata(\"/something\")\n      .setTags(\"one\", \"two\")\n      .addTags(\"two\", \"three\", \"four\");\n    newFindbugs.newRule(\"ABC\").setName(\"ABC\").setHtmlDescription(\"ABC\");\n    newFindbugs.done();\n\n    RuleDefinitions.Repository findbugs = context.repository(\"findbugs\");\n    assertThat(findbugs.rules()).hasSize(2);\n\n    RuleDefinitions.Rule npeRule = findbugs.rule(\"NPE\");\n    assertThat(npeRule.key()).isEqualTo(\"NPE\");\n    assertThat(npeRule.name()).isEqualTo(\"Detect NPE\");\n    assertThat(npeRule.defaultSeverity()).isEqualTo(Severity.BLOCKER);\n    assertThat(npeRule.htmlDescription()).isEqualTo(\"Detect <code>java.lang.NullPointerException<\/code>\");\n    assertThat(npeRule.tags()).containsOnly(\"one\", \"two\", \"three\", \"four\");\n    assertThat(npeRule.params()).isEmpty();\n    assertThat(npeRule.metadata()).isEqualTo(\"/something\");\n    assertThat(npeRule.template()).isFalse();\n    assertThat(npeRule.toString()).isEqualTo(\"[repository=findbugs, key=NPE]\");\n\n    // test equals() and hashCode()\n    RuleDefinitions.Rule otherRule = findbugs.rule(\"ABC\");\n    assertThat(npeRule).isEqualTo(npeRule).isNotEqualTo(otherRule).isNotEqualTo(\"NPE\").isNotEqualTo(null);\n    assertThat(npeRule.hashCode()).isEqualTo(npeRule.hashCode());\n  }","commit_id":"f5521caa09810aac91e1dbb86dee52e435f4bbd5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_rule_with_default_fields() {\n    RuleDefinitions.NewRepository newFindbugs = context.newRepository(\"findbugs\", \"java\");\n    newFindbugs.newRule(\"NPE\");\n    newFindbugs.done();\n\n    RuleDefinitions.Rule rule = context.repository(\"findbugs\").rule(\"NPE\");\n    assertThat(rule.key()).isEqualTo(\"NPE\");\n    assertThat(rule.name()).isEqualTo(\"NPE\");\n    assertThat(rule.defaultSeverity()).isEqualTo(Severity.MAJOR);\n    assertThat(rule.htmlDescription()).isNull();\n    assertThat(rule.params()).isEmpty();\n    assertThat(rule.metadata()).isNull();\n    assertThat(rule.tags()).isEmpty();\n  }","id":85898,"modified_method":"@Test\n  public void define_rule_with_default_fields() {\n    RuleDefinitions.NewRepository newFindbugs = context.newRepository(\"findbugs\", \"java\");\n    newFindbugs.newRule(\"NPE\").setName(\"NPE\").setHtmlDescription(\"NPE\");\n    newFindbugs.done();\n\n    RuleDefinitions.Rule rule = context.repository(\"findbugs\").rule(\"NPE\");\n    assertThat(rule.key()).isEqualTo(\"NPE\");\n    assertThat(rule.defaultSeverity()).isEqualTo(Severity.MAJOR);\n    assertThat(rule.params()).isEmpty();\n    assertThat(rule.metadata()).isNull();\n    assertThat(rule.tags()).isEmpty();\n  }","commit_id":"f5521caa09810aac91e1dbb86dee52e435f4bbd5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_blank_rule_html_description() {\n    try {\n      context.newRepository(\"findbugs\", \"java\").newRule(\"NPE\").setHtmlDescription(null);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"HTML description of rule [repository=findbugs, key=NPE] is blank\");\n    }\n  }","id":85899,"modified_method":"@Test\n  public void fail_if_blank_rule_html_description() {\n    RuleDefinitions.NewRepository newRepository = context.newRepository(\"findbugs\", \"java\");\n    newRepository.newRule(\"NPE\").setName(\"NPE\").setHtmlDescription(null);\n    try {\n      newRepository.done();\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"HTML description of rule [repository=findbugs, key=NPE] is empty\");\n    }\n  }","commit_id":"f5521caa09810aac91e1dbb86dee52e435f4bbd5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_blank_rule_name() {\n    try {\n      context.newRepository(\"findbugs\", \"java\").newRule(\"NPE\").setName(null);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Name of rule [repository=findbugs, key=NPE] is blank\");\n    }\n  }","id":85900,"modified_method":"@Test\n  public void fail_if_blank_rule_name() {\n    RuleDefinitions.NewRepository newRepository = context.newRepository(\"findbugs\", \"java\");\n    newRepository.newRule(\"NPE\").setName(null).setHtmlDescription(\"NPE\");\n    try {\n      newRepository.done();\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"Name of rule [repository=findbugs, key=NPE] is empty\");\n    }\n  }","commit_id":"f5521caa09810aac91e1dbb86dee52e435f4bbd5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public VariableResolver createVariable(String name,\r\n                                           Object value) {\r\n        VariableResolver vr = getVariableResolver( name );\r\n        if ( vr != null ) {\r\n            if ( this.localVariables == null ) {\r\n                this.localVariables = new HashMap();\r\n            }\r\n            vr.setValue( value );\r\n            return vr;\r\n        } else {\r\n            if ( this.localVariables == null ) {\r\n                this.localVariables = new HashMap();\r\n            }\r\n            addResolver( name,\r\n                         vr = new LocalVariableResolver( this,\r\n                                                         name ) );\r\n            vr.setValue( value );\r\n            return vr;\r\n        }\r\n    }","id":85901,"modified_method":"public VariableResolver createVariable(String name,\r\n                                           Object value) {\r\n        VariableResolver vr = getVariableResolver( name );\r\n        if ( vr == null ) {\r\n            addResolver( name,\r\n                         vr = new LocalVariableResolver( this,\r\n                                                         name ) );\r\n        }\r\n        \r\n        vr.setValue( value );\r\n        return vr;        \r\n    }","commit_id":"d40cd56f5733f05b770d07de733b6c5487999592","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public boolean isResolveable(String name) {\r\n        if ( DroolsMVELKnowledgeHelper.DROOLS.equals( name ) ) {\r\n            addResolver( DroolsMVELKnowledgeHelper.DROOLS,\r\n                         new DroolsMVELKnowledgeHelper( this ) );\r\n            return true;\r\n\r\n        } else if ( this.variableResolvers != null && this.variableResolvers.containsKey( name ) ) {\r\n            return true;\r\n        } else if ( this.previousDeclarations != null && this.previousDeclarations.containsKey( name ) ) {\r\n            addResolver( name,\r\n                         new DroolsMVELPreviousDeclarationVariable( (Declaration) this.previousDeclarations.get( name ),\r\n                                                                    this ) );\r\n            return true;\r\n        } else if ( this.localDeclarations != null && this.localDeclarations.containsKey( name ) ) {\r\n            addResolver( name,\r\n                         new DroolsMVELLocalDeclarationVariable( (Declaration) this.localDeclarations.get( name ),\r\n                                                                 this ) );\r\n            return true;\r\n        } else if ( this.globals.containsKey( name ) ) {\r\n            addResolver( name,\r\n                         new DroolsMVELGlobalVariable( name,\r\n                                                       (Class) this.globals.get( name ),\r\n                                                       this ) );\r\n            return true;\r\n        } else if ( this.variableResolvers != null && this.variableResolvers.containsKey( name ) ) {\r\n            addResolver( name,\r\n                         new LocalVariableResolver( this,\r\n                                                    name ) );\r\n            return true;\r\n        } else if ( nextFactory != null ) {\r\n            return nextFactory.isResolveable( name );\r\n        }\r\n\r\n        return false;\r\n    }","id":85902,"modified_method":"public boolean isResolveable(String name) {\r\n        if ( DroolsMVELKnowledgeHelper.DROOLS.equals( name ) ) {\r\n            addResolver( DroolsMVELKnowledgeHelper.DROOLS,\r\n                         new DroolsMVELKnowledgeHelper( this ) );\r\n            return true;\r\n\r\n        } else if ( this.variableResolvers != null && this.variableResolvers.containsKey( name ) ) {\r\n            return true;\r\n        } else if ( this.previousDeclarations != null && this.previousDeclarations.containsKey( name ) ) {\r\n            addResolver( name,\r\n                         new DroolsMVELPreviousDeclarationVariable( (Declaration) this.previousDeclarations.get( name ),\r\n                                                                    this ) );\r\n            return true;\r\n        } else if ( this.localDeclarations != null && this.localDeclarations.containsKey( name ) ) {\r\n            addResolver( name,\r\n                         new DroolsMVELLocalDeclarationVariable( (Declaration) this.localDeclarations.get( name ),\r\n                                                                 this ) );\r\n            return true;\r\n        } else if ( this.globals.containsKey( name ) ) {\r\n            addResolver( name,\r\n                         new DroolsMVELGlobalVariable( name,\r\n                                                       (Class) this.globals.get( name ),\r\n                                                       this ) );\r\n            return true;\r\n        }  else if ( nextFactory != null ) {\r\n            return nextFactory.isResolveable( name );\r\n        }\r\n\r\n        return false;\r\n    }","commit_id":"d40cd56f5733f05b770d07de733b6c5487999592","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public VariableResolver createVariable(String name,\r\n                                           Object value,\r\n                                           Class type) {\r\n        VariableResolver vr = getVariableResolver( name );\r\n        if ( vr != null && vr.getType() != null ) {\r\n            throw new CompileException( \"variable already defined within scope: \" + vr.getType() + \" \" + name );\r\n        } else {\r\n            if ( this.localVariables == null ) {\r\n                this.localVariables = new HashMap();\r\n            }\r\n            addResolver( name,\r\n                         vr = new LocalVariableResolver( this,\r\n                                                         name,\r\n                                                         type ) );\r\n            vr.setValue( value );\r\n            return vr;\r\n        }\r\n    }","id":85903,"modified_method":"public VariableResolver createVariable(String name,\r\n                                           Object value,\r\n                                           Class type) {\r\n        VariableResolver vr = getVariableResolver( name );\r\n        if ( vr == null ) {\r\n            addResolver( name,\r\n                         vr = new LocalVariableResolver( this,\r\n                                                         name,\r\n                                                         type ) );\r\n        }        \r\n        \r\n        vr.setValue( value );\r\n        return vr;\r\n    }","commit_id":"d40cd56f5733f05b770d07de733b6c5487999592","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setContext(final Tuple tuple,\r\n                           final KnowledgeHelper knowledgeHelper,\r\n                           final Object object,\r\n                           final WorkingMemory workingMemory,\r\n                           final Map variables) {\r\n        if ( tuple != null ) {\r\n            this.tupleObjects = ((ReteTuple) tuple).toObjectArray();\r\n        }\r\n        this.knowledgeHelper = knowledgeHelper;\r\n        this.object = object;\r\n        this.workingMemory = workingMemory;\r\n        this.localVariables = variables;\r\n    }","id":85904,"modified_method":"public void setContext(final Tuple tuple,\r\n                           final KnowledgeHelper knowledgeHelper,\r\n                           final Object object,\r\n                           final WorkingMemory workingMemory,\r\n                           final Map variables) {\r\n        if ( tuple != null ) {\r\n            this.tupleObjects = ((ReteTuple) tuple).toObjectArray();\r\n        }\r\n        this.knowledgeHelper = knowledgeHelper;\r\n        this.object = object;\r\n        this.workingMemory = workingMemory;\r\n        if ( variables == null ) {\r\n            if ( this.localVariables == null ) {\r\n                this.localVariables = new HashMap();\r\n            } else {\r\n                this.localVariables.clear();\r\n            }            \r\n        } else {\r\n            this.localVariables = variables;\r\n        }\r\n    }","commit_id":"d40cd56f5733f05b770d07de733b6c5487999592","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected long addCoverImage(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector coverImageImageSelector)\n\t\tthrows PortalException {\n\n\t\tlong coverImageId = 0;\n\n\t\tbyte[] bytes = null;\n\n\t\ttry {\n\t\t\tbytes = coverImageImageSelector.getCroppedImageBytes();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t\t}\n\t\t}\n\n\t\tif (bytes == null) {\n\t\t\treturn coverImageId;\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = coverImageImageSelector.getTitle();\n\t\t\tString mimeType = coverImageImageSelector.getMimeType();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempCroppedImage_\" + entryId;\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddGroupPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tFileEntry fileEntry = PortletFileRepositoryUtil.addPortletFileEntry(\n\t\t\t\tgroupId, userId, BlogsEntry.class.getName(), entryId,\n\t\t\t\tPortletKeys.BLOGS, folder.getFolderId(), file, title, mimeType,\n\t\t\t\tfalse);\n\n\t\t\tcoverImageId = fileEntry.getFileEntryId();\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\n\t\treturn coverImageId;\n\t}","id":85905,"modified_method":"protected long addCoverImage(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector coverImageImageSelector)\n\t\tthrows PortalException {\n\n\t\tlong coverImageId = 0;\n\n\t\tbyte[] bytes = null;\n\n\t\ttry {\n\t\t\tbytes = coverImageImageSelector.getCroppedImageBytes();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t\t}\n\t\t}\n\n\t\tif (bytes == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = coverImageImageSelector.getTitle();\n\t\t\tString mimeType = coverImageImageSelector.getMimeType();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempCroppedImage_\" + entryId;\n\t\t\t}\n\n\t\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\t\tserviceContext.setAddGroupPermissions(true);\n\t\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tFileEntry fileEntry = PortletFileRepositoryUtil.addPortletFileEntry(\n\t\t\t\tgroupId, userId, BlogsEntry.class.getName(), entryId,\n\t\t\t\tPortletKeys.BLOGS, folder.getFolderId(), file, title, mimeType,\n\t\t\t\tfalse);\n\n\t\t\tcoverImageId = fileEntry.getFileEntryId();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\n\t\treturn coverImageId;\n\t}","commit_id":"01f8c44ea1f972f2dd2d142e229cd3d3bcab0445","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tFileEntry tempFileEntry =\n\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\t\tsmallImageImageSelector.getImageId());\n\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\ttempFileEntry.getMimeType(), tempFileEntry.getTitle(),\n\t\t\t\t\ttempFileEntry.getContentStream());\n\n\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\ttempFileEntry.getFileEntryId());\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\treturn startWorkflowInstance(userId, entry, serviceContext);\n\t}","id":85906,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, ImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getCoverImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tFileEntry tempSmallImageFileEntry = null;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\t\t\tentry.getSmallImageFileEntryId());\n\t\t\t\t}\n\n\t\t\t\ttempSmallImageFileEntry =\n\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\t\tsmallImageImageSelector.getImageId());\n\n\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\ttempSmallImageFileEntry.getMimeType(),\n\t\t\t\t\ttempSmallImageFileEntry.getTitle(),\n\t\t\t\t\ttempSmallImageFileEntry.getContentStream());\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif ((coverImageImageSelector != null) &&\n\t\t\t(coverImageImageSelector.getImageId() != 0)) {\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t}\n\n\t\tif (tempSmallImageFileEntry != null) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempSmallImageFileEntry.getFileEntryId());\n\t\t}\n\n\t\treturn entry;\n\t}","commit_id":"01f8c44ea1f972f2dd2d142e229cd3d3bcab0445","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String subtitle, String description,\n\t\t\tString content, Date displayDate, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tDate now = new Date();\n\n\t\tvalidate(title, content);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Comments\n\n\t\taddDiscussion(entry, userId, groupId);\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = 0;\n\t\tString coverImageURL = null;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\tuserId, groupId, entryId, coverImageImageSelector);\n\t\t}\n\n\t\tboolean smallImage = false;\n\t\tlong smallImageFileEntryId = 0;\n\t\tString smallImageURL = null;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (smallImageFileEntryId != 0) {\n\t\t\tFileEntry tempFileEntry =\n\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\tsmallImageFileEntryId);\n\n\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, tempFileEntry.getMimeType(),\n\t\t\t\ttempFileEntry.getTitle(), tempFileEntry.getContentStream());\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempFileEntry.getFileEntryId());\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\treturn startWorkflowInstance(userId, entry, serviceContext);\n\t}","id":85907,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String subtitle, String description,\n\t\t\tString content, Date displayDate, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tDate now = new Date();\n\n\t\tvalidate(title, content);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Comments\n\n\t\taddDiscussion(entry, userId, groupId);\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = 0;\n\t\tString coverImageURL = null;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\t\t}\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tcoverImageFileEntryId = addCoverImage(\n\t\t\t\tuserId, groupId, entryId, coverImageImageSelector);\n\t\t}\n\n\t\tboolean smallImage = false;\n\t\tlong smallImageFileEntryId = 0;\n\t\tString smallImageURL = null;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\t\t}\n\n\t\tFileEntry tempSmallImageFileEntry = null;\n\n\t\tif (smallImageFileEntryId != 0) {\n\t\t\ttempSmallImageFileEntry =\n\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\t\t\tsmallImageFileEntryId);\n\n\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\tuserId, groupId, entryId, tempSmallImageFileEntry.getMimeType(),\n\t\t\t\ttempSmallImageFileEntry.getTitle(),\n\t\t\t\ttempSmallImageFileEntry.getContentStream());\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif ((coverImageImageSelector != null) &&\n\t\t\t(coverImageImageSelector.getImageId() != 0)) {\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t}\n\n\t\tif (tempSmallImageFileEntry != null) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempSmallImageFileEntry.getFileEntryId());\n\t\t}\n\n\t\treturn entry;\n\t}","commit_id":"01f8c44ea1f972f2dd2d142e229cd3d3bcab0445","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\t@Override\n\t@SystemEvent(type = SystemEventConstants.TYPE_DELETE)\n\tpublic BlogsEntry deleteEntry(BlogsEntry entry) throws PortalException {\n\n\t\t// Entry\n\n\t\tblogsEntryPersistence.remove(entry);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());\n\n\t\t// Image\n\n\t\timageLocalService.deleteImage(entry.getSmallImageId());\n\n\t\t// Subscriptions\n\n\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId());\n\n\t\t// Statistics\n\n\t\tblogsStatsUserLocalService.updateStatsUser(\n\t\t\tentry.getGroupId(), entry.getUserId(), entry.getDisplayDate());\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Attachments\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageFileEntryId);\n\t\t}\n\n\t\t// Comment\n\n\t\tdeleteDiscussion(entry);\n\n\t\t// Expando\n\n\t\texpandoRowLocalService.deleteRows(entry.getEntryId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Workflow\n\n\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(\n\t\t\tentry.getCompanyId(), entry.getGroupId(),\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\treturn entry;\n\t}","id":85908,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\t@Override\n\t@SystemEvent(type = SystemEventConstants.TYPE_DELETE)\n\tpublic BlogsEntry deleteEntry(BlogsEntry entry) throws PortalException {\n\n\t\t// Entry\n\n\t\tblogsEntryPersistence.remove(entry);\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, entry.getEntryId());\n\n\t\t// Image\n\n\t\timageLocalService.deleteImage(entry.getSmallImageId());\n\n\t\t// Subscriptions\n\n\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\tentry.getCompanyId(), BlogsEntry.class.getName(),\n\t\t\tentry.getEntryId());\n\n\t\t// Statistics\n\n\t\tblogsStatsUserLocalService.updateStatsUser(\n\t\t\tentry.getGroupId(), entry.getUserId(), entry.getDisplayDate());\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Attachments\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\n\t\tif (coverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageFileEntryId);\n\t\t}\n\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\n\t\tif (smallImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tsmallImageFileEntryId);\n\t\t}\n\n\t\t// Comment\n\n\t\tdeleteDiscussion(entry);\n\n\t\t// Expando\n\n\t\texpandoRowLocalService.deleteRows(entry.getEntryId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Trash\n\n\t\ttrashEntryLocalService.deleteEntry(\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\t// Workflow\n\n\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(\n\t\t\tentry.getCompanyId(), entry.getGroupId(),\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId());\n\n\t\treturn entry;\n\t}","commit_id":"dff7af212d27cd4d14279f178bb8f0c971db1776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addCoverImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\timageSelector.getImageId());\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tif (fileEntry.isRepositoryCapabilityProvided(\n\t\t\t\tTemporaryFileEntriesCapability.class)) {\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getContentStream());\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tbyte[] bytes = imageSelector.getCroppedImageBytes();\n\n\t\t\tif (bytes == null) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = imageSelector.getTitle();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempCroppedImage_\" + entryId;\n\t\t\t}\n\n\t\t\tFolder folder = addCoverImageFolder(userId, groupId);\n\n\t\t\tFileEntry coverImageFileEntry =\n\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(), title,\n\t\t\t\t\t\timageSelector.getMimeType(), file);\n\n\t\t\treturn coverImageFileEntry.getFileEntryId();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Unable to get cropped image from image selector image \" +\n\t\t\t\t\t\timageSelector.getImageId());\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\n\t\treturn 0;\n\t}","id":85909,"modified_method":"protected long addCoverImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\timageSelector.getImageId());\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tif (fileEntry.isRepositoryCapabilityProvided(\n\t\t\t\tTemporaryFileEntriesCapability.class)) {\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getContentStream());\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tbyte[] bytes = imageSelector.getCroppedImageBytes();\n\n\t\t\tif (bytes == null) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = imageSelector.getTitle();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempCroppedImage_\" + entryId;\n\t\t\t}\n\n\t\t\tFolder folder = addCoverImageFolder(userId, groupId);\n\n\t\t\tFileEntry coverImageFileEntry =\n\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(), title,\n\t\t\t\t\t\timageSelector.getMimeType(), file);\n\n\t\t\treturn coverImageFileEntry.getFileEntryId();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new EntryCoverImageCropException();\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","commit_id":"dff7af212d27cd4d14279f178bb8f0c971db1776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected long addSmallImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\timageSelector.getImageId());\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tif (fileEntry.isRepositoryCapabilityProvided(\n\t\t\t\tTemporaryFileEntriesCapability.class)) {\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getContentStream());\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tImageBag imageBag = ImageToolUtil.read(\n\t\t\t\tfileEntry.getContentStream());\n\n\t\t\tRenderedImage renderedImage = imageBag.getRenderedImage();\n\n\t\t\tBlogsGroupServiceSettings blogsGroupServiceSettings =\n\t\t\t\tBlogsGroupServiceSettings.getInstance(groupId);\n\n\t\t\trenderedImage = ImageToolUtil.scale(\n\t\t\t\trenderedImage, blogsGroupServiceSettings.getSmallImageWidth());\n\n\t\t\tbyte[] bytes = ImageToolUtil.getBytes(\n\t\t\t\trenderedImage, imageBag.getType());\n\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = imageSelector.getTitle();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempScaledImage_\" + entryId;\n\t\t\t}\n\n\t\t\tFolder folder = addSmallImageFolder(userId, groupId);\n\n\t\t\tFileEntry smallImageFileEntry =\n\t\t\t\tPortletFileRepositoryUtil.addPortletFileEntry(\n\t\t\t\t\tgroupId, userId, BlogsEntry.class.getName(), entryId,\n\t\t\t\t\tBlogsConstants.SERVICE_NAME, folder.getFolderId(), file,\n\t\t\t\t\ttitle, imageSelector.getMimeType(), false);\n\n\t\t\treturn smallImageFileEntry.getFileEntryId();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new EntrySmallImageScaleException();\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","id":85910,"modified_method":"protected long addSmallImageFileEntry(\n\t\t\tlong userId, long groupId, long entryId,\n\t\t\tImageSelector imageSelector)\n\t\tthrows PortalException {\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\timageSelector.getImageId());\n\n\t\tBlogsEntryAttachmentFileEntryHelper\n\t\t\tblogsEntryAttachmentFileEntryHelper =\n\t\t\t\tnew BlogsEntryAttachmentFileEntryHelper();\n\n\t\tif (fileEntry.isRepositoryCapabilityProvided(\n\t\t\t\tTemporaryFileEntriesCapability.class)) {\n\n\t\t\tFolder folder = addAttachmentsFolder(userId, groupId);\n\n\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getContentStream());\n\t\t}\n\n\t\tFile file = null;\n\n\t\ttry {\n\t\t\tImageBag imageBag = ImageToolUtil.read(\n\t\t\t\tfileEntry.getContentStream());\n\n\t\t\tRenderedImage renderedImage = imageBag.getRenderedImage();\n\n\t\t\tBlogsGroupServiceSettings blogsGroupServiceSettings =\n\t\t\t\tBlogsGroupServiceSettings.getInstance(groupId);\n\n\t\t\trenderedImage = ImageToolUtil.scale(\n\t\t\t\trenderedImage, blogsGroupServiceSettings.getSmallImageWidth());\n\n\t\t\tbyte[] bytes = ImageToolUtil.getBytes(\n\t\t\t\trenderedImage, imageBag.getType());\n\n\t\t\tfile = FileUtil.createTempFile(bytes);\n\n\t\t\tString title = imageSelector.getTitle();\n\n\t\t\tif (Validator.isNull(title)) {\n\t\t\t\ttitle =\n\t\t\t\t\tStringUtil.randomString() + \"_tempScaledImage_\" + entryId;\n\t\t\t}\n\n\t\t\tFolder folder = addSmallImageFolder(userId, groupId);\n\n\t\t\tFileEntry smallImageFileEntry =\n\t\t\t\tblogsEntryAttachmentFileEntryHelper.\n\t\t\t\t\taddBlogsEntryAttachmentFileEntry(\n\t\t\t\t\t\tgroupId, userId, entryId, folder.getFolderId(), title,\n\t\t\t\t\t\timageSelector.getMimeType(), file);\n\n\t\t\treturn smallImageFileEntry.getFileEntryId();\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new EntrySmallImageScaleException();\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.delete(file);\n\t\t}\n\t}","commit_id":"dff7af212d27cd4d14279f178bb8f0c971db1776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, String coverImageCaption,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(entry, serviceContext.getModelPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tlong deletePreviousCoverImageFileEntryId = 0;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImageFileEntry(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tFileEntry tempSmallImageFileEntry = null;\n\n\t\tlong deletePreviousSmallImageFileEntryId = 0;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\tif (smallImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\t\tsmallImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageCaption(coverImageCaption);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif (deletePreviousCoverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousCoverImageFileEntryId);\n\t\t}\n\n\t\tif (deletePreviousSmallImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousSmallImageFileEntryId);\n\t\t}\n\n\t\tif ((coverImageImageSelector != null) &&\n\t\t\t(coverImageImageSelector.getImageId() != 0) &&\n\t\t\t(coverImageImageSelector.getImageId() !=\n\t\t\t\tentry.getCoverImageFileEntryId())) {\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t}\n\n\t\tif (tempSmallImageFileEntry != null) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\ttempSmallImageFileEntry.getFileEntryId());\n\t\t}\n\n\t\treturn entry;\n\t}","id":85911,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String subtitle,\n\t\t\tString description, String content, Date displayDate,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, String coverImageCaption,\n\t\t\tImageSelector coverImageImageSelector,\n\t\t\tImageSelector smallImageImageSelector,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tvalidate(title, content);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setTitle(title);\n\t\tentry.setSubtitle(subtitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(entry, serviceContext.getModelPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Images\n\n\t\tlong coverImageFileEntryId = entry.getCoverImageFileEntryId();\n\t\tString coverImageURL = entry.getCoverImageURL();\n\n\t\tlong deletePreviousCoverImageFileEntryId = 0;\n\n\t\tif (coverImageImageSelector != null) {\n\t\t\tcoverImageFileEntryId = coverImageImageSelector.getImageId();\n\t\t\tcoverImageURL = coverImageImageSelector.getImageURL();\n\n\t\t\tif (coverImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (coverImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getCoverImageFileEntryId()) {\n\n\t\t\t\tif (entry.getCoverImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousCoverImageFileEntryId =\n\t\t\t\t\t\tentry.getCoverImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\tif (coverImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tcoverImageFileEntryId = addCoverImageFileEntry(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entryId,\n\t\t\t\t\t\tcoverImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean smallImage = entry.isSmallImage();\n\t\tlong smallImageFileEntryId = entry.getSmallImageFileEntryId();\n\t\tString smallImageURL = entry.getSmallImageURL();\n\n\t\tlong deletePreviousSmallImageFileEntryId = 0;\n\n\t\tif (smallImageImageSelector != null) {\n\t\t\tsmallImage = !smallImageImageSelector.isRemoveSmallImage();\n\t\t\tsmallImageFileEntryId = smallImageImageSelector.getImageId();\n\t\t\tsmallImageURL = smallImageImageSelector.getImageURL();\n\n\t\t\tif (smallImageImageSelector.getImageId() == 0) {\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (smallImageImageSelector.getImageId() !=\n\t\t\t\t\t\tentry.getSmallImageFileEntryId()) {\n\n\t\t\t\tif (entry.getSmallImageFileEntryId() != 0) {\n\t\t\t\t\tdeletePreviousSmallImageFileEntryId =\n\t\t\t\t\t\tentry.getSmallImageFileEntryId();\n\t\t\t\t}\n\n\t\t\t\tif (smallImageImageSelector.getImageId() != 0) {\n\t\t\t\t\tsmallImageFileEntryId = addSmallImageFileEntry(\n\t\t\t\t\t\tuserId, entry.getGroupId(), entry.getEntryId(),\n\t\t\t\t\t\tsmallImageImageSelector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvalidate(smallImageFileEntryId);\n\n\t\tentry.setCoverImageCaption(coverImageCaption);\n\t\tentry.setCoverImageFileEntryId(coverImageFileEntryId);\n\t\tentry.setCoverImageURL(coverImageURL);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageFileEntryId(smallImageFileEntryId);\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\tif (deletePreviousCoverImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousCoverImageFileEntryId);\n\t\t}\n\n\t\tif (deletePreviousSmallImageFileEntryId != 0) {\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tdeletePreviousSmallImageFileEntryId);\n\t\t}\n\n\t\tif ((coverImageImageSelector != null) &&\n\t\t\t(coverImageImageSelector.getImageId() != 0) &&\n\t\t\t(coverImageImageSelector.getImageId() !=\n\t\t\t\tentry.getCoverImageFileEntryId())) {\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tcoverImageImageSelector.getImageId());\n\t\t}\n\n\t\tif ((smallImageImageSelector != null) &&\n\t\t\t(smallImageImageSelector.getImageId() != 0) &&\n\t\t\t(smallImageImageSelector.getImageId() !=\n\t\t\t\tentry.getCoverImageFileEntryId())) {\n\n\t\t\tPortletFileRepositoryUtil.deletePortletFileEntry(\n\t\t\t\tsmallImageImageSelector.getImageId());\n\t\t}\n\n\t\treturn entry;\n\t}","commit_id":"dff7af212d27cd4d14279f178bb8f0c971db1776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Folder addSmallImageFolder(long userId, long groupId)\n\t\tthrows PortalException {\n\n\t\treturn doAddFolder(userId, groupId, _SMALL_IMAGE_FOLDER_NAME);\n\t}","id":85912,"modified_method":"protected Folder addSmallImageFolder(long userId, long groupId)\n\t\tthrows PortalException {\n\n\t\treturn doAddFolder(userId, groupId, _SMALL_IMAGE_FOLDER_NAME);\n\t}","commit_id":"dff7af212d27cd4d14279f178bb8f0c971db1776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\t\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\t\tblogsEntryAttachmentFileEntryReferences = null;\n\n\t\t\tUploadException uploadException =\n\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\tif (uploadException != null) {\n\t\t\t\tif (uploadException.isExceededLiferayFileItemSizeLimit()) {\n\t\t\t\t\tthrow new LiferayFileItemException();\n\t\t\t\t}\n\t\t\t\telse if (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\tthrow new FileSizeException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD) ||\n\t\t\t\t\t cmd.equals(Constants.UPDATE)) {\n\n\t\t\t\tCallable<Object[]> updateEntryCallable =\n\t\t\t\t\tnew UpdateEntryCallable(actionRequest);\n\n\t\t\t\tObject[] returnValue = TransactionInvokerUtil.invoke(\n\t\t\t\t\t_transactionAttribute, updateEntryCallable);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\t((List<BlogsEntryAttachmentFileEntryReference>)\n\t\t\t\t\t\treturnValue[2]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntries(actionRequest, false);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE_TO_TRASH)) {\n\t\t\t\tdeleteEntries(actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.RESTORE)) {\n\t\t\t\trestoreTrashEntries(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribe(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribe(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tString portletId = HttpUtil.getParameter(redirect, \"p_p_id\", false);\n\n\t\t\tif (Validator.isNotNull(oldUrlTitle)) {\n\t\t\t\tString oldRedirectParam =\n\t\t\t\t\tPortalUtil.getPortletNamespace(portletId) + \"redirect\";\n\n\t\t\t\tString oldRedirect = HttpUtil.getParameter(\n\t\t\t\t\tredirect, oldRedirectParam, false);\n\n\t\t\t\tif (Validator.isNotNull(oldRedirect)) {\n\t\t\t\t\tString newRedirect = HttpUtil.decodeURL(oldRedirect);\n\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldRedirectParam, \"redirect\");\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldRedirect, newRedirect);\n\t\t\t\t}\n\t\t\t\telse if (redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t\t\t redirect.contains(\"/blogs/\" + oldUrlTitle + \"?\") ||\n\t\t\t\t\t\t redirect.contains(\"/blog/\" + oldUrlTitle + \"?\")) {\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t}\n\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tboolean ajax = ParamUtil.getBoolean(actionRequest, \"ajax\");\n\n\t\t\tif (ajax) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\t\t\tfor (BlogsEntryAttachmentFileEntryReference\n\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference :\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReferences) {\n\n\t\t\t\t\tJSONObject blogsEntryFileEntryReferencesJSONObject =\n\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"attributeDataImageId\",\n\t\t\t\t\t\tEditorConstants.ATTRIBUTE_DATA_IMAGE_ID);\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryId\",\n\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntryId()));\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryUrl\",\n\t\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntryURL(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetBlogsEntryAttachmentFileEntry(),\n\t\t\t\t\t\t\tStringPool.BLANK));\n\n\t\t\t\t\tjsonArray.put(blogsEntryFileEntryReferencesJSONObject);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\"blogsEntryAttachmentReferences\", jsonArray);\n\n\t\t\t\tjsonObject.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\tJSONPortletResponseUtil.writeJSON(\n\t\t\t\t\tactionRequest, actionResponse, jsonObject);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((entry != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tactionRequest, entry, redirect);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\t\tif (!windowState.equals(LiferayWindowState.POP_UP)) {\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tif (cmd.equals(Constants.ADD) && (entry != null)) {\n\t\t\t\t\t\t\tString namespace = PortalUtil.getPortletNamespace(\n\t\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"className\",\n\t\t\t\t\t\t\t\tBlogsEntry.class.getName());\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"classPK\",\n\t\t\t\t\t\t\t\tentry.getEntryId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString mvcPath = \"/blogs/edit_entry.jsp\";\n\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tmvcPath = \"/blogs/error.jsp\";\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryDescriptionException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntrySmallImageNameException ||\n\t\t\t\t\t e instanceof EntrySmallImageScaleException ||\n\t\t\t\t\t e instanceof EntryTitleException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof LiferayFileItemException ||\n\t\t\t\t\t e instanceof SanitizerException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\tif (cause instanceof SanitizerException) {\n\t\t\t\t\tSessionErrors.add(actionRequest, SanitizerException.class);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", mvcPath);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", \"/blogs/error.jsp\");\n\t\t}\n\t}","id":85913,"modified_method":"@Override\n\tprotected void doProcessAction(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tBlogsEntry entry = null;\n\t\t\tString oldUrlTitle = StringPool.BLANK;\n\t\t\tList<BlogsEntryAttachmentFileEntryReference>\n\t\t\t\tblogsEntryAttachmentFileEntryReferences = null;\n\n\t\t\tUploadException uploadException =\n\t\t\t\t(UploadException)actionRequest.getAttribute(\n\t\t\t\t\tWebKeys.UPLOAD_EXCEPTION);\n\n\t\t\tif (uploadException != null) {\n\t\t\t\tif (uploadException.isExceededLiferayFileItemSizeLimit()) {\n\t\t\t\t\tthrow new LiferayFileItemException();\n\t\t\t\t}\n\t\t\t\telse if (uploadException.isExceededSizeLimit()) {\n\t\t\t\t\tthrow new FileSizeException(uploadException.getCause());\n\t\t\t\t}\n\n\t\t\t\tthrow new PortalException(uploadException.getCause());\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.ADD) ||\n\t\t\t\t\t cmd.equals(Constants.UPDATE)) {\n\n\t\t\t\tCallable<Object[]> updateEntryCallable =\n\t\t\t\t\tnew UpdateEntryCallable(actionRequest);\n\n\t\t\t\tObject[] returnValue = TransactionInvokerUtil.invoke(\n\t\t\t\t\t_transactionAttribute, updateEntryCallable);\n\n\t\t\t\tentry = (BlogsEntry)returnValue[0];\n\t\t\t\toldUrlTitle = ((String)returnValue[1]);\n\t\t\t\tblogsEntryAttachmentFileEntryReferences =\n\t\t\t\t\t((List<BlogsEntryAttachmentFileEntryReference>)\n\t\t\t\t\t\treturnValue[2]);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteEntries(actionRequest, false);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.MOVE_TO_TRASH)) {\n\t\t\t\tdeleteEntries(actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.RESTORE)) {\n\t\t\t\trestoreTrashEntries(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE)) {\n\t\t\t\tsubscribe(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE)) {\n\t\t\t\tunsubscribe(actionRequest);\n\t\t\t}\n\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\t\t\tboolean updateRedirect = false;\n\n\t\t\tString portletId = HttpUtil.getParameter(redirect, \"p_p_id\", false);\n\n\t\t\tif (Validator.isNotNull(oldUrlTitle)) {\n\t\t\t\tString oldRedirectParam =\n\t\t\t\t\tPortalUtil.getPortletNamespace(portletId) + \"redirect\";\n\n\t\t\t\tString oldRedirect = HttpUtil.getParameter(\n\t\t\t\t\tredirect, oldRedirectParam, false);\n\n\t\t\t\tif (Validator.isNotNull(oldRedirect)) {\n\t\t\t\t\tString newRedirect = HttpUtil.decodeURL(oldRedirect);\n\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t\tnewRedirect = StringUtil.replace(\n\t\t\t\t\t\tnewRedirect, oldRedirectParam, \"redirect\");\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldRedirect, newRedirect);\n\t\t\t\t}\n\t\t\t\telse if (redirect.endsWith(\"/blogs/\" + oldUrlTitle) ||\n\t\t\t\t\t\t redirect.contains(\"/blogs/\" + oldUrlTitle + \"?\") ||\n\t\t\t\t\t\t redirect.contains(\"/blog/\" + oldUrlTitle + \"?\")) {\n\n\t\t\t\t\tredirect = StringUtil.replace(\n\t\t\t\t\t\tredirect, oldUrlTitle, entry.getUrlTitle());\n\t\t\t\t}\n\n\t\t\t\tupdateRedirect = true;\n\t\t\t}\n\n\t\t\tint workflowAction = ParamUtil.getInteger(\n\t\t\t\tactionRequest, \"workflowAction\",\n\t\t\t\tWorkflowConstants.ACTION_SAVE_DRAFT);\n\n\t\t\tboolean ajax = ParamUtil.getBoolean(actionRequest, \"ajax\");\n\n\t\t\tif (ajax) {\n\t\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\t\t\tfor (BlogsEntryAttachmentFileEntryReference\n\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference :\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReferences) {\n\n\t\t\t\t\tJSONObject blogsEntryFileEntryReferencesJSONObject =\n\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"attributeDataImageId\",\n\t\t\t\t\t\tEditorConstants.ATTRIBUTE_DATA_IMAGE_ID);\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryId\",\n\t\t\t\t\t\tString.valueOf(\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetTempBlogsEntryAttachmentFileEntryId()));\n\t\t\t\t\tblogsEntryFileEntryReferencesJSONObject.put(\n\t\t\t\t\t\t\"fileEntryUrl\",\n\t\t\t\t\t\tPortletFileRepositoryUtil.getPortletFileEntryURL(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tblogsEntryAttachmentFileEntryReference.\n\t\t\t\t\t\t\t\tgetBlogsEntryAttachmentFileEntry(),\n\t\t\t\t\t\t\tStringPool.BLANK));\n\n\t\t\t\t\tjsonArray.put(blogsEntryFileEntryReferencesJSONObject);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\"blogsEntryAttachmentReferences\", jsonArray);\n\n\t\t\t\tjsonObject.put(\"entryId\", entry.getEntryId());\n\t\t\t\tjsonObject.put(\"redirect\", redirect);\n\t\t\t\tjsonObject.put(\"updateRedirect\", updateRedirect);\n\n\t\t\t\tJSONPortletResponseUtil.writeJSON(\n\t\t\t\t\tactionRequest, actionResponse, jsonObject);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((entry != null) &&\n\t\t\t\t(workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT)) {\n\n\t\t\t\tredirect = getSaveAndContinueRedirect(\n\t\t\t\t\tactionRequest, entry, redirect);\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tWindowState windowState = actionRequest.getWindowState();\n\n\t\t\t\tif (!windowState.equals(LiferayWindowState.POP_UP)) {\n\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tredirect = PortalUtil.escapeRedirect(redirect);\n\n\t\t\t\t\tif (Validator.isNotNull(redirect)) {\n\t\t\t\t\t\tif (cmd.equals(Constants.ADD) && (entry != null)) {\n\t\t\t\t\t\t\tString namespace = PortalUtil.getPortletNamespace(\n\t\t\t\t\t\t\t\tportletId);\n\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"className\",\n\t\t\t\t\t\t\t\tBlogsEntry.class.getName());\n\t\t\t\t\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\t\t\t\t\tredirect, namespace + \"classPK\",\n\t\t\t\t\t\t\t\tentry.getEntryId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tString mvcPath = \"/blogs/edit_entry.jsp\";\n\n\t\t\tif (e instanceof NoSuchEntryException ||\n\t\t\t\te instanceof PrincipalException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\n\t\t\t\tmvcPath = \"/blogs/error.jsp\";\n\t\t\t}\n\t\t\telse if (e instanceof EntryContentException ||\n\t\t\t\t\t e instanceof EntryCoverImageCropException ||\n\t\t\t\t\t e instanceof EntryDescriptionException ||\n\t\t\t\t\t e instanceof EntryDisplayDateException ||\n\t\t\t\t\t e instanceof EntrySmallImageNameException ||\n\t\t\t\t\t e instanceof EntrySmallImageScaleException ||\n\t\t\t\t\t e instanceof EntryTitleException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof LiferayFileItemException ||\n\t\t\t\t\t e instanceof SanitizerException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass());\n\t\t\t}\n\t\t\telse if (e instanceof AssetCategoryException ||\n\t\t\t\t\t e instanceof AssetTagException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass(), e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\tif (cause instanceof SanitizerException) {\n\t\t\t\t\tSessionErrors.add(actionRequest, SanitizerException.class);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", mvcPath);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\t_log.error(t, t);\n\n\t\t\tactionResponse.setRenderParameter(\"mvcPath\", \"/blogs/error.jsp\");\n\t\t}\n\t}","commit_id":"dff7af212d27cd4d14279f178bb8f0c971db1776","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List getExtensions() {\n    return ImmutableList.of(\n        CpdSensor.class,\n        SumDuplicationsDecorator.class,\n        DuplicationDensityDecorator.class,\n        IndexFactory.class,\n        SonarEngine.class,\n        SonarBridgeEngine.class);\n  }","id":85914,"modified_method":"public List getExtensions() {\n    return ImmutableList.of(\n        PropertyDefinition.build(CoreProperties.CPD_CROSS_RPOJECT)\n            .defaultValue(CoreProperties.CPD_CROSS_RPOJECT_DEFAULT_VALUE + \"\")\n            .name(\"Cross project duplication detection\")\n            .description(\"Sonar supports the detection of cross project duplications. Activating this property will slightly increase each Sonar analysis time.\")\n            .qualifiers(Qualifiers.PROJECT, Qualifiers.MODULE)\n            .global(true)\n            .category(CoreProperties.CATEGORY_DUPLICATIONS)\n            .type(PropertyType.BOOLEAN)\n            .build(),\n        PropertyDefinition.build(CoreProperties.CPD_SKIP_PROPERTY)\n            .defaultValue(\"false\")\n            .name(\"Skip\")\n            .description(\"Disable detection of duplications\")\n            .global(false)\n            .category(CoreProperties.CATEGORY_DUPLICATIONS)\n            .type(PropertyType.BOOLEAN)\n            .build(),\n        PropertyDefinition.build(CoreProperties.CPD_EXCLUSIONS)\n            .defaultValue(\"\")\n            .name(\"Duplication exclusions\")\n            .description(\"Patterns used to exclude some source files from the duplication detection mechanism. \" +\n                \"See the \\\"Exclusions\\\" category to know how to use wildcards to specify this property.\")\n            .qualifiers(Qualifiers.PROJECT, Qualifiers.MODULE)\n            .global(true)\n            .category(CoreProperties.CATEGORY_DUPLICATIONS)\n            .multiValues(true)\n            .build(),\n\n        CpdSensor.class,\n        SumDuplicationsDecorator.class,\n        DuplicationDensityDecorator.class,\n        IndexFactory.class,\n        SonarEngine.class,\n        SonarBridgeEngine.class);\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void getExtensions() {\n    assertThat(new CpdPlugin().getExtensions()).hasSize(6);\n  }","id":85915,"modified_method":"@Test\n  public void getExtensions() {\n    assertThat(new CpdPlugin().getExtensions()).hasSize(9);\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static Builder build(String key) {\n    return new Builder(key);\n  }","id":85916,"modified_method":"/**\n   * @since 3.6\n   */\n  public static Builder build(String key) {\n    return new Builder(key);\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private PropertyDefinition(Builder builder) {\n    this.key = builder.key;\n    this.name = builder.name;\n    this.description = builder.description;\n    this.defaultValue = builder.defaultValue;\n    this.category = builder.category;\n    this.global = builder.global;\n    this.type = builder.type;\n    this.options = builder.options;\n    this.multiValues = builder.multiValues;\n    this.propertySetKey = builder.propertySetKey;\n    this.fields = builder.fields;\n    this.deprecatedKey = builder.deprecatedKey;\n    this.qualifiers = builder.qualifiers;\n  }","id":85917,"modified_method":"/**\n   * @since 3.6\n   */\n  private PropertyDefinition(Builder builder) {\n    this.key = builder.key;\n    this.name = builder.name;\n    this.description = builder.description;\n    this.defaultValue = builder.defaultValue;\n    this.category = builder.category;\n    this.global = builder.global;\n    this.type = builder.type;\n    this.options = builder.options;\n    this.multiValues = builder.multiValues;\n    this.propertySetKey = builder.propertySetKey;\n    this.fields = builder.fields;\n    this.deprecatedKey = builder.deprecatedKey;\n    this.qualifiers = builder.qualifiers;\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"static PropertyDefinition create(Property annotation) {\n    return PropertyDefinition.build(annotation.key())\n        .name(annotation.name())\n        .defaultValue(annotation.defaultValue())\n        .description(annotation.description())\n        .global(annotation.global())\n        .project(annotation.project())\n        .module(annotation.module())\n        .category(annotation.category())\n        .type(annotation.type())\n        .options(annotation.options())\n        .multiValues(annotation.multiValues())\n        .propertySetKey(annotation.propertySetKey())\n        .fields(PropertyFieldDefinition.create(annotation.fields()))\n        .deprecatedKey(annotation.deprecatedKey())\n        .build();\n  }","id":85918,"modified_method":"/**\n   * @since 3.6\n   */\n  static PropertyDefinition create(Property annotation) {\n    List<String> qualifiers = newArrayList();\n    if (annotation.project()) {\n      qualifiers.add(Qualifiers.PROJECT);\n    }\n    if (annotation.module()) {\n      qualifiers.add(Qualifiers.MODULE);\n    }\n    return PropertyDefinition.build(annotation.key())\n        .name(annotation.name())\n        .defaultValue(annotation.defaultValue())\n        .description(annotation.description())\n        .global(annotation.global())\n        .qualifiers(qualifiers)\n        .category(annotation.category())\n        .type(annotation.type())\n        .options(annotation.options())\n        .multiValues(annotation.multiValues())\n        .propertySetKey(annotation.propertySetKey())\n        .fields(PropertyFieldDefinition.create(annotation.fields()))\n        .deprecatedKey(annotation.deprecatedKey())\n        .build();\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_create_property_with_default_values() {\n    PropertyDefinition def = PropertyDefinition.build(\"hello\")\n        .name(\"Hello\")\n        .build();\n\n    assertThat(def.key()).isEqualTo(\"hello\");\n    assertThat(def.name()).isEqualTo(\"Hello\");\n    assertThat(def.defaultValue()).isEmpty();\n    assertThat(def.category()).isEmpty();\n    assertThat(def.options()).isEmpty();\n    assertThat(def.description()).isEmpty();\n    assertThat(def.type()).isEqualTo(PropertyType.STRING);\n    assertThat(def.global()).isTrue();\n    assertThat(def.qualifiers()).isEmpty();\n    assertThat(def.project()).isFalse();\n    assertThat(def.module()).isFalse();\n    assertThat(def.multiValues()).isFalse();\n    assertThat(def.propertySetKey()).isEmpty();\n    assertThat(def.fields()).isEmpty();\n  }","id":85919,"modified_method":"@Test\n  public void should_create_property_with_default_values() {\n    PropertyDefinition def = PropertyDefinition.build(\"hello\")\n        .name(\"Hello\")\n        .build();\n\n    assertThat(def.key()).isEqualTo(\"hello\");\n    assertThat(def.name()).isEqualTo(\"Hello\");\n    assertThat(def.defaultValue()).isEmpty();\n    assertThat(def.category()).isEmpty();\n    assertThat(def.options()).isEmpty();\n    assertThat(def.description()).isEmpty();\n    assertThat(def.type()).isEqualTo(PropertyType.STRING);\n    assertThat(def.global()).isTrue();\n    assertThat(def.qualifiers()).isEmpty();\n    assertThat(def.multiValues()).isFalse();\n    assertThat(def.propertySetKey()).isEmpty();\n    assertThat(def.fields()).isEmpty();\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_create_from_annotation_default_values() {\n    Properties props = AnnotationUtils.getAnnotation(DefaultValues.class, Properties.class);\n    Property prop = props.value()[0];\n\n    PropertyDefinition def = PropertyDefinition.create(prop);\n\n    assertThat(def.key()).isEqualTo(\"hello\");\n    assertThat(def.name()).isEqualTo(\"Hello\");\n    assertThat(def.defaultValue()).isEmpty();\n    assertThat(def.category()).isEmpty();\n    assertThat(def.options()).isEmpty();\n    assertThat(def.description()).isEmpty();\n    assertThat(def.type()).isEqualTo(PropertyType.STRING);\n    assertThat(def.global()).isTrue();\n    assertThat(def.project()).isFalse();\n    assertThat(def.module()).isFalse();\n    assertThat(def.multiValues()).isFalse();\n    assertThat(def.propertySetKey()).isEmpty();\n    assertThat(def.fields()).isEmpty();\n  }","id":85920,"modified_method":"@Test\n  public void should_create_from_annotation_default_values() {\n    Properties props = AnnotationUtils.getAnnotation(DefaultValues.class, Properties.class);\n    Property prop = props.value()[0];\n\n    PropertyDefinition def = PropertyDefinition.create(prop);\n\n    assertThat(def.key()).isEqualTo(\"hello\");\n    assertThat(def.name()).isEqualTo(\"Hello\");\n    assertThat(def.defaultValue()).isEmpty();\n    assertThat(def.category()).isEmpty();\n    assertThat(def.options()).isEmpty();\n    assertThat(def.description()).isEmpty();\n    assertThat(def.type()).isEqualTo(PropertyType.STRING);\n    assertThat(def.global()).isTrue();\n    assertThat(def.qualifiers()).isEmpty();\n    assertThat(def.multiValues()).isFalse();\n    assertThat(def.propertySetKey()).isEmpty();\n    assertThat(def.fields()).isEmpty();\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_create_from_annotation() {\n    Properties props = AnnotationUtils.getAnnotation(Init.class, Properties.class);\n    Property prop = props.value()[0];\n\n    PropertyDefinition def = PropertyDefinition.create(prop);\n\n    assertThat(def.key()).isEqualTo(\"hello\");\n    assertThat(def.name()).isEqualTo(\"Hello\");\n    assertThat(def.defaultValue()).isEqualTo(\"world\");\n    assertThat(def.category()).isEqualTo(\"categ\");\n    assertThat(def.options()).containsOnly(\"de\", \"en\");\n    assertThat(def.description()).isEqualTo(\"desc\");\n    assertThat(def.type()).isEqualTo(PropertyType.FLOAT);\n    assertThat(def.global()).isFalse();\n    assertThat(def.project()).isTrue();\n    assertThat(def.module()).isTrue();\n    assertThat(def.multiValues()).isTrue();\n    assertThat(def.propertySetKey()).isEqualTo(\"set\");\n    assertThat(def.fields()).isEmpty();\n  }","id":85921,"modified_method":"@Test\n  public void should_create_from_annotation() {\n    Properties props = AnnotationUtils.getAnnotation(Init.class, Properties.class);\n    Property prop = props.value()[0];\n\n    PropertyDefinition def = PropertyDefinition.create(prop);\n\n    assertThat(def.key()).isEqualTo(\"hello\");\n    assertThat(def.name()).isEqualTo(\"Hello\");\n    assertThat(def.defaultValue()).isEqualTo(\"world\");\n    assertThat(def.category()).isEqualTo(\"categ\");\n    assertThat(def.options()).containsOnly(\"de\", \"en\");\n    assertThat(def.description()).isEqualTo(\"desc\");\n    assertThat(def.type()).isEqualTo(PropertyType.FLOAT);\n    assertThat(def.global()).isFalse();\n    assertThat(def.qualifiers()).containsOnly(Qualifiers.PROJECT, Qualifiers.MODULE);\n    assertThat(def.multiValues()).isTrue();\n    assertThat(def.propertySetKey()).isEqualTo(\"set\");\n    assertThat(def.fields()).isEmpty();\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_group_by_category() {\n    PropertyDefinitions def = new PropertyDefinitions(\n        PropertyDefinition.build(\"global1\").name(\"Global1\").category(\"catGlobal1\").global(true).project(false).module(false).build(),\n        PropertyDefinition.build(\"global2\").name(\"Global2\").category(\"catGlobal1\").global(true).project(false).module(false).build(),\n        PropertyDefinition.build(\"global3\").name(\"Global3\").category(\"catGlobal2\").global(true).project(false).module(false).build(),\n        PropertyDefinition.build(\"project\").name(\"Project\").category(\"catProject\").global(false).project(true).module(false).build(),\n        PropertyDefinition.build(\"module\").name(\"Module\").category(\"catModule\").global(false).project(false).module(true).build(),\n        PropertyDefinition.build(\"view\").name(\"View\").category(\"catView\").global(false).qualifiers(Qualifiers.VIEW).build()\n    );\n\n    assertThat(def.getPropertiesByCategory(null).keySet()).containsOnly(\"catGlobal1\", \"catGlobal2\");\n    assertThat(def.getPropertiesByCategory(Qualifiers.PROJECT).keySet()).containsOnly(\"catProject\");\n    assertThat(def.getPropertiesByCategory(Qualifiers.MODULE).keySet()).containsOnly(\"catModule\");\n    assertThat(def.getPropertiesByCategory(Qualifiers.VIEW).keySet()).containsOnly(\"catView\");\n    assertThat(def.getPropertiesByCategory(\"Unkown\").keySet()).isEmpty();\n  }","id":85922,"modified_method":"@Test\n  public void should_group_by_category() {\n    PropertyDefinitions def = new PropertyDefinitions(\n        PropertyDefinition.build(\"global1\").name(\"Global1\").category(\"catGlobal1\").global(true).build(),\n        PropertyDefinition.build(\"global2\").name(\"Global2\").category(\"catGlobal1\").global(true).build(),\n        PropertyDefinition.build(\"global3\").name(\"Global3\").category(\"catGlobal2\").global(true).build(),\n        PropertyDefinition.build(\"project\").name(\"Project\").category(\"catProject\").global(false).qualifiers(Qualifiers.PROJECT).build(),\n        PropertyDefinition.build(\"module\").name(\"Module\").category(\"catModule\").global(false).qualifiers(Qualifiers.MODULE).build(),\n        PropertyDefinition.build(\"view\").name(\"View\").category(\"catView\").global(false).qualifiers(Qualifiers.VIEW).build()\n    );\n\n    assertThat(def.getPropertiesByCategory(null).keySet()).containsOnly(\"catGlobal1\", \"catGlobal2\");\n    assertThat(def.getPropertiesByCategory(Qualifiers.PROJECT).keySet()).containsOnly(\"catProject\");\n    assertThat(def.getPropertiesByCategory(Qualifiers.MODULE).keySet()).containsOnly(\"catModule\");\n    assertThat(def.getPropertiesByCategory(Qualifiers.VIEW).keySet()).containsOnly(\"catView\");\n    assertThat(def.getPropertiesByCategory(\"Unkown\").keySet()).isEmpty();\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private String getLogin() {\n    return settings.property(CoreProperties.LOGIN) != null ? settings.property(CoreProperties.LOGIN) : DEFAULT_LOGIN;\n  }","id":85923,"modified_method":"private String getLogin() {\n    String login = settings.property(CoreProperties.LOGIN);\n    return login != null ? login : DEFAULT_LOGIN;\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private String getPassword() {\n    return settings.property(CoreProperties.PASSWORD) != null ? settings.property(CoreProperties.PASSWORD) : DEFAULT_PASSWORD;\n  }","id":85924,"modified_method":"private String getPassword() {\n    String password = settings.property(CoreProperties.PASSWORD);\n    return password != null ? password : DEFAULT_PASSWORD;\n  }","commit_id":"6f2f4aa5db7b4cbd9f88e02badf52bf7066b0cbc","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Ghostway(UUID ownerId) {\r\n        super(ownerId, 6, \"Ghostway\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{2}{W}\");\r\n        this.expansionSetCode = \"GPT\";\r\n\r\n        this.color.setWhite(true);\r\n\r\n        // Exile each creature you control. Return those cards to the battlefield under their owner's control at the beginning of the next end step.\r\n        this.getSpellAbility().addEffect(new GhostwayEffect());\r\n    }","id":85925,"modified_method":"public Ghostway(UUID ownerId) {\r\n        super(ownerId, 6, \"Ghostway\", Rarity.RARE, new CardType[]{CardType.INSTANT}, \"{2}{W}\");\r\n        this.expansionSetCode = \"GPT\";\r\n\r\n        // Exile each creature you control. Return those cards to the battlefield under their owner's control at the beginning of the next end step.\r\n        this.getSpellAbility().addEffect(new GhostwayEffect());\r\n    }","commit_id":"c681f1583cddb9eb2be282baca3c62fd7859ee74","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        UUID exileId = source.getSourceId();\r\n        if (exileId != null) {\r\n            for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), game)) {\r\n                if (creature != null) {\r\n                    if (creature.moveToExile(source.getSourceId(), \"Ghostway Exile\", source.getSourceId(), game)) {\r\n                        AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(), Zone.BATTLEFIELD, true));\r\n                        delayedAbility.setSourceId(source.getSourceId());\r\n                        delayedAbility.setControllerId(source.getControllerId());\r\n                        delayedAbility.setSourceObject(source.getSourceObject(game));\r\n                        game.addDelayedTriggeredAbility(delayedAbility);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":85926,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = source.getSourceObject(game);\r\n        if (sourceObject != null && controller != null) {\r\n            int numberCreatures = 0;\r\n            UUID exileId = CardUtil.getObjectExileZoneId(game, sourceObject);\r\n            for (Permanent creature : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), game)) {\r\n                if (creature != null) {\r\n                    controller.moveCardToExileWithInfo(creature, exileId,sourceObject.getLogName(), source.getSourceId(), game, Zone.BATTLEFIELD);\r\n                    numberCreatures++;\r\n                }\r\n            }\r\n            if (numberCreatures > 0) {\r\n                AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(\r\n                        new ReturnFromExileEffect(exileId, Zone.BATTLEFIELD, false));\r\n                delayedAbility.setSourceId(source.getSourceId());\r\n                delayedAbility.setControllerId(source.getControllerId());\r\n                delayedAbility.setSourceObject(source.getSourceObject(game));\r\n                game.addDelayedTriggeredAbility(delayedAbility);                \r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"c681f1583cddb9eb2be282baca3c62fd7859ee74","url":"https://github.com/magefree/mage"},{"original_method":"public DistortionStrike(UUID ownerId) {\r\n        super(ownerId, 60, \"Distortion Strike\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{U}\");\r\n        this.expansionSetCode = \"ROE\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Target creature gets +1/+0 until end of turn and is unblockable this turn.\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n        this.getSpellAbility().addEffect(new BoostTargetEffect(1, 0, Duration.EndOfTurn));\r\n        this.getSpellAbility().addEffect(new UnblockableTargetEffect());\r\n        // Rebound\r\n        this.addAbility(new ReboundAbility());\r\n    }","id":85927,"modified_method":"public DistortionStrike(UUID ownerId) {\r\n        super(ownerId, 60, \"Distortion Strike\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{U}\");\r\n        this.expansionSetCode = \"ROE\";\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Target creature gets +1/+0 until end of turn and is unblockable this turn.\r\n        this.getSpellAbility().addTarget(new TargetCreaturePermanent());\r\n        this.getSpellAbility().addEffect(new BoostTargetEffect(1, 0, Duration.EndOfTurn));\r\n        Effect effect = new UnblockableTargetEffect();\r\n        effect.setText(\"and is unblockable this turn\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        // Rebound\r\n        this.addAbility(new ReboundAbility());\r\n    }","commit_id":"63eae70d63f4ac3cf0625a1d9dd5c1d2ff8dff1c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (event.getType() == GameEvent.EventType.TARGET) {\r\n            Card targetCard = game.getCard(event.getTargetId());\r\n            StackObject stackObject = (StackObject) game.getStack().getStackObject(event.getSourceId());\r\n            if (targetCard != null && stackObject != null) {\r\n                Zone zone = game.getState().getZone(targetCard.getId());\r\n                if (zone != null && (zone == Zone.GRAVEYARD)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":85928,"modified_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (event.getType() == GameEvent.EventType.TARGET) {\r\n            Card targetCard = game.getCard(event.getTargetId());\r\n            StackObject stackObject = (StackObject) game.getStack().getStackObject(event.getSourceId());\r\n            if (targetCard != null && stackObject != null) {\r\n                Zone zone = game.getState().getZone(targetCard.getId());\r\n                if (zone != null && zone.equals(Zone.GRAVEYARD)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"63eae70d63f4ac3cf0625a1d9dd5c1d2ff8dff1c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        Spell sourceSpell = (Spell) game.getObject(source.getId());\n        if (sourceSpell != null && sourceSpell.isCopiedSpell()) {\n            return false;\n        } else {\n            Card sourceCard = (Card) game.getObject(source.getSourceId());\n            Player player = game.getPlayer(sourceCard.getOwnerId());\n\n            sourceCard.moveToExile(this.cardId, player.getName() + \" Rebound Exile\", source.getId(), game);\n            this.used = true;\n\n            return true;\n        }\n    }","id":85929,"modified_method":"@Override\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\n        Spell sourceSpell = (Spell) game.getObject(source.getId());\n        if (sourceSpell != null && sourceSpell.isCopiedSpell()) {\n            return false;\n        } else {\n            Card sourceCard = (Card) game.getObject(source.getSourceId());\n            Player player = game.getPlayer(sourceCard.getOwnerId());\n            if (player != null) {\n                player.moveCardToExileWithInfo(sourceCard, this.cardId, new StringBuilder(player.getName()).append(\" Rebound\").toString(), source.getSourceId(), game, Zone.HAND);\n                this.used = true;\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"63eae70d63f4ac3cf0625a1d9dd5c1d2ff8dff1c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public String getText(Mode mode) {\r\n        if (mode.getTargets().isEmpty()) {\r\n            return \"\";\r\n        }\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        Target target = mode.getTargets().get(0);\r\n        if (target.getMaxNumberOfTargets() > 1) {\r\n            if (target.getMaxNumberOfTargets() != target.getNumberOfTargets()) {\r\n                sb.append(\"up to \");\r\n            }\r\n            sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(\" \");\r\n        }\r\n        sb.append(\"target \").append(mode.getTargets().get(0).getTargetName());\r\n        if (target.getMaxNumberOfTargets() > 1) {\r\n            sb.append(\"s are unblockable\");\r\n        } else {\r\n            sb.append(\" is unblockable\");\r\n        }\r\n\r\n        if (Duration.EndOfTurn.equals(this.duration)) {\r\n            sb.append(\" this turn\");\r\n        }\r\n\r\n        return sb.toString();\r\n    }","id":85930,"modified_method":"@Override\r\n    public String getText(Mode mode) {\r\n        if (staticText != null && !staticText.isEmpty()) {\r\n            return staticText;\r\n        }\r\n        if (mode.getTargets().isEmpty()) {\r\n            return \"\";\r\n        }\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        Target target = mode.getTargets().get(0);\r\n        if (target.getMaxNumberOfTargets() > 1) {\r\n            if (target.getMaxNumberOfTargets() != target.getNumberOfTargets()) {\r\n                sb.append(\"up to \");\r\n            }\r\n            sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(\" \");\r\n        }\r\n        sb.append(\"target \").append(mode.getTargets().get(0).getTargetName());\r\n        if (target.getMaxNumberOfTargets() > 1) {\r\n            sb.append(\"s are unblockable\");\r\n        } else {\r\n            sb.append(\" is unblockable\");\r\n        }\r\n\r\n        if (Duration.EndOfTurn.equals(this.duration)) {\r\n            sb.append(\" this turn\");\r\n        }\r\n\r\n        return sb.toString();\r\n    }","commit_id":"63eae70d63f4ac3cf0625a1d9dd5c1d2ff8dff1c","url":"https://github.com/magefree/mage"},{"original_method":"public MartyrOfSands(UUID ownerId) {\r\n        super(ownerId, 15, \"Martyr of Sands\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{W}\");\r\n        this.expansionSetCode = \"CSP\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Cleric\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // {1}, Reveal X white cards from your hand, Sacrifice Martyr of Sands: You gain three times X life.\r\n        Effect effect = new GainLifeEffect(new MultipliedValue(new RevealTargetFromHandCostCount(), 3));\r\n        effect.setText(\"You gain three times X life.\");\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl(\"{1}\"));\r\n        ability.addCost(new RevealTargetFromHandCost(new TargetCardInHand(0, Integer.MAX_VALUE, filter)));\r\n        ability.addCost(new SacrificeSourceCost());\r\n        this.addAbility(ability);\r\n    }","id":85931,"modified_method":"public MartyrOfSands(UUID ownerId) {\r\n        super(ownerId, 15, \"Martyr of Sands\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{W}\");\r\n        this.expansionSetCode = \"CSP\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Cleric\");\r\n\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // {1}, Reveal X white cards from your hand, Sacrifice Martyr of Sands: You gain three times X life.\r\n        Effect effect = new GainLifeEffect(new MultipliedValue(new RevealTargetFromHandCostCount(), 3));\r\n        effect.setText(\"You gain three times X life.\");\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl(\"{1}\"));\r\n        ability.addCost(new RevealTargetFromHandCost(new TargetCardInHand(0, Integer.MAX_VALUE, filter)));\r\n        ability.addCost(new SacrificeSourceCost());\r\n        this.addAbility(ability);\r\n    }","commit_id":"5915259e9677d3a70ba819406ef1143d940df968","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));\r\n        if (spell != null) {\r\n            if (spell.moveToExile(source.getSourceId(), \"Possibility Storm Exile\", source.getSourceId(), game)) {\r\n                Player player = game.getPlayer(spell.getControllerId());\r\n                if (player != null && player.getLibrary().size() > 0) {\r\n                    Library library = player.getLibrary();\r\n                    Card card;\r\n                    do {\r\n                        card = library.removeFromTop(game);\r\n                        if (card != null) {\r\n                            card.moveToExile(source.getSourceId(), \"Possibility Storm Exile\", source.getSourceId(), game);\r\n                        }\r\n                    } while (library.size() > 0 && card != null && !sharesType(card, spell.getCardType()));\r\n\r\n                    if (card != null && sharesType(card, spell.getCardType())) {\r\n                        if(player.chooseUse(Outcome.PlayForFree, new StringBuilder(\"Cast \").append(card.getName()).append(\" without paying cost?\").toString(), game)) {\r\n                            player.cast(card.getSpellAbility(), game, true);\r\n                        }\r\n                    }\r\n\r\n                    ExileZone exile = game.getExile().getExileZone(source.getSourceId());\r\n                    if (exile != null) {\r\n                        while (exile.size() > 0) {\r\n                            card = exile.getRandom(game);\r\n                            exile.remove(card.getId());\r\n                            card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, false);\r\n                        }\r\n                    }\r\n\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":85932,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));\r\n        MageObject sourceObject = source.getSourceObject(game);        \r\n        if (sourceObject != null && spell != null) {\r\n            Player spellController = game.getPlayer(spell.getControllerId());\r\n            if (spellController != null &&\r\n                spellController.moveCardToExileWithInfo(spell, source.getSourceId(), sourceObject.getName(), source.getSourceId(), game, Zone.STACK)) {\r\n                if (spellController.getLibrary().size() > 0) {\r\n                    Library library = spellController.getLibrary();\r\n                    Card card;\r\n                    do {\r\n                        card = library.removeFromTop(game);\r\n                        if (card != null) {\r\n                            spellController.moveCardToExileWithInfo(card, source.getSourceId(), sourceObject.getName(), source.getSourceId(), game, Zone.LIBRARY);\r\n                        }\r\n                    } while (library.size() > 0 && card != null && !sharesType(card, spell.getCardType()));\r\n\r\n                    if (card != null && sharesType(card, spell.getCardType())) {\r\n                        if (spellController.chooseUse(Outcome.PlayForFree, new StringBuilder(\"Cast \").append(card.getName()).append(\" without paying cost?\").toString(), game)) {\r\n                            spellController.cast(card.getSpellAbility(), game, true);\r\n                        }\r\n                    }\r\n\r\n                    ExileZone exile = game.getExile().getExileZone(source.getSourceId());\r\n                    if (exile != null) {\r\n                        while (exile.size() > 0) {\r\n                            card = exile.getRandom(game);\r\n                            exile.remove(card.getId());\r\n                            spellController.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.EXILED, false, false);\r\n                        }\r\n                    }\r\n\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"5915259e9677d3a70ba819406ef1143d940df968","url":"https://github.com/magefree/mage"},{"original_method":"public PossibilityStorm(UUID ownerId) {\r\n        super(ownerId, 34, \"Possibility Storm\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{R}{R}\");\r\n        this.expansionSetCode = \"DGM\";\r\n\r\n        this.color.setRed(true);\r\n\r\n        // Whenever a player casts a spell from his or her hand, that player exiles it, then exiles cards from\r\n        // the top of his or her library until he or she exiles a card that shares a card type with it. That\r\n        // player may cast that card without paying its mana cost. Then he or she puts all cards exiled with\r\n        // Possibility Storm on the bottom of his or her library in a random order.\r\n        this.addAbility(new PossibilityStormTriggeredAbility());\r\n    }","id":85933,"modified_method":"public PossibilityStorm(UUID ownerId) {\r\n        super(ownerId, 34, \"Possibility Storm\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{R}{R}\");\r\n        this.expansionSetCode = \"DGM\";\r\n\r\n        // Whenever a player casts a spell from his or her hand, that player exiles it, then exiles cards from\r\n        // the top of his or her library until he or she exiles a card that shares a card type with it. That\r\n        // player may cast that card without paying its mana cost. Then he or she puts all cards exiled with\r\n        // Possibility Storm on the bottom of his or her library in a random order.\r\n        this.addAbility(new PossibilityStormTriggeredAbility());\r\n    }","commit_id":"5915259e9677d3a70ba819406ef1143d940df968","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event.getType() == EventType.SPELL_CAST && event.getZone() == Zone.HAND) {\r\n            Spell spell = game.getStack().getSpell(event.getTargetId());\r\n            if (spell != null) {\r\n                for (Effect effect : this.getEffects()) {\r\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":85934,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event.getZone() == Zone.HAND) {\r\n            Spell spell = game.getStack().getSpell(event.getTargetId());\r\n            if (spell != null) {\r\n                for (Effect effect : this.getEffects()) {\r\n                    effect.setTargetPointer(new FixedTarget(event.getTargetId()));\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"5915259e9677d3a70ba819406ef1143d940df968","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana) {\r\n        if (targets.choose(Outcome.Benefit, controllerId, sourceId, game)) {\r\n            convertedManaCosts = 0;\r\n            numberCardsRevealed = 0;\r\n            Player player = game.getPlayer(controllerId);\r\n            Cards cards = new CardsImpl();\r\n            for (UUID targetId : targets.get(0).getTargets()) {\r\n                Card card = player.getHand().get(targetId, game);\r\n                if (card != null) {\r\n                    convertedManaCosts += card.getManaCost().convertedManaCost();\r\n                    numberCardsRevealed++;\r\n                    cards.add(card);\r\n                }\r\n                player.revealCards(\"card cost\", cards, game);\r\n                paid = true;\r\n                return paid;\r\n            }\r\n            if (!paid && targets.get(0).getNumberOfTargets() == 0) {\r\n                paid = true; // e.g. for optional additional costs.  example: Dragonlord's Prerogative\r\n                return paid;\r\n            }\r\n        }\r\n        paid = false;\r\n        return paid;\r\n    }","id":85935,"modified_method":"@Override\r\n    public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana) {\r\n        if (targets.choose(Outcome.Benefit, controllerId, sourceId, game)) {\r\n            convertedManaCosts = 0;\r\n            numberCardsRevealed = 0;\r\n            Player player = game.getPlayer(controllerId);\r\n            Cards cards = new CardsImpl();\r\n            for (UUID targetId : targets.get(0).getTargets()) {\r\n                Card card = player.getHand().get(targetId, game);\r\n                if (card != null) {\r\n                    convertedManaCosts += card.getManaCost().convertedManaCost();\r\n                    numberCardsRevealed++;\r\n                    cards.add(card);\r\n                }\r\n            }\r\n            if (numberCardsRevealed > 0 ) {\r\n                player.revealCards(\"card cost\", cards, game);\r\n            }\r\n            if (targets.get(0).getNumberOfTargets() <= numberCardsRevealed) {\r\n                paid = true; // e.g. for optional additional costs.  example: Dragonlord's Prerogative also true if 0 cards shown\r\n                return paid;\r\n            }\r\n        }\r\n        paid = false;\r\n        return paid;\r\n    }","commit_id":"5915259e9677d3a70ba819406ef1143d940df968","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (event.getType() == GameEvent.EventType.CAST_SPELL) {\r\n            Player controller = game.getPlayer(source.getControllerId());\r\n            if (controller != null && controller.hasOpponent(event.getPlayerId(), game)) {\r\n                return !game.canPlaySorcery(event.getPlayerId());\r\n            }\r\n        }\r\n        return false;\r\n    }","id":85936,"modified_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null && controller.hasOpponent(event.getPlayerId(), game)) {\r\n            return !game.canPlaySorcery(event.getPlayerId());\r\n        }\r\n        return false;\r\n    }","commit_id":"5915259e9677d3a70ba819406ef1143d940df968","url":"https://github.com/magefree/mage"},{"original_method":"public TeferiMageOfZhalfir(UUID ownerId) {\r\n        super(ownerId, 83, \"Teferi, Mage of Zhalfir\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{U}{U}{U}\");\r\n        this.expansionSetCode = \"TSP\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(4);\r\n\r\n        // Flash\r\n        this.addAbility(FlashAbility.getInstance());\r\n        // Creature cards you own that aren't on the battlefield have flash.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new TeferiMageOfZhalfirAddFlashEffect()));\r\n\r\n        // Each opponent can cast spells only any time he or she could cast a sorcery.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new TeferiMageOfZhalfirReplacementEffect()));\r\n\r\n        \r\n    }","id":85937,"modified_method":"public TeferiMageOfZhalfir(UUID ownerId) {\r\n        super(ownerId, 83, \"Teferi, Mage of Zhalfir\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{2}{U}{U}{U}\");\r\n        this.expansionSetCode = \"TSP\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.power = new MageInt(3);\r\n        this.toughness = new MageInt(4);\r\n\r\n        // Flash\r\n        this.addAbility(FlashAbility.getInstance());\r\n\r\n        // Creature cards you own that aren't on the battlefield have flash.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new TeferiMageOfZhalfirAddFlashEffect()));\r\n\r\n        // Each opponent can cast spells only any time he or she could cast a sorcery.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new TeferiMageOfZhalfirReplacementEffect()));\r\n\r\n        \r\n    }","commit_id":"5915259e9677d3a70ba819406ef1143d940df968","url":"https://github.com/magefree/mage"},{"original_method":"/**\n         * Action when shoe certificate button is clicked.\n         */\n        private void actionShowCertificate()\n        {\n            if(certOpened)\n            {\n                certPanel.removeAll();\n                certButton.setText(GuiActivator.getResources()\n                    .getI18NString(\"service.gui.SHOW_CERT\"));\n\n                certPanel.revalidate();\n                certPanel.repaint();\n                pack();\n                certOpened = false;\n                setLocationRelativeTo(getParent());\n                return;\n            }\n\n            certPanel.setLayout(new BorderLayout());\n            certPanel.add(alwaysTrustCheckBox, BorderLayout.NORTH);\n\n            JTextArea certInfoPane = new JTextArea();\n            certInfoPane.setEditable(false);\n            certInfoPane.setText(cert.toString());\n            final JScrollPane certScroll = new JScrollPane(certInfoPane);\n            certScroll.setPreferredSize(new Dimension(200, 200));\n            certPanel.add(certScroll, BorderLayout.CENTER);\n\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    certScroll.getVerticalScrollBar().setValue(0);\n                }\n            });\n\n            certButton.setText(GuiActivator.getResources()\n                .getI18NString(\"service.gui.HIDE_CERT\"));\n\n            certPanel.revalidate();\n            certPanel.repaint();\n            pack();\n            certOpened = true;\n            setLocationRelativeTo(getParent());\n        }","id":85938,"modified_method":"/**\n         * Action when shoe certificate button is clicked.\n         */\n        private void actionShowCertificate()\n        {\n            if(certOpened)\n            {\n                certPanel.removeAll();\n                certButton.setText(GuiActivator.getResources()\n                    .getI18NString(\"service.gui.SHOW_CERT\"));\n\n                contentPane.revalidate();\n                contentPane.repaint();\n                pack();\n                certOpened = false;\n                setLocationRelativeTo(getParent());\n                return;\n            }\n\n            certPanel.setLayout(new BorderLayout());\n            certPanel.add(alwaysTrustCheckBox, BorderLayout.NORTH);\n\n            Component certInfoPane = null;\n            if(cert instanceof X509Certificate)\n            {\n                certInfoPane = getX509DisplayComponent((X509Certificate)cert);\n            }\n            else\n            {\n                JTextArea textArea = new JTextArea();\n                textArea.setEditable(false);\n                textArea.setText(cert.toString());\n                certInfoPane = textArea;\n            }\n            \n            final JScrollPane certScroll = new JScrollPane(certInfoPane);\n            certScroll.setPreferredSize(new Dimension(300, 300));\n            certPanel.add(certScroll, BorderLayout.CENTER);\n\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    certScroll.getVerticalScrollBar().setValue(0);\n                }\n            });\n\n            certButton.setText(GuiActivator.getResources()\n                .getI18NString(\"service.gui.HIDE_CERT\"));\n\n            contentPane.revalidate();\n            contentPane.repaint();\n            pack();\n            certOpened = true;\n            setLocationRelativeTo(getParent());\n        }","commit_id":"7a6b8a526fb05087caaa782eef0ce6abd09c3ef6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Inits the dialog initial display.\n         */\n        private void init()\n        {\n            this.getContentPane().setLayout(new BorderLayout(5, 5));\n\n            JLabel imgLabel = new JLabel(\n                GuiActivator.getResources().getImage(\n                    \"impl.media.security.zrtp.CONF_ICON\"));\n            imgLabel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n            this.getContentPane().add(imgLabel, BorderLayout.WEST);\n\n            String descriptionTxt = GuiActivator.getResources()\n                .getI18NString(\n                    \"service.gui.CERT_DIALOG_DESCRIPTION_TXT\",\n                    new String[]{\n                        GuiActivator.getResources().getSettingsString(\n                            \"service.gui.APPLICATION_NAME\"),\n                        host,\n                        String.valueOf(port)});\n\n            JTextArea descriptionLabel = new JTextArea();\n            descriptionLabel.setEditable(false);\n            descriptionLabel.setWrapStyleWord(true);\n            descriptionLabel.setLineWrap(true);\n            descriptionLabel.setOpaque(false);\n            descriptionLabel.setText(descriptionTxt);\n            descriptionLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));\n            this.getContentPane().add(descriptionLabel, BorderLayout.CENTER);\n\n            TransparentPanel southPanel =\n                new TransparentPanel(new BorderLayout());\n            southPanel.setBorder(BorderFactory.createEmptyBorder(0, 5, 5, 5));\n\n            certPanel = new TransparentPanel();\n            southPanel.add(certPanel, BorderLayout.CENTER);\n\n            TransparentPanel buttonPanel =\n                new TransparentPanel(new BorderLayout());\n            southPanel.add(buttonPanel, BorderLayout.SOUTH);\n\n            certButton = new JButton();\n            certButton.setText(\"Show Certificate\");\n            certButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    actionShowCertificate();\n                }\n            });\n            TransparentPanel firstButonPanel = \n                new TransparentPanel(new FlowLayout(FlowLayout.LEFT));\n            firstButonPanel.add(certButton);\n            buttonPanel.add(firstButonPanel, BorderLayout.WEST);\n\n            TransparentPanel secondButonPanel =\n                new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));\n            JButton cancelButton = new JButton(\n                GuiActivator.getResources().getI18NString(\"service.gui.CANCEL\"));\n            cancelButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    actionCancel();\n                }\n            });\n            JButton continueButton = new JButton(\n                GuiActivator.getResources().getI18NString(\"service.gui.CONTINUE\"));\n            continueButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    actionContinue();\n                }\n            });\n            secondButonPanel.add(continueButton);\n            secondButonPanel.add(cancelButton);\n            buttonPanel.add(secondButonPanel, BorderLayout.EAST);\n\n            this.getContentPane().add(southPanel, BorderLayout.SOUTH);\n\n            pack();\n        }","id":85939,"modified_method":"/**\n         * Inits the dialog initial display.\n         */\n        private void init()\n        {\n            this.getContentPane().setLayout(new BorderLayout());\n\n            contentPane =\n                new TransparentPanel(new BorderLayout(5, 5));\n\n            TransparentPanel northPanel =\n                new TransparentPanel(new BorderLayout(5, 5));\n            northPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 5, 5));\n\n            JLabel imgLabel = new JLabel(\n                GuiActivator.getResources().getImage(\n                    \"impl.media.security.zrtp.CONF_ICON\"));\n            imgLabel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n            northPanel.add(imgLabel, BorderLayout.WEST);\n\n            String descriptionTxt = GuiActivator.getResources()\n                .getI18NString(\n                    \"service.gui.CERT_DIALOG_DESCRIPTION_TXT\",\n                    new String[]{\n                        GuiActivator.getResources().getSettingsString(\n                            \"service.gui.APPLICATION_NAME\"),\n                        host,\n                        String.valueOf(port)});\n\n            JLabel descriptionLabel = new JLabel(descriptionTxt);\n\n            northPanel.add(descriptionLabel, BorderLayout.CENTER);\n            contentPane.add(northPanel, BorderLayout.NORTH);\n\n            certPanel = new TransparentPanel();\n            contentPane.add(certPanel, BorderLayout.CENTER);\n\n            TransparentPanel southPanel =\n                new TransparentPanel(new BorderLayout());\n            contentPane.add(southPanel, BorderLayout.SOUTH);\n\n            certButton = new JButton();\n            certButton.setText(GuiActivator.getResources()\n                .getI18NString(\"service.gui.SHOW_CERT\"));\n            certButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    actionShowCertificate();\n                }\n            });\n            TransparentPanel firstButonPanel = \n                new TransparentPanel(new FlowLayout(FlowLayout.LEFT));\n            firstButonPanel.add(certButton);\n            southPanel.add(firstButonPanel, BorderLayout.WEST);\n\n            TransparentPanel secondButonPanel =\n                new TransparentPanel(new FlowLayout(FlowLayout.RIGHT));\n            JButton cancelButton = new JButton(\n                GuiActivator.getResources().getI18NString(\"service.gui.CANCEL\"));\n            cancelButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    actionCancel();\n                }\n            });\n            JButton continueButton = new JButton(\n                GuiActivator.getResources().getI18NString(\"service.gui.CONTINUE\"));\n            continueButton.addActionListener(new ActionListener() {\n\n                public void actionPerformed(ActionEvent e)\n                {\n                    actionContinue();\n                }\n            });\n            secondButonPanel.add(continueButton);\n            secondButonPanel.add(cancelButton);\n            southPanel.add(secondButonPanel, BorderLayout.EAST);\n\n            this.getContentPane().add(contentPane, BorderLayout.CENTER);\n\n            pack();\n        }","commit_id":"7a6b8a526fb05087caaa782eef0ce6abd09c3ef6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Creates the dialog.\n         * @param certs\n         * @param host \n         * @param port\n         */\n        public VerifyCertificateDialog(Certificate[] certs, String host, int port)\n        {\n            super(GuiActivator.getUIService().getMainFrame(), false);\n\n            setTitle(GuiActivator.getResources().getI18NString(\n                \"service.gui.CERT_DIALOG_TITLE\"));\n            setModal(true);\n\n            // for now shows only the first certificate from the chain\n            this.cert = certs[0];\n            this.host = host;\n            this.port = port;\n\n            setMinimumSize(new Dimension(600, 200));\n\n            setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\n            init();\n\n            setLocationRelativeTo(getParent());\n        }","id":85940,"modified_method":"/**\n         * Creates the dialog.\n         * @param certs\n         * @param host \n         * @param port\n         */\n        public VerifyCertificateDialog(Certificate[] certs, String host, int port)\n        {\n            super(GuiActivator.getUIService().getMainFrame(), false);\n\n            setTitle(GuiActivator.getResources().getI18NString(\n                \"service.gui.CERT_DIALOG_TITLE\"));\n            setModal(true);\n\n            // for now shows only the first certificate from the chain\n            this.cert = certs[0];\n            this.host = host;\n            this.port = port;\n\n            setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\n            init();\n\n            setLocationRelativeTo(getParent());\n        }","commit_id":"7a6b8a526fb05087caaa782eef0ce6abd09c3ef6","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n   * Constructor.\n   * @param lay layout: horizontal = true, vertical = false\n   */\n  public BaseXSplit(final boolean lay) {\n    layout(this);\n    horiz = lay;\n  }","id":85941,"modified_method":"/**\n   * Constructor.\n   * @param horizontal horizontal/vertical layout\n   */\n  public BaseXSplit(final boolean horizontal) {\n    layout(this);\n    horiz = horizontal;\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Toggles the project view.\n   */\n  public void project() {\n    if(gui.gopts.get(GUIOptions.SHOWPROJECT)) {\n      split.sizes(sizes);\n      focusProject(false);\n    } else {\n      sizes = split.sizes(new double[] { 0, 1 });\n      getEditor().requestFocusInWindow();\n    }\n  }","id":85942,"modified_method":"/**\n   * Toggles the project view.\n   */\n  public void project() {\n    if(gui.gopts.get(GUIOptions.SHOWPROJECT)) {\n      split.sizes(sizes);\n      project.focus();\n    } else {\n      sizes = split.sizes(new double[] { 0, 1 });\n      getEditor().requestFocusInWindow();\n    }\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Focuses the project view.\n   * @param filt focus filter or content\n   */\n  public void focusProject(final boolean filt) {\n    project.focus(filt);\n  }","id":85943,"modified_method":"/**\n   * Focuses the project view.\n   */\n  public void focusProject() {\n    project.focus();\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Closes an editor.\n   * @param edit editor to be closed. {@code null} closes the currently\n   * opened editor.\n   * @return {@code true} if editor was closed\n   */\n  public boolean close(final EditorArea edit) {\n    final EditorArea ea = edit != null ? edit : getEditor();\n    if(!confirm(ea)) return false;\n\n    // remove reference to last executed file\n    if(execFile != null && ea.file.path().equals(execFile.path())) execFile = null;\n    tabs.remove(ea);\n    final int t = tabs.getTabCount();\n    final int i = tabs.getSelectedIndex();\n    if(t == 1) {\n      // no panels left: close search bar\n      search.deactivate(true);\n      // reopen single tab and focus project listener\n      addTab();\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() { focusProject(false); }\n      });\n    } else if(i + 1 == t) {\n      // if necessary, activate last editor tab\n      tabs.setSelectedIndex(i - 1);\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() { getEditor().requestFocusInWindow(); }\n      });\n    }\n    return true;\n  }","id":85944,"modified_method":"/**\n   * Closes an editor.\n   * @param edit editor to be closed. {@code null} closes the currently opened editor.\n   * @return {@code true} if editor was closed\n   */\n  public boolean close(final EditorArea edit) {\n    final EditorArea ea = edit != null ? edit : getEditor();\n    if(!confirm(ea)) return false;\n\n    // remove reference to last executed file\n    if(execFile != null && ea.file.path().equals(execFile.path())) execFile = null;\n    tabs.remove(ea);\n    final int t = tabs.getTabCount();\n    final int i = tabs.getSelectedIndex();\n    if(t == 1) {\n      // no panels left: close search bar\n      search.deactivate(true);\n      // reopen single tab and focus project listener\n      addTab();\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() { project.focus(); }\n      });\n    } else if(i + 1 == t) {\n      // if necessary, activate last editor tab\n      tabs.setSelectedIndex(i - 1);\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() { getEditor().requestFocusInWindow(); }\n      });\n    }\n    return true;\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Refreshes the filter view.\n   * @param force force refresh\n   */\n  void refresh(final boolean force) {\n    final String file = files.getText();\n    final String content = contents.getText();\n    if(!force && lastFiles.equals(file) && lastContents.equals(content)) return;\n    lastFiles = file;\n    lastContents = content;\n    ++threadID;\n\n    final Component oldView = project.scroll.getViewport().getView(), newView;\n    if(file.isEmpty() && content.isEmpty()) {\n      newView = project.tree;\n    } else {\n      newView = project.list;\n      final Thread t = new Thread() {\n        @Override\n        public void run() {\n          filter(file, content, threadID);\n        }\n      };\n      t.setDaemon(true);\n      t.start();\n    }\n    if(oldView != newView) project.scroll.setViewportView(newView);\n  }","id":85945,"modified_method":"/**\n   * Refreshes the filter view.\n   * @param force force refresh\n   */\n  void refresh(final boolean force) {\n    final String file = files.getText();\n    final String content = contents.getText();\n    if(!force && lastFiles.equals(file) && lastContents.equals(content)) return;\n    lastFiles = file;\n    lastContents = content;\n    ++threadID;\n\n    final boolean list = !file.isEmpty() || !content.isEmpty();\n    if(list) {\n      final Thread t = new Thread() {\n        @Override\n        public void run() {\n          filter(file, content, threadID);\n        }\n      };\n      t.setDaemon(true);\n      t.start();\n    }\n    project.showList(list);\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param view project view\n   */\n  ProjectList(final ProjectView view) {\n    project = view;\n    setCellRenderer(new CellRenderer());\n    addMouseListener(new MouseAdapter() {\n      @Override\n      public void mousePressed(final MouseEvent e) {\n        if(SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2) open();\n      }\n    });\n    new BaseXPopup(this, view.gui, commands);\n  }","id":85946,"modified_method":"/**\n   * Constructor.\n   * @param view project view\n   */\n  ProjectList(final ProjectView view) {\n    project = view;\n    setBorder(new EmptyBorder(4, 4, 4, 4));\n    setCellRenderer(new CellRenderer());\n    addMouseListener(new MouseAdapter() {\n      @Override\n      public void mousePressed(final MouseEvent e) {\n        if(SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2) open();\n      }\n    });\n    new BaseXPopup(this, view.gui, commands);\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Changes the root directory.\n   */\n  private void change() {\n    final ProjectNode child = selectedNode();\n    final BaseXFileChooser fc = new BaseXFileChooser(CHOOSE_DIR, child.file.path(), gui);\n    final IOFile io = fc.select(Mode.DOPEN);\n    if(io != null) {\n      root.file = io;\n      root.refresh();\n      filter.reset();\n      path.setText(io.path());\n      gui.gopts.set(GUIOptions.PROJECTPATH, io.path());\n    }\n  }","id":85947,"modified_method":"/**\n   * Changes the root directory.\n   */\n  void change() {\n    final ProjectNode child = tree.selectedNode();\n    final BaseXFileChooser fc = new BaseXFileChooser(CHOOSE_DIR, child.file.path(), gui);\n    final IOFile io = fc.select(Mode.DOPEN);\n    if(io != null) {\n      root.file = io;\n      root.refresh();\n      filter.reset();\n      path.setText(io.path());\n      gui.gopts.set(GUIOptions.PROJECTPATH, io.path());\n    }\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param ev editor view\n   */\n  public ProjectView(final EditorView ev) {\n    super(ev.gui);\n    view = ev;\n    setLayout(new BorderLayout());\n\n    final DefaultMutableTreeNode invisible = new DefaultMutableTreeNode();\n    tree = new BaseXTree(invisible, gui).border(4, 4, 4, 4);\n    renderer = new ProjectCellRenderer();\n    tree.setExpandsSelectedPaths(true);\n    tree.setCellRenderer(renderer);\n    tree.addTreeWillExpandListener(this);\n    tree.addMouseListener(new MouseAdapter() {\n      @Override public void mousePressed(final MouseEvent e) {\n        if(SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2)\n          new OpenCmd().execute(gui);\n      }\n    });\n\n    tree.setCellEditor(new ProjectCellEditor(tree, renderer));\n    tree.setEditable(true);\n\n    // choose common parent directories of project directories\n    root = new ProjectDir(new IOFile(root()), this);\n    invisible.add(root);\n\n    // expand root and child directories\n    for(int r = 0; r < 2; r++) tree.expandRow(r);\n    tree.setRootVisible(false);\n    tree.setSelectionRow(0);\n\n    // add popup\n    new BaseXPopup(tree, gui, new OpenCmd(), new OpenExternalCmd(), null,\n        new DeleteCmd(), new RenameCmd(), new NewDirCmd(), null,\n        new RefreshCmd(), new CopyPathCmd());\n\n    // add scroll bar\n    scroll = new JScrollPane(tree);\n    scroll.setBorder(new EmptyBorder(0, 0, 0, 0));\n\n    filter = new ProjectFilter(this);\n    list = new ProjectList(this);\n    BaseXLayout.addInteraction(list, gui);\n\n    final BaseXBack back = new BaseXBack().layout(new BorderLayout(2, 2));\n    back.setBorder(new CompoundBorder(new MatteBorder(0, 0, 1, 0, GUIConstants.GRAY),\n        new EmptyBorder(3, 1, 3, 2)));\n\n    path = new BaseXTextField(gui);\n    path.setText(root.file.path());\n    path.setEnabled(false);\n\n    final BaseXButton browse = new BaseXButton(DOTS, gui);\n    browse.setMargin(new Insets(0, 2, 0, 2));\n    browse.setToolTipText(CHOOSE_DIR);\n    browse.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) { change(); }\n    });\n\n    back.add(path, BorderLayout.CENTER);\n    back.add(browse, BorderLayout.EAST);\n    back.add(filter, BorderLayout.SOUTH);\n\n    add(back, BorderLayout.NORTH);\n    add(scroll, BorderLayout.CENTER);\n  }","id":85948,"modified_method":"/**\n   * Constructor.\n   * @param ev editor view\n   */\n  public ProjectView(final EditorView ev) {\n    super(ev.gui);\n    editor = ev;\n    setLayout(new BorderLayout());\n\n    tree = new ProjectTree(this);\n    root = new ProjectDir(new IOFile(root()), this);\n    tree.init(root);\n\n    filter = new ProjectFilter(this);\n    list = new ProjectList(this);\n    BaseXLayout.addInteraction(list, gui);\n\n    final BaseXBack back = new BaseXBack().layout(new BorderLayout(2, 2));\n    back.setBorder(new CompoundBorder(new MatteBorder(0, 0, 1, 0, GUIConstants.GRAY),\n        new EmptyBorder(3, 1, 3, 2)));\n\n    path = new BaseXTextField(gui);\n    path.setText(root.file.path());\n    path.setEnabled(false);\n\n    final BaseXButton browse = new BaseXButton(DOTS, gui);\n    browse.setMargin(new Insets(0, 2, 0, 2));\n    browse.setToolTipText(CHOOSE_DIR);\n    browse.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(final ActionEvent e) { change(); }\n    });\n\n    back.add(path, BorderLayout.CENTER);\n    back.add(browse, BorderLayout.EAST);\n    back.add(filter, BorderLayout.SOUTH);\n\n    // add scroll bars\n    final JScrollPane lscroll = new JScrollPane(list);\n    lscroll.setBorder(new EmptyBorder(0, 0, 0, 0));\n    final JScrollPane tscroll = new JScrollPane(tree);\n    tscroll.setBorder(new EmptyBorder(0, 0, 0, 0));\n\n    split = new BaseXSplit(false);\n    split.mode(Fill.NONE);\n    split.add(lscroll);\n    split.add(tscroll);\n    split.sizes(sizes);\n    showList(false);\n\n    add(back, BorderLayout.NORTH);\n    add(split, BorderLayout.CENTER);\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Opens the selected file.\n   * @param file file to be opened\n   * @param search search string\n   */\n  void open(final IOFile file, final String search) {\n    final EditorArea editor = view.open(file);\n    if(editor == null) return;\n\n    // delay search and focus request (avoid keyTyped event to be handled in editor)\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        editor.jump(search);\n      }\n    });\n  }","id":85949,"modified_method":"/**\n   * Opens the selected file.\n   * @param file file to be opened\n   * @param search search string\n   */\n  void open(final IOFile file, final String search) {\n    final EditorArea ea = editor.open(file);\n    if(ea == null) return;\n\n    // delay search and focus request (avoid keyTyped event to be handled in editor)\n    SwingUtilities.invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        ea.jump(search);\n      }\n    });\n  }","commit_id":"d18b0dc0932327b2f9d25d75c7f28586942163a8","url":"https://github.com/BaseXdb/basex"},{"original_method":"public AuxiliaryRightPanel(final DescriptionSaveListener descriptionListener) {\n    myDescriptionLabel = new DescriptionLabel();\n\n    myErrorLabel = new JLabel();\n    myErrorLabel.setBackground(UIUtil.isUnderDarcula() ? JBColor.PINK.darker() :JBColor.PINK);\n    myErrorLabel.setForeground(JBColor.BLACK);\n    myErrorLabel.setOpaque(true);\n    myErrorLabel.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 0));\n\n    myValidatedTextField = new ValidatedTextField(new SaveInputComponentValidator() {\n      @Override\n      public void doSave(@NotNull String text) {\n        descriptionListener.saveDescription(text.trim());\n      }\n\n      @Override\n      public boolean checkValid(@NotNull String text) {\n        return true;\n      }\n\n      @Override\n      public void cancel() {\n        descriptionListener.cancel();\n      }\n    });\n\n    myLayout = new CardLayout();\n    setLayout(myLayout);\n\n    new ClickListener() {\n      @Override\n      public boolean onClick(@NotNull MouseEvent event, int clickCount) {\n        if (clickCount != 2) {\n          return false;\n        }\n        editDescription(myDescriptionLabel.getText());\n        return true;\n      }\n    }.installOn(myDescriptionLabel);\n\n    add(myDescriptionLabel, SHOW_DESCRIPTION_CARD);\n    add(myErrorLabel, ERROR_CARD);\n    add(myValidatedTextField, EDIT_DESCRIPTION_CARD);\n\n    showDescription(null);\n  }","id":85950,"modified_method":"public AuxiliaryRightPanel(final DescriptionSaveListener descriptionListener) {\n    myCardPanel = new JPanel();\n    myDescriptionLabel = new DescriptionLabel();\n\n    myErrorLabel = new JLabel();\n    myErrorLabel.setBackground(UIUtil.isUnderDarcula() ? JBColor.PINK.darker() : JBColor.PINK);\n    myErrorLabel.setForeground(JBColor.BLACK);\n    myErrorLabel.setOpaque(true);\n\n    myValidatedTextField = new ValidatedTextField(new SaveInputComponentValidator() {\n      @Override\n      public void doSave(@NotNull String text) {\n        descriptionListener.saveDescription(text.trim());\n      }\n\n      @Override\n      public boolean checkValid(@NotNull String text) {\n        return true;\n      }\n\n      @Override\n      public void cancel() {\n        descriptionListener.cancel();\n      }\n    });\n\n    myLayout = new CardLayout();\n    myCardPanel.setLayout(myLayout);\n    myCardPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 6, 0));\n\n    new ClickListener() {\n      @Override\n      public boolean onClick(@NotNull MouseEvent event, int clickCount) {\n        if (clickCount != 2) {\n          return false;\n        }\n        editDescription(myDescriptionLabel.getText());\n        return true;\n      }\n    }.installOn(myDescriptionLabel);\n\n    myCardPanel.add(myDescriptionLabel, SHOW_DESCRIPTION_CARD);\n    myCardPanel.add(myErrorLabel, ERROR_CARD);\n    myCardPanel.add(myValidatedTextField, EDIT_DESCRIPTION_CARD);\n\n    showDescription(null);\n\n    setLayout(new BorderLayout());\n    add(myValidatedTextField.getHintLabel(), BorderLayout.NORTH);\n    add(myCardPanel, BorderLayout.CENTER);\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showError(final @NotNull String errorText) {\n    myErrorLabel.setText(errorText);\n    myLayout.show(this, ERROR_CARD);\n  }","id":85951,"modified_method":"public void showError(final @NotNull String errorText) {\n    myErrorLabel.setText(errorText);\n    myLayout.show(myCardPanel, ERROR_CARD);\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showDescription(@Nullable String newDescription) {\n    if (newDescription == null) {\n      newDescription = \"\";\n    }\n    myDescriptionLabel.setAllText(newDescription);\n    myLayout.show(this, SHOW_DESCRIPTION_CARD);\n  }","id":85952,"modified_method":"public void showDescription(@Nullable String newDescription) {\n    if (newDescription == null) {\n      newDescription = \"\";\n    }\n    myDescriptionLabel.setAllText(newDescription);\n    myLayout.show(myCardPanel, SHOW_DESCRIPTION_CARD);\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void editDescription(@Nullable String startValue) {\n    if (startValue == null) {\n      startValue = \"\";\n    }\n    myValidatedTextField.setText(startValue);\n    myLayout.show(this, EDIT_DESCRIPTION_CARD);\n    myValidatedTextField.requestFocus();\n  }","id":85953,"modified_method":"public void editDescription(@Nullable String startValue) {\n    if (startValue == null) {\n      startValue = \"\";\n    }\n    myValidatedTextField.setText(startValue);\n    myLayout.show(myCardPanel, EDIT_DESCRIPTION_CARD);\n    myValidatedTextField.requestFocus();\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Dimension getPreferredSize() {\n      final boolean isEmpty = getIcon() == null && StringUtil.isEmpty(getText());\n      int width = isEmpty ? JBUI.scale(10) + ARROW_ICON.getIconWidth() : super.getPreferredSize().width;\n      if (isSmallVariant()) width += JBUI.scale(4);\n      return new Dimension(width, JBUI.scale(isSmallVariant() ? 19 : 21));\n    }","id":85954,"modified_method":"@Override\n    public Dimension getPreferredSize() {\n      final boolean isEmpty = getIcon() == null && StringUtil.isEmpty(getText());\n      int width = isEmpty ? JBUI.scale(10) + ARROW_ICON.getIconWidth() : super.getPreferredSize().width;\n      if (isSmallVariant()) width += JBUI.scale(4);\n      return new Dimension(width, isSmallVariant() ? JBUI.scale(19) : super.getPreferredSize().height);\n    }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showPopup() {\n      myForcePressed = true;\n      repaint();\n\n      Runnable onDispose = new Runnable() {\n        @Override\n        public void run() {\n          // give button chance to handle action listener\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              myForcePressed = false;\n              myPopup = null;\n            }\n          });\n          repaint();\n          fireStateChanged();\n        }\n      };\n\n      myPopup = createPopup(onDispose);\n      myPopup.show(new RelativePoint(this, new Point(2, getHeight())));\n    }","id":85955,"modified_method":"public void showPopup() {\n      myForcePressed = true;\n      repaint();\n\n      Runnable onDispose = new Runnable() {\n        @Override\n        public void run() {\n          // give button chance to handle action listener\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              myForcePressed = false;\n              myPopup = null;\n            }\n          });\n          repaint();\n          fireStateChanged();\n        }\n      };\n\n      myPopup = createPopup(onDispose);\n      myPopup.show(new RelativePoint(this, new Point(-1, getHeight())));\n    }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionToolsConfigurable(@NotNull final InspectionProjectProfileManager projectProfileManager,\n                                     InspectionProfileManager profileManager) {\n    myWholePanel = new JPanel();\n\n    myWholePanel.setLayout(new BorderLayout());\n\n    final JPanel toolbar = new JPanel();\n    toolbar.setBorder(BorderFactory.createEmptyBorder(0, 0, 7, 0));\n\n    myPanel = new JPanel();\n\n    myWholePanel.add(toolbar, BorderLayout.PAGE_START);\n    myWholePanel.add(myPanel, BorderLayout.CENTER);\n\n    myProfiles = new ProfilesConfigurableComboBox(new ListCellRendererWrapper<Profile>() {\n      @Override\n      public void customize(final JList list, final Profile value, final int index, final boolean selected, final boolean hasFocus) {\n        final SingleInspectionProfilePanel singleInspectionProfilePanel = myPanels.get(value);\n        final boolean isShared = singleInspectionProfilePanel.isProfileShared();\n        setIcon(isShared ? AllIcons.General.ProjectSettings : AllIcons.General.Settings);\n        setText(singleInspectionProfilePanel.getCurrentProfileName());\n      }\n    }) {\n      @Override\n      public void onProfileChosen(InspectionProfileImpl inspectionProfile) {\n        myLayout.show(myPanel, getCardName(inspectionProfile));\n        myAuxiliaryRightPanel.showDescription(inspectionProfile.getDescription());\n      }\n    };\n    JPanel profilesHolder = new JPanel();\n    profilesHolder.setLayout(new CardLayout());\n\n\n    JComponent manageButton = new ManageButton(new ManageButtonBuilder() {\n      @Override\n      public boolean isSharedToTeamMembers() {\n        SingleInspectionProfilePanel panel = getSelectedPanel();\n        return panel != null && panel.isProfileShared();\n      }\n\n      @Override\n      public void setShareToTeamMembers(boolean shared) {\n        final SingleInspectionProfilePanel selectedPanel = getSelectedPanel();\n        LOG.assertTrue(selectedPanel != null, \"No settings selectedPanel for: \" + getSelectedObject());\n\n        final String name = getSelectedPanel().getCurrentProfileName();\n        for (SingleInspectionProfilePanel p : myPanels.values()) {\n          if (p != selectedPanel && Comparing.equal(p.getCurrentProfileName(), name)) {\n            final boolean curShared = p.isProfileShared();\n            if (curShared == shared) {\n              Messages.showErrorDialog((shared ? \"Shared\" : \"Application level\") + \" profile with same name exists.\", \"Inspections Settings\");\n              return;\n            }\n          }\n        }\n\n        selectedPanel.setProfileShared(shared);\n        myProfiles.repaint();\n      }\n\n      @Override\n      public void copy() {\n        final InspectionProfileImpl newProfile = copyToNewProfile(getSelectedObject(), getProject());\n        if (newProfile != null) {\n          final InspectionProfileImpl modifiableModel = (InspectionProfileImpl)newProfile.getModifiableModel();\n          modifiableModel.setModified(true);\n          modifiableModel.setProjectLevel(false);\n          addProfile(modifiableModel);\n          rename(modifiableModel);\n        }\n      }\n\n      @Override\n      public boolean canRename() {\n        final InspectionProfileImpl profile = getSelectedObject();\n        return !profile.isProfileLocked();\n      }\n\n      @Override\n      public void rename() {\n        rename(getSelectedObject());\n      }\n\n      private void rename(@NotNull final InspectionProfileImpl inspectionProfile) {\n        final String initialName = getSelectedPanel().getCurrentProfileName();\n        myProfiles.showEditCard(initialName, new SaveInputComponentValidator() {\n          @Override\n          public void doSave(@NotNull String text) {\n            if (!text.equals(initialName)) {\n              getProfilePanel(inspectionProfile).setCurrentProfileName(text);\n            }\n            myProfiles.showComboBoxCard();\n          }\n\n          @Override\n          public boolean checkValid(@NotNull String text) {\n            final SingleInspectionProfilePanel singleInspectionProfilePanel = myPanels.get(inspectionProfile);\n            if (singleInspectionProfilePanel == null) {\n              return false;\n            }\n            final boolean isValid = text.equals(initialName) || !hasName(text, singleInspectionProfilePanel.isProfileShared());\n            if (isValid) {\n              myAuxiliaryRightPanel.showDescription(getSelectedObject().getDescription());\n            }\n            else {\n              myAuxiliaryRightPanel.showError(\"Name is already in use. Please change name to unique.\");\n            }\n            return isValid;\n          }\n\n          @Override\n          public void cancel() {\n            myProfiles.showComboBoxCard();\n            myAuxiliaryRightPanel.showDescription(getSelectedObject().getDescription());\n          }\n        });\n      }\n\n      @Override\n      public boolean canDelete() {\n        return isDeleteEnabled(myProfiles.getSelectedProfile());\n      }\n\n      @Override\n      public void delete() {\n        final InspectionProfileImpl selectedProfile = myProfiles.getSelectedProfile();\n        myProfiles.getModel().removeElement(selectedProfile);\n        myDeletedProfiles.add(selectedProfile);\n      }\n\n      @Override\n      public boolean canEditDescription() {\n        return true;\n      }\n\n      @Override\n      public void editDescription() {\n        myAuxiliaryRightPanel.editDescription(getSelectedObject().getDescription());\n      }\n\n      @Override\n      public boolean hasDescription() {\n        return !StringUtil.isEmpty(getSelectedObject().getDescription());\n      }\n\n      @Override\n      public void export() {\n        final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n        descriptor.setDescription(\"Choose directory to store profile file\");\n        FileChooser.chooseFile(descriptor, getProject(), myWholePanel, null, new Consumer<VirtualFile>() {\n          @Override\n          public void consume(VirtualFile file) {\n            final Element element = new Element(\"inspections\");\n            try {\n              final SingleInspectionProfilePanel panel = getSelectedPanel();\n              LOG.assertTrue(panel != null);\n              final InspectionProfileImpl profile = getSelectedObject();\n              LOG.assertTrue(true);\n              profile.writeExternal(element);\n              final String filePath =\n                FileUtil.toSystemDependentName(file.getPath()) + File.separator + FileUtil.sanitizeFileName(profile.getName()) + \".xml\";\n              if (new File(filePath).isFile()) {\n                if (Messages\n                      .showOkCancelDialog(myWholePanel, \"File \\'\" + filePath + \"\\' already exist. Do you want to overwrite it?\", \"Warning\",\n                                          Messages.getQuestionIcon()) != Messages.OK) {\n                  return;\n                }\n              }\n              JDOMUtil.writeDocument(new Document(element), filePath, SystemProperties.getLineSeparator());\n            }\n            catch (WriteExternalException e1) {\n              LOG.error(e1);\n            }\n            catch (IOException e1) {\n              LOG.error(e1);\n            }\n          }\n        });\n      }\n\n      @Override\n      public void doImport() {\n        final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, false, false, false, false) {\n          @Override\n          public boolean isFileSelectable(VirtualFile file) {\n            return file.getFileType().equals(StdFileTypes.XML);\n          }\n        };\n        descriptor.setDescription(\"Choose profile file\");\n        FileChooser.chooseFile(descriptor, getProject(), myWholePanel, null, new Consumer<VirtualFile>() {\n          @Override\n          public void consume(VirtualFile file) {\n            if (file == null) return;\n            InspectionProfileImpl profile =\n              new InspectionProfileImpl(\"TempProfile\", InspectionToolRegistrar.getInstance(), myProfileManager);\n            try {\n              Element rootElement = JDOMUtil.loadDocument(VfsUtilCore.virtualToIoFile(file)).getRootElement();\n              if (Comparing.strEqual(rootElement.getName(), \"component\")) {//import right from .idea/inspectProfiles/xxx.xml\n                rootElement = rootElement.getChildren().get(0);\n              }\n              final Set<String> levels = new HashSet<String>();\n              for (Object o : rootElement.getChildren(\"inspection_tool\")) {\n                final Element inspectElement = (Element)o;\n                levels.add(inspectElement.getAttributeValue(\"level\"));\n                for (Object s : inspectElement.getChildren(\"scope\")) {\n                  levels.add(((Element)s).getAttributeValue(\"level\"));\n                }\n              }\n              for (Iterator<String> iterator = levels.iterator(); iterator.hasNext(); ) {\n                String level = iterator.next();\n                if (myProfileManager.getOwnSeverityRegistrar().getSeverity(level) != null) {\n                  iterator.remove();\n                }\n              }\n              if (!levels.isEmpty()) {\n                if (Messages.showYesNoDialog(myWholePanel, \"Undefined severities detected: \" +\n                                                           StringUtil.join(levels, \", \") +\n                                                           \". Do you want to create them?\", \"Warning\", Messages.getWarningIcon()) ==\n                    Messages.YES) {\n                  for (String level : levels) {\n                    final TextAttributes textAttributes = CodeInsightColors.WARNINGS_ATTRIBUTES.getDefaultAttributes();\n                    HighlightInfoType.HighlightInfoTypeImpl info =\n                      new HighlightInfoType.HighlightInfoTypeImpl(new HighlightSeverity(level, 50),\n                                                                  TextAttributesKey\n                                                                    .createTextAttributesKey(level));\n                    myProfileManager.getOwnSeverityRegistrar()\n                      .registerSeverity(new SeverityRegistrar.SeverityBasedTextAttributes(textAttributes.clone(), info),\n                                        textAttributes.getErrorStripeColor());\n                  }\n                }\n              }\n              profile.readExternal(rootElement);\n              profile.setProjectLevel(false);\n              profile.initInspectionTools(getProject());\n              if (getProfilePanel(profile) != null) {\n                if (Messages.showOkCancelDialog(myWholePanel, \"Profile with name \\'\" +\n                                                              profile.getName() +\n                                                              \"\\' already exists. Do you want to overwrite it?\", \"Warning\",\n                                                Messages.getInformationIcon()) != Messages.OK) {\n                  return;\n                }\n              }\n              final ModifiableModel model = profile.getModifiableModel();\n              model.setModified(true);\n              addProfile((InspectionProfileImpl)model);\n\n              //TODO myDeletedProfiles ? really need this\n              myDeletedProfiles.remove(profile);\n            }\n            catch (InvalidDataException e1) {\n              LOG.error(e1);\n            }\n            catch (JDOMException e1) {\n              LOG.error(e1);\n            }\n            catch (IOException e1) {\n              LOG.error(e1);\n            }\n          }\n        });\n      }\n    }).build();\n\n    myAuxiliaryRightPanel = new AuxiliaryRightPanel(new AuxiliaryRightPanel.DescriptionSaveListener() {\n      @Override\n      public void saveDescription(@NotNull String description) {\n        final InspectionProfileImpl inspectionProfile = getSelectedObject();\n        if (!Comparing.strEqual(description, inspectionProfile.getDescription())) {\n          inspectionProfile.setDescription(description);\n          inspectionProfile.setModified(true);\n        }\n        myAuxiliaryRightPanel.showDescription(description);\n      }\n\n      @Override\n      public void cancel() {\n        myAuxiliaryRightPanel.showDescription(getSelectedObject().getDescription());\n      }\n    });\n\n    toolbar.setLayout(new GridBagLayout());\n    toolbar.add(new JLabel(HEADER_TITLE), new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.VERTICAL, new Insets(0, 0, 0, 0), 0, 0));\n\n    toolbar.add(myProfiles.getHintLabel(), new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.VERTICAL, new Insets(0, 6, 6, 0), 0, 0));\n    toolbar.add(myProfiles, new GridBagConstraints(1, 1, 1, 1, 0, 1.0, GridBagConstraints.WEST, GridBagConstraints.VERTICAL, new Insets(0, 6, 0, 0), 0, 0));\n\n    toolbar.add(manageButton, new GridBagConstraints(2, 1, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.VERTICAL, new Insets(0, 10, 0, 0), 0, 0));\n\n    toolbar.add(myAuxiliaryRightPanel.getHintLabel(), new GridBagConstraints(3, 0, 1, 1, 0, 0, GridBagConstraints.WEST, GridBagConstraints.VERTICAL, new Insets(0, 15, 6, 0), 0, 0));\n    toolbar.add(myAuxiliaryRightPanel, new GridBagConstraints(3, 1, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(0, 15, 0, 0), 0, 0));\n\n    myProjectProfileManager = projectProfileManager;\n    myProfileManager = profileManager;\n  }","id":85956,"modified_method":"public InspectionToolsConfigurable(@NotNull final InspectionProjectProfileManager projectProfileManager,\n                                     InspectionProfileManager profileManager) {\n    myWholePanel = new JPanel();\n\n    myWholePanel.setLayout(new BorderLayout());\n\n    final JPanel toolbar = new JPanel();\n    toolbar.setBorder(BorderFactory.createEmptyBorder(0, 0, 7, 0));\n\n    myPanel = new JPanel();\n\n    myWholePanel.add(toolbar, BorderLayout.PAGE_START);\n    myWholePanel.add(myPanel, BorderLayout.CENTER);\n\n    myProfiles = new ProfilesConfigurableComboBox(new ListCellRendererWrapper<Profile>() {\n      @Override\n      public void customize(final JList list, final Profile value, final int index, final boolean selected, final boolean hasFocus) {\n        final SingleInspectionProfilePanel singleInspectionProfilePanel = myPanels.get(value);\n        final boolean isShared = singleInspectionProfilePanel.isProfileShared();\n        setIcon(isShared ? AllIcons.General.ProjectSettings : AllIcons.General.Settings);\n        setText(singleInspectionProfilePanel.getCurrentProfileName());\n      }\n    }) {\n      @Override\n      public void onProfileChosen(InspectionProfileImpl inspectionProfile) {\n        myLayout.show(myPanel, getCardName(inspectionProfile));\n        myAuxiliaryRightPanel.showDescription(inspectionProfile.getDescription());\n      }\n    };\n    JPanel profilesHolder = new JPanel();\n    profilesHolder.setLayout(new CardLayout());\n\n\n    JComponent manageButton = new ManageButton(new ManageButtonBuilder() {\n      @Override\n      public boolean isSharedToTeamMembers() {\n        SingleInspectionProfilePanel panel = getSelectedPanel();\n        return panel != null && panel.isProfileShared();\n      }\n\n      @Override\n      public void setShareToTeamMembers(boolean shared) {\n        final SingleInspectionProfilePanel selectedPanel = getSelectedPanel();\n        LOG.assertTrue(selectedPanel != null, \"No settings selectedPanel for: \" + getSelectedObject());\n\n        final String name = getSelectedPanel().getCurrentProfileName();\n        for (SingleInspectionProfilePanel p : myPanels.values()) {\n          if (p != selectedPanel && Comparing.equal(p.getCurrentProfileName(), name)) {\n            final boolean curShared = p.isProfileShared();\n            if (curShared == shared) {\n              Messages.showErrorDialog((shared ? \"Shared\" : \"Application level\") + \" profile with same name exists.\", \"Inspections Settings\");\n              return;\n            }\n          }\n        }\n\n        selectedPanel.setProfileShared(shared);\n        myProfiles.repaint();\n      }\n\n      @Override\n      public void copy() {\n        final InspectionProfileImpl newProfile = copyToNewProfile(getSelectedObject(), getProject());\n        if (newProfile != null) {\n          final InspectionProfileImpl modifiableModel = (InspectionProfileImpl)newProfile.getModifiableModel();\n          modifiableModel.setModified(true);\n          modifiableModel.setProjectLevel(false);\n          addProfile(modifiableModel);\n          rename(modifiableModel);\n        }\n      }\n\n      @Override\n      public boolean canRename() {\n        final InspectionProfileImpl profile = getSelectedObject();\n        return !profile.isProfileLocked();\n      }\n\n      @Override\n      public void rename() {\n        rename(getSelectedObject());\n      }\n\n      private void rename(@NotNull final InspectionProfileImpl inspectionProfile) {\n        final String initialName = getSelectedPanel().getCurrentProfileName();\n        myProfiles.showEditCard(initialName, new SaveInputComponentValidator() {\n          @Override\n          public void doSave(@NotNull String text) {\n            if (!text.equals(initialName)) {\n              getProfilePanel(inspectionProfile).setCurrentProfileName(text);\n            }\n            myProfiles.showComboBoxCard();\n          }\n\n          @Override\n          public boolean checkValid(@NotNull String text) {\n            final SingleInspectionProfilePanel singleInspectionProfilePanel = myPanels.get(inspectionProfile);\n            if (singleInspectionProfilePanel == null) {\n              return false;\n            }\n            final boolean isValid = text.equals(initialName) || !hasName(text, singleInspectionProfilePanel.isProfileShared());\n            if (isValid) {\n              myAuxiliaryRightPanel.showDescription(getSelectedObject().getDescription());\n            }\n            else {\n              myAuxiliaryRightPanel.showError(\"Name is already in use. Please change name to unique.\");\n            }\n            return isValid;\n          }\n\n          @Override\n          public void cancel() {\n            myProfiles.showComboBoxCard();\n            myAuxiliaryRightPanel.showDescription(getSelectedObject().getDescription());\n          }\n        });\n      }\n\n      @Override\n      public boolean canDelete() {\n        return isDeleteEnabled(myProfiles.getSelectedProfile());\n      }\n\n      @Override\n      public void delete() {\n        final InspectionProfileImpl selectedProfile = myProfiles.getSelectedProfile();\n        myProfiles.getModel().removeElement(selectedProfile);\n        myDeletedProfiles.add(selectedProfile);\n      }\n\n      @Override\n      public boolean canEditDescription() {\n        return true;\n      }\n\n      @Override\n      public void editDescription() {\n        myAuxiliaryRightPanel.editDescription(getSelectedObject().getDescription());\n      }\n\n      @Override\n      public boolean hasDescription() {\n        return !StringUtil.isEmpty(getSelectedObject().getDescription());\n      }\n\n      @Override\n      public void export() {\n        final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n        descriptor.setDescription(\"Choose directory to store profile file\");\n        FileChooser.chooseFile(descriptor, getProject(), myWholePanel, null, new Consumer<VirtualFile>() {\n          @Override\n          public void consume(VirtualFile file) {\n            final Element element = new Element(\"inspections\");\n            try {\n              final SingleInspectionProfilePanel panel = getSelectedPanel();\n              LOG.assertTrue(panel != null);\n              final InspectionProfileImpl profile = getSelectedObject();\n              LOG.assertTrue(true);\n              profile.writeExternal(element);\n              final String filePath =\n                FileUtil.toSystemDependentName(file.getPath()) + File.separator + FileUtil.sanitizeFileName(profile.getName()) + \".xml\";\n              if (new File(filePath).isFile()) {\n                if (Messages\n                      .showOkCancelDialog(myWholePanel, \"File \\'\" + filePath + \"\\' already exist. Do you want to overwrite it?\", \"Warning\",\n                                          Messages.getQuestionIcon()) != Messages.OK) {\n                  return;\n                }\n              }\n              JDOMUtil.writeDocument(new Document(element), filePath, SystemProperties.getLineSeparator());\n            }\n            catch (WriteExternalException e1) {\n              LOG.error(e1);\n            }\n            catch (IOException e1) {\n              LOG.error(e1);\n            }\n          }\n        });\n      }\n\n      @Override\n      public void doImport() {\n        final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, false, false, false, false) {\n          @Override\n          public boolean isFileSelectable(VirtualFile file) {\n            return file.getFileType().equals(StdFileTypes.XML);\n          }\n        };\n        descriptor.setDescription(\"Choose profile file\");\n        FileChooser.chooseFile(descriptor, getProject(), myWholePanel, null, new Consumer<VirtualFile>() {\n          @Override\n          public void consume(VirtualFile file) {\n            if (file == null) return;\n            InspectionProfileImpl profile =\n              new InspectionProfileImpl(\"TempProfile\", InspectionToolRegistrar.getInstance(), myProfileManager);\n            try {\n              Element rootElement = JDOMUtil.loadDocument(VfsUtilCore.virtualToIoFile(file)).getRootElement();\n              if (Comparing.strEqual(rootElement.getName(), \"component\")) {//import right from .idea/inspectProfiles/xxx.xml\n                rootElement = rootElement.getChildren().get(0);\n              }\n              final Set<String> levels = new HashSet<String>();\n              for (Object o : rootElement.getChildren(\"inspection_tool\")) {\n                final Element inspectElement = (Element)o;\n                levels.add(inspectElement.getAttributeValue(\"level\"));\n                for (Object s : inspectElement.getChildren(\"scope\")) {\n                  levels.add(((Element)s).getAttributeValue(\"level\"));\n                }\n              }\n              for (Iterator<String> iterator = levels.iterator(); iterator.hasNext(); ) {\n                String level = iterator.next();\n                if (myProfileManager.getOwnSeverityRegistrar().getSeverity(level) != null) {\n                  iterator.remove();\n                }\n              }\n              if (!levels.isEmpty()) {\n                if (Messages.showYesNoDialog(myWholePanel, \"Undefined severities detected: \" +\n                                                           StringUtil.join(levels, \", \") +\n                                                           \". Do you want to create them?\", \"Warning\", Messages.getWarningIcon()) ==\n                    Messages.YES) {\n                  for (String level : levels) {\n                    final TextAttributes textAttributes = CodeInsightColors.WARNINGS_ATTRIBUTES.getDefaultAttributes();\n                    HighlightInfoType.HighlightInfoTypeImpl info =\n                      new HighlightInfoType.HighlightInfoTypeImpl(new HighlightSeverity(level, 50),\n                                                                  TextAttributesKey\n                                                                    .createTextAttributesKey(level));\n                    myProfileManager.getOwnSeverityRegistrar()\n                      .registerSeverity(new SeverityRegistrar.SeverityBasedTextAttributes(textAttributes.clone(), info),\n                                        textAttributes.getErrorStripeColor());\n                  }\n                }\n              }\n              profile.readExternal(rootElement);\n              profile.setProjectLevel(false);\n              profile.initInspectionTools(getProject());\n              if (getProfilePanel(profile) != null) {\n                if (Messages.showOkCancelDialog(myWholePanel, \"Profile with name \\'\" +\n                                                              profile.getName() +\n                                                              \"\\' already exists. Do you want to overwrite it?\", \"Warning\",\n                                                Messages.getInformationIcon()) != Messages.OK) {\n                  return;\n                }\n              }\n              final ModifiableModel model = profile.getModifiableModel();\n              model.setModified(true);\n              addProfile((InspectionProfileImpl)model);\n\n              //TODO myDeletedProfiles ? really need this\n              myDeletedProfiles.remove(profile);\n            }\n            catch (InvalidDataException e1) {\n              LOG.error(e1);\n            }\n            catch (JDOMException e1) {\n              LOG.error(e1);\n            }\n            catch (IOException e1) {\n              LOG.error(e1);\n            }\n          }\n        });\n      }\n    }).build();\n\n    myAuxiliaryRightPanel = new AuxiliaryRightPanel(new AuxiliaryRightPanel.DescriptionSaveListener() {\n      @Override\n      public void saveDescription(@NotNull String description) {\n        final InspectionProfileImpl inspectionProfile = getSelectedObject();\n        if (!Comparing.strEqual(description, inspectionProfile.getDescription())) {\n          inspectionProfile.setDescription(description);\n          inspectionProfile.setModified(true);\n        }\n        myAuxiliaryRightPanel.showDescription(description);\n      }\n\n      @Override\n      public void cancel() {\n        myAuxiliaryRightPanel.showDescription(getSelectedObject().getDescription());\n      }\n    });\n\n    toolbar.setLayout(new GridBagLayout());\n    final JLabel headerTitleLabel = new JLabel(HEADER_TITLE);\n    headerTitleLabel.setBorder(IdeBorderFactory.createEmptyBorder(10, 0, 0, 0));\n    toolbar.add(headerTitleLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\n\n    toolbar.add(myProfiles, new GridBagConstraints(1, 0, 1, 1, 0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.VERTICAL, new Insets(0, 6, 0, 0), 0, 0));\n\n    toolbar.add(withBorderOnTop(manageButton), new GridBagConstraints(2, 0, 1, 1, 0, 0, GridBagConstraints.CENTER, GridBagConstraints.VERTICAL, new Insets(0, 10, 0, 0), 0, 0));\n\n    toolbar.add(myAuxiliaryRightPanel, new GridBagConstraints(3, 0, 1, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 15, 0, 0), 0, 0));\n\n    myProjectProfileManager = projectProfileManager;\n    myProfileManager = profileManager;\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ManageButton(final ManageButtonBuilder builder) {\n    myBuilder = builder;\n    getTemplatePresentation().setText(\"Manage\");\n    if (SystemInfo.isMac) {\n      setSmallVariant(false);\n    }\n  }","id":85957,"modified_method":"public ManageButton(final ManageButtonBuilder builder) {\n    myBuilder = builder;\n    getTemplatePresentation().setText(\"Manage\");\n    setSmallVariant(false);\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showEditCard(final String initialValue, final SaveInputComponentValidator inputValidator) {\n    mySaveListener.setDelegate(inputValidator);\n    mySubmitNameComponent.setText(initialValue);\n    myCardLayout.show(this, EDIT_CARD);\n    mySubmitNameComponent.requestFocus();\n  }","id":85958,"modified_method":"public void showEditCard(final String initialValue, final SaveInputComponentValidator inputValidator) {\n    mySaveListener.setDelegate(inputValidator);\n    mySubmitNameComponent.setText(initialValue);\n    myCardLayout.show(myComboBoxPanel, EDIT_CARD);\n    mySubmitNameComponent.requestFocus();\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProfilesConfigurableComboBox(final ListCellRendererWrapper<Profile> comboBoxItemsRenderer) {\n    myCardLayout = new CardLayout();\n    setLayout(myCardLayout);\n\n    myProfilesComboBox = new JComboBox();\n    add(myProfilesComboBox, COMBO_CARD);\n\n    mySaveListener = new SaveInputComponentValidator.Wrapper();\n    mySubmitNameComponent = new ValidatedTextField(mySaveListener);\n    add(mySubmitNameComponent, EDIT_CARD);\n\n    myProfilesComboBox.setRenderer(comboBoxItemsRenderer);\n    myProfilesComboBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final InspectionProfileImpl profile = getSelectedProfile();\n        if (profile != null) {\n          onProfileChosen(profile);\n        }\n      }\n    });\n\n    showComboBoxCard();\n  }","id":85959,"modified_method":"public ProfilesConfigurableComboBox(final ListCellRendererWrapper<Profile> comboBoxItemsRenderer) {\n    myComboBoxPanel = new JPanel();\n\n    myCardLayout = new CardLayout();\n    myComboBoxPanel.setLayout(myCardLayout);\n    myComboBoxPanel.setBorder(IdeBorderFactory.createEmptyBorder(new Insets(4, 0, 6, 0)));\n\n    myProfilesComboBox = new JComboBox();\n    myComboBoxPanel.add(myProfilesComboBox, COMBO_CARD);\n\n    mySaveListener = new SaveInputComponentValidator.Wrapper();\n    mySubmitNameComponent = new ValidatedTextField(mySaveListener);\n    myComboBoxPanel.add(mySubmitNameComponent, EDIT_CARD);\n\n    myProfilesComboBox.setRenderer(comboBoxItemsRenderer);\n    myProfilesComboBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final InspectionProfileImpl profile = getSelectedProfile();\n        if (profile != null) {\n          onProfileChosen(profile);\n        }\n      }\n    });\n\n    setLayout(new BorderLayout());\n    add(mySubmitNameComponent.getHintLabel(), BorderLayout.NORTH);\n    add(myComboBoxPanel, BorderLayout.CENTER);\n\n    showComboBoxCard();\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void showComboBoxCard() {\n    myCardLayout.show(this, COMBO_CARD);\n  }","id":85960,"modified_method":"public void showComboBoxCard() {\n    myCardLayout.show(myComboBoxPanel, COMBO_CARD);\n  }","commit_id":"ca6e09dc4a400af38963f35c9d1f21c4d461e78e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getControllerId(), source.getId(), source.getControllerId(), event.getAmount(), false);\r\n        if (!game.replaceEvent(preventEvent)) {\r\n            Permanent targetCreature = game.getPermanent(source.getFirstTarget());\r\n            if (targetCreature != null) {\r\n                int damage = event.getAmount();\r\n                if (event.getAmount() >= this.amount) {\r\n                    event.setAmount(damage - this.amount);\r\n                    damage = this.amount;\r\n                    this.used = true;\r\n                    this.discard();\r\n                } else {\r\n                    event.setAmount(0);\r\n                    this.amount -= damage;\r\n                }\r\n\r\n                targetCreature.damage(damage, source.getSourceId(), game, true, false, event.getAppliedEffects());\r\n                game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,\r\n                        source.getControllerId(), source.getSourceId(), source.getControllerId(), damage));\r\n            }\r\n        }\r\n        return false;\r\n    }","id":85961,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getControllerId(), source.getId(), source.getControllerId(), event.getAmount(), false);\r\n        if (!game.replaceEvent(preventEvent)) {\r\n            Permanent targetCreature = game.getPermanent(source.getFirstTarget());\r\n            if (targetCreature != null) {\r\n                int damage = event.getAmount();\r\n                if (event.getAmount() >= this.amount) {\r\n                    event.setAmount(damage - this.amount);\r\n                    damage = this.amount;\r\n                    this.used = true;\r\n                    this.discard();\r\n                } else {\r\n                    event.setAmount(0);\r\n                    this.amount -= damage;\r\n                }\r\n                if (damage > 0) {\r\n                    game.informPlayers(new StringBuilder(\"Acolyte's Reward \").append(\"prevented \").append(damage).append(\" to \").append(targetCreature.getName()).toString());\r\n                    game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,\r\n                            source.getControllerId(), source.getSourceId(), source.getControllerId(), damage));\r\n\r\n                    Player targetPlayer = game.getPlayer(source.getTargets().get(1).getFirstTarget());\r\n                    if (targetPlayer != null) {\r\n                        targetPlayer.damage(damage, source.getSourceId(), game, false, true);\r\n                        game.informPlayers(new StringBuilder(\"Acolyte's Reward \").append(\"deals \").append(damage).append(\" damge to \").append(targetPlayer.getName()).toString());\r\n                    } else {\r\n                        Permanent targetDamageCreature = game.getPermanent(source.getTargets().get(1).getFirstTarget());\r\n                        if (targetDamageCreature != null) {\r\n                            targetDamageCreature.damage(damage, source.getSourceId(), game, true, false);\r\n                            game.informPlayers(new StringBuilder(\"Acolyte's Reward \").append(\"deals \").append(damage).append(\" damge to \").append(targetDamageCreature.getName()).toString());\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"a5c0ae1b41ad1f6f6e893c27d11813b9043a272e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tChoiceColor choice = (ChoiceColor) this.source.getChoices().get(0);\n\t\tfilter2.setColor(choice.getColor());\n\t\tfilter2.setMessage(choice.getChoice());\n\t\tfilter1.getControllerId().clear();\n\t\tfilter1.getControllerId().add(source.getControllerId());\n\t\tfor (Permanent perm: game.getBattlefield().getActivePermanents(filter1)) {\n\t\t\tperm.addAbility(ability);\n\t\t}\n\t\treturn true;\n\t}","id":85962,"modified_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tChoiceColor choice = (ChoiceColor) this.source.getChoices().get(0);\n\t\tfilter2.setColor(choice.getColor());\n\t\tfilter2.setMessage(choice.getChoice());\n\t\tfor (Permanent perm: game.getBattlefield().getAllActivePermanents(filter1, source.getControllerId())) {\n\t\t\tperm.addAbility(ability);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"public DragonskullSummit(UUID ownerId) {\n\t\tsuper(ownerId, \"Dragonskull Summit\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121671_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new DragonskullSummitEffect()));\n\t\tthis.addAbility(new BlackManaAbility());\n\t\tthis.addAbility(new RedManaAbility());\n\t}","id":85963,"modified_method":"public DragonskullSummit(UUID ownerId) {\n\t\tsuper(ownerId, \"Dragonskull Summit\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121671_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new EntersBattlefieldTappedUnlessControlsEffect(filter)));\n\t\tthis.addAbility(new BlackManaAbility());\n\t\tthis.addAbility(new RedManaAbility());\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tint amount = this.source.getManaCosts().getVariableCosts().get(0).getValue();\n\n\t\tFilterCreaturePermanent filter = new FilterCreaturePermanent();\n\t\tfilter.getAbilities().add(FlyingAbility.getInstance());\n\t\tfilter.setNotAbilities(true);\n\t\tfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter)) {\n\t\t\tpermanent.damage(amount, source.getId(), game);\n\t\t}\n\t\tfor (Player player: game.getPlayers().values()) {\n\t\t\tplayer.damage(amount, source.getId(), game);\n\t\t}\n\t\treturn true;\n\t}","id":85964,"modified_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tint amount = this.source.getManaCosts().getVariableCosts().get(0).getValue();\n\n\t\tFilterCreaturePermanent filter = new FilterCreaturePermanent();\n\t\tfilter.getAbilities().add(FlyingAbility.getInstance());\n\t\tfilter.setNotAbilities(true);\n\t\tfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter, this.source.getControllerId(), game)) {\n\t\t\tpermanent.damage(amount, source.getId(), game);\n\t\t}\n\t\tfor (UUID playerId: game.getPlayer(this.source.getControllerId()).getInRange()) {\n\t\t\tPlayer player = game.getPlayer(playerId);\n\t\t\tif (player != null)\n\t\t\t\tplayer.damage(amount, source.getId(), game);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"public GlacialFortress(UUID ownerId) {\n\t\tsuper(ownerId, \"Glacial Fortress\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121634_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new GlacialFortressEffect()));\n\t\tthis.addAbility(new BlueManaAbility());\n\t\tthis.addAbility(new WhiteManaAbility());\n\t}","id":85965,"modified_method":"public GlacialFortress(UUID ownerId) {\n\t\tsuper(ownerId, \"Glacial Fortress\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121634_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new EntersBattlefieldTappedUnlessControlsEffect(filter)));\n\t\tthis.addAbility(new BlueManaAbility());\n\t\tthis.addAbility(new WhiteManaAbility());\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean checkIfClause(Game game) {\n\t\tFilterLandPermanent filter = new FilterLandPermanent();\n\t\tfilter.getControllerId().clear();\n\t\tfilter.getControllerId().add(this.controllerId);\n\t\tint numLands = game.getBattlefield().count(filter);\n\t\tfor (UUID opponentId: game.getOpponents(this.controllerId)) {\n\t\t\tfilter.getControllerId().clear();\n\t\t\tfilter.getControllerId().add(opponentId);\n\t\t\tif (numLands < game.getBattlefield().count(filter)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":85966,"modified_method":"@Override\n\tpublic boolean checkIfClause(Game game) {\n\t\tFilterLandPermanent filter = new FilterLandPermanent();\n\t\tint numLands = game.getBattlefield().countAll(filter, this.controllerId);\n\t\tfor (UUID opponentId: game.getOpponents(this.controllerId)) {\n\t\t\tfilter.getControllerId().clear();\n\t\t\tfilter.getControllerId().add(opponentId);\n\t\t\tif (numLands < game.getBattlefield().countAll(filter, opponentId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tPlayer controller = game.getPlayer(this.source.getControllerId());\n\t\tint amount = this.source.getManaCosts().getVariableCosts().get(0).getValue();\n\n\t\tFilterCreaturePermanent filter = new FilterCreaturePermanent();\n\t\tif (amount > 4) {\n\t\t\tfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter)) {\n\t\t\t\tpermanent.destroy(this.source.getSourceId(), game, false);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < amount; i++) {\n\t\t\tcontroller.putOntoBattlefield(new SoldierToken(), game);\n\t\t}\n\t\treturn true;\n\t}","id":85967,"modified_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tPlayer controller = game.getPlayer(this.source.getControllerId());\n\t\tint amount = this.source.getManaCosts().getVariableCosts().get(0).getValue();\n\n\t\tFilterCreaturePermanent filter = new FilterCreaturePermanent();\n\t\tif (amount > 4) {\n\t\t\tfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter, this.source.getControllerId(), game)) {\n\t\t\t\tpermanent.destroy(this.source.getSourceId(), game, false);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < amount; i++) {\n\t\t\tcontroller.putOntoBattlefield(new SoldierToken(), game);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"public boolean apply(Game game) {\n\t\tfilter.getControllerId().clear();\n\t\tfilter.getControllerId().add(this.source.getControllerId());\n\t\tList<UUID> wolves = new ArrayList<UUID>();\n\t\tPermanent target = game.getPermanent(this.source.getFirstTarget());\n\t\tif (target != null) {\n\t\t\tfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter)) {\n\t\t\t\tpermanent.tap(game);\n\t\t\t\ttarget.damage(permanent.getToughness().getValue(), permanent.getId(), game);\n\t\t\t}\n\t\t\tPlayer player = game.getPlayer(target.getControllerId());\n\t\t\tplayer.assignDamage(target.getPower().getValue(), wolves, target.getId(), game);\n\t\t}\n\t\treturn true;\n\t}","id":85968,"modified_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tList<UUID> wolves = new ArrayList<UUID>();\n\t\tPermanent target = game.getPermanent(this.source.getFirstTarget());\n\t\tif (target != null) {\n\t\t\tfor (Permanent permanent: game.getBattlefield().getAllActivePermanents(filter, this.source.getControllerId())) {\n\t\t\t\tpermanent.tap(game);\n\t\t\t\ttarget.damage(permanent.getToughness().getValue(), permanent.getId(), game);\n\t\t\t}\n\t\t\tPlayer player = game.getPlayer(target.getControllerId());\n\t\t\tplayer.assignDamage(target.getPower().getValue(), wolves, target.getId(), game);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tFilterPermanent filter = new FilterPermanent();\n\t\tfilter.getCardType().add(CardType.CREATURE);\n\t\tfilter.getColor().setGreen(true);\n\t\tfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter)) {\n\t\t\tif (permanent.getTurnsOnBattlefield() == 0) {\n\t\t\t\tpermanent.getCounters().addCounter(new PlusOneCounter());\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":85969,"modified_method":"@Override\n\tpublic boolean apply(Game game) {\n\t\tFilterPermanent filter = new FilterPermanent();\n\t\tfilter.getCardType().add(CardType.CREATURE);\n\t\tfilter.getColor().setGreen(true);\n\t\tfor (Permanent permanent: game.getBattlefield().getActivePermanents(filter, this.source.getControllerId(), game)) {\n\t\t\tif (permanent.getTurnsOnBattlefield() == 0) {\n\t\t\t\tpermanent.getCounters().addCounter(new PlusOneCounter());\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"public RootboundCrag(UUID ownerId) {\n\t\tsuper(ownerId, \"Rootbound Crag\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121648_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new RootboundCragEffect()));\n\t\tthis.addAbility(new RedManaAbility());\n\t\tthis.addAbility(new GreenManaAbility());\n\t}","id":85970,"modified_method":"public RootboundCrag(UUID ownerId) {\n\t\tsuper(ownerId, \"Rootbound Crag\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121648_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new EntersBattlefieldTappedUnlessControlsEffect(filter)));\n\t\tthis.addAbility(new RedManaAbility());\n\t\tthis.addAbility(new GreenManaAbility());\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean checkIfClause(Game game) {\n\t\tfilter.getControllerId().clear();\n\t\tfilter.getControllerId().add(this.controllerId);\n\t\treturn game.getBattlefield().count(filter) >= 5;\n\t}","id":85971,"modified_method":"@Override\n\tpublic boolean checkIfClause(Game game) {\n\t\treturn game.getBattlefield().countAll(filter, this.controllerId) >= 5;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"public SunpetalGrove(UUID ownerId) {\n\t\tsuper(ownerId, \"Sunpetal Grove\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121679_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new SunpetalGroveEffect()));\n\t\tthis.addAbility(new GreenManaAbility());\n\t\tthis.addAbility(new WhiteManaAbility());\n\t}","id":85972,"modified_method":"public SunpetalGrove(UUID ownerId) {\n\t\tsuper(ownerId, \"Sunpetal Grove\", new CardType[]{CardType.LAND}, null);\n\t\tthis.expansionSetId = Magic2010.getInstance().getId();\n\t\tthis.art = \"121679_typ_reg_sty_010.jpg\";\n\t\tthis.addAbility(new EntersBattlefieldStaticAbility(new EntersBattlefieldTappedUnlessControlsEffect(filter)));\n\t\tthis.addAbility(new GreenManaAbility());\n\t\tthis.addAbility(new WhiteManaAbility());\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n\tpublic boolean canPay(UUID playerId, Game game) {\n\t\tfor (UUID opponentId: game.getOpponents(playerId)) {\n\t\t\tfilter.getControllerId().clear();\n\t\t\tfilter.getControllerId().add(opponentId);\n\t\t\tif (game.getBattlefield().count(filter) > 3) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":85973,"modified_method":"@Override\n\tpublic boolean canPay(UUID playerId, Game game) {\n\t\tfor (UUID opponentId: game.getOpponents(playerId)) {\n\t\t\tfilter.getControllerId().clear();\n\t\t\tfilter.getControllerId().add(opponentId);\n\t\t\tif (game.getBattlefield().countAll(filter, opponentId) > 3) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"d91c00d0029c0241f0f4cc59c492c106dcd8479d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = source.getSourceObject(game);\r\n        if (controller != null && sourceObject != null) {\r\n            Card card = controller.getLibrary().getFromTop(game);\r\n            Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n            if (card != null) {\r\n                controller.moveCards(card, null, Zone.HAND, source, game);\r\n                sourcePermanent.damage(card.getManaCost().convertedManaCost(), source.getSourceId(), game, false, false);\r\n                controller.revealCards(sourceObject.getIdName(), new CardsImpl(card), game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":85974,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = source.getSourceObject(game);\r\n        if (controller != null && sourceObject != null) {\r\n            Card card = controller.getLibrary().getFromTop(game);\r\n            Permanent sourcePermanent = game.getPermanent(source.getSourceId());\r\n            if (card != null) {\r\n                controller.moveCards(card, Zone.HAND, source, game);\r\n                if (sourcePermanent != null) {\r\n                    sourcePermanent.damage(card.getManaCost().convertedManaCost(), source.getSourceId(), game, false, false);\r\n                }\r\n                controller.revealCards(sourceObject.getIdName(), new CardsImpl(card), game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"74c310de3e45ed7581b2bd0517d41f63fa2204fe","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(Permanent permanent, Ability source, Game game) {\r\n        if (game.getStep().getType() == PhaseStep.UNTAP) {\r\n            if (game.getTurnNum() != turn) {\r\n                turn = game.getTurnNum();\r\n                applies = false;\r\n                Permanent storageMatrix = game.getPermanent(source.getSourceId());\r\n                if (storageMatrix != null && !storageMatrix.isTapped()) {\r\n                    Choice choiceImpl = new ChoiceImpl(true);\r\n                    choiceImpl.setMessage(\"Untap which kind of permanent?\");\r\n                    choiceImpl.setChoices(choice);\r\n                    Player player = game.getPlayer(game.getActivePlayerId());\r\n                    if (player != null) {\r\n                        while (!player.choose(outcome, choiceImpl, game)) {\r\n                            if (player.canRespond()) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        String choosenType = choiceImpl.getChoice();\r\n                        game.informPlayers(storageMatrix.getLogName() + \": \" + player.getLogName() + \" chose to untap \" + choosenType);\r\n\r\n                        if (choosenType.equals(CardType.ARTIFACT.toString())) {\r\n                            type = CardType.ARTIFACT;\r\n                        } else if (choosenType.equals(CardType.LAND.toString())) {\r\n                            type = CardType.LAND;\r\n                        } else {\r\n                            type = CardType.CREATURE;\r\n                        }\r\n                        applies = true;\r\n                    }\r\n                }\r\n            }\r\n            if (applies) {\r\n                return !permanent.getCardType().contains(type);\r\n            }\r\n        }\r\n        return false;\r\n    }","id":85975,"modified_method":"@Override\r\n    public boolean applies(Permanent permanent, Ability source, Game game) {\r\n        if (game.getStep().getType() == PhaseStep.UNTAP) {\r\n            if (game.getTurnNum() != turn) {\r\n                turn = game.getTurnNum();\r\n                applies = false;\r\n                Permanent storageMatrix = game.getPermanent(source.getSourceId());\r\n                if (storageMatrix != null && !storageMatrix.isTapped()) {\r\n                    Choice choiceImpl = new ChoiceImpl(true);\r\n                    choiceImpl.setMessage(\"Untap which kind of permanent?\");\r\n                    choiceImpl.setChoices(choice);\r\n                    Player player = game.getPlayer(game.getActivePlayerId());\r\n                    if (player != null) {\r\n                        while (!player.choose(outcome, choiceImpl, game)) {\r\n                            if (player.canRespond()) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        String choosenType = choiceImpl.getChoice();\r\n                        if (choosenType != null) {\r\n                            game.informPlayers(storageMatrix.getLogName() + \": \" + player.getLogName() + \" chose to untap \" + choosenType);\r\n\r\n                            if (choosenType.equals(CardType.ARTIFACT.toString())) {\r\n                                type = CardType.ARTIFACT;\r\n                            } else if (choosenType.equals(CardType.LAND.toString())) {\r\n                                type = CardType.LAND;\r\n                            } else {\r\n                                type = CardType.CREATURE;\r\n                            }\r\n                            applies = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (applies) {\r\n                return !permanent.getCardType().contains(type);\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"74c310de3e45ed7581b2bd0517d41f63fa2204fe","url":"https://github.com/magefree/mage"},{"original_method":"private EditorCell createProperty_ook5es_a0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"name\");\n    provider.setNoTargetText(\"<no name>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_name\");\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":85976,"modified_method":"private EditorCell createProperty_ook5es_a0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"name\");\n    provider.setNoTargetText(\"<no name>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_name\");\n    editorCell.setSubstituteInfo(new CompositeSubstituteInfo(editorContext, provider.getCellContext(), new SubstituteInfoPartExt[]{new AbstractFigureParameter_Editor.AbstractFigureParameter_generic_cellMenu_ook5es_a0a0()}));\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"5f1ecd28dc8df2a77db1c0db20bbe24a88f4545a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0b, fqName)) {\n      case 0:\n        return new CellModel_DiagramNode_Constraints();\n      case 2:\n        return new FigureParameterProperty_Constraints();\n      case 1:\n        return new FigureParameterLink_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","id":85977,"modified_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0b, fqName)) {\n      case 1:\n        return new CellModel_DiagramNode_Constraints();\n      case 3:\n        return new FigureParameterProperty_Constraints();\n      case 2:\n        return new FigureParameterLink_Constraints();\n      case 0:\n        return new AbstractFigureParameter_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","commit_id":"5f1ecd28dc8df2a77db1c0db20bbe24a88f4545a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public IHelginsDescriptor getTypesystem() {\n    return null;\n  }","id":85978,"modified_method":"@Override\n  public IHelginsDescriptor getTypesystem() {\n    return new TypesystemDescriptor();\n  }","commit_id":"5f1ecd28dc8df2a77db1c0db20bbe24a88f4545a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_2117021943016126851(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(_context.getNode()), \"jetbrains.mps.lang.editor.diagram.structure.CellModel_DiagramNode\"), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getSetterName_3748979635600013130(_context.getNode())});\n  }","id":85979,"modified_method":"public static Object referenceMacro_GetReferent_2117021943016126851(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getSetterName_3748979635600013130(_context.getNode())});\n  }","commit_id":"5f1ecd28dc8df2a77db1c0db20bbe24a88f4545a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_2117021943029825140(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(_context.getNode()), \"jetbrains.mps.lang.editor.diagram.structure.CellModel_DiagramNode\"), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","id":85980,"modified_method":"public static Object referenceMacro_GetReferent_2117021943029825140(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","commit_id":"5f1ecd28dc8df2a77db1c0db20bbe24a88f4545a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_2117021943028789641(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(_context.getNode()), \"jetbrains.mps.lang.editor.diagram.structure.CellModel_DiagramNode\"), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","id":85981,"modified_method":"public static Object referenceMacro_GetReferent_2117021943028789641(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    SNode figureReference = SLinkOperations.getTarget(AbstractFigureParameter_Behavior.call_getDiagramNodeCell_1491555030355957123(_context.getNode()), \"figure\", true);\n    return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), figureReference, \"virtual_getMethodDeclaration_8322026508615817443\", new Object[]{AbstractFigureParameter_Behavior.call_getGetterName_3748979635600013007(_context.getNode())});\n  }","commit_id":"5f1ecd28dc8df2a77db1c0db20bbe24a88f4545a","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Searches for all instances of {@link AbstractCheckDescriptor} on the\n   * classpath and registers each as a singleton with the\n   * {@link UpgradeCheckRegistry}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void registerUpgradeChecks() {\n    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);\n\n    // make the registry a singleton\n    UpgradeCheckRegistry registry = new UpgradeCheckRegistry();\n    bind(UpgradeCheckRegistry.class).toInstance(registry);\n\n    // match all implementations of the base check class\n    AssignableTypeFilter filter = new AssignableTypeFilter(AbstractCheckDescriptor.class);\n    scanner.addIncludeFilter(filter);\n\n    Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(AbstractCheckDescriptor.class.getPackage().getName());\n\n    // no dispatchers is a problem\n    if (null == beanDefinitions || beanDefinitions.size() == 0) {\n      LOG.error(\"No instances of {} found to register\", AbstractCheckDescriptor.class);\n      return;\n    }\n\n    // for every discovered check, singleton-ize them and register with the\n    // registry\n    for (BeanDefinition beanDefinition : beanDefinitions) {\n      String className = beanDefinition.getBeanClassName();\n      Class<?> clazz = ClassUtils.resolveClassName(className, ClassUtils.getDefaultClassLoader());\n\n      try {\n        AbstractCheckDescriptor upgradeCheck = (AbstractCheckDescriptor) clazz.newInstance();\n        bind((Class<AbstractCheckDescriptor>) clazz).toInstance(upgradeCheck);\n        registry.register(upgradeCheck);\n      } catch (Exception exception) {\n        LOG.error(\"Unable to bind and register upgrade check {}\", clazz, exception);\n      }\n    }\n\n    // log the order of the pre-upgrade checks\n    List<AbstractCheckDescriptor> upgradeChecks = registry.getUpgradeChecks();\n    for (AbstractCheckDescriptor upgradeCheck : upgradeChecks) {\n      LOG.debug(\"Registered pre-upgrade check {}\", upgradeCheck.getClass());\n    }\n  }","id":85982,"modified_method":"/**\n   * Searches for all instances of {@link AbstractCheckDescriptor} on the\n   * classpath and registers each as a singleton with the\n   * {@link UpgradeCheckRegistry}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Set<BeanDefinition> registerUpgradeChecks(Set<BeanDefinition> beanDefinitions) {\n\n    // make the registry a singleton\n    UpgradeCheckRegistry registry = new UpgradeCheckRegistry();\n    bind(UpgradeCheckRegistry.class).toInstance(registry);\n\n    if (null == beanDefinitions || beanDefinitions.isEmpty()) {\n      ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);\n\n      // match all implementations of the base check class\n      AssignableTypeFilter filter = new AssignableTypeFilter(AbstractCheckDescriptor.class);\n      scanner.addIncludeFilter(filter);\n\n      beanDefinitions = scanner.findCandidateComponents(AbstractCheckDescriptor.class.getPackage().getName());\n    }\n\n    // no dispatchers is a problem\n    if (null == beanDefinitions || beanDefinitions.size() == 0) {\n      LOG.error(\"No instances of {} found to register\", AbstractCheckDescriptor.class);\n      return null;\n    }\n\n    // for every discovered check, singleton-ize them and register with the\n    // registry\n    for (BeanDefinition beanDefinition : beanDefinitions) {\n      String className = beanDefinition.getBeanClassName();\n      Class<?> clazz = ClassUtils.resolveClassName(className, ClassUtils.getDefaultClassLoader());\n\n      try {\n        AbstractCheckDescriptor upgradeCheck = (AbstractCheckDescriptor) clazz.newInstance();\n        bind((Class<AbstractCheckDescriptor>) clazz).toInstance(upgradeCheck);\n        registry.register(upgradeCheck);\n      } catch (Exception exception) {\n        LOG.error(\"Unable to bind and register upgrade check {}\", clazz, exception);\n      }\n    }\n\n    // log the order of the pre-upgrade checks\n    List<AbstractCheckDescriptor> upgradeChecks = registry.getUpgradeChecks();\n    for (AbstractCheckDescriptor upgradeCheck : upgradeChecks) {\n      LOG.debug(\"Registered pre-upgrade check {}\", upgradeCheck.getClass());\n    }\n    return beanDefinitions;\n  }","commit_id":"d237c9ad36815756685b1384a43bbb90e3aa2117","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void configure() {\n    installFactories();\n\n    final SessionIdManager sessionIdManager = new HashSessionIdManager();\n    final SessionManager sessionManager = new HashSessionManager();\n    sessionManager.getSessionCookieConfig().setPath(\"/\");\n    sessionManager.setSessionIdManager(sessionIdManager);\n    bind(SessionManager.class).toInstance(sessionManager);\n    bind(SessionIdManager.class).toInstance(sessionIdManager);\n\n    bind(KerberosOperationHandlerFactory.class);\n    bind(KerberosDescriptorFactory.class);\n    bind(KerberosServiceDescriptorFactory.class);\n    bind(KerberosHelper.class).to(KerberosHelperImpl.class);\n\n    bind(CredentialStoreService.class).to(CredentialStoreServiceImpl.class);\n\n    bind(Configuration.class).toInstance(configuration);\n    bind(OsFamily.class).toInstance(os_family);\n    bind(HostsMap.class).toInstance(hostsMap);\n    bind(PasswordEncoder.class).toInstance(new StandardPasswordEncoder());\n    bind(DelegatingFilterProxy.class).toInstance(new DelegatingFilterProxy() {\n      {\n        setTargetBeanName(\"springSecurityFilterChain\");\n      }\n    });\n\n    bind(Gson.class).annotatedWith(Names.named(\"prettyGson\")).toInstance(prettyGson);\n\n    install(buildJpaPersistModule());\n\n    bind(Gson.class).in(Scopes.SINGLETON);\n    bind(SecureRandom.class).in(Scopes.SINGLETON);\n\n    bind(Clusters.class).to(ClustersImpl.class);\n    bind(AmbariCustomCommandExecutionHelper.class);\n    bind(ActionDBAccessor.class).to(ActionDBAccessorImpl.class);\n    bindConstant().annotatedWith(Names.named(\"schedulerSleeptime\")).to(\n        configuration.getExecutionSchedulerWait());\n\n    // This time is added to summary timeout time of all tasks in stage\n    // So it's an \"additional time\", given to stage to finish execution before\n    // it is considered as timed out\n    bindConstant().annotatedWith(Names.named(\"actionTimeout\")).to(600000L);\n\n    bindConstant().annotatedWith(Names.named(\"dbInitNeeded\")).to(dbInitNeeded);\n    bindConstant().annotatedWith(Names.named(\"statusCheckInterval\")).to(5000L);\n\n    //ExecutionCommands cache size\n\n    bindConstant().annotatedWith(Names.named(\"executionCommandCacheSize\")).\n        to(configuration.getExecutionCommandsCacheSize());\n\n\n    // Host role commands status summary max cache enable/disable\n    bindConstant().annotatedWith(Names.named(HostRoleCommandDAO.HRC_STATUS_SUMMARY_CACHE_ENABLED)).\n      to(configuration.getHostRoleCommandStatusSummaryCacheEnabled());\n\n    // Host role commands status summary max cache size\n    bindConstant().annotatedWith(Names.named(HostRoleCommandDAO.HRC_STATUS_SUMMARY_CACHE_SIZE)).\n      to(configuration.getHostRoleCommandStatusSummaryCacheSize());\n    // Host role command status summary cache expiry duration in minutes\n    bindConstant().annotatedWith(Names.named(HostRoleCommandDAO.HRC_STATUS_SUMMARY_CACHE_EXPIRY_DURATION_MINUTES)).\n      to(configuration.getHostRoleCommandStatusSummaryCacheExpiryDuration());\n\n\n\n\n    bind(AmbariManagementController.class).to(\n        AmbariManagementControllerImpl.class);\n    bind(AbstractRootServiceResponseFactory.class).to(RootServiceResponseFactory.class);\n    bind(ExecutionScheduler.class).to(ExecutionSchedulerImpl.class);\n    bind(DBAccessor.class).to(DBAccessorImpl.class);\n    bind(ViewInstanceHandlerList.class).to(AmbariHandlerList.class);\n    bind(TimelineMetricCacheProvider.class);\n    bind(TimelineMetricCacheEntryFactory.class);\n    bind(SecurityConfigurationFactory.class).in(Scopes.SINGLETON);\n\n    bind(PersistedState.class).to(PersistedStateImpl.class);\n\n    // factory to create LoggingRequestHelper instances for LogSearch integration\n    bind(LoggingRequestHelperFactory.class).to(LoggingRequestHelperFactoryImpl.class);\n\n    bind(MetricsService.class).to(MetricsServiceImpl.class).in(Scopes.SINGLETON);\n\n    requestStaticInjection(DatabaseConsistencyCheckHelper.class);\n    requestStaticInjection(KerberosChecker.class);\n    requestStaticInjection(AuthorizationHelper.class);\n\n    bindByAnnotation(null);\n    bindNotificationDispatchers();\n    registerUpgradeChecks();\n  }","id":85983,"modified_method":"@Override\n  protected void configure() {\n    installFactories();\n\n    final SessionIdManager sessionIdManager = new HashSessionIdManager();\n    final SessionManager sessionManager = new HashSessionManager();\n    sessionManager.getSessionCookieConfig().setPath(\"/\");\n    sessionManager.setSessionIdManager(sessionIdManager);\n    bind(SessionManager.class).toInstance(sessionManager);\n    bind(SessionIdManager.class).toInstance(sessionIdManager);\n\n    bind(KerberosOperationHandlerFactory.class);\n    bind(KerberosDescriptorFactory.class);\n    bind(KerberosServiceDescriptorFactory.class);\n    bind(KerberosHelper.class).to(KerberosHelperImpl.class);\n\n    bind(CredentialStoreService.class).to(CredentialStoreServiceImpl.class);\n\n    bind(Configuration.class).toInstance(configuration);\n    bind(OsFamily.class).toInstance(os_family);\n    bind(HostsMap.class).toInstance(hostsMap);\n    bind(PasswordEncoder.class).toInstance(new StandardPasswordEncoder());\n    bind(DelegatingFilterProxy.class).toInstance(new DelegatingFilterProxy() {\n      {\n        setTargetBeanName(\"springSecurityFilterChain\");\n      }\n    });\n\n    bind(Gson.class).annotatedWith(Names.named(\"prettyGson\")).toInstance(prettyGson);\n\n    install(buildJpaPersistModule());\n\n    bind(Gson.class).in(Scopes.SINGLETON);\n    bind(SecureRandom.class).in(Scopes.SINGLETON);\n\n    bind(Clusters.class).to(ClustersImpl.class);\n    bind(AmbariCustomCommandExecutionHelper.class);\n    bind(ActionDBAccessor.class).to(ActionDBAccessorImpl.class);\n    bindConstant().annotatedWith(Names.named(\"schedulerSleeptime\")).to(\n        configuration.getExecutionSchedulerWait());\n\n    // This time is added to summary timeout time of all tasks in stage\n    // So it's an \"additional time\", given to stage to finish execution before\n    // it is considered as timed out\n    bindConstant().annotatedWith(Names.named(\"actionTimeout\")).to(600000L);\n\n    bindConstant().annotatedWith(Names.named(\"dbInitNeeded\")).to(dbInitNeeded);\n    bindConstant().annotatedWith(Names.named(\"statusCheckInterval\")).to(5000L);\n\n    //ExecutionCommands cache size\n\n    bindConstant().annotatedWith(Names.named(\"executionCommandCacheSize\")).\n        to(configuration.getExecutionCommandsCacheSize());\n\n\n    // Host role commands status summary max cache enable/disable\n    bindConstant().annotatedWith(Names.named(HostRoleCommandDAO.HRC_STATUS_SUMMARY_CACHE_ENABLED)).\n      to(configuration.getHostRoleCommandStatusSummaryCacheEnabled());\n\n    // Host role commands status summary max cache size\n    bindConstant().annotatedWith(Names.named(HostRoleCommandDAO.HRC_STATUS_SUMMARY_CACHE_SIZE)).\n      to(configuration.getHostRoleCommandStatusSummaryCacheSize());\n    // Host role command status summary cache expiry duration in minutes\n    bindConstant().annotatedWith(Names.named(HostRoleCommandDAO.HRC_STATUS_SUMMARY_CACHE_EXPIRY_DURATION_MINUTES)).\n      to(configuration.getHostRoleCommandStatusSummaryCacheExpiryDuration());\n\n\n\n\n    bind(AmbariManagementController.class).to(\n        AmbariManagementControllerImpl.class);\n    bind(AbstractRootServiceResponseFactory.class).to(RootServiceResponseFactory.class);\n    bind(ExecutionScheduler.class).to(ExecutionSchedulerImpl.class);\n    bind(DBAccessor.class).to(DBAccessorImpl.class);\n    bind(ViewInstanceHandlerList.class).to(AmbariHandlerList.class);\n    bind(TimelineMetricCacheProvider.class);\n    bind(TimelineMetricCacheEntryFactory.class);\n    bind(SecurityConfigurationFactory.class).in(Scopes.SINGLETON);\n\n    bind(PersistedState.class).to(PersistedStateImpl.class);\n\n    // factory to create LoggingRequestHelper instances for LogSearch integration\n    bind(LoggingRequestHelperFactory.class).to(LoggingRequestHelperFactoryImpl.class);\n\n    bind(MetricsService.class).to(MetricsServiceImpl.class).in(Scopes.SINGLETON);\n\n    requestStaticInjection(DatabaseConsistencyCheckHelper.class);\n    requestStaticInjection(KerberosChecker.class);\n    requestStaticInjection(AuthorizationHelper.class);\n\n    bindByAnnotation(null);\n    bindNotificationDispatchers(null);\n    registerUpgradeChecks(null);\n  }","commit_id":"d237c9ad36815756685b1384a43bbb90e3aa2117","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Searches for all instances of {@link NotificationDispatcher} on the\n   * classpath and registers each as a singleton with the\n   * {@link DispatchFactory}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void bindNotificationDispatchers() {\n    ClassPathScanningCandidateComponentProvider scanner =\n        new ClassPathScanningCandidateComponentProvider(false);\n\n    // make the factory a singleton\n    DispatchFactory dispatchFactory = DispatchFactory.getInstance();\n    bind(DispatchFactory.class).toInstance(dispatchFactory);\n\n    // match all implementations of the dispatcher interface\n    AssignableTypeFilter filter = new AssignableTypeFilter(\n        NotificationDispatcher.class);\n\n    scanner.addIncludeFilter(filter);\n\n    Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(\n        \"org.apache.ambari.server.notifications.dispatchers\");\n\n    // no dispatchers is a problem\n    if (null == beanDefinitions || beanDefinitions.size() == 0) {\n      LOG.error(\"No instances of {} found to register\", NotificationDispatcher.class);\n      return;\n    }\n\n    // for every discovered dispatcher, singleton-ize them and register with\n    // the dispatch factory\n    for (BeanDefinition beanDefinition : beanDefinitions) {\n      String className = beanDefinition.getBeanClassName();\n      Class<?> clazz = ClassUtils.resolveClassName(className,\n          ClassUtils.getDefaultClassLoader());\n\n      try {\n        NotificationDispatcher dispatcher;\n        if (clazz.equals(SNMPDispatcher.class)) {\n          dispatcher = (NotificationDispatcher) clazz.getConstructor(Integer.class).newInstance(configuration.getSNMPUdpBindPort());\n        } else {\n          dispatcher = (NotificationDispatcher) clazz.newInstance();\n        }\n        dispatchFactory.register(dispatcher.getType(), dispatcher);\n        bind((Class<NotificationDispatcher>) clazz).toInstance(dispatcher);\n\n        LOG.info(\"Binding and registering notification dispatcher {}\", clazz);\n      } catch (Exception exception) {\n        LOG.error(\"Unable to bind and register notification dispatcher {}\",\n            clazz, exception);\n      }\n    }\n  }","id":85984,"modified_method":"/**\n   * Searches for all instances of {@link NotificationDispatcher} on the\n   * classpath and registers each as a singleton with the\n   * {@link DispatchFactory}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  protected Set<BeanDefinition> bindNotificationDispatchers(Set<BeanDefinition> beanDefinitions) {\n\n    // make the factory a singleton\n    DispatchFactory dispatchFactory = DispatchFactory.getInstance();\n    bind(DispatchFactory.class).toInstance(dispatchFactory);\n\n    if (null == beanDefinitions || beanDefinitions.isEmpty()) {\n      ClassPathScanningCandidateComponentProvider scanner =\n        new ClassPathScanningCandidateComponentProvider(false);\n\n      // match all implementations of the dispatcher interface\n      AssignableTypeFilter filter = new AssignableTypeFilter(\n        NotificationDispatcher.class);\n\n      scanner.addIncludeFilter(filter);\n\n      beanDefinitions = scanner.findCandidateComponents(\"org.apache.ambari.server.notifications.dispatchers\");\n    }\n\n    // no dispatchers is a problem\n    if (null == beanDefinitions || beanDefinitions.size() == 0) {\n      LOG.error(\"No instances of {} found to register\", NotificationDispatcher.class);\n      return null;\n    }\n\n    // for every discovered dispatcher, singleton-ize them and register with\n    // the dispatch factory\n    for (BeanDefinition beanDefinition : beanDefinitions) {\n      String className = beanDefinition.getBeanClassName();\n      Class<?> clazz = ClassUtils.resolveClassName(className,\n          ClassUtils.getDefaultClassLoader());\n\n      try {\n        NotificationDispatcher dispatcher;\n        if (clazz.equals(SNMPDispatcher.class)) {\n          dispatcher = (NotificationDispatcher) clazz.getConstructor(Integer.class).newInstance(configuration.getSNMPUdpBindPort());\n        } else {\n          dispatcher = (NotificationDispatcher) clazz.newInstance();\n        }\n        dispatchFactory.register(dispatcher.getType(), dispatcher);\n        bind((Class<NotificationDispatcher>) clazz).toInstance(dispatcher);\n\n        LOG.info(\"Binding and registering notification dispatcher {}\", clazz);\n      } catch (Exception exception) {\n        LOG.error(\"Unable to bind and register notification dispatcher {}\",\n            clazz, exception);\n      }\n    }\n\n    return beanDefinitions;\n  }","commit_id":"d237c9ad36815756685b1384a43bbb90e3aa2117","url":"https://github.com/apache/ambari"},{"original_method":"@Before\n  public void setup() throws Exception {\n    InMemoryDefaultTestModule module = HeartbeatTestHelper.getTestModule();\n    injector = Guice.createInjector(module);\n    injector.getInstance(GuiceJpaInitializer.class);\n    clusters = injector.getInstance(Clusters.class);\n    injector.injectMembers(this);\n    unitOfWork = injector.getInstance(UnitOfWork.class);\n\n    EasyMock.replay(injector.getInstance(AuditLogger.class));\n  }","id":85985,"modified_method":"@Before\n  public void setup() throws Exception {\n    injector.getInstance(GuiceJpaInitializer.class);\n    injector.injectMembers(this);\n    EasyMock.replay(injector.getInstance(AuditLogger.class));\n  }","commit_id":"d237c9ad36815756685b1384a43bbb90e3aa2117","url":"https://github.com/apache/ambari"},{"original_method":"@After\n  public void teardown() {\n    injector.getInstance(PersistService.class).stop();\n    injector = null;\n  }","id":85986,"modified_method":"@After\n  public void teardown() {\n    injector.getInstance(PersistService.class).stop();\n  }","commit_id":"d237c9ad36815756685b1384a43bbb90e3aa2117","url":"https://github.com/apache/ambari"},{"original_method":"@Before\n  public void setup() throws Exception {\n    injector = Guice.createInjector(new InMemoryDefaultTestModule());\n    injector.getInstance(GuiceJpaInitializer.class);\n    injector.injectMembers(this);\n\n    expect(entityManagerProviderMock.get()).andReturn(null);\n    replay(entityManagerProviderMock);\n  }","id":85987,"modified_method":"@Before\n  public void setup() throws Exception {\n    injector.getInstance(GuiceJpaInitializer.class);\n    injector.getInstance(StageUtils.class);\n    injector.injectMembers(this);\n\n    expect(entityManagerProviderMock.get()).andReturn(null);\n    replay(entityManagerProviderMock);\n  }","commit_id":"d237c9ad36815756685b1384a43bbb90e3aa2117","url":"https://github.com/apache/ambari"},{"original_method":"@Before\n  public void init() {\n    reset(entityManagerProvider);\n    expect(entityManagerProvider.get()).andReturn(entityManager).anyTimes();\n    replay(entityManagerProvider);\n    injector = Guice.createInjector(new InMemoryDefaultTestModule());\n    injector.getInstance(GuiceJpaInitializer.class);\n\n    upgradeCatalogHelper = injector.getInstance(UpgradeCatalogHelper.class);\n    // inject AmbariMetaInfo to ensure that stacks get populated in the DB\n    injector.getInstance(AmbariMetaInfo.class);\n    // load the stack entity\n    StackDAO stackDAO = injector.getInstance(StackDAO.class);\n    desiredStackEntity = stackDAO.find(\"HDP\", \"2.2.0\");\n  }","id":85988,"modified_method":"@Before\n  public void init() {\n    reset(entityManagerProvider);\n    expect(entityManagerProvider.get()).andReturn(entityManager).anyTimes();\n    replay(entityManagerProvider);\n\n    injector.getInstance(GuiceJpaInitializer.class);\n\n    // inject AmbariMetaInfo to ensure that stacks get populated in the DB\n    injector.getInstance(AmbariMetaInfo.class);\n\n    injector.injectMembers(this);\n\n    // load the stack entity\n    StackDAO stackDAO = injector.getInstance(StackDAO.class);\n    desiredStackEntity = stackDAO.find(\"HDP\", \"2.2.0\");\n  }","commit_id":"d237c9ad36815756685b1384a43bbb90e3aa2117","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Initializes specially-marked interfaces that require injection.\n   * <p/>\n   * An example of where this is needed is with a singleton that is headless; in\n   * other words, it doesn't have any injections but still needs to be part of\n   * the Guice framework.\n   * <p/>\n   * A second example of where this is needed is when classes require static\n   * members that are available via injection.\n   * <p/>\n   * This currently scans {@code org.apache.ambari.server} for any\n   * {@link EagerSingleton} or {@link StaticallyInject} or {@link AmbariService}\n   * instances.\n   */\n  @SuppressWarnings(\"unchecked\")\n  private void bindByAnnotation() {\n    ClassPathScanningCandidateComponentProvider scanner =\n        new ClassPathScanningCandidateComponentProvider(false);\n\n    List<Class<? extends Annotation>> classes = Arrays.asList(\n        EagerSingleton.class, StaticallyInject.class, AmbariService.class);\n\n    // match only singletons that are eager listeners\n    for (Class<? extends Annotation> cls : classes) {\n      scanner.addIncludeFilter(new AnnotationTypeFilter(cls));\n    }\n\n    Set<BeanDefinition> beanDefinitions = scanner.findCandidateComponents(\"org.apache.ambari.server\");\n\n    if (null == beanDefinitions || beanDefinitions.size() == 0) {\n      LOG.warn(\"No instances of {} found to register\", classes);\n      return;\n    }\n\n    Set<com.google.common.util.concurrent.Service> services =\n        new HashSet<com.google.common.util.concurrent.Service>();\n\n    for (BeanDefinition beanDefinition : beanDefinitions) {\n      String className = beanDefinition.getBeanClassName();\n      Class<?> clazz = ClassUtils.resolveClassName(className,\n          ClassUtils.getDefaultClassLoader());\n\n      if (null != clazz.getAnnotation(EagerSingleton.class)) {\n        bind(clazz).asEagerSingleton();\n        LOG.debug(\"Binding singleton {} eagerly\", clazz);\n      }\n\n      if (null != clazz.getAnnotation(StaticallyInject.class)) {\n        requestStaticInjection(clazz);\n        LOG.debug(\"Statically injecting {} \", clazz);\n      }\n\n      // Ambari services are registered with Guava\n      if (null != clazz.getAnnotation(AmbariService.class)) {\n        // safety check to ensure it's actually a Guava service\n        if (!AbstractScheduledService.class.isAssignableFrom(clazz)) {\n          String message = MessageFormat.format(\n              \"Unable to register service {0} because it is not an AbstractScheduledService\",\n              clazz);\n\n          LOG.warn(message);\n          throw new RuntimeException(message);\n        }\n\n        // instantiate the service, register as singleton via toInstance()\n        AbstractScheduledService service = null;\n        try {\n          service = (AbstractScheduledService) clazz.newInstance();\n          bind((Class<AbstractScheduledService>) clazz).toInstance(service);\n          services.add(service);\n          LOG.debug(\"Registering service {} \", clazz);\n        } catch (Exception exception) {\n          LOG.error(\"Unable to register {} as a service\", clazz, exception);\n          throw new RuntimeException(exception);\n        }\n      }\n    }\n\n    ServiceManager manager = new ServiceManager(services);\n    bind(ServiceManager.class).toInstance(manager);\n  }","id":85989,"modified_method":"/**\n   * Initializes specially-marked interfaces that require injection.\n   * <p/>\n   * An example of where this is needed is with a singleton that is headless; in\n   * other words, it doesn't have any injections but still needs to be part of\n   * the Guice framework.\n   * <p/>\n   * A second example of where this is needed is when classes require static\n   * members that are available via injection.\n   * <p/>\n   * If {@code beanDefinitions} is empty or null this will scan \n   * {@code org.apache.ambari.server} (currently) for any {@link EagerSingleton}\n   * or {@link StaticallyInject} or {@link AmbariService} instances.\n   *\n   * @param beanDefinitions the set of bean definitions. If it is empty or\n   *                        {@code null} scan will occur.\n   *\n   * @return the set of bean definitions that was found during scan if\n   *         {@code beanDefinitions} was null or empty. Else original\n   *         {@code beanDefinitions} will be returned.\n   *\n   */\n  // Method is protected and returns a set of bean definitions for testing convenience.\n  @SuppressWarnings(\"unchecked\")\n  protected Set<BeanDefinition> bindByAnnotation(Set<BeanDefinition> beanDefinitions) {\n    List<Class<? extends Annotation>> classes = Arrays.asList(\n        EagerSingleton.class, StaticallyInject.class, AmbariService.class);\n\n    if (null == beanDefinitions || beanDefinitions.size() == 0) {\n      ClassPathScanningCandidateComponentProvider scanner =\n          new ClassPathScanningCandidateComponentProvider(false);\n\n      // match only singletons that are eager listeners\n      for (Class<? extends Annotation> cls : classes) {\n        scanner.addIncludeFilter(new AnnotationTypeFilter(cls));\n      }\n\n      beanDefinitions = scanner.findCandidateComponents(\"org.apache.ambari.server\");\n    }\n\n    if (null == beanDefinitions || beanDefinitions.size() == 0) {\n      LOG.warn(\"No instances of {} found to register\", classes);\n      return beanDefinitions;\n    }\n\n    Set<com.google.common.util.concurrent.Service> services =\n        new HashSet<com.google.common.util.concurrent.Service>();\n\n    for (BeanDefinition beanDefinition : beanDefinitions) {\n      String className = beanDefinition.getBeanClassName();\n      Class<?> clazz = ClassUtils.resolveClassName(className,\n          ClassUtils.getDefaultClassLoader());\n\n      if (null != clazz.getAnnotation(EagerSingleton.class)) {\n        bind(clazz).asEagerSingleton();\n        LOG.debug(\"Binding singleton {} eagerly\", clazz);\n      }\n\n      if (null != clazz.getAnnotation(StaticallyInject.class)) {\n        requestStaticInjection(clazz);\n        LOG.debug(\"Statically injecting {} \", clazz);\n      }\n\n      // Ambari services are registered with Guava\n      if (null != clazz.getAnnotation(AmbariService.class)) {\n        // safety check to ensure it's actually a Guava service\n        if (!AbstractScheduledService.class.isAssignableFrom(clazz)) {\n          String message = MessageFormat.format(\n              \"Unable to register service {0} because it is not an AbstractScheduledService\",\n              clazz);\n\n          LOG.warn(message);\n          throw new RuntimeException(message);\n        }\n\n        // instantiate the service, register as singleton via toInstance()\n        AbstractScheduledService service = null;\n        try {\n          service = (AbstractScheduledService) clazz.newInstance();\n          bind((Class<AbstractScheduledService>) clazz).toInstance(service);\n          services.add(service);\n          LOG.debug(\"Registering service {} \", clazz);\n        } catch (Exception exception) {\n          LOG.error(\"Unable to register {} as a service\", clazz, exception);\n          throw new RuntimeException(exception);\n        }\n      }\n    }\n\n    ServiceManager manager = new ServiceManager(services);\n    bind(ServiceManager.class).toInstance(manager);\n\n    return beanDefinitions;\n  }","commit_id":"855998383381d80966428b481d4448216956eb6f","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void configure() {\n    installFactories();\n\n    final SessionIdManager sessionIdManager = new HashSessionIdManager();\n    final SessionManager sessionManager = new HashSessionManager();\n    sessionManager.setSessionPath(\"/\");\n    sessionManager.setSessionIdManager(sessionIdManager);\n    bind(SessionManager.class).toInstance(sessionManager);\n    bind(SessionIdManager.class).toInstance(sessionIdManager);\n\n    bind(Configuration.class).toInstance(configuration);\n    bind(OsFamily.class).toInstance(os_family);\n    bind(HostsMap.class).toInstance(hostsMap);\n    bind(PasswordEncoder.class).toInstance(new StandardPasswordEncoder());\n    bind(DelegatingFilterProxy.class).toInstance(new DelegatingFilterProxy() {\n      {\n        setTargetBeanName(\"springSecurityFilterChain\");\n      }\n    });\n    bind(Gson.class).annotatedWith(Names.named(\"prettyGson\")).toInstance(prettyGson);\n\n    install(buildJpaPersistModule());\n\n    bind(Gson.class).in(Scopes.SINGLETON);\n    bind(SecureRandom.class).in(Scopes.SINGLETON);\n\n    bind(Clusters.class).to(ClustersImpl.class);\n    bind(AmbariCustomCommandExecutionHelper.class);\n    bind(ActionDBAccessor.class).to(ActionDBAccessorImpl.class);\n    bindConstant().annotatedWith(Names.named(\"schedulerSleeptime\")).to(10000L);\n\n    // This time is added to summary timeout time of all tasks in stage\n    // So it's an \"additional time\", given to stage to finish execution before\n    // it is considered as timed out\n    bindConstant().annotatedWith(Names.named(\"actionTimeout\")).to(600000L);\n\n    bindConstant().annotatedWith(Names.named(\"dbInitNeeded\")).to(dbInitNeeded);\n    bindConstant().annotatedWith(Names.named(\"statusCheckInterval\")).to(5000L);\n\n    //ExecutionCommands cache size\n\n    bindConstant().annotatedWith(Names.named(\"executionCommandCacheSize\")).\n        to(configuration.getExecutionCommandsCacheSize());\n\n    bind(AmbariManagementController.class)\n        .to(AmbariManagementControllerImpl.class);\n    bind(AbstractRootServiceResponseFactory.class).to(RootServiceResponseFactory.class);\n    bind(ExecutionScheduler.class).to(ExecutionSchedulerImpl.class);\n    bind(DBAccessor.class).to(DBAccessorImpl.class);\n    bind(ViewInstanceHandlerList.class).to(AmbariHandlerList.class);\n\n    requestStaticInjection(ExecutionCommandWrapper.class);\n\n    bindByAnnotation();\n  }","id":85990,"modified_method":"@Override\n  protected void configure() {\n    installFactories();\n\n    final SessionIdManager sessionIdManager = new HashSessionIdManager();\n    final SessionManager sessionManager = new HashSessionManager();\n    sessionManager.setSessionPath(\"/\");\n    sessionManager.setSessionIdManager(sessionIdManager);\n    bind(SessionManager.class).toInstance(sessionManager);\n    bind(SessionIdManager.class).toInstance(sessionIdManager);\n\n    bind(Configuration.class).toInstance(configuration);\n    bind(OsFamily.class).toInstance(os_family);\n    bind(HostsMap.class).toInstance(hostsMap);\n    bind(PasswordEncoder.class).toInstance(new StandardPasswordEncoder());\n    bind(DelegatingFilterProxy.class).toInstance(new DelegatingFilterProxy() {\n      {\n        setTargetBeanName(\"springSecurityFilterChain\");\n      }\n    });\n    bind(Gson.class).annotatedWith(Names.named(\"prettyGson\")).toInstance(prettyGson);\n\n    install(buildJpaPersistModule());\n\n    bind(Gson.class).in(Scopes.SINGLETON);\n    bind(SecureRandom.class).in(Scopes.SINGLETON);\n\n    bind(Clusters.class).to(ClustersImpl.class);\n    bind(AmbariCustomCommandExecutionHelper.class);\n    bind(ActionDBAccessor.class).to(ActionDBAccessorImpl.class);\n    bindConstant().annotatedWith(Names.named(\"schedulerSleeptime\")).to(10000L);\n\n    // This time is added to summary timeout time of all tasks in stage\n    // So it's an \"additional time\", given to stage to finish execution before\n    // it is considered as timed out\n    bindConstant().annotatedWith(Names.named(\"actionTimeout\")).to(600000L);\n\n    bindConstant().annotatedWith(Names.named(\"dbInitNeeded\")).to(dbInitNeeded);\n    bindConstant().annotatedWith(Names.named(\"statusCheckInterval\")).to(5000L);\n\n    //ExecutionCommands cache size\n\n    bindConstant().annotatedWith(Names.named(\"executionCommandCacheSize\")).\n        to(configuration.getExecutionCommandsCacheSize());\n\n    bind(AmbariManagementController.class)\n        .to(AmbariManagementControllerImpl.class);\n    bind(AbstractRootServiceResponseFactory.class).to(RootServiceResponseFactory.class);\n    bind(ExecutionScheduler.class).to(ExecutionSchedulerImpl.class);\n    bind(DBAccessor.class).to(DBAccessorImpl.class);\n    bind(ViewInstanceHandlerList.class).to(AmbariHandlerList.class);\n\n    requestStaticInjection(ExecutionCommandWrapper.class);\n\n    bindByAnnotation(null);\n  }","commit_id":"855998383381d80966428b481d4448216956eb6f","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected void configure() {\n    properties.setProperty(Configuration.SERVER_PERSISTENCE_TYPE_KEY, \"in-memory\");\n    properties.setProperty(Configuration.METADETA_DIR_PATH,\n        \"src/test/resources/stacks\");\n    properties.setProperty(Configuration.SERVER_VERSION_FILE,\n            \"target/version\");\n    properties.setProperty(Configuration.OS_VERSION_KEY,\n        \"centos5\");\n    properties.setProperty(Configuration.SHARED_RESOURCES_DIR_KEY, \"src/test/resources/\");\n\n    try {\n      install(new ControllerModule(properties));\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","id":85991,"modified_method":"@Override\n  protected void configure() {\n    properties.setProperty(Configuration.SERVER_PERSISTENCE_TYPE_KEY, \"in-memory\");\n    properties.setProperty(Configuration.METADETA_DIR_PATH,\n        \"src/test/resources/stacks\");\n    properties.setProperty(Configuration.SERVER_VERSION_FILE,\n            \"target/version\");\n    properties.setProperty(Configuration.OS_VERSION_KEY,\n        \"centos5\");\n    properties.setProperty(Configuration.SHARED_RESOURCES_DIR_KEY, \"src/test/resources/\");\n\n    try {\n      install(new BeanDefinitionsCachingTestControllerModule(properties));\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"855998383381d80966428b481d4448216956eb6f","url":"https://github.com/apache/ambari"},{"original_method":"public static void main(String[] args) {\n\n    Map<String, String> config = new HashMap<String, String>();\n\n    CConfiguration conf = CConfiguration.create();\n\n    String jdbcType = conf.get(\"passport.jdbc.type\",\"mysql\");\n    String connectionString  = conf.get(\"passport.jdbc.connection.string\",\n                                        \"jdbc:mysql://localhost:3306/passport?user=root\");\n\n    int port = conf.getInt(\"passport.http.server.port\", 7777);\n    int gracefulShutdownTime = conf.getInt(\"passport.http.graceful.shutdown.time\",10000);\n    int maxThreads = conf.getInt(\"passport.http.max.threads\",100);\n\n    config.put(\"jdbcType\", jdbcType);\n    config.put(\"connectionString\",connectionString);\n\n    Realm realm = new JDBCAuthrozingRealm(config);\n\n    org.apache.shiro.mgt.SecurityManager securityManager = new DefaultSecurityManager(realm);\n    SecurityUtils.setSecurityManager(securityManager);\n\n    PassportHttpServer server = new PassportHttpServer(port, config, maxThreads,gracefulShutdownTime);\n    server.start();\n\n\n  }","id":85992,"modified_method":"public static void main(String[] args) {\n\n    Map<String, String> config = new HashMap<String, String>();\n\n    CConfiguration conf = CConfiguration.create();\n\n    String jdbcType = conf.get(\"passport.jdbc.type\",\"mysql\");\n    String connectionString  = conf.get(\"passport.jdbc.connection.string\",\n                                        \"jdbc:mysql://localhost:3306/passport?user=root&\" +\n                                        \"zeroDateTimeBehavior=convertToNull\");\n\n    int port = conf.getInt(\"passport.http.server.port\", 7777);\n    int gracefulShutdownTime = conf.getInt(\"passport.http.graceful.shutdown.time\",10000);\n    int maxThreads = conf.getInt(\"passport.http.max.threads\",100);\n\n    config.put(\"jdbcType\", jdbcType);\n    config.put(\"connectionString\",connectionString);\n\n    Realm realm = new JDBCAuthrozingRealm(config);\n\n    org.apache.shiro.mgt.SecurityManager securityManager = new DefaultSecurityManager(realm);\n    SecurityUtils.setSecurityManager(securityManager);\n\n    PassportHttpServer server = new PassportHttpServer(port, config, maxThreads,gracefulShutdownTime);\n    server.start();\n\n\n  }","commit_id":"9684b56e63dc274c58a053350030f1432ade54cf","url":"https://github.com/caskdata/cdap"},{"original_method":"private void start() {\n\n    try {\n\n      Server server = new Server();\n      server.setStopAtShutdown(true);\n      server.setGracefulShutdown(gracefulShutdownTime);\n\n      Context context = new Context(server, \"/\", Context.SESSIONS);\n      context.addEventListener(new PassportGuiceServletContextListener(configuration));\n      context.addServlet(DefaultServlet.class, \"/\");\n      context.addFilter(GuiceFilter.class, \"/*\", 0);\n\n      // Use the connector to bind Jetty to local host\n      Connector connector = new SelectChannelConnector();\n      connector.setHost(\"localhost\");\n      connector.setPort(port);\n      server.addConnector(connector);\n\n      QueuedThreadPool threadPool = new QueuedThreadPool();\n      threadPool.setMaxThreads(maxThreads);\n      server.setThreadPool(threadPool);\n\n      //JMX jetty\n      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n      MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);\n      server.getContainer().addEventListener(mBeanContainer);\n      mBeanContainer.start();\n\n      LOG.info(\"Starting the server with the following parameters\");\n      LOG.info(String.format(\"Port: %d\",port));\n      LOG.info(String.format(\"Threads: %d\",maxThreads));\n      for(Map.Entry<String,String> e: configuration.entrySet()){\n        LOG.info(\"Config %s: %s\", e.getKey(),e.getValue());\n      }\n\n      server.start();\n      server.join();\n      LOG.info(\"Server started Successfully\");\n\n    } catch (Exception e) {\n      LOG.error(\"Error while starting server\");\n      LOG.error(e.getMessage());\n    }\n  }","id":85993,"modified_method":"private void start() {\n\n    try {\n\n      Server server = new Server();\n      server.setStopAtShutdown(true);\n      server.setGracefulShutdown(gracefulShutdownTime);\n\n      Context context = new Context(server, \"/\", Context.SESSIONS);\n      context.addEventListener(new PassportGuiceServletContextListener(configuration));\n      context.addServlet(DefaultServlet.class, \"/\");\n      context.addFilter(GuiceFilter.class, \"/*\", 0);\n\n      // Use the connector to bind Jetty to local host\n      Connector connector = new SelectChannelConnector();\n      connector.setHost(\"localhost\");\n      connector.setPort(port);\n      server.addConnector(connector);\n\n      QueuedThreadPool threadPool = new QueuedThreadPool();\n      threadPool.setMaxThreads(maxThreads);\n      server.setThreadPool(threadPool);\n\n      //JMX jetty\n      MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n      MBeanContainer mBeanContainer = new MBeanContainer(mBeanServer);\n      server.getContainer().addEventListener(mBeanContainer);\n      mBeanContainer.start();\n\n      LOG.info(\"Starting the server with the following parameters\");\n      LOG.info(String.format(\"Port: %d\",port));\n      LOG.info(String.format(\"Threads: %d\",maxThreads));\n      for(Map.Entry<String,String> e: configuration.entrySet()){\n        LOG.info(String.format(\"Config %s : %s\", e.getKey(),e.getValue()));\n        System.out.println(e.getKey()+\" \"+e.getValue());\n      }\n\n      server.start();\n      server.join();\n      LOG.info(\"Server started Successfully\");\n\n    } catch (Exception e) {\n      LOG.error(\"Error while starting server\");\n      LOG.error(e.getMessage());\n    }\n  }","commit_id":"9684b56e63dc274c58a053350030f1432ade54cf","url":"https://github.com/caskdata/cdap"},{"original_method":"public void runMayThrow() throws Exception\n        {\n            logger.info(String.format(\"[repair #%s] new session: will sync %s on range %s for %s.%s\", getName(), repairedNodes(), range, tablename, Arrays.toString(cfnames)));\n\n            if (endpoints.isEmpty())\n            {\n                differencingDone.signalAll();\n                logger.info(\"[repair #%s] No neighbors to repair with on range %s: session completed\", getName(), range);\n                return;\n            }\n\n            // Checking all nodes are live\n            for (InetAddress endpoint : endpoints)\n            {\n                if (!FailureDetector.instance.isAlive(endpoint))\n                {\n                    differencingDone.signalAll();\n                    logger.info(\"[repair #%s] Could not proceed on repair because a neighbor (%s) is dead: session failed\", getName(), endpoint);\n                    return;\n                }\n            }\n\n            AntiEntropyService.instance.sessions.put(getName(), this);\n            Gossiper.instance.register(this);\n            FailureDetector.instance.registerFailureDetectionEventListener(this);\n            try\n            {\n                // Create and queue a RepairJob for each column family\n                for (String cfname : cfnames)\n                {\n                    RepairJob job = new RepairJob(cfname);\n                    jobs.offer(job);\n                    activeJobs.put(cfname, job);\n                }\n\n                jobs.peek().sendTreeRequests();\n\n                // block whatever thread started this session until all requests have been returned:\n                // if this thread dies, the session will still complete in the background\n                completed.await();\n                if (exception == null)\n                {\n                    logger.info(String.format(\"[repair #%s] session completed successfully\", getName()));\n                }\n                else\n                {\n                    logger.error(String.format(\"[repair #%s] session completed with the following error\", getName()), exception);\n                    throw exception;\n                }\n            }\n            catch (InterruptedException e)\n            {\n                throw new RuntimeException(\"Interrupted while waiting for repair: repair will continue in the background.\");\n            }\n            finally\n            {\n                FailureDetector.instance.unregisterFailureDetectionEventListener(this);\n                Gossiper.instance.unregister(this);\n                AntiEntropyService.instance.sessions.remove(getName());\n            }\n        }","id":85994,"modified_method":"public void runMayThrow() throws Exception\n        {\n            logger.info(String.format(\"[repair #%s] new session: will sync %s on range %s for %s.%s\", getName(), repairedNodes(), range, tablename, Arrays.toString(cfnames)));\n\n            if (endpoints.isEmpty())\n            {\n                differencingDone.signalAll();\n                logger.info(\"[repair #%s] No neighbors to repair with on range %s: session completed\", getName(), range);\n                return;\n            }\n\n            // Checking all nodes are live\n            for (InetAddress endpoint : endpoints)\n            {\n                if (!FailureDetector.instance.isAlive(endpoint))\n                {\n                    differencingDone.signalAll();\n                    logger.info(String.format(\"[repair #%s] Cannot proceed on repair because a neighbor (%s) is dead: session failed\", getName(), endpoint));\n                    return;\n                }\n            }\n\n            AntiEntropyService.instance.sessions.put(getName(), this);\n            Gossiper.instance.register(this);\n            FailureDetector.instance.registerFailureDetectionEventListener(this);\n            try\n            {\n                // Create and queue a RepairJob for each column family\n                for (String cfname : cfnames)\n                {\n                    RepairJob job = new RepairJob(cfname);\n                    jobs.offer(job);\n                    activeJobs.put(cfname, job);\n                }\n\n                jobs.peek().sendTreeRequests();\n\n                // block whatever thread started this session until all requests have been returned:\n                // if this thread dies, the session will still complete in the background\n                completed.await();\n                if (exception == null)\n                {\n                    logger.info(String.format(\"[repair #%s] session completed successfully\", getName()));\n                }\n                else\n                {\n                    logger.error(String.format(\"[repair #%s] session completed with the following error\", getName()), exception);\n                    throw exception;\n                }\n            }\n            catch (InterruptedException e)\n            {\n                throw new RuntimeException(\"Interrupted while waiting for repair: repair will continue in the background.\");\n            }\n            finally\n            {\n                FailureDetector.instance.unregisterFailureDetectionEventListener(this);\n                Gossiper.instance.unregister(this);\n                AntiEntropyService.instance.sessions.remove(getName());\n            }\n        }","commit_id":"c3b5073b063ed291cf9b7aee27b3b62286ca4eec","url":"https://github.com/apache/cassandra"},{"original_method":"public void runMayThrow() throws Exception\n        {\n            logger.info(String.format(\"[repair #%s] new session: will sync %s on range %s for %s.%s\", getName(), repairedNodes(), range, tablename, Arrays.toString(cfnames)));\n\n            if (endpoints.isEmpty())\n            {\n                differencingDone.signalAll();\n                logger.info(\"[repair #%s] No neighbors to repair with on range %s: session completed\", getName(), range);\n                return;\n            }\n\n            // Checking all nodes are live\n            for (InetAddress endpoint : endpoints)\n            {\n                if (!FailureDetector.instance.isAlive(endpoint))\n                {\n                    differencingDone.signalAll();\n                    logger.info(String.format(\"[repair #%s] Cannot proceed on repair because a neighbor (%s) is dead: session failed\", getName(), endpoint));\n                    return;\n                }\n            }\n\n            AntiEntropyService.instance.sessions.put(getName(), this);\n            Gossiper.instance.register(this);\n            FailureDetector.instance.registerFailureDetectionEventListener(this);\n            try\n            {\n                // Create and queue a RepairJob for each column family\n                for (String cfname : cfnames)\n                {\n                    RepairJob job = new RepairJob(cfname);\n                    jobs.offer(job);\n                    activeJobs.put(cfname, job);\n                }\n\n                jobs.peek().sendTreeRequests();\n\n                // block whatever thread started this session until all requests have been returned:\n                // if this thread dies, the session will still complete in the background\n                completed.await();\n                if (exception == null)\n                {\n                    logger.info(String.format(\"[repair #%s] session completed successfully\", getName()));\n                }\n                else\n                {\n                    logger.error(String.format(\"[repair #%s] session completed with the following error\", getName()), exception);\n                    throw exception;\n                }\n            }\n            catch (InterruptedException e)\n            {\n                throw new RuntimeException(\"Interrupted while waiting for repair.\");\n            }\n            finally\n            {\n                // mark this session as terminated\n                terminate();\n                FailureDetector.instance.unregisterFailureDetectionEventListener(this);\n                Gossiper.instance.unregister(this);\n                AntiEntropyService.instance.sessions.remove(getName());\n            }\n        }","id":85995,"modified_method":"public void runMayThrow() throws Exception\n        {\n            logger.info(String.format(\"[repair #%s] new session: will sync %s on range %s for %s.%s\", getName(), repairedNodes(), range, tablename, Arrays.toString(cfnames)));\n\n            if (endpoints.isEmpty())\n            {\n                differencingDone.signalAll();\n                logger.info(String.format(\"[repair #%s] No neighbors to repair with on range %s: session completed\", getName(), range));\n                return;\n            }\n\n            // Checking all nodes are live\n            for (InetAddress endpoint : endpoints)\n            {\n                if (!FailureDetector.instance.isAlive(endpoint))\n                {\n                    differencingDone.signalAll();\n                    logger.info(String.format(\"[repair #%s] Cannot proceed on repair because a neighbor (%s) is dead: session failed\", getName(), endpoint));\n                    return;\n                }\n            }\n\n            AntiEntropyService.instance.sessions.put(getName(), this);\n            Gossiper.instance.register(this);\n            FailureDetector.instance.registerFailureDetectionEventListener(this);\n            try\n            {\n                // Create and queue a RepairJob for each column family\n                for (String cfname : cfnames)\n                {\n                    RepairJob job = new RepairJob(cfname);\n                    jobs.offer(job);\n                    activeJobs.put(cfname, job);\n                }\n\n                jobs.peek().sendTreeRequests();\n\n                // block whatever thread started this session until all requests have been returned:\n                // if this thread dies, the session will still complete in the background\n                completed.await();\n                if (exception == null)\n                {\n                    logger.info(String.format(\"[repair #%s] session completed successfully\", getName()));\n                }\n                else\n                {\n                    logger.error(String.format(\"[repair #%s] session completed with the following error\", getName()), exception);\n                    throw exception;\n                }\n            }\n            catch (InterruptedException e)\n            {\n                throw new RuntimeException(\"Interrupted while waiting for repair.\");\n            }\n            finally\n            {\n                // mark this session as terminated\n                terminate();\n                FailureDetector.instance.unregisterFailureDetectionEventListener(this);\n                Gossiper.instance.unregister(this);\n                AntiEntropyService.instance.sessions.remove(getName());\n            }\n        }","commit_id":"ec76baf0dd2a976542106cd5e58652c3d36ffd23","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Compares our trees, and triggers repairs for any ranges that mismatch.\n     */\n    public void run()\n    {\n        // compare trees, and collect differences\n        differences.addAll(MerkleTree.difference(r1.tree, r2.tree));\n\n        // choose a repair method based on the significance of the difference\n        String format = String.format(\"[repair #%s] Endpoints %s and %s %%s for %s\", desc.sessionId, r1.endpoint, r2.endpoint, desc.columnFamily);\n        if (differences.isEmpty())\n        {\n            logger.info(String.format(format, \"are consistent\"));\n            // send back sync complete message\n            MessagingService.instance().sendOneWay(new SyncComplete(desc, r1.endpoint, r2.endpoint, true).createMessage(), FBUtilities.getLocalAddress());\n            return;\n        }\n\n        // non-0 difference: perform streaming repair\n        logger.info(format, \"have {} range(s) out of sync\", differences.size());\n        performStreamingRepair();\n    }","id":85996,"modified_method":"/**\n     * Compares our trees, and triggers repairs for any ranges that mismatch.\n     */\n    public void run()\n    {\n        // compare trees, and collect differences\n        differences.addAll(MerkleTree.difference(r1.tree, r2.tree));\n\n        // choose a repair method based on the significance of the difference\n        String format = String.format(\"[repair #%s] Endpoints %s and %s %%s for %s\", desc.sessionId, r1.endpoint, r2.endpoint, desc.columnFamily);\n        if (differences.isEmpty())\n        {\n            logger.info(String.format(format, \"are consistent\"));\n            // send back sync complete message\n            MessagingService.instance().sendOneWay(new SyncComplete(desc, r1.endpoint, r2.endpoint, true).createMessage(), FBUtilities.getLocalAddress());\n            return;\n        }\n\n        // non-0 difference: perform streaming repair\n        logger.info(String.format(format, \"have \" + differences.size() + \" range(s) out of sync\"));\n        performStreamingRepair();\n    }","commit_id":"66a6990aa076bbcdebee952f47c95ccdad735dbc","url":"https://github.com/apache/cassandra"},{"original_method":"public void runMayThrow() throws Exception\n        {\n            logger.info(String.format(\"[repair #%s] new session: will sync %s on range %s for %s.%s\", getName(), repairedNodes(), range, tablename, Arrays.toString(cfnames)));\n\n            if (endpoints.isEmpty())\n            {\n                differencingDone.signalAll();\n                logger.info(\"[repair #%s] No neighbors to repair with on range %s: session completed\", getName(), range);\n                return;\n            }\n\n            // Checking all nodes are live\n            for (InetAddress endpoint : endpoints)\n            {\n                if (!FailureDetector.instance.isAlive(endpoint))\n                {\n                    differencingDone.signalAll();\n                    logger.info(String.format(\"[repair #%s] Cannot proceed on repair because a neighbor (%s) is dead: session failed\", getName(), endpoint));\n                    return;\n                }\n\n                if (MessagingService.instance().getVersion(endpoint) < MessagingService.VERSION_11 && isSequential)\n                {\n                    logger.info(String.format(\"[repair #%s] Cannot repair using snapshots as node %s is pre-1.1\", getName(), endpoint));\n                    return;\n                }\n            }\n\n            AntiEntropyService.instance.sessions.put(getName(), this);\n            Gossiper.instance.register(this);\n            FailureDetector.instance.registerFailureDetectionEventListener(this);\n            try\n            {\n                // Create and queue a RepairJob for each column family\n                for (String cfname : cfnames)\n                {\n                    RepairJob job = new RepairJob(cfname);\n                    jobs.offer(job);\n                    activeJobs.put(cfname, job);\n                }\n\n                jobs.peek().sendTreeRequests();\n\n                // block whatever thread started this session until all requests have been returned:\n                // if this thread dies, the session will still complete in the background\n                completed.await();\n                if (exception == null)\n                {\n                    logger.info(String.format(\"[repair #%s] session completed successfully\", getName()));\n                }\n                else\n                {\n                    logger.error(String.format(\"[repair #%s] session completed with the following error\", getName()), exception);\n                    throw exception;\n                }\n            }\n            catch (InterruptedException e)\n            {\n                throw new RuntimeException(\"Interrupted while waiting for repair.\");\n            }\n            finally\n            {\n                // mark this session as terminated\n                terminate();\n                FailureDetector.instance.unregisterFailureDetectionEventListener(this);\n                Gossiper.instance.unregister(this);\n                AntiEntropyService.instance.sessions.remove(getName());\n            }\n        }","id":85997,"modified_method":"public void runMayThrow() throws Exception\n        {\n            logger.info(String.format(\"[repair #%s] new session: will sync %s on range %s for %s.%s\", getName(), repairedNodes(), range, tablename, Arrays.toString(cfnames)));\n\n            if (endpoints.isEmpty())\n            {\n                differencingDone.signalAll();\n                logger.info(String.format(\"[repair #%s] No neighbors to repair with on range %s: session completed\", getName(), range));\n                return;\n            }\n\n            // Checking all nodes are live\n            for (InetAddress endpoint : endpoints)\n            {\n                if (!FailureDetector.instance.isAlive(endpoint))\n                {\n                    differencingDone.signalAll();\n                    logger.info(String.format(\"[repair #%s] Cannot proceed on repair because a neighbor (%s) is dead: session failed\", getName(), endpoint));\n                    return;\n                }\n\n                if (MessagingService.instance().getVersion(endpoint) < MessagingService.VERSION_11 && isSequential)\n                {\n                    logger.info(String.format(\"[repair #%s] Cannot repair using snapshots as node %s is pre-1.1\", getName(), endpoint));\n                    return;\n                }\n            }\n\n            AntiEntropyService.instance.sessions.put(getName(), this);\n            Gossiper.instance.register(this);\n            FailureDetector.instance.registerFailureDetectionEventListener(this);\n            try\n            {\n                // Create and queue a RepairJob for each column family\n                for (String cfname : cfnames)\n                {\n                    RepairJob job = new RepairJob(cfname);\n                    jobs.offer(job);\n                    activeJobs.put(cfname, job);\n                }\n\n                jobs.peek().sendTreeRequests();\n\n                // block whatever thread started this session until all requests have been returned:\n                // if this thread dies, the session will still complete in the background\n                completed.await();\n                if (exception == null)\n                {\n                    logger.info(String.format(\"[repair #%s] session completed successfully\", getName()));\n                }\n                else\n                {\n                    logger.error(String.format(\"[repair #%s] session completed with the following error\", getName()), exception);\n                    throw exception;\n                }\n            }\n            catch (InterruptedException e)\n            {\n                throw new RuntimeException(\"Interrupted while waiting for repair.\");\n            }\n            finally\n            {\n                // mark this session as terminated\n                terminate();\n                FailureDetector.instance.unregisterFailureDetectionEventListener(this);\n                Gossiper.instance.unregister(this);\n                AntiEntropyService.instance.sessions.remove(getName());\n            }\n        }","commit_id":"58c5533e956cab461a4122e63212cee1f8275713","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n   * For each identity, create a keytab and append to a new or existing keytab file.\n   * <p/>\n   * It is expected that the {@link org.apache.ambari.server.serveraction.kerberos.CreatePrincipalsServerAction}\n   * (or similar) has executed before this action and a set of passwords has been created, map to\n   * their relevant (evaluated) principals and stored in the requestSharedDataContext.\n   * <p/>\n   * If a password exists for the current evaluatedPrincipal, use a\n   * {@link org.apache.ambari.server.serveraction.kerberos.KerberosOperationHandler} to generate\n   * the keytab file. To help avoid filename collisions and to build a structure that is easy to\n   * discover, each keytab file is stored in host-specific\n   * ({@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFile#HOSTNAME})\n   * directory using the SHA1 hash of its destination file path\n   * ({@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFile#KEYTAB_FILE_PATH})\n   * <p/>\n   * <pre>\n   *   data_directory\n   *   |- host1\n   *   |  |- 16a054404c8826cd604a27ac970e8cc4b9c7a3fa   (keytab file)\n   *   |  |- ...                                        (keytab files)\n   *   |  |- a3c09cae73406912e8c55296d1c85b674d24f576   (keytab file)\n   *   |- host2\n   *   |  |- ...\n   * <\/pre>\n   *\n   * @param identityRecord           a Map containing the data for the current identity record\n   * @param evaluatedPrincipal       a String indicating the relevant principal\n   * @param operationHandler         a KerberosOperationHandler used to perform Kerberos-related\n   *                                 tasks for specific Kerberos implementations\n   *                                 (MIT, Active Directory, etc...)\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport, indicating an error condition; or null, indicating a success condition\n   * @throws AmbariException if an error occurs while processing the identity record\n   */\n  @Override\n  protected CommandReport processIdentity(Map<String, String> identityRecord, String evaluatedPrincipal,\n                                          KerberosOperationHandler operationHandler,\n                                          Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n\n    if (identityRecord != null) {\n\n      if (operationHandler == null) {\n        String message = String.format(\"Failed to create keytab file for %s, missing handler\", evaluatedPrincipal);\n        LOG.error(message);\n        commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n      } else {\n        Map<String, String> principalPasswordMap = getPrincipalPasswordMap(requestSharedDataContext);\n        Map<String, Integer> principalKeyNumberMap = getPrincipalKeyNumberMap(requestSharedDataContext);\n\n        String host = identityRecord.get(HOSTNAME);\n        String keytabFilePath = identityRecord.get(KEYTAB_FILE_PATH);\n\n        if ((host != null) && !host.isEmpty() && (keytabFilePath != null) && !keytabFilePath.isEmpty()) {\n          // Look up the current evaluatedPrincipal's password.\n          // If found create th keytab file, else skip it.\n          String password = principalPasswordMap.get(evaluatedPrincipal);\n\n          if (password == null) {\n            String message = String.format(\"Failed to create keytab file for %s, missing password\", evaluatedPrincipal);\n            LOG.error(message);\n            commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n          } else {\n            // Determine where to store the keytab file.  It should go into a host-specific\n            // directory under the previously determined data directory.\n            File hostDirectory = new File(getDataDirectoryPath(), host);\n\n            // Ensure the host directory exists...\n            if (hostDirectory.exists() || hostDirectory.mkdirs()) {\n              File keytabFile = new File(hostDirectory, DigestUtils.sha1Hex(keytabFilePath));\n              Integer keyNumber = principalKeyNumberMap.get(evaluatedPrincipal);\n\n              try {\n                if (operationHandler.createKeytabFile(evaluatedPrincipal, password, keyNumber, keytabFile)) {\n                  LOG.debug(\"Successfully created keytab file for {} at {}\",\n                      evaluatedPrincipal, keytabFile.getAbsolutePath());\n                } else {\n                  String message = String.format(\"Failed to create keytab file for %s at %s\",\n                      evaluatedPrincipal, keytabFile.getAbsolutePath());\n                  LOG.error(message);\n                  commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n                }\n              } catch (KerberosOperationException e) {\n                String message = String.format(\"Failed to create keytab file for %s - %s\", evaluatedPrincipal, e.getMessage());\n                LOG.error(message, e);\n                commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n              }\n            } else {\n              String message = String.format(\"Failed to create keytab file for %s, the container directory does not exist: %s\",\n                  evaluatedPrincipal, hostDirectory.getAbsolutePath());\n              LOG.error(message);\n              commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n            }\n          }\n        }\n      }\n    }\n\n    return commandReport;\n  }","id":85998,"modified_method":"/**\n   * For each identity, create a keytab and append to a new or existing keytab file.\n   * <p/>\n   * It is expected that the {@link org.apache.ambari.server.serveraction.kerberos.CreatePrincipalsServerAction}\n   * (or similar) has executed before this action and a set of passwords has been created, map to\n   * their relevant (evaluated) principals and stored in the requestSharedDataContext.\n   * <p/>\n   * If a password exists for the current evaluatedPrincipal, use a\n   * {@link org.apache.ambari.server.serveraction.kerberos.KerberosOperationHandler} to generate\n   * the keytab file. To help avoid filename collisions and to build a structure that is easy to\n   * discover, each keytab file is stored in host-specific\n   * ({@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFile#HOSTNAME})\n   * directory using the SHA1 hash of its destination file path\n   * ({@link org.apache.ambari.server.serveraction.kerberos.KerberosActionDataFile#KEYTAB_FILE_PATH})\n   * <p/>\n   * <pre>\n   *   data_directory\n   *   |- host1\n   *   |  |- 16a054404c8826cd604a27ac970e8cc4b9c7a3fa   (keytab file)\n   *   |  |- ...                                        (keytab files)\n   *   |  |- a3c09cae73406912e8c55296d1c85b674d24f576   (keytab file)\n   *   |- host2\n   *   |  |- ...\n   * <\/pre>\n   *\n   * @param identityRecord           a Map containing the data for the current identity record\n   * @param evaluatedPrincipal       a String indicating the relevant principal\n   * @param operationHandler         a KerberosOperationHandler used to perform Kerberos-related\n   *                                 tasks for specific Kerberos implementations\n   *                                 (MIT, Active Directory, etc...)\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport, indicating an error condition; or null, indicating a success condition\n   * @throws AmbariException if an error occurs while processing the identity record\n   */\n  @Override\n  protected CommandReport processIdentity(Map<String, String> identityRecord, String evaluatedPrincipal,\n                                          KerberosOperationHandler operationHandler,\n                                          Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n\n    if (identityRecord != null) {\n      String message = String.format(\"Creating keytab file for %s\", evaluatedPrincipal);\n      LOG.info(message);\n      actionLog.writeStdOut(message);\n\n      if (operationHandler == null) {\n        message = String.format(\"Failed to create keytab file for %s, missing KerberosOperationHandler\", evaluatedPrincipal);\n        actionLog.writeStdErr(message);\n        LOG.error(message);\n        commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n      } else {\n        Map<String, String> principalPasswordMap = getPrincipalPasswordMap(requestSharedDataContext);\n        Map<String, Integer> principalKeyNumberMap = getPrincipalKeyNumberMap(requestSharedDataContext);\n\n        String host = identityRecord.get(HOSTNAME);\n        String keytabFilePath = identityRecord.get(KEYTAB_FILE_PATH);\n\n        if ((host != null) && !host.isEmpty() && (keytabFilePath != null) && !keytabFilePath.isEmpty()) {\n          // Look up the current evaluatedPrincipal's password.\n          // If found create th keytab file, else skip it.\n          String password = principalPasswordMap.get(evaluatedPrincipal);\n\n          if (password == null) {\n            message = String.format(\"Failed to create keytab file for %s, missing password\", evaluatedPrincipal);\n            actionLog.writeStdErr(message);\n            LOG.error(message);\n            commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n          } else {\n            // Determine where to store the keytab file.  It should go into a host-specific\n            // directory under the previously determined data directory.\n            File hostDirectory = new File(getDataDirectoryPath(), host);\n\n            // Ensure the host directory exists...\n            if (hostDirectory.exists() || hostDirectory.mkdirs()) {\n              File keytabFile = new File(hostDirectory, DigestUtils.sha1Hex(keytabFilePath));\n              Integer keyNumber = principalKeyNumberMap.get(evaluatedPrincipal);\n\n              try {\n                if (operationHandler.createKeytabFile(evaluatedPrincipal, password, keyNumber, keytabFile)) {\n                  message = String.format(\"Successfully created keytab file for %s at %s\", evaluatedPrincipal, keytabFile.getAbsolutePath());\n                  LOG.debug(message);\n                } else {\n                  message = String.format(\"Failed to create keytab file for %s at %s\", evaluatedPrincipal, keytabFile.getAbsolutePath());\n                  actionLog.writeStdErr(message);\n                  LOG.error(message);\n                  commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n                }\n              } catch (KerberosOperationException e) {\n                message = String.format(\"Failed to create keytab file for %s - %s\", evaluatedPrincipal, e.getMessage());\n                actionLog.writeStdErr(message);\n                LOG.error(message, e);\n                commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n              }\n            } else {\n              message = String.format(\"Failed to create keytab file for %s, the container directory does not exist: %s\",\n                  evaluatedPrincipal, hostDirectory.getAbsolutePath());\n              actionLog.writeStdErr(message);\n              LOG.error(message);\n              commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n            }\n          }\n        }\n      }\n    }\n\n    return commandReport;\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * For each identity, generate a unique password create a new or update an existing principal in\n   * an assume to be configured KDC.\n   * <p/>\n   * If a password has not been previously created the current evaluatedPrincipal, create a \"secure\"\n   * password using {@link KerberosOperationHandler#createSecurePassword()}.  Then if the principal\n   * does not exist in the KDC, create it using the generated password; else if it does exist update\n   * its password.  Finally store the generated password in the shared principal-to-password map and\n   * store the new key numbers in the shared principal-to-key_number map so that subsequent process\n   * may use the data if necessary.\n   *\n   * @param identityRecord           a Map containing the data for the current identity record\n   * @param evaluatedPrincipal       a String indicating the relevant principal\n   * @param operationHandler         a KerberosOperationHandler used to perform Kerberos-related\n   *                                 tasks for specific Kerberos implementations\n   *                                 (MIT, Active Directory, etc...)\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport, indicating an error condition; or null, indicating a success condition\n   * @throws AmbariException if an error occurs while processing the identity record\n   */\n  @Override\n  protected CommandReport processIdentity(Map<String, String> identityRecord, String evaluatedPrincipal,\n                                          KerberosOperationHandler operationHandler,\n                                          Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n\n    Map<String, String> principalPasswordMap = getPrincipalPasswordMap(requestSharedDataContext);\n    Map<String, Integer> principalKeyNumberMap = getPrincipalKeyNumberMap(requestSharedDataContext);\n\n    String password = principalPasswordMap.get(evaluatedPrincipal);\n\n    if (password == null) {\n      password = operationHandler.createSecurePassword();\n\n      try {\n        if (operationHandler.principalExists(evaluatedPrincipal)) {\n          // Create a new password since we need to know what it is.\n          // A new password/key would have been generated after exporting the keytab anyways.\n          LOG.warn(\"Principal already exists, setting new password - {}\", evaluatedPrincipal);\n\n          Integer keyNumber = operationHandler.setPrincipalPassword(evaluatedPrincipal, password);\n\n          if (keyNumber != null) {\n            principalPasswordMap.put(evaluatedPrincipal, password);\n            principalKeyNumberMap.put(evaluatedPrincipal, keyNumber);\n            LOG.debug(\"Successfully set password for principal {}\", evaluatedPrincipal);\n          } else {\n            String message = String.format(\"Failed to set password for principal %s - unknown reason\", evaluatedPrincipal);\n            LOG.error(message);\n            commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n          }\n        } else {\n          LOG.debug(\"Creating new principal - {}\", evaluatedPrincipal);\n          boolean servicePrincipal = \"service\".equalsIgnoreCase(identityRecord.get(KerberosActionDataFile.PRINCIPAL_TYPE));\n          Integer keyNumber = operationHandler.createPrincipal(evaluatedPrincipal, password, servicePrincipal);\n\n          if (keyNumber != null) {\n            principalPasswordMap.put(evaluatedPrincipal, password);\n            principalKeyNumberMap.put(evaluatedPrincipal, keyNumber);\n            LOG.debug(\"Successfully created new principal {}\", evaluatedPrincipal);\n          } else {\n            String message = String.format(\"Failed to create principal %s - unknown reason\", evaluatedPrincipal);\n            LOG.error(message);\n            commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n          }\n        }\n      } catch (KerberosOperationException e) {\n        String message = String.format(\"Failed to create principal %s - %s\", evaluatedPrincipal, e.getMessage());\n        LOG.error(message, e);\n        commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", \"\", message);\n      }\n    }\n\n    return commandReport;\n  }","id":85999,"modified_method":"/**\n   * For each identity, generate a unique password create a new or update an existing principal in\n   * an assume to be configured KDC.\n   * <p/>\n   * If a password has not been previously created the current evaluatedPrincipal, create a \"secure\"\n   * password using {@link KerberosOperationHandler#createSecurePassword()}.  Then if the principal\n   * does not exist in the KDC, create it using the generated password; else if it does exist update\n   * its password.  Finally store the generated password in the shared principal-to-password map and\n   * store the new key numbers in the shared principal-to-key_number map so that subsequent process\n   * may use the data if necessary.\n   *\n   * @param identityRecord           a Map containing the data for the current identity record\n   * @param evaluatedPrincipal       a String indicating the relevant principal\n   * @param operationHandler         a KerberosOperationHandler used to perform Kerberos-related\n   *                                 tasks for specific Kerberos implementations\n   *                                 (MIT, Active Directory, etc...)\n   * @param requestSharedDataContext a Map to be used a shared data among all ServerActions related\n   *                                 to a given request\n   * @return a CommandReport, indicating an error condition; or null, indicating a success condition\n   * @throws AmbariException if an error occurs while processing the identity record\n   */\n  @Override\n  protected CommandReport processIdentity(Map<String, String> identityRecord, String evaluatedPrincipal,\n                                          KerberosOperationHandler operationHandler,\n                                          Map<String, Object> requestSharedDataContext)\n      throws AmbariException {\n    CommandReport commandReport = null;\n\n    Map<String, String> principalPasswordMap = getPrincipalPasswordMap(requestSharedDataContext);\n    Map<String, Integer> principalKeyNumberMap = getPrincipalKeyNumberMap(requestSharedDataContext);\n\n    String password = principalPasswordMap.get(evaluatedPrincipal);\n\n    if (password == null) {\n      String message = String.format(\"Creating principal, %s\", evaluatedPrincipal);\n      LOG.info(message);\n      actionLog.writeStdOut(message);\n\n      password = operationHandler.createSecurePassword();\n\n      try {\n        if (operationHandler.principalExists(evaluatedPrincipal)) {\n          // Create a new password since we need to know what it is.\n          // A new password/key would have been generated after exporting the keytab anyways.\n          message = String.format(\"Principal, %s, already exists, setting new password\", evaluatedPrincipal);\n          LOG.warn(message);\n          actionLog.writeStdOut(message);\n          Integer keyNumber = operationHandler.setPrincipalPassword(evaluatedPrincipal, password);\n\n          if (keyNumber != null) {\n            principalPasswordMap.put(evaluatedPrincipal, password);\n            principalKeyNumberMap.put(evaluatedPrincipal, keyNumber);\n            message = String.format(\"Successfully set password for %s\", evaluatedPrincipal);\n            LOG.debug(message);\n          } else {\n            message = String.format(\"Failed to set password for %s - unknown reason\", evaluatedPrincipal);\n            LOG.error(message);\n            actionLog.writeStdErr(message);\n            commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n          }\n        } else {\n          message = String.format(\"Creating new principal, %s\", evaluatedPrincipal);\n          LOG.debug(message);\n\n          boolean servicePrincipal = \"service\".equalsIgnoreCase(identityRecord.get(KerberosActionDataFile.PRINCIPAL_TYPE));\n          Integer keyNumber = operationHandler.createPrincipal(evaluatedPrincipal, password, servicePrincipal);\n\n          if (keyNumber != null) {\n            principalPasswordMap.put(evaluatedPrincipal, password);\n            principalKeyNumberMap.put(evaluatedPrincipal, keyNumber);\n            message = String.format(\"Successfully created new principal, %s\", evaluatedPrincipal);\n            LOG.debug(message);\n          } else {\n            message = String.format(\"Failed to create principal, %s - unknown reason\", evaluatedPrincipal);\n            LOG.error(message);\n            actionLog.writeStdErr(message);\n            commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n          }\n        }\n      } catch (KerberosOperationException e) {\n        message = String.format(\"Failed to create principal, %s - %s\", evaluatedPrincipal, e.getMessage());\n        LOG.error(message, e);\n        actionLog.writeStdErr(message);\n        commandReport = createCommandReport(1, HostRoleStatus.FAILED, \"{}\", actionLog.getStdOut(), actionLog.getStdErr());\n      }\n    }\n\n    return commandReport;\n  }","commit_id":"9fbcce8a36e5f50db0be847eae882695a1dddebd","url":"https://github.com/apache/ambari"}]