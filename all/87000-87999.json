[{"original_method":"/**\n\t * Override to return the appropriate attribute names.\n\t * @param eo\n\t * @return\n\t */\n\tprotected NSArray<String> _publicAttributeNames(EOEnterpriseObject eo) {\n\t\treturn EOEnterpriseObjectSerializer.publicAttributeNames(eo);\n\t}","id":87000,"modified_method":"/**\n\t * Override to return the appropriate attribute names.\n\t * @param eo\n\t * @return\n\t */\n\tprotected NSArray<String> _writableAttributeNames(EOEnterpriseObject eo) {\n\t\treturn EOEnterpriseObjectSerializer.writableAttributeNames(eo);\n\t}","commit_id":"2f7e815131de00f68270dc2c00ccef057912a084","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void determineTurnsToMerge(boolean leftside, List<RouteSegmentResult> result) {\n\t\tfor (int i = result.size() - 2; i >= 0; i--) {\n\t\t\tRouteSegmentResult currentSegment = result.get(i);\n\t\t\tRouteSegmentResult nextSegment = null;\n\n\t\t\t// We need to get the next segment that has a turn and lanes attached.\n\t\t\tfor (int j = i + 1; j < result.size(); j++) {\n\t\t\t\tRouteSegmentResult possibleSegment = result.get(j);\n\t\t\t\tif (possibleSegment.getTurnType() != null && possibleSegment.getTurnType().getLanes() != null) {\n\t\t\t\t\tnextSegment = possibleSegment;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentSegment.getTurnType() == null || currentSegment.getTurnType().getLanes() == null\n\t\t\t\t\t|| nextSegment == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Only allow slight turns that are nearby to be merged.\n\t\t\tif (currentSegment.getDistance() < 60 && nextSegment.getTurnType().getLanes().length <= currentSegment.getTurnType().getLanes().length\n\t\t\t\t\t&& (currentSegment.getTurnType().getValue() == TurnType.C\n\t\t\t\t\t || currentSegment.getTurnType().getValue() == TurnType.TSLL\n\t\t\t\t\t || currentSegment.getTurnType().getValue() == TurnType.TSLR\n\t\t\t\t\t || currentSegment.getTurnType().getValue() == TurnType.KL\n\t\t\t\t\t || currentSegment.getTurnType().getValue() == TurnType.KR)) {\n\t\t\t\tmergeTurnLanes(leftside, currentSegment, nextSegment);\n\t\t\t}\n\t\t}\n\t}","id":87001,"modified_method":"private void determineTurnsToMerge(boolean leftside, List<RouteSegmentResult> result) {\n\t\tfor (int i = result.size() - 2; i >= 0; i--) {\n\t\t\tRouteSegmentResult currentSegment = result.get(i);\n\t\t\tRouteSegmentResult nextSegment = null;\n\n\t\t\t// We need to get the next segment that has a turn and lanes attached.\n\t\t\tfor (int j = i + 1; j < result.size(); j++) {\n\t\t\t\tRouteSegmentResult possibleSegment = result.get(j);\n\t\t\t\tif (possibleSegment.getTurnType() != null && possibleSegment.getTurnType().getLanes() != null) {\n\t\t\t\t\tnextSegment = possibleSegment;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTurnType currentTurn = currentSegment.getTurnType();\n\t\t\tTurnType nextTurn = nextSegment.getTurnType();\n\n\t\t\tif (currentTurn == null || currentTurn.getLanes() == null || nextTurn == null || nextTurn.getLanes() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Only allow slight turns that are nearby to be merged.\n\t\t\tif (currentSegment.getDistance() < 60 && nextTurn.getLanes().length <= currentTurn.getLanes().length\n\t\t\t\t\t&& TurnType.isSlightTurn(currentTurn.getValue())) {\n\t\t\t\tmergeTurnLanes(leftside, currentSegment, nextSegment);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cefabcf5208837ea70b767539ac5e1d8743e4ce7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void mergeTurnLanes(boolean leftSide, RouteSegmentResult currentSegment, RouteSegmentResult nextSegment) {\n\t\tboolean isUsingTurnLanes = TurnType.getPrimaryTurn(currentSegment.getTurnType().getLanes()[0]) != 0\n\t\t\t&& TurnType.getPrimaryTurn(nextSegment.getTurnType().getLanes()[0]) != 0;\n\t\tif (isUsingTurnLanes) {\n\t\t\tint[] lanes = new int[currentSegment.getTurnType().getLanes().length];\n\t\t\t// Unset the allowed lane bit\n\t\t\tfor (int i = 0; i < lanes.length; i++) {\n\t\t\t\tlanes[i] = currentSegment.getTurnType().getLanes()[i] & ~1;\n\t\t\t}\n\n\t\t\t// Find the first lane that matches (based on the turn being taken), and how many lanes match\n\t\t\tint matchingIndex = 0;\n\t\t\tint maxMatchedLanes = 0;\n\t\t\tfor (int i = 0; i < lanes.length; i++) {\n\t\t\t\tint matchedLanes = 0;\n\t\t\t\tfor (int j = 0; j < nextSegment.getTurnType().getLanes().length - i; j++) {\n\t\t\t\t\tif (TurnType.getPrimaryTurn(nextSegment.getTurnType().getLanes()[j])\n                            == TurnType.getPrimaryTurn(currentSegment.getTurnType().getLanes()[i + j])) {\n\t\t\t\t\t\tmatchedLanes++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (matchedLanes > maxMatchedLanes) {\n\t\t\t\t\tmatchingIndex = i;\n\t\t\t\t\tmaxMatchedLanes = matchedLanes;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (maxMatchedLanes <= 1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Copy the allowed bit from the next segment's lanes to the current segment's matching lanes\n\t\t\tfor (int i = matchingIndex; i - matchingIndex < nextSegment.getTurnType().getLanes().length; i++) {\n\t\t\t\tlanes[i] |= nextSegment.getTurnType().getLanes()[i - matchingIndex] & 1;\n\t\t\t}\n\t\t\tTurnType t = currentSegment.getTurnType();\n\t\t\tt.setLanes(lanes);\n\t\t\tint turn = inferTurnFromLanes(lanes);\n\t\t\tif (turn != 0 && turn != t.getValue()) {\n\t\t\t\tTurnType newTurnType = TurnType.valueOf(turn, leftSide);\n\t\t\t\tnewTurnType.setLanes(lanes);\n\t\t\t\tnewTurnType.setSkipToSpeak(t.isSkipToSpeak());\n\t\t\t\tcurrentSegment.setTurnType(newTurnType);\n\t\t\t}\n\t\t}\n\t}","id":87002,"modified_method":"private void mergeTurnLanes(boolean leftSide, RouteSegmentResult currentSegment, RouteSegmentResult nextSegment) {\n\t\tTurnType currentTurn = currentSegment.getTurnType();\n\t\tTurnType nextTurn = nextSegment.getTurnType();\n\t\tboolean isUsingTurnLanes = TurnType.getPrimaryTurn(currentTurn.getLanes()[0]) != 0\n\t\t\t&& TurnType.getPrimaryTurn(nextTurn.getLanes()[0]) != 0;\n\t\tif (isUsingTurnLanes) {\n\t\t\tint[] lanes = new int[currentTurn.getLanes().length];\n\t\t\t// Unset the allowed lane bit\n\t\t\tfor (int i = 0; i < lanes.length; i++) {\n\t\t\t\tlanes[i] = currentTurn.getLanes()[i] & ~1;\n\t\t\t}\n\n\t\t\t// Find the first lane that matches (based on the turn being taken), and how many lanes match\n\t\t\tint matchingIndex = 0;\n\t\t\tint maxMatchedLanes = 0;\n\t\t\tfor (int i = 0; i < lanes.length; i++) {\n\t\t\t\tint matchedLanes = 0;\n\t\t\t\tfor (int j = 0; j < nextTurn.getLanes().length - i; j++) {\n\t\t\t\t\tif (TurnType.getPrimaryTurn(nextTurn.getLanes()[j])\n                            == TurnType.getPrimaryTurn(currentTurn.getLanes()[i + j])) {\n\t\t\t\t\t\tmatchedLanes++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (matchedLanes > maxMatchedLanes) {\n\t\t\t\t\tmatchingIndex = i;\n\t\t\t\t\tmaxMatchedLanes = matchedLanes;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (maxMatchedLanes <= 1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Copy the allowed bit from the next segment's lanes to the current segment's matching lanes\n\t\t\tfor (int i = matchingIndex; i - matchingIndex < nextTurn.getLanes().length; i++) {\n\t\t\t\tlanes[i] |= nextTurn.getLanes()[i - matchingIndex] & 1;\n\t\t\t}\n\t\t\tcurrentTurn.setLanes(lanes);\n\t\t\tint turn = inferTurnFromLanes(lanes);\n\t\t\tif (turn != 0 && turn != currentTurn.getValue()) {\n\t\t\t\tTurnType newTurnType = TurnType.valueOf(turn, leftSide);\n\t\t\t\tnewTurnType.setLanes(lanes);\n\t\t\t\tnewTurnType.setSkipToSpeak(currentTurn.isSkipToSpeak());\n\t\t\t\tcurrentSegment.setTurnType(newTurnType);\n\t\t\t}\n\t\t}\n\t}","commit_id":"cefabcf5208837ea70b767539ac5e1d8743e4ce7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n    public boolean isWatched(String element, String user, WatchedElementType type) throws XWikiException\n    {\n        // TODO: Can this be optimized by a direct \"exists\" query on the list item? Would it e better than what we\n        // currently have with the document cache? If we try a query, it would also need to be performed on the user's\n        // wiki/database, not the current one.\n        return getWatchedElements(user, type).contains(element);\n    }","id":87003,"modified_method":"@Override\n    public boolean isWatched(String element, String user, WatchedElementType type) throws XWikiException\n    {\n        // TODO: Can this be optimized by a direct \"exists\" query on the list item? Would it e better than what we\n        // currently have with the document cache? If we try a query, it would also need to be performed on the user's\n        // wiki/database, not the current one.\n        Collection<String> watchedElements = getWatchedElements(user, type);\n        if (WatchedElementType.SPACE.equals(type)) {\n            // Special handling for Nested Spaces\n            for (String watchedSpace : watchedElements) {\n                // Check if there is an exact match on the watched space or if the current space is nested inside a\n                // watched space.\n                String watchedSpacePrefix = String.format(\"%s.\", watchedSpace);\n                if (element.equals(watchedSpace) || element.startsWith(watchedSpacePrefix)) {\n                    return true;\n                }\n            }\n\n            return false;\n        } else {\n            return watchedElements.contains(element);\n        }\n    }","commit_id":"1ccbc2e7e6090a08660cf48f9a536e51fb511764","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @return Get all the authors of a composite event, if this event is not a composite this list will contain single\n     *         entry.\n     */\n    public List<String> getAuthors()\n    {\n        if (authors == null) {\n            authors = new ArrayList<String>();\n\n            if (!isComposite()) {\n                authors.add(getAuthor());\n            } else {\n                for (ActivityEvent event : activityEvents) {\n                    if (!authors.contains(event.getUser())) {\n                        authors.add(event.getUser());\n                    }\n                }\n            }\n        }\n\n        return authors;\n    }","id":87004,"modified_method":"/**\n     * @return Get all the authors of a composite event, if this event is not a composite this list will contain single\n     *         entry.\n     */\n    public List<String> getAuthors()\n    {\n        if (authors == null) {\n            authors = new ArrayList<String>();\n\n            if (!isComposite()) {\n                authors.add(getAuthor());\n            } else {\n                for (ActivityEvent event : activityEvents) {\n                    String prefixedAuthor = event.getWiki() + WatchListStore.WIKI_SPACE_SEP + event.getUser();\n                    if (!authors.contains(prefixedAuthor)) {\n                        authors.add(prefixedAuthor);\n                    }\n                }\n            }\n        }\n\n        return authors;\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the events matching criteria.\n     * \n     * @param wikis a list of wikis from which events should match\n     * @param spaces a list of spaces from which events should match\n     * @param documents a list of documents from which events should match\n     * @param userName notification recipient\n     * @param context the XWiki context\n     * @return the list of events matching the given scopes\n     */\n    public List<WatchListEvent> getMatchingEvents(List<String> wikis, List<String> spaces, List<String> documents,\n        String userName, XWikiContext context)\n    {\n        List<WatchListEvent> matchingEvents = new ArrayList<WatchListEvent>();\n\n        for (WatchListEvent event : events) {\n            if (wikis.contains(event.getWiki()) || spaces.contains(event.getPrefixedSpace())\n                || documents.contains(event.getPrefixedFullName())) {\n                try {\n                    if (context.getWiki().getRightService().hasAccessLevel(\"view\", userName,\n                        event.getPrefixedFullName(), context)) {\n                        matchingEvents.add(event);\n                    }\n                } catch (XWikiException e) {\n                    // We're in a job, we don't throw exceptions\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        Collections.sort(matchingEvents);\n\n        return matchingEvents;\n    }","id":87005,"modified_method":"/**\n     * Get the events matching criteria.\n     * \n     * @param wikis a list of wikis from which events should match\n     * @param spaces a list of spaces from which events should match\n     * @param documents a list of documents from which events should match\n     * @param users a list of users from which events should match\n     * @param userName notification recipient\n     * @param context the XWiki context\n     * @return the list of events matching the given scopes\n     */\n    public List<WatchListEvent> getMatchingEvents(List<String> wikis, List<String> spaces, List<String> documents,\n        List<String> users, String userName, XWikiContext context)\n    {\n        List<WatchListEvent> matchingEvents = new ArrayList<WatchListEvent>();        \n               \n        \n        for (WatchListEvent event : events) {\n            if (wikis.contains(event.getWiki()) || spaces.contains(event.getPrefixedSpace())\n                || documents.contains(event.getPrefixedFullName()) \n                || ListUtils.intersection(users, event.getAuthors()).size() > 0) {\n                try {\n                    if (context.getWiki().getRightService().hasAccessLevel(\"view\", userName,\n                        event.getPrefixedFullName(), context)) {\n                        matchingEvents.add(event);\n                    }\n                } catch (XWikiException e) {\n                    // We're in a job, we don't throw exceptions\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        Collections.sort(matchingEvents);\n\n        return matchingEvents;\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Method called from the scheduler.\n     * \n     * @param jobContext Context of the request\n     * @throws JobExecutionException if the job execution fails.\n     */\n    @Override\n    public void executeJob(JobExecutionContext jobContext) throws JobExecutionException\n    {\n        try {\n            init(jobContext);\n\n            if (watchListJobObject == null) {\n                return;\n            }\n\n            List<String> subscribers = getSubscribers();\n            Date previousFireTime = getPreviousFireTime();            \n            WatchListEventMatcher eventMatcher = new WatchListEventMatcher(previousFireTime, context);\n            setPreviousFireTime();\n            \n            if (!hasSubscribers()) {\n                return;\n            }\n\n            if (eventMatcher.getEventNumber() == 0) {\n                return;\n            }\n\n            for (String subscriber : subscribers) {\n                List<String> wikis = plugin.getStore().getWatchedElements(subscriber, ElementType.WIKI, this.context);\n                List<String> spaces = plugin.getStore().getWatchedElements(subscriber, ElementType.SPACE, this.context);\n                List<String> documents =\n                    plugin.getStore().getWatchedElements(subscriber, ElementType.DOCUMENT, this.context);\n                List<WatchListEvent> matchingEvents =\n                    eventMatcher.getMatchingEvents(wikis, spaces, documents, subscriber, context);\n                String userWiki = StringUtils.substringBefore(subscriber, WatchListStore.WIKI_SPACE_SEP);\n\n                // If events have occurred on at least one element watched by the user, send the email\n                if (matchingEvents.size() > 0) {\n                    plugin.getNotifier().sendEmailNotification(subscriber, matchingEvents, getEmailTemplate(userWiki),\n                        previousFireTime, context);\n                }\n            }            \n        } catch (Exception e) {\n            // We're in a job, we don't throw exceptions\n            LOG.error(\"Exception while running job\", e);\n            e.printStackTrace();\n        } finally {\n            context.getWiki().getStore().cleanUp(context);\n            cleanupComponents();\n        }\n    }","id":87006,"modified_method":"/**\n     * Method called from the scheduler.\n     * \n     * @param jobContext Context of the request\n     * @throws JobExecutionException if the job execution fails.\n     */\n    @Override\n    public void executeJob(JobExecutionContext jobContext) throws JobExecutionException\n    {\n        try {\n            init(jobContext);\n\n            if (watchListJobObject == null) {\n                return;\n            }\n\n            List<String> subscribers = getSubscribers();\n            Date previousFireTime = getPreviousFireTime();            \n            WatchListEventMatcher eventMatcher = new WatchListEventMatcher(previousFireTime, context);\n            setPreviousFireTime();\n            \n            if (!hasSubscribers()) {\n                return;\n            }\n\n            if (eventMatcher.getEventNumber() == 0) {\n                return;\n            }\n\n            for (String subscriber : subscribers) {\n                List<String> wikis = plugin.getStore().getWatchedElements(subscriber, ElementType.WIKI, this.context);\n                List<String> spaces = plugin.getStore().getWatchedElements(subscriber, ElementType.SPACE, this.context);\n                List<String> documents =\n                    plugin.getStore().getWatchedElements(subscriber, ElementType.DOCUMENT, this.context);\n                List<String> users = plugin.getStore().getWatchedElements(subscriber, ElementType.USER, this.context);\n                List<WatchListEvent> matchingEvents =\n                    eventMatcher.getMatchingEvents(wikis, spaces, documents, users, subscriber, context);\n                String userWiki = StringUtils.substringBefore(subscriber, WatchListStore.WIKI_SPACE_SEP);\n\n                // If events have occurred on at least one element watched by the user, send the email\n                if (matchingEvents.size() > 0) {\n                    plugin.getNotifier().sendEmailNotification(subscriber, matchingEvents, getEmailTemplate(userWiki),\n                        previousFireTime, context);\n                }\n            }            \n        } catch (Exception e) {\n            // We're in a job, we don't throw exceptions\n            LOG.error(\"Exception while running job\", e);\n            e.printStackTrace();\n        } finally {\n            context.getWiki().getStore().cleanUp(context);\n            cleanupComponents();\n        }\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the elements (wikis + spaces + documents) watched by the current user.\n     * \n     * @return The list of the elements in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retreived nor created\n     */\n    public List<String> getWatchedElements() throws XWikiException\n    {\n        List<String> wEls = new ArrayList<String>();\n        wEls.addAll(getWatchedDocuments());\n        wEls.addAll(getWatchedSpaces());\n        wEls.addAll(getWatchedWikis());\n        return wEls;\n    }","id":87007,"modified_method":"/**\n     * Get the elements (wikis + spaces + documents + users) watched by the current user.\n     * \n     * @return The list of the elements in the user's WatchList\n     * @throws XWikiException If the user's WatchList Object cannot be retrieved nor created\n     */\n    public List<String> getWatchedElements() throws XWikiException\n    {\n        List<String> wEls = new ArrayList<String>();\n        wEls.addAll(getWatchedDocuments());\n        wEls.addAll(getWatchedSpaces());\n        wEls.addAll(getWatchedWikis());\n        wEls.addAll(getWatchedUsers());\n        \n        return wEls;\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the name of the XClass property the given type is stored in.\n     * \n     * @param type type to retrieve\n     * @return the name of the XClass property\n     */\n    private String getWatchListClassPropertyForType(ElementType type)\n    {\n        if (ElementType.WIKI.equals(type)) {\n            return WATCHLIST_CLASS_WIKIS_PROP;\n        } else if (ElementType.SPACE.equals(type)) {\n            return WATCHLIST_CLASS_SPACES_PROP;\n        } else if (ElementType.DOCUMENT.equals(type)) {\n            return WATCHLIST_CLASS_DOCUMENTS_PROP;\n        } else {\n            return StringUtils.EMPTY;\n        }\n    }","id":87008,"modified_method":"/**\n     * Get the name of the XClass property the given type is stored in.\n     * \n     * @param type type to retrieve\n     * @return the name of the XClass property\n     */\n    private String getWatchListClassPropertyForType(ElementType type)\n    {\n        if (ElementType.WIKI.equals(type)) {\n            return WATCHLIST_CLASS_WIKIS_PROP;\n        } else if (ElementType.SPACE.equals(type)) {\n            return WATCHLIST_CLASS_SPACES_PROP;\n        } else if (ElementType.DOCUMENT.equals(type)) {\n            return WATCHLIST_CLASS_DOCUMENTS_PROP;\n        } else if (ElementType.USER.equals(type)) {\n            return WATCHLIST_CLASS_USERS_PROP;\n        } else {\n            return StringUtils.EMPTY;\n        }\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Add the specified element (document or space) to the corresponding list in the user's WatchList.\n     * \n     * @param user XWikiUser\n     * @param newWatchedElement The name of the element to add (document of space)\n     * @param type type of the element to remove\n     * @param context Context of the request\n     * @return True if the element was'nt already in list\n     * @throws XWikiException if the modification hasn't been saved\n     */\n    public boolean addWatchedElement(String user, String newWatchedElement, ElementType type, XWikiContext context)\n        throws XWikiException\n    {\n        String elementToWatch = context.getDatabase() + WIKI_SPACE_SEP + newWatchedElement;\n\n        if (this.isWatched(elementToWatch, user, type, context)) {\n            return false;\n        }\n\n        List<String> watchedElements = new ArrayList<String>();\n        watchedElements.addAll(getWatchedElements(user, type, context));\n        watchedElements.add(elementToWatch);\n\n        this.setWatchListElementsProperty(user, type, watchedElements, context);\n        return true;\n    }","id":87009,"modified_method":"/**\n     * Add the specified element (document or space) to the corresponding list in the user's WatchList.\n     * \n     * @param user XWikiUser\n     * @param newWatchedElement The name of the element to add (document of space)\n     * @param type type of the element to remove\n     * @param context Context of the request\n     * @return True if the element was'nt already in list\n     * @throws XWikiException if the modification hasn't been saved\n     */\n    public boolean addWatchedElement(String user, String newWatchedElement, ElementType type, XWikiContext context)\n        throws XWikiException\n    {\n        String elementToWatch = newWatchedElement;\n        \n        if (!ElementType.WIKI.equals(type) && !newWatchedElement.contains(WIKI_SPACE_SEP)) {\n            elementToWatch = context.getDatabase() + WIKI_SPACE_SEP + newWatchedElement;\n        }\n\n        if (this.isWatched(elementToWatch, user, type, context)) {\n            return false;\n        }\n\n        List<String> watchedElements = getWatchedElements(user, type, context);\n        watchedElements.add(elementToWatch);\n\n        this.setWatchListElementsProperty(user, type, watchedElements, context);\n        return true;\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Remove the specified element (document or space) from the corresponding list in the user's WatchList.\n     * \n     * @param user XWiki User\n     * @param watchedElement The name of the element to remove (document or space)\n     * @param type type of the element to remove\n     * @param context Context of the request\n     * @return True if the element was in list and has been removed, false if the element was'nt in the list\n     * @throws XWikiException If the WatchList Object cannot be retreived or if the user's profile cannot be saved\n     */\n    public boolean removeWatchedElement(String user, String watchedElement, ElementType type, XWikiContext context)\n        throws XWikiException\n    {\n        String elementToRemove = watchedElement;\n        if (!watchedElement.contains(WIKI_SPACE_SEP)) {\n            elementToRemove = context.getDatabase() + WIKI_SPACE_SEP + watchedElement;\n        }\n\n        if (!this.isWatched(elementToRemove, user, type, context)) {\n            return false;\n        }\n\n        List<String> watchedElements = new ArrayList<String>();\n        watchedElements.addAll(getWatchedElements(user, type, context));\n        watchedElements.remove(elementToRemove);\n\n        this.setWatchListElementsProperty(user, type, watchedElements, context);\n        return true;\n    }","id":87010,"modified_method":"/**\n     * Remove the specified element (document or space) from the corresponding list in the user's WatchList.\n     * \n     * @param user XWiki User\n     * @param watchedElement The name of the element to remove (document or space)\n     * @param type type of the element to remove\n     * @param context Context of the request\n     * @return True if the element was in list and has been removed, false if the element was'nt in the list\n     * @throws XWikiException If the WatchList Object cannot be retreived or if the user's profile cannot be saved\n     */\n    public boolean removeWatchedElement(String user, String watchedElement, ElementType type, XWikiContext context)\n        throws XWikiException\n    {\n        String elementToRemove = watchedElement;\n        \n        if (!ElementType.WIKI.equals(type) && !watchedElement.contains(WIKI_SPACE_SEP)) {\n            elementToRemove = context.getDatabase() + WIKI_SPACE_SEP + watchedElement;\n        }\n\n        if (!this.isWatched(elementToRemove, user, type, context)) {\n            return false;\n        }\n        \n        List<String> watchedElements = getWatchedElements(user, type, context);\n        watchedElements.remove(elementToRemove);\n\n        this.setWatchListElementsProperty(user, type, watchedElements, context);\n        return true;\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create or update the watchlist class properties.\n     * \n     * @param watchListClass document in which the class must be created\n     * @param context the XWiki context\n     * @return true if the class properties have been created or modified\n     * @throws XWikiException when retrieving of watchlist jobs in the wiki fails\n     */    \n    private boolean initWatchListClassProperties(XWikiDocument watchListClass, XWikiContext context)\n        throws XWikiException\n    {\n        boolean needsUpdate = false;\n        BaseClass bclass = watchListClass.getxWikiClass();\n        bclass.setName(WATCHLIST_CLASS);\n\n        needsUpdate |= bclass.addStaticListField(WATCHLIST_CLASS_INTERVAL_PROP, \"Email notifications interval\", \"\");\n\n        // Check that the interval property contains all the available jobs\n        StaticListClass intervalClass = (StaticListClass) bclass.get(WATCHLIST_CLASS_INTERVAL_PROP);\n        List<String> intervalValues = intervalClass.getList(context);\n        List<String> newInterval = new ArrayList<String>();\n        newInterval.addAll(intervalValues);\n        boolean intervalNeedsUpdate = false;\n\n        // Look for missing jobs, build a complete list\n        for (String jobName : jobDocumentNames) {\n            if (!newInterval.contains(jobName)) {\n                newInterval.add(jobName);\n                intervalNeedsUpdate = true;\n            }\n        }\n\n        // Save the complete list in the interval prop\n        if (intervalNeedsUpdate) {\n            intervalClass.setValues(StringUtils.join(newInterval, \"|\"));\n            needsUpdate = true;\n        }\n\n        // Create storage properties\n        needsUpdate |= bclass.addTextAreaField(WATCHLIST_CLASS_WIKIS_PROP, \"Wiki list\", 80, 5);\n        needsUpdate |= bclass.addTextAreaField(WATCHLIST_CLASS_SPACES_PROP, \"Space list\", 80, 5);\n        needsUpdate |= bclass.addTextAreaField(WATCHLIST_CLASS_DOCUMENTS_PROP, \"Document list\", 80, 5);\n\n        return needsUpdate;\n    }","id":87011,"modified_method":"/**\n     * Create or update the watchlist class properties.\n     * \n     * @param watchListClass document in which the class must be created\n     * @param context the XWiki context\n     * @return true if the class properties have been created or modified\n     * @throws XWikiException when retrieving of watchlist jobs in the wiki fails\n     */    \n    private boolean initWatchListClassProperties(XWikiDocument watchListClass, XWikiContext context)\n        throws XWikiException\n    {\n        boolean needsUpdate = false;\n        BaseClass bclass = watchListClass.getxWikiClass();\n        bclass.setName(WATCHLIST_CLASS);\n\n        needsUpdate |= bclass.addStaticListField(WATCHLIST_CLASS_INTERVAL_PROP, \"Email notifications interval\", \"\");\n\n        // Check that the interval property contains all the available jobs\n        StaticListClass intervalClass = (StaticListClass) bclass.get(WATCHLIST_CLASS_INTERVAL_PROP);\n        List<String> intervalValues = intervalClass.getList(context);\n        List<String> newInterval = new ArrayList<String>();\n        newInterval.addAll(intervalValues);\n        boolean intervalNeedsUpdate = false;\n\n        // Look for missing jobs, build a complete list\n        for (String jobName : jobDocumentNames) {\n            if (!newInterval.contains(jobName)) {\n                newInterval.add(jobName);\n                intervalNeedsUpdate = true;\n            }\n        }\n\n        // Save the complete list in the interval prop\n        if (intervalNeedsUpdate) {\n            intervalClass.setValues(StringUtils.join(newInterval, \"|\"));\n            needsUpdate = true;\n        }\n\n        // Create storage properties\n        needsUpdate |= bclass.addTextAreaField(WATCHLIST_CLASS_WIKIS_PROP, \"Wiki list\", 80, 5);\n        needsUpdate |= bclass.addTextAreaField(WATCHLIST_CLASS_SPACES_PROP, \"Space list\", 80, 5);\n        needsUpdate |= bclass.addTextAreaField(WATCHLIST_CLASS_DOCUMENTS_PROP, \"Document list\", 80, 5);\n        needsUpdate |= bclass.addTextAreaField(WATCHLIST_CLASS_USERS_PROP, \"User list\", 80, 5);\n\n        return needsUpdate;\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get watched elements for the given element type and user.\n     * \n     * @param user user to match\n     * @param type element type to match\n     * @param context the XWiki context\n     * @return matching elements\n     * @throws XWikiException if retrieval of elements fails\n     */\n    public List<String> getWatchedElements(String user, ElementType type, XWikiContext context) throws XWikiException\n    {\n        BaseObject watchListObject = this.getWatchListObject(user, context);\n        String watchedItems = watchListObject.getLargeStringValue(getWatchListClassPropertyForType(type)).trim();\n        return Arrays.asList(watchedItems.split(WATCHLIST_ELEMENT_SEP));\n    }","id":87012,"modified_method":"/**\n     * Get watched elements for the given element type and user.\n     * \n     * @param user user to match\n     * @param type element type to match\n     * @param context the XWiki context\n     * @return matching elements\n     * @throws XWikiException if retrieval of elements fails\n     */\n    public List<String> getWatchedElements(String user, ElementType type, XWikiContext context) throws XWikiException\n    {\n        BaseObject watchListObject = this.getWatchListObject(user, context);\n        String watchedItems = watchListObject.getLargeStringValue(getWatchListClassPropertyForType(type)).trim();\n        List<String> elements = new ArrayList<String>();\n        elements.addAll(Arrays.asList(watchedItems.split(WATCHLIST_ELEMENT_SEP)));\n        return elements;\n    }","commit_id":"347eade8b030bbbf6fa194e8745d943180c3ba0d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static void updateGenSourcesIml(File genSourcesIml, File... sourceDirs) throws JDOMException, IOException {\n    Set<String> sourcesIncluded = new HashSet<String>();\n    for (File imlFile : Utils.withExtension(\".iml\", Utils.files(new File(\".\")))) {\n      if (imlFile.getCanonicalPath().equals(genSourcesIml.getCanonicalPath())) continue;\n      Document doc = JDOMUtil.loadDocument(imlFile);\n      Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n      for (Element cRoot : (List<Element>) rootManager.getChildren(CONTENT)) {\n        for (Element sFolder : (List<Element>) cRoot.getChildren(SOURCE_FOLDER)) {\n          String imlFormattedRoot = sFolder.getAttributeValue(URL);\n          sourcesIncluded.add(new File(imlFormattedRoot.replace(\"file://$MODULE_DIR$\", imlFile.getParent())).getCanonicalPath());\n        }\n      }\n    }\n\n    Document doc = JDOMUtil.loadDocument(genSourcesIml);\n    Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n\n    Set<String> contentRootUrls = new HashSet<String>();\n    for (File dir : sourceDirs) {\n      contentRootUrls.add(PATH_START_MODULE + dir);\n\n      // try to modify existing content roots\n      Element contentRoot = Utils.getChildByAttribute(rootManager, CONTENT, URL, PATH_START_MODULE + dir);\n      if (contentRoot == null) {\n        contentRoot = new Element(CONTENT);\n        contentRoot.setAttribute(URL, PATH_START_MODULE + dir);\n        rootManager.addContent(contentRoot);\n      }\n      contentRoot.removeContent();\n\n      // generate lists of source gen and classes gen folders and add as source and excluded to content root\n      List<String> sourceGenFolders = new ArrayList<String>();\n      List<String> classesGenFolders = new ArrayList<String>();\n      for (Pair<String, String> module : Utils.collectMPSCompiledModulesInfo(dir)) {\n        String sourceCanonical = new File(module.o2).getCanonicalPath();\n        if (!sourcesIncluded.contains(sourceCanonical)) {\n          //todo dirty hack until Julia fixes packaging\n          if (!sourceCanonical.endsWith(\"languages/languageDesign/smodel/tests_gen\")) {\n            assert sourceCanonical.startsWith(dir.getCanonicalPath()) : \"module generates files to outside of 'root' folder for it:\\n\" + module.o1 + \"\\ngenerates into\\n\" + module.o2;\n            if (new File(module.o2).exists()) {\n              String sFolder = PATH_START_MODULE + Utils.getRelativeProjectPath(module.o2);\n              sourceGenFolders.add(sFolder);\n            }\n          }\n        }\n        String cgFolder = PATH_START_MODULE + Utils.getRelativeProjectPath(module.o1) + \"/\" + AbstractModule.CLASSES_GEN;\n        classesGenFolders.add(cgFolder);\n      }\n      Collections.sort(sourceGenFolders);\n      Collections.sort(classesGenFolders);\n\n      for (String sourceGenFolder : sourceGenFolders) {\n        Element sourceFolder = new Element(SOURCE_FOLDER);\n        sourceFolder.setAttribute(URL, sourceGenFolder);\n        sourceFolder.setAttribute(\"isTestSource\", \"false\");\n        contentRoot.addContent(sourceFolder);\n      }\n      for (String classesGenFolder : classesGenFolders) {\n        Element excludeFolder = new Element(EXCLUDE_FOLDER);\n        excludeFolder.setAttribute(URL, classesGenFolder);\n        contentRoot.addContent(excludeFolder);\n      }\n    }\n\n    // remove unnecessary content roots\n    List<Element> toRemove = new ArrayList<Element>();\n    for (Object _contentRoot : rootManager.getChildren(CONTENT)) {\n      Element contentRoot = (Element) _contentRoot;\n      if (!contentRootUrls.contains(contentRoot.getAttributeValue(URL))) {\n        toRemove.add(contentRoot);\n      }\n    }\n    for (Element element : toRemove) {\n      element.detach();\n    }\n\n    JDOMUtil.writeDocument(doc, genSourcesIml);\n  }","id":87013,"modified_method":"public static void updateGenSourcesIml(File genSourcesIml, File... sourceDirs) throws JDOMException, IOException {\n    Set<String> sourcesIncluded = new HashSet<String>();\n    for (File imlFile : Utils.withExtension(\".iml\", Utils.files(new File(\".\")))) {\n      if (imlFile.getCanonicalPath().equals(genSourcesIml.getCanonicalPath())) continue;\n      Document doc = JDOMUtil.loadDocument(imlFile);\n      Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n      for (Element cRoot : (List<Element>) rootManager.getChildren(CONTENT)) {\n        for (Element sFolder : (List<Element>) cRoot.getChildren(SOURCE_FOLDER)) {\n          String imlFormattedRoot = sFolder.getAttributeValue(URL);\n          sourcesIncluded.add(new File(imlFormattedRoot.replace(\"file://$MODULE_DIR$\", imlFile.getParent())).getCanonicalPath());\n        }\n      }\n    }\n\n    Document doc = JDOMUtil.loadDocument(genSourcesIml);\n    Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n\n    Set<String> contentRootUrls = new HashSet<String>();\n    for (File dir : sourceDirs) {\n      contentRootUrls.add(PATH_START_MODULE + dir);\n\n      // try to modify existing content roots\n      Element contentRoot = Utils.getChildByAttribute(rootManager, CONTENT, URL, PATH_START_MODULE + dir);\n      if (contentRoot == null) {\n        contentRoot = new Element(CONTENT);\n        contentRoot.setAttribute(URL, PATH_START_MODULE + dir);\n        rootManager.addContent(contentRoot);\n      }\n      contentRoot.removeContent();\n\n      // generate lists of source gen and classes gen folders and add as source and excluded to content root\n      List<String> sourceGenFolders = new ArrayList<String>();\n      List<String> classesGenFolders = new ArrayList<String>();\n      for (Entry<String, Collection<String>> module : Utils.collectMPSCompiledModulesInfo(dir).entrySet()) {\n        for (String sourcePath : module.getValue()) {\n          String sourceCanonical = new File(sourcePath).getCanonicalPath();\n          if (!sourcesIncluded.contains(sourceCanonical)) {\n            //todo dirty hack until Julia fixes packaging\n            if (!sourceCanonical.endsWith(\"languages/languageDesign/smodel/tests_gen\")) {\n              assert sourceCanonical.startsWith(dir.getCanonicalPath()) : \"module generates files to outside of 'root' folder for it:\\n\" + module.getKey() + \"\\ngenerates into\\n\" + sourcePath;\n              if (new File(sourcePath).exists()) {\n                String sFolder = PATH_START_MODULE + Utils.getRelativeProjectPath(sourcePath);\n                sourceGenFolders.add(sFolder);\n              }\n            }\n          }\n        }\n      }\n      for (String modulePath : Utils.collectMPSCompiledModulesInfo(dir).keySet()) {\n        String cgFolder = PATH_START_MODULE + Utils.getRelativeProjectPath(modulePath) + \"/\" + AbstractModule.CLASSES_GEN;\n        classesGenFolders.add(cgFolder);\n      }\n      Collections.sort(sourceGenFolders);\n      Collections.sort(classesGenFolders);\n\n      for (String sourceGenFolder : sourceGenFolders) {\n        Element sourceFolder = new Element(SOURCE_FOLDER);\n        sourceFolder.setAttribute(URL, sourceGenFolder);\n        sourceFolder.setAttribute(\"isTestSource\", \"false\");\n        contentRoot.addContent(sourceFolder);\n      }\n      for (String classesGenFolder : classesGenFolders) {\n        Element excludeFolder = new Element(EXCLUDE_FOLDER);\n        excludeFolder.setAttribute(URL, classesGenFolder);\n        contentRoot.addContent(excludeFolder);\n      }\n    }\n\n    // remove unnecessary content roots\n    List<Element> toRemove = new ArrayList<Element>();\n    for (Object _contentRoot : rootManager.getChildren(CONTENT)) {\n      Element contentRoot = (Element) _contentRoot;\n      if (!contentRootUrls.contains(contentRoot.getAttributeValue(URL))) {\n        toRemove.add(contentRoot);\n      }\n    }\n    for (Element element : toRemove) {\n      element.detach();\n    }\n\n    JDOMUtil.writeDocument(doc, genSourcesIml);\n  }","commit_id":"adfdf4d0c98d9afef2fd97134282d7eb4663300e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void updateGenSourcesImlNoIntersections(File genSourcesIml, File... sourceDirs) throws JDOMException, IOException {\n    System.out.println(\"Analyzing existing imls...\");\n    Set<String> modelRoots = new HashSet<String>();\n    Set<String> sourcesIncluded = new HashSet<String>();\n    for (File imlFile : Utils.withExtension(\".iml\", Utils.files(new File(\".\")))) {\n      //if (imlFile.getCanonicalPath().equals(genSourcesIml.getCanonicalPath())) continue;\n      Document doc = JDOMUtil.loadDocument(imlFile);\n      Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n      for (Element cRoot : (List<Element>) rootManager.getChildren(CONTENT)) {\n        String imlFormattedRoot = cRoot.getAttributeValue(URL);\n        modelRoots.add(new File(imlFormattedRoot.replace(\"file://$MODULE_DIR$\", imlFile.getParent())).getCanonicalPath());\n\n        for (Element sFolder : (List<Element>) cRoot.getChildren(SOURCE_FOLDER)) {\n          String imlFormattedSourceFolder = sFolder.getAttributeValue(URL);\n          String sourcePath = new File(imlFormattedSourceFolder.replace(\"file://$MODULE_DIR$\", imlFile.getParent())).getCanonicalPath();\n          sourcesIncluded.add(sourcePath);\n        }\n      }\n    }\n\n    System.out.println(\"Analyzing MPS modules...\");\n    Document doc = JDOMUtil.loadDocument(genSourcesIml);\n    Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n    List<String> sourceGen = new ArrayList<String>();\n    List<String> classesGen = new ArrayList<String>();\n    for (File dir : sourceDirs) {\n      for (Pair<String, String> moduleWithSourceGen : Utils.collectMPSCompiledModulesInfo(dir)) {\n        String sourceCanonical = new File(moduleWithSourceGen.o2).getCanonicalPath();\n        //todo dirty hack until Julia fixes packaging\n        if (!sourceCanonical.endsWith(\"languages/languageDesign/smodel/tests_gen\")) {\n          assert sourceCanonical.startsWith(dir.getCanonicalPath()) : \"module generates files to outside of 'root' folder for it:\\n\" + moduleWithSourceGen.o1 + \"\\ngenerates into\\n\" + moduleWithSourceGen.o2;\n          if (new File(moduleWithSourceGen.o2).exists()) {\n            sourceGen.add(moduleWithSourceGen.o2);\n          }\n\n          classesGen.add(moduleWithSourceGen.o1 + \"/\" + AbstractModule.CLASSES_GEN);\n        }\n      }\n    }\n\n    System.out.println(\"Building model roots for gensources module...\");\n    sourceGen.removeAll(sourcesIncluded);\n    Collections.sort(sourceGen);\n    Collections.sort(classesGen);\n    //rootManager.removeChildren(CONTENT);\n\n    Set<String> newRoots = new HashSet<String>();\n    for (String sGen : sourceGen) {\n      String root = null;\n\n      // find existing\n      for (String newRoot : newRoots) {\n        if (sGen.startsWith(newRoot)) {\n          root = newRoot;\n        }\n      }\n\n      //find outermost directory not intersecting with other model roots\n      if (root == null) {\n        root = sGen;\n        String parent = new File(root).getParent();\n        while (!intersects(modelRoots, parent)) {\n          root = parent;\n          parent = new File(root).getParent();\n        }\n        newRoots.add(root);\n\n        Element contentRoot = new Element(CONTENT);\n        contentRoot.setAttribute(URL, PATH_START_MODULE + Utils.getRelativeProjectPath(root));\n        rootManager.addContent(contentRoot);\n      }\n\n      String rootInImlFormat = PATH_START_MODULE + Utils.getRelativeProjectPath(root);\n      Element contentRoot = Utils.getChildByAttribute(rootManager, CONTENT, URL, rootInImlFormat);\n\n      Element sourceFolder = new Element(SOURCE_FOLDER);\n      sourceFolder.setAttribute(URL, PATH_START_MODULE + Utils.getRelativeProjectPath(sGen));\n      sourceFolder.setAttribute(\"isTestSource\", \"false\");\n      contentRoot.addContent(sourceFolder);\n    }\n\n    for (String cGen : classesGen) {\n      String root = null;\n      for (String newRoot : newRoots) {\n        if (cGen.startsWith(newRoot)) {\n          root = newRoot;\n        }\n      }\n\n      //assert root != null : \"Classes gen folder which has no corresponding content root: \" + cGen;\n      if (root == null) continue;\n\n      String rootInImlFormat = PATH_START_MODULE + Utils.getRelativeProjectPath(root);\n      Element contentRoot = Utils.getChildByAttribute(rootManager, CONTENT, URL, rootInImlFormat);\n\n      Element excludeFolder = new Element(EXCLUDE_FOLDER);\n      excludeFolder.setAttribute(URL, PATH_START_MODULE + Utils.getRelativeProjectPath(cGen));\n      contentRoot.addContent(excludeFolder);\n    }\n\n    System.out.println(\"Saving...\");\n    JDOMUtil.writeDocument(doc, genSourcesIml);\n\n    System.out.println(\"Done.\");\n  }","id":87014,"modified_method":"public static void updateGenSourcesImlNoIntersections(File genSourcesIml, File... sourceDirs) throws JDOMException, IOException {\n    System.out.println(\"Analyzing existing imls...\");\n    Set<String> modelRoots = new HashSet<String>();\n    Set<String> sourcesIncluded = new HashSet<String>();\n    for (File imlFile : Utils.withExtension(\".iml\", Utils.files(new File(\".\")))) {\n      //if (imlFile.getCanonicalPath().equals(genSourcesIml.getCanonicalPath())) continue;\n      Document doc = JDOMUtil.loadDocument(imlFile);\n      Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n      for (Element cRoot : (List<Element>) rootManager.getChildren(CONTENT)) {\n        String imlFormattedRoot = cRoot.getAttributeValue(URL);\n        modelRoots.add(new File(imlFormattedRoot.replace(\"file://$MODULE_DIR$\", imlFile.getParent())).getCanonicalPath());\n\n        for (Element sFolder : (List<Element>) cRoot.getChildren(SOURCE_FOLDER)) {\n          String imlFormattedSourceFolder = sFolder.getAttributeValue(URL);\n          String sourcePath = new File(imlFormattedSourceFolder.replace(\"file://$MODULE_DIR$\", imlFile.getParent())).getCanonicalPath();\n          sourcesIncluded.add(sourcePath);\n        }\n      }\n    }\n\n    System.out.println(\"Analyzing MPS modules...\");\n    Document doc = JDOMUtil.loadDocument(genSourcesIml);\n    Element rootManager = Utils.getComponentWithName(doc, MODULE_ROOT_MANAGER);\n    List<String> sourceGen = new ArrayList<String>();\n    List<String> classesGen = new ArrayList<String>();\n    for (File dir : sourceDirs) {\n      for (Entry<String, Collection<String>> module : Utils.collectMPSCompiledModulesInfo(dir).entrySet()) {\n        for (String sourcePath : module.getValue()) {\n          String sourceCanonical = new File(sourcePath).getCanonicalPath();\n          //todo dirty hack until Julia fixes packaging\n          if (!sourceCanonical.endsWith(\"languages/languageDesign/smodel/tests_gen\")) {\n            assert sourceCanonical.startsWith(dir.getCanonicalPath()) : \"module generates files to outside of 'root' folder for it:\\n\" + module.getKey() + \"\\ngenerates into\\n\" + sourcePath;\n            if (new File(sourcePath).exists()) {\n              sourceGen.add(sourcePath);\n            }\n\n          }\n        }\n        classesGen.add(module.getKey() + \"/\" + AbstractModule.CLASSES_GEN);\n      }\n    }\n\n    System.out.println(\"Building model roots for gensources module...\");\n    sourceGen.removeAll(sourcesIncluded);\n    Collections.sort(sourceGen);\n    Collections.sort(classesGen);\n    //rootManager.removeChildren(CONTENT);\n\n    Set<String> newRoots = new HashSet<String>();\n    for (String sGen : sourceGen) {\n      String root = null;\n\n      // find existing\n      for (String newRoot : newRoots) {\n        if (sGen.startsWith(newRoot)) {\n          root = newRoot;\n        }\n      }\n\n      //find outermost directory not intersecting with other model roots\n      if (root == null) {\n        root = sGen;\n        String parent = new File(root).getParent();\n        while (!intersects(modelRoots, parent)) {\n          root = parent;\n          parent = new File(root).getParent();\n        }\n        newRoots.add(root);\n\n        Element contentRoot = new Element(CONTENT);\n        contentRoot.setAttribute(URL, PATH_START_MODULE + Utils.getRelativeProjectPath(root));\n        rootManager.addContent(contentRoot);\n      }\n\n      String rootInImlFormat = PATH_START_MODULE + Utils.getRelativeProjectPath(root);\n      Element contentRoot = Utils.getChildByAttribute(rootManager, CONTENT, URL, rootInImlFormat);\n\n      Element sourceFolder = new Element(SOURCE_FOLDER);\n      sourceFolder.setAttribute(URL, PATH_START_MODULE + Utils.getRelativeProjectPath(sGen));\n      sourceFolder.setAttribute(\"isTestSource\", \"false\");\n      contentRoot.addContent(sourceFolder);\n    }\n\n    for (String cGen : classesGen) {\n      String root = null;\n      for (String newRoot : newRoots) {\n        if (cGen.startsWith(newRoot)) {\n          root = newRoot;\n        }\n      }\n\n      //assert root != null : \"Classes gen folder which has no corresponding content root: \" + cGen;\n      if (root == null) continue;\n\n      String rootInImlFormat = PATH_START_MODULE + Utils.getRelativeProjectPath(root);\n      Element contentRoot = Utils.getChildByAttribute(rootManager, CONTENT, URL, rootInImlFormat);\n\n      Element excludeFolder = new Element(EXCLUDE_FOLDER);\n      excludeFolder.setAttribute(URL, PATH_START_MODULE + Utils.getRelativeProjectPath(cGen));\n      contentRoot.addContent(excludeFolder);\n    }\n\n    System.out.println(\"Saving...\");\n    JDOMUtil.writeDocument(doc, genSourcesIml);\n\n    System.out.println(\"Done.\");\n  }","commit_id":"adfdf4d0c98d9afef2fd97134282d7eb4663300e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void updateCompilerExcludes(File compilerXmlFile, File... sourceDirs) throws JDOMException, IOException {\n    Document compiler = JDOMUtil.loadDocument(compilerXmlFile);\n\n    Element rootElement = Utils.getComponentWithName(compiler, COMPILER_CONFIGURATION);\n    Element excludeXml = rootElement.getChild(\"excludeFromCompile\");\n    excludeXml.removeChildren(DIRECTORY);\n\n    List<String> paths = new ArrayList<String>();\n    for (Pair<String, String> module : Utils.collectMPSCompiledModulesInfo(sourceDirs)) {\n      paths.add(PATH_START_PROJECT + Utils.getRelativeProjectPath(module.o2));\n    }\n    Collections.sort(paths);\n    for (String path : paths) {\n      Element excludedDir = new Element(DIRECTORY);\n      excludedDir.setAttribute(URL, path);\n      excludedDir.setAttribute(\"includeSubdirectories\", \"true\");\n      excludeXml.addContent(excludedDir);\n    }\n\n    JDOMUtil.writeDocument(compiler, compilerXmlFile);\n  }","id":87015,"modified_method":"public static void updateCompilerExcludes(File compilerXmlFile, File... sourceDirs) throws JDOMException, IOException {\n    Document compiler = JDOMUtil.loadDocument(compilerXmlFile);\n\n    Element rootElement = Utils.getComponentWithName(compiler, COMPILER_CONFIGURATION);\n    Element excludeXml = rootElement.getChild(\"excludeFromCompile\");\n    excludeXml.removeChildren(DIRECTORY);\n\n    List<String> paths = new ArrayList<String>();\n    for (Entry<String, Collection<String>> module : Utils.collectMPSCompiledModulesInfo(sourceDirs).entrySet()) {\n      for (String sourcePath : module.getValue()) {\n        paths.add(PATH_START_PROJECT + Utils.getRelativeProjectPath(sourcePath));\n      }\n    }\n    Collections.sort(paths);\n    for (String path : paths) {\n      Element excludedDir = new Element(DIRECTORY);\n      excludedDir.setAttribute(URL, path);\n      excludedDir.setAttribute(\"includeSubdirectories\", \"true\");\n      excludeXml.addContent(excludedDir);\n    }\n\n    JDOMUtil.writeDocument(compiler, compilerXmlFile);\n  }","commit_id":"adfdf4d0c98d9afef2fd97134282d7eb4663300e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<Pair<String, String>> collectMPSCompiledModulesInfo(File... dirs) {\n    List<Pair<String, String>> result = new ArrayList<Pair<String, String>>();\n    for (File dir : dirs) {\n      collectMPSCompiledModulesInfoRecursively(dir, result);\n    }\n    return result;\n  }","id":87016,"modified_method":"public static MultiMap<String, String> collectMPSCompiledModulesInfo(File... dirs) {\n    MultiMap<String, String> result = new MultiMap<String, String>();\n    for (File dir : dirs) {\n      collectMPSCompiledModulesInfoRecursively(dir, result);\n    }\n    return result;\n  }","commit_id":"adfdf4d0c98d9afef2fd97134282d7eb4663300e","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void collectMPSCompiledModulesInfoRecursively(File dir, List<Pair<String, String>> result) {\n    for (File child : dir.listFiles()) {\n      if (child.isDirectory()) {\n        collectMPSCompiledModulesInfoRecursively(child, result);\n        continue;\n      }\n\n      boolean solution = child.getName().endsWith(MPSExtentions.DOT_SOLUTION);\n      boolean language = child.getName().endsWith(MPSExtentions.DOT_LANGUAGE);\n      if (!(solution || language)) continue;\n\n      IFile moduleIFile = new IoFileSystemProvider().getFile(child.getAbsolutePath());\n      IFile moduleDir = moduleIFile.getParent();\n      MacroHelper expander = MacrosFactory.forModuleFile(moduleIFile);\n\n      if (solution) {\n        SolutionDescriptor sd = SolutionDescriptorPersistence.loadSolutionDescriptor(moduleIFile, expander);\n        if (!sd.getCompileInMPS()) continue;\n\n        String srcPath = ProjectPathUtil.getGeneratorOutputPath(moduleIFile, sd).getPath();\n        result.add(new Pair<String, String>(moduleDir.getPath(), srcPath));\n      } else {\n        LanguageDescriptor ld = LanguageDescriptorPersistence.loadLanguageDescriptor(moduleIFile, expander);\n        String srcPath = ProjectPathUtil.getGeneratorOutputPath(moduleIFile, ld).getPath();\n        result.add(new Pair<String, String>(moduleDir.getPath(), srcPath));\n      }\n    }\n  }","id":87017,"modified_method":"private static void collectMPSCompiledModulesInfoRecursively(File dir, MultiMap<String, String> result) {\n    for (File child : dir.listFiles()) {\n      if (child.isDirectory()) {\n        collectMPSCompiledModulesInfoRecursively(child, result);\n        continue;\n      }\n\n      boolean solution = child.getName().endsWith(MPSExtentions.DOT_SOLUTION);\n      boolean language = child.getName().endsWith(MPSExtentions.DOT_LANGUAGE);\n      if (!(solution || language)) continue;\n\n      IFile moduleIFile = new IoFileSystemProvider().getFile(child.getAbsolutePath());\n      IFile moduleDir = moduleIFile.getParent();\n      MacroHelper expander = MacrosFactory.forModuleFile(moduleIFile);\n\n      if (solution) {\n        SolutionDescriptor sd = SolutionDescriptorPersistence.loadSolutionDescriptor(moduleIFile, expander);\n        if (!sd.getCompileInMPS()) continue;\n\n        String srcPath = ProjectPathUtil.getGeneratorOutputPath(moduleIFile, sd).getPath();\n        result.putValue(moduleDir.getPath(), srcPath);\n        String testPath = ProjectPathUtil.getGeneratorTestsOutputPath(moduleIFile, sd).getPath();\n        result.putValue(moduleDir.getPath(), testPath);\n      } else {\n        LanguageDescriptor ld = LanguageDescriptorPersistence.loadLanguageDescriptor(moduleIFile, expander);\n        String srcPath = ProjectPathUtil.getGeneratorOutputPath(moduleIFile, ld).getPath();\n        result.putValue(moduleDir.getPath(), srcPath);\n      }\n    }\n  }","commit_id":"adfdf4d0c98d9afef2fd97134282d7eb4663300e","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void onDeactivate()\n   {\n      commandReg_.removeHandler();\n      commandReg_ = null;\n      \n      recordCurrentNavigationPosition();\n     \n   }","id":87018,"modified_method":"public void onDeactivate()\n   {\n      if (commandReg_ != null)\n         commandReg_.removeHandler();\n      commandReg_ = null;\n      \n      recordCurrentNavigationPosition();\n     \n   }","commit_id":"d7cd995ef41de725c50e92fdad3bffa738d02fae","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void detach()\n   {\n      stopExecution();\n      handlers_.removeHandler();\n   }","id":87019,"modified_method":"public void detach()\n   {\n      stop();\n      handlers_.removeHandler();\n   }","commit_id":"d385ade1d33df3e8ef96b6713162fe777e1fbb95","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void start()\n   {\n      if (isRunning_)\n         return;\n      \n      if (!task_.onStart())\n         return;\n      \n      isRunning_ = true;\n      stopRequested_ = false;\n      \n      if (handler_ != null)\n      {\n         handler_.removeHandler();\n         handler_ = null;\n      }\n      \n      handler_ = Event.addNativePreviewHandler(new NativePreviewHandler()\n      {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            int eventType = event.getTypeInt();\n            lastEventWasMouseMove_ = eventType == Event.ONMOUSEMOVE;\n            \n            if (lastEventWasMouseMove_)\n            {\n               lastMouseMoveTime_ = System.currentTimeMillis();\n               lastMouseCoords_ = ScreenCoordinates.create(\n                     event.getNativeEvent().getClientX(),\n                     event.getNativeEvent().getClientY());\n            }\n         }\n      });\n      \n      Scheduler.get().scheduleFixedDelay(new RepeatingCommand()\n      {\n         @Override\n         public boolean execute()\n         {\n            if (stopRequested_)\n               return stopExecution();\n            \n            long currentTime = System.currentTimeMillis();\n            long lastModifiedTime = docDisplay_.getLastModifiedTime();\n            long lastCursorChangedTime = docDisplay_.getLastCursorChangedTime();\n            \n            if ((currentTime - lastModifiedTime) < idleThresholdMs_)\n               return true;\n            \n            if ((currentTime - lastCursorChangedTime) < idleThresholdMs_)\n               return true;\n            \n            if ((currentTime - lastMouseMoveTime_) < idleThresholdMs_)\n               return true;\n            \n            Position position =\n                  lastEventWasMouseMove_ ?\n                        docDisplay_.toDocumentPosition(lastMouseCoords_) :\n                           docDisplay_.getCursorPosition();\n            \n            return task_.continueExecution(position, lastEventWasMouseMove_);\n         }\n      }, (int) pollDelayMs_);\n      \n   }","id":87020,"modified_method":"public void start()\n   {\n      // If we try to 'stop()' then 'start()' the background task in quick\n      // succession, we should unset the 'stopRequested_' field to ensure that\n      // the 'stop()' request is cancelled, and let the originally scheduled\n      // task continue running.\n      if (isRunning_)\n      {\n         stopRequested_ = false;\n         return;\n      }\n      \n      if (!task_.onStart())\n         return;\n      \n      isRunning_ = true;\n      stopRequested_ = false;\n      \n      if (handler_ != null)\n      {\n         handler_.removeHandler();\n         handler_ = null;\n      }\n      \n      handler_ = Event.addNativePreviewHandler(new NativePreviewHandler()\n      {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            int eventType = event.getTypeInt();\n            lastEventWasMouseMove_ = eventType == Event.ONMOUSEMOVE;\n            \n            if (lastEventWasMouseMove_)\n            {\n               lastMouseMoveTime_ = System.currentTimeMillis();\n               lastMouseCoords_ = ScreenCoordinates.create(\n                     event.getNativeEvent().getClientX(),\n                     event.getNativeEvent().getClientY());\n            }\n         }\n      });\n      \n      Scheduler.get().scheduleFixedDelay(new RepeatingCommand()\n      {\n         @Override\n         public boolean execute()\n         {\n            if (stopRequested_)\n               return stopExecution();\n            \n            long currentTime = System.currentTimeMillis();\n            long lastModifiedTime = docDisplay_.getLastModifiedTime();\n            long lastCursorChangedTime = docDisplay_.getLastCursorChangedTime();\n            \n            if ((currentTime - lastModifiedTime) < idleThresholdMs_)\n               return true;\n            \n            if ((currentTime - lastCursorChangedTime) < idleThresholdMs_)\n               return true;\n            \n            if ((currentTime - lastMouseMoveTime_) < idleThresholdMs_)\n               return true;\n            \n            Position position =\n                  lastEventWasMouseMove_ ?\n                        docDisplay_.toDocumentPosition(lastMouseCoords_) :\n                           docDisplay_.getCursorPosition();\n            \n            return task_.continueExecution(position, lastEventWasMouseMove_);\n         }\n      }, (int) pollDelayMs_);\n      \n   }","commit_id":"d385ade1d33df3e8ef96b6713162fe777e1fbb95","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void onUnload()\n   {\n      super.onUnload();\n      nativePreviewReg_.removeHandler();\n   }","id":87021,"modified_method":"@Override\n   protected void onUnload()\n   {\n      super.onUnload();\n      if (nativePreviewReg_ != null)\n      {\n         nativePreviewReg_.removeHandler();\n         nativePreviewReg_ = null;\n      }\n   }","commit_id":"d385ade1d33df3e8ef96b6713162fe777e1fbb95","url":"https://github.com/rstudio/rstudio"},{"original_method":"public RCompletionToolTip(DocDisplay docDisplay)\n   {\n      // save references\n      docDisplay_ = docDisplay;\n\n      // set the max width\n      setMaxWidth(Window.getClientWidth() - 200);\n      getElement().getStyle().setZIndex(10000);\n   }","id":87022,"modified_method":"public RCompletionToolTip(DocDisplay docDisplay)\n   {\n      docDisplay_ = docDisplay;\n      handlers_ = new HandlerRegistrations();\n\n      // set the max width\n      setMaxWidth(Window.getClientWidth() - 200);\n      getElement().getStyle().setZIndex(10000);\n      \n      addAttachHandler(new AttachEvent.Handler()\n      {\n         @Override\n         public void onAttachOrDetach(AttachEvent event)\n         {\n            if (event.isAttached())\n               attachHandlers();\n            else\n               detachHandlers();\n         }\n      });\n   }","commit_id":"d385ade1d33df3e8ef96b6713162fe777e1fbb95","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void onLoad()\n   {\n      super.onLoad();\n      nativePreviewReg_ = Event.addNativePreviewHandler(new NativePreviewHandler()\n      {\n         public void onPreviewNativeEvent(NativePreviewEvent e)\n         {\n            int eventType = e.getTypeInt();\n            if (eventType == Event.ONKEYDOWN ||\n                eventType == Event.ONMOUSEDOWN)\n            {\n               // dismiss if we've left our anchor zone\n               // (defer this so the current key has a chance to \n               // enter the editor and affect the cursor)\n               Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n\n                  @Override\n                  public void execute()\n                  {\n                     Position cursorPos = docDisplay_.getCursorPosition();\n                     if (anchor_ != null)\n                     {\n                        Range anchorRange = anchor_.getRange();\n\n                        if (cursorPos.isBeforeOrEqualTo(anchorRange.getStart()) ||\n                              cursorPos.isAfterOrEqualTo(anchorRange.getEnd()))\n                        {\n                           anchor_.detach();\n                           anchor_ = null;\n                           hide();\n                        }\n                     }\n                  }\n               });\n            }\n         }\n      });\n   }","id":87023,"modified_method":"@Override\n   protected void onLoad()\n   {\n      super.onLoad();\n      if (nativePreviewReg_ != null)\n      {\n         nativePreviewReg_.removeHandler();\n         nativePreviewReg_ = null;\n      }\n      \n      nativePreviewReg_ = Event.addNativePreviewHandler(new NativePreviewHandler()\n      {\n         public void onPreviewNativeEvent(NativePreviewEvent e)\n         {\n            int eventType = e.getTypeInt();\n            if (eventType == Event.ONKEYDOWN ||\n                eventType == Event.ONMOUSEDOWN)\n            {\n               // dismiss if we've left our anchor zone\n               // (defer this so the current key has a chance to \n               // enter the editor and affect the cursor)\n               Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n\n                  @Override\n                  public void execute()\n                  {\n                     Position cursorPos = docDisplay_.getCursorPosition();\n                     if (anchor_ != null)\n                     {\n                        Range anchorRange = anchor_.getRange();\n\n                        if (cursorPos.isBeforeOrEqualTo(anchorRange.getStart()) ||\n                              cursorPos.isAfterOrEqualTo(anchorRange.getEnd()))\n                        {\n                           anchor_.detach();\n                           anchor_ = null;\n                           hide();\n                        }\n                     }\n                  }\n               });\n            }\n         }\n      });\n   }","commit_id":"d385ade1d33df3e8ef96b6713162fe777e1fbb95","url":"https://github.com/rstudio/rstudio"},{"original_method":"public SignatureToolTipManager(DocDisplay docDisplay)\n   {\n      RStudioGinjector.INSTANCE.injectMembers(this);\n      toolTip_ = new RCompletionToolTip(docDisplay);\n      docDisplay_ = docDisplay;\n      idleTask_ = new DocumentIdleBackgroundTask(\n            docDisplay,\n            new DocumentIdleBackgroundTask.BackgroundTask()\n            {\n               @Override\n               public boolean continueExecution(Position position, boolean isMouse)\n               {\n                  if (!uiPrefs_.showFunctionTooltipOnIdle().getGlobalValue())\n                     return false;\n                  \n                  if (!uiPrefs_.showSignatureTooltips().getGlobalValue())\n                     return false;\n                  \n                  resolveActiveFunctionAndDisplayToolTip(position, !isMouse);\n                  return true;\n               }\n            });\n   }","id":87024,"modified_method":"public SignatureToolTipManager(DocDisplay docDisplay)\n   {\n      RStudioGinjector.INSTANCE.injectMembers(this);\n      toolTip_ = new RCompletionToolTip(docDisplay);\n      docDisplay_ = docDisplay;\n      handlers_ = new HandlerRegistrations();\n      \n      idleTask_ = new DocumentIdleBackgroundTask(\n            docDisplay,\n            new DocumentIdleBackgroundTask.BackgroundTask()\n            {\n               @Override\n               public boolean continueExecution(Position position, boolean isMouse)\n               {\n                  if (!uiPrefs_.showFunctionTooltipOnIdle().getGlobalValue())\n                     return false;\n                  \n                  if (!uiPrefs_.showSignatureTooltips().getGlobalValue())\n                     return false;\n                  \n                  isMouseTriggeredEvent_ = isMouse;\n                  resolveActiveFunctionAndDisplayToolTip(position, !isMouse);\n                  return true;\n               }\n            });\n      \n      handlers_.add(docDisplay_.addCursorChangedHandler(new CursorChangedHandler()\n      {\n         @Override\n         public void onCursorChanged(CursorChangedEvent event)\n         {\n            if (isMouseTriggeredEvent_)\n               toolTip_.hide();\n         }\n      }));\n   }","commit_id":"d385ade1d33df3e8ef96b6713162fe777e1fbb95","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void resolveActiveFunctionAndDisplayToolTip(\n         final Position position,\n         final boolean searchForFunction)\n   {\n            \n      if (!uiPrefs_.showSignatureTooltips().getValue())\n         return;\n      \n      if (docDisplay_.isPopupVisible())\n         return;\n      \n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return;\n      \n      TokenCursor cursor = editor.getSession().getMode().getRCodeModel().getTokenCursor();\n      if (!cursor.moveToPosition(position))\n         return;\n\n      if (searchForFunction && !cursor.moveToActiveFunction())\n         return;\n      \n      if (!cursor.nextValue().equals(\"(\"))\n         return;\n      \n      final TokenCursor callEndCursor = cursor.cloneCursor();\n      Position callEndPos = callEndCursor.currentPosition();\n      callEndPos.setColumn(\n            callEndPos.getColumn() +\n            callEndCursor.currentValue().length());\n      \n      if (!cursor.findStartOfEvaluationContext())\n         return;\n\n      final String callString = editor.getTextForRange(Range.fromPoints(\n            cursor.currentPosition(),\n            callEndPos));\n      \n      if (isBoringFunction(callString))\n         return;\n\n      server_.getArgs(callString, \"\", new ServerRequestCallback<String>() {\n         \n         @Override\n         public void onResponseReceived(String arguments)\n         {\n            final String signature = callString + arguments;\n            \n            if (StringUtil.isNullOrEmpty(arguments))\n               return;\n            \n            if (toolTip_.isShowing() && toolTip_.getSignature().equals(signature))\n               return;\n            \n            if (!searchForFunction)\n            {\n               toolTip_.resolvePositionAndShow(\n                     signature,\n                     position);\n            }\n            else\n            {\n               TokenCursor endCursor = callEndCursor.cloneCursor();\n               if (!endCursor.moveToNextToken())\n                  return;\n               \n               if (!endCursor.fwdToMatchingToken())\n                  return;\n               \n               toolTip_.resolvePositionAndShow(\n                     signature,\n                     Range.fromPoints(\n                           callEndCursor.currentPosition(),\n                           endCursor.currentPosition()));\n            }\n         }\n\n         @Override\n         public void onError(ServerError error)\n         {\n            Debug.logError(error);\n         }\n      });\n   }","id":87025,"modified_method":"public void resolveActiveFunctionAndDisplayToolTip(\n         final Position position,\n         final boolean searchForFunction)\n   {\n            \n      if (!uiPrefs_.showSignatureTooltips().getValue())\n         return;\n      \n      if (docDisplay_.isPopupVisible())\n         return;\n      \n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor == null)\n         return;\n      \n      TokenCursor cursor = editor.getSession().getMode().getRCodeModel().getTokenCursor();\n      if (!cursor.moveToPosition(position))\n         return;\n\n      if (searchForFunction && !cursor.moveToActiveFunction())\n         return;\n      \n      if (!cursor.nextValue().equals(\"(\"))\n         return;\n      \n      final TokenCursor callEndCursor = cursor.cloneCursor();\n      Position callEndPos = callEndCursor.currentPosition();\n      callEndPos.setColumn(\n            callEndPos.getColumn() +\n            callEndCursor.currentValue().length());\n      \n      if (!cursor.findStartOfEvaluationContext())\n         return;\n\n      final String callString = editor.getTextForRange(Range.fromPoints(\n            cursor.currentPosition(),\n            callEndPos));\n      \n      if (isBoringFunction(callString))\n         return;\n      \n      if (position.equals(lastCursorPosition_))\n         return;\n\n      server_.getArgs(callString, \"\", new ServerRequestCallback<String>() {\n         \n         @Override\n         public void onResponseReceived(String arguments)\n         {\n            final String signature = callString + arguments;\n            \n            if (StringUtil.isNullOrEmpty(arguments))\n               return;\n            \n            if (!searchForFunction)\n            {\n               lastCursorPosition_ = position;\n               toolTip_.resolvePositionAndShow(\n                     signature,\n                     position);\n            }\n            else\n            {\n               TokenCursor endCursor = callEndCursor.cloneCursor();\n               if (!endCursor.moveToNextToken())\n                  return;\n               \n               if (!endCursor.fwdToMatchingToken())\n                  return;\n               \n               lastCursorPosition_ = position;\n               toolTip_.resolvePositionAndShow(\n                     signature,\n                     Range.fromPoints(\n                           callEndCursor.currentPosition(),\n                           endCursor.currentPosition()));\n            }\n         }\n\n         @Override\n         public void onError(ServerError error)\n         {\n            Debug.logError(error);\n         }\n      });\n   }","commit_id":"d385ade1d33df3e8ef96b6713162fe777e1fbb95","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\r\n     * Categoryfield widgets for ADE forms.<p>\r\n     */\r\n    public CmsCategoryField() {\r\n\r\n        super();\r\n        initWidget(m_panel);\r\n        m_panel.add(m_scrollPanel);\r\n        m_scrollPanel.setResizable(true);\r\n        m_scrollPanel.getElement().getStyle().setHeight(50, Unit.PX);\r\n        m_scrollPanel.add(m_categories);\r\n\r\n        m_panel.add(m_error);\r\n        m_scrollPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.generalCss().cornerAll());\r\n    }","id":87026,"modified_method":"/**\r\n     * Categoryfield widgets for ADE forms.<p>\r\n     */\r\n    public CmsCategoryField() {\r\n\r\n        super();\r\n        initWidget(m_panel);\r\n        m_panel.add(m_scrollPanel);\r\n        m_scrollPanel.getElement().getStyle().setHeight(50, Unit.PX);\r\n        m_scrollPanel.add(m_categories);\r\n\r\n        m_panel.add(m_error);\r\n        m_scrollPanel.addStyleName(I_CmsLayoutBundle.INSTANCE.generalCss().cornerAll());\r\n    }","commit_id":"b0d4a60caffda899582674f54092742f529615eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Returns a list of all selected values.<p>\r\n     * \r\n     * @return a list of selected values\r\n     */\r\n    public List<String> getAllSelected() {\r\n\r\n        return m_selectedCategories;\r\n    }","id":87027,"modified_method":"/**\r\n     * Returns a list of all selected values.<p>\r\n     * \r\n     * @return a list of selected values\r\n     */\r\n    public List<String> getAllSelected() {\r\n\r\n        List<String> result = new ArrayList<String>();\r\n        Iterator<Widget> it = m_scrollList.iterator();\r\n        while (it.hasNext()) {\r\n            CmsTreeItem test = (CmsTreeItem)it.next();\r\n            if (test.getCheckBox().isChecked()) {\r\n                result.add(test.getId());\r\n                selectedChildren(result, test);\r\n            }\r\n        }\r\n        return result;\r\n    }","commit_id":"b0d4a60caffda899582674f54092742f529615eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Help function to parse the configuration.<p>\r\n     * @param configuration the value to be parsed.\r\n     *  \r\n     * */\r\n    private void parseConfiguration(String configuration) {\r\n\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(configuration)) {\r\n            int categoryIndex = configuration.indexOf(CONFIGURATION_CATEGORY);\r\n            if (categoryIndex != -1) {\r\n                // category is given\r\n                String category = configuration.substring(CONFIGURATION_CATEGORY.length() + 1);\r\n                if (category.indexOf('|') != -1) {\r\n                    // cut eventual following configuration values\r\n                    category = category.substring(0, category.indexOf('|'));\r\n                }\r\n                m_categoryFolder = category;\r\n            }\r\n            int selectiontypeIndex = configuration.indexOf(CONFIGURATION_SELECTIONTYPE);\r\n            if (selectiontypeIndex != -1) {\r\n                // selection type is given\r\n                String selectiontype = configuration.substring(selectiontypeIndex\r\n                    + CONFIGURATION_SELECTIONTYPE.length()\r\n                    + 1);\r\n                if (selectiontype.indexOf(\"|\") != -1) {\r\n                    // cut eventual following configuration values\r\n                    selectiontype = selectiontype.substring(0, selectiontype.indexOf(\"|\"));\r\n                }\r\n                m_selectiontype = selectiontype;\r\n            }\r\n\r\n        }\r\n    }","id":87028,"modified_method":"/**\r\n     * Help function to parse the configuration.<p>\r\n     * @param configuration the value to be parsed.\r\n     *  \r\n     * */\r\n    private void parseConfiguration(String configuration) {\r\n\r\n        if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(configuration)) {\r\n            int categoryIndex = configuration.indexOf(CONFIGURATION_CATEGORY);\r\n            if (categoryIndex != -1) {\r\n                // category is given\r\n                String category = configuration.substring(CONFIGURATION_CATEGORY.length() + 1);\r\n                if (category.indexOf('|') != -1) {\r\n                    // cut eventual following configuration values\r\n                    category = category.substring(0, category.indexOf('|'));\r\n                }\r\n                m_categoryFolder = category;\r\n            }\r\n            int selectiontypeIndex = configuration.indexOf(CONFIGURATION_SELECTIONTYPE);\r\n            if (selectiontypeIndex != -1) {\r\n                // selection type is given\r\n                String selectiontype = configuration.substring(selectiontypeIndex\r\n                    + CONFIGURATION_SELECTIONTYPE.length()\r\n                    + 1);\r\n                if (selectiontype.indexOf(\"|\") != -1) {\r\n                    // cut eventual following configuration values\r\n                    selectiontype = selectiontype.substring(0, selectiontype.indexOf(\"|\"));\r\n                }\r\n                m_selectiontype = selectiontype;\r\n            }\r\n            int categoryListIndex = configuration.indexOf(CONFIGURATION_CATEGORYLIST);\r\n            if (categoryListIndex != -1) {\r\n                // selection type is given\r\n                String catList = configuration.substring(categoryListIndex + CONFIGURATION_CATEGORYLIST.length() + 1);\r\n                if (catList.indexOf(\"|\") != -1) {\r\n                    // cut eventual following configuration values\r\n                    catList = catList.substring(0, catList.indexOf(\"|\"));\r\n                }\r\n                String[] catArray = catList.split(\",\");\r\n                for (int i = 0; i < catArray.length; i++) {\r\n                    m_categoryList.add(catArray[i]);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n    }","commit_id":"b0d4a60caffda899582674f54092742f529615eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * \r\n     */\r\n    protected void closePopup() {\r\n\r\n        m_previewHandlerRegistration.removeHandler();\r\n        m_previewHandlerRegistration = null;\r\n        String selected = \"\";\r\n        if (m_isSingelValue) {\r\n            selected = m_cmsCategoryTree.getSelected();\r\n        } else {\r\n            for (String s : m_cmsCategoryTree.getAllSelected()) {\r\n                if (!s.isEmpty()) {\r\n                    selected += m_categoryFolder + s + \",\";\r\n                }\r\n            }\r\n        }\r\n        setValue(selected);\r\n        m_cmsPopup.hide();\r\n\r\n    }","id":87029,"modified_method":"/**\r\n     * \r\n     */\r\n    protected void closePopup() {\r\n\r\n        if (m_previewHandlerRegistration != null) {\r\n            m_previewHandlerRegistration.removeHandler();\r\n            m_previewHandlerRegistration = null;\r\n        }\r\n        String selected = \"\";\r\n        if (m_isSingelValue) {\r\n            selected = m_cmsCategoryTree.getSelected();\r\n        } else {\r\n            for (String s : m_cmsCategoryTree.getAllSelected()) {\r\n                if (!s.isEmpty()) {\r\n                    selected += m_categoryFolder + s + \",\";\r\n                }\r\n            }\r\n        }\r\n        setValue(selected);\r\n        m_cmsPopup.hide();\r\n\r\n    }","commit_id":"b0d4a60caffda899582674f54092742f529615eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#setValue(java.lang.Object, boolean)\r\n     */\r\n    public void setValue(String value, boolean fireEvents) {\r\n\r\n        String singelValue = \"\";\r\n        m_selected.clear();\r\n        if (m_isSingelValue && !value.isEmpty() && !value.replace(m_categoryFolder, \"\").isEmpty()) {\r\n            value = value.replace(\",\", \"\");\r\n            String childValue = value.replace(m_categoryFolder, \"\");\r\n            singelValue = childValue;\r\n            String helpValue = childValue.substring(0, childValue.lastIndexOf(\"/\"));\r\n            while (helpValue.indexOf(\"/\") != -1) {\r\n                helpValue = helpValue.substring(0, helpValue.lastIndexOf(\"/\") + 1);\r\n                value += \",\" + m_categoryFolder + helpValue;\r\n                helpValue = helpValue.substring(0, helpValue.lastIndexOf(\"/\"));\r\n            }\r\n        }\r\n\r\n        String shortvalue = value.replaceAll(m_categoryFolder, \"\");\r\n        m_selectedValue = shortvalue;\r\n        String[] selected = shortvalue.split(\",\");\r\n        m_selectedArray = selected;\r\n        ArrayList<String> test = new ArrayList<String>();\r\n        for (int i = 0; i < selected.length; i++) {\r\n            m_selected.add(selected[i].replace(m_categoryFolder, \"\"));\r\n            test.add(selected[i].replace(m_categoryFolder, \"\"));\r\n        }\r\n\r\n        if (!selected[0].isEmpty()) {\r\n            m_results = new ArrayList<CmsCategoryTreeEntry>();\r\n            parseValues(test.toArray(new String[0]), null, 1);\r\n            m_categoryField.buildCategoryTree(m_results, m_selected);\r\n        } else {\r\n            m_results = new ArrayList<CmsCategoryTreeEntry>();\r\n            m_categoryField.buildCategoryTree(m_results, m_selected);\r\n        }\r\n\r\n        if (fireEvents) {\r\n            fireChangeEvent();\r\n        }\r\n        if (m_isSingelValue) {\r\n            m_selected.clear();\r\n            m_selected.add(singelValue);\r\n        }\r\n        if (!selected[0].isEmpty()) {\r\n            int elementheight = (selected.length * 24) + 2;\r\n            if (elementheight < DEFAULT_HEIGHT) {\r\n                m_height = elementheight;\r\n            } else {\r\n                m_height = DEFAULT_HEIGHT;\r\n            }\r\n\r\n            if (m_height > MAX_HEIGHT) {\r\n                m_height = MAX_HEIGHT;\r\n            }\r\n        } else {\r\n            m_height = 26;\r\n        }\r\n        m_categoryField.setHeight(m_height);\r\n    }","id":87030,"modified_method":"/**\r\n     * @see com.google.gwt.user.client.ui.HasValue#setValue(java.lang.Object, boolean)\r\n     */\r\n    public void setValue(String value, boolean fireEvents) {\r\n\r\n        String singelValue = \"\";\r\n        m_selected.clear();\r\n        if (m_isSingelValue && !value.isEmpty()) {\r\n            Iterator<String> it = m_categoryList.iterator();\r\n            while (it.hasNext()) {\r\n                String catRootPath = it.next();\r\n                if (value.contains(catRootPath)) {\r\n                    m_categoryFolder = catRootPath;\r\n                }\r\n            }\r\n            value = value.replace(\",\", \"\");\r\n            String childValue = value.replace(m_categoryFolder, \"\");\r\n            singelValue = childValue;\r\n            String helpValue = childValue.substring(0, childValue.lastIndexOf(\"/\"));\r\n            while (helpValue.indexOf(\"/\") != -1) {\r\n                helpValue = helpValue.substring(0, helpValue.lastIndexOf(\"/\") + 1);\r\n                value += \",\" + m_categoryFolder + helpValue;\r\n                helpValue = helpValue.substring(0, helpValue.lastIndexOf(\"/\"));\r\n            }\r\n        }\r\n\r\n        String shortvalue = value.replaceAll(m_categoryFolder, \"\");\r\n        m_selectedValue = shortvalue;\r\n        String[] selected = shortvalue.split(\",\");\r\n        m_selectedArray = selected;\r\n        ArrayList<String> test = new ArrayList<String>();\r\n        for (int i = 0; i < selected.length; i++) {\r\n            m_selected.add(selected[i].replace(m_categoryFolder, \"\"));\r\n            test.add(selected[i].replace(m_categoryFolder, \"\"));\r\n        }\r\n\r\n        if (!selected[0].isEmpty()) {\r\n            m_results = new ArrayList<CmsCategoryTreeEntry>();\r\n            parseValues(test.toArray(new String[0]), null, 1);\r\n            m_categoryField.buildCategoryTree(m_results, m_selected);\r\n        } else {\r\n            m_results = new ArrayList<CmsCategoryTreeEntry>();\r\n            m_categoryField.buildCategoryTree(m_results, m_selected);\r\n        }\r\n\r\n        if (fireEvents) {\r\n            fireChangeEvent();\r\n        }\r\n        if (m_isSingelValue) {\r\n            m_selected.clear();\r\n            m_selected.add(singelValue);\r\n        }\r\n\r\n        if (!selected[0].isEmpty()) {\r\n            int elementheight = (selected.length * 24) + 2;\r\n            m_height = elementheight;\r\n\r\n            if (m_height > MAX_HEIGHT) {\r\n                m_height = MAX_HEIGHT;\r\n                m_categoryField.getScrollPanel().setResizable(true);\r\n            }\r\n        } else {\r\n            m_height = 24;\r\n        }\r\n        m_categoryField.setHeight(m_height);\r\n    }","commit_id":"b0d4a60caffda899582674f54092742f529615eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Constructs an CmsComboWidget with the in XSD schema declared configuration.<p>\r\n     * @param config The configuration string given from OpenCms XSD\r\n     * @param isSingelValue Is true if only one value is set in xml\r\n     */\r\n    public CmsCategoryWidget(String config) {\r\n\r\n        //merge configuration string\r\n        parseConfiguration(config);\r\n\r\n        if (m_selectiontype.equals(\"multi\")) {\r\n            m_isSingelValue = false;\r\n        } else {\r\n            m_isSingelValue = true;\r\n        }\r\n\r\n        m_categoryField.getScrollPanel().addStyleName(I_CmsLayoutBundle.INSTANCE.widgetCss().categoryPanel());\r\n\r\n        m_categoryField.addDomHandler(new ClickHandler() {\r\n\r\n            public void onClick(ClickEvent event) {\r\n\r\n                if ((m_cmsPopup == null) || !m_cmsPopup.isShowing()) {\r\n                    openPopup();\r\n                } else {\r\n                    closePopup();\r\n                }\r\n\r\n            }\r\n        }, ClickEvent.getType());\r\n        initWidget(m_categoryField);\r\n    }","id":87031,"modified_method":"/**\r\n     * Constructs an CmsComboWidget with the in XSD schema declared configuration.<p>\r\n     * @param config The configuration string given from OpenCms XSD\r\n     */\r\n    public CmsCategoryWidget(String config) {\r\n\r\n        //merge configuration string\r\n        parseConfiguration(config);\r\n\r\n        if (m_selectiontype.equals(\"multi\")) {\r\n            m_isSingelValue = false;\r\n        } else {\r\n            m_isSingelValue = true;\r\n        }\r\n\r\n        m_categoryField.getScrollPanel().addStyleName(I_CmsLayoutBundle.INSTANCE.widgetCss().categoryPanel());\r\n        m_categoryField.getScrollPanel().setResizable(false);\r\n        m_categoryField.addDomHandler(new ClickHandler() {\r\n\r\n            public void onClick(ClickEvent event) {\r\n\r\n                if ((m_cmsPopup == null) || !m_cmsPopup.isShowing()) {\r\n                    openPopup();\r\n                } else {\r\n                    closePopup();\r\n                }\r\n\r\n            }\r\n        }, ClickEvent.getType());\r\n        initWidget(m_categoryField);\r\n    }","commit_id":"b0d4a60caffda899582674f54092742f529615eb","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public static Toolbar createToolbarFromXul( Document doc, Shell shell, Messages xulMessages, Object caller ) {\n\t\tNodeList list = doc.getElementsByTagName( \"toolbox\" ); //$NON-NLS-1$\n\t\tToolbar toolbar = null;\n\t\tif( list != null && list.getLength() > 0 ) {\n\t\t\t// we can only handle one menu bar\n\t\t\tNode toolboxNode = list.item( 0 );\n\t\t\t// get the top level menus\n\t\t\tNode toolbarNode = XMLHandler.getSubNode( toolboxNode, \"toolbar\" ); //$NON-NLS-1$\n\t\t\twhile( toolbarNode != null ) {\n\t\t\t\tif( \"toolbar\".equals( toolbarNode.getNodeName() ) ) { //$NON-NLS-1$\n\t\t\t        \t// create a top-level item\n\t\t\t\t\t\tString id = XMLHandler.getTagAttribute( toolbarNode, \"id\" ); //$NON-NLS-1$\n\t\t\t\t    \ttoolbar = new Toolbar(shell, id, null);\n\t\t\t\t    \t\n\t\t\t\t\t\tNode buttonNode = toolbarNode.getFirstChild();\n\t\t\t\t\t\twhile( buttonNode != null ) {\n\t\t\t\t\t\t\tif( \"toolbarbutton\".equals( buttonNode.getNodeName() ) ) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\tString value = XMLHandler.getTagAttribute( buttonNode, \"value\" ); //$NON-NLS-1$\n\t\t\t\t\t\t\t\tString imagePath = XMLHandler.getTagAttribute( buttonNode, \"image\" ); //$NON-NLS-1$\n\t\t\t\t\t\t\t\tString hint = XMLHandler.getTagAttribute( buttonNode, \"tooltiptext\" ); //$NON-NLS-1$\n\t\t\t\t\t\t\t\thint = localizeXulText( hint, xulMessages );\n\t\t\t\t\t\t\t\tToolbarButton button = new ToolbarButton(shell, value, toolbar);\n\t\t\t\t\t\t\t\tbutton.setHint(hint);\n//\t\t\t\t\t\t        final Image image = ImageUtil.makeImageTransparent(shell.getDisplay(), \n//\t\t\t\t\t\t        \t\tnew Image(shell.getDisplay(), caller.getClass().getResourceAsStream(imagePath)), new RGB(192, 192, 192)); \n\t\t\t\t\t\t        final Image image = new Image(shell.getDisplay(), caller.getClass().getResourceAsStream(imagePath)); \n\t\t\t\t\t\t        button.setImage(image);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if( \"toolbarseparator\".equals( buttonNode.getNodeName() ) ) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\tnew ToolbarSeparator(shell, toolbar);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuttonNode = buttonNode.getNextSibling();\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// see if there are more options\n\t\t\t\ttoolbarNode = toolbarNode.getNextSibling();\n\t\t\t}\n\t\t\treturn toolbar;\n\t\t}\n\t\treturn null;\n\t}","id":87032,"modified_method":"public static Toolbar createToolbarFromXul( Document doc, Shell shell, Messages xulMessages, Object caller ) {\n\t\tNodeList list = doc.getElementsByTagName( \"toolbox\" ); //$NON-NLS-1$\n\t\tToolbar toolbar = null;\n\t\tif( list != null && list.getLength() > 0 ) {\n\t\t\t// we can only handle one menu bar\n\t\t\tNode toolboxNode = list.item( 0 );\n\t\t\t// get the top level menus\n\t\t\tNode toolbarNode = XMLHandler.getSubNode( toolboxNode, \"toolbar\" ); //$NON-NLS-1$\n\t\t\twhile( toolbarNode != null ) {\n\t\t\t\tif( \"toolbar\".equals( toolbarNode.getNodeName() ) ) { //$NON-NLS-1$\n\t\t\t        \t// create a top-level item\n\t\t\t\t\t\tString id = XMLHandler.getTagAttribute( toolbarNode, \"id\" ); //$NON-NLS-1$\n\t\t\t\t    \ttoolbar = new Toolbar(shell, id, null);\n\t\t\t\t    \t\n\t\t\t\t\t\tNode buttonNode = toolbarNode.getFirstChild();\n\t\t\t\t\t\twhile( buttonNode != null ) {\n\t\t\t\t\t\t\tif( \"toolbarbutton\".equals( buttonNode.getNodeName() ) ) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\tString value = XMLHandler.getTagAttribute( buttonNode, \"value\" ); //$NON-NLS-1$\n\t\t\t\t\t\t\t\tString imagePath = XMLHandler.getTagAttribute( buttonNode, \"image\" ); //$NON-NLS-1$\n\t\t\t\t\t\t\t\tString hint = XMLHandler.getTagAttribute( buttonNode, \"tooltiptext\" ); //$NON-NLS-1$\n\t\t\t\t\t\t\t\thint = localizeXulText( hint, xulMessages );\n\t\t\t\t\t\t\t\tToolbarButton button = new ToolbarButton(shell, value, toolbar);\n\t\t\t\t\t\t\t\tbutton.setHint(hint);\n//\t\t\t\t\t\t        final Image image = ImageUtil.makeImageTransparent(shell.getDisplay(), \n//\t\t\t\t\t\t        \t\tnew Image(shell.getDisplay(), caller.getClass().getResourceAsStream(imagePath)), new RGB(192, 192, 192)); \n\t\t\t\t\t\t\t\tInputStream stream = caller.getClass().getResourceAsStream(imagePath);\n\t\t\t\t\t\t\t\tif( stream != null ) {\n\t\t\t\t\t\t\t        final Image image = new Image(shell.getDisplay(), stream); \n\t\t\t\t\t\t\t        button.setImage(image);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if( \"toolbarseparator\".equals( buttonNode.getNodeName() ) ) { //$NON-NLS-1$\n\t\t\t\t\t\t\t\tnew ToolbarSeparator(shell, toolbar);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbuttonNode = buttonNode.getNextSibling();\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// see if there are more options\n\t\t\t\ttoolbarNode = toolbarNode.getNextSibling();\n\t\t\t}\n\t\t\treturn toolbar;\n\t\t}\n\t\treturn null;\n\t}","commit_id":"ddaa4f214647f5477f4c784460c274bf4b1e3af6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | (modal?SWT.APPLICATION_MODAL:SWT.NONE) | SWT.RESIZE | SWT.MIN | SWT.MAX );\r\n \t\tprops.setLook(shell);\n \t\t\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(shellText);\n\t\tshell.setImage(GUIResource.getInstance().getImageSpoon());\r\n\t\t\r\n\t\tint margin = Const.MARGIN;\r\n\t\t\r\n\t\tif(quickSearch)\r\n\t\t{\r\n\t\t\tToolBar treeTb = new ToolBar(shell, SWT.HORIZONTAL | SWT.FLAT);\r\n\t\t\tprops.setLook(treeTb);\r\n\t\r\n\t\t\tToolItem wtfilter = new ToolItem(treeTb, SWT.SEPARATOR);\r\n\t\t\tLabel wlfilter = new Label(treeTb, SWT.SEARCH);\r\n\t\t\tprops.setLook(wlfilter);\r\n\t\t\twlfilter.setText(BaseMessages.getString(PKG, \"EnterSelectionDialog.FilterString.Label\"));\r\n\t\t\twtfilter.setControl(wlfilter);\r\n\t\t\tif(Const.isOSX()) {\r\n\t\t\t\twtfilter.setWidth(100);\r\n\t\t\t} else {\r\n\t\t\t\twtfilter.setWidth(60);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twfilter = new ToolItem(treeTb, SWT.SEPARATOR);\r\n\t\t\tsearchText = new Text(treeTb, SWT.SEARCH | SWT.CANCEL);\r\n\t\t\tprops.setLook(searchText);\r\n\t\t\tsearchText.setToolTipText(BaseMessages.getString(PKG, \"EnterSelectionDialog.FilterString.ToolTip\"));\r\n\t\t\twfilter.setControl(searchText);\r\n\t\t\twfilter.setWidth(120);\r\n\t\t\t\r\n\t\t\twbRegex = new ToolItem(treeTb, SWT.CHECK);\r\n\t\t\twbRegex.setImage(GUIResource.getInstance().getImageRegexSmall());\r\n\t\t\twbRegex.setToolTipText(BaseMessages.getString(PKG, \"EnterSelectionDialog.useRegEx.Tooltip\"));\r\n\t\t\t\t\t\t\r\n\t\t\tgoSearch = new ToolItem(treeTb,SWT.PUSH);\r\n\t\t    goSearch.setImage(GUIResource.getInstance().getImageSearchSmall());\r\n\t\t    goSearch.setToolTipText(BaseMessages.getString(PKG, \"EnterSelectionDialog.refresh.Label\"));\r\n\r\n\t      goSearch.addSelectionListener(new SelectionAdapter() {\r\n          public void widgetSelected(SelectionEvent event) {\r\n            updateFilter();\r\n          }});\t\t    \r\n\t\t    \r\n\t    addConnection = new ToolItem(treeTb,SWT.PUSH);\r\n\t    addConnection.setImage(GUIResource.getInstance().getImageAdd());\r\n\t    addConnection.setToolTipText(BaseMessages.getString(PKG, \"Add.Datasource.Label\"));\r\n\t    \r\n\t    addConnection.addSelectionListener(new SelectionAdapter() {\r\n\t          public void widgetSelected(SelectionEvent event) {\r\n\t            addDataSource();\r\n\t          }});  \r\n\t\t    \r\n\t        FormData fd=new FormData();\r\n\t        fd.right = new FormAttachment(100, -margin);\r\n\t        fd.top  = new FormAttachment(0, margin);\r\n\t\t\ttreeTb.setLayoutData(fd);\r\n\t\t\t\r\n\t\t\t searchText.addSelectionListener(new SelectionAdapter() {\r\n\t\t\t\t public void widgetDefaultSelected(SelectionEvent e) { updateFilter(); } });\r\n\t\r\n\t\r\n\t\t\t// From step line\r\n\t\t\twlSelection=new Label(shell, SWT.NONE);\r\n\t\t\twlSelection.setText(lineText);\r\n\t \t\tprops.setLook(wlSelection);\r\n\t\t\tfdlSelection=new FormData();\r\n\t\t\tfdlSelection.left = new FormAttachment(0, 0);\r\n\t\t\tfdlSelection.top  = new FormAttachment(treeTb, margin);\r\n\t\t\twlSelection.setLayoutData(fdlSelection);\r\n\t\t}else{\r\n\t\t\t// From step line\r\n\t\t\twlSelection=new Label(shell, SWT.NONE);\r\n\t\t\twlSelection.setText(lineText);\r\n\t \t\tprops.setLook(wlSelection);\r\n\t\t\tfdlSelection=new FormData();\r\n\t\t\tfdlSelection.left = new FormAttachment(0, 0);\r\n\t\t\twlSelection.setLayoutData(fdlSelection);\r\n\t\t}\n        \n        int options = SWT.LEFT | SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL;\n        if (multi) options|=SWT.MULTI; else options|=SWT.SINGLE;  \n        \r\n\t\twSelection=new List(shell, options );\r\n\t\tfor (int i=0;i<choices.length;i++) wSelection.add(choices[i]);\r\n\t\tif (selectedNrs!=null)\r\n\t\t{\r\n\t\t\twSelection.select(selectedNrs);\r\n\t\t\twSelection.showSelection();\r\n\t\t}\n        if (fixed)\n        {\n            props.setLook(wSelection, Props.WIDGET_STYLE_FIXED);\n        }\n        else\n        {\r\n            props.setLook(wSelection);\n        }\r\n\t\t\r\n\r\n\t\t// Some buttons\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\tif (viewOnly) \r\n\t\t{\r\n\t\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.Close\"));\r\n\t\t} \r\n\t\telse\r\n\t\t{\r\n\t\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\t\t}\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\r\n\t\twOK.addListener    (SWT.Selection, lsOK     );\n        \n        Button[] buttons = new Button[] { wOK };\r\n\t\t\r\n\t\tif (!viewOnly)\r\n\t\t{\r\n\t\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\t\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\r\n\t\t\twCancel.addListener(SWT.Selection, lsCancel );\n            \n            buttons = new Button[] { wOK, wCancel };\n\t\t}\n        \n        BaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\r\n\n        fdSelection=new FormData();\n        fdSelection.left = new FormAttachment(0, 0);\n        fdSelection.right= new FormAttachment(100, 0);\n        fdSelection.top  = new FormAttachment(wlSelection, margin);\n        fdSelection.bottom= new FormAttachment(wOK, -margin*3);\n        wSelection.setLayoutData(fdSelection);\n        \r\n\t\t// Add listeners\r\n\t\t\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\twSelection.addSelectionListener(lsDef);\r\n\t\twSelection.addKeyListener(new KeyAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void keyPressed(KeyEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tif (e.character == SWT.CR) ok();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Detect [X] or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n\t\tgetData();\r\n\t\t\r\n\t\tBaseStepDialog.setSize(shell);\n\t\t\r\n\t\twOK.setFocus();\r\n\t\t\r\n\t\tshell.open();\n\t\t\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn selection;\r\n\t}","id":87033,"modified_method":"public String open()\r\n\t{\r\n\t\tShell parent = getParent();\r\n\t\tDisplay display = parent.getDisplay();\r\n\r\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | (modal?SWT.APPLICATION_MODAL:SWT.NONE) | SWT.RESIZE | SWT.MIN | SWT.MAX );\r\n \t\tprops.setLook(shell);\n \t\t\r\n\r\n\t\tFormLayout formLayout = new FormLayout ();\r\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\r\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\r\n\r\n\t\tshell.setLayout(formLayout);\r\n\t\tshell.setText(shellText);\n\t\tshell.setImage(GUIResource.getInstance().getImageSpoon());\r\n\t\t\r\n\t\tint margin = Const.MARGIN;\r\n\t\t\r\n\t\tif(quickSearch)\r\n\t\t{\r\n\t\t\tToolBar treeTb = new ToolBar(shell, SWT.HORIZONTAL | SWT.FLAT);\r\n\t\t\tprops.setLook(treeTb);\r\n\t\r\n\t\t\tToolItem wtfilter = new ToolItem(treeTb, SWT.SEPARATOR);\r\n\t\t\tLabel wlfilter = new Label(treeTb, SWT.SEARCH);\r\n\t\t\tprops.setLook(wlfilter);\r\n\t\t\twlfilter.setText(BaseMessages.getString(PKG, \"EnterSelectionDialog.FilterString.Label\"));\r\n\t\t\twtfilter.setControl(wlfilter);\r\n\t\t\tif(Const.isOSX()) {\r\n\t\t\t\twtfilter.setWidth(100);\r\n\t\t\t} else {\r\n\t\t\t\twtfilter.setWidth(60);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twfilter = new ToolItem(treeTb, SWT.SEPARATOR);\r\n\t\t\tsearchText = new Text(treeTb, SWT.SEARCH | SWT.CANCEL);\r\n\t\t\tprops.setLook(searchText);\r\n\t\t\tsearchText.setToolTipText(BaseMessages.getString(PKG, \"EnterSelectionDialog.FilterString.ToolTip\"));\r\n\t\t\twfilter.setControl(searchText);\r\n\t\t\twfilter.setWidth(120);\r\n\t\t\t\r\n\t\t\twbRegex = new ToolItem(treeTb, SWT.CHECK);\r\n\t\t\twbRegex.setImage(GUIResource.getInstance().getImageRegexSmall());\r\n\t\t\twbRegex.setToolTipText(BaseMessages.getString(PKG, \"EnterSelectionDialog.useRegEx.Tooltip\"));\r\n\t\t\t\t\t\t\r\n\t\t\tgoSearch = new ToolItem(treeTb,SWT.PUSH);\r\n\t\t    goSearch.setImage(GUIResource.getInstance().getImageSearchSmall());\r\n\t\t    goSearch.setToolTipText(BaseMessages.getString(PKG, \"EnterSelectionDialog.refresh.Label\"));\r\n\r\n\t      goSearch.addSelectionListener(new SelectionAdapter() {\r\n          public void widgetSelected(SelectionEvent event) {\r\n            updateFilter();\r\n          }});\t\t    \r\n\t\t    \r\n\t    if(this.databasesInterface != null) {\r\n  \t    addConnection = new ToolItem(treeTb,SWT.PUSH);\r\n  \t    addConnection.setImage(GUIResource.getInstance().getImageAdd());\r\n  \t    addConnection.setToolTipText(BaseMessages.getString(PKG, \"Add.Datasource.Label\"));\r\n  \t    \r\n  \t    addConnection.addSelectionListener(new SelectionAdapter() {\r\n  \t          public void widgetSelected(SelectionEvent event) {\r\n  \t            addDataSource();\r\n  \t          }});  \r\n\t    }\r\n\t\t    \r\n\t        FormData fd=new FormData();\r\n\t        fd.right = new FormAttachment(100, -margin);\r\n\t        fd.top  = new FormAttachment(0, margin);\r\n\t\t\ttreeTb.setLayoutData(fd);\r\n\t\t\t\r\n\t\t\t searchText.addSelectionListener(new SelectionAdapter() {\r\n\t\t\t\t public void widgetDefaultSelected(SelectionEvent e) { updateFilter(); } });\r\n\t\r\n\t\r\n\t\t\t// From step line\r\n\t\t\twlSelection=new Label(shell, SWT.NONE);\r\n\t\t\twlSelection.setText(lineText);\r\n\t \t\tprops.setLook(wlSelection);\r\n\t\t\tfdlSelection=new FormData();\r\n\t\t\tfdlSelection.left = new FormAttachment(0, 0);\r\n\t\t\tfdlSelection.top  = new FormAttachment(treeTb, margin);\r\n\t\t\twlSelection.setLayoutData(fdlSelection);\r\n\t\t}else{\r\n\t\t\t// From step line\r\n\t\t\twlSelection=new Label(shell, SWT.NONE);\r\n\t\t\twlSelection.setText(lineText);\r\n\t \t\tprops.setLook(wlSelection);\r\n\t\t\tfdlSelection=new FormData();\r\n\t\t\tfdlSelection.left = new FormAttachment(0, 0);\r\n\t\t\twlSelection.setLayoutData(fdlSelection);\r\n\t\t}\n        \n        int options = SWT.LEFT | SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL;\n        if (multi) options|=SWT.MULTI; else options|=SWT.SINGLE;  \n        \r\n\t\twSelection=new List(shell, options );\r\n\t\tfor (int i=0;i<choices.length;i++) wSelection.add(choices[i]);\r\n\t\tif (selectedNrs!=null)\r\n\t\t{\r\n\t\t\twSelection.select(selectedNrs);\r\n\t\t\twSelection.showSelection();\r\n\t\t}\n        if (fixed)\n        {\n            props.setLook(wSelection, Props.WIDGET_STYLE_FIXED);\n        }\n        else\n        {\r\n            props.setLook(wSelection);\n        }\r\n\t\t\r\n\r\n\t\t// Some buttons\r\n\t\twOK=new Button(shell, SWT.PUSH);\r\n\t\tif (viewOnly) \r\n\t\t{\r\n\t\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.Close\"));\r\n\t\t} \r\n\t\telse\r\n\t\t{\r\n\t\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\r\n\t\t}\r\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\r\n\t\twOK.addListener    (SWT.Selection, lsOK     );\n        \n        Button[] buttons = new Button[] { wOK };\r\n\t\t\r\n\t\tif (!viewOnly)\r\n\t\t{\r\n\t\t\twCancel=new Button(shell, SWT.PUSH);\r\n\t\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\r\n\t\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\r\n\t\t\twCancel.addListener(SWT.Selection, lsCancel );\n            \n            buttons = new Button[] { wOK, wCancel };\n\t\t}\n        \n        BaseStepDialog.positionBottomButtons(shell, buttons, margin, null);\r\n\n        fdSelection=new FormData();\n        fdSelection.left = new FormAttachment(0, 0);\n        fdSelection.right= new FormAttachment(100, 0);\n        fdSelection.top  = new FormAttachment(wlSelection, margin);\n        fdSelection.bottom= new FormAttachment(wOK, -margin*3);\n        wSelection.setLayoutData(fdSelection);\n        \r\n\t\t// Add listeners\r\n\t\t\r\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\r\n\t\twSelection.addSelectionListener(lsDef);\r\n\t\twSelection.addKeyListener(new KeyAdapter() \r\n\t\t\t{\r\n\t\t\t\tpublic void keyPressed(KeyEvent e) \r\n\t\t\t\t{\r\n\t\t\t\t\tif (e.character == SWT.CR) ok();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t// Detect [X] or ALT-F4 or something that kills this window...\r\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\r\n\r\n\t\tgetData();\r\n\t\t\r\n\t\tBaseStepDialog.setSize(shell);\n\t\t\r\n\t\twOK.setFocus();\r\n\t\t\r\n\t\tshell.open();\n\t\t\r\n\t\twhile (!shell.isDisposed())\r\n\t\t{\r\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\r\n\t\t}\r\n\t\treturn selection;\r\n\t}","commit_id":"527421328657f5130087c1c3053543790d6a2c8e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(@Nullable Project project) {\n    if (project != null) {\n      for (VcsDescriptor descriptor : ProjectLevelVcsManager.getInstance(project).getAllVcss()) {\n        if (\"Git\".equals(descriptor.getDisplayName())) {\n          return Collections.unmodifiableCollection(Arrays.asList(\n            option(project, \"Git: Commit automatically on cherry-pick\", \"isAutoCommitOnCherryPick\", \"setAutoCommitOnCherryPick\"),\n            option(project, \"Git: Auto-update if push of the current branch was rejected\", \"autoUpdateIfPushRejected\", \"setAutoUpdateIfPushRejected\"),\n            option(project, \"Git: Warn if CRLF line separators are about to be committed\", \"warnAboutCrlf\", \"setWarnAboutCrlf\"),\n            option(project, \"Git: Warn when committing in detached HEAD or during rebase\", \"warnAboutDetachedHead\", \"setWarnAboutDetachedHead\")));\n        }\n      }\n    }\n    return Collections.emptyList();\n  }","id":87034,"modified_method":"@NotNull\n  @Override\n  public Collection<BooleanOptionDescription> getOptions(@Nullable Project project) {\n    if (project != null) {\n      for (VcsDescriptor descriptor : ProjectLevelVcsManager.getInstance(project).getAllVcss()) {\n        if (\"Git\".equals(descriptor.getDisplayName())) {\n          final GitVcsSettings settings = GitVcsSettings.getInstance(project);\n          ArrayList<BooleanOptionDescription> options = new ArrayList<BooleanOptionDescription>();\n          options.add(option(project, \"Git: Commit automatically on cherry-pick\", \"isAutoCommitOnCherryPick\", \"setAutoCommitOnCherryPick\"));\n          options.add(option(project, \"Git: Auto-update if push of the current branch was rejected\", \"autoUpdateIfPushRejected\", \"setAutoUpdateIfPushRejected\"));\n          GitRepositoryManager manager = ServiceManager.getService(project, GitRepositoryManager.class);\n          if (manager != null && manager.moreThanOneRoot()) {\n            options.add(new BooleanOptionDescription(\"Git: Control repositories synchronously\", \"vcs.Git\") {\n              @Override\n              public boolean isOptionEnabled() {\n                return settings.getSyncSetting() == DvcsSyncSettings.Value.SYNC;\n              }\n\n              @Override\n              public void setOptionState(boolean enabled) {\n                settings.setSyncSetting(enabled ? DvcsSyncSettings.Value.SYNC : DvcsSyncSettings.Value.DONT_SYNC);\n              }\n            });\n          }\n          options.add(option(project, \"Git: Warn if CRLF line separators are about to be committed\", \"warnAboutCrlf\", \"setWarnAboutCrlf\"));\n          options.add(option(project, \"Git: Warn when committing in detached HEAD or during rebase\", \"warnAboutDetachedHead\", \"setWarnAboutDetachedHead\"));\n          options.add(option(project, \"Git: Allow force push\", \"isForcePushAllowed\", \"setForcePushAllowed\"));\n          return Collections.unmodifiableCollection(options);\n        }\n      }\n    }\n    return Collections.emptyList();\n  }","commit_id":"04bea33a04dd2de07d9e2e0088b6d0e2205dc60c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Decodes parameters object from the provided url fragment\n\t * \n\t * @param urlFragment\n\t * @return Parameters created from the url fragment\n\t */\n\tprotected ValueMap decodeParameters(String urlFragment)\n\t{\n\t\t// Hack off any leading slash\n\t\tif (urlFragment.startsWith(\"/\"))\n\t\t{\n\t\t\turlFragment = urlFragment.substring(1);\n\t\t}\n\n\t\tif (urlFragment.length() == 0)\n\t\t{\n\t\t\treturn new ValueMap();\n\t\t}\n\n\t\t// Split into pairs\n\t\tfinal String[] pairs = urlFragment.split(\"/\");\n\n\t\t// If we don't have an even number of pairs\n\t\tif (pairs.length % 2 != 0)\n\t\t{\n\t\t\t// give up\n\t\t\tthrow new IllegalStateException(\"URL fragment has unmatched key/value \" +\n        \"pair: \" + urlFragment);\n\t\t}\n\n\t\t// Loop through pairs\n\t\t\n\t\tValueMap parameters = new ValueMap();\n\t\tfor (int i = 0; i < pairs.length; i += 2)\n\t\t{\n\t\t\tString value = pairs[i + 1];\n\t\t\tvalue = urlDecode(value);\n\t\t\tparameters.add(pairs[i], value);\n\t\t}\n\t\treturn parameters;\n\t}","id":87035,"modified_method":"/**\n\t * Decodes parameters object from the provided url fragment\n\t * \n\t * @param urlFragment\n\t *            fragment of the url after the decoded path and before the\n\t *            query string\n\t * @param urlParameters\n\t *            query string parameters\n\t * @return Parameters created from the url fragment and query string\n\t */\n\tprotected ValueMap decodeParameters(String urlFragment, Map urlParameters)\n\t{\n\t\t// Hack off any leading slash\n\t\tif (urlFragment.startsWith(\"/\"))\n\t\t{\n\t\t\turlFragment = urlFragment.substring(1);\n\t\t}\n\n\t\tif (urlFragment.length() == 0)\n\t\t{\n\t\t\treturn new ValueMap();\n\t\t}\n\n\t\t// Split into pairs\n\t\tfinal String[] pairs = urlFragment.split(\"/\");\n\n\t\t// If we don't have an even number of pairs\n\t\tif (pairs.length % 2 != 0)\n\t\t{\n\t\t\t// give up\n\t\t\tthrow new IllegalStateException(\"URL fragment has unmatched key/value \" + \"pair: \"\n\t\t\t\t\t+ urlFragment);\n\t\t}\n\n\t\t// Loop through pairs\n\n\t\tValueMap parameters = new ValueMap();\n\t\tfor (int i = 0; i < pairs.length; i += 2)\n\t\t{\n\t\t\tString value = pairs[i + 1];\n\t\t\tvalue = urlDecode(value);\n\t\t\tparameters.add(pairs[i], value);\n\t\t}\n\n\n\t\tif (urlParameters != null)\n\t\t{\n\t\t\tparameters.putAll(urlParameters);\n\t\t}\n\n\t\treturn parameters;\n\t}","commit_id":"74850d787eafba4414e457d3189dd0d3ffa7cf90","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(getMountPath().length());\n\t\tfinal PageParameters parameters = new PageParameters(decodeParameters(parametersFragment));\n\n\t\t// Merge with query-string arguments\n\t\tparameters.putAll(requestParameters.getParameters());\n\n\t\tfinal String pageMapName = parameters.getString(\"wicket:pageMapName\");\n\t\tfinal BookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(pageMapName,\n\t\t\t\tbookmarkablePageClass, parameters);\n\t\treturn target;\n\t}","id":87036,"modified_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(getMountPath().length());\n\t\tfinal PageParameters parameters = new PageParameters(decodeParameters(parametersFragment, requestParameters.getParameters()));\n\n\t\tfinal String pageMapName = parameters.getString(\"wicket:pageMapName\");\n\t\tfinal BookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(pageMapName,\n\t\t\t\tbookmarkablePageClass, parameters);\n\t\treturn target;\n\t}","commit_id":"74850d787eafba4414e457d3189dd0d3ffa7cf90","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\t\tString remainder = requestParameters.getPath().substring(getMountPath().length());\n\t\tfinal String parametersFragment;\n\t\tint ix = remainder.indexOf('/', 1);\n\t\tif (ix == -1)\n\t\t{\n\t\t\tix = remainder.length();\n\t\t\tparametersFragment = \"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparametersFragment = remainder.substring(ix);\n\t\t}\n\t\t\n\t\tif (remainder.startsWith(\"/\")) {\n\t\t\tremainder=remainder.substring(1);\n\t\t\tix--;\n\t\t}\n\t\t\n\t\tfinal String bookmarkablePageClassName = packageName + \".\"+ remainder.substring(0, ix);\n\t\tClass bookmarkablePageClass = Session.get().getClassResolver().resolveClass(\n\t\t\t\tbookmarkablePageClassName);\n\t\tPageParameters parameters = new PageParameters(decodeParameters(parametersFragment));\n\n\t\t// Merge with query-string arguments\n\t\tparameters.putAll(requestParameters.getParameters());\n\n\t\tBookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(\n\t\t\t\tbookmarkablePageClass, parameters);\n\t\treturn target;\n\t}","id":87037,"modified_method":"/**\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\n\t{\n\t\tString remainder = requestParameters.getPath().substring(getMountPath().length());\n\t\tfinal String parametersFragment;\n\t\tint ix = remainder.indexOf('/', 1);\n\t\tif (ix == -1)\n\t\t{\n\t\t\tix = remainder.length();\n\t\t\tparametersFragment = \"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparametersFragment = remainder.substring(ix);\n\t\t}\n\t\t\n\t\tif (remainder.startsWith(\"/\")) {\n\t\t\tremainder=remainder.substring(1);\n\t\t\tix--;\n\t\t}\n\t\t\n\t\tfinal String bookmarkablePageClassName = packageName + \".\"+ remainder.substring(0, ix);\n\t\tClass bookmarkablePageClass = Session.get().getClassResolver().resolveClass(\n\t\t\t\tbookmarkablePageClassName);\n\t\tPageParameters parameters = new PageParameters(decodeParameters(parametersFragment, requestParameters.getParameters()));\n\n\t\tBookmarkablePageRequestTarget target = new BookmarkablePageRequestTarget(\n\t\t\t\tbookmarkablePageClass, parameters);\n\t\treturn target;\n\t}","commit_id":"74850d787eafba4414e457d3189dd0d3ffa7cf90","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\r\n\t */\r\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\r\n\t{\r\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(\r\n\t\t\t\tgetMountPath().length());\r\n\t\tfinal ValueMap parameters = decodeParameters(parametersFragment);\r\n\r\n\t\t// Merge with query-string arguments\r\n\t\tparameters.putAll(requestParameters.getParameters());\r\n\r\n\t\trequestParameters.setParameters(parameters);\r\n\t\trequestParameters.setResourceKey(resourceKey);\r\n\t\treturn new SharedResourceRequestTarget(requestParameters);\r\n\t}","id":87038,"modified_method":"/**\r\n\t * @see wicket.request.target.coding.IRequestTargetUrlCodingStrategy#decode(wicket.request.RequestParameters)\r\n\t */\r\n\tpublic IRequestTarget decode(RequestParameters requestParameters)\r\n\t{\r\n\t\tfinal String parametersFragment = requestParameters.getPath().substring(\r\n\t\t\t\tgetMountPath().length());\r\n\t\tfinal ValueMap parameters = decodeParameters(parametersFragment, requestParameters.getParameters());\r\n\r\n\t\trequestParameters.setParameters(parameters);\r\n\t\trequestParameters.setResourceKey(resourceKey);\r\n\t\treturn new SharedResourceRequestTarget(requestParameters);\r\n\t}","commit_id":"74850d787eafba4414e457d3189dd0d3ffa7cf90","url":"https://github.com/apache/wicket"},{"original_method":"protected void buildAnyCategoriesSQL(long[] categoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\tList<Long> categoryIdArray = new ArrayList<Long>();\n\n\t\t\tfor (long categoryId : categoryIds) {\n\t\t\t\tcategoryIdArray.addAll(\n\t\t\t\t\tAssetCategoryFinderUtil.getTreeCategoryIds(categoryId));\n\t\t\t}\n\n\t\t\tcategoryIds = new long[categoryIdArray.size()];\n\n\t\t\tfor (int i = 0; i < categoryIdArray.size(); i++) {\n\t\t\t\tcategoryIds[i] = categoryIdArray.get(i);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\" AND (\");\n\n\t\tString categoryIdsString = StringUtil.merge(categoryIds);\n\n\t\tsql = StringUtil.replace(sql, \"[$CATEGORY_IDS$]\", categoryIdsString);\n\n\t\tsb.append(sql);\n\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","id":87039,"modified_method":"protected void buildAnyCategoriesSQL(long[] categoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tsb.append(\" AND (\");\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tString categoryIdsString = null;\n\n\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\tList<Long> categoryIdsList = new ArrayList<Long>();\n\n\t\t\tfor (long categoryId : categoryIds) {\n\t\t\t\tcategoryIdsList.addAll(\n\t\t\t\t\tAssetCategoryFinderUtil.findByG_L(categoryId));\n\t\t\t}\n\n\t\t\tcategoryIdsString = StringUtil.merge(categoryIdsList);\n\t\t}\n\t\telse {\n\t\t\tcategoryIdsString = StringUtil.merge(categoryIds);\n\t\t}\n\n\t\tsb.append(\n\t\t\tStringUtil.replace(sql, \"[$CATEGORY_ID$]\", categoryIdsString));\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","commit_id":"5467b6d51dbc45611dc8c9156551f0ecb78de244","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void buildNotAllCategoriesSQL(\n\t\t\tlong[] categoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tsb.append(\" AND (\");\n\n\t\tfor (int i = 0; i < categoryIds.length; i++) {\n\t\t\tsb.append(\"NOT \");\n\n\t\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\t\tList<Long> treeCategoryIdArray =\n\t\t\t\t\tAssetCategoryFinderUtil.getTreeCategoryIds(categoryIds[i]);\n\n\t\t\t\tif (treeCategoryIdArray.size() > 1) {\n\t\t\t\t\tlong[] treeCategoryIds =\n\t\t\t\t\t\tnew long[treeCategoryIdArray.size()];\n\n\t\t\t\t\tfor (int j = 0; j < treeCategoryIdArray.size(); j++) {\n\t\t\t\t\t\ttreeCategoryIds[j] = treeCategoryIdArray.get(j);\n\t\t\t\t\t}\n\n\t\t\t\t\tString categoryIdsString = StringUtil.merge(\n\t\t\t\t\t\ttreeCategoryIds);\n\n\t\t\t\t\tString tempSQL = StringUtil.replace(\n\t\t\t\t\t\tsql, \"[$CATEGORY_IDS$]\", categoryIdsString);\n\n\t\t\t\t\tsb.append(tempSQL);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString tempSQL = StringUtil.replace(\n\t\t\t\tsql, \"IN ([$CATEGORY_IDS$])\",\n\t\t\t\t\"= \".concat(String.valueOf(categoryIds[i])));\n\n\t\t\tsb.append(tempSQL);\n\n\t\t\tif ((i + 1) < categoryIds.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t}\n\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","id":87040,"modified_method":"protected void buildNotAllCategoriesSQL(\n\t\t\tlong[] categoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tsb.append(\" AND (\");\n\n\t\tfor (int i = 0; i < categoryIds.length; i++) {\n\t\t\tsb.append(\"NOT \");\n\n\t\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\t\tList<Long> treeCategoryIds = AssetCategoryFinderUtil.findByG_L(\n\t\t\t\t\tcategoryIds[i]);\n\n\t\t\t\tif (treeCategoryIds.size() > 1) {\n\t\t\t\t\tsb.append(\n\t\t\t\t\t\tStringUtil.replace(\n\t\t\t\t\t\t\tsql, \"[$CATEGORY_ID$]\",\n\t\t\t\t\t\t\tStringUtil.merge(treeCategoryIds)));\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.append(\n\t\t\t\tStringUtil.replace(\n\t\t\t\t\tsql, \" IN ([$CATEGORY_ID$])\", \" = \" + categoryIds[i]));\n\n\t\t\tif ((i + 1) < categoryIds.length) {\n\t\t\t\tsb.append(\" OR \");\n\t\t\t}\n\t\t}\n\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","commit_id":"5467b6d51dbc45611dc8c9156551f0ecb78de244","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void buildNotAnyCategoriesSQL(\n\t\t\tlong[] notCategoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tif (notCategoryIds.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tlong[] categoryIds = notCategoryIds;\n\n\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\tList<Long> categoryIdArray = new ArrayList<Long>();\n\n\t\t\tfor (long categoryId : notCategoryIds) {\n\t\t\t\tcategoryIdArray.addAll(\n\t\t\t\t\tAssetCategoryFinderUtil.getTreeCategoryIds(categoryId));\n\t\t\t}\n\n\t\t\tcategoryIds = new long[categoryIdArray.size()];\n\n\t\t\tfor (int i = 0; i < categoryIdArray.size(); i++) {\n\t\t\t\tcategoryIds[i] = categoryIdArray.get(i);\n\t\t\t}\n\t\t}\n\n\t\tsb.append(\" AND (NOT \");\n\n\t\tString categoryIdsString = StringUtil.merge(categoryIds);\n\n\t\tsql = StringUtil.replace(sql, \"[$CATEGORY_IDS$]\", categoryIdsString);\n\n\t\tsb.append(sql);\n\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","id":87041,"modified_method":"protected void buildNotAnyCategoriesSQL(\n\t\t\tlong[] notCategoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tif (notCategoryIds.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tsb.append(\" AND (NOT \");\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tString notCategoryIdsString = null;\n\n\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\tList<Long> notCategoryIdsList = new ArrayList<Long>();\n\n\t\t\tfor (long notCategoryId : notCategoryIds) {\n\t\t\t\tnotCategoryIdsList.addAll(\n\t\t\t\t\tAssetCategoryFinderUtil.findByG_L(notCategoryId));\n\t\t\t}\n\n\t\t\tnotCategoryIdsString = StringUtil.merge(notCategoryIdsList);\n\t\t}\n\t\telse {\n\t\t\tnotCategoryIdsString = StringUtil.merge(notCategoryIds);\n\t\t}\n\n\t\tsb.append(\n\t\t\tStringUtil.replace(sql, \"[$CATEGORY_ID$]\", notCategoryIdsString));\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","commit_id":"5467b6d51dbc45611dc8c9156551f0ecb78de244","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void buildAllCategoriesSQL(long[] categoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tsb.append(\" AND (\");\n\n\t\tfor (int i = 0; i < categoryIds.length; i++) {\n\t\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\t\tList<Long> treeCategoryIdArray =\n\t\t\t\t\tAssetCategoryFinderUtil.getTreeCategoryIds(categoryIds[i]);\n\n\t\t\t\tif (treeCategoryIdArray.size() > 1) {\n\t\t\t\t\tlong[] treeCategoryIds =\n\t\t\t\t\t\tnew long[treeCategoryIdArray.size()];\n\n\t\t\t\t\tfor (int j = 0; j < treeCategoryIdArray.size(); j++) {\n\t\t\t\t\t\ttreeCategoryIds[j] = treeCategoryIdArray.get(j);\n\t\t\t\t\t}\n\n\t\t\t\t\tString categoryIdsString = StringUtil.merge(\n\t\t\t\t\t\ttreeCategoryIds);\n\n\t\t\t\t\tString tempSQL = StringUtil.replace(\n\t\t\t\t\t\tsql, \"[$CATEGORY_IDS$]\", categoryIdsString);\n\n\t\t\t\t\tsb.append(tempSQL);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString tempSQL = StringUtil.replace(\n\t\t\t\tsql, \"IN ([$CATEGORY_IDS$])\",\n\t\t\t\t\"= \".concat(String.valueOf(categoryIds[i])));\n\n\t\t\tsb.append(tempSQL);\n\n\t\t\tif ((i + 1) < categoryIds.length) {\n\t\t\t\tsb.append(\" AND \");\n\t\t\t}\n\t\t}\n\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","id":87042,"modified_method":"protected void buildAllCategoriesSQL(long[] categoryIds, StringBundler sb)\n\t\tthrows SystemException {\n\n\t\tString sql = CustomSQLUtil.get(FIND_BY_AND_CATEGORY_IDS);\n\n\t\tsb.append(\" AND (\");\n\n\t\tfor (int i = 0; i < categoryIds.length; i++) {\n\t\t\tif (PropsValues.ASSET_CATEGORIES_SEARCH_HIERARCHICAL) {\n\t\t\t\tList<Long> treeCategoryIds = AssetCategoryFinderUtil.findByG_L(\n\t\t\t\t\tcategoryIds[i]);\n\n\t\t\t\tif (treeCategoryIds.size() > 1) {\n\t\t\t\t\tsb.append(\n\t\t\t\t\t\tStringUtil.replace(\n\t\t\t\t\t\t\tsql, \"[$CATEGORY_ID$]\",\n\t\t\t\t\t\t\tStringUtil.merge(treeCategoryIds)));\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsb.append(\n\t\t\t\tStringUtil.replace(\n\t\t\t\t\tsql, \" IN ([$CATEGORY_ID$])\", \" = \" + categoryIds[i]));\n\n\t\t\tif ((i + 1) < categoryIds.length) {\n\t\t\t\tsb.append(\" AND \");\n\t\t\t}\n\t\t}\n\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t}","commit_id":"5467b6d51dbc45611dc8c9156551f0ecb78de244","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString tabs1 = ParamUtil.getString(req, \"tabs1\");\n\n\t\tif (tabs1.equals(\"forward-address\")) {\n\t\t\tString[] forwardAddressArray = StringUtil.split(\n\t\t\t\tParamUtil.getString(req, \"forwardAddress\"), \"\\n\");\n\n\t\t\tList forwardAddressList = new ArrayList();\n\n\t\t\tfor (int i = 0; i < forwardAddressArray.length; i++) {\n\t\t\t\tif (Validator.isEmailAddress(forwardAddressArray[i])) {\n\t\t\t\t\tforwardAddressList.add(forwardAddressArray[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (forwardAddressList.size() > 0) {\n\t\t\t\tprefs.setValue(\n\t\t\t\t\t\"forward-address\",\n\t\t\t\t\tStringUtil.merge(forwardAddressArray, StringPool.SPACE));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprefs.setValue(\"forward-address\", StringPool.BLANK);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMailServiceUtil.addForward(\n\t\t\t\t\treq.getRemoteUser(), forwardAddressList);\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tthrow new PortletException(se);\n\t\t\t}\n\t\t}\n\t\telse if (tabs1.equals(\"signature\")) {\n\t\t\tString signature = ParamUtil.getString(req, \"signature\");\n\n\t\t\tprefs.setValue(\"signature\", signature);\n\t\t}\n\t\telse if (tabs1.equals(\"vacation-message\")) {\n\t\t\tString vacationMessage = ParamUtil.getString(\n\t\t\t\treq, \"vacationMessage\");\n\n\t\t\tprefs.setValue(\"vacation-message\", vacationMessage);\n\n\t\t\ttry {\n\t\t\t\tUser user = PortalUtil.getUser(req);\n\n\t\t\t\tMailServiceUtil.addVacationMessage(\n\t\t\t\t\tuser.getUserId(), user.getEmailAddress(), vacationMessage);\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tthrow new PortletException(se);\n\t\t\t}\n\t\t}\n\n\t\tprefs.store();\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doEdit\");\n\t}","id":87043,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig config,\n\t\t\tActionRequest req, ActionResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\tif (!cmd.equals(Constants.UPDATE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences prefs = req.getPreferences();\n\n\t\tString tabs1 = ParamUtil.getString(req, \"tabs1\");\n\n\t\tif (tabs1.equals(\"forward-address\")) {\n\t\t\tString forwardAddress = ParamUtil.getString(req, \"forwardAddress\");\n\n\t\t\tString[] forwardAddressArray = StringUtil.split(\n\t\t\t\tforwardAddress, \"\\n\");\n\n\t\t\tList forwardAddressList = new ArrayList();\n\n\t\t\tfor (int i = 0; i < forwardAddressArray.length; i++) {\n\t\t\t\tif (Validator.isEmailAddress(forwardAddressArray[i])) {\n\t\t\t\t\tforwardAddressList.add(forwardAddressArray[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (forwardAddressList.size() > 0) {\n\t\t\t\tforwardAddressArray =\n\t\t\t\t\t(String[])forwardAddressList.toArray(new String[0]);\n\n\t\t\t\tforwardAddress = StringUtil.merge(\n\t\t\t\t\tforwardAddressArray, StringPool.SPACE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tforwardAddress = StringPool.BLANK;\n\t\t\t}\n\n\t\t\tprefs.setValue(\"forward-address\", forwardAddress);\n\n\t\t\tres.setRenderParameter(\"forwardAddress\", forwardAddress);\n\n\t\t\ttry {\n\t\t\t\tMailServiceUtil.addForward(\n\t\t\t\t\treq.getRemoteUser(), forwardAddressList);\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tthrow new PortletException(se);\n\t\t\t}\n\t\t}\n\t\telse if (tabs1.equals(\"signature\")) {\n\t\t\tString signature = ParamUtil.getString(req, \"signature\");\n\n\t\t\tprefs.setValue(\"signature\", signature);\n\t\t}\n\t\telse if (tabs1.equals(\"vacation-message\")) {\n\t\t\tString vacationMessage = ParamUtil.getString(\n\t\t\t\treq, \"vacationMessage\");\n\n\t\t\tprefs.setValue(\"vacation-message\", vacationMessage);\n\n\t\t\ttry {\n\t\t\t\tUser user = PortalUtil.getUser(req);\n\n\t\t\t\tMailServiceUtil.addVacationMessage(\n\t\t\t\t\tuser.getUserId(), user.getEmailAddress(), vacationMessage);\n\t\t\t}\n\t\t\tcatch (SystemException se) {\n\t\t\t\tthrow new PortletException(se);\n\t\t\t}\n\t\t}\n\n\t\tprefs.store();\n\n\t\tSessionMessages.add(req, config.getPortletName() + \".doEdit\");\n\t}","commit_id":"b26ca154effc6f18bef3475eb314f259bf228822","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SetReference<PrivateNetworkIndex, VmInstance> allocateNetworkIndex( ) throws TransactionException {\n    EntityTransaction db = Entities.get( ExtantNetwork.class );\n    SetReference<PrivateNetworkIndex, VmInstance> ref;\n    try {\n      ref = null;\n      if ( this.getIndexes( ).isEmpty( ) ) {\n        for ( long i = NetworkGroups.networkingConfiguration( ).getMinNetworkIndex( ); i < NetworkGroups.networkingConfiguration( ).getMaxNetworkIndex( ); i++ ) {\n          PrivateNetworkIndex newIdx = PrivateNetworkIndex.create( this, i );\n          PrivateNetworkIndex netIdx = Entities.persist( newIdx );\n          this.getIndexes( ).add( netIdx );\n        }\n        Entities.merge( this );\n      }\n      for ( PrivateNetworkIndex idx : Iterables.filter( this.getIndexes( ), PrivateNetworkIndex.filterFree( ) ) ) {\n        try {\n          ref = idx.allocate( );\n          break;\n        } catch ( Exception ex1 ) {\n          continue;\n        }\n      }\n      Entities.merge( this );\n      if ( ref != null ) {\n        db.commit( );\n        return ref;\n      } else {\n        db.rollback( );\n        throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName );\n      }\n    } catch ( TransactionException ex ) {\n      throw ex;\n    } catch ( Exception ex ) {\n      throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName, ex );\n    }\n  }","id":87044,"modified_method":"public SetReference<PrivateNetworkIndex, VmInstance> allocateNetworkIndex( ) throws TransactionException {\n    EntityTransaction db = Entities.get( ExtantNetwork.class );\n    SetReference<PrivateNetworkIndex, VmInstance> ref = null;\n    try {\n      ExtantNetwork exNet = Entities.merge( this );\n      if ( exNet.getIndexes( ).isEmpty( ) ) {\n        for ( long i = NetworkGroups.networkingConfiguration( ).getMinNetworkIndex( ); i < NetworkGroups.networkingConfiguration( ).getMaxNetworkIndex( ); i++ ) {\n          PrivateNetworkIndex newIdx = PrivateNetworkIndex.create( exNet, i );\n          exNet.getIndexes( ).add( newIdx );\n          PrivateNetworkIndex netIdx = Entities.persist( newIdx );\n        }\n        Entities.merge( exNet );\n      }\n      for ( PrivateNetworkIndex idx : Iterables.filter( exNet.getIndexes( ), PrivateNetworkIndex.filterFree( ) ) ) {\n        try {\n          ref = idx.allocate( );\n          break;\n        } catch ( Exception ex1 ) {\n          continue;\n        }\n      }\n      Entities.merge( this );\n      if ( ref != null ) {\n        db.commit( );\n        return ref;\n      } else {\n        db.rollback( );\n        throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName );\n      }\n    } catch ( TransactionException ex ) {\n      throw ex;\n    } catch ( Exception ex ) {\n      throw new TransactionExecutionException( \"Failed to allocate a private network index in network: \" + this.displayName, ex );\n    }\n  }","commit_id":"fdf0cbcc8d1828c88129cb42007310cfd6db9f6e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private ExtantNetwork attemptNetworkTagging( ) throws NotEnoughResourcesException {\n    for ( Integer i : Numbers.shuffled( NetworkGroups.networkTagInterval( ) ) ) {\n      try {\n        Entities.uniqueResult( ExtantNetwork.named( i ) );\n        continue;\n      } catch ( Exception ex ) {\n        try {\n          this.setExtantNetwork( Entities.persist( ExtantNetwork.create( this, i ) ) );\n          Entities.merge( this );\n          return this.getExtantNetwork( );\n        } catch ( Exception ex1 ) {\n          Logs.exhaust( ).trace( ex1, ex1 );\n          throw new NotEnoughResourcesException( \"Failed to allocate network tag for network: \" + this.getFullName( ), ex1 );\n        }\n      }\n    }\n    throw new NotEnoughResourcesException( \"Failed to allocate network tag for network: \" + this.getFullName( ) + \": no network tags are free.\" );\n  }","id":87045,"modified_method":"private ExtantNetwork attemptNetworkTagging( ) throws NotEnoughResourcesException {\n    for ( Integer i : Numbers.shuffled( NetworkGroups.networkTagInterval( ) ) ) {\n      try {\n        Entities.uniqueResult( ExtantNetwork.named( i ) );\n        continue;\n      } catch ( Exception ex ) {\n        try {\n          ExtantNetwork exNet = ExtantNetwork.create( this, i );\n          exNet.setNetworkGroup( this );\n          this.setExtantNetwork( exNet );\n          Entities.persist( exNet );\n          return Entities.merge( this ).extantNetwork;\n        } catch ( Exception ex1 ) {\n          Logs.exhaust( ).trace( ex1, ex1 );\n          throw new NotEnoughResourcesException( \"Failed to allocate network tag for network: \" + this.getFullName( ), ex1 );\n        }\n      }\n    }\n    throw new NotEnoughResourcesException( \"Failed to allocate network tag for network: \" + this.getFullName( ) + \": no network tags are free.\" );\n  }","commit_id":"fdf0cbcc8d1828c88129cb42007310cfd6db9f6e","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@AfterMethod(alwaysRun=true)\n    public void tearDown() throws Exception {\n        managementContext.terminate();\n        if (mementoDir != null) RebindTestUtils.deleteMementoDir(mementoDir);\n    }","id":87046,"modified_method":"@AfterMethod(alwaysRun=true)\n    public void tearDown() throws Exception {\n        if (managementContext != null) managementContext.terminate();\n        if (mementoDir != null) RebindTestUtils.deleteMementoDir(mementoDir);\n    }","commit_id":"1b9937be2b1b46df2ae26b0c2f698aad587d5db5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  public void terminate() {\n    if (monitor != null) {\n      Logger logger = LoggerFactory.getLogger(getClass());\n      logger.info(\"Shutting down server\");\n      monitor.interrupt();\n      monitor = null;\n      elasticsearch.terminate();\n      server.terminate();\n    }\n  }","id":87047,"modified_method":"@Override\n  public void terminate() {\n    if (monitor != null) {\n      Logger logger = LoggerFactory.getLogger(getClass());\n      logger.info(\"Shutting down server\");\n      monitor.interrupt();\n      monitor = null;\n      if (elasticsearch != null) {\n        elasticsearch.terminate();\n      }\n      if (server != null) {\n        server.terminate();\n      }\n    }\n  }","commit_id":"725d5d318527c4f9429889ee7208064e59caafae","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void resubmitTasks(List<Long> taskIds) {\n    hostRoleCommandCache.invalidateAll(taskIds);\n\n    List<HostRoleCommandEntity> tasks = hostRoleCommandDAO.findByPKs(taskIds);\n    for (HostRoleCommandEntity task : tasks) {\n      task.setStatus(HostRoleStatus.PENDING);\n      task.setStartTime(-1L);\n      task.setEndTime(-1L);\n    }\n\n    hostRoleCommandDAO.mergeAll(tasks);\n  }","id":87048,"modified_method":"@Override\n  public void resubmitTasks(List<Long> taskIds) {\n    hostRoleCommandCache.invalidateAll(taskIds);\n\n    List<HostRoleCommandEntity> tasks = hostRoleCommandDAO.findByPKs(taskIds);\n    for (HostRoleCommandEntity task : tasks) {\n      task.setStatus(HostRoleStatus.PENDING);\n      task.setStartTime(-1L);\n      task.setEndTime(-1L);\n    }\n\n    // no need to merge if there's nothing to merge\n    if (!tasks.isEmpty()) {\n      hostRoleCommandDAO.mergeAll(tasks);\n    }\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public void timeoutHostRole(String host, long requestId, long stageId,\n                              String role) {\n    long now = System.currentTimeMillis();\n    List<HostRoleCommandEntity> commands =\n        hostRoleCommandDAO.findByHostRole(host, requestId, stageId, role);\n    for (HostRoleCommandEntity command : commands) {\n      command.setStatus(command.isRetryAllowed() ? HostRoleStatus.HOLDING_TIMEDOUT : HostRoleStatus.TIMEDOUT);\n      command.setEndTime(now);\n    }\n    hostRoleCommandDAO.mergeAll(commands);\n    endRequestIfCompleted(requestId);\n  }","id":87049,"modified_method":"@Override\n  public void timeoutHostRole(String host, long requestId, long stageId,\n                              String role) {\n    long now = System.currentTimeMillis();\n    List<HostRoleCommandEntity> commands =\n        hostRoleCommandDAO.findByHostRole(host, requestId, stageId, role);\n    for (HostRoleCommandEntity command : commands) {\n      command.setStatus(command.isRetryAllowed() ? HostRoleStatus.HOLDING_TIMEDOUT : HostRoleStatus.TIMEDOUT);\n      command.setEndTime(now);\n    }\n\n    // no need to merge if there's nothing to merge\n    if (!commands.isEmpty()) {\n      hostRoleCommandDAO.mergeAll(commands);\n    }\n\n    endRequestIfCompleted(requestId);\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public void updateHostRoleStates(Collection<CommandReport> reports) {\n    Map<Long, CommandReport> taskReports = new HashMap<Long, CommandReport>();\n    for (CommandReport report : reports) {\n      taskReports.put(report.getTaskId(), report);\n    }\n\n    long now = System.currentTimeMillis();\n\n    List<Long> requestsToCheck = new ArrayList<Long>();\n    List<Long> abortedCommandUpdates = new ArrayList<Long>();\n\n    List<HostRoleCommandEntity> commandEntities = hostRoleCommandDAO.findByPKs(taskReports.keySet());\n    for (HostRoleCommandEntity commandEntity : commandEntities) {\n      CommandReport report = taskReports.get(commandEntity.getTaskId());\n\n      switch (commandEntity.getStatus()) {\n        case ABORTED:\n          // We don't want to overwrite statuses for ABORTED tasks with\n          // statuses that have been received from the agent after aborting task\n          abortedCommandUpdates.add(commandEntity.getTaskId());\n          break;\n        default:\n          HostRoleStatus status = HostRoleStatus.valueOf(report.getStatus());\n          // if FAILED and marked for holding then set status = HOLDING_FAILED\n          if (status == HostRoleStatus.FAILED && commandEntity.isRetryAllowed()) {\n            status = HostRoleStatus.HOLDING_FAILED;\n\n            // tasks can be marked as skipped when they fail\n            if (commandEntity.isFailureAutoSkipped()) {\n              status = HostRoleStatus.SKIPPED_FAILED;\n            }\n          }\n\n          commandEntity.setStatus(status);\n          break;\n      }\n\n      commandEntity.setStdOut(report.getStdOut().getBytes());\n      commandEntity.setStdError(report.getStdErr().getBytes());\n      commandEntity.setStructuredOut(report.getStructuredOut() == null ? null :\n        report.getStructuredOut().getBytes());\n      commandEntity.setExitcode(report.getExitCode());\n\n      if (HostRoleStatus.getCompletedStates().contains(commandEntity.getStatus())) {\n        commandEntity.setEndTime(now);\n\n        String actionId = report.getActionId();\n        long[] requestStageIds = StageUtils.getRequestStage(actionId);\n        long requestId = requestStageIds[0];\n        long stageId = requestStageIds[1];\n        if (requestDAO.getLastStageId(requestId).equals(stageId)) {\n          requestsToCheck.add(requestId);\n        }\n      }\n    }\n\n    hostRoleCommandDAO.mergeAll(commandEntities);\n    // Invalidate cache because of updates to ABORTED commands\n    hostRoleCommandCache.invalidateAll(abortedCommandUpdates);\n\n    for (Long requestId : requestsToCheck) {\n      endRequestIfCompleted(requestId);\n    }\n  }","id":87050,"modified_method":"@Override\n  public void updateHostRoleStates(Collection<CommandReport> reports) {\n    Map<Long, CommandReport> taskReports = new HashMap<Long, CommandReport>();\n    for (CommandReport report : reports) {\n      taskReports.put(report.getTaskId(), report);\n    }\n\n    long now = System.currentTimeMillis();\n\n    List<Long> requestsToCheck = new ArrayList<Long>();\n    List<Long> abortedCommandUpdates = new ArrayList<Long>();\n\n    List<HostRoleCommandEntity> commandEntities = hostRoleCommandDAO.findByPKs(taskReports.keySet());\n    for (HostRoleCommandEntity commandEntity : commandEntities) {\n      CommandReport report = taskReports.get(commandEntity.getTaskId());\n\n      switch (commandEntity.getStatus()) {\n        case ABORTED:\n          // We don't want to overwrite statuses for ABORTED tasks with\n          // statuses that have been received from the agent after aborting task\n          abortedCommandUpdates.add(commandEntity.getTaskId());\n          break;\n        default:\n          HostRoleStatus status = HostRoleStatus.valueOf(report.getStatus());\n          // if FAILED and marked for holding then set status = HOLDING_FAILED\n          if (status == HostRoleStatus.FAILED && commandEntity.isRetryAllowed()) {\n            status = HostRoleStatus.HOLDING_FAILED;\n\n            // tasks can be marked as skipped when they fail\n            if (commandEntity.isFailureAutoSkipped()) {\n              status = HostRoleStatus.SKIPPED_FAILED;\n            }\n          }\n\n          commandEntity.setStatus(status);\n          break;\n      }\n\n      commandEntity.setStdOut(report.getStdOut().getBytes());\n      commandEntity.setStdError(report.getStdErr().getBytes());\n      commandEntity.setStructuredOut(report.getStructuredOut() == null ? null :\n        report.getStructuredOut().getBytes());\n      commandEntity.setExitcode(report.getExitCode());\n\n      if (HostRoleStatus.getCompletedStates().contains(commandEntity.getStatus())) {\n        commandEntity.setEndTime(now);\n\n        String actionId = report.getActionId();\n        long[] requestStageIds = StageUtils.getRequestStage(actionId);\n        long requestId = requestStageIds[0];\n        long stageId = requestStageIds[1];\n        if (requestDAO.getLastStageId(requestId).equals(stageId)) {\n          requestsToCheck.add(requestId);\n        }\n      }\n    }\n\n    // no need to merge if there's nothing to merge\n    if (!commandEntities.isEmpty()) {\n      hostRoleCommandDAO.mergeAll(commandEntities);\n    }\n\n    // Invalidate cache because of updates to ABORTED commands\n    hostRoleCommandCache.invalidateAll(abortedCommandUpdates);\n\n    for (Long requestId : requestsToCheck) {\n      endRequestIfCompleted(requestId);\n    }\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public void abortOperation(long requestId) {\n    long now = System.currentTimeMillis();\n\n    endRequest(requestId);\n\n    List<HostRoleCommandEntity> commands =\n        hostRoleCommandDAO.findByRequest(requestId);\n    for (HostRoleCommandEntity command : commands) {\n      if (command.getStatus() == HostRoleStatus.QUEUED ||\n          command.getStatus() == HostRoleStatus.IN_PROGRESS ||\n          command.getStatus() == HostRoleStatus.PENDING) {\n\n        command.setStatus(HostRoleStatus.ABORTED);\n        command.setEndTime(now);\n        LOG.info(\"Aborting command. Hostname \" + command.getHostName()\n            + \" role \" + command.getRole()\n            + \" requestId \" + command.getRequestId()\n            + \" taskId \" + command.getTaskId()\n            + \" stageId \" + command.getStageId());\n      }\n    }\n\n    hostRoleCommandDAO.mergeAll(commands);\n  }","id":87051,"modified_method":"@Override\n  public void abortOperation(long requestId) {\n    long now = System.currentTimeMillis();\n\n    endRequest(requestId);\n\n    List<HostRoleCommandEntity> commands =\n        hostRoleCommandDAO.findByRequest(requestId);\n    for (HostRoleCommandEntity command : commands) {\n      if (command.getStatus() == HostRoleStatus.QUEUED ||\n          command.getStatus() == HostRoleStatus.IN_PROGRESS ||\n          command.getStatus() == HostRoleStatus.PENDING) {\n\n        command.setStatus(HostRoleStatus.ABORTED);\n        command.setEndTime(now);\n        LOG.info(\"Aborting command. Hostname \" + command.getHostName()\n            + \" role \" + command.getRole()\n            + \" requestId \" + command.getRequestId()\n            + \" taskId \" + command.getTaskId()\n            + \" stageId \" + command.getStageId());\n      }\n    }\n\n    // no need to merge if there's nothing to merge\n    if (!commands.isEmpty()) {\n      hostRoleCommandDAO.mergeAll(commands);\n    }\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public void updateHostRoleState(String hostname, long requestId,\n                                  long stageId, String role, CommandReport report) {\n    boolean checkRequest = false;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Update HostRoleState: \"\n        + \"HostName \" + hostname + \" requestId \" + requestId + \" stageId \"\n        + stageId + \" role \" + role + \" report \" + report);\n    }\n\n    long now = System.currentTimeMillis();\n    List<HostRoleCommandEntity> commands = hostRoleCommandDAO.findByHostRole(\n      hostname, requestId, stageId, role);\n\n    for (HostRoleCommandEntity command : commands) {\n      HostRoleStatus status = HostRoleStatus.valueOf(report.getStatus());\n\n      // if FAILED and marked for holding then set status = HOLDING_FAILED\n      if (status == HostRoleStatus.FAILED && command.isRetryAllowed()) {\n        status = HostRoleStatus.HOLDING_FAILED;\n\n        // tasks can be marked as skipped when they fail\n        if (command.isFailureAutoSkipped()) {\n          status = HostRoleStatus.SKIPPED_FAILED;\n        }\n      }\n\n      command.setStatus(status);\n      command.setStdOut(report.getStdOut().getBytes());\n      command.setStdError(report.getStdErr().getBytes());\n      command.setStructuredOut(report.getStructuredOut() == null ? null :\n        report.getStructuredOut().getBytes());\n\n      if (HostRoleStatus.getCompletedStates().contains(command.getStatus())) {\n        command.setEndTime(now);\n        if (requestDAO.getLastStageId(requestId).equals(stageId)) {\n          checkRequest = true;\n        }\n      }\n      command.setExitcode(report.getExitCode());\n    }\n\n    hostRoleCommandDAO.mergeAll(commands);\n\n    if (checkRequest) {\n      endRequestIfCompleted(requestId);\n    }\n  }","id":87052,"modified_method":"@Override\n  public void updateHostRoleState(String hostname, long requestId,\n                                  long stageId, String role, CommandReport report) {\n    boolean checkRequest = false;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Update HostRoleState: \"\n        + \"HostName \" + hostname + \" requestId \" + requestId + \" stageId \"\n        + stageId + \" role \" + role + \" report \" + report);\n    }\n\n    long now = System.currentTimeMillis();\n    List<HostRoleCommandEntity> commands = hostRoleCommandDAO.findByHostRole(\n      hostname, requestId, stageId, role);\n\n    for (HostRoleCommandEntity command : commands) {\n      HostRoleStatus status = HostRoleStatus.valueOf(report.getStatus());\n\n      // if FAILED and marked for holding then set status = HOLDING_FAILED\n      if (status == HostRoleStatus.FAILED && command.isRetryAllowed()) {\n        status = HostRoleStatus.HOLDING_FAILED;\n\n        // tasks can be marked as skipped when they fail\n        if (command.isFailureAutoSkipped()) {\n          status = HostRoleStatus.SKIPPED_FAILED;\n        }\n      }\n\n      command.setStatus(status);\n      command.setStdOut(report.getStdOut().getBytes());\n      command.setStdError(report.getStdErr().getBytes());\n      command.setStructuredOut(report.getStructuredOut() == null ? null :\n        report.getStructuredOut().getBytes());\n\n      if (HostRoleStatus.getCompletedStates().contains(command.getStatus())) {\n        command.setEndTime(now);\n        if (requestDAO.getLastStageId(requestId).equals(stageId)) {\n          checkRequest = true;\n        }\n      }\n      command.setExitcode(report.getExitCode());\n    }\n\n    // no need to merge if there's nothing to merge\n    if (!commands.isEmpty()) {\n      hostRoleCommandDAO.mergeAll(commands);\n    }\n\n    if (checkRequest) {\n      endRequestIfCompleted(requestId);\n    }\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\n    // Should we start a unit of work?\n    if (!emProvider.isWorking()) {\n      emProvider.begin();\n      didWeStartWork.set(true);\n    }\n\n    Transactional transactional = readTransactionMetadata(methodInvocation);\n    EntityManager em = this.emProvider.get();\n\n    // Allow 'joining' of transactions if there is an enclosing @Transactional method.\n    if (em.getTransaction().isActive()) {\n      return methodInvocation.proceed();\n    }\n\n    final EntityTransaction txn = em.getTransaction();\n    txn.begin();\n\n    Object result;\n    try {\n      result = methodInvocation.proceed();\n\n    } catch (Exception e) {\n      //commit transaction only if rollback didn't occur\n      if (rollbackIfNecessary(transactional, e, txn)) {\n        txn.commit();\n      }\n\n      detailedLogForPersistenceError(e);\n\n      //propagate whatever exception is thrown anyway\n      throw e;\n    } finally {\n      // Close the em if necessary (guarded so this code doesn't run unless catch fired).\n      if (null != didWeStartWork.get() && !txn.isActive()) {\n        didWeStartWork.remove();\n        unitOfWork.end();\n      }\n    }\n\n    //everything was normal so commit the txn (do not move into try block above as it\n    //  interferes with the advised method's throwing semantics)\n    try {\n      txn.commit();\n    } catch (Exception e) {\n      detailedLogForPersistenceError(e);\n      throw e;\n    } finally {\n      //close the em if necessary\n      if (null != didWeStartWork.get()) {\n        didWeStartWork.remove();\n        unitOfWork.end();\n      }\n    }\n\n    //or return result\n    return result;\n  }","id":87053,"modified_method":"@Override\n  public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n\n    // Should we start a unit of work?\n    if (!emProvider.isWorking()) {\n      emProvider.begin();\n      didWeStartWork.set(true);\n    }\n\n    Transactional transactional = readTransactionMetadata(methodInvocation);\n    EntityManager em = emProvider.get();\n\n    // Allow 'joining' of transactions if there is an enclosing @Transactional method.\n    if (em.getTransaction().isActive()) {\n      return methodInvocation.proceed();\n    }\n\n    Object result;\n\n    final EntityTransaction txn = em.getTransaction();\n    txn.begin();\n\n    try {\n      result = methodInvocation.proceed();\n\n    } catch (Exception e) {\n      // commit transaction only if rollback didn't occur\n      if (rollbackIfNecessary(transactional, e, txn)) {\n        txn.commit();\n      }\n\n      detailedLogForPersistenceError(e);\n\n      // propagate whatever exception is thrown anyway\n      throw e;\n    } finally {\n      // Close the em if necessary (guarded so this code doesn't run unless\n      // catch fired).\n      if (null != didWeStartWork.get() && !txn.isActive()) {\n        didWeStartWork.remove();\n        unitOfWork.end();\n      }\n    }\n\n    // everything was normal so commit the txn (do not move into try block\n    // above as it\n    // interferes with the advised method's throwing semantics)\n    try {\n      txn.commit();\n    } catch (Exception e) {\n      detailedLogForPersistenceError(e);\n      throw e;\n    } finally {\n      // close the em if necessary\n      if (null != didWeStartWork.get()) {\n        didWeStartWork.remove();\n        unitOfWork.end();\n      }\n    }\n\n    // or return result\n    return result;\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"private <T> void bindFinder(Class<T> iface) {\n    if (!isDynamicFinderValid(iface)) {\n      return;\n    }\n\n    InvocationHandler finderInvoker = new InvocationHandler() {\n      @Inject\n      JpaFinderProxy finderProxy;\n\n      public Object invoke(final Object thisObject, final Method method, final Object[] args)\n          throws Throwable {\n\n        // Don't intercept non-finder methods like equals and hashcode.\n        if (!method.isAnnotationPresent(Finder.class)) {\n          // This is not ideal, we are using the invocation handler's equals\n          // and hashcode as a proxy (!) for the proxy's equals and hashcode.\n          return method.invoke(this, args);\n        }\n\n        return finderProxy.invoke(new MethodInvocation() {\n          public Method getMethod() {\n            return method;\n          }\n\n          public Object[] getArguments() {\n            return null == args ? new Object[0] : args;\n          }\n\n          public Object proceed() throws Throwable {\n            return method.invoke(thisObject, args);\n          }\n\n          public Object getThis() {\n            throw new UnsupportedOperationException(\"Bottomless proxies don't expose a this.\");\n          }\n\n          public AccessibleObject getStaticPart() {\n            throw new UnsupportedOperationException();\n          }\n        });\n      }\n    };\n    requestInjection(finderInvoker);\n\n    @SuppressWarnings(\"unchecked\") // Proxy must produce instance of type given.\n        T proxy = (T) Proxy\n        .newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[] { iface },\n            finderInvoker);\n\n    bind(iface).toInstance(proxy);\n  }","id":87054,"modified_method":"private <T> void bindFinder(Class<T> iface) {\n    if (!isDynamicFinderValid(iface)) {\n      return;\n    }\n\n    InvocationHandler finderInvoker = new InvocationHandler() {\n      @Inject\n      JpaFinderProxy finderProxy;\n\n      @Override\n      public Object invoke(final Object thisObject, final Method method, final Object[] args)\n          throws Throwable {\n\n        // Don't intercept non-finder methods like equals and hashcode.\n        if (!method.isAnnotationPresent(Finder.class)) {\n          // This is not ideal, we are using the invocation handler's equals\n          // and hashcode as a proxy (!) for the proxy's equals and hashcode.\n          return method.invoke(this, args);\n        }\n\n        return finderProxy.invoke(new MethodInvocation() {\n          @Override\n          public Method getMethod() {\n            return method;\n          }\n\n          @Override\n          public Object[] getArguments() {\n            return null == args ? new Object[0] : args;\n          }\n\n          @Override\n          public Object proceed() throws Throwable {\n            return method.invoke(thisObject, args);\n          }\n\n          @Override\n          public Object getThis() {\n            throw new UnsupportedOperationException(\"Bottomless proxies don't expose a this.\");\n          }\n\n          @Override\n          public AccessibleObject getStaticPart() {\n            throw new UnsupportedOperationException();\n          }\n        });\n      }\n    };\n    requestInjection(finderInvoker);\n\n    @SuppressWarnings(\"unchecked\") // Proxy must produce instance of type given.\n        T proxy = (T) Proxy\n        .newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[] { iface },\n            finderInvoker);\n\n    bind(iface).toInstance(proxy);\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Override protected void configurePersistence() {\n    bindConstant().annotatedWith(Jpa.class).to(jpaUnit);\n\n    if (null != properties) {\n      bind(Properties.class).annotatedWith(Jpa.class).toInstance(properties);\n    } else {\n      bind(Properties.class).annotatedWith(Jpa.class)\n          .toProvider(Providers.<Properties>of(null));\n    }\n\n    bind(AmbariJpaPersistService.class).in(Singleton.class);\n\n    bind(PersistService.class).to(AmbariJpaPersistService.class);\n    bind(UnitOfWork.class).to(AmbariJpaPersistService.class);\n    bind(EntityManager.class).toProvider(AmbariJpaPersistService.class);\n    bind(EntityManagerFactory.class)\n        .toProvider(JpaPersistService.EntityManagerFactoryProvider.class);\n\n\n\n    transactionInterceptor = new AmbariJpaLocalTxnInterceptor();\n    requestInjection(transactionInterceptor);\n    sessionInterceptor = new AmbariLocalSessionInterceptor();\n    requestInjection(sessionInterceptor);\n\n\n    // Bind dynamic finders.\n    for (Class<?> finder : dynamicFinders) {\n      bindFinder(finder);\n    }\n\n    bindInterceptor(annotatedWith(RequiresSession.class), any(), sessionInterceptor);\n    bindInterceptor(any(), annotatedWith(RequiresSession.class), sessionInterceptor);\n  }","id":87055,"modified_method":"@Override protected void configurePersistence() {\n    bindConstant().annotatedWith(Jpa.class).to(jpaUnit);\n\n    if (null != properties) {\n      bind(Properties.class).annotatedWith(Jpa.class).toInstance(properties);\n    } else {\n      bind(Properties.class).annotatedWith(Jpa.class).toProvider(Providers.<Properties> of(null));\n    }\n\n    bind(AmbariJpaPersistService.class).in(Singleton.class);\n\n    bind(PersistService.class).to(AmbariJpaPersistService.class);\n    bind(UnitOfWork.class).to(AmbariJpaPersistService.class);\n    bind(EntityManager.class).toProvider(AmbariJpaPersistService.class);\n    bind(EntityManagerFactory.class).toProvider(JpaPersistService.EntityManagerFactoryProvider.class);\n\n    transactionInterceptor = new AmbariJpaLocalTxnInterceptor();\n    requestInjection(transactionInterceptor);\n\n    MethodInterceptor sessionInterceptor = new AmbariLocalSessionInterceptor();\n    requestInjection(sessionInterceptor);\n\n    // Bind dynamic finders.\n    for (Class<?> finder : dynamicFinders) {\n      bindFinder(finder);\n    }\n\n    bindInterceptor(annotatedWith(RequiresSession.class), any(), sessionInterceptor);\n    bindInterceptor(any(), annotatedWith(RequiresSession.class), sessionInterceptor);\n\n    // method-level binding for cross-cutting locks\n    // this runs before the base class binds Transactional, so it always runs\n    // first\n    MethodInterceptor lockAwareInterceptor = new TransactionalLockInterceptor();\n    requestInjection(lockAwareInterceptor);\n    bindInterceptor(any(), annotatedWith(TransactionalLock.class), lockAwareInterceptor);\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Transactional\n  public void remove(HostRoleCommandEntity stageEntity) {\n    entityManagerProvider.get().remove(merge(stageEntity));\n\n    invalidateHostRoleCommandStatusCache(stageEntity);\n  }","id":87056,"modified_method":"@Transactional\n  @TransactionalLock(lockArea = LockArea.HRC_STATUS_CACHE, lockType = LockType.WRITE)\n  public void remove(HostRoleCommandEntity entity) {\n    EntityManager entityManager = entityManagerProvider.get();\n    entityManager.remove(merge(entity));\n    invalidateHostRoleCommandStatusCache(entity);\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Transactional\n  public HostRoleCommandEntity merge(HostRoleCommandEntity stageEntity) {\n    HostRoleCommandEntity entity = entityManagerProvider.get().merge(stageEntity);\n\n    invalidateHostRoleCommandStatusCache(entity);\n\n    return entity;\n  }","id":87057,"modified_method":"@Transactional\n  @TransactionalLock(lockArea = LockArea.HRC_STATUS_CACHE, lockType = LockType.WRITE)\n  public HostRoleCommandEntity merge(HostRoleCommandEntity entity) {\n    EntityManager entityManager = entityManagerProvider.get();\n    entity = entityManager.merge(entity);\n\n    invalidateHostRoleCommandStatusCache(entity);\n\n    return entity;\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Loads the counts of tasks for a request and groups them by stage id.\n   * This allows for very efficient loading when there are a huge number of stages\n   * and tasks to iterate (for example, during a Stack Upgrade).\n   * @param requestId the request id\n   * @return the map of stage-to-summary objects\n   */\n  @RequiresSession\n  protected Map<Long, HostRoleCommandStatusSummaryDTO> loadAggregateCounts(Long requestId) {\n\n    TypedQuery<HostRoleCommandStatusSummaryDTO> query = entityManagerProvider.get().createQuery(\n      SUMMARY_DTO, HostRoleCommandStatusSummaryDTO.class);\n\n    query.setParameter(\"requestId\", requestId);\n    query.setParameter(\"aborted\", HostRoleStatus.ABORTED);\n    query.setParameter(\"completed\", HostRoleStatus.COMPLETED);\n    query.setParameter(\"failed\", HostRoleStatus.FAILED);\n    query.setParameter(\"holding\", HostRoleStatus.HOLDING);\n    query.setParameter(\"holding_failed\", HostRoleStatus.HOLDING_FAILED);\n    query.setParameter(\"holding_timedout\", HostRoleStatus.HOLDING_TIMEDOUT);\n    query.setParameter(\"in_progress\", HostRoleStatus.IN_PROGRESS);\n    query.setParameter(\"pending\", HostRoleStatus.PENDING);\n    query.setParameter(\"queued\", HostRoleStatus.QUEUED);\n    query.setParameter(\"timedout\", HostRoleStatus.TIMEDOUT);\n    query.setParameter(\"skipped_failed\", HostRoleStatus.SKIPPED_FAILED);\n\n    Map<Long, HostRoleCommandStatusSummaryDTO> map = new HashMap<Long, HostRoleCommandStatusSummaryDTO>();\n\n    for (HostRoleCommandStatusSummaryDTO dto : daoUtils.selectList(query)) {\n      map.put(dto.getStageId(), dto);\n    }\n\n    return map;\n  }","id":87058,"modified_method":"/**\n   * Loads the counts of tasks for a request and groups them by stage id.\n   * This allows for very efficient loading when there are a huge number of stages\n   * and tasks to iterate (for example, during a Stack Upgrade).\n   * @param requestId the request id\n   * @return the map of stage-to-summary objects\n   */\n  @RequiresSession\n  protected Map<Long, HostRoleCommandStatusSummaryDTO> loadAggregateCounts(Long requestId) {\n    Map<Long, HostRoleCommandStatusSummaryDTO> map = new HashMap<Long, HostRoleCommandStatusSummaryDTO>();\n\n    // ensure that we wait for any running transactions working on this cache to\n    // complete\n    ReadWriteLock lock = transactionLocks.getLock(LockArea.HRC_STATUS_CACHE);\n    lock.readLock().lock();\n\n    try {\n      TypedQuery<HostRoleCommandStatusSummaryDTO> query = entityManagerProvider.get().createQuery(\n          SUMMARY_DTO, HostRoleCommandStatusSummaryDTO.class);\n\n      query.setParameter(\"requestId\", requestId);\n      query.setParameter(\"aborted\", HostRoleStatus.ABORTED);\n      query.setParameter(\"completed\", HostRoleStatus.COMPLETED);\n      query.setParameter(\"failed\", HostRoleStatus.FAILED);\n      query.setParameter(\"holding\", HostRoleStatus.HOLDING);\n      query.setParameter(\"holding_failed\", HostRoleStatus.HOLDING_FAILED);\n      query.setParameter(\"holding_timedout\", HostRoleStatus.HOLDING_TIMEDOUT);\n      query.setParameter(\"in_progress\", HostRoleStatus.IN_PROGRESS);\n      query.setParameter(\"pending\", HostRoleStatus.PENDING);\n      query.setParameter(\"queued\", HostRoleStatus.QUEUED);\n      query.setParameter(\"timedout\", HostRoleStatus.TIMEDOUT);\n      query.setParameter(\"skipped_failed\", HostRoleStatus.SKIPPED_FAILED);\n\n      for (HostRoleCommandStatusSummaryDTO dto : daoUtils.selectList(query)) {\n        map.put(dto.getStageId(), dto);\n      }\n    } finally {\n      lock.readLock().unlock();\n    }\n\n    return map;\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Transactional\n  public List<HostRoleCommandEntity> mergeAll(Collection<HostRoleCommandEntity> entities) {\n    List<HostRoleCommandEntity> managedList = new ArrayList<HostRoleCommandEntity>(entities.size());\n    for (HostRoleCommandEntity entity : entities) {\n      managedList.add(entityManagerProvider.get().merge(entity));\n\n      invalidateHostRoleCommandStatusCache(entity);\n    }\n    return managedList;\n  }","id":87059,"modified_method":"@Transactional\n  @TransactionalLock(lockArea = LockArea.HRC_STATUS_CACHE, lockType = LockType.WRITE)\n  public List<HostRoleCommandEntity> mergeAll(Collection<HostRoleCommandEntity> entities) {\n    List<HostRoleCommandEntity> managedList = new ArrayList<HostRoleCommandEntity>(entities.size());\n    for (HostRoleCommandEntity entity : entities) {\n      EntityManager entityManager = entityManagerProvider.get();\n      managedList.add(entityManager.merge(entity));\n      invalidateHostRoleCommandStatusCache(entity);\n    }\n\n    return managedList;\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"@Transactional\n  public void create(HostRoleCommandEntity stageEntity) {\n    entityManagerProvider.get().persist(stageEntity);\n\n    invalidateHostRoleCommandStatusCache(stageEntity);\n  }","id":87060,"modified_method":"@Transactional\n  @TransactionalLock(lockArea = LockArea.HRC_STATUS_CACHE, lockType = LockType.WRITE)\n  public void create(HostRoleCommandEntity entity) {\n    EntityManager entityManager = entityManagerProvider.get();\n    entityManager.persist(entity);\n\n    invalidateHostRoleCommandStatusCache(entity);\n  }","commit_id":"1621a53dc5820ba1ca5bf5204628b51d341f0caa","url":"https://github.com/apache/ambari"},{"original_method":"public void unregisterMBeanServer(MBeanServer mbeanServer) {\n        if (mbeanServer != null) {\n            try {\n                ObjectName name = getObjectName();\n                mbeanServer.unregisterMBean(name);\n            } catch (Exception e) {\n                LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n            }\n        }\n    }","id":87061,"modified_method":"public void unregisterMBeanServer(MBeanServer mbeanServer) {\n        if (mbeanServer != null) {\n            try {\n                ObjectName name = getObjectName();\n\t\t\t\tif (mbeanServer.isRegistered(name)) {\n\t\t\t\t\tmbeanServer.unregisterMBean(name);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n                LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n            }\n        }\n    }","commit_id":"ee5bdb3b412058da7423f59a5a7fe72f68d4dfb4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void registerMBeanServer(MBeanServer mbeanServer) {\n        try {\n            ObjectName name = getObjectName();\n            mbeanServer.registerMBean(this, name);\n        } catch (Exception e) {\n            LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n        }\n    }","id":87062,"modified_method":"public void registerMBeanServer(MBeanServer mbeanServer) {\n        try {\n            ObjectName name = getObjectName();\n\t\t\tif (!mbeanServer.isRegistered(name)) {\n\t\t\t\tmbeanServer.registerMBean(this, name);\n\t\t\t}\n\t\t} catch (Exception e) {\n            LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n        }\n    }","commit_id":"ee5bdb3b412058da7423f59a5a7fe72f68d4dfb4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void registerMBeanServer(MBeanServer mbeanServer) {\n        try {\n            ObjectName name = getObjectName();\n            mbeanServer.registerMBean(this, name);\n        } catch (Exception e) {\n            LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n        }\n    }","id":87063,"modified_method":"public void registerMBeanServer(MBeanServer mbeanServer) {\n        try {\n            ObjectName name = getObjectName();\n\t\t\tif (!mbeanServer.isRegistered(name)) {\n\t\t\t\tmbeanServer.registerMBean(this, name);\n\t\t\t}\n\t\t} catch (Exception e) {\n            LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n        }\n    }","commit_id":"ee5bdb3b412058da7423f59a5a7fe72f68d4dfb4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public void unregisterMBeanServer(MBeanServer mbeanServer) {\n        if (mbeanServer != null) {\n            try {\n                ObjectName name = getObjectName();\n                mbeanServer.unregisterMBean(name);\n            } catch (Exception e) {\n                LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n            }\n        }\n    }","id":87064,"modified_method":"public void unregisterMBeanServer(MBeanServer mbeanServer) {\n        if (mbeanServer != null) {\n            try {\n                ObjectName name = getObjectName();\n\t\t\t\tif (mbeanServer.isRegistered(name)) {\n\t\t\t\t\tmbeanServer.unregisterMBean(name);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n                LOG.warn(\"An error occured during mbean server registration: \" + e, e);\n            }\n        }\n    }","commit_id":"ee5bdb3b412058da7423f59a5a7fe72f68d4dfb4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void startJmx() {\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(\"org.apache.tomcat.jdbc.pool.jmx:type=ConnectionPool,name=\"+getName());\n            jmxPool = new org.apache.tomcat.jdbc.pool.jmx.ConnectionPool(this);\n            mbs.registerMBean(jmxPool, name);\n        } catch (Exception x) {\n            log.warn(\"Unable to start JMX integration for connection pool. Instance[\"+getName()+\"] can't be monitored.\",x);\n        }\n    }","id":87065,"modified_method":"protected void startJmx() {\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(POOL_JMX_TYPE_PREFIX+\"ConnectionPool,name=\"+getName());\n            jmxPool = new org.apache.tomcat.jdbc.pool.jmx.ConnectionPool(this);\n            mbs.registerMBean(jmxPool, name);\n        } catch (Exception x) {\n            log.warn(\"Unable to start JMX integration for connection pool. Instance[\"+getName()+\"] can't be monitored.\",x);\n        }\n    }","commit_id":"dd256d5dab5f89a2248fd8ab392a656567999d69","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Initialize the connection pool - called from the constructor\n     * @param properties PoolProperties - properties used to initialize the pool with\n     * @throws SQLException\n     */\n    protected void init(PoolProperties properties) throws SQLException {\n        poolProperties = properties;\n        //make space for 10 extra in case we flow over a bit\n        busy = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),false);\n        //busy = new FairBlockingQueue<PooledConnection>();\n        //make space for 10 extra in case we flow over a bit\n        if (properties.isFairQueue()) {\n            idle = new FairBlockingQueue<PooledConnection>();\n        } else {\n            idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),properties.isFairQueue());\n        }\n\n        //if the evictor thread is supposed to run, start it now\n        if (properties.isPoolSweeperEnabled()) {\n            poolCleaner = new PoolCleaner(\"[Pool-Cleaner]:\" + properties.getName(), this, properties.getTimeBetweenEvictionRunsMillis());\n            poolCleaner.start();\n        } //end if\n\n        if (properties.getMaxActive()<properties.getInitialSize()) {\n            log.warn(\"initialSize is larger than maxActive, setting initialSize to: \"+properties.getMaxActive());\n            properties.setInitialSize(properties.getMaxActive());\n        }\n        if (properties.getMinIdle()>properties.getMaxActive()) {\n            log.warn(\"minIdle is larger than maxActive, setting minIdle to: \"+properties.getMaxActive());\n            properties.setMinIdle(properties.getMaxActive());\n        }\n        if (properties.getMaxIdle()>properties.getMaxActive()) {\n            log.warn(\"maxIdle is larger than maxActive, setting maxIdle to: \"+properties.getMaxActive());\n            properties.setMaxIdle(properties.getMaxActive());\n        }\n        if (properties.getMaxIdle()<properties.getMinIdle()) {\n            log.warn(\"maxIdle is smaller than minIdle, setting maxIdle to: \"+properties.getMinIdle());\n            properties.setMaxIdle(properties.getMinIdle());\n        }\n\n\n        PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray();\n        for (int i=0; i<proxies.length; i++) {\n            try {\n                proxies[i].getInterceptorClass().newInstance().poolStarted(this);\n            }catch (Exception x) {\n                log.warn(\"Unable to inform interceptor of pool start.\",x);\n                close(true);\n                SQLException ex = new SQLException();\n                ex.initCause(x);\n                throw ex;\n            }\n        }        \n        //initialize the pool with its initial set of members\n        PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()];\n        try {\n            for (int i = 0; i < initialPool.length; i++) {\n                initialPool[i] = this.borrowConnection(0); //don't wait, should be no contention\n            } //for\n\n        } catch (SQLException x) {\n            close(true);\n            throw x;\n        } finally {\n            //return the members as idle to the pool\n            for (int i = 0; i < initialPool.length; i++) {\n                if (initialPool[i] != null) {\n                    try {this.returnConnection(initialPool[i]);}catch(Exception x){}\n                } //end if\n            } //for\n        } //catch\n        if (this.getPoolProperties().isJmxEnabled()) startJmx();\n        closed = false;\n    }","id":87066,"modified_method":"/**\n     * Initialize the connection pool - called from the constructor\n     * @param properties PoolProperties - properties used to initialize the pool with\n     * @throws SQLException\n     */\n    protected void init(PoolProperties properties) throws SQLException {\n        poolProperties = properties;\n        //make space for 10 extra in case we flow over a bit\n        busy = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),false);\n        //busy = new FairBlockingQueue<PooledConnection>();\n        //make space for 10 extra in case we flow over a bit\n        if (properties.isFairQueue()) {\n            idle = new FairBlockingQueue<PooledConnection>();\n        } else {\n            idle = new ArrayBlockingQueue<PooledConnection>(properties.getMaxActive(),properties.isFairQueue());\n        }\n\n        //if the evictor thread is supposed to run, start it now\n        if (properties.isPoolSweeperEnabled()) {\n            poolCleaner = new PoolCleaner(\"[Pool-Cleaner]:\" + properties.getName(), this, properties.getTimeBetweenEvictionRunsMillis());\n            poolCleaner.start();\n        } //end if\n\n        if (properties.getMaxActive()<properties.getInitialSize()) {\n            log.warn(\"initialSize is larger than maxActive, setting initialSize to: \"+properties.getMaxActive());\n            properties.setInitialSize(properties.getMaxActive());\n        }\n        if (properties.getMinIdle()>properties.getMaxActive()) {\n            log.warn(\"minIdle is larger than maxActive, setting minIdle to: \"+properties.getMaxActive());\n            properties.setMinIdle(properties.getMaxActive());\n        }\n        if (properties.getMaxIdle()>properties.getMaxActive()) {\n            log.warn(\"maxIdle is larger than maxActive, setting maxIdle to: \"+properties.getMaxActive());\n            properties.setMaxIdle(properties.getMaxActive());\n        }\n        if (properties.getMaxIdle()<properties.getMinIdle()) {\n            log.warn(\"maxIdle is smaller than minIdle, setting maxIdle to: \"+properties.getMinIdle());\n            properties.setMaxIdle(properties.getMinIdle());\n        }\n\n        if (this.getPoolProperties().isJmxEnabled()) startJmx();\n        \n        PoolProperties.InterceptorDefinition[] proxies = getPoolProperties().getJdbcInterceptorsAsArray();\n        for (int i=0; i<proxies.length; i++) {\n            try {\n                proxies[i].getInterceptorClass().newInstance().poolStarted(this);\n            }catch (Exception x) {\n                log.warn(\"Unable to inform interceptor of pool start.\",x);\n                if (jmxPool!=null) jmxPool.notify(jmxPool.NOTIFY_INIT, getStackTrace(x));\n                close(true);\n                SQLException ex = new SQLException();\n                ex.initCause(x);\n                throw ex;\n            }\n        }        \n        //initialize the pool with its initial set of members\n        PooledConnection[] initialPool = new PooledConnection[poolProperties.getInitialSize()];\n        try {\n            for (int i = 0; i < initialPool.length; i++) {\n                initialPool[i] = this.borrowConnection(0); //don't wait, should be no contention\n            } //for\n\n        } catch (SQLException x) {\n            if (jmxPool!=null) jmxPool.notify(jmxPool.NOTIFY_INIT, getStackTrace(x));\n            close(true);\n            throw x;\n        } finally {\n            //return the members as idle to the pool\n            for (int i = 0; i < initialPool.length; i++) {\n                if (initialPool[i] != null) {\n                    try {this.returnConnection(initialPool[i]);}catch(Exception x){}\n                } //end if\n            } //for\n        } //catch\n        \n        closed = false;\n    }","commit_id":"dd256d5dab5f89a2248fd8ab392a656567999d69","url":"https://github.com/apache/tomcat"},{"original_method":"protected void stopJmx() {\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(\"org.apache.tomcat.jdbc.pool.jmx:type=ConnectionPool,name=\"+getName());\n            mbs.unregisterMBean(name);\n            jmxPool = null;\n        }catch (Exception x) {\n            log.warn(\"Unable to stop JMX integration for connection pool. Instance[\"+getName()+\"].\",x);\n        }\n    }","id":87067,"modified_method":"protected void stopJmx() {\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(POOL_JMX_TYPE_PREFIX+\"ConnectionPool,name=\"+getName());\n            if (mbs.isRegistered(name))\n                mbs.unregisterMBean(name);\n            jmxPool = null;\n        }catch (Exception x) {\n            log.warn(\"Unable to stop JMX integration for connection pool. Instance[\"+getName()+\"].\",x);\n        }\n    }","commit_id":"dd256d5dab5f89a2248fd8ab392a656567999d69","url":"https://github.com/apache/tomcat"},{"original_method":"public static MBeanNotificationInfo[] getDefaultNotificationInfo() {\n        String[] types = new String[] {NOTIFY_CONNECT, NOTIFY_ABANDON}; \n        String name = Notification.class.getName(); \n        String description = \"A connection pool error condition was met.\"; \n        MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description); \n        return new MBeanNotificationInfo[] {info};\n    }","id":87068,"modified_method":"public static MBeanNotificationInfo[] getDefaultNotificationInfo() {\n        String[] types = new String[] {NOTIFY_INIT, NOTIFY_CONNECT, NOTIFY_ABANDON}; \n        String name = Notification.class.getName(); \n        String description = \"A connection pool error condition was met.\"; \n        MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description); \n        return new MBeanNotificationInfo[] {info};\n    }","commit_id":"dd256d5dab5f89a2248fd8ab392a656567999d69","url":"https://github.com/apache/tomcat"},{"original_method":"protected void registerJmx() {\n        try {\n            if (getCompositeType()!=null) {\n                ObjectName oname = new ObjectName(\"org.apache.tomcat.jdbc.pool.jmx:type=\"+getClass().getName()+\",name=\" + poolName);\n                Registry registry = Registry.getRegistry(null, null);\n                registry.loadDescriptors(getClass().getPackage().getName(),getClass().getClassLoader());\n                ManagedBean managed = registry.findManagedBean(this.getClass().getName());\n                DynamicMBean mbean = managed!=null?managed.createMBean(this):null;\n                if (mbean!=null && mbeans.putIfAbsent(poolName, mbean)==null) {\n                    registry.getMBeanServer().registerMBean( mbean, oname);\n                } else {\n                    log.warn(SlowQueryReport.class.getName()+ \"- No JMX support, composite type was not found.\");\n                }\n            } else {\n                log.warn(SlowQueryReport.class.getName()+ \"- No JMX support, composite type was not found.\");\n            }\n        } catch (MalformedObjectNameException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (InstanceNotFoundException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (RuntimeOperationsException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (MBeanException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (InstanceAlreadyExistsException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (NotCompliantMBeanException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        }\n    }","id":87069,"modified_method":"protected void registerJmx() {\n        try {\n            if (getCompositeType()!=null) {\n                ObjectName oname = new ObjectName(ConnectionPool.POOL_JMX_TYPE_PREFIX+getClass().getName()+\",name=\" + poolName);\n                Registry registry = Registry.getRegistry(null, null);\n                registry.loadDescriptors(getClass().getPackage().getName(),getClass().getClassLoader());\n                ManagedBean managed = registry.findManagedBean(this.getClass().getName());\n                DynamicMBean mbean = managed!=null?managed.createMBean(this):null;\n                if (mbean!=null && mbeans.putIfAbsent(poolName, mbean)==null) {\n                    registry.getMBeanServer().registerMBean( mbean, oname);\n                } else if (mbean==null){\n                    log.warn(SlowQueryReport.class.getName()+ \"- No JMX support, unable to initiate Tomcat JMX.\");\n                }\n            } else {\n                log.warn(SlowQueryReport.class.getName()+ \"- No JMX support, composite type was not found.\");\n            }\n        } catch (MalformedObjectNameException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (InstanceNotFoundException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (RuntimeOperationsException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (MBeanException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (InstanceAlreadyExistsException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        } catch (NotCompliantMBeanException e) {\n            log.error(\"Jmx registration failed, no JMX data will be exposed for the query stats.\",e);\n        }\n    }","commit_id":"dd256d5dab5f89a2248fd8ab392a656567999d69","url":"https://github.com/apache/tomcat"},{"original_method":"protected void deregisterJmx() {\n        try {\n            DynamicMBean mbean = null;\n            if ((mbean=mbeans.remove(poolName))!=null) {\n                Registry registry = Registry.getRegistry(null, null);\n                ManagedBean managed = registry.findManagedBean(this.getClass().getName());\n                if (managed!=null) {\n                    ObjectName oname = new ObjectName(\"org.apache.tomcat.jdbc.pool.jmx:type=\"+getClass().getName()+\",name=\" + poolName);\n                    registry.unregisterComponent(oname);\n                    registry.removeManagedBean(managed);\n                }\n                \n            }\n        } catch (MalformedObjectNameException e) {\n            log.warn(\"Jmx deregistration failed.\",e);\n        } catch (RuntimeOperationsException e) {\n            log.warn(\"Jmx deregistration failed.\",e);\n        }\n        \n    }","id":87070,"modified_method":"protected void deregisterJmx() {\n        try {\n            DynamicMBean mbean = null;\n            if ((mbean=mbeans.remove(poolName))!=null) {\n                Registry registry = Registry.getRegistry(null, null);\n                ManagedBean managed = registry.findManagedBean(this.getClass().getName());\n                if (managed!=null) {\n                    ObjectName oname = new ObjectName(ConnectionPool.POOL_JMX_TYPE_PREFIX+getClass().getName()+\",name=\" + poolName);\n                    registry.unregisterComponent(oname);\n                    registry.removeManagedBean(managed);\n                }\n                \n            }\n        } catch (MalformedObjectNameException e) {\n            log.warn(\"Jmx deregistration failed.\",e);\n        } catch (RuntimeOperationsException e) {\n            log.warn(\"Jmx deregistration failed.\",e);\n        }\n        \n    }","commit_id":"dd256d5dab5f89a2248fd8ab392a656567999d69","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param expr Expr.\n     */\n    public void addChild(GridSqlElement expr) {\n        if (expr == null)\n            throw new NullPointerException();\n\n        children.add(expr);\n    }","id":87071,"modified_method":"/**\n     * @param expr Expr.\n     * @return {@code this}.\n     */\n    public GridSqlElement addChild(GridSqlElement expr) {\n        if (expr == null)\n            throw new NullPointerException();\n\n        children.add(expr);\n\n        return this;\n    }","commit_id":"c85b7bea4e6a60247b4bd270314bab76cfa95c14","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param idx Index of column.\n     * @return Column alias.\n     */\n    private static String column(int idx) {\n        return COLUMN_PREFIX + idx;\n    }","id":87072,"modified_method":"/**\n     * @param idx Index of column.\n     * @return Generated by index column alias.\n     */\n    private static String columnAlias(int idx) {\n        return COLUMN_PREFIX + idx;\n    }","commit_id":"c85b7bea4e6a60247b4bd270314bab76cfa95c14","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param conn Connection.\n     * @param query Query.\n     * @param params Parameters.\n     * @return Two step query.\n     */\n    public static GridCacheTwoStepQuery split(Connection conn, String query, Object[] params) {\n        GridSqlSelect srcQry = GridSqlQueryParser.parse(conn, query);\n\n        if (srcQry.groups().isEmpty()) { // Simple case.\n            String tbl0 = table(0);\n\n            GridCacheTwoStepQuery res = new GridCacheTwoStepQuery(\"select * from \" + tbl0);\n\n            res.addMapQuery(tbl0, srcQry.getSQL(), params);\n\n            return res;\n        }\n\n        // Map query.\n        GridSqlSelect mapQry = srcQry.clone();\n\n        mapQry.clearSelect();\n\n        List<GridSqlAlias> aliases = new ArrayList<>(srcQry.allExpressions().size());\n\n        int idx = 0;\n\n        for (GridSqlElement exp : srcQry.allExpressions()) { // Add all expressions to select clause.\n            if (exp instanceof GridSqlColumn)\n                exp = new GridSqlAlias(((GridSqlColumn)exp).columnName(), exp);\n            else if (!(exp instanceof GridSqlAlias))\n                exp = new GridSqlAlias(column(idx), exp);\n\n            aliases.add((GridSqlAlias)exp);\n\n            mapQry.addSelectExpression(exp);\n\n            idx++;\n\n            assert aliases.size() == idx;\n        }\n\n        mapQry.clearGroups();\n\n        for (int col : srcQry.groupColumns())\n            mapQry.addGroupExpression(new GridSqlColumn(null, null, aliases.get(col).alias()));\n\n        mapQry.clearSort(); // TODO sort support\n\n        // Reduce query.\n        GridSqlSelect rdcQry = new GridSqlSelect();\n\n        for (int i = 0; i < srcQry.select().size(); i++)\n            rdcQry.addSelectExpression(new GridSqlColumn(null, null, aliases.get(i).alias()));\n\n        rdcQry.from(new GridSqlTable(null, table(0)));\n\n        for (int col : srcQry.groupColumns())\n            rdcQry.addGroupExpression(new GridSqlColumn(null, null, aliases.get(col).alias()));\n\n        GridCacheTwoStepQuery res = new GridCacheTwoStepQuery(rdcQry.getSQL());\n\n        res.addMapQuery(table(0), mapQry.getSQL(), params);\n\n        return res;\n    }","id":87073,"modified_method":"/**\n     * @param conn Connection.\n     * @param query Query.\n     * @param params Parameters.\n     * @return Two step query.\n     */\n    public static GridCacheTwoStepQuery split(Connection conn, String query, Object[] params) {\n        GridSqlSelect srcQry = GridSqlQueryParser.parse(conn, query);\n\n        if (srcQry.groups().isEmpty()) { // Simple case.\n            String tbl0 = table(0);\n\n            GridCacheTwoStepQuery res = new GridCacheTwoStepQuery(\"select * from \" + tbl0);\n\n            res.addMapQuery(tbl0, srcQry.getSQL(), params);\n\n            return res;\n        }\n\n        // Map query.\n        GridSqlSelect mapQry = srcQry.clone();\n\n        mapQry.clearSelect();\n\n        List<GridSqlElement> mapExps = new ArrayList<>(srcQry.allExpressions());\n\n        GridSqlElement[] rdcExps = new GridSqlElement[srcQry.select().size()];\n\n        for (int i = 0, len = mapExps.size(); i < len; i++)\n            splitSelectExpression(mapExps, rdcExps, i);\n\n        List<GridSqlAlias> aliases = new ArrayList<>(srcQry.allExpressions().size());\n\n        int idx = 0;\n\n        for (GridSqlElement exp : mapExps) { // Add all expressions to select clause.\n            if (exp instanceof GridSqlColumn)\n                exp = alias(((GridSqlColumn)exp).columnName(), exp);\n            else if (!(exp instanceof GridSqlAlias))\n                exp = alias(columnAlias(idx), exp);\n\n            aliases.add((GridSqlAlias)exp);\n\n            mapQry.addSelectExpression(exp);\n\n            idx++;\n        }\n\n        mapQry.clearGroups();\n\n        for (int col : srcQry.groupColumns())\n            mapQry.addGroupExpression(column(aliases.get(col).alias()));\n\n        mapQry.clearSort(); // TODO sort support\n\n        // Reduce query.\n        GridSqlSelect rdcQry = new GridSqlSelect();\n\n        for (int i = 0; i < srcQry.select().size(); i++)\n            rdcQry.addSelectExpression(column(aliases.get(i).alias()));\n\n        rdcQry.from(new GridSqlTable(null, table(0)));\n\n        for (int col : srcQry.groupColumns())\n            rdcQry.addGroupExpression(column(aliases.get(col).alias()));\n\n        GridCacheTwoStepQuery res = new GridCacheTwoStepQuery(rdcQry.getSQL());\n\n        res.addMapQuery(table(0), mapQry.getSQL(), params);\n\n        return res;\n    }","commit_id":"c85b7bea4e6a60247b4bd270314bab76cfa95c14","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Fills the User ID and Password fields in this panel with the data coming\n     * from the given protocolProvider.\n     *\n     * @param protocolProvider The <tt>ProtocolProviderService<\/tt> to load\n     *            the data from.\n     */\n    public void loadAccount(ProtocolProviderService protocolProvider)\n    {\n        AccountID accountID = protocolProvider.getAccountID();\n\n        Map accountProperties = accountID.getAccountProperties();\n\n        String password = (String) accountProperties.get(\n            ProtocolProviderFactory.PASSWORD);\n\n        this.userIDField.setEnabled(false);\n        this.userIDField.setText(accountID.getUserID());\n\n        if (password != null)\n        {\n            this.passField.setText(password);\n            this.rememberPassBox.setSelected(true);\n        }\n\n        String serverAddress = (String) accountProperties\n            .get(ProtocolProviderFactory.SERVER_ADDRESS);\n\n        serverField.setText(serverAddress);\n\n        String serverPort = (String) accountProperties\n            .get(ProtocolProviderFactory.SERVER_PORT);\n\n        portField.setText(serverPort);\n\n        boolean keepAlive = new Boolean((String)accountProperties\n            .get(\"SEND_KEEP_ALIVE\")).booleanValue();\n\n        sendKeepAliveBox.setSelected(keepAlive);\n\n        boolean gmailNotificationEnabled = new Boolean((String)accountProperties\n                  .get(\"GMAIL_NOTIFICATIONS_ENABLED\")).booleanValue();\n\n        gmailNotificationsBox.setSelected(gmailNotificationEnabled);\n\n        String resource = (String) accountProperties.get(\n            ProtocolProviderFactory.RESOURCE);\n\n        resourceField.setText(resource);\n\n        String priority = (String) accountProperties.get(\n            ProtocolProviderFactory.RESOURCE_PRIORITY);\n\n        priorityField.setText(priority);\n\n        this.isServerOverridden = accountID.getAccountPropertyBoolean(\n            ProtocolProviderFactory.IS_SERVER_OVERRIDDEN, false);\n    }","id":87074,"modified_method":"/**\n     * Fills the User ID and Password fields in this panel with the data coming\n     * from the given protocolProvider.\n     *\n     * @param protocolProvider The <tt>ProtocolProviderService<\/tt> to load\n     *            the data from.\n     */\n    public void loadAccount(ProtocolProviderService protocolProvider)\n    {\n        AccountID accountID = protocolProvider.getAccountID();\n        Map<String, String> accountProperties\n            = accountID.getAccountProperties();\n\n        String password\n            = accountProperties.get(ProtocolProviderFactory.PASSWORD);\n\n        this.userIDField.setEnabled(false);\n        this.userIDField.setText(accountID.getUserID());\n\n        if (password != null)\n        {\n            this.passField.setText(password);\n            this.rememberPassBox.setSelected(true);\n        }\n\n        String serverAddress\n            = accountProperties.get(ProtocolProviderFactory.SERVER_ADDRESS);\n\n        serverField.setText(serverAddress);\n\n        String serverPort\n            = accountProperties.get(ProtocolProviderFactory.SERVER_PORT);\n\n        portField.setText(serverPort);\n\n        boolean keepAlive\n            = Boolean.parseBoolean(accountProperties.get(\"SEND_KEEP_ALIVE\"));\n\n        sendKeepAliveBox.setSelected(keepAlive);\n\n        boolean gmailNotificationEnabled\n            = Boolean.parseBoolean(\n                    accountProperties.get(\"GMAIL_NOTIFICATIONS_ENABLED\"));\n\n        gmailNotificationsBox.setSelected(gmailNotificationEnabled);\n\n        String resource\n            = accountProperties.get(ProtocolProviderFactory.RESOURCE);\n\n        resourceField.setText(resource);\n\n        String priority\n            = accountProperties.get(ProtocolProviderFactory.RESOURCE_PRIORITY);\n\n        priorityField.setText(priority);\n\n        this.isServerOverridden\n            = accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.IS_SERVER_OVERRIDDEN,\n                    false);\n    }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Disables Next Button if Port field value is incorrect\n     */\n    private void setNextButtonAccordingToPortAndPriority()\n    {\n        try\n        {\n            new Integer(portField.getText());\n            new Integer(priorityField.getText());\n            wizard.getWizardContainer().setNextFinishButtonEnabled(true);\n        }\n        catch (NumberFormatException ex)\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(false);\n        }\n    }","id":87075,"modified_method":"/**\n     * Disables Next Button if Port field value is incorrect\n     */\n    private void setNextButtonAccordingToPortAndPriority()\n    {\n        try\n        {\n            Integer.parseInt(portField.getText());\n            Integer.parseInt(priorityField.getText());\n            wizard.getWizardContainer().setNextFinishButtonEnabled(true);\n        }\n        catch (NumberFormatException ex)\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(false);\n        }\n    }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Enables or disables the \"Next\" wizard button according to whether the\n     * UserID field is empty.\n     */\n    private void setNextButtonAccordingToUserIDAndResource()\n    {\n        if (userIDField.getText() == null\n            || userIDField.getText().equals(\"\")\n            || resourceField.getText() == null\n            || resourceField.getText().equals(\"\"))\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(false);\n        }\n        else\n        {\n            wizard.getWizardContainer().setNextFinishButtonEnabled(true);\n        }\n    }","id":87076,"modified_method":"/**\n     * Enables or disables the \"Next\" wizard button according to whether the\n     * UserID field is empty.\n     */\n    private void setNextButtonAccordingToUserIDAndResource()\n    {\n        boolean nextFinishButtonEnabled = false;\n\n        String userID = userIDField.getText();\n        if ((userID != null) && !userID.equals(\"\"))\n        {\n            String resource = resourceField.getText();\n            if ((resource != null) && !resource.equals(\"\"))\n            {\n                nextFinishButtonEnabled = true;\n            }\n        }\n\n        wizard\n            .getWizardContainer()\n                .setNextFinishButtonEnabled(nextFinishButtonEnabled);\n    }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void processPacket(Packet packet)\n        {\n            if(packet != null &&  !(packet instanceof NewMailNotificationIQ))\n                return;\n\n            //check whether we are still enabled.\n            boolean enableGmailNotifications\n                = Boolean.parseBoolean( jabberProvider.getAccountID()\n                    .getAccountPropertyString(\"GMAIL_NOTIFICATIONS_ENABLED\"));\n\n            if (!enableGmailNotifications)\n                return;\n\n            if(opSetPersPresence.getCurrentStatusMessage()\n                    .equals(JabberStatusEnum.OFFLINE))\n                return;\n\n            MailboxQueryIQ mailboxQueryIQ = new MailboxQueryIQ();\n\n            if(lastReceivedMailboxResultTime != -1)\n                mailboxQueryIQ.setNewerThanTime(\n                                lastReceivedMailboxResultTime);\n\n            logger.trace(\n                \"send mailNotification for acc: \"\n                + jabberProvider.getAccountID().getAccountUniqueID());\n\n            jabberProvider.getConnection().sendPacket(mailboxQueryIQ);\n        }","id":87077,"modified_method":"public void processPacket(Packet packet)\n        {\n            if(packet != null &&  !(packet instanceof NewMailNotificationIQ))\n                return;\n\n            //check whether we are still enabled.\n            boolean enableGmailNotifications\n                = jabberProvider\n                    .getAccountID()\n                        .getAccountPropertyBoolean(\n                            \"GMAIL_NOTIFICATIONS_ENABLED\",\n                            false);\n\n            if (!enableGmailNotifications)\n                return;\n\n            if(opSetPersPresence.getCurrentStatusMessage()\n                    .equals(JabberStatusEnum.OFFLINE))\n                return;\n\n            MailboxQueryIQ mailboxQueryIQ = new MailboxQueryIQ();\n\n            if(lastReceivedMailboxResultTime != -1)\n                mailboxQueryIQ.setNewerThanTime(\n                                lastReceivedMailboxResultTime);\n\n            logger.trace(\n                \"send mailNotification for acc: \"\n                + jabberProvider.getAccountID().getAccountUniqueID());\n\n            jabberProvider.getConnection().sendPacket(mailboxQueryIQ);\n        }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Fire Unregistered event\n         */\n        void fireUnregisterd()\n        {\n            jabberProvider.fireRegistrationStateChanged(\n                jabberProvider.getRegistrationState(),\n                RegistrationState.CONNECTION_FAILED,\n                RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, null);\n\n            opSetPersPresence.fireProviderStatusChangeEvent(\n                opSetPersPresence.getPresenceStatus(),\n                jabberProvider\n                    .getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));\n        }","id":87078,"modified_method":"/**\n         * Fire Unregistered event\n         */\n        private void fireUnregisterd()\n        {\n            jabberProvider.fireRegistrationStateChanged(\n                jabberProvider.getRegistrationState(),\n                RegistrationState.CONNECTION_FAILED,\n                RegistrationStateChangeEvent.REASON_INTERNAL_ERROR, null);\n\n            opSetPersPresence.fireProviderStatusChangeEvent(\n                opSetPersPresence.getPresenceStatus(),\n                jabberProvider\n                    .getJabberStatusEnum().getStatus(JabberStatusEnum.OFFLINE));\n        }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * Checks whether first packet in queue is ok\n         * @return boolean\n         * @throws NoSuchElementException\n         */\n        boolean checkFirstPacket()\n            throws NoSuchElementException\n        {\n            KeepAliveEvent receivedEvent\n                = receivedKeepAlivePackets.removeLast();\n\n            if(jabberProvider.hashCode() != receivedEvent.getSrcProviderHash()\n               || OperationSetBasicInstantMessagingJabberImpl.this.hashCode()\n                      != receivedEvent.getSrcOpSetHash()\n               || !jabberProvider.getAccountID().getUserID().\n                                        equals(receivedEvent.getFromUserID()) )\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n        }","id":87079,"modified_method":"/**\n         * Checks whether first packet in queue is ok\n         * @return boolean\n         * @throws NoSuchElementException\n         */\n        private boolean checkFirstPacket()\n            throws NoSuchElementException\n        {\n            KeepAliveEvent receivedEvent\n                = receivedKeepAlivePackets.removeLast();\n\n            return\n                (jabberProvider.hashCode() == receivedEvent.getSrcProviderHash()\n                    && OperationSetBasicInstantMessagingJabberImpl.this.hashCode()\n                            == receivedEvent.getSrcOpSetHash()\n                    && jabberProvider.getAccountID().getUserID()\n                            .equals(receivedEvent.getFromUserID()));\n        }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n         * The method is called by a ProtocolProvider implementation whenever\n         * a change in the registration state of the corresponding provider had\n         * occurred.\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            logger.debug(\"The provider changed state from: \"\n                         + evt.getOldState()\n                         + \" to: \" + evt.getNewState());\n\n            if (evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                opSetPersPresence =\n                    (OperationSetPersistentPresenceJabberImpl) jabberProvider\n                        .getOperationSet(OperationSetPersistentPresence.class);\n\n                jabberProvider.getConnection().addPacketListener(\n                        new SmackMessageListener(),\n                        new AndFilter(\n                            new PacketFilter[]{new GroupMessagePacketFilter(),\n                            new PacketTypeFilter(\n                            org.jivesoftware.smack.packet.Message.class)}));\n\n                //subscribe for Google (GMail or Google Apps) notifications\n                //for new mail messages.\n                boolean enableGmailNotifications\n                   = Boolean.parseBoolean( jabberProvider.getAccountID()\n                     .getAccountPropertyString(\"GMAIL_NOTIFICATIONS_ENABLED\"));\n\n                if (enableGmailNotifications)\n                    subscribeForGmailNotifications();\n\n\n                // run keep alive thread\n                if(keepAliveSendTask == null && keepAliveEnabled)\n                {\n                    jabberProvider.getConnection().addPacketListener(\n                        new KeepalivePacketListener(),\n                        new PacketTypeFilter(\n                            KeepAliveEvent.class));\n\n                    keepAliveSendTask = new KeepAliveSendTask();\n\n                    keepAliveTimer.scheduleAtFixedRate(\n                        keepAliveSendTask,\n                        KEEPALIVE_INTERVAL,\n                        KEEPALIVE_INTERVAL);\n                }\n            }\n        }","id":87080,"modified_method":"/**\n         * The method is called by a ProtocolProvider implementation whenever\n         * a change in the registration state of the corresponding provider had\n         * occurred.\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            logger.debug(\"The provider changed state from: \"\n                         + evt.getOldState()\n                         + \" to: \" + evt.getNewState());\n\n            if (evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                opSetPersPresence =\n                    (OperationSetPersistentPresenceJabberImpl) jabberProvider\n                        .getOperationSet(OperationSetPersistentPresence.class);\n\n                jabberProvider.getConnection().addPacketListener(\n                        new SmackMessageListener(),\n                        new AndFilter(\n                            new PacketFilter[]{new GroupMessagePacketFilter(),\n                            new PacketTypeFilter(\n                            org.jivesoftware.smack.packet.Message.class)}));\n\n                //subscribe for Google (GMail or Google Apps) notifications\n                //for new mail messages.\n                boolean enableGmailNotifications\n                   = jabberProvider\n                       .getAccountID()\n                           .getAccountPropertyBoolean(\n                               \"GMAIL_NOTIFICATIONS_ENABLED\",\n                               false);\n\n                if (enableGmailNotifications)\n                    subscribeForGmailNotifications();\n\n\n                // run keep alive thread\n                if(keepAliveSendTask == null && keepAliveEnabled)\n                {\n                    jabberProvider.getConnection().addPacketListener(\n                        new KeepalivePacketListener(),\n                        new PacketTypeFilter(\n                            KeepAliveEvent.class));\n\n                    keepAliveSendTask = new KeepAliveSendTask();\n\n                    keepAliveTimer.scheduleAtFixedRate(\n                        keepAliveSendTask,\n                        KEEPALIVE_INTERVAL,\n                        KEEPALIVE_INTERVAL);\n                }\n            }\n        }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sends the <tt>message<\/tt> to the destination indicated by the\n     * <tt>to<\/tt> contact.\n     *\n     * @param to the <tt>Contact<\/tt> to send <tt>message<\/tt> to\n     * @param message the <tt>Message<\/tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to<\/tt> is not an\n     * instance of ContactImpl.\n     */\n    public void sendInstantMessage(Contact to, Message message)\n        throws IllegalStateException, IllegalArgumentException\n    {\n        if( !(to instanceof ContactJabberImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Jabber contact.\"\n               + to);\n\n        try\n        {\n            assertConnected();\n\n            org.jivesoftware.smack.MessageListener msgListener =\n                new org.jivesoftware.smack.MessageListener()\n                {\n                    public void processMessage(\n                        Chat arg0,\n                        org.jivesoftware.smack.packet.Message arg1)\n                    {\n                        //we are not supporting chat base messaging right now\n                        //so we don't listen on the chat itself.\n                        //this should be implemented once we start supporting\n                        //session oriented chats.\n                    }\n                };\n\n            XMPPConnection jabberConnection = jabberProvider.getConnection();\n\n            Chat chat = jabberConnection.getChatManager()\n                .createChat(to.getAddress(), msgListener);\n\n            org.jivesoftware.smack.packet.Message msg =\n                new org.jivesoftware.smack.packet.Message();\n\n            MessageDeliveredEvent msgDeliveryPendingEvt\n            = new MessageDeliveredEvent(\n                    message, to, System.currentTimeMillis());\n\n            msgDeliveryPendingEvt = messageDeliveryPendingTransform(\n                            msgDeliveryPendingEvt);\n\n            if (msgDeliveryPendingEvt == null)\n                return;\n\n            String content = msgDeliveryPendingEvt\n                                    .getSourceMessage().getContent();\n\n            if(message.getContentType().equals(HTML_MIME_TYPE))\n            {\n                msg.setBody(Html2Text.extractText(content));\n\n                // Check if the other user supports XHTML messages\n                if (XHTMLManager.isServiceEnabled(  jabberConnection,\n                                                    chat.getParticipant()))\n                {\n                    // Add the XHTML text to the message\n                    XHTMLManager.addBody(msg,\n                        OPEN_BODY_TAG + content + CLOSE_BODY_TAG);\n                }\n            }\n            else\n            {\n                // this is plain text so keep it as it is.\n                msg.setBody(content);\n            }\n\n            msg.addExtension(new Version());\n\n            MessageEventManager.\n                addNotificationsRequests(msg, true, false, false, true);\n\n            chat.sendMessage(msg);\n\n            MessageDeliveredEvent msgDeliveredEvt\n                = new MessageDeliveredEvent(\n                        message, to, System.currentTimeMillis());\n\n            // msgDeliveredEvt = messageDeliveredTransform(msgDeliveredEvt);\n\n            if (msgDeliveredEvt != null)\n                fireMessageEvent(msgDeliveredEvt);\n        }\n        catch (XMPPException ex)\n        {\n            logger.error(\"message not send\", ex);\n        }\n    }","id":87081,"modified_method":"/**\n     * Sends the <tt>message<\/tt> to the destination indicated by the\n     * <tt>to<\/tt> contact.\n     *\n     * @param to the <tt>Contact<\/tt> to send <tt>message<\/tt> to\n     * @param message the <tt>Message<\/tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to<\/tt> is not an\n     * instance of ContactImpl.\n     */\n    public void sendInstantMessage(Contact to, Message message)\n        throws IllegalStateException, IllegalArgumentException\n    {\n        if( !(to instanceof ContactJabberImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Jabber contact.\"\n               + to);\n\n        try\n        {\n            assertConnected();\n\n            org.jivesoftware.smack.MessageListener msgListener =\n                new org.jivesoftware.smack.MessageListener()\n                {\n                    public void processMessage(\n                        Chat arg0,\n                        org.jivesoftware.smack.packet.Message arg1)\n                    {\n                        //we are not supporting chat base messaging right now\n                        //so we don't listen on the chat itself.\n                        //this should be implemented once we start supporting\n                        //session oriented chats.\n                    }\n                };\n\n            XMPPConnection jabberConnection = jabberProvider.getConnection();\n\n            Chat chat = jabberConnection.getChatManager()\n                .createChat(to.getAddress(), msgListener);\n\n            org.jivesoftware.smack.packet.Message msg =\n                new org.jivesoftware.smack.packet.Message();\n\n            MessageDeliveredEvent msgDeliveryPendingEvt\n                = new MessageDeliveredEvent(message, to);\n\n            msgDeliveryPendingEvt\n                = messageDeliveryPendingTransform(msgDeliveryPendingEvt);\n\n            if (msgDeliveryPendingEvt == null)\n                return;\n\n            String content = msgDeliveryPendingEvt\n                                    .getSourceMessage().getContent();\n\n            if(message.getContentType().equals(HTML_MIME_TYPE))\n            {\n                msg.setBody(Html2Text.extractText(content));\n\n                // Check if the other user supports XHTML messages\n                if (XHTMLManager.isServiceEnabled(  jabberConnection,\n                                                    chat.getParticipant()))\n                {\n                    // Add the XHTML text to the message\n                    XHTMLManager.addBody(msg,\n                        OPEN_BODY_TAG + content + CLOSE_BODY_TAG);\n                }\n            }\n            else\n            {\n                // this is plain text so keep it as it is.\n                msg.setBody(content);\n            }\n\n            msg.addExtension(new Version());\n\n            MessageEventManager.\n                addNotificationsRequests(msg, true, false, false, true);\n\n            chat.sendMessage(msg);\n\n            MessageDeliveredEvent msgDeliveredEvt\n                = new MessageDeliveredEvent(message, to);\n\n            // msgDeliveredEvt = messageDeliveredTransform(msgDeliveredEvt);\n\n            if (msgDeliveredEvt != null)\n                fireMessageEvent(msgDeliveredEvt);\n        }\n        catch (XMPPException ex)\n        {\n            logger.error(\"message not send\", ex);\n        }\n    }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines wheter the protocol supports the supplied content type\n     *\n     * @param contentType the type we want to check\n     * @return <tt>true<\/tt> if the protocol supports it and\n     * <tt>false<\/tt> otherwise.\n     */\n    public boolean isContentTypeSupported(String contentType)\n    {\n        if(contentType.equals(DEFAULT_MIME_TYPE)\n            || contentType.equals(HTML_MIME_TYPE))\n            return true;\n        else\n           return false;\n    }","id":87082,"modified_method":"/**\n     * Determines wheter the protocol supports the supplied content type\n     *\n     * @param contentType the type we want to check\n     * @return <tt>true<\/tt> if the protocol supports it and\n     * <tt>false<\/tt> otherwise.\n     */\n    public boolean isContentTypeSupported(String contentType)\n    {\n        return\n            (contentType.equals(DEFAULT_MIME_TYPE)\n                || contentType.equals(HTML_MIME_TYPE));\n    }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public boolean accept(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return false;\n\n            org.jivesoftware.smack.packet.Message msg\n                = (org.jivesoftware.smack.packet.Message) packet;\n\n            if(msg.getType().equals(\n                org.jivesoftware.smack.packet.Message.Type.groupchat))\n                return false;\n\n            return true;\n        }","id":87083,"modified_method":"public boolean accept(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return false;\n\n            org.jivesoftware.smack.packet.Message msg\n                = (org.jivesoftware.smack.packet.Message) packet;\n\n            return\n                !msg.getType().equals(\n                        org.jivesoftware.smack.packet.Message.Type.groupchat);\n        }","commit_id":"3832b1605ba119c88ab0798a6ee965999a85589f","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Saves the user input when the \"Next\" wizard buttons is clicked.\r\n     */\r\n    public void commitPage()\r\n    {\r\n        GoogleTalkAccountRegistration registration = wizard.getRegistration();\r\n\r\n        String userID = userIDField.getText();\r\n\r\n        if(userID == null || userID.trim().length() == 0)\r\n            throw new IllegalStateException(\"No user ID provided.\");\r\n\r\n        registration.setUserID(userID);\r\n\r\n        registration.setPassword(new String(passField.getPassword()));\r\n        registration.setRememberPassword(rememberPassBox.isSelected());\r\n\r\n        registration.setServerAddress(serverField.getText());\r\n        registration.setSendKeepAlive(sendKeepAliveBox.isSelected());\r\n        registration.setResource(resourceField.getText());\r\n\r\n        if (portField.getText() != null)\r\n            registration.setPort(Integer.parseInt(portField.getText()));\r\n\r\n        if (priorityField.getText() != null)\r\n            registration.setPriority(\r\n                Integer.parseInt(priorityField.getText()));\r\n\r\n        nextPageIdentifier = SUMMARY_PAGE_IDENTIFIER;\r\n\r\n        isCommitted = true;\r\n    }","id":87084,"modified_method":"/**\r\n     * Saves the user input when the \"Next\" wizard buttons is clicked.\r\n     */\r\n    public void commitPage()\r\n    {\r\n        GoogleTalkAccountRegistration registration = wizard.getRegistration();\r\n\r\n        String userID = userIDField.getText();\r\n\r\n        if(userID == null || userID.trim().length() == 0)\r\n            throw new IllegalStateException(\"No user ID provided.\");\r\n\r\n        registration.setUserID(userID);\r\n\r\n        registration.setPassword(new String(passField.getPassword()));\r\n        registration.setRememberPassword(rememberPassBox.isSelected());\r\n\r\n        registration.setServerAddress(serverField.getText());\r\n        registration.setSendKeepAlive(sendKeepAliveBox.isSelected());\r\n        registration.setResource(resourceField.getText());\r\n\r\n        if (portField.getText() != null)\r\n            registration.setPort(Integer.parseInt(portField.getText()));\r\n\r\n        if (priorityField.getText() != null)\r\n            registration.setPriority(\r\n                Integer.parseInt(priorityField.getText()));\r\n\r\n        isCommitted = true;\r\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Creates an instance of <tt>FirstWizardPage<\/tt>.\r\n     *\r\n     * @param wizard the parent wizard\r\n     */\r\n    public FirstWizardPage(GoogleTalkAccountRegistrationWizard wizard)\r\n    {\r\n\r\n        super(new BorderLayout());\r\n\r\n        this.wizard = wizard;\r\n\r\n        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\r\n\r\n        this.init();\r\n\r\n        this.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\r\n\r\n        this.labelsPanel\r\n            .setLayout(new BoxLayout(labelsPanel, BoxLayout.Y_AXIS));\r\n\r\n        this.valuesPanel\r\n            .setLayout(new BoxLayout(valuesPanel, BoxLayout.Y_AXIS));\r\n    }","id":87085,"modified_method":"/**\r\n     * Creates an instance of <tt>FirstWizardPage<\/tt>.\r\n     *\r\n     * @param wizard the parent wizard\r\n     */\r\n    public FirstWizardPage(GoogleTalkAccountRegistrationWizard wizard)\r\n    {\r\n        super(new BorderLayout());\r\n\r\n        this.wizard = wizard;\r\n\r\n        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\r\n\r\n        this.mainPanel.setOpaque(false);\r\n        this.userIDPassPanel.setOpaque(false);\r\n\r\n        this.userIDField.getDocument().addDocumentListener(new DocumentListener()\r\n        {\r\n            public void insertUpdate(DocumentEvent evt)\r\n            {\r\n                setNextButtonAccordingToUserIDAndResource();\r\n\r\n                setServerFieldAccordingToUserID();\r\n            }\r\n\r\n            public void removeUpdate(DocumentEvent evt)\r\n            {\r\n                setNextButtonAccordingToUserIDAndResource();\r\n\r\n                setServerFieldAccordingToUserID();\r\n            }\r\n\r\n            public void changedUpdate(DocumentEvent evt) {}\r\n        });\r\n\r\n        this.rememberPassBox.setSelected(true);\r\n\r\n        this.userIDExampleLabel.setForeground(Color.GRAY);\r\n        this.userIDExampleLabel.setFont(userIDExampleLabel.getFont()\r\n            .deriveFont(8));\r\n        this.userIDExampleLabel.setBorder(BorderFactory.createEmptyBorder(0, 0,\r\n            8, 0));\r\n\r\n        JPanel emptyPanel = new TransparentPanel();\r\n        emptyPanel.setMaximumSize(new Dimension(40, 35));\r\n\r\n        JPanel labelsPanel = new TransparentPanel();\r\n        labelsPanel.setLayout(new BoxLayout(labelsPanel, BoxLayout.Y_AXIS));\r\n        labelsPanel.add(userIDLabel);\r\n        labelsPanel.add(emptyPanel);\r\n        labelsPanel.add(passLabel);\r\n\r\n        JPanel valuesPanel = new TransparentPanel();\r\n        valuesPanel.setLayout(new BoxLayout(valuesPanel, BoxLayout.Y_AXIS));\r\n        valuesPanel.add(userIDField);\r\n        valuesPanel.add(userIDExampleLabel);\r\n        valuesPanel.add(passField);\r\n\r\n        userIDPassPanel.add(labelsPanel, BorderLayout.WEST);\r\n        userIDPassPanel.add(valuesPanel, BorderLayout.CENTER);\r\n        userIDPassPanel.add(rememberPassBox, BorderLayout.SOUTH);\r\n\r\n        userIDPassPanel.setBorder(BorderFactory.createTitledBorder(Resources\r\n            .getString(\"plugin.jabberaccregwizz.USERNAME_AND_PASSWORD\")));\r\n\r\n        mainPanel.add(userIDPassPanel);\r\n\r\n        portField.getDocument().addDocumentListener(new DocumentListener()\r\n        {\r\n            public void changedUpdate(DocumentEvent evt)\r\n            {\r\n            }\r\n\r\n            public void insertUpdate(DocumentEvent evt)\r\n            {\r\n                setNextButtonAccordingToPortAndPriority();\r\n            }\r\n\r\n            public void removeUpdate(DocumentEvent evt)\r\n            {\r\n                setNextButtonAccordingToPortAndPriority();\r\n            }\r\n        });\r\n\r\n        priorityField.getDocument().addDocumentListener(new DocumentListener()\r\n        {\r\n            public void changedUpdate(DocumentEvent evt)\r\n            {\r\n            }\r\n\r\n            public void insertUpdate(DocumentEvent evt)\r\n            {\r\n                setNextButtonAccordingToPortAndPriority();\r\n            }\r\n\r\n            public void removeUpdate(DocumentEvent evt)\r\n            {\r\n                setNextButtonAccordingToPortAndPriority();\r\n            }\r\n        });\r\n\r\n        labelsAdvOpPanel.add(serverLabel);\r\n        labelsAdvOpPanel.add(portLabel);\r\n        labelsAdvOpPanel.add(resourceLabel);\r\n        labelsAdvOpPanel.add(priorityLabel);\r\n\r\n        valuesAdvOpPanel.add(serverField);\r\n        valuesAdvOpPanel.add(portField);\r\n        valuesAdvOpPanel.add(resourceField);\r\n        valuesAdvOpPanel.add(priorityField);\r\n\r\n        JPanel checkBoxesPanel\r\n            = new TransparentPanel(new GridLayout(0, 1, 10, 10));\r\n        checkBoxesPanel.add(sendKeepAliveBox);\r\n\r\n        advancedOpPanel.add(checkBoxesPanel, BorderLayout.NORTH);\r\n        advancedOpPanel.add(labelsAdvOpPanel, BorderLayout.WEST);\r\n        advancedOpPanel.add(valuesAdvOpPanel, BorderLayout.CENTER);\r\n\r\n        advancedOpPanel.setBorder(BorderFactory.createTitledBorder(Resources\r\n            .getString(\"plugin.jabberaccregwizz.ADVANCED_OPTIONS\")));\r\n\r\n        mainPanel.add(advancedOpPanel);\r\n\r\n        registerButton.addActionListener(new ActionListener()\r\n        {\r\n            public void actionPerformed(ActionEvent evt)\r\n            {\r\n                logger.debug(\"Reg OK\");\r\n\r\n                /*\r\n                 * We don't have our own implementation of registering/signing\r\n                 * up with Google Talk so we'll just use webSignup.\r\n                 */\r\n                FirstWizardPage.this.wizard.webSignup();\r\n\r\n                logger.debug(\"Reg End\");\r\n            }\r\n        });\r\n\r\n        buttonPanel.add(registerButton);\r\n\r\n        registerArea.setEditable(false);\r\n        registerArea.setOpaque(false);\r\n        registerArea.setLineWrap(true);\r\n        registerArea.setWrapStyleWord(true);\r\n\r\n        registerPanel.add(registerArea);\r\n        registerPanel.add(buttonPanel);\r\n\r\n        registerPanel.setBorder(BorderFactory.createTitledBorder(Resources\r\n            .getString(\"plugin.googletalkaccregwizz.NEW_ACCOUNT_TITLE\")));\r\n\r\n        mainPanel.add(registerPanel);\r\n\r\n        this.add(mainPanel, BorderLayout.NORTH);\r\n\r\n        this.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\r\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Enables or disables the \"Next\" wizard button according to whether the\r\n     * UserID field is empty.\r\n     */\r\n    private void setNextButtonAccordingToUserIDAndResource()\r\n    {\r\n        if (userIDField.getText() == null\r\n            || userIDField.getText().equals(\"\")\r\n            || resourceField.getText() == null\r\n            || resourceField.getText().equals(\"\"))\r\n        {\r\n            wizard.getWizardContainer().setNextFinishButtonEnabled(false);\r\n        }\r\n        else\r\n        {\r\n            wizard.getWizardContainer().setNextFinishButtonEnabled(true);\r\n        }\r\n    }","id":87086,"modified_method":"/**\r\n     * Enables or disables the \"Next\" wizard button according to whether the\r\n     * UserID field is empty.\r\n     */\r\n    private void setNextButtonAccordingToUserIDAndResource()\r\n    {\r\n        String userID = userIDField.getText();\r\n        boolean enabled;\r\n\r\n        if ((userID == null) || userID.equals(\"\"))\r\n            enabled = false;\r\n        else\r\n        {\r\n            String resource = resourceField.getText();\r\n\r\n            enabled = ((resource != null) && !resource.equals(\"\"));\r\n        }\r\n        wizard.getWizardContainer().setNextFinishButtonEnabled(enabled);\r\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Disables Next Button if Port field value is incorrect\r\n     */\r\n    private void setNextButtonAccordingToPortAndPriority()\r\n    {\r\n        try\r\n        {\r\n            new Integer(portField.getText());\r\n            new Integer(priorityField.getText());\r\n            wizard.getWizardContainer().setNextFinishButtonEnabled(true);\r\n        }\r\n        catch (NumberFormatException ex)\r\n        {\r\n            wizard.getWizardContainer().setNextFinishButtonEnabled(false);\r\n        }\r\n    }","id":87087,"modified_method":"/**\r\n     * Disables Next Button if Port field value is incorrect\r\n     */\r\n    private void setNextButtonAccordingToPortAndPriority()\r\n    {\r\n        boolean enabled;\r\n\r\n        try\r\n        {\r\n            Integer.parseInt(portField.getText());\r\n            Integer.parseInt(priorityField.getText());\r\n            enabled = true;\r\n        }\r\n        catch (NumberFormatException ex)\r\n        {\r\n            enabled = false;\r\n        }\r\n        wizard.getWizardContainer().setNextFinishButtonEnabled(enabled);\r\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Implements the <code>WizardPage.getNextPageIdentifier<\/code> to return\r\n     * the next page identifier - the summary page.\r\n     *\r\n     * @return the id of the next wizard page.\r\n     */\r\n    public Object getNextPageIdentifier()\r\n    {\r\n        return nextPageIdentifier;\r\n    }","id":87088,"modified_method":"/**\r\n     * Implements the <code>WizardPage.getNextPageIdentifier<\/code> to return\r\n     * the next page identifier - the summary page.\r\n     *\r\n     * @return the id of the next wizard page.\r\n     */\r\n    public Object getNextPageIdentifier()\r\n    {\r\n        return SUMMARY_PAGE_IDENTIFIER;\r\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Fills the User ID and Password fields in this panel with the data coming\r\n     * from the given protocolProvider.\r\n     *\r\n     * @param protocolProvider The <tt>ProtocolProviderService<\/tt> to load\r\n     *            the data from.\r\n     */\r\n    public void loadAccount(ProtocolProviderService protocolProvider)\r\n    {\r\n        AccountID accountID = protocolProvider.getAccountID();\r\n\r\n        Map accountProperties = accountID.getAccountProperties();\r\n\r\n        String password = (String) accountProperties.get(\r\n            ProtocolProviderFactory.PASSWORD);\r\n\r\n        this.userIDField.setEnabled(false);\r\n        this.userIDField.setText(accountID.getUserID());\r\n\r\n        if (password != null)\r\n        {\r\n            this.passField.setText(password);\r\n            this.rememberPassBox.setSelected(true);\r\n        }\r\n\r\n        String serverAddress = (String) accountProperties\r\n            .get(ProtocolProviderFactory.SERVER_ADDRESS);\r\n\r\n        serverField.setText(serverAddress);\r\n\r\n        String serverPort = (String) accountProperties\r\n            .get(ProtocolProviderFactory.SERVER_PORT);\r\n\r\n        portField.setText(serverPort);\r\n\r\n        boolean keepAlive = new Boolean((String)accountProperties\r\n            .get(\"SEND_KEEP_ALIVE\")).booleanValue();\r\n\r\n        sendKeepAliveBox.setSelected(keepAlive);\r\n\r\n        String resource = (String) accountProperties.get(\r\n            ProtocolProviderFactory.RESOURCE);\r\n\r\n        resourceField.setText(resource);\r\n\r\n        String priority = (String) accountProperties.get(\r\n            ProtocolProviderFactory.RESOURCE_PRIORITY);\r\n\r\n        priorityField.setText(priority);\r\n\r\n        this.isServerOverridden = accountID.getAccountPropertyBoolean(\r\n            ProtocolProviderFactory.IS_SERVER_OVERRIDDEN, false);\r\n\r\n    }","id":87089,"modified_method":"/**\r\n     * Fills the User ID and Password fields in this panel with the data coming\r\n     * from the given protocolProvider.\r\n     *\r\n     * @param protocolProvider The <tt>ProtocolProviderService<\/tt> to load\r\n     *            the data from.\r\n     */\r\n    public void loadAccount(ProtocolProviderService protocolProvider)\r\n    {\r\n        AccountID accountID = protocolProvider.getAccountID();\r\n\r\n        Map accountProperties = accountID.getAccountProperties();\r\n\r\n        String password = (String) accountProperties.get(\r\n            ProtocolProviderFactory.PASSWORD);\r\n\r\n        this.userIDField.setEnabled(false);\r\n        this.userIDField.setText(accountID.getUserID());\r\n\r\n        if (password != null)\r\n        {\r\n            this.passField.setText(password);\r\n            this.rememberPassBox.setSelected(true);\r\n        }\r\n\r\n        String serverAddress = (String) accountProperties\r\n            .get(ProtocolProviderFactory.SERVER_ADDRESS);\r\n\r\n        serverField.setText(serverAddress);\r\n\r\n        String serverPort = (String) accountProperties\r\n            .get(ProtocolProviderFactory.SERVER_PORT);\r\n\r\n        portField.setText(serverPort);\r\n\r\n        boolean keepAlive\r\n            = Boolean.parseBoolean(\r\n                (String) accountProperties.get(\"SEND_KEEP_ALIVE\"));\r\n\r\n        sendKeepAliveBox.setSelected(keepAlive);\r\n\r\n        String resource = (String) accountProperties.get(\r\n            ProtocolProviderFactory.RESOURCE);\r\n\r\n        resourceField.setText(resource);\r\n\r\n        String priority = (String) accountProperties.get(\r\n            ProtocolProviderFactory.RESOURCE_PRIORITY);\r\n\r\n        priorityField.setText(priority);\r\n\r\n        this.isServerOverridden = accountID.getAccountPropertyBoolean(\r\n            ProtocolProviderFactory.IS_SERVER_OVERRIDDEN, false);\r\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Join a chat room on this server.\n     * \n     * @param chatRoom the chat room to join\n     */\n    public void join(ChatRoom chatRoom)\n    {\n        if (!isInitialized)\n        {\n            joinCache.add(chatRoom);\n\n            return;\n        }\n\n        this.joinChannel(chatRoom.getName());\n\n        Timer joinTimeoutTimer = new Timer();\n\n        joinTimeoutTimers.put(chatRoom, joinTimeoutTimer);\n\n        joinTimeoutTimer.schedule(new JoinTimeoutTask(chatRoom), timeout);\n    }","id":87090,"modified_method":"/**\n     * Join a chat room on this server.\n     * \n     * @param chatRoom the chat room to join\n     */\n    public void join(ChatRoom chatRoom)\n    {\n        if (!isInitialized)\n        {\n            joinCache.add(chatRoom);\n\n            return;\n        }\n\n        this.joinChannel(chatRoom.getName());\n\n        Timer joinTimeoutTimer = new Timer();\n\n        joinTimeoutTimers.put(chatRoom, joinTimeoutTimer);\n\n        joinTimeoutTimer.schedule(new JoinTimeoutTask(chatRoom), TIMEOUT);\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * \n     * @param code The three-digit numerical code for the response.\n     * @param response The full response from the IRC server.\n     * \n     * @see ReplyConstants\n     */\n    protected void onServerResponse (int code, String response)\n    {\n        if (code == ERR_NOSUCHCHANNEL)\n        {\n            logger.error(\"No such channel:\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NOSUCHCHANNEL);\n        }\n        else if (code == ERR_BADCHANMASK)\n        {\n            logger.error(\"Bad channel mask :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_BADCHANMASK);\n        }\n        else if (code == ERR_BADCHANNELKEY)\n        {\n            logger.error(\"Bad channel key :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_BADCHANNELKEY);\n        }\n        else if (code == ERR_BANNEDFROMCHAN)\n        {\n            logger.error(\"Banned from channel :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_BANNEDFROMCHAN);\n        }\n        else if (code == ERR_CHANNELISFULL)\n        {\n            logger.error(\"Channel is full :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_CHANNELISFULL);\n        }\n        else if (code == ERR_CHANOPRIVSNEEDED)\n        {\n            logger.error(\"Channel operator privilages needed :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_CHANOPRIVSNEEDED);\n        }\n        else if (code == ERR_ERRONEUSNICKNAME)\n        {\n            logger.error(\"ERR_ERRONEUSNICKNAME :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_ERRONEUSNICKNAME);\n        }\n        else if (code == ERR_INVITEONLYCHAN)\n        {\n            logger.error(\"Invite only channel :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_INVITEONLYCHAN);\n        }\n        else if (code == ERR_NEEDMOREPARAMS)\n        {\n            logger.error(\"Need more params :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NEEDMOREPARAMS);\n        }\n        else if (code == ERR_NICKCOLLISION)\n        {\n            logger.error(\"Nick collision :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NICKCOLLISION);\n        }\n        else if (code == ERR_NICKNAMEINUSE)\n        {\n            logger.error(\"Nickname in use :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NICKNAMEINUSE);\n        }\n        else if (code == ERR_NONICKNAMEGIVEN)\n        {\n            logger.error(\"No nickname given :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NONICKNAMEGIVEN);\n        }\n        else if (code == ERR_NOTONCHANNEL)\n        {\n            logger.error(\"Not on channel :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NOTONCHANNEL);\n        }\n        else if (code == ERR_TOOMANYCHANNELS)\n        {\n            logger.error(\"Too many channels :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_TOOMANYCHANNELS);\n        }\n        // reply responses\n        else if (code == RPL_WHOISUSER)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n\n            String nickname = tokenizer.nextToken();\n            String login = tokenizer.nextToken();\n            String hostname = tokenizer.nextToken();\n\n            UserInfo userInfo = new UserInfo(nickname, login, hostname);\n\n            this.userInfoTable.put(nickname, userInfo);\n        }\n        else if (code == RPL_WHOISSERVER)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            int end = response.indexOf(':');\n            String serverInfo = response.substring(end + 1);\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                ((UserInfo) userInfoTable.get(userNickName))\n                        .setServerInfo(serverInfo);\n            }\n        }\n        else if (code == RPL_WHOISOPERATOR)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                ((UserInfo) userInfoTable.get(userNickName)).setIrcOp(true);\n            }\n        }\n        else if (code == RPL_WHOISIDLE)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n            long idle = Long.parseLong(tokenizer.nextToken());\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                ((UserInfo) userInfoTable.get(userNickName)).setIdle(idle);\n            }\n        }\n        else if (code == RPL_WHOISCHANNELS)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                ((UserInfo) userInfoTable.get(userNickName))\n                    .clearJoinedChatRoom();\n\n                while(tokenizer.hasMoreTokens())\n                {\n                    String channel = tokenizer.nextToken();\n\n                    if(channel.startsWith(\":\"))\n                        channel = channel.substring(1);\n\n                    ((UserInfo) userInfoTable.get(userNickName))\n                        .addJoinedChatRoom(channel);\n                }\n            }\n        }\n        else if (code == RPL_ENDOFWHOIS)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                UserInfo userInfo\n                    = (UserInfo) userInfoTable.get(userNickName);\n                \n                this.onWhoIs(userInfo);\n            }\n        }\n        else if (code == RPL_ENDOFMOTD)\n        {\n            this.isInitialized = true;\n\n            ArrayList joinCacheCopy = new ArrayList(joinCache);\n\n            joinCache.clear();\n\n            for (int i = 0; i < joinCacheCopy.size(); i ++)\n            {\n                this.join((ChatRoom) joinCacheCopy.get(i));\n            }\n        }\n        else if (code != RPL_LISTSTART\n                    && code != RPL_LIST\n                    && code != RPL_LISTEND\n                    && code != RPL_ENDOFNAMES)\n        {\n            logger.trace(\n                \"Server response: Code : \"\n                + code\n                + \" Response : \"\n                + response);\n\n            int delimiterIndex = response.indexOf(':');\n\n            if(delimiterIndex != -1 && delimiterIndex < response.length() - 1)\n                response = response.substring(delimiterIndex + 1);\n\n            MessageIrcImpl message\n                = new MessageIrcImpl(\n                    response,\n                    MessageIrcImpl.DEFAULT_MIME_TYPE,\n                    MessageIrcImpl.DEFAULT_MIME_ENCODING,\n                    null);\n\n            ChatRoomIrcImpl serverRoom\n                = (ChatRoomIrcImpl) ircMUCOpSet.findSystemRoom();\n\n            ChatRoomMember serverMember = ircMUCOpSet.findSystemMember();\n\n            serverRoom.fireMessageReceivedEvent(\n                    message,\n                    serverMember,\n                    System.currentTimeMillis(),\n                    ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n        }\n    }","id":87091,"modified_method":"/**\n     * \n     * @param code The three-digit numerical code for the response.\n     * @param response The full response from the IRC server.\n     * \n     * @see ReplyConstants\n     */\n    protected void onServerResponse (int code, String response)\n    {\n        if (code == ERR_NOSUCHCHANNEL)\n        {\n            logger.error(\"No such channel:\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NOSUCHCHANNEL);\n        }\n        else if (code == ERR_BADCHANMASK)\n        {\n            logger.error(\"Bad channel mask :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_BADCHANMASK);\n        }\n        else if (code == ERR_BADCHANNELKEY)\n        {\n            logger.error(\"Bad channel key :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_BADCHANNELKEY);\n        }\n        else if (code == ERR_BANNEDFROMCHAN)\n        {\n            logger.error(\"Banned from channel :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_BANNEDFROMCHAN);\n        }\n        else if (code == ERR_CHANNELISFULL)\n        {\n            logger.error(\"Channel is full :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_CHANNELISFULL);\n        }\n        else if (code == ERR_CHANOPRIVSNEEDED)\n        {\n            logger.error(\"Channel operator privilages needed :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_CHANOPRIVSNEEDED);\n        }\n        else if (code == ERR_ERRONEUSNICKNAME)\n        {\n            logger.error(\"ERR_ERRONEUSNICKNAME :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_ERRONEUSNICKNAME);\n        }\n        else if (code == ERR_INVITEONLYCHAN)\n        {\n            logger.error(\"Invite only channel :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_INVITEONLYCHAN);\n        }\n        else if (code == ERR_NEEDMOREPARAMS)\n        {\n            logger.error(\"Need more params :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NEEDMOREPARAMS);\n        }\n        else if (code == ERR_NICKCOLLISION)\n        {\n            logger.error(\"Nick collision :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NICKCOLLISION);\n        }\n        else if (code == ERR_NICKNAMEINUSE)\n        {\n            logger.error(\"Nickname in use :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NICKNAMEINUSE);\n        }\n        else if (code == ERR_NONICKNAMEGIVEN)\n        {\n            logger.error(\"No nickname given :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NONICKNAMEGIVEN);\n        }\n        else if (code == ERR_NOTONCHANNEL)\n        {\n            logger.error(\"Not on channel :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_NOTONCHANNEL);\n        }\n        else if (code == ERR_TOOMANYCHANNELS)\n        {\n            logger.error(\"Too many channels :\" + code\n                + \": Response :\" + response);\n\n            this.notifyChatRoomOperation(ERR_TOOMANYCHANNELS);\n        }\n        // reply responses\n        else if (code == RPL_WHOISUSER)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n\n            String nickname = tokenizer.nextToken();\n            String login = tokenizer.nextToken();\n            String hostname = tokenizer.nextToken();\n\n            UserInfo userInfo = new UserInfo(nickname, login, hostname);\n\n            this.userInfoTable.put(nickname, userInfo);\n        }\n        else if (code == RPL_WHOISSERVER)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            int end = response.indexOf(':');\n            String serverInfo = response.substring(end + 1);\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                userInfoTable.get(userNickName).setServerInfo(serverInfo);\n            }\n        }\n        else if (code == RPL_WHOISOPERATOR)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                userInfoTable.get(userNickName).setIrcOp(true);\n            }\n        }\n        else if (code == RPL_WHOISIDLE)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n            long idle = Long.parseLong(tokenizer.nextToken());\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                userInfoTable.get(userNickName).setIdle(idle);\n            }\n        }\n        else if (code == RPL_WHOISCHANNELS)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                userInfoTable.get(userNickName).clearJoinedChatRoom();\n\n                while(tokenizer.hasMoreTokens())\n                {\n                    String channel = tokenizer.nextToken();\n\n                    if(channel.startsWith(\":\"))\n                        channel = channel.substring(1);\n\n                    userInfoTable.get(userNickName).addJoinedChatRoom(channel);\n                }\n            }\n        }\n        else if (code == RPL_ENDOFWHOIS)\n        {\n            StringTokenizer tokenizer = new StringTokenizer(response);\n            tokenizer.nextToken();\n            String userNickName = tokenizer.nextToken();\n\n            if (userInfoTable.containsKey(userNickName))\n            {\n                UserInfo userInfo = userInfoTable.get(userNickName);\n                \n                this.onWhoIs(userInfo);\n            }\n        }\n        else if (code == RPL_ENDOFMOTD)\n        {\n            this.isInitialized = true;\n\n            ChatRoom[] joinCacheCopy\n                = joinCache.toArray(new ChatRoom[joinCache.size()]);\n\n            joinCache.clear();\n\n            for (ChatRoom joinCacheElement : joinCacheCopy)\n            {\n                this.join(joinCacheElement);\n            }\n        }\n        else if (code != RPL_LISTSTART\n                    && code != RPL_LIST\n                    && code != RPL_LISTEND\n                    && code != RPL_ENDOFNAMES)\n        {\n            logger.trace(\n                \"Server response: Code : \"\n                + code\n                + \" Response : \"\n                + response);\n\n            int delimiterIndex = response.indexOf(':');\n\n            if(delimiterIndex != -1 && delimiterIndex < response.length() - 1)\n                response = response.substring(delimiterIndex + 1);\n\n            MessageIrcImpl message\n                = new MessageIrcImpl(\n                    response,\n                    MessageIrcImpl.DEFAULT_MIME_TYPE,\n                    MessageIrcImpl.DEFAULT_MIME_ENCODING,\n                    null);\n\n            ChatRoomIrcImpl serverRoom\n                = (ChatRoomIrcImpl) ircMUCOpSet.findSystemRoom();\n\n            ChatRoomMember serverMember = ircMUCOpSet.findSystemMember();\n\n            serverRoom.fireMessageReceivedEvent(\n                    message,\n                    serverMember,\n                    System.currentTimeMillis(),\n                    ChatRoomMessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n        }\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Join a chat room on this server.\n     * \n     * @param chatRoom the chat room to join\n     * @param password the password of the chat room\n     */\n    public void join(ChatRoom chatRoom, byte[] password)\n    {\n        this.joinChannel(chatRoom.getName(), new String(password));\n\n        Timer joinTimeoutTimer = new Timer();\n\n        joinTimeoutTimers.put(chatRoom, joinTimeoutTimer);\n        \n        joinTimeoutTimer.schedule(new JoinTimeoutTask(chatRoom), timeout);\n    }","id":87092,"modified_method":"/**\n     * Join a chat room on this server.\n     * \n     * @param chatRoom the chat room to join\n     * @param password the password of the chat room\n     */\n    public void join(ChatRoom chatRoom, byte[] password)\n    {\n        this.joinChannel(chatRoom.getName(), new String(password));\n\n        Timer joinTimeoutTimer = new Timer();\n\n        joinTimeoutTimers.put(chatRoom, joinTimeoutTimer);\n        \n        joinTimeoutTimer.schedule(new JoinTimeoutTask(chatRoom), TIMEOUT);\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * This method is called whenever someone (possibly us) joins a channel\n     * which we are on.\n     * \n     * @param channel The channel which somebody joined.\n     * @param sender The nick of the user who joined the channel.\n     * @param login The login of the user who joined the channel.\n     * @param hostname The host name of the user who joined the channel.\n     */\n    protected void onJoin(  String channel,\n                            String sender,\n                            String login,\n                            String hostname)\n    {\n        logger.trace(\"JOIN on \" + channel + \": Received from \" + sender\n                + \" \" + login + \"@\" + hostname);\n\n        ChatRoomIrcImpl chatRoom\n            = (ChatRoomIrcImpl) ircMUCOpSet.findRoom(channel);\n\n        if(joinTimeoutTimers.containsKey(chatRoom))\n        {\n            Timer timer = (Timer) joinTimeoutTimers.get(chatRoom);\n\n            timer.cancel();\n            joinTimeoutTimers.remove(chatRoom);\n        }\n\n        if(chatRoom.getUserNickname().equals(sender))\n        {\n            ircMUCOpSet.fireLocalUserPresenceEvent(\n                chatRoom,\n                LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED,\n                \"\");\n        }\n        else\n        {\n            ChatRoomMemberIrcImpl member = new ChatRoomMemberIrcImpl(\n                    parentProvider,\n                    chatRoom,\n                    sender,\n                    login,\n                    hostname,\n                    ChatRoomMemberRole.GUEST);\n\n            chatRoom.addChatRoomMember(sender, member);\n\n            //we don't specify a reason\n            chatRoom.fireMemberPresenceEvent(\n                member,\n                null,\n                ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED,\n                null);\n        }\n    }","id":87093,"modified_method":"/**\n     * This method is called whenever someone (possibly us) joins a channel\n     * which we are on.\n     * \n     * @param channel The channel which somebody joined.\n     * @param sender The nick of the user who joined the channel.\n     * @param login The login of the user who joined the channel.\n     * @param hostname The host name of the user who joined the channel.\n     */\n    protected void onJoin(  String channel,\n                            String sender,\n                            String login,\n                            String hostname)\n    {\n        logger.trace(\"JOIN on \" + channel + \": Received from \" + sender\n                + \" \" + login + \"@\" + hostname);\n\n        ChatRoomIrcImpl chatRoom\n            = (ChatRoomIrcImpl) ircMUCOpSet.findRoom(channel);\n\n        if(joinTimeoutTimers.containsKey(chatRoom))\n        {\n            Timer timer = joinTimeoutTimers.get(chatRoom);\n\n            timer.cancel();\n            joinTimeoutTimers.remove(chatRoom);\n        }\n\n        if(chatRoom.getUserNickname().equals(sender))\n        {\n            ircMUCOpSet.fireLocalUserPresenceEvent(\n                chatRoom,\n                LocalUserChatRoomPresenceChangeEvent.LOCAL_USER_JOINED,\n                \"\");\n        }\n        else\n        {\n            ChatRoomMemberIrcImpl member = new ChatRoomMemberIrcImpl(\n                    parentProvider,\n                    chatRoom,\n                    sender,\n                    login,\n                    hostname,\n                    ChatRoomMemberRole.GUEST);\n\n            chatRoom.addChatRoomMember(sender, member);\n\n            //we don't specify a reason\n            chatRoom.fireMemberPresenceEvent(\n                member,\n                null,\n                ChatRoomMemberPresenceChangeEvent.MEMBER_JOINED,\n                null);\n        }\n    }","commit_id":"70ade3308f385e91ff3cd5fcbed824dee30d56e4","url":"https://github.com/jitsi/jitsi"},{"original_method":"public List<BinaryMapDataObject> queryBbox(int lx, int rx, int ty, int by) throws IOException {\n\t\tfinal List<BinaryMapDataObject> result = new ArrayList<BinaryMapDataObject>();\n\t\tBinaryMapIndexReader.SearchRequest<BinaryMapDataObject> sr = BinaryMapIndexReader.buildSearchRequest(lx, rx, ty, by,\n\t\t\t\t5, new BinaryMapIndexReader.SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, BinaryMapIndexReader.MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, new ResultMatcher<BinaryMapDataObject>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject object) {\n\t\t\t\t\t\tif (object.getPointsLength() < 1) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitTypes(object);\n\t\t\t\t\t\tresult.add(object);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treader.searchMapIndex(sr);\n\t\treturn result;\n\t}","id":87094,"modified_method":"public List<BinaryMapDataObject> queryBbox(int lx, int rx, int ty, int by) throws IOException {\n\t\tfinal List<BinaryMapDataObject> result = new ArrayList<BinaryMapDataObject>();\n\t\tBinaryMapIndexReader.SearchRequest<BinaryMapDataObject> sr = BinaryMapIndexReader.buildSearchRequest(lx, rx, ty, by,\n\t\t\t\t5, new BinaryMapIndexReader.SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, BinaryMapIndexReader.MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, new ResultMatcher<BinaryMapDataObject>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject object) {\n\t\t\t\t\t\tif (object.getPointsLength() < 1) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitTypes(object);\n\t\t\t\t\t\tresult.add(object);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\tif(reader != null) {\n\t\t\treader.searchMapIndex(sr);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"f6692765f256a44ec58dac4129935a723657e1d1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void cacheAllCountries() throws IOException {\n\t\tquadTree = new QuadTree<String>(new QuadRect(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE),\n\t\t\t\t8, 0.55f);\n\t\tBinaryMapIndexReader.SearchRequest<BinaryMapDataObject> sr = BinaryMapIndexReader.buildSearchRequest(0, Integer.MAX_VALUE, 0, Integer.MAX_VALUE,\n\t\t\t\t5, new BinaryMapIndexReader.SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, BinaryMapIndexReader.MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, new ResultMatcher<BinaryMapDataObject>() {\n\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject object) {\n\t\t\t\t\t\tif (object.getPointsLength() < 1) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitTypes(object);\n\t\t\t\t\t\tString nm = object.getNameByType(downloadNameType);\n\t\t\t\t\t\tif (!countries.containsKey(nm)) {\n\t\t\t\t\t\t\tLinkedList<BinaryMapDataObject> ls = new LinkedList<BinaryMapDataObject>();\n\t\t\t\t\t\t\tcountries.put(nm, ls);\n\t\t\t\t\t\t\tls.add(object);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcountries.get(nm).add(object);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint maxx = object.getPoint31XTile(0);\n\t\t\t\t\t\tint maxy = object.getPoint31YTile(0);\n\t\t\t\t\t\tint minx = maxx;\n\t\t\t\t\t\tint miny = maxy;\n\t\t\t\t\t\tfor (int i = 1; i < object.getPointsLength(); i++) {\n\t\t\t\t\t\t\tint x = object.getPoint31XTile(i);\n\t\t\t\t\t\t\tint y = object.getPoint31YTile(i);\n\t\t\t\t\t\t\tif (y < miny) {\n\t\t\t\t\t\t\t\tminy = y;\n\t\t\t\t\t\t\t} else if (y > maxy) {\n\t\t\t\t\t\t\t\tmaxy = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x < minx) {\n\t\t\t\t\t\t\t\tminx = x;\n\t\t\t\t\t\t\t} else if (x > maxx) {\n\t\t\t\t\t\t\t\tmaxx = x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tquadTree.insert(nm, new QuadRect(minx, miny, maxx, maxy));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treader.searchMapIndex(sr);\n\t}","id":87095,"modified_method":"public void cacheAllCountries() throws IOException {\n\t\tquadTree = new QuadTree<String>(new QuadRect(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE),\n\t\t\t\t8, 0.55f);\n\t\tBinaryMapIndexReader.SearchRequest<BinaryMapDataObject> sr = BinaryMapIndexReader.buildSearchRequest(0, Integer.MAX_VALUE, 0, Integer.MAX_VALUE,\n\t\t\t\t5, new BinaryMapIndexReader.SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, BinaryMapIndexReader.MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, new ResultMatcher<BinaryMapDataObject>() {\n\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject object) {\n\t\t\t\t\t\tif (object.getPointsLength() < 1) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitTypes(object);\n\t\t\t\t\t\tString nm = object.getNameByType(downloadNameType);\n\t\t\t\t\t\tif (!countries.containsKey(nm)) {\n\t\t\t\t\t\t\tLinkedList<BinaryMapDataObject> ls = new LinkedList<BinaryMapDataObject>();\n\t\t\t\t\t\t\tcountries.put(nm, ls);\n\t\t\t\t\t\t\tls.add(object);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcountries.get(nm).add(object);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tint maxx = object.getPoint31XTile(0);\n\t\t\t\t\t\tint maxy = object.getPoint31YTile(0);\n\t\t\t\t\t\tint minx = maxx;\n\t\t\t\t\t\tint miny = maxy;\n\t\t\t\t\t\tfor (int i = 1; i < object.getPointsLength(); i++) {\n\t\t\t\t\t\t\tint x = object.getPoint31XTile(i);\n\t\t\t\t\t\t\tint y = object.getPoint31YTile(i);\n\t\t\t\t\t\t\tif (y < miny) {\n\t\t\t\t\t\t\t\tminy = y;\n\t\t\t\t\t\t\t} else if (y > maxy) {\n\t\t\t\t\t\t\t\tmaxy = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x < minx) {\n\t\t\t\t\t\t\t\tminx = x;\n\t\t\t\t\t\t\t} else if (x > maxx) {\n\t\t\t\t\t\t\t\tmaxx = x;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tquadTree.insert(nm, new QuadRect(minx, miny, maxx, maxy));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\tif(reader != null) {\n\t\t\treader.searchMapIndex(sr);\n\t\t}\n\t}","commit_id":"f6692765f256a44ec58dac4129935a723657e1d1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private List<BinaryMapDataObject> queryNoInit(final int tile31x, final int tile31y) throws IOException {\n\t\tfinal List<BinaryMapDataObject> result = new ArrayList<BinaryMapDataObject>();\n\t\tBinaryMapIndexReader.SearchRequest<BinaryMapDataObject> sr = BinaryMapIndexReader.buildSearchRequest(tile31x, tile31x, tile31y, tile31y,\n\t\t\t\t5, new BinaryMapIndexReader.SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, BinaryMapIndexReader.MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, new ResultMatcher<BinaryMapDataObject>() {\n\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject object) {\n\t\t\t\t\t\tif (object.getPointsLength() < 1) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitTypes(object);\n\t\t\t\t\t\tif (contain(object, tile31x, tile31y)) {\n\t\t\t\t\t\t\tresult.add(object);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treader.searchMapIndex(sr);\n\t\treturn result;\n\t}","id":87096,"modified_method":"private List<BinaryMapDataObject> queryNoInit(final int tile31x, final int tile31y) throws IOException {\n\t\tfinal List<BinaryMapDataObject> result = new ArrayList<BinaryMapDataObject>();\n\t\tBinaryMapIndexReader.SearchRequest<BinaryMapDataObject> sr = BinaryMapIndexReader.buildSearchRequest(tile31x, tile31x, tile31y, tile31y,\n\t\t\t\t5, new BinaryMapIndexReader.SearchFilter() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean accept(TIntArrayList types, BinaryMapIndexReader.MapIndex index) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}, new ResultMatcher<BinaryMapDataObject>() {\n\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean publish(BinaryMapDataObject object) {\n\t\t\t\t\t\tif (object.getPointsLength() < 1) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitTypes(object);\n\t\t\t\t\t\tif (contain(object, tile31x, tile31y)) {\n\t\t\t\t\t\t\tresult.add(object);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\tif(reader != null) {\n\t\t\treader.searchMapIndex(sr);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"f6692765f256a44ec58dac4129935a723657e1d1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    SafeDeleteLink safeDeleteLink = new SafeDeleteLink();\n    final RefactoringContext refactoringContext = new RefactoringContext(OldRefactoringAdapter.createAdapterFor(safeDeleteLink));\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final String[] linkName = new String[]{null};\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"MyVeryGoodConcept1\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode link = concept.getLinkDeclarations().get(0).getNode();\n        linkName[0] = link.getProperty(\"role\");\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setDoesGenerateModels(false);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              SReference reference = root.getReference(linkName[0]);\n              result[0] = (reference != null);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":87097,"modified_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final Wrappers._T<IRefactoring> refactoring = new Wrappers._T<IRefactoring>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoring.value = RefactoringUtil.getRefactoringByClassName(((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590291(jetbrains.mps.lang.structure.scripts)\", \"1201283571431\"), \"jetbrains.mps.lang.refactoring.structure.OldRefactoring\"), \"call_getGeneratedClassLongName_4598603396803851284\", new Class[]{SNode.class})));\n      }\n    });\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring.value);\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final String[] linkName = new String[]{null};\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"MyVeryGoodConcept1\");\n        SNode link = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"), \"linkDeclaration\", true)).first();\n        linkName[0] = SPropertyOperations.getString(link, \"role\");\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setDoesGenerateModels(false);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              SReference reference = root.getReference(linkName[0]);\n              result[0] = (reference != null);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"e01a9d5a977e7e3d2e690ed4ba104e7ec78721d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final String conceptName = \"MyVeryGoodConcept1\";\n    MoveConcepts moveConcepts = new MoveConcepts();\n    final RefactoringContext refactoringContext = new RefactoringContext(OldRefactoringAdapter.createAdapterFor(moveConcepts));\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final SModelDescriptor[] targetStructureModelDescriptor = new SModelDescriptor[]{null};\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        targetStructureModelDescriptor[0] = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode concept = SModelOperations.getRootByName(model, conceptName);\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(concept);\n        refactoringContext.setSelectedNodes(Arrays.asList(concept));\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(MoveConcepts.targetModel, targetStructureModelDescriptor[0]);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              result[0] = sModel.rootsIterator().next().getConceptFqName().equals(targetStructureModelDescriptor[0].getSModelReference().getSModelFqName() + \".\" + conceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":87098,"modified_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final String conceptName = \"MyVeryGoodConcept1\";\n    final Wrappers._T<IRefactoring> refactoring = new Wrappers._T<IRefactoring>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoring.value = RefactoringUtil.getRefactoringByClassName(((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590291(jetbrains.mps.lang.structure.scripts)\", \"1198173570106\"), \"jetbrains.mps.lang.refactoring.structure.OldRefactoring\"), \"call_getGeneratedClassLongName_4598603396803851284\", new Class[]{SNode.class})));\n      }\n    });\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring.value);\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final SModelDescriptor[] targetStructureModelDescriptor = new SModelDescriptor[]{null};\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        targetStructureModelDescriptor[0] = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode concept = SModelOperations.getRootByName(model, conceptName);\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(concept);\n        refactoringContext.setSelectedNodes(Arrays.asList(concept));\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(\"targetModel\", targetStructureModelDescriptor[0]);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              result[0] = sModel.rootsIterator().next().getConceptFqName().equals(targetStructureModelDescriptor[0].getSModelReference().getSModelFqName() + \".\" + conceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"e01a9d5a977e7e3d2e690ed4ba104e7ec78721d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final String newConceptName = \"MyVeryGoodConcept2\";\n    RenameConcept renameConcept = new RenameConcept();\n    final RefactoringContext refactoringContext = new RefactoringContext(OldRefactoringAdapter.createAdapterFor(renameConcept));\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        final SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        refactoringContext.setParameter(RenameConceptRefactoringTester.STRMD, structureModelDescriptor);\n        SModel model = structureModelDescriptor.getSModel();\n        SNode concept = SModelOperations.getRootByName(model, \"MyVeryGoodConcept1\");\n        refactoringContext.setSelectedNode(concept);\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(\"newName\", newConceptName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              String conceptFqName = sModel.rootsIterator().next().getConceptFqName();\n              SModelDescriptor structureModelDescriptor = (SModelDescriptor) refactoringContext.getParameter(RenameConceptRefactoringTester.STRMD);\n              result[0] = conceptFqName.equals(structureModelDescriptor.getSModelReference().getSModelFqName() + \".\" + newConceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":87099,"modified_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final String newConceptName = \"MyVeryGoodConcept2\";\n    final Wrappers._T<IRefactoring> refactoring = new Wrappers._T<IRefactoring>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoring.value = RefactoringUtil.getRefactoringByClassName(((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590291(jetbrains.mps.lang.structure.scripts)\", \"1198085953023\"), \"jetbrains.mps.lang.refactoring.structure.OldRefactoring\"), \"call_getGeneratedClassLongName_4598603396803851284\", new Class[]{SNode.class})));\n      }\n    });\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring.value);\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        final SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        refactoringContext.setParameter(RenameConceptRefactoringTester.STRMD, structureModelDescriptor);\n        SModel model = structureModelDescriptor.getSModel();\n        SNode concept = SModelOperations.getRootByName(model, \"MyVeryGoodConcept1\");\n        refactoringContext.setSelectedNode(concept);\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(\"newName\", newConceptName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              String conceptFqName = sModel.rootsIterator().next().getConceptFqName();\n              SModelDescriptor structureModelDescriptor = (SModelDescriptor) refactoringContext.getParameter(RenameConceptRefactoringTester.STRMD);\n              result[0] = conceptFqName.equals(structureModelDescriptor.getSModelReference().getSModelFqName() + \".\" + newConceptName);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"e01a9d5a977e7e3d2e690ed4ba104e7ec78721d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    RenameLink renameLink = new RenameLink();\n    final RefactoringContext refactoringContext = new RefactoringContext(OldRefactoringAdapter.createAdapterFor(renameLink));\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final String newLinkName = \"goodConcept\";\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"AbstractGoodConcept\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode link = concept.getLinkDeclarations().get(0).getNode();\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(RenameLink.newName, newLinkName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              result[0] = (root.getChildren(newLinkName).size() == 4);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":87100,"modified_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final Wrappers._T<IRefactoring> refactoring = new Wrappers._T<IRefactoring>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoring.value = RefactoringUtil.getRefactoringByClassName(((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590291(jetbrains.mps.lang.structure.scripts)\", \"1198587937318\"), \"jetbrains.mps.lang.refactoring.structure.OldRefactoring\"), \"call_getGeneratedClassLongName_4598603396803851284\", new Class[]{SNode.class})));\n      }\n    });\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring.value);\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final String newLinkName = \"goodConcept\";\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringTargetLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"AbstractGoodConcept\");\n        SNode link = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"), \"linkDeclaration\", true)).first();\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(\"newName\", newLinkName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              result[0] = (root.getChildren(newLinkName).size() == 4);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"e01a9d5a977e7e3d2e690ed4ba104e7ec78721d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final String newLinkName = \"sister\";\n    RenameLink renameLink = new RenameLink();\n    final RefactoringContext refactoringContext = new RefactoringContext(OldRefactoringAdapter.createAdapterFor(renameLink));\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"MyVeryGoodConcept1\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode link = concept.getLinkDeclarations().get(0).getNode();\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(RenameLink.newName, newLinkName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              SNode referent = root.getReferent(newLinkName);\n              if (referent == null) {\n                System.err.println(\"referent is null\");\n                result[0] = false;\n                return;\n              }\n              result[0] = \"MyGood2\".equals(referent.getName());\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":87101,"modified_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final String newLinkName = \"sister\";\n    final Wrappers._T<IRefactoring> refactoring = new Wrappers._T<IRefactoring>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoring.value = RefactoringUtil.getRefactoringByClassName(((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590291(jetbrains.mps.lang.structure.scripts)\", \"1198587937318\"), \"jetbrains.mps.lang.refactoring.structure.OldRefactoring\"), \"call_getGeneratedClassLongName_4598603396803851284\", new Class[]{SNode.class})));\n      }\n    });\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring.value);\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"MyVeryGoodConcept1\");\n        SNode link = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"), \"linkDeclaration\", true)).first();\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(link);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(\"newName\", newLinkName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              SNode referent = root.getReferent(newLinkName);\n              if (referent == null) {\n                System.err.println(\"referent is null\");\n                result[0] = false;\n                return;\n              }\n              result[0] = \"MyGood2\".equals(referent.getName());\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"e01a9d5a977e7e3d2e690ed4ba104e7ec78721d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    RenameProperty renameProperty = new RenameProperty();\n    final RefactoringContext refactoringContext = new RefactoringContext(OldRefactoringAdapter.createAdapterFor(renameProperty));\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final String newPropertyName = \"niceProperty\";\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"YetAnotherGoodConcept\");\n        ConceptDeclaration concept = (ConceptDeclaration) BaseAdapter.fromNode(node);\n        SNode property = concept.getPropertyDeclarations().get(0).getNode();\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(property);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(RenameProperty.newName, newPropertyName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              SNode firstChild = root.getChildren(\"anotherGoodConcept\").get(0);\n              String propertyValue = firstChild.getProperty(newPropertyName);\n              result[0] = \"cat\".equals(propertyValue);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","id":87102,"modified_method":"public boolean testRefactoring(final Project project, final SModelDescriptor sandbox1, final SModelDescriptor sandbox2, final Language testRefactoringLanguage, final Language testRefactoringTargetLanguage) {\n    final Wrappers._T<IRefactoring> refactoring = new Wrappers._T<IRefactoring>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoring.value = RefactoringUtil.getRefactoringByClassName(((String) BehaviorManager.getInstance().invoke(Object.class, SNodeOperations.cast(SNodeOperations.getNode(\"r:00000000-0000-4000-0000-011c89590291(jetbrains.mps.lang.structure.scripts)\", \"1198764756152\"), \"jetbrains.mps.lang.refactoring.structure.OldRefactoring\"), \"call_getGeneratedClassLongName_4598603396803851284\", new Class[]{SNode.class})));\n      }\n    });\n    final RefactoringContext refactoringContext = new RefactoringContext(refactoring.value);\n    refactoringContext.setCurrentOperationContext(ProjectOperationContext.get(project));\n    final String newPropertyName = \"niceProperty\";\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SModelDescriptor structureModelDescriptor = testRefactoringLanguage.getStructureModelDescriptor();\n        SModel model = structureModelDescriptor.getSModel();\n        SNode node = SModelOperations.getRootByName(model, \"YetAnotherGoodConcept\");\n        SNode property = ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\"), \"propertyDeclaration\", true)).first();\n        refactoringContext.setSelectedProject(project);\n        refactoringContext.setSelectedNode(property);\n        refactoringContext.setSelectedModel(structureModelDescriptor);\n        refactoringContext.setParameter(\"newName\", newPropertyName);\n      }\n    });\n    new RefactoringTestFacade().doExecuteInTest(refactoringContext);\n    final boolean[] result = new boolean[]{false};\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            try {\n              if (sandbox1.getLoadingState() != ModelLoadingState.NOT_LOADED) {\n                System.err.println(\"test environment is invalid: model sandbox1 is already initialized, should be not\");\n                result[0] = false;\n                return;\n              }\n              SModel sModel = sandbox1.getSModel();\n              SNode root = sModel.rootsIterator().next();\n              SNode firstChild = root.getChildren(\"anotherGoodConcept\").get(0);\n              String propertyValue = firstChild.getProperty(newPropertyName);\n              result[0] = \"cat\".equals(propertyValue);\n            } catch (Throwable t) {\n              t.printStackTrace();\n              result[0] = false;\n              return;\n            }\n          }\n        });\n      }\n    });\n    return result[0];\n  }","commit_id":"e01a9d5a977e7e3d2e690ed4ba104e7ec78721d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String getMessagesText() {\n    StringBuffer buff = new StringBuffer();\n    String methodName = this.myParameters.getName();\n    if (methodName.length() == 0) {\n      buff.append(\"Method name is empty.\\n\");\n    } else {\n      boolean nameIsGood = Character.isJavaIdentifierStart(methodName.charAt(0));\n      for (int i = 1; i < methodName.length(); i++) {\n        nameIsGood = nameIsGood && Character.isJavaIdentifierPart(methodName.charAt(0));\n      }\n      if (!(nameIsGood)) {\n        buff.append(\"Method name is incorrect.\");\n      }\n    }\n    String errors = ExtractMethodFabric.getErrors(this.myParameters.getNodesToRefactor());\n    if (errors != null) {\n      buff.append(errors);\n      this.myCanRefactor = false;\n    } else {\n      this.myCanRefactor = true;\n    }\n    SNode overrides = this.myParameters.getOverridingMethodClass();\n    if (overrides != null) {\n      if (overrides == SNodeOperations.getAncestor(this.myParameters.getContainerMethod(), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false)) {\n        buff.append(\"Such method already exists.\\n\");\n      } else {\n        buff.append(\"Method overrides method from class \").append(SPropertyOperations.getString(overrides, \"name\")).append(\"\\n\");\n      }\n    }\n    if (buff.length() == 0) {\n      buff.append(\"\\n\");\n    }\n    return buff.toString();\n  }","id":87103,"modified_method":"private String getMessagesText() {\n    StringBuffer buff = new StringBuffer();\n    String methodName = this.myParameters.getName();\n    if (methodName.length() == 0) {\n      buff.append(\"Method name is empty.\\n\");\n    } else {\n      boolean nameIsGood = Character.isJavaIdentifierStart(methodName.charAt(0));\n      for (int i = 1; i < methodName.length(); i++) {\n        nameIsGood = nameIsGood && Character.isJavaIdentifierPart(methodName.charAt(0));\n      }\n      if (!(nameIsGood)) {\n        buff.append(\"Method name is incorrect.\");\n      }\n    }\n    String errors = ExtractMethodFactory.getErrors(this.myParameters.getNodesToRefactor());\n    if (errors != null) {\n      buff.append(errors);\n      this.myCanRefactor = false;\n    } else {\n      this.myCanRefactor = true;\n    }\n    SNode overrides = this.myParameters.getOverridingMethodClass();\n    if (overrides != null) {\n      if (overrides == SNodeOperations.getAncestor(this.myParameters.getContainerMethod(), \"jetbrains.mps.baseLanguage.structure.Classifier\", false, false)) {\n        buff.append(\"Such method already exists.\\n\");\n      } else {\n        buff.append(\"Method overrides method from class \").append(SPropertyOperations.getString(overrides, \"name\")).append(\"\\n\");\n      }\n    }\n    if (buff.length() == 0) {\n      buff.append(\"\\n\");\n    }\n    return buff.toString();\n  }","commit_id":"5c10ed088cee1e1114625736adf2260893fcb8e7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event) {\n    try {\n      final Wrappers._T<ExtractMethodRefactoringParameters> params = new Wrappers._T<ExtractMethodRefactoringParameters>();\n      final Wrappers._T<ExtractMethodRefactoring> refactoring = new Wrappers._T<ExtractMethodRefactoring>();\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          params.value = new ExtractMethodRefactoringParameters(ExtractMethod_Action.this.nodes);\n          refactoring.value = ExtractMethodFabric.createRefactoring(params.value);\n          params.value.setReturnType(refactoring.value.getMethodType());\n        }\n      });\n      ExtractMethodDialog dialog = new ExtractMethodDialog(ExtractMethod_Action.this.frame, ExtractMethod_Action.this.context, params.value, refactoring.value);\n      dialog.pack();\n      dialog.showDialog();\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"ExtractMethod\", t);\n    }\n  }","id":87104,"modified_method":"public void doExecute(@NotNull final AnActionEvent event) {\n    try {\n      final Wrappers._T<ExtractMethodRefactoringParameters> params = new Wrappers._T<ExtractMethodRefactoringParameters>();\n      final Wrappers._T<ExtractMethodRefactoring> refactoring = new Wrappers._T<ExtractMethodRefactoring>();\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          params.value = new ExtractMethodRefactoringParameters(ExtractMethod_Action.this.nodes);\n          refactoring.value = ExtractMethodFactory.createRefactoring(params.value);\n          params.value.setReturnType(refactoring.value.getMethodType());\n        }\n      });\n      ExtractMethodDialog dialog = new ExtractMethodDialog(ExtractMethod_Action.this.frame, ExtractMethod_Action.this.context, params.value, refactoring.value);\n      dialog.pack();\n      dialog.showDialog();\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"ExtractMethod\", t);\n    }\n  }","commit_id":"5c10ed088cee1e1114625736adf2260893fcb8e7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(AnActionEvent event) {\n    return ExtractMethodFabric.isRefactoringAvailable(ExtractMethod_Action.this.nodes);\n  }","id":87105,"modified_method":"public boolean isApplicable(AnActionEvent event) {\n    return ExtractMethodFactory.isRefactoringAvailable(ExtractMethod_Action.this.nodes);\n  }","commit_id":"5c10ed088cee1e1114625736adf2260893fcb8e7","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doRefactoring() {\n    this.dispose();\n    final Wrappers._T<SNode> result = new Wrappers._T<SNode>();\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        result.value = IntroduceVariableDialog.this.getRefactoring().doRefactoring();\n      }\n    });\n    this.myEditorContext.select(result.value);\n  }","id":87106,"modified_method":"protected void doRefactoring() {\n    this.dispose();\n    final Wrappers._T<List<SNode>> duplicates = new Wrappers._T<List<SNode>>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        SNode expr = IntroduceVariableDialog.this.getRefactoring().getExpression();\n        duplicates.value = new SimpleDuplicatesFinder(expr).findDuplicates(IntroduceVariableDialog.this.getRootToFindDuplicates(expr));\n      }\n    });\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        IntroduceVariableDialog.this.myResult = IntroduceVariableDialog.this.getRefactoring().doRefactoring();\n      }\n    });\n    this.myEditorContext.select(this.myResult);\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        duplicates.value = ListSequence.fromList(duplicates.value).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return VisibilityUtil.isVisible(SNodeOperations.getParent(it), IntroduceVariableDialog.this.myResult);\n          }\n        }).toListSequence();\n      }\n    });\n    this.getDuplicatesProcessor().process(duplicates.value);\n  }","commit_id":"5c10ed088cee1e1114625736adf2260893fcb8e7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MigrationScript fetchScriptForModule(AbstractModule module, MigrationScriptReference scriptReference) {\n    SLanguage depLanguage = scriptReference.getLanguage();\n    int current = scriptReference.getFromVersion();\n    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());\n    if (md == null) {\n      if (LOG.isEnabledFor(Level.WARN)) {\n        LOG.warn(\"Could not load migration descriptor for language \" + depLanguage + \".\");\n      }\n    }\n    MigrationScript script = check_gd1mrb_a0e0s(md, current);\n    if (script == null) {\n      if (LOG.isEnabledFor(Level.WARN)) {\n        LOG.warn(\"Could not load migration script for language \" + depLanguage + \", version \" + current + \".\");\n      }\n      return null;\n    }\n    return script;\n  }","id":87107,"modified_method":"public MigrationScript fetchScript(MigrationScriptReference scriptReference) {\n    SLanguage depLanguage = scriptReference.getLanguage();\n    int current = scriptReference.getFromVersion();\n    MigrationDescriptor md = getMigrationDescriptor((Language) depLanguage.getSourceModule());\n    if (md == null) {\n      if (LOG.isEnabledFor(Level.WARN)) {\n        LOG.warn(\"Could not load migration descriptor for language \" + depLanguage + \".\");\n      }\n    }\n    MigrationScript script = check_gd1mrb_a0e0s(md, current);\n    if (script == null) {\n      if (LOG.isEnabledFor(Level.WARN)) {\n        LOG.warn(\"Could not load migration script for language \" + depLanguage + \", version \" + current + \".\");\n      }\n      return null;\n    }\n    return script;\n  }","commit_id":"c381af32d257b19148678de099f926de0801cc54","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MigrationManager.MigrationState nextStep() {\n    final Wrappers._T<MigrationManager.MigrationState> result = new Wrappers._T<MigrationManager.MigrationState>(null);\n\n    final Map<SModule, Iterable<MigrationScriptReference>> languageVersions = MapSequence.fromMap(new HashMap<SModule, Iterable<MigrationScriptReference>>());\n    final Wrappers._T<Iterable<? extends SModule>> projectModules = new Wrappers._T<Iterable<? extends SModule>>();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        projectModules.value = mpsProject.getModulesWithGenerators();\n      }\n    });\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        Sequence.fromIterable(projectModules.value).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {\n          public void visit(AbstractModule it) {\n            MapSequence.fromMap(languageVersions).put(it, MigrationsUtil.getLanguageVersions(it));\n          }\n        });\n      }\n    });\n    final Iterable<ScriptApplied> allStepScripts = Sequence.fromIterable(projectModules.value).ofType(AbstractModule.class).translate(new ITranslator2<AbstractModule, ScriptApplied>() {\n      public Iterable<ScriptApplied> translate(final AbstractModule module) {\n        return Sequence.fromIterable(MapSequence.fromMap(languageVersions).get(module)).where(new IWhereFilter<MigrationScriptReference>() {\n          public boolean accept(MigrationScriptReference it) {\n            return MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module);\n          }\n        }).select(new ISelector<MigrationScriptReference, MigrationScript>() {\n          public MigrationScript select(MigrationScriptReference it) {\n            return fetchScriptForModule(module, it);\n          }\n        }).where(new IWhereFilter<MigrationScript>() {\n          public boolean accept(MigrationScript script) {\n            return script != null;\n          }\n        }).select(new ISelector<MigrationScript, ScriptApplied>() {\n          public ScriptApplied select(MigrationScript script) {\n            return new ScriptApplied(script, module);\n          }\n        });\n      }\n    }).toListSequence();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        final ScriptApplied nextScript = Sequence.fromIterable(allStepScripts).findFirst(new IWhereFilter<ScriptApplied>() {\n          public boolean accept(ScriptApplied it) {\n            return isAvailable(it);\n          }\n        });\n        if (nextScript != null) {\n          result.value = new MigrationManager.Step() {\n            public String getDescription() {\n              return nextScript.toString();\n            }\n            public boolean execute() {\n              final Wrappers._boolean res = new Wrappers._boolean();\n              ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n                public void run() {\n                  res.value = executeScript(nextScript);\n                }\n              });\n              return res.value;\n            }\n          };\n        } else {\n          result.value = new MigrationManager.Finished() {};\n        }\n      }\n    });\n\n    return result.value;\n  }","id":87108,"modified_method":"public MigrationManager.MigrationState nextStep() {\n    final Wrappers._T<MigrationManager.MigrationState> result = new Wrappers._T<MigrationManager.MigrationState>(null);\n\n    final Map<SModule, Iterable<MigrationScriptReference>> languageVersions = MapSequence.fromMap(new HashMap<SModule, Iterable<MigrationScriptReference>>());\n    final Wrappers._T<Iterable<? extends SModule>> projectModules = new Wrappers._T<Iterable<? extends SModule>>();\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        projectModules.value = mpsProject.getModulesWithGenerators();\n      }\n    });\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        Sequence.fromIterable(projectModules.value).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {\n          public void visit(AbstractModule it) {\n            MapSequence.fromMap(languageVersions).put(it, MigrationsUtil.getLanguageVersions(it));\n          }\n        });\n      }\n    });\n    final List<ScriptApplied> allStepScripts = ListSequence.fromList(new ArrayList<ScriptApplied>());\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        ListSequence.fromList(allStepScripts).addSequence(Sequence.fromIterable(projectModules.value).ofType(AbstractModule.class).translate(new ITranslator2<AbstractModule, ScriptApplied>() {\n          public Iterable<ScriptApplied> translate(final AbstractModule module) {\n            return Sequence.fromIterable(MapSequence.fromMap(languageVersions).get(module)).where(new IWhereFilter<MigrationScriptReference>() {\n              public boolean accept(MigrationScriptReference it) {\n                return MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module);\n              }\n            }).select(new ISelector<MigrationScriptReference, MigrationScript>() {\n              public MigrationScript select(MigrationScriptReference it) {\n                return fetchScript(it);\n              }\n            }).where(new IWhereFilter<MigrationScript>() {\n              public boolean accept(MigrationScript script) {\n                return script != null;\n              }\n            }).select(new ISelector<MigrationScript, ScriptApplied>() {\n              public ScriptApplied select(MigrationScript script) {\n                return new ScriptApplied(script, module);\n              }\n            });\n          }\n        }));\n      }\n    });\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        final ScriptApplied nextScript = ListSequence.fromList(allStepScripts).findFirst(new IWhereFilter<ScriptApplied>() {\n          public boolean accept(ScriptApplied it) {\n            return isAvailable(it);\n          }\n        });\n        if (nextScript != null) {\n          result.value = new MigrationManager.Step() {\n            public String getDescription() {\n              return nextScript.toString();\n            }\n            public boolean execute() {\n              final Wrappers._boolean res = new Wrappers._boolean();\n              ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n                public void run() {\n                  res.value = executeScript(nextScript);\n                }\n              });\n              return res.value;\n            }\n          };\n        } else {\n          result.value = new MigrationManager.Finished() {};\n        }\n      }\n    });\n\n    return result.value;\n  }","commit_id":"c381af32d257b19148678de099f926de0801cc54","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  @Nullable\n  public Tuples._2<Integer, byte[]> mergeContents(FileContent baseContent, FileContent localContent, FileContent latestContent) {\n    if (Boolean.getBoolean(\"mps.mergedriver.model.fail\")) {\n      // fail, so the merge will be done in full MPS \n      return null;\n    }\n\n    RuntimeFlags.setPlayRefactoringsMode(false);\n    RuntimeFlags.setMergeDriverMode(true);\n    LightModelEnvironmentInfoImpl persistenceEnv = new LightModelEnvironmentInfoImpl();\n    PersistenceRegistry.getInstance().setModelEnvironmentInfo(persistenceEnv);\n\n    String ext = (myExtension == null ? MPSExtentions.MODEL : myExtension);\n    if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {\n      // special support for per-root persistence \n      ext = MPSExtentions.MODEL;\n    }\n\n    if (LOG.isInfoEnabled()) {\n      LOG.info(\"Reading models...\");\n    }\n    final SModel baseModel = loadModel(baseContent, ext);\n    final SModel localModel = loadModel(localContent, ext);\n    final SModel latestModel = loadModel(latestContent, ext);\n    if (baseModel == null || localModel == null || latestModel == null) {\n      return backup(baseContent, localContent, latestContent);\n    }\n    myModelName = baseModel.getModelName();\n\n    int baseP = getPersistenceVersion(baseModel);\n    int localP = getPersistenceVersion(localModel);\n    int latestP = getPersistenceVersion(latestModel);\n    if (baseP >= 7 && localP >= 7 && latestP >= 7 || baseP < 7 && localP < 7 && latestP < 7) {\n      // ok, can merge \n    } else {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(String.format(\"%s: Conflicting model persistence versions\", myModelName));\n      }\n      return backup(baseContent, localContent, latestContent);\n    }\n    if (!(persistenceEnv.isConsistent())) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(String.format(\"%s: Inconsistent structure ids or import versions\", myModelName));\n      }\n      return backup(baseContent, localContent, latestContent);\n    }\n\n    try {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"Merging \" + baseModel.getReference() + \"...\");\n      }\n      final Wrappers._T<MergeSession> mergeSession = new Wrappers._T<MergeSession>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          mergeSession.value = MergeSession.createMergeSession(baseModel, localModel, latestModel);\n          int conflictingChangesCount = Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>() {\n            public boolean accept(ModelChange c) {\n              return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();\n            }\n          }).count();\n          if (conflictingChangesCount == 0) {\n            if (LOG.isInfoEnabled()) {\n              LOG.info(String.format(\"%s: %d changes detected: %d local and %d latest.\", myModelName, Sequence.fromIterable(mergeSession.value.getAllChanges()).count(), ListSequence.fromList(mergeSession.value.getMyChangeSet().getModelChanges()).count(), ListSequence.fromList(mergeSession.value.getRepositoryChangeSet().getModelChanges()).count()));\n            }\n            mergeSession.value.applyChanges(mergeSession.value.getAllChanges());\n          } else {\n            if (LOG.isInfoEnabled()) {\n              LOG.info(String.format(\"%s: %d changes detected, %d of them are conflicting\", myModelName, Sequence.fromIterable(mergeSession.value.getAllChanges()).count(), conflictingChangesCount));\n            }\n          }\n        }\n      });\n      if (mergeSession.value.hasIdsToRestore()) {\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: node id duplication detected, should merge in UI.\", myModelName));\n        }\n      } else {\n        String resultString;\n        SModel resultModel = mergeSession.value.getResultModel();\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: Saving merged model...\", myModelName));\n        }\n        updateMetaModelInfo(resultModel, baseModel, localModel, latestModel);\n        if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {\n          // special support for per-root persistence \n          resultString = PersistenceUtil.savePerRootModel(resultModel, MPSExtentions.MODEL_HEADER.equals(myExtension));\n        } else {\n          resultString = PersistenceUtil.saveModel(resultModel, ext);\n        }\n        if (resultString == null) {\n          if (LOG.isEnabledFor(Level.ERROR)) {\n            LOG.error(\"Error while saving result model\");\n          }\n          return backup(baseContent, localContent, latestContent);\n        }\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: merged successfully.\", myModelName));\n        }\n        backup(baseContent, localContent, latestContent);\n        return MultiTuple.<Integer,byte[]>from(MERGED, resultString.getBytes(FileUtil.DEFAULT_CHARSET));\n      }\n    } catch (Throwable e) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"Exception while merging\", e);\n      }\n      return backup(baseContent, localContent, latestContent);\n    }\n\n    return backup(baseContent, localContent, latestContent);\n  }","id":87109,"modified_method":"@Override\n  @Nullable\n  public Tuples._2<Integer, byte[]> mergeContents(FileContent baseContent, FileContent localContent, FileContent latestContent) {\n    if (Boolean.getBoolean(\"mps.mergedriver.model.fail\")) {\n      // fail, so the merge will be done in full MPS \n      return null;\n    }\n\n    RuntimeFlags.setPlayRefactoringsMode(false);\n    RuntimeFlags.setMergeDriverMode(true);\n    LightModelEnvironmentInfoImpl persistenceEnv = new LightModelEnvironmentInfoImpl();\n    PersistenceRegistry.getInstance().setModelEnvironmentInfo(persistenceEnv);\n\n    String ext = (myExtension == null ? MPSExtentions.MODEL : myExtension);\n    if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {\n      // special support for per-root persistence \n      ext = MPSExtentions.MODEL;\n    }\n\n    if (LOG.isInfoEnabled()) {\n      LOG.info(\"Reading models...\");\n    }\n    final SModel baseModel = loadModel(baseContent, ext);\n    final SModel localModel = loadModel(localContent, ext);\n    final SModel latestModel = loadModel(latestContent, ext);\n    if (baseModel == null || localModel == null || latestModel == null) {\n      return backup(baseContent, localContent, latestContent);\n    }\n    myModelName = baseModel.getModelName();\n\n    int baseP = getPersistenceVersion(baseModel);\n    int localP = getPersistenceVersion(localModel);\n    int latestP = getPersistenceVersion(latestModel);\n    if (baseP >= 7 && localP >= 7 && latestP >= 7 || baseP < 7 && localP < 7 && latestP < 7) {\n      // ok, can merge \n    } else {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(String.format(\"%s: Conflicting model persistence versions\", myModelName));\n      }\n      return backup(baseContent, localContent, latestContent);\n    }\n    if (!(persistenceEnv.isConsistent())) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(String.format(\"%s: Inconsistent structure ids or import versions\", myModelName));\n      }\n      return backup(baseContent, localContent, latestContent);\n    }\n\n    try {\n      if (LOG.isInfoEnabled()) {\n        LOG.info(\"Merging \" + baseModel.getReference() + \"...\");\n      }\n      final Wrappers._T<MergeSession> mergeSession = new Wrappers._T<MergeSession>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          mergeSession.value = MergeSession.createMergeSession(baseModel, localModel, latestModel);\n        }\n      });\n      int conflictingChangesCount = Sequence.fromIterable(mergeSession.value.getAllChanges()).where(new IWhereFilter<ModelChange>() {\n        public boolean accept(ModelChange c) {\n          return Sequence.fromIterable(mergeSession.value.getConflictedWith(c)).isNotEmpty();\n        }\n      }).count();\n      if (conflictingChangesCount == 0) {\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: %d changes detected: %d local and %d latest.\", myModelName, Sequence.fromIterable(mergeSession.value.getAllChanges()).count(), ListSequence.fromList(mergeSession.value.getMyChangeSet().getModelChanges()).count(), ListSequence.fromList(mergeSession.value.getRepositoryChangeSet().getModelChanges()).count()));\n        }\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            mergeSession.value.applyChanges(mergeSession.value.getAllChanges());\n          }\n        });\n      } else {\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: %d changes detected, %d of them are conflicting\", myModelName, Sequence.fromIterable(mergeSession.value.getAllChanges()).count(), conflictingChangesCount));\n        }\n        return backup(baseContent, localContent, latestContent);\n      }\n      if (mergeSession.value.hasIdsToRestore()) {\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: node id duplication detected, should merge in UI.\", myModelName));\n        }\n      } else {\n        String resultString;\n        SModel resultModel = mergeSession.value.getResultModel();\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: Saving merged model...\", myModelName));\n        }\n        updateMetaModelInfo(resultModel, baseModel, localModel, latestModel);\n        if (MPSExtentions.MODEL_HEADER.equals(myExtension) || MPSExtentions.MODEL_ROOT.equals(myExtension)) {\n          // special support for per-root persistence \n          resultString = PersistenceUtil.savePerRootModel(resultModel, MPSExtentions.MODEL_HEADER.equals(myExtension));\n        } else {\n          resultString = PersistenceUtil.saveModel(resultModel, ext);\n        }\n        if (resultString == null) {\n          if (LOG.isEnabledFor(Level.ERROR)) {\n            LOG.error(\"Error while saving result model\");\n          }\n          return backup(baseContent, localContent, latestContent);\n        }\n        if (LOG.isInfoEnabled()) {\n          LOG.info(String.format(\"%s: merged successfully.\", myModelName));\n        }\n        backup(baseContent, localContent, latestContent);\n        return MultiTuple.<Integer,byte[]>from(MERGED, resultString.getBytes(FileUtil.DEFAULT_CHARSET));\n      }\n    } catch (Throwable e) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"Exception while merging\", e);\n      }\n    }\n\n    return backup(baseContent, localContent, latestContent);\n  }","commit_id":"f76fd936970ab01c475ec6c856f73f611ffe3596","url":"https://github.com/JetBrains/MPS"},{"original_method":"@BaseDialog.Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOk() {\n    final boolean needToRegenerate = myRegenerateLanguage.getModel().isSelected();\n\n    boolean renamed = ModelAccess.instance().runWriteActionInCommand(new Computable<Boolean>() {\n      public Boolean compute() {\n        final String fqName = myLanguageNameField.getText();\n\n        if (MPSModuleRepository.getInstance().getModuleByUID(fqName) != null) {\n          setErrorText(\"Duplicate language name\");\n          return false;\n        }\n\n        new LanguageRenamer(myProject, myLanguage, fqName).rename(needToRegenerate);\n        return true;\n      }\n    });\n\n    if (!renamed) {\n      return;\n    }\n\n    if (needToRegenerate) {\n      final MPSProject mpsProject = myProject.getComponent(MPSProjectHolder.class).getMPSProject();\n      GenParameters params = ModelAccess.instance().runReadAction(new Computable<GenParameters>() {\n        public GenParameters compute() {\n          ModuleTestConfiguration languageConfig = new ModuleTestConfiguration();\n          languageConfig.setModuleRef(myLanguage.getModuleReference());\n          languageConfig.setName(\"tmp\");\n\n          try {\n            return languageConfig.getGenParams(mpsProject, true);\n          } catch (IllegalGeneratorConfigurationException e) {\n            return null;\n          }\n        }\n      });\n\n      if (params == null) {\n        setErrorText(\"Generator configuration is invalid\");\n        return;\n      }\n\n      myProject.getComponent(GeneratorManager.class)\n        .generateModelsFromDifferentModules(\n          new ModuleContext(myLanguage, mpsProject),\n          params.getModels(),\n          IGenerationType.FILES);\n    }\n\n    dispose();\n  }","id":87110,"modified_method":"@BaseDialog.Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOk() {\n    final boolean needToRegenerate = myRegenerateLanguage.getModel().isSelected();\n\n    boolean renamed = ModelAccess.instance().runWriteActionInCommand(new Computable<Boolean>() {\n      public Boolean compute() {\n        final String fqName = myLanguageNameField.getText();\n\n        if (MPSModuleRepository.getInstance().getModuleByUID(fqName) != null) {\n          setErrorText(\"Duplicate language name\");\n          return false;\n        }\n\n        new LanguageRenamer(myProject, myLanguage, fqName).rename(needToRegenerate);\n        return true;\n      }\n    });\n\n    if (!renamed) {\n      return;\n    }\n\n\n    if (needToRegenerate) {\n\n      final Set<Language> langs = new LinkedHashSet<Language>();\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          langs.add(myLanguage);\n          langs.addAll(MPSModuleRepository.getInstance().getAllExtendingLanguages(myLanguage));\n        }\n      });\n\n      for (final Language l : langs) {\n        final MPSProject mpsProject = myProject.getComponent(MPSProjectHolder.class).getMPSProject();\n        GenParameters params = ModelAccess.instance().runReadAction(new Computable<GenParameters>() {\n          public GenParameters compute() {\n            ModuleTestConfiguration languageConfig = new ModuleTestConfiguration();\n\n            languageConfig.setModuleRef(l.getModuleReference());\n            languageConfig.setName(\"tmp\");\n\n            try {\n              return languageConfig.getGenParams(mpsProject, true);\n            } catch (IllegalGeneratorConfigurationException e) {\n              return null;\n            }\n          }\n        });\n\n        if (params == null) {\n          setErrorText(\"Generator configuration is invalid\");\n          return;\n        }\n\n        myProject.getComponent(GeneratorManager.class)\n          .generateModelsFromDifferentModules(\n            new ModuleContext(myLanguage, mpsProject),\n            params.getModels(),\n            IGenerationType.FILES);\n      }\n    }\n\n    dispose();\n  }","commit_id":"32145abca3c1abc22d36ac15174a0fa65d3ee868","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MergeModelsDialog(final SModel baseModel, final SModel mineModel, final SModel repositoryModel, DiffRequest request) {\n    super(request.getProject(), true);\n    setTitle(\"Merging \" + baseModel.getModelDescriptor().getModelName());\n    SModelDescriptor baseMD = baseModel.getModelDescriptor();\n    SModelDescriptor mineMD = mineModel.getModelDescriptor();\n    SModelDescriptor repMD = repositoryModel.getModelDescriptor();\n    myProject = request.getProject();\n    myContentTitles = request.getContentTitles();\n    assert myContentTitles.length == 3;\n    myMergeSession = MergeSession.createMergeSession(baseModel, mineModel, repositoryModel);\n    DiffTemporaryModule.setSModelId(myMergeSession.getResultModel(), \"result\");\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myInitialState = myMergeSession.getCurrentState();\n      }\n    });\n    if (ListSequence.fromList(myMergeSession.getMetadataChanges()).isNotEmpty()) {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          SModel baseMetaModel = MetadataUtil.createMetadataModel(baseModel);\n          SModel mineMetaModel = MetadataUtil.createMetadataModel(mineModel);\n          SModel repoMetaModel = MetadataUtil.createMetadataModel(repositoryModel);\n          myMetadataMergeSession = MergeSession.createMergeSession(baseMetaModel, mineMetaModel, repoMetaModel);\n          DiffTemporaryModule.setSModelId(myMetadataMergeSession.getResultModel(), \"result\");\n          myMetadataInitialState = myMetadataMergeSession.getCurrentState();\n        }\n      });\n    }\n    final jetbrains.mps.project.Project p = ProjectHelper.toMPSProject(myProject);\n    DiffTemporaryModule.createModuleForModel(myMergeSession.getResultModel(), \"result\", p, true);\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffTemporaryModule.registerModel(myMergeSession.getResultModel().getModelDescriptor(), p);\n      }\n    });\n    myMergeSession.installResultModelListener();\n    DiffTemporaryModule.createModuleForModel(mineModel, \"mine\", p);\n    DiffTemporaryModule.createModuleForModel(repositoryModel, \"repository\", p);\n    if (myMetadataMergeSession != null) {\n      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getResultModel(), \"result\", p, true);\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          DiffTemporaryModule.registerModel(myMetadataMergeSession.getResultModel().getModelDescriptor(), p);\n        }\n      });\n      myMetadataMergeSession.installResultModelListener();\n      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getMyModel(), \"mine\", p);\n      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getRepositoryModel(), \"repository\", p);\n    }\n\n    myMergeTree = new MergeModelsDialog.MergeModelsTree();\n\n    DefaultActionGroup actionGroup = ActionUtils.groupFromActions(new ResetState(this), new MergeNonConflictingRoots(this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this), Separator.getInstance(), new InvokeTextDiffAction(\"Merge as Text (Use Carefully!)\", \"Merge models using text merge for XML contents\", this, request, new MergeTool()));\n    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actionGroup, true);\n    myToolbar.updateActionsImmediately();\n    myPanel.add(myToolbar.getComponent(), BorderLayout.NORTH);\n    myPanel.add(ScrollPaneFactory.createScrollPane(myMergeTree), BorderLayout.CENTER);\n    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey());\n    if (size == null) {\n      myPanel.setPreferredSize(new Dimension(500, 450));\n    }\n    init();\n  }","id":87111,"modified_method":"public MergeModelsDialog(final SModel baseModel, final SModel mineModel, final SModel repositoryModel, DiffRequest request) {\n    super(request.getProject(), true);\n    setTitle(\"Merging \" + baseModel.getModelDescriptor().getModelName());\n    SModelDescriptor baseMD = baseModel.getModelDescriptor();\n    SModelDescriptor mineMD = mineModel.getModelDescriptor();\n    SModelDescriptor repMD = repositoryModel.getModelDescriptor();\n    myProject = request.getProject();\n    myContentTitles = request.getContentTitles();\n    assert myContentTitles.length == 3;\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myMergeSession = MergeSession.createMergeSession(baseModel, mineModel, repositoryModel);\n      }\n    });\n    DiffTemporaryModule.setSModelId(myMergeSession.getResultModel(), \"result\");\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myInitialState = myMergeSession.getCurrentState();\n      }\n    });\n    if (ListSequence.fromList(myMergeSession.getMetadataChanges()).isNotEmpty()) {\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          final SModel baseMetaModel = MetadataUtil.createMetadataModel(baseModel);\n          final SModel mineMetaModel = MetadataUtil.createMetadataModel(mineModel);\n          final SModel repoMetaModel = MetadataUtil.createMetadataModel(repositoryModel);\n          ModelAccess.instance().runReadAction(new Runnable() {\n            public void run() {\n              myMetadataMergeSession = MergeSession.createMergeSession(baseMetaModel, mineMetaModel, repoMetaModel);\n            }\n          });\n          DiffTemporaryModule.setSModelId(myMetadataMergeSession.getResultModel(), \"result\");\n          myMetadataInitialState = myMetadataMergeSession.getCurrentState();\n        }\n      });\n    }\n    final jetbrains.mps.project.Project p = ProjectHelper.toMPSProject(myProject);\n    DiffTemporaryModule.createModuleForModel(myMergeSession.getResultModel(), \"result\", p, true);\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffTemporaryModule.registerModel(myMergeSession.getResultModel().getModelDescriptor(), p);\n      }\n    });\n    myMergeSession.installResultModelListener();\n    DiffTemporaryModule.createModuleForModel(mineModel, \"mine\", p);\n    DiffTemporaryModule.createModuleForModel(repositoryModel, \"repository\", p);\n    if (myMetadataMergeSession != null) {\n      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getResultModel(), \"result\", p, true);\n      ModelAccess.instance().runWriteAction(new Runnable() {\n        public void run() {\n          DiffTemporaryModule.registerModel(myMetadataMergeSession.getResultModel().getModelDescriptor(), p);\n        }\n      });\n      myMetadataMergeSession.installResultModelListener();\n      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getMyModel(), \"mine\", p);\n      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getRepositoryModel(), \"repository\", p);\n    }\n\n    myMergeTree = new MergeModelsDialog.MergeModelsTree();\n\n    DefaultActionGroup actionGroup = ActionUtils.groupFromActions(new ResetState(this), new MergeNonConflictingRoots(this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this), Separator.getInstance(), new InvokeTextDiffAction(\"Merge as Text (Use Carefully!)\", \"Merge models using text merge for XML contents\", this, request, new MergeTool()));\n    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actionGroup, true);\n    myToolbar.updateActionsImmediately();\n    myPanel.add(myToolbar.getComponent(), BorderLayout.NORTH);\n    myPanel.add(ScrollPaneFactory.createScrollPane(myMergeTree), BorderLayout.CENTER);\n    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey());\n    if (size == null) {\n      myPanel.setPreferredSize(new Dimension(500, 450));\n    }\n    init();\n  }","commit_id":"32348c69df3e9edda74f2f63073499a1172caafe","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void write(String className, TestClassResult result, OutputStream output) {\n        try {\n            SimpleXmlWriter writer = new SimpleXmlWriter(output);\n            writer.writeCharacters(\"\\n  \");\n            writer.writeStartElement(\"testsuite\")\n                .attribute(\"name\", className)\n                .attribute(\"tests\", String.valueOf(result.getTestsCount()))\n                .attribute(\"failures\", String.valueOf(result.getFailuresCount()))\n                .attribute(\"errors\", \"0\")\n                .attribute(\"timestamp\", DateUtils.format(result.getStartTime(), DateUtils.ISO8601_DATETIME_PATTERN))\n                .attribute(\"hostname\", hostName)\n                .attribute(\"time\", String.valueOf(result.getDuration() / 1000.0));\n\n            //TODO SF indentation belongs elsewhere\n            writer.writeCharacters(\"\\n  \");\n            writer.writeStartElement(\"properties\");\n            writer.writeEndElement();\n\n            writeTests(writer, result.getResults(), className);\n\n            writer.writeCharacters(\"\\n  \");\n            writer.writeStartElement(\"system-out\");\n            writeOutputs(writer, className, TestOutputEvent.Destination.StdOut);\n            writer.writeEndElement();\n\n            writer.writeCharacters(\"\\n  \");\n            writer.writeStartElement(\"system-err\");\n            writeOutputs(writer, className, TestOutputEvent.Destination.StdErr);\n            writer.writeEndElement();\n            writer.writeCharacters(\"\\n\");\n\n            writer.writeEndElement();\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Problems writing the XML results for class: \" + className, e);\n        }\n    }","id":87112,"modified_method":"public void write(String className, TestClassResult result, OutputStream output) {\n        try {\n            SimpleXmlWriter writer = new SimpleXmlWriter(output);\n            writer.newLine();\n            writer.writeCharacters(\"  \");\n            writer.writeStartElement(\"testsuite\")\n                    .attribute(\"name\", className)\n                    .attribute(\"tests\", String.valueOf(result.getTestsCount()))\n                    .attribute(\"failures\", String.valueOf(result.getFailuresCount()))\n                    .attribute(\"errors\", \"0\")\n                    .attribute(\"timestamp\", DateUtils.format(result.getStartTime(), DateUtils.ISO8601_DATETIME_PATTERN))\n                    .attribute(\"hostname\", hostName)\n                    .attribute(\"time\", String.valueOf(result.getDuration() / 1000.0));\n\n            writer.newLine();\n            //TODO SF indentation belongs elsewhere\n            writer.writeCharacters(\"  \");\n            writer.writeStartElement(\"properties\");\n            writer.writeEndElement();\n\n            writeTests(writer, result.getResults(), className);\n\n            writer.newLine();\n            writer.writeCharacters(\"  \");\n            writer.writeStartElement(\"system-out\");\n            writeOutputs(writer, className, TestOutputEvent.Destination.StdOut);\n            writer.writeEndElement();\n            writer.newLine();\n            writer.writeCharacters(\"  \");\n            writer.writeStartElement(\"system-err\");\n            writeOutputs(writer, className, TestOutputEvent.Destination.StdErr);\n            writer.writeEndElement();\n            writer.newLine();\n\n            writer.writeEndElement();\n        } catch (IOException e) {\n            throw new UncheckedIOException(\"Problems writing the XML results for class: \" + className, e);\n        }\n    }","commit_id":"40deef90769169629b9b78ce3d5929e6c04d0181","url":"https://github.com/gradle/gradle"},{"original_method":"private void writeTests(SimpleXmlWriter writer, Set<TestMethodResult> methodResults, String className) throws IOException {\n        for (TestMethodResult methodResult : methodResults) {\n            writer.writeCharacters(\"\\n    \");\n            String testCase = methodResult.result.getResultType() == TestResult.ResultType.SKIPPED ? \"ignored-testcase\" : \"testcase\";\n            writer.writeStartElement(testCase)\n                    .attribute(\"name\", methodResult.name)\n                    .attribute(\"classname\", className)\n                    .attribute(\"time\", String.valueOf(methodResult.getDuration() / 1000.0));\n\n            for (Throwable failure : methodResult.result.getExceptions()) {\n                writer.writeCharacters(\"\\n      \");\n                writer.writeStartElement(\"failure\")\n                        .attribute(\"message\", failureMessage(failure))\n                        .attribute(\"type\", failure.getClass().getName());\n\n                writer.writeCharacters(stackTrace(failure));\n\n                writer.writeEndElement();\n            }\n\n            writer.writeEndElement();\n        }\n    }","id":87113,"modified_method":"private void writeTests(SimpleXmlWriter writer, Set<TestMethodResult> methodResults, String className) throws IOException {\n        for (TestMethodResult methodResult : methodResults) {\n            writer.newLine();\n            writer.writeCharacters(\"    \");\n            String testCase = methodResult.result.getResultType() == TestResult.ResultType.SKIPPED ? \"ignored-testcase\" : \"testcase\";\n            writer.writeStartElement(testCase)\n                    .attribute(\"name\", methodResult.name)\n                    .attribute(\"classname\", className)\n                    .attribute(\"time\", String.valueOf(methodResult.getDuration() / 1000.0));\n\n            for (Throwable failure : methodResult.result.getExceptions()) {\n                writer.newLine();\n                writer.writeCharacters(\"      \");\n                writer.writeStartElement(\"failure\")\n                        .attribute(\"message\", failureMessage(failure))\n                        .attribute(\"type\", failure.getClass().getName());\n\n                writer.writeCharacters(stackTrace(failure));\n\n                writer.writeEndElement();\n            }\n\n            writer.writeEndElement();\n        }\n    }","commit_id":"40deef90769169629b9b78ce3d5929e6c04d0181","url":"https://github.com/gradle/gradle"},{"original_method":"public static SNode sourceNodeQuery_5336086527852751150(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return ListSequence.fromList(SLinkOperations.getTargets(_context.getNode(), \"item\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.console.base.structure.GeneratedCommand\");\n      }\n    }).last();\n  }","id":87114,"modified_method":"public static SNode sourceNodeQuery_5336086527852751150(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    return SLinkOperations.getTarget(_context.getNode(), \"command\", true);\n  }","commit_id":"d917ebb3b155fe9e137445a30e2d277d0b7cc450","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void doExecute(AnActionEvent event, Map<String, Object> arg) {\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(myRoot, \"history\", true), \"item\", true)).clear();\n      validateImports();\n      setSelection();\n    }","id":87115,"modified_method":"protected void doExecute(AnActionEvent event, Map<String, Object> arg) {\n      SNode command = SLinkOperations.getTarget(SLinkOperations.getTarget(myRoot, \"commandHolder\", true), \"command\", true);\n      SNode newRoot = SConceptOperations.createNewNode(\"jetbrains.mps.console.base.structure.ConsoleRoot\", null);\n      SLinkOperations.setTarget(newRoot, \"commandHolder\", SConceptOperations.createNewNode(\"jetbrains.mps.console.base.structure.CommandHolder\", null), true);\n      SLinkOperations.setTarget(newRoot, \"history\", SConceptOperations.createNewNode(\"jetbrains.mps.console.base.structure.History\", null), true);\n      SLinkOperations.setTarget(SLinkOperations.getTarget(newRoot, \"commandHolder\", true), \"command\", command, true);\n      SModelOperations.addRootNode(myModel, newRoot);\n      myEditor.editNode(newRoot);\n      SNodeOperations.deleteNode(myRoot);\n      myRoot = newRoot;\n      validateImports();\n      setSelection();\n    }","commit_id":"c119581730376ff11be28049579367652376f824","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0a, fqName)) {\n      case 0:\n        return new MqlLinkSelector_Constraints();\n      case 1:\n        return new MqlPropertySelector_Constraints();\n      case 3:\n        return new MqlVarReference_Constraints();\n      case 2:\n        return new MqlQuery_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","id":87116,"modified_method":"public ConstraintsDescriptor getDescriptor(String fqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_2qnle6_a0a0a, fqName)) {\n      case 1:\n        return new MqlLinkSelector_Constraints();\n      case 3:\n        return new MqlPropertySelector_Constraints();\n      case 5:\n        return new MqlVarReference_Constraints();\n      case 4:\n        return new MqlQuery_Constraints();\n      case 2:\n        return new MqlParameterReference_Constraints();\n      case 0:\n        return new MqlAssignment_Constraints();\n      default:\n        // todo: illegal in some cases? \n        return new BaseConstraintsDescriptor(fqName);\n    }\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode virtual_getType_228266671027861783(SNode thisNode) {\n    return MqlExpression_Behavior.call_getType_228266671027861783(ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"expressions\", true)).last());\n  }","id":87117,"modified_method":"public static SNode virtual_getType_228266671027861783(SNode thisNode) {\n    return MqlExpression_Behavior.call_getType_228266671027861783(SLinkOperations.getTarget(thisNode, \"right\", true));\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean _StyleParameter_QueryFunction_j2e473_a0a(SNode node, EditorContext editorContext) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"expressions\", true)).count() > 1;\n  }","id":87118,"modified_method":"private static boolean _StyleParameter_QueryFunction_j2e473_a2a0(SNode node, EditorContext editorContext) {\n    return !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.query.structure.MqlParentheses\")) && !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.query.structure.MqlComma\"));\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean _StyleParameter_QueryFunction_j2e473_a1a0(SNode node, EditorContext editorContext) {\n    return !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.query.structure.MqlParentheses\"));\n  }","id":87119,"modified_method":"private static boolean _StyleParameter_QueryFunction_j2e473_a1a0(SNode node, EditorContext editorContext) {\n    return !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), \"jetbrains.mps.query.structure.MqlComma\"));\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_j2e473_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_j2e473_a\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, new AttributeCalculator<Boolean>() {\n        public Boolean calculate(EditorCell cell) {\n          return MqlComma_Editor._StyleParameter_QueryFunction_j2e473_a0a((cell == null ?\n            null :\n            cell.getSNode()\n          ), (cell == null ?\n            null :\n            cell.getEditorContext()\n          ));\n        }\n      });\n    }\n    editorCell.addEditorCell(this.createRefNodeList_j2e473_a0(editorContext, node));\n    return editorCell;\n  }","id":87120,"modified_method":"private EditorCell createCollection_j2e473_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_j2e473_a\");\n    editorCell.addEditorCell(this.createCollection_j2e473_a0(editorContext, node));\n    return editorCell;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefNodeList_j2e473_a0(EditorContext editorContext, SNode node) {\n    AbstractCellListHandler handler = new MqlComma_Editor.expressionsListHandler_j2e473_a0(node, \"expressions\", editorContext);\n    EditorCell_Collection editorCell = handler.createCells(editorContext, new CellLayout_Indent(), false);\n    editorCell.setCellId(\"refNodeList_expressions\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_INDENT, true);\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, new AttributeCalculator<Boolean>() {\n        public Boolean calculate(EditorCell cell) {\n          return MqlComma_Editor._StyleParameter_QueryFunction_j2e473_a1a0((cell == null ?\n            null :\n            cell.getSNode()\n          ), (cell == null ?\n            null :\n            cell.getEditorContext()\n          ));\n        }\n      });\n    }\n    editorCell.setRole(handler.getElementRole());\n    return editorCell;\n  }","id":87121,"modified_method":"private EditorCell createRefNode_j2e473_a0a(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new RefNodeCellProvider(node, editorContext);\n    provider.setRole(\"left\");\n    provider.setNoTargetText(\"<no left>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    remove_binaryLeft.setCellActions(editorCell, node, editorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected Map<String, ReferenceConstraintsDescriptor> getNotDefaultReferences() {\n    Map<String, ReferenceConstraintsDescriptor> references = new HashMap();\n    references.put(\"var\", new BaseReferenceConstraintsDescriptor(\"var\", this) {\n      @Override\n      public boolean hasOwnScopeProvider() {\n        return true;\n      }\n\n      @Nullable\n      @Override\n      public ReferenceScopeProvider getScopeProvider() {\n        return new BaseReferenceScopeProvider() {\n          @Override\n          public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferenceConstraintsContext _context) {\n            List<SNode> result = new ArrayList<SNode>();\n            SNode current = _context.getEnclosingNode();\n            while ((current != null)) {\n              if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlComma\")) {\n                for (SNode expr : SLinkOperations.getTargets(SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlComma\"), \"expressions\", true)) {\n                  if (expr == current) {\n                    break;\n                  }\n                  if (SNodeOperations.isInstanceOf(expr, \"jetbrains.mps.query.structure.MqlAssignment\")) {\n                    ListSequence.fromList(result).addElement(SNodeOperations.cast(expr, \"jetbrains.mps.query.structure.MqlAssignment\"));\n                  }\n                }\n              }\n              current = SNodeOperations.getParent(current);\n            }\n            return result;\n          }\n\n          @Override\n          public SNodePointer getSearchScopeValidatorNode() {\n            return breakingNode_97d4g1_a0a1a0a0a1a0b0a1a0;\n          }\n        };\n      }\n    });\n    return references;\n  }","id":87122,"modified_method":"@Override\n  protected Map<String, ReferenceConstraintsDescriptor> getNotDefaultReferences() {\n    Map<String, ReferenceConstraintsDescriptor> references = new HashMap();\n    references.put(\"var\", new BaseReferenceConstraintsDescriptor(\"var\", this) {\n      @Override\n      public boolean hasOwnScopeProvider() {\n        return true;\n      }\n\n      @Nullable\n      @Override\n      public ReferenceScopeProvider getScopeProvider() {\n        return new BaseReferenceScopeProvider() {\n          @Override\n          public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferenceConstraintsContext _context) {\n            List<SNode> result = new ArrayList<SNode>();\n            SNode current = _context.getEnclosingNode();\n            if (SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.query.structure.MqlComma\")) {\n              SNode left = SLinkOperations.getTarget(SNodeOperations.cast(_context.getEnclosingNode(), \"jetbrains.mps.query.structure.MqlComma\"), \"left\", true);\n              if (SNodeOperations.isInstanceOf(left, \"jetbrains.mps.query.structure.MqlAssignment\")) {\n                ListSequence.fromList(result).addElement(SNodeOperations.cast(left, \"jetbrains.mps.query.structure.MqlAssignment\"));\n              }\n            }\n            while ((current != null)) {\n              if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlComma\")) {\n                SNode left = SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlComma\"), \"left\", true);\n                if (left != current && SNodeOperations.isInstanceOf(left, \"jetbrains.mps.query.structure.MqlAssignment\")) {\n                  ListSequence.fromList(result).addElement(SNodeOperations.cast(left, \"jetbrains.mps.query.structure.MqlAssignment\"));\n                }\n              }\n              current = SNodeOperations.getParent(current);\n            }\n            return result;\n          }\n\n          @Override\n          public SNodePointer getSearchScopeValidatorNode() {\n            return breakingNode_97d4g1_a0a1a0a0a1a0b0a1a0;\n          }\n        };\n      }\n    });\n    return references;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"static SNode getTargetForRightTransform(@NotNull SNode contextNode, SNode result) {\n    int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(result);\n    SNode targetNode = contextNode;\n    for (SNode parentNode = SNodeOperations.getParent(targetNode); parentNode != null && SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlExpression\") && MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) < prio; parentNode = SNodeOperations.getParent(targetNode)) {\n      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) == -1) {\n        // we do not go through expressions like parentheses or calls \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlBinaryExpr\") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration(\"jetbrains.mps.query.structure.MqlBinaryExpr\", \"left\")) {\n        // if parent expression is BinaryOperation and target is left child of it \n        // then we should rather transform current target \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlDotExpression\") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration(\"jetbrains.mps.query.structure.MqlDotExpression\", \"left\")) {\n        // if parent expression is DotExpression and target is operang (\"left\" part of the expression) \n        // then we should rather transform current target \n        break;\n      }\n      targetNode = SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\");\n    }\n    return targetNode;\n  }","id":87123,"modified_method":"public static SNode getTargetForRightTransform(@NotNull SNode contextNode, SNode result) {\n    int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(result);\n    SNode targetNode = contextNode;\n    for (SNode parentNode = SNodeOperations.getParent(targetNode); parentNode != null && SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlExpression\") && MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) < prio; parentNode = SNodeOperations.getParent(targetNode)) {\n      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) == -1) {\n        // we do not go through expressions like parentheses or calls \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlTriplex\") && SNodeOperations.isInstanceOf(result, \"jetbrains.mps.query.structure.MqlComma\")) {\n        // comma in triplex is ok, need to parenthesise \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlBinaryExpr\") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration(\"jetbrains.mps.query.structure.MqlBinaryExpr\", \"left\")) {\n        // if parent expression is BinaryOperation and target is left child of it \n        // then we should rather transform current target \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlDotExpression\") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration(\"jetbrains.mps.query.structure.MqlDotExpression\", \"left\")) {\n        // if parent expression is DotExpression and target is operang (\"left\" part of the expression) \n        // then we should rather transform current target \n        break;\n      }\n\n      targetNode = SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\");\n    }\n    return targetNode;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"static SNode parenthesiseIfNecessary(@NotNull SNode contextNode) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(contextNode), \"jetbrains.mps.query.structure.MqlBinaryExpr\")) {\n      SNode parentBinaryOperation = SNodeOperations.cast(SNodeOperations.getParent(contextNode), \"jetbrains.mps.query.structure.MqlBinaryExpr\");\n      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(parentBinaryOperation) < MqlExpression_Behavior.call_getPriority_7352592509980890960(contextNode)) {\n        SNode result = SNodeOperations.replaceWithNewChild(contextNode, \"jetbrains.mps.query.structure.MqlParentheses\");\n        SLinkOperations.setTarget(result, \"expr\", contextNode, true);\n        return result;\n      }\n    }\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(contextNode), \"jetbrains.mps.query.structure.MqlDotExpression\")) {\n      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.getParent(contextNode)) < MqlExpression_Behavior.call_getPriority_7352592509980890960(contextNode)) {\n        SNode result = SNodeOperations.replaceWithNewChild(contextNode, \"jetbrains.mps.query.structure.MqlParentheses\");\n        SLinkOperations.setTarget(result, \"expr\", contextNode, true);\n        return result;\n      }\n    }\n    return contextNode;\n  }","id":87124,"modified_method":"public static SNode parenthesiseAndRotateIfNecessary(@NotNull SNode contextNode) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(contextNode), \"jetbrains.mps.query.structure.MqlExpression\")) {\n      int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(SNodeOperations.getParent(contextNode), \"jetbrains.mps.query.structure.MqlExpression\"));\n      boolean needWrapping = prio >= 0 && prio < MqlExpression_Behavior.call_getPriority_7352592509980890960(contextNode);\n      if (!(needWrapping) && prio >= 0 && prio == MqlExpression_Behavior.call_getPriority_7352592509980890960(contextNode)) {\n        if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(contextNode), \"jetbrains.mps.query.structure.MqlTriplex\") && SNodeOperations.getContainingLinkDeclaration(contextNode) != SLinkOperations.findLinkDeclaration(\"jetbrains.mps.query.structure.MqlTriplex\", \"elseexpr\")) {\n          needWrapping = true;\n        }\n      }\n      if (needWrapping) {\n        SNode result = SNodeOperations.replaceWithNewChild(contextNode, \"jetbrains.mps.query.structure.MqlParentheses\");\n        SLinkOperations.setTarget(result, \"expr\", contextNode, true);\n        return result;\n      } else if (SNodeOperations.isInstanceOf(contextNode, \"jetbrains.mps.query.structure.MqlBinaryExpr\")) {\n        PrecedenceUtil.checkOperationWRTPriority(SNodeOperations.cast(contextNode, \"jetbrains.mps.query.structure.MqlBinaryExpr\"));\n      }\n    }\n    return contextNode;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"static SNode getTargetForLeftTransform(SNode context, SNode result) {\n    int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(result);\n    SNode targetNode = context;\n    for (SNode parentNode = SNodeOperations.getParent(targetNode); parentNode != null && SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlExpression\") && MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) < prio; parentNode = SNodeOperations.getParent(targetNode)) {\n      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) == -1) {\n        // we do not go through expressions like parentheses or calls \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlBinaryExpr\") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration(\"jetbrains.mps.query.structure.MqlBinaryExpr\", \"right\")) {\n        // if parent expression is BinaryOperation having higher priority and target is rhigh child of it \n        // then we should rather transform current target and add additional parenthesis around resulting expression \n        break;\n      }\n      targetNode = SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\");\n    }\n    return targetNode;\n  }","id":87125,"modified_method":"static SNode getTargetForLeftTransform(SNode context, SNode result) {\n    int prio = MqlExpression_Behavior.call_getPriority_7352592509980890960(result);\n    SNode targetNode = context;\n    for (SNode parentNode = SNodeOperations.getParent(targetNode); parentNode != null && SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlExpression\") && MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) < prio; parentNode = SNodeOperations.getParent(targetNode)) {\n      if (MqlExpression_Behavior.call_getPriority_7352592509980890960(SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\")) == -1) {\n        // we do not go through expressions like parentheses or calls \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlTriplex\") && SNodeOperations.isInstanceOf(result, \"jetbrains.mps.query.structure.MqlComma\")) {\n        // comma in triplex is ok, need to parenthesise \n        break;\n      }\n      if (SNodeOperations.isInstanceOf(parentNode, \"jetbrains.mps.query.structure.MqlBinaryExpr\") && SNodeOperations.getContainingLinkDeclaration(targetNode) == SLinkOperations.findLinkDeclaration(\"jetbrains.mps.query.structure.MqlBinaryExpr\", \"right\")) {\n        // if parent expression is BinaryOperation having higher priority and target is rhigh child of it \n        // then we should rather transform current target and add additional parenthesis around resulting expression \n        break;\n      }\n      targetNode = SNodeOperations.cast(parentNode, \"jetbrains.mps.query.structure.MqlExpression\");\n    }\n    return targetNode;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_2059702675525956854(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlTriplex\");\n      ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, _context.getSourceNode()) {\n        public SNode doSubstitute(String pattern) {\n          SNode to = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlTriplex\", null);\n          SNode current = _context.getSourceNode();\n          while (SNodeOperations.isInstanceOf(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlBinaryExpr\") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlBinaryExpr\"), \"right\", true) == current) {\n            current = SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlExpression\");\n          }\n          SNodeOperations.replaceWithAnother(current, to);\n          SLinkOperations.setTarget(to, \"condition\", current, true);\n          return to;\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"?\";\n        }\n\n        public String getVisibleMatchingText(String pattern) {\n          return this.getMatchingText(pattern);\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"triplex operator\";\n        }\n      });\n    }\n    return result;\n  }","id":87126,"modified_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_2059702675525956854(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlTriplex\");\n      ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, _context.getSourceNode()) {\n        public SNode doSubstitute(String pattern) {\n          SNode to = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlTriplex\", null);\n          SNode current = _context.getSourceNode();\n          current = PrecedenceUtil.getTargetForRightTransform(current, to);\n          SNodeOperations.replaceWithAnother(current, to);\n          SLinkOperations.setTarget(to, \"condition\", current, true);\n          return PrecedenceUtil.parenthesiseAndRotateIfNecessary(to);\n        }\n\n        public String getMatchingText(String pattern) {\n          return \"?\";\n        }\n\n        public String getVisibleMatchingText(String pattern) {\n          return this.getMatchingText(pattern);\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"triplex operator\";\n        }\n      });\n    }\n    return result;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_7352592509980787934(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlArithmetic\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlArithmeticKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlArithmetic\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForRightTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"left\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048041\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SEnumOperations.getEnumMemberName((item)).toLowerCase() + \" operator\";\n          }\n        });\n      }\n    }\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlCondition\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlConditionKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlCondition\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForRightTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"left\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\") + \" operator\";\n          }\n        });\n      }\n    }\n    return result;\n  }","id":87127,"modified_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_7352592509980787934(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlArithmetic\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlArithmeticKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlArithmetic\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForRightTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"left\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseAndRotateIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048041\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SEnumOperations.getEnumMemberName((item)).toLowerCase() + \" operator\";\n          }\n        });\n      }\n    }\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlCondition\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlConditionKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlCondition\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForRightTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"left\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseAndRotateIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\") + \" operator\";\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_8205627927119749822(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlComma\");\n      ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, _context.getSourceNode()) {\n        public SNode doSubstitute(String pattern) {\n          SNode to = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlComma\", null);\n          SNode current = _context.getSourceNode();\n          while (SNodeOperations.isInstanceOf(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlBinaryExpr\") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlBinaryExpr\"), \"right\", true) == current) {\n            current = SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlExpression\");\n          }\n          SNodeOperations.replaceWithAnother(current, to);\n          ListSequence.fromList(SLinkOperations.getTargets(to, \"expressions\", true)).insertElement(0, current);\n          return ListSequence.fromList(SLinkOperations.getTargets(to, \"expressions\", true)).getElement(1);\n\n        }\n\n        public String getMatchingText(String pattern) {\n          return \",\";\n        }\n\n        public String getVisibleMatchingText(String pattern) {\n          return this.getMatchingText(pattern);\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"comma expression\";\n        }\n      });\n    }\n    return result;\n  }","id":87128,"modified_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_8205627927119749822(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlComma\");\n      ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, _context.getSourceNode()) {\n        public SNode doSubstitute(String pattern) {\n          SNode to = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlComma\", null);\n          SNode current = _context.getSourceNode();\n          current = PrecedenceUtil.getTargetForRightTransform(current, to);\n          SNodeOperations.replaceWithAnother(current, to);\n          SLinkOperations.setTarget(to, \"left\", current, true);\n          PrecedenceUtil.parenthesiseAndRotateIfNecessary(to);\n          return SLinkOperations.getTarget(to, \"right\", true);\n        }\n\n        public String getMatchingText(String pattern) {\n          return \",\";\n        }\n\n        public String getVisibleMatchingText(String pattern) {\n          return this.getMatchingText(pattern);\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"comma expression\";\n        }\n      });\n    }\n    return result;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean sideTransformHintSubstituteActionsBuilder_Precondition_MqlExpression_8205627927119749823(final IOperationContext operationContext, final SideTransformPreconditionContext _context) {\n    SNode current = _context.getSourceNode();\n    while (SNodeOperations.isInstanceOf(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlBinaryExpr\") && SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlBinaryExpr\"), \"right\", true) == current) {\n      current = SNodeOperations.cast(SNodeOperations.getParent(current), \"jetbrains.mps.query.structure.MqlExpression\");\n    }\n    return !(SNodeOperations.isInstanceOf(current, \"jetbrains.mps.query.structure.MqlComma\"));\n  }","id":87129,"modified_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_2268293679705627817(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlComma\");\n      ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, _context.getSourceNode()) {\n        public SNode doSubstitute(String pattern) {\n          SNode to = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlComma\", null);\n          SNode current = _context.getSourceNode();\n          current = PrecedenceUtil.getTargetForLeftTransform(current, to);\n          SNodeOperations.replaceWithAnother(current, to);\n          SLinkOperations.setTarget(to, \"right\", current, true);\n          PrecedenceUtil.parenthesiseAndRotateIfNecessary(to);\n          return SLinkOperations.getTarget(to, \"left\", true);\n        }\n\n        public String getMatchingText(String pattern) {\n          return \",\";\n        }\n\n        public String getVisibleMatchingText(String pattern) {\n          return this.getMatchingText(pattern);\n        }\n\n        public String getDescriptionText(String pattern) {\n          return \"comma expression\";\n        }\n      });\n    }\n    return result;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_8595827001410586465(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlArithmetic\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlArithmeticKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlArithmetic\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForLeftTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"right\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048041\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SEnumOperations.getEnumMemberName((item)).toLowerCase() + \" operator\";\n          }\n        });\n      }\n    }\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlCondition\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlConditionKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlCondition\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForLeftTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"right\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\") + \" operator\";\n          }\n        });\n      }\n    }\n    return result;\n  }","id":87130,"modified_method":"public static List<INodeSubstituteAction> sideTransform_ActionsFactory_MqlExpression_8595827001410586465(final IOperationContext operationContext, final SideTransformActionsBuilderContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlArithmetic\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlArithmeticKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlArithmetic\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForLeftTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"right\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseAndRotateIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048041\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SEnumOperations.getEnumMemberName((item)).toLowerCase() + \" operator\";\n          }\n        });\n      }\n    }\n    {\n      final SNode concept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlCondition\");\n      Calculable calculable = new Calculable() {\n        public Object calculate() {\n          return SEnumOperations.getEnumMembers(SEnumOperations.getEnum(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"MqlConditionKind\"));\n        }\n      };\n      Iterable<SNode> parameterObjects = (Iterable<SNode>) calculable.calculate();\n      assert parameterObjects != null;\n      for (final SNode item : parameterObjects) {\n        ListSequence.fromList(result).addElement(new AbstractSideTransformHintSubstituteAction(concept, item, _context.getSourceNode()) {\n          public SNode doSubstitute(String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(_context.getModel(), \"jetbrains.mps.query.structure.MqlCondition\", _context.getSourceNode());\n            SPropertyOperations.set(result, \"kind\", \"\" + SEnumOperations.getEnumMemberValue((item)));\n            SNode nodeToProcess = PrecedenceUtil.getTargetForLeftTransform(_context.getSourceNode(), result);\n            SNodeOperations.replaceWithAnother(nodeToProcess, result);\n            SLinkOperations.setTarget(result, \"right\", nodeToProcess, true);\n            return PrecedenceUtil.parenthesiseAndRotateIfNecessary(result);\n          }\n\n          public String getMatchingText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\");\n          }\n\n          public String getVisibleMatchingText(String text) {\n            return this.getMatchingText(text);\n          }\n\n          public String getDescriptionText(String text) {\n            return SPropertyOperations.getString(ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getNode(\"r:f9198ffd-e084-425c-aa82-f2db8289f5eb(jetbrains.mps.query.structure)\", \"6762883159245048026\"), \"member\", true)).findFirst(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SPropertyOperations.getString(it, \"internalValue\").equals(SEnumOperations.getEnumMemberValue((item)));\n              }\n            }), \"externalValue\") + \" operator\";\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_MqlExpression_228266671027634830(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlIntLiteral\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode intConst = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.query.structure.MqlIntLiteral\", null);\n            try {\n              SPropertyOperations.set(intConst, \"value\", \"\" + (Integer.parseInt(pattern)));\n            } catch (NumberFormatException e) {\n              SPropertyOperations.set(intConst, \"value\", \"\" + (0));\n            }\n            return intConst;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            if (strictly) {\n              return REGEXP_x583g4_a0a0a0a2a0a0a0a2a0a1a4.matcher(pattern).matches();\n            } else {\n              return REGEXP_x583g4_a0a0a0a0c0a0a0a0c0a0b0e.matcher(pattern).matches();\n            }\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"integer literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return pattern;\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlBoolLiteral\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.query.structure.MqlBoolLiteral\", null);\n            SPropertyOperations.set(result, \"value\", \"\" + (true));\n            return result;\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"true literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"true\";\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlBoolLiteral\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.query.structure.MqlBoolLiteral\", null);\n            SPropertyOperations.set(result, \"value\", \"\" + (false));\n            return result;\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"false literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"false\";\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","id":87131,"modified_method":"public static List<INodeSubstituteAction> nodeSubstituteActionsBuilder_ActionsFactory_MqlExpression_228266671027634830(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context) {\n    List<INodeSubstituteAction> result = ListSequence.fromList(new ArrayList<INodeSubstituteAction>());\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlIntLiteral\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode intConst = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.query.structure.MqlIntLiteral\", null);\n            try {\n              SPropertyOperations.set(intConst, \"value\", \"\" + (Integer.parseInt(pattern)));\n            } catch (NumberFormatException e) {\n              SPropertyOperations.set(intConst, \"value\", \"\" + (0));\n            }\n            return intConst;\n          }\n\n          public boolean hasSubstitute() {\n            return true;\n          }\n\n          public boolean canSubstitute_internal(String pattern, boolean strictly) {\n            if (strictly) {\n              return REGEXP_x583g4_a0a0a0a2a0a0a0a2a0a1a3.matcher(pattern).matches();\n            } else {\n              return REGEXP_x583g4_a0a0a0a0c0a0a0a0c0a0b0d.matcher(pattern).matches();\n            }\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"integer literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return (StringUtils.isEmpty(pattern) ?\n              \"0\" :\n              pattern\n            );\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlBoolLiteral\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.query.structure.MqlBoolLiteral\", null);\n            SPropertyOperations.set(result, \"value\", \"\" + (true));\n            return result;\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"true literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"true\";\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    {\n      SNode outputConcept = SConceptOperations.findConceptDeclaration(\"jetbrains.mps.query.structure.MqlBoolLiteral\");\n      SNode childConcept = (SNode) _context.getChildConcept();\n      if (outputConcept == null || SConceptOperations.isSuperConceptOf(childConcept, NameUtil.nodeFQName(outputConcept))) {\n        ListSequence.fromList(result).addElement(new DefaultSimpleSubstituteAction(outputConcept, _context.getParentNode(), _context.getCurrentTargetNode(), _context.getChildSetter(), operationContext.getScope()) {\n          public SNode createChildNode(Object parameterObject, SModel model, String pattern) {\n            SNode result = SNodeFactoryOperations.createNewNode(model, \"jetbrains.mps.query.structure.MqlBoolLiteral\", null);\n            SPropertyOperations.set(result, \"value\", \"\" + (false));\n            return result;\n          }\n\n          public String getDescriptionText(String pattern) {\n            return \"false literal\";\n          }\n\n          public String getMatchingText(String pattern) {\n            return \"false\";\n          }\n\n          public String getVisibleMatchingText(String pattern) {\n            return this.getMatchingText(pattern);\n          }\n        });\n      }\n    }\n    return result;\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlArithmetic\", \"jetbrains.mps.query.structure.MqlBinaryExpr\", false, new String[]{\"jetbrains.mps.query.structure.MqlBinaryExpr\"}, new String[]{\"kind\"}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlAssignment\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlBinaryExpr\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlBoolLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"value\"}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlBoolType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlClosure\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlComma\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlCondition\", \"jetbrains.mps.query.structure.MqlBinaryExpr\", false, new String[]{\"jetbrains.mps.query.structure.MqlBinaryExpr\"}, new String[]{\"kind\"}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlDotExpression\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlExpression\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlFunctionType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlIntLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"value\"}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlIntType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlLinkSelector\", \"jetbrains.mps.query.structure.MqlSelector\", false, new String[]{\"jetbrains.mps.query.structure.MqlSelector\"}, new String[]{}, new String[]{\"link\"});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlListType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNoContextQueryCall\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{\"query\"});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNodeType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{\"concept\"});\n      case 17:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNullLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 18:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNullType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 19:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlPackage\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 20:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlParameter\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 21:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlParameterReference\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{\"parameter\"});\n      case 22:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlParentheses\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 23:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlPropertySelector\", \"jetbrains.mps.query.structure.MqlSelector\", false, new String[]{\"jetbrains.mps.query.structure.MqlSelector\"}, new String[]{}, new String[]{\"property\"});\n      case 24:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlQuery\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 25:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlSelector\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 26:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlStringLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"value\"}, new String[]{});\n      case 27:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlStringType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 28:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlThis\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 29:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlTriplex\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 30:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlType\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 31:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlUnary\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"kind\"}, new String[]{});\n      case 32:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlVarReference\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{\"var\"});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":87132,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlArithmetic\", \"jetbrains.mps.query.structure.MqlBinaryExpr\", false, new String[]{\"jetbrains.mps.query.structure.MqlBinaryExpr\"}, new String[]{\"kind\"}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlAssignment\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlBinaryExpr\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlBoolLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"value\"}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlBoolType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlClosure\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\", \"jetbrains.mps.query.structure.MqlParametersContainer\"}, new String[]{}, new String[]{});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlComma\", \"jetbrains.mps.query.structure.MqlBinaryExpr\", false, new String[]{\"jetbrains.mps.query.structure.MqlBinaryExpr\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlCondition\", \"jetbrains.mps.query.structure.MqlBinaryExpr\", false, new String[]{\"jetbrains.mps.query.structure.MqlBinaryExpr\"}, new String[]{\"kind\"}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlDotExpression\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlExpression\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlFunctionType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 11:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlIntLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"value\"}, new String[]{});\n      case 12:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlIntType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 13:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlLinkSelector\", \"jetbrains.mps.query.structure.MqlSelector\", false, new String[]{\"jetbrains.mps.query.structure.MqlSelector\"}, new String[]{}, new String[]{\"link\"});\n      case 14:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlListType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 15:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNoContextQueryCall\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{\"query\"});\n      case 16:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNodeType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{\"concept\"});\n      case 17:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNullLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 18:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlNullType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 19:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlPackage\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 20:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlParameter\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\"}, new String[]{}, new String[]{});\n      case 21:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlParameterReference\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{\"parameter\"});\n      case 22:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlParametersContainer\", null, true, new String[]{}, new String[]{}, new String[]{});\n      case 23:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlParentheses\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 24:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlPropertySelector\", \"jetbrains.mps.query.structure.MqlSelector\", false, new String[]{\"jetbrains.mps.query.structure.MqlSelector\"}, new String[]{}, new String[]{\"property\"});\n      case 25:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlQuery\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.lang.core.structure.INamedConcept\", \"jetbrains.mps.query.structure.MqlParametersContainer\"}, new String[]{}, new String[]{});\n      case 26:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlSelector\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 27:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlStringLiteral\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"value\"}, new String[]{});\n      case 28:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlStringType\", \"jetbrains.mps.query.structure.MqlType\", false, new String[]{\"jetbrains.mps.query.structure.MqlType\"}, new String[]{}, new String[]{});\n      case 29:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlThis\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 30:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlTriplex\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{});\n      case 31:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlType\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 32:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlUnary\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{\"kind\"}, new String[]{});\n      case 33:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.query.structure.MqlVarReference\", \"jetbrains.mps.query.structure.MqlExpression\", false, new String[]{\"jetbrains.mps.query.structure.MqlExpression\"}, new String[]{}, new String[]{\"var\"});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"0ebf8a515052bc503d643e1b2f8bffa33742ad11","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\r\n   * Returns true if big rectangle, false else.\r\n   * @param rn root\r\n   * @param lv level\r\n   * @return boolean\r\n   */\r\n  boolean isBigRectangle(final int rn, final int lv) {\r\n    return getTreeBorder(rn, lv).size > rects[rn][lv].length;\r\n  }","id":87133,"modified_method":"/**\r\n   * Returns true if big rectangle, false else.\r\n   * @param rn root\r\n   * @param lv level\r\n   * @return boolean\r\n   */\r\n  boolean isBigRectangle(final int rn, final int lv) {\r\n    return !(getTreeBorder(rn, lv).size == rects[rn][lv].length);\r\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Determines nodes in each level and caches them.\r\n   * @param data data reference\r\n   */\r\n  private void cacheNodes(final Data data) {\r\n\r\n    // long time = System.currentTimeMillis();\r\n\r\n    if(USE_CHILDITERATOR) {\r\n      IntList parList = new IntList(1);\r\n      parList.add(0);\r\n      nodes = new IntList[maxLevel];\r\n      int l = 0;\r\n      while(maxLevel > l) {\r\n        nodes[l++] = parList;\r\n        parList = getNextNodeLine(parList, data);\r\n      }\r\n    } else {\r\n      final IntList[] li = new IntList[maxLevel];\r\n      for(int i = 0; i < maxLevel; i++)\r\n        li[i] = new IntList();\r\n      final int ts = data.meta.size;\r\n      final int[] lvlPre = new int[maxLevel];\r\n      li[0].add(0);\r\n      lvlPre[0] = 0;\r\n      for(int p = 1; p < ts; p++) {\r\n        final int k = data.kind(p);\r\n        if(k == Data.ATTR) continue;\r\n        int lv = 0;\r\n        final int par = data.parent(p, k);\r\n        while(par != lvlPre[lv])\r\n          lv++;\r\n        lvlPre[lv + 1] = p;\r\n        li[lv + 1].add(p);\r\n      }\r\n      nodes = li;\r\n    }\r\n  }","id":87134,"modified_method":"/**\r\n   * Determines nodes in each level and caches them.\r\n   * @param data data reference\r\n   */\r\n  private void cacheNodes(final Data data) {\r\n\r\n    // long time = System.currentTimeMillis();\r\n\r\n    if(USE_CHILDITERATOR) {\r\n      IntList parList = new IntList(1);\r\n      parList.add(0);\r\n      nodes = new IntList[maxLevel];\r\n      int l = 0;\r\n      while(maxLevel > l) {\r\n        nodes[l++] = parList;\r\n        parList = getNextNodeLine(parList, data);\r\n      }\r\n    } else {\r\n      final IntList[] li = new IntList[maxLevel];\r\n      for(int i = 0; i < maxLevel; i++)\r\n        li[i] = new IntList();\r\n      final int ts = data.meta.size;\r\n      final int[] lvlPre = new int[maxLevel];\r\n      li[0].add(0);\r\n      lvlPre[0] = 0;\r\n      for(int p = 1; p < ts; p++) {\r\n        final int k = data.kind(p);\r\n        if(!SHOW_ATTR && k == Data.ATTR) continue;\r\n        int lv = 0;\r\n        final int par = data.parent(p, k);\r\n        while(par != lvlPre[lv])\r\n          lv++;\r\n        lvlPre[lv + 1] = p;\r\n        li[lv + 1].add(p);\r\n      }\r\n      nodes = li;\r\n    }\r\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns index of pre.\r\n   * @param rn root\r\n   * @param lv level\r\n   * @param pre pre\r\n   * @return index\r\n   */\r\n  int getPreIndex(final int rn, final int lv, final int pre) {\r\n    final TreeBorder bo = getTreeBorder(rn, lv);\r\n    return searchPreIndex(bo.level, pre, pre, bo.start, bo.size - 1) - bo.start;\r\n  }","id":87135,"modified_method":"/**\r\n   * Returns index of pre.\r\n   * @param rn root\r\n   * @param lv level\r\n   * @param pre pre\r\n   * @return index\r\n   */\r\n  int getPreIndex(final int rn, final int lv, final int pre) {\r\n    final TreeBorder bo = getTreeBorder(rn, lv);\r\n    return searchPreIndex(bo.level, pre, pre, bo.start, bo.start + bo.size - 1)\r\n        - bo.start;\r\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates normal rectangles.\r\n   * @param g graphics reference\r\n   * @param rn root\r\n   * @param lv level\r\n   * @param c context\r\n   * @param w width\r\n   * @param bo TreeBorder\r\n   */\r\n  private void normalRectangle(final Graphics g, final int rn, final int lv,\r\n      final Context c, final double w, final TreeBorder bo) {\r\n\r\n // new array, to be filled with the rectangles of the current level\r\n    rects[rn][lv] = new TreeRect[bo.size];\r\n\r\n    double xx = rn * w * bo.size + LEFT_RIGHT_MARGIN;\r\n    double ww = w;\r\n\r\n    for(int i = bo.start; i < bo.start + bo.size; i++) {\r\n\r\n      if(SLIM_TO_TEXT) {\r\n        final double boxMiddle = xx + ww / 2f;\r\n        final byte[] b = getText(c, rn, nodes[bo.level].get(i));\r\n        int o = calcOptimalRectWidth(g, b) + 10;\r\n        if(o < MIN_TXT_SPACE) o = MIN_TXT_SPACE;\r\n        if(w > o) {\r\n          xx = boxMiddle - o / 2d;\r\n          ww = o;\r\n        }\r\n      }\r\n      rects[rn][lv][i - bo.start] = new TreeRect((int) xx, (int) ww);\r\n\r\n      xx += w;\r\n    }\r\n  }","id":87136,"modified_method":"/**\r\n   * Creates normal rectangles.\r\n   * @param g graphics reference\r\n   * @param rn root\r\n   * @param lv level\r\n   * @param c context\r\n   * @param w width\r\n   * @param bo TreeBorder\r\n   */\r\n  private void normalRectangle(final Graphics g, final int rn, final int lv,\r\n      final Context c, final double w, final TreeBorder bo) {\r\n\r\n    // new array, to be filled with the rectangles of the current level\r\n    rects[rn][lv] = new TreeRect[bo.size];\r\n\r\n    double xx = rn * w * bo.size;\r\n    double ww = w;\r\n\r\n    for(int i = bo.start; i < bo.start + bo.size; i++) {\r\n\r\n      if(SLIM_TO_TEXT) {\r\n        final double boxMiddle = xx + ww / 2f;\r\n        final byte[] b = getText(c, rn, nodes[bo.level].get(i));\r\n        int o = calcOptimalRectWidth(g, b) + 10;\r\n        if(o < MIN_TXT_SPACE) o = MIN_TXT_SPACE;\r\n        if(w > o) {\r\n          xx = boxMiddle - o / 2d;\r\n          ww = o;\r\n        }\r\n      }\r\n      rects[rn][lv][i - bo.start] = new TreeRect((int) xx + BORDER_PADDING,\r\n          (int) ww - BORDER_PADDING);\r\n\r\n      xx += w;\r\n    }\r\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Create new rectangles and set subtree borders.\r\n   * @param g graphics reference\r\n   * @param c context\r\n   * @param sw screen width\r\n   * @return tree distance\r\n   */\r\n  double generateBordersAndRects(final Graphics g,\r\n      final Context c, final int sw) {\r\n    final Data d = c.current.data;\r\n    final int[] roots = c.current.nodes;\r\n    final int rl = roots.length;\r\n    if(rl == 0) return -1;\r\n    final TreeBorder[][] bo = new TreeBorder[rl][];\r\n    final double w = sw / (double) rl - 2 * LEFT_RIGHT_MARGIN;\r\n    if(w == 0) return -1;\r\n    rects = new TreeRect[rl][][];\r\n\r\n    for(int i = 0; i < rl; i++) {\r\n      bo[i] = generateSubtreeBorders(d, roots[i]);\r\n      generateRects(g, i, c, bo[i], w);\r\n    }\r\n    border = bo;\r\n    return w;\r\n  }","id":87137,"modified_method":"/**\r\n   * Create new rectangles and set subtree borders.\r\n   * @param g graphics reference\r\n   * @param c context\r\n   * @param sw screen width\r\n   * @return tree distance\r\n   */\r\n  double generateBordersAndRects(final Graphics g, \r\n  final Context c, final int sw) {\r\n    final Data d = c.current.data;\r\n    final int[] roots = c.current.nodes;\r\n    final int rl = roots.length;\r\n    if(rl == 0) return -1;\r\n    final TreeBorder[][] bo = new TreeBorder[rl][];\r\n    final double w = (sw - BORDER_PADDING) / (double) rl;\r\n    if(w == 0) return -1;\r\n    rects = new TreeRect[rl][][];\r\n\r\n    for(int i = 0; i < rl; i++) {\r\n      bo[i] = generateSubtreeBorders(d, roots[i]);\r\n      generateRects(g, i, c, bo[i], w);\r\n    }\r\n    border = bo;\r\n    return w;\r\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Invoked if not enough space for more than one big rectangle.\r\n   * @param rn root\r\n   * @param lv level\r\n   * @param w the width\r\n   */\r\n  private void bigRectangle(final int rn, final int lv, final double w) {\r\n    rects[rn][lv] = new TreeRect[1];\r\n    rects[rn][lv][0] = new TreeRect((int)\r\n        (w * rn) + LEFT_RIGHT_MARGIN, (int) w);\r\n  }","id":87138,"modified_method":"/**\r\n   * Invoked if not enough space for more than one big rectangle.\r\n   * @param rn root\r\n   * @param lv level\r\n   * @param w the width\r\n   */\r\n  private void bigRectangle(final int rn, final int lv, final double w) {\r\n    rects[rn][lv] = new TreeRect[1];\r\n    rects[rn][lv][0] = new TreeRect((int) (w * rn) + BORDER_PADDING, (int) w\r\n        - BORDER_PADDING);\r\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Verifies if the specified coordinates are inside the rectangle.\r\n   * @param xx x position\r\n   * @return result of comparison\r\n   */\r\n  public boolean contains(final int xx) {\r\n    return xx >= x && xx <= x + w || xx >= x + w && xx <= x;\r\n  }","id":87139,"modified_method":"/**\r\n   * Verifies if the specified coordinates are inside the rectangle.\r\n   * @param xx x position\r\n   * @return result of comparison\r\n   */\r\n  public boolean contains(final int xx) {\r\n    return xx >= x && xx <= x + w;\r\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Finds rectangle at cursor position.\n   * @return focused rectangle\n   */\n  private boolean focus() {\n    if(refreshedFocus) {\n      final int pre = gui.context.focused;\n\n      for(int i = 0; i < cache.getHeight(frn); i++) {\n\n        if(cache.isBigRectangle(frn, i)) {\n          final int index = cache.getPreIndex(frn, i, pre);\n\n          if(index > -1) {\n            focusedRect = cache.getTreeRectsPerLevel(frn, i)[0];\n            focusedRectLevel = i;\n            refreshedFocus = false;\n            return true;\n          }\n        } else {\n\n          final TreeRect rect = cache.searchRect(0, i, pre);\n\n          if(rect != null) {\n            focusedRect = rect;\n            focusedRectLevel = i;\n            refreshedFocus = false;\n            return true;\n          }\n        }\n      }\n    } else {\n\n      final int rn = frn = getTreePerX(mousePosX);\n      final int lv = getLevelPerY(mousePosY);\n\n      if(lv < 0 || cache.getHeight(rn) == -1 || lv >= cache.getHeight(rn))\n        return false;\n\n      final TreeRect[] rL = cache.getTreeRectsPerLevel(rn, lv);\n\n      for(int i = 0; i < rL.length; i++) {\n        final TreeRect r = rL[i];\n\n        if(r.contains(mousePosX)) {\n          focusedRect = r;\n          focusedRectLevel = lv;\n          int pre = cache.getPrePerIndex(rn, lv, i);\n\n          // if multiple pre values, then approximate pre value\n          if(cache.isBigRectangle(rn, lv)) {\n            final double ratio = mousePosX / (double) r.w;\n            final int index = (int) (cache.getLevelSize(0, lv) * ratio);\n            pre = cache.getPrePerIndex(0, lv, index);\n          }\n          gui.notify.focus(pre, this);\n          refreshedFocus = false;\n          return true;\n        }\n      }\n    }\n    refreshedFocus = false;\n    return false;\n  }","id":87140,"modified_method":"/**\n   * Finds rectangle at cursor position.\n   * @return focused rectangle\n   */\n  private boolean focus() {\n    if(refreshedFocus) {\n      final int pre = gui.context.focused;\n\n      for(int i = 0; i < cache.getHeight(frn); i++) {\n\n        if(cache.isBigRectangle(frn, i)) {\n          final int index = cache.getPreIndex(frn, i, pre);\n\n          if(index > -1) {\n            focusedRect = cache.getTreeRectsPerLevel(frn, i)[0];\n            focusedRectLevel = i;\n            refreshedFocus = false;\n            return true;\n          }\n        } else {\n\n          final TreeRect rect = cache.searchRect(0, i, pre);\n\n          if(rect != null) {\n            focusedRect = rect;\n            focusedRectLevel = i;\n            refreshedFocus = false;\n            return true;\n          }\n        }\n      }\n    } else {\n\n      final int rn = frn = getTreePerX(mousePosX);\n      final int lv = getLevelPerY(mousePosY);\n\n      if(lv < 0 || cache.getHeight(rn) < 0 || lv >= cache.getHeight(rn)) \n      return false;\n\n      final TreeRect[] rL = cache.getTreeRectsPerLevel(rn, lv);\n\n      for(int i = 0; i < rL.length; i++) {\n        final TreeRect r = rL[i];\n\n        if(r.contains(mousePosX)) {\n          focusedRect = r;\n          focusedRectLevel = lv;\n          int pre = -1;\n\n          // if multiple pre values, then approximate pre value\n          if(cache.isBigRectangle(rn, lv)) {\n            pre = cache.getPrePerXPos(rn, lv, mousePosX);\n          } else {\n            pre = cache.getPrePerIndex(rn, lv, i);\n          }\n          gui.notify.focus(pre, this);\n          refreshedFocus = false;\n          return true;\n        }\n      }\n    }\n    refreshedFocus = false;\n    return false;\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Highlights nodes.\n   * @param g the graphics reference\n   * @param rn root\n   * @param pre pre\n   * @param r rectangle to highlight\n   * @param l level\n   * @param cx child's x value\n   * @param t highlight type\n   */\n  private void highlightNode(final Graphics g, final int rn, final int pre,\n      final TreeRect r, final int l, final int cx, final byte t) {\n\n    if(l == -1) return;\n\n    final int y = getYperLevel(l);\n    final int h = nodeHeight;\n    final boolean br = cache.isBigRectangle(rn, l);\n    final boolean root = gui.context.current.nodes[rn] == pre;\n    final int height = cache.getHeight(rn);\n\n    final Data d = gui.context.data;\n    final int k = d.kind(pre);\n    final int size = d.size(pre, k);\n    // big rectangle x\n    int brx = -1;\n\n    drawRectangle(g, rn, l, r, pre, t);\n\n    if(br) {\n      final int index = cache.getPreIndex(rn, l, pre);\n      if(t == DRAW_HIGHLIGHT) fix = index;\n      final double ratio = index / (double) (cache.getLevelSize(rn, l) - 1);\n      brx = (int) (r.w * ratio);\n      g.setColor(COLORS[7]);\n      g.drawLine(brx, y, brx, y + nodeHeight);\n    }\n\n    if(cx > -1 && MIN_NODE_DIST_CONN <= levelDistance) {\n      g.setColor(COLORS[7]);\n      g.drawLine(cx, getYperLevel(l + 1) - 1, brx == -1 ? (2 * r.x + r.w) / 2\n          : brx, y + nodeHeight + 1);\n    }\n\n    if((t == DRAW_HIGHLIGHT || t == DRAW_PARENT) && !root) {\n      final int par = d.parent(pre, k);\n      final int lv = l - 1;\n      final TreeRect parRect = cache.searchRect(rn, lv, par);\n      if(parRect == null) return;\n      highlightNode(g, rn, par, parRect, lv, brx == -1 ? (2 * r.x + r.w) / 2\n          : brx, DRAW_PARENT);\n    }\n\n    if((t == DRAW_CONN || t == DRAW_HIGHLIGHT || t == DRAW_DESCENDANTS)\n        && size > 1 && l + 1 < height) highlightDescendants(g, rn, pre, r, l,\n        brx, t);\n\n    if(t != DRAW_HIGHLIGHT) return;\n\n    final String s = Token.string(cache.getText(gui.context, rn, pre));\n    final int w = BaseXLayout.width(g, s);\n\n    g.setColor(COLORS[l + 5]);\n\n    if(root) {\n      g.fillRect(r.x, y + h + 2, w + 2, fontHeight);\n      g.setColor(Color.WHITE);\n      g.drawString(s, r.x + 1, (int) (y + h + (float) fontHeight) - 2);\n    } else {\n      g.fillRect(r.x, y - fontHeight, w + 2, fontHeight);\n      g.setColor(Color.WHITE);\n      g.drawString(s, r.x + 1, (int) (y - h / (float) fontHeight) - 2);\n    }\n\n  }","id":87141,"modified_method":"/**\n   * Highlights nodes.\n   * @param g the graphics reference\n   * @param rn root\n   * @param pre pre\n   * @param r rectangle to highlight\n   * @param l level\n   * @param cx child's x value\n   * @param t highlight type\n   */\n  private void highlightNode(final Graphics g, final int rn, final int pre,\n      final TreeRect r, final int l, final int cx, final byte t) {\n\n    if(l == -1) return;\n\n    final int y = getYperLevel(l);\n    final int h = nodeHeight;\n    final boolean br = cache.isBigRectangle(rn, l);\n    final boolean root = gui.context.current.nodes[rn] == pre;\n    final int height = cache.getHeight(rn);\n\n//    System.out.println(\"rn: \" + rn + \" t: \" + t + \" br: \" + br + \" root \"\n//        + root);\n\n    final Data d = gui.context.data;\n    final int k = d.kind(pre);\n    final int size = d.size(pre, k);\n    // big rectangle x\n    int brx = -1;\n\n    if(t != DRAW_CONN) drawRectangle(g, rn, l, r, pre, t);\n\n    if(br) {\n      final int index = cache.getPreIndex(rn, l, pre);\n      if(t == DRAW_HIGHLIGHT) fix = index;\n      final double ratio = index / (double) (cache.getLevelSize(rn, l) - 1);\n\n//      System.out.println(\"index:\" + index + \" lsize: \"\n//          + cache.getLevelSize(rn, l) + \"w:\" + r.w + \" ratio:\" + ratio);\n\n      brx = r.x + (int) (r.w * ratio);\n      g.setColor(COLORS[7]);\n      g.drawLine(brx, y, brx, y + nodeHeight);\n    }\n\n    if(cx > -1 && MIN_NODE_DIST_CONN <= levelDistance) {\n      g.setColor(COLORS[7]);\n      g.drawLine(cx, getYperLevel(l + 1) - 1, brx == -1 ? (2 * r.x + r.w) / 2\n          : brx, y + nodeHeight + 1);\n    }\n\n    if((t == DRAW_HIGHLIGHT || t == DRAW_PARENT) && !root) {\n      final int par = d.parent(pre, k);\n      final int lv = l - 1;\n\n//    System.out.println(\"brx: \" + brx + \"   level: \" + lv + \"   pre: \" + pre);\n\n      final TreeRect parRect = cache.searchRect(rn, lv, par);\n      if(parRect == null) return;\n      highlightNode(g, rn, par, parRect, lv, brx == -1 ? (2 * r.x + r.w) / 2\n          : brx, DRAW_PARENT);\n    }\n\n    if((t == DRAW_CONN || t == DRAW_HIGHLIGHT || t == DRAW_DESCENDANTS)\n        && size > 1 && l + 1 < height) highlightDescendants(g, rn, pre, r, l,\n        brx, t);\n\n    if(t != DRAW_HIGHLIGHT) return;\n\n    final String s = Token.string(cache.getText(gui.context, rn, pre));\n    final int w = BaseXLayout.width(g, s);\n\n    g.setColor(COLORS[l + 5]);\n\n    if(root) {\n      g.fillRect(r.x, y + h + 2, w + 2, fontHeight);\n      g.setColor(Color.WHITE);\n      g.drawString(s, r.x + 1, (int) (y + h + (float) fontHeight) - 2);\n    } else {\n      g.fillRect(r.x, y - fontHeight, w + 2, fontHeight);\n      g.setColor(Color.WHITE);\n      g.drawString(s, r.x + 1, (int) (y - h / (float) fontHeight) - 2);\n    }\n\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Highlights the marked nodes.\n   */\n  private void markNodes() {\n    refreshedMark = false;\n    markedImage = createImage();\n    final Graphics mg = markedImage.getGraphics();\n    smooth(mg);\n\n    if(gui.context.marked == null) return;\n\n    final int size = gui.context.marked.size();\n\n    final int[] marked = Arrays.copyOf(gui.context.marked.nodes, size);\n\n    int rn = 0;\n\n    while(rn < numRoots) {\n\n      for(int i = 0; i < cache.getHeight(rn); i++) {\n\n        final int y = getYperLevel(i);\n\n        if(cache.isBigRectangle(rn, i)) {\n\n          for(int j = 0; j < size; j++) {\n            final int pre = marked[j];\n\n            final int ix = cache.getPreIndex(rn, i, pre);\n\n            if(ix > -1) {\n              final int x = (int) (getWidth() * ix /\n                  (double) cache.getLevelSize(\n                  rn, i));\n              mg.setColor(Color.RED);\n              mg.drawRect(x, y, 2, nodeHeight);\n            }\n          }\n        } else {\n\n          for(int j = 0; j < size; j++) {\n            final int pre = marked[j];\n\n            final TreeRect rect = cache.searchRect(rn, i, pre);\n\n            if(rect != null) {\n              drawRectangle(mg, rn, i, rect, pre, DRAW_MARK);\n            }\n          }\n        }\n      }\n      rn++;\n    }\n  }","id":87142,"modified_method":"/**\n   * Highlights the marked nodes.\n   */\n  private void markNodes() {\n    markedImage = createImage();\n    final Graphics mg = markedImage.getGraphics();\n    smooth(mg);\n\n    final int size = gui.context.marked.size();\n    if(size == 0) return;\n\n    final int[] marked = Arrays.copyOf(gui.context.marked.nodes, size);\n\n    int rn = 0;\n\n    while(rn < numRoots) {\n\n      for(int i = 0; i < cache.getHeight(rn); i++) {\n\n        final int y = getYperLevel(i);\n\n        if(cache.isBigRectangle(rn, i)) {\n\n          for(int j = 0; j < size; j++) {\n            final int pre = marked[j];\n\n            final int ix = cache.getPreIndex(rn, i, pre);\n\n            if(ix > -1) {\n              final int x = (int) (getWidth() * ix / \n              (double) cache.getLevelSize(\n                  rn, i));\n              mg.setColor(Color.RED);\n              mg.drawRect(x, y, 2, nodeHeight);\n            }\n          }\n        } else {\n\n          for(int j = 0; j < size; j++) {\n            final int pre = marked[j];\n\n            final TreeRect rect = cache.searchRect(rn, i, pre);\n\n            if(rect != null) {\n              drawRectangle(mg, rn, i, rect, pre, DRAW_MARK);\n            }\n          }\n        }\n      }\n      rn++;\n    }\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Draws the dragged selection and marks the nodes inside.\n   * @param g the graphics reference\n   */\n  private void markSelektedNodes(final Graphics g) {\n    final int x = selectRect.w < 0 ? selectRect.x + selectRect.w : selectRect.x;\n    final int y = selectRect.h < 0 ? selectRect.y + selectRect.h : selectRect.y;\n    final int w = Math.abs(selectRect.w);\n    final int h = Math.abs(selectRect.h);\n\n    // draw selection\n    g.setColor(Color.RED);\n    g.drawRect(x, y, w, h);\n\n    final int t = y + h;\n    final int size = cache.maxLevel;\n    final IntList list = new IntList();\n\n    for(int i = 0; i < size; i++) {\n      final int yL = getYperLevel(i);\n\n      if(i < cache.getHeight(frn) && (yL >= y || yL + nodeHeight >= y)\n          && (yL <= t || yL + nodeHeight <= t)) {\n\n        final TreeRect[] rlv = cache.getTreeRectsPerLevel(frn, i);\n        final int s = cache.getLevelSize(frn, i);\n\n        if(cache.isBigRectangle(frn, i)) {\n          final TreeRect mRect = rlv[0];\n          int sPrePos = (int) (s * (x / (double) mRect.w));\n          int ePrePos = (int) (s * ((x + w) / (double) mRect.w));\n\n          if(sPrePos < 0) sPrePos = 0;\n          if(ePrePos >= s) ePrePos = s - 1;\n\n          while(sPrePos++ < ePrePos)\n            list.add(cache.getPrePerIndex(frn, i, sPrePos));\n\n        } else {\n          for(int j = 0; j < s; j++) {\n            final TreeRect tr = rlv[j];\n            if(tr.contains(x, w)) list.add(cache.getPrePerIndex(frn, i, j));\n          }\n        }\n        gui.notify.mark(new Nodes(list.finish(), gui.context.data), this);\n        markNodes();\n        repaint();\n      }\n    }\n  }","id":87143,"modified_method":"/**\n   * Draws the dragged selection and marks the nodes inside.\n   * @param g the graphics reference\n   */\n  private void markSelektedNodes(final Graphics g) {\n    final int x = selectRect.w < 0 ? selectRect.x + selectRect.w : selectRect.x;\n    final int y = selectRect.h < 0 ? selectRect.y + selectRect.h : selectRect.y;\n    final int w = Math.abs(selectRect.w);\n    final int h = Math.abs(selectRect.h);\n\n    // draw selection\n    g.setColor(Color.RED);\n    g.drawRect(x, y, w, h);\n\n    final int t = y + h;\n    final int size = cache.maxLevel;\n    final IntList list = new IntList();\n\n    for(int i = 0; i < size; i++) {\n      final int yL = getYperLevel(i);\n\n      if(i < cache.getHeight(frn) && (yL >= y || yL + nodeHeight >= y)\n          && (yL <= t || yL + nodeHeight <= t)) {\n\n        final TreeRect[] rlv = cache.getTreeRectsPerLevel(frn, i);\n        final int s = cache.getLevelSize(frn, i);\n\n        if(cache.isBigRectangle(frn, i)) {\n          final TreeRect mRect = rlv[0];\n          int sPrePos = (int) (s * (x / (double) mRect.w));\n          int ePrePos = (int) (s * ((x + w) / (double) mRect.w));\n\n          if(sPrePos < 0) sPrePos = 0;\n          if(ePrePos >= s) ePrePos = s - 1;\n\n          while(sPrePos++ < ePrePos)\n            list.add(cache.getPrePerIndex(frn, i, sPrePos));\n        } else {\n          for(int j = 0; j < s; j++) {\n            final TreeRect tr = rlv[j];\n            if(tr.contains(x, w)) list.add(cache.getPrePerIndex(frn, i, j));\n          }\n        }\n        gui.notify.mark(new Nodes(list.finish(), gui.context.data), this);\n        markNodes();\n      }\n    }\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Highlights descendants.\n   * @param g the graphics reference\n   * @param rn root\n   * @param pre pre\n   * @param r rectangle to highlight\n   * @param l level\n   * @param px parent's x value\n   * @param t highlight type\n   */\n  private void highlightDescendants(final Graphics g, final int rn,\n      final int pre, final TreeRect r, final int l,\n      final int px, final byte t) {\n\n    final Data d = gui.context.current.data;\n    drawRectangle(g, rn, l, r, pre, t);\n    final int lv = l + 1;\n    final TreeBorder[] sbo = cache.generateSubtreeBorders(d, pre);\n    if(sbo.length < 2) return;\n    final int parc = px == -1 ? (2 * r.x + r.w) / 2 : px;\n\n    if(cache.isBigRectangle(rn, lv)) {\n      drawBigRectDescendants(g, rn, lv, sbo, parc, t);\n\n    } else {\n      final TreeBorder bo = sbo[1];\n      final TreeBorder bos = cache.getTreeBorder(rn, lv);\n\n      for(int j = 0; j < bo.size; j++) {\n        int pi = cache.getPrePerIndex(bo, j);\n        final TreeRect sr = cache.getTreeRectPerIndex(rn, lv, j + bo.start\n            - bos.start);\n\n        if(SHOW_DESCENDANTS_CONN && levelDistance >= MIN_NODE_DIST_CONN) {\n          drawDescendantsConn(g, lv, sr, parc, t);\n        }\n\n        highlightDescendants(g, rn, pi, sr, lv, -1, t == DRAW_CONN ? DRAW_CONN\n            : DRAW_DESCENDANTS);\n      }\n    }\n  }","id":87144,"modified_method":"/**\n   * Highlights descendants.\n   * @param g the graphics reference\n   * @param rn root\n   * @param pre pre\n   * @param r rectangle to highlight\n   * @param l level\n   * @param px parent's x value\n   * @param t highlight type\n   */\n  private void highlightDescendants(final Graphics g, final int rn,\n      final int pre, final TreeRect r, final int l, \n      final int px, final byte t) {\n\n    final Data d = gui.context.current.data;\n    if(!cache.isBigRectangle(rn, l) && t != DRAW_CONN) drawRectangle(g, rn, l,\n        r, pre, t);\n    final int lv = l + 1;\n\n    final TreeBorder[] sbo = cache.generateSubtreeBorders(d, pre);\n\n    if(cache.getHeight(rn) <= lv || sbo.length < 2) return;\n    final int parc = px == -1 ? (2 * r.x + r.w) / 2 : px;\n\n    if(cache.isBigRectangle(rn, lv)) {\n      drawBigRectDescendants(g, rn, lv, sbo, parc, t);\n\n    } else {\n      final TreeBorder bo = sbo[1];\n      final TreeBorder bos = cache.getTreeBorder(rn, lv);\n\n      for(int j = 0; j < bo.size; j++) {\n        int pi = cache.getPrePerIndex(bo, j);\n//        if(gui.context.current.nodes[0] > 0) System.out.println(\"rn:\" + rn\n//            + \" lv:\" + lv + \" bo-size:\" + bo.size + \" bo-start:\" + (bo.start)\n//            + \" bos:\" + bos.start + \" rl:\" + cache.rects.length + \" rlvl:\"\n//            + cache.rects[rn].length + \" r:\" + cache.rects[rn][lv].length);\n\n        final int start = bo.start >= bos.start ? bo.start - bos.start\n            : bo.start;\n        final TreeRect sr = cache.getTreeRectPerIndex(rn, lv, j + start);\n\n        if(SHOW_DESCENDANTS_CONN && levelDistance >= MIN_NODE_DIST_CONN) {\n          drawDescendantsConn(g, lv, sr, parc, t);\n        }\n\n        highlightDescendants(g, rn, pi, sr, lv, -1, t == DRAW_CONN ? DRAW_CONN\n            : DRAW_DESCENDANTS);\n      }\n    }\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n\n    // timer\n    // final Performance perf = new Performance();\n    // perf.initTimer();\n\n    // initializes sizes\n    nodeHeight = MAX_NODE_HEIGHT;\n    smooth(g);\n    g.setFont(font);\n    fontHeight = g.getFontMetrics().getHeight();\n\n    if(windowSizeChanged()) {\n      if(markedImage != null) {\n        markedImage = null;\n        refreshedMark = true;\n      }\n      focusedRect = null;\n      if((treedist = cache.generateBordersAndRects(g, gui.context, getWidth()))\n          == -1) return;\n      setLevelDistance();\n      createNewMainImage();\n    } else setLevelDistance();\n    g.drawImage(treeImage, 0, 0, getWidth(), getHeight(), this);\n\n    // highlights marked nodes\n    if(refreshedMark) markNodes();\n\n    if(selection) markSelektedNodes(g);\n\n    if(markedImage != null) g.drawImage(markedImage, 0, 0, getWidth(),\n        getHeight(), this);\n\n    // highlights the focused node\n\n    if(focus()) {\n      final int focused = gui.context.focused;\n\n      highlightNode(g, frn, focused, focusedRect, focusedRectLevel, -1,\n          DRAW_HIGHLIGHT);\n\n      if(SHOW_EXTRA_INFO) {\n        g.setColor(new Color(0xeeeeee));\n        g.fillRect(0, getHeight() - fontHeight - 6, getWidth(), fontHeight + 6);\n        final Data d = gui.context.data;\n        final int k = d.kind(focused);\n        final int s = d.size(focused, k);\n        final int as = d.attSize(focused, k);\n        g.setColor(Color.BLACK);\n        g.drawString(\"level: \" + focusedRectLevel + \"  level-size: \"\n            + cache.getLevelSize(0, focusedRectLevel) + \"  node-size: \"\n            + (s - as) + \"  node: \"\n            + Token.string(ViewData.tag(gui.prop, d, focused)) + \"  pre: \"\n            + focused, 2, getHeight() - 6);\n      }\n    }\n  }","id":87145,"modified_method":"@Override\n  public void paintComponent(final Graphics g) {\n    super.paintComponent(g);\n\n    // timer\n    // final Performance perf = new Performance();\n    // perf.initTimer();\n\n    // initializes sizes\n    nodeHeight = MAX_NODE_HEIGHT;\n    smooth(g);\n    g.setFont(font);\n    fontHeight = g.getFontMetrics().getHeight();\n\n    if(windowSizeChanged()) {\n      if(markedImage != null) {\n        markedImage = null;\n      }\n      focusedRect = null;\n      if((treedist = cache.generateBordersAndRects(g, gui.context, getWidth())) \n      == -1) return;\n      setLevelDistance();\n      createNewMainImage();\n      if(gui.context.marked.size() > 0) markNodes();\n\n    } else setLevelDistance();\n    g.drawImage(treeImage, 0, 0, getWidth(), getHeight(), this);\n\n    if(selection) markSelektedNodes(g);\n\n    if(markedImage != null) g.drawImage(markedImage, 0, 0, getWidth(),\n        getHeight(), this);\n\n    // highlights the focused node\n\n    if(focus()) {\n      final int focused = gui.context.focused;\n\n      highlightNode(g, frn, focused, focusedRect, focusedRectLevel, -1,\n          DRAW_HIGHLIGHT);\n\n      if(SHOW_EXTRA_INFO) {\n        g.setColor(new Color(0xeeeeee));\n        g.fillRect(0, getHeight() - fontHeight - 6, getWidth(), fontHeight + 6);\n        final Data d = gui.context.data;\n        final int k = d.kind(focused);\n        final int s = d.size(focused, k);\n        final int as = d.attSize(focused, k);\n        g.setColor(Color.BLACK);\n        g.drawString(\"pre: \" + focused + \"level: \" + focusedRectLevel\n            + \"  level-size: \" + cache.getLevelSize(frn, focusedRectLevel)\n            + \"  node-size: \" + (s - as) + \"  node: \"\n            + Token.string(ViewData.tag(gui.prop, d, focused)), 2,\n            getHeight() - 6);\n      }\n    }\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Draws Rectangles.\n   * @param g graphics reference\n   * @param rn root\n   * @param lv level\n   * @param r rectangle\n   * @param pre pre\n   * @param type use type\n   */\n  private void drawRectangle(final Graphics g, final int rn, final int lv,\n      final TreeRect r, final int pre, final byte type) {\n\n    final int y = getYperLevel(lv);\n    final int h = nodeHeight;\n    final boolean br = cache.isBigRectangle(rn, lv);\n    boolean txt = !br && fontHeight <= h;\n    boolean fill = false;\n    boolean border = false;\n\n    Color borderColor = null;\n    Color fillColor = null;\n    Color textColor = Color.BLACK;\n\n    switch(type) {\n      case DRAW_RECTANGLE:\n        borderColor = getColorPerLevel(lv, false);\n        fillColor = getColorPerLevel(lv, true);\n        txt = txt && DRAW_NODE_TEXT;\n        border = BORDER_RECTANGLES;\n        fill = FILL_RECTANGLES;\n        break;\n      case DRAW_HIGHLIGHT:\n        borderColor = color6;\n        final int alpha = 0xDD000000;\n        final int rgb = GUIConstants.COLORCELL.getRGB();\n        fillColor = new Color(rgb + alpha, true);\n        border = true;\n        fill = !br;\n        break;\n      case DRAW_MARK:\n        borderColor = h > 2 && r.w > 4 ? colormarkA : colormark1;\n        fillColor = colormark1;\n        fill = border = true;\n        break;\n      case DRAW_DESCENDANTS:\n        final int alphaD = 0xDD000000;\n        final int rgbD = COLORS[6].getRGB();\n        fillColor = new Color(rgbD + alphaD, true);\n        borderColor = COLORS[8];\n        textColor = Color.WHITE;\n        fill = true;\n        border = true;\n        if(h < 2 || r.w < 4) {\n          borderColor = COLORS[6];\n          txt = false;\n        }\n        break;\n      case DRAW_PARENT:\n        fillColor = COLORS[6];\n        textColor = Color.WHITE;\n        fill = !br;\n        if(h < 2 || r.w < 4) {\n          borderColor = COLORS[6];\n          border = true;\n          txt = false;\n        }\n        break;\n      case DRAW_CONN:\n        txt = false;\n        break;\n    }\n\n    if(border) {\n      final int xx = r.x + BORDER_PADDING;\n      final int ww = r.w - BORDER_PADDING;\n      g.setColor(borderColor);\n      g.drawRect(xx, y, ww, h);\n      // g.drawRoundRect(xx, y, ww, h, 20, 20);\n      // if(type == DRAW_HIGHLIGHT)\n      // g.drawRect(xx + 1, y + 1, ww - 2, h - 2);\n    }\n\n    if(fill) {\n      final int xx = r.x + BORDER_PADDING + 1;\n      final int ww = r.w - BORDER_PADDING - 1;\n      g.setColor(fillColor);\n      g.fillRect(xx, y + 1, ww, h - 1);\n      // g.fillRoundRect(xx, y, ww, h, 20, 20);\n    }\n\n    if(txt && (fill || !FILL_RECTANGLES)) {\n      g.setColor(textColor);\n      drawRectangleText(g, rn, lv, r, pre);\n    }\n  }","id":87146,"modified_method":"/**\n   * Draws Rectangles.\n   * @param g graphics reference\n   * @param rn root\n   * @param lv level\n   * @param r rectangle\n   * @param pre pre\n   * @param type use type\n   */\n  private void drawRectangle(final Graphics g, final int rn, final int lv,\n      final TreeRect r, final int pre, final byte type) {\n\n    final int y = getYperLevel(lv);\n    final int h = nodeHeight;\n    final boolean br = cache.isBigRectangle(rn, lv);\n    boolean txt = !br && fontHeight <= h;\n    boolean fill = true;\n    boolean border = true;\n\n    Color borderColor = null;\n    Color fillColor = null;\n    Color textColor = Color.BLACK;\n\n    switch(type) {\n      case DRAW_RECTANGLE:\n        borderColor = getColorPerLevel(lv, false);\n        fillColor = getColorPerLevel(lv, true);\n        txt = txt && DRAW_NODE_TEXT;\n        border = BORDER_RECTANGLES;\n        fill = FILL_RECTANGLES;\n        break;\n      case DRAW_HIGHLIGHT:\n        borderColor = color6;\n        final int alpha = 0xDD000000;\n        final int rgb = GUIConstants.COLORCELL.getRGB();\n        fillColor = new Color(rgb + alpha, true);\n        border = true;\n        fill = !br;\n        break;\n      case DRAW_MARK:\n        borderColor = h > 2 && r.w > 4 ? colormarkA : colormark1;\n        fillColor = colormark1;\n        break;\n      case DRAW_DESCENDANTS:\n        final int alphaD = 0xDD000000;\n        final int rgbD = COLORS[6].getRGB();\n        fillColor = new Color(rgbD + alphaD, true);\n        borderColor = COLORS[8];\n        textColor = Color.WHITE;\n        fill = true;\n        border = true;\n        if(h < 2 || r.w < 4) {\n          borderColor = fillColor;\n          txt = false;\n        }\n        break;\n      case DRAW_PARENT:\n        fillColor = COLORS[6];\n        textColor = Color.WHITE;\n        fill = !br;\n        if(h < 2 || r.w < 4) {\n          borderColor = COLORS[6];\n          border = true;\n          txt = false;\n        }\n        break;\n    }\n\n    final int xx = r.x;\n    final int ww = r.w;\n\n    if(border) {\n      g.setColor(borderColor);\n      g.drawRect(xx, y, ww, h);\n      // g.drawRoundRect(xx, y, ww, h, 20, 20);\n      // if(type == DRAW_HIGHLIGHT)\n      // g.drawRect(xx + 1, y + 1, ww - 2, h - 2);\n    }\n    if(fill) {\n      g.setColor(fillColor);\n      g.fillRect(xx + 1, y + 1, ww - 1, h - 1);\n      // g.fillRoundRect(xx, y, ww, h, 20, 20);\n    }\n\n    if(txt && (fill || !FILL_RECTANGLES)) {\n      g.setColor(textColor);\n      drawRectangleText(g, rn, lv, r, pre);\n    }\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Draws descendants for big rectangles.\n   * @param g graphics reference\n   * @param rn root\n   * @param lv level\n   * @param subt subtree\n   * @param parc parent center\n   * @param t type\n   */\n  private void drawBigRectDescendants(final Graphics g, final int rn,\n      final int lv, final TreeBorder[] subt, final int parc, final byte t) {\n\n    int lvv = lv;\n    int cen = parc;\n    int i;\n\n    for(i = 1; i < subt.length && cache.isBigRectangle(rn, lvv); i++) {\n\n      final TreeBorder bos = cache.getTreeBorder(rn, lvv);\n      final TreeBorder bo = subt[i];\n\n      final TreeRect r = cache.getTreeRectPerIndex(rn, lvv, 0);\n      final int start = bo.start - bos.start;\n      final double sti = start / (double) bos.size;\n      final double eni = (start + bo.size) / (double) bos.size;\n\n      final int df = r.x + (int) ((r.w) * sti);\n      final int dt = r.x + (int) ((r.w) * eni);\n      final int ww = Math.max(dt - df, 2);\n\n      if(MIN_NODE_DIST_CONN <= levelDistance) drawDescendantsConn(g, lvv,\n          new TreeRect(df, ww), cen, t);\n      cen = (2 * df + ww) / 2;\n      switch(t) {\n        case DRAW_CONN:\n          break;\n        default:\n          // g.setColor(COLORS[1]);\n          // g.drawRect(df, getYperLevel(lvv), ww, nodeHeight);\n          final int rgb = COLORS[7].getRGB();\n          final int alpha = 0x33000000;\n          g.setColor(new Color(rgb + alpha, false));\n          g.fillRect(df, getYperLevel(lvv), ww, nodeHeight);\n      }\n\n      if(lvv + 1 < cache.getHeight(rn) && !cache.isBigRectangle(rn, lvv + 1)) {\n        final Data d = gui.context.current.data;\n\n        for(int j = subt[i].start; j < subt[i].start + subt[i].size; j++) {\n          final int pre = cache.getPrePerIndex(rn, lvv, j);\n          final int k = d.kind(pre);\n          final int s = d.size(pre, k) - d.attSize(pre, k);\n          if(s > 0) highlightDescendants(g, rn, pre, r, lvv, cen,\n              t == DRAW_HIGHLIGHT || t == DRAW_DESCENDANTS ? DRAW_DESCENDANTS\n                  : DRAW_CONN);\n        }\n        return;\n      }\n      lvv++;\n    }\n  }","id":87147,"modified_method":"/**\n   * Draws descendants for big rectangles.\n   * @param g graphics reference\n   * @param rn root\n   * @param lv level\n   * @param subt subtree\n   * @param parc parent center\n   * @param t type\n   */\n  private void drawBigRectDescendants(final Graphics g, final int rn,\n      final int lv, final TreeBorder[] subt, final int parc, final byte t) {\n\n    final int h = cache.getHeight(rn);\n    int lvv = lv;\n    int cen = parc;\n    int i;\n\n    for(i = 1; i < subt.length && cache.isBigRectangle(rn, lvv); i++) {\n\n      final TreeBorder bos = cache.getTreeBorder(rn, lvv);\n      final TreeBorder bo = subt[i];\n\n      final TreeRect r = cache.getTreeRectPerIndex(rn, lvv, 0);\n      final int start = bo.start - bos.start;\n      final double sti = start / (double) bos.size;\n      final double eni = (start + bo.size) / (double) bos.size;\n\n      final int df = r.x + (int) ((r.w) * sti);\n      final int dt = r.x + (int) ((r.w) * eni);\n      final int ww = Math.max(dt - df, 2);\n\n      if(MIN_NODE_DIST_CONN <= levelDistance) drawDescendantsConn(g, lvv,\n          new TreeRect(df, ww), cen, t);\n      cen = (2 * df + ww) / 2;\n      switch(t) {\n        case DRAW_CONN:\n          break;\n        default:\n          // g.setColor(COLORS[1]);\n          // g.drawRect(df, getYperLevel(lvv), ww, nodeHeight);\n          final int rgb = COLORS[7].getRGB();\n          final int alpha = 0x33000000;\n          g.setColor(new Color(rgb + alpha, false));\n          g.fillRect(df, getYperLevel(lvv), ww, nodeHeight);\n      }\n\n      if(lvv + 1 < h\n          && !cache.isBigRectangle(rn, lvv + 1)) {\n        final Data d = gui.context.current.data;\n        for(int j = 0; j < subt[i].size; j++) {\n          final int pre = cache.getPrePerIndex(rn, lvv, j);\n          final int k = d.kind(pre);\n          final int s = d.size(pre, k) - d.attSize(pre, k);\n          if(s > 0) highlightDescendants(g, rn, pre, r, lvv, cen,\n              t == DRAW_HIGHLIGHT || t == DRAW_DESCENDANTS ? DRAW_DESCENDANTS\n                  : DRAW_CONN);\n        }\n        return;\n      }\n      lvv++;\n    }\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void mouseClicked(final MouseEvent e) {\n    final boolean left = SwingUtilities.isLeftMouseButton(e);\n    final boolean right = !left;\n    if(!right && !left || focusedRect == null) return;\n\n    if(left) {\n\n      if(focusedRectLevel >= cache.getHeight(frn)) return;\n\n      if(cache.isBigRectangle(frn, focusedRectLevel)) {\n        final Nodes ns = new Nodes(gui.context.data);\n        final int sum = (int) ((cache.getLevelSize(frn, focusedRectLevel) - 1)\n            / (double) focusedRect.w);\n        int[] m = new int[sum];\n        for(int i = 0; i < sum; i++) {\n          m[i] = cache.getPrePerIndex(frn, focusedRectLevel, i + fix);\n        }\n        ns.union(m);\n        gui.notify.mark(ns, null);\n\n      } else {\n        gui.notify.mark(0, null);\n      }\n      if(e.getClickCount() > 1) {\n        gui.notify.context(gui.context.marked, false, this);\n        refreshContext(false, false);\n      }\n    }\n  }","id":87148,"modified_method":"@Override\n  public void mouseClicked(final MouseEvent e) {\n    final boolean left = SwingUtilities.isLeftMouseButton(e);\n    final boolean right = !left;\n    if(!right && !left || focusedRect == null) return;\n\n    if(left) {\n\n      if(focusedRectLevel >= cache.getHeight(frn)) return;\n\n      if(cache.isBigRectangle(frn, focusedRectLevel)) {\n        final Nodes ns = new Nodes(gui.context.data);\n        final int w = focusedRect.w;\n        final int ls = cache.getLevelSize(frn, focusedRectLevel);\n        final int sum = (int) Math.max(ls / (double) w, 1);\n        int[] m = new int[sum];\n        for(int i = 0; i < sum; i++) {\n          m[i] = cache.getPrePerIndex(frn, focusedRectLevel, i + fix);\n        }\n        ns.union(m);\n        gui.notify.mark(ns, null);\n      } else {\n        gui.notify.mark(0, null);\n      }\n      if(e.getClickCount() > 1) {\n        gui.notify.context(gui.context.marked, false, this);\n        refreshContext(false, false);\n      }\n    }\n  }","commit_id":"e60f87b353a5e01eef0442da9fdf975656eef7ab","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n    public PrimitiveLongIterator relationshipsGetAll()\n    {\n        return new PrimitiveLongBaseIterator()\n        {\n            private final RelationshipStore store = neoStore.getRelationshipStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final RelationshipRecord reusableNodeRecord = new RelationshipRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            try\n                            {\n                                RelationshipRecord record = store.getRecord( currentId, reusableNodeRecord, CHECK );\n                                if ( record != null && record.inUse() )\n                                {\n                                    return next( record.getId() );\n                                }\n                            }\n                            catch ( InvalidRecordException e )\n                            {\n                                // OK, just continue\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n        };\n    }","id":87149,"modified_method":"@Override\n    public PrimitiveLongIterator relationshipsGetAll()\n    {\n        return new PrimitiveLongBaseIterator()\n        {\n            private final RelationshipStore store = neoStore.getRelationshipStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final RelationshipRecord reusableRecord = new RelationshipRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            try\n                            {\n                                if ( store.fillRecord( currentId, reusableRecord, CHECK ) && reusableRecord.inUse() )\n                                {\n                                    return next( reusableRecord.getId() );\n                                }\n                            }\n                            catch ( InvalidRecordException e )\n                            {\n                                // OK, just continue\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n        };\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Pair<Map<DirectionWrapper, Iterable<RelationshipRecord>>, RelationshipLoadingPosition>\n            getMoreRelationships( long nodeId, RelationshipLoadingPosition originalPosition,\n                    DirectionWrapper direction, int[] types )\n    {\n        // initialCapacity=grabSize saves the lists the trouble of resizing\n        List<RelationshipRecord> out = new ArrayList<>();\n        List<RelationshipRecord> in = new ArrayList<>();\n        List<RelationshipRecord> loop = null;\n        Map<DirectionWrapper, Iterable<RelationshipRecord>> result = new EnumMap<>( DirectionWrapper.class );\n        result.put( DirectionWrapper.OUTGOING, out );\n        result.put( DirectionWrapper.INCOMING, in );\n        RelationshipLoadingPosition loadPosition = originalPosition.clone();\n        long position = loadPosition.position( direction, types );\n        for ( int i = 0; i < relationshipGrabSize && position != Record.NO_NEXT_RELATIONSHIP.intValue(); i++ )\n        {\n            RelationshipRecord relRecord = relationshipStore.getChainRecord( position );\n            if ( relRecord == null )\n            {\n                // return what we got so far\n                return Pair.of( result, loadPosition );\n            }\n            long firstNode = relRecord.getFirstNode();\n            long secondNode = relRecord.getSecondNode();\n            if ( relRecord.inUse() )\n            {\n                if ( firstNode == secondNode )\n                {\n                    if ( loop == null )\n                    {\n                        // This is done lazily because loops are probably quite\n                        // rarely encountered\n                        loop = new ArrayList<>();\n                        result.put( DirectionWrapper.BOTH, loop );\n                    }\n                    loop.add( relRecord );\n                }\n                else if ( firstNode == nodeId )\n                {\n                    out.add( relRecord );\n                }\n                else if ( secondNode == nodeId )\n                {\n                    in.add( relRecord );\n                }\n            }\n            else\n            {\n                i--;\n            }\n            long next = 0;\n            if ( firstNode == nodeId )\n            {\n                next = relRecord.getFirstNextRel();\n            }\n            else if ( secondNode == nodeId )\n            {\n                next = relRecord.getSecondNextRel();\n            }\n            else\n            {\n                throw new InvalidRecordException( \"While loading relationships for Node[\" + nodeId +\n                        \"] a Relationship[\" + relRecord.getId() + \"] was encountered that had startNode: \" + firstNode +\n                        \" and endNode: \" + secondNode + \", i.e. which had neither start nor end node as the node we're \" +\n                        \"loading relationships for\" );\n            }\n            position = loadPosition.nextPosition( next, direction, types );\n        }\n        return Pair.of( result, loadPosition );\n    }","id":87150,"modified_method":"public Pair<Map<DirectionWrapper, Iterable<RelationshipRecord>>, RelationshipLoadingPosition>\n            getMoreRelationships( long nodeId, RelationshipLoadingPosition originalPosition,\n                    DirectionWrapper direction, int[] types )\n    {\n        // initialCapacity=grabSize saves the lists the trouble of resizing\n        List<RelationshipRecord> out = new ArrayList<>();\n        List<RelationshipRecord> in = new ArrayList<>();\n        List<RelationshipRecord> loop = null;\n        Map<DirectionWrapper, Iterable<RelationshipRecord>> result = new EnumMap<>( DirectionWrapper.class );\n        result.put( DirectionWrapper.OUTGOING, out );\n        result.put( DirectionWrapper.INCOMING, in );\n        RelationshipLoadingPosition loadPosition = originalPosition.clone();\n        long position = loadPosition.position( direction, types );\n        RelationshipRecord relRecord = null;\n        boolean allocateNewRecord = true;\n        for ( int i = 0; i < relationshipGrabSize && position != Record.NO_NEXT_RELATIONSHIP.intValue(); i++ )\n        {\n            if ( allocateNewRecord )\n            {\n                relRecord = new RelationshipRecord( -1 );\n                allocateNewRecord = false;\n            }\n\n            if ( !relationshipStore.fillChainRecord( position, relRecord ) )\n            {\n                // return what we got so far\n                return Pair.of( result, loadPosition );\n            }\n            long firstNode = relRecord.getFirstNode();\n            long secondNode = relRecord.getSecondNode();\n            if ( relRecord.inUse() )\n            {\n                if ( firstNode == secondNode )\n                {\n                    if ( loop == null )\n                    {\n                        // This is done lazily because loops are probably quite\n                        // rarely encountered\n                        loop = new ArrayList<>();\n                        result.put( DirectionWrapper.BOTH, loop );\n                    }\n                    loop.add( relRecord );\n                    allocateNewRecord = true;\n                }\n                else if ( firstNode == nodeId )\n                {\n                    out.add( relRecord );\n                    allocateNewRecord = true;\n                }\n                else if ( secondNode == nodeId )\n                {\n                    in.add( relRecord );\n                    allocateNewRecord = true;\n                }\n            }\n            else\n            {\n                i--;\n            }\n            long next = 0;\n            if ( firstNode == nodeId )\n            {\n                next = relRecord.getFirstNextRel();\n            }\n            else if ( secondNode == nodeId )\n            {\n                next = relRecord.getSecondNextRel();\n            }\n            else\n            {\n                throw new InvalidRecordException( \"While loading relationships for Node[\" + nodeId +\n                        \"] a Relationship[\" + relRecord.getId() + \"] was encountered that had startNode: \" + firstNode +\n                        \" and endNode: \" + secondNode + \", i.e. which had neither start nor end node as the node we're \" +\n                        \"loading relationships for\" );\n            }\n            position = loadPosition.nextPosition( next, direction, types );\n        }\n        return Pair.of( result, loadPosition );\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public RelationshipRecord getLightRel( long id )\n    {\n        try\n        {\n            assertIdExists( id );\n        }\n        catch ( InvalidRecordException e )\n        {\n            return null;\n        }\n\n        return getRecord( id, new RelationshipRecord( id ), RecordLoad.CHECK );\n    }","id":87151,"modified_method":"public RelationshipRecord getLightRel( long id )\n    {\n        try\n        {\n            assertIdExists( id );\n        }\n        catch ( InvalidRecordException e )\n        {\n            return null;\n        }\n\n        RelationshipRecord record = new RelationshipRecord( id );\n\n        if( fillRecord( id, record, RecordLoad.CHECK ) )\n        {\n            return record;\n        }\n        else\n        {\n            return null;\n        }\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public RelationshipRecord getRecord( long id )\n    {\n        return getRecord( id, new RelationshipRecord( id ), RecordLoad.NORMAL );\n    }","id":87152,"modified_method":"@Override\n    public RelationshipRecord getRecord( long id )\n    {\n        RelationshipRecord record = new RelationshipRecord( id );\n\n        if ( fillRecord( id, record, RecordLoad.NORMAL ) )\n        {\n            return record;\n        }\n        else\n        {\n            return null;\n        }\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private RelationshipRecord getRecord( long id, PageCursor cursor,\n        RecordLoad load, RelationshipRecord record )\n    {\n        cursor.setOffset( offsetForId( id ) );\n\n        // [    ,   x] in use flag\n        // [    ,xxx ] first node high order bits\n        // [xxxx,    ] next prop high order bits\n        long inUseByte = cursor.getByte();\n\n        boolean inUse = (inUseByte & 0x1) == Record.IN_USE.intValue();\n        if ( !inUse )\n        {\n            switch ( load )\n            {\n            case NORMAL:\n                throw new InvalidRecordException( \"RelationshipRecord[\" + id + \"] not in use\" );\n            case CHECK:\n                return null;\n            }\n        }\n\n        long firstNode = cursor.getUnsignedInt();\n        long firstNodeMod = (inUseByte & 0xEL) << 31;\n\n        long secondNode = cursor.getUnsignedInt();\n\n        // [ xxx,    ][    ,    ][    ,    ][    ,    ] second node high order bits,     0x70000000\n        // [    ,xxx ][    ,    ][    ,    ][    ,    ] first prev rel high order bits,  0xE000000\n        // [    ,   x][xx  ,    ][    ,    ][    ,    ] first next rel high order bits,  0x1C00000\n        // [    ,    ][  xx,x   ][    ,    ][    ,    ] second prev rel high order bits, 0x380000\n        // [    ,    ][    , xxx][    ,    ][    ,    ] second next rel high order bits, 0x70000\n        // [    ,    ][    ,    ][xxxx,xxxx][xxxx,xxxx] type\n        long typeInt = cursor.getInt();\n        long secondNodeMod = (typeInt & 0x70000000L) << 4;\n        int type = (int)(typeInt & 0xFFFF);\n\n        record.setId( id );\n        record.setFirstNode( longFromIntAndMod( firstNode, firstNodeMod ) );\n        record.setSecondNode( longFromIntAndMod( secondNode, secondNodeMod ) );\n        record.setType( type );\n        record.setInUse( inUse );\n\n        long firstPrevRel = cursor.getUnsignedInt();\n        long firstPrevRelMod = (typeInt & 0xE000000L) << 7;\n        record.setFirstPrevRel( longFromIntAndMod( firstPrevRel, firstPrevRelMod ) );\n\n        long firstNextRel = cursor.getUnsignedInt();\n        long firstNextRelMod = (typeInt & 0x1C00000L) << 10;\n        record.setFirstNextRel( longFromIntAndMod( firstNextRel, firstNextRelMod ) );\n\n        long secondPrevRel = cursor.getUnsignedInt();\n        long secondPrevRelMod = (typeInt & 0x380000L) << 13;\n        record.setSecondPrevRel( longFromIntAndMod( secondPrevRel, secondPrevRelMod ) );\n\n        long secondNextRel = cursor.getUnsignedInt();\n        long secondNextRelMod = (typeInt & 0x70000L) << 16;\n        record.setSecondNextRel( longFromIntAndMod( secondNextRel, secondNextRelMod ) );\n\n        long nextProp = cursor.getUnsignedInt();\n        long nextPropMod = (inUseByte & 0xF0L) << 28;\n\n        byte extraByte = cursor.getByte();\n\n        record.setFirstInFirstChain( (extraByte & 0x1) != 0 );\n        record.setFirstInSecondChain( (extraByte & 0x2) != 0 );\n\n        record.setNextProp( longFromIntAndMod( nextProp, nextPropMod ) );\n        return record;\n    }","id":87153,"modified_method":"private boolean readRecord( long id, PageCursor cursor,\n        RecordLoad load, RelationshipRecord record )\n    {\n        cursor.setOffset( offsetForId( id ) );\n\n        // [    ,   x] in use flag\n        // [    ,xxx ] first node high order bits\n        // [xxxx,    ] next prop high order bits\n        long inUseByte = cursor.getByte();\n\n        boolean inUse = (inUseByte & 0x1) == Record.IN_USE.intValue();\n        if ( !inUse )\n        {\n            switch ( load )\n            {\n            case NORMAL:\n                throw new InvalidRecordException( \"RelationshipRecord[\" + id + \"] not in use\" );\n            case CHECK:\n                return false;\n            }\n        }\n\n        long firstNode = cursor.getUnsignedInt();\n        long firstNodeMod = (inUseByte & 0xEL) << 31;\n\n        long secondNode = cursor.getUnsignedInt();\n\n        // [ xxx,    ][    ,    ][    ,    ][    ,    ] second node high order bits,     0x70000000\n        // [    ,xxx ][    ,    ][    ,    ][    ,    ] first prev rel high order bits,  0xE000000\n        // [    ,   x][xx  ,    ][    ,    ][    ,    ] first next rel high order bits,  0x1C00000\n        // [    ,    ][  xx,x   ][    ,    ][    ,    ] second prev rel high order bits, 0x380000\n        // [    ,    ][    , xxx][    ,    ][    ,    ] second next rel high order bits, 0x70000\n        // [    ,    ][    ,    ][xxxx,xxxx][xxxx,xxxx] type\n        long typeInt = cursor.getInt();\n        long secondNodeMod = (typeInt & 0x70000000L) << 4;\n        int type = (int)(typeInt & 0xFFFF);\n\n        record.setId( id );\n        record.setFirstNode( longFromIntAndMod( firstNode, firstNodeMod ) );\n        record.setSecondNode( longFromIntAndMod( secondNode, secondNodeMod ) );\n        record.setType( type );\n        record.setInUse( inUse );\n\n        long firstPrevRel = cursor.getUnsignedInt();\n        long firstPrevRelMod = (typeInt & 0xE000000L) << 7;\n        record.setFirstPrevRel( longFromIntAndMod( firstPrevRel, firstPrevRelMod ) );\n\n        long firstNextRel = cursor.getUnsignedInt();\n        long firstNextRelMod = (typeInt & 0x1C00000L) << 10;\n        record.setFirstNextRel( longFromIntAndMod( firstNextRel, firstNextRelMod ) );\n\n        long secondPrevRel = cursor.getUnsignedInt();\n        long secondPrevRelMod = (typeInt & 0x380000L) << 13;\n        record.setSecondPrevRel( longFromIntAndMod( secondPrevRel, secondPrevRelMod ) );\n\n        long secondNextRel = cursor.getUnsignedInt();\n        long secondNextRelMod = (typeInt & 0x70000L) << 16;\n        record.setSecondNextRel( longFromIntAndMod( secondNextRel, secondNextRelMod ) );\n\n        long nextProp = cursor.getUnsignedInt();\n        long nextPropMod = (inUseByte & 0xF0L) << 28;\n\n        byte extraByte = cursor.getByte();\n\n        record.setFirstInFirstChain( (extraByte & 0x1) != 0 );\n        record.setFirstInSecondChain( (extraByte & 0x2) != 0 );\n\n        record.setNextProp( longFromIntAndMod( nextProp, nextPropMod ) );\n        return true;\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public RelationshipRecord getRecord( long id, RelationshipRecord target, RecordLoad loadMode )\n    {\n        try ( PageCursor cursor = storeFile.io( pageIdForRecord( id ), PF_SHARED_LOCK ) )\n        {\n            if ( cursor.next() )\n            {\n                RelationshipRecord record;\n                do\n                {\n                    record = getRecord( id, cursor, loadMode, target );\n                } while ( cursor.shouldRetry() );\n                return record;\n            }\n            else if ( loadMode == RecordLoad.NORMAL )\n            {\n                throw new InvalidRecordException( \"RelationshipRecord[\" + id + \"] not in use\" );\n            }\n            else if ( loadMode == RecordLoad.CHECK )\n            {\n                return null;\n            }\n            else // force\n            {\n                return new RelationshipRecord( id, -1, -1, -1 );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( e );\n        }\n    }","id":87154,"modified_method":"public boolean fillRecord( long id, RelationshipRecord target, RecordLoad loadMode )\n    {\n        try ( PageCursor cursor = storeFile.io( pageIdForRecord( id ), PF_SHARED_LOCK ) )\n        {\n            if ( cursor.next() )\n            {\n                boolean success;\n                do\n                {\n                    success = readRecord( id, cursor, loadMode, target );\n                } while ( cursor.shouldRetry() );\n                return success;\n            }\n            else if ( loadMode == RecordLoad.NORMAL )\n            {\n                throw new InvalidRecordException( \"RelationshipRecord[\" + id + \"] not in use\" );\n            }\n            else if ( loadMode == RecordLoad.CHECK )\n            {\n                return false;\n            }\n            else // force\n            {\n                target.setId( id );\n                target.setType( -1 );\n                target.setFirstNode( -1 );\n                target.setSecondNode( -1 );\n                return true;\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new UnderlyingStorageException( e );\n        }\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public RelationshipRecord forceGetRecord( long id )\n    {\n        try\n        {\n            assertIdExists( id );\n        }\n        catch ( InvalidRecordException e )\n        {\n            return new RelationshipRecord( id, -1, -1, -1 );\n        }\n        return getRecord( id, new RelationshipRecord( id ), RecordLoad.FORCE );\n    }","id":87155,"modified_method":"@Override\n    public RelationshipRecord forceGetRecord( long id )\n    {\n        try\n        {\n            assertIdExists( id );\n        }\n        catch ( InvalidRecordException e )\n        {\n            return new RelationshipRecord( id, -1, -1, -1 );\n        }\n\n        RelationshipRecord record = new RelationshipRecord( -1 );\n\n        if ( fillRecord( id, record, RecordLoad.FORCE ) )\n        {\n            return record;\n        }\n        else\n        {\n            return null;\n        }\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected final void process()\n    {\n        long highId = relationshipStore.getHighestPossibleIdInUse();\n        RelationshipRecord heavilyReusedRecord = new RelationshipRecord( -1 );\n        for ( long i = highId; i >= 0; i-- )\n        {\n            RelationshipRecord record = relationshipStore.getRecord( i, heavilyReusedRecord, RecordLoad.CHECK );\n            if ( record != null && process( record ) )\n            {\n                relationshipStore.updateRecord( record );\n            }\n            itemProcessed();\n        }\n    }","id":87156,"modified_method":"@Override\n    protected final void process()\n    {\n        long highId = relationshipStore.getHighestPossibleIdInUse();\n        RelationshipRecord heavilyReusedRecord = new RelationshipRecord( -1 );\n        for ( long i = highId; i >= 0; i-- )\n        {\n            if ( relationshipStore.fillRecord( i, heavilyReusedRecord, RecordLoad.CHECK )\n                    && process( heavilyReusedRecord ) )\n            {\n                relationshipStore.updateRecord( heavilyReusedRecord );\n            }\n            itemProcessed();\n        }\n    }","commit_id":"f9038cbc9460a1b2a957f9c00ec3de20bbe197eb","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\t\tif (_value != null)\n\t\t\trender(renderer, \"value\", _value);\n\t}","id":87157,"modified_method":"protected void renderProperties(org.zkoss.zk.ui.sys.ContentRenderer renderer)\n\tthrows java.io.IOException {\n\t\tsuper.renderProperties(renderer);\n\t\tif (_value != null)\n\t\t\trender(renderer, \"value\", _value);\n\t\tresolveGroup(false);\n\t\tif (_group != null)\n\t\t\trender(renderer, \"$group\", _group.getUuid());\n\t}","commit_id":"03add39c224f4cd1ee2ead803a52b61526e47d6a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns {@link Radiogroup} that this radio button belongs to.\n\t * It is the nearest ancestor {@link Radiogroup}.\n\t * In other words, it searches up the parent, parent's parent\n\t * and so on for any {@link Radiogroup} instance.\n\t * If found this radio belongs the found radiogroup.\n\t * If not, this radio itself is a group.\n\t */\n\tpublic Radiogroup getRadiogroup() {\n\t\tfor (Component p = this;;) {\n\t\t\tComponent q = p.getParent();\n\t\t\tif ((q instanceof Radiogroup) || q == null)\n\t\t\t\treturn (Radiogroup)q;\n\t\t\tp = q;\n\t\t}\n\t}","id":87158,"modified_method":"/** Returns {@link Radiogroup} that this radio button belongs to.\n\t * It is the nearest ancestor {@link Radiogroup}.\n\t * In other words, it searches up the parent, parent's parent\n\t * and so on for any {@link Radiogroup} instance.\n\t * If found this radio belongs the found radiogroup.\n\t * If not, this radio itself is a group.\n\t */\n\tpublic Radiogroup getRadiogroup() {\n\t\tresolveGroup(false);\n\t\tif (_group != null)\n\t\t\treturn _group;\n\n\t\tfor (Component p = this;;) {\n\t\t\tComponent q = p.getParent();\n\t\t\tif ((q instanceof Radiogroup) || q == null)\n\t\t\t\treturn (Radiogroup)q;\n\t\t\tp = q;\n\t\t}\n\t}","commit_id":"03add39c224f4cd1ee2ead803a52b61526e47d6a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Fix the selected index, _jsel, assuming there are no selected one\n\t * before (and excludes) j-the radio button.\n\t */\n\t/*package*/ void fixSelectedIndex() {\n\t\t_jsel = fixSelIndex(this, new MutableInteger(0));\n\t}","id":87159,"modified_method":"/** Fix the selected index, _jsel, assuming there are no selected one\n\t * before (and excludes) j-the radio button.\n\t */\n\t/*package*/ void fixSelectedIndex() {\n\t\tfinal MutableInteger cur = new MutableInteger(0);\n\t\t_jsel = fixSelIndex(this, cur);\n\n\t\tif (_jsel < 0 && _externs != null)\n\t\t\tfor (Iterator it = _externs.iterator(); it.hasNext();) {\n\t\t\t\tfinal Radio radio = (Radio)it.next();\n\t\t\t\tif (!isRedudant(radio)) {\n\t\t\t\t\tif (radio.isSelected()) {\n\t\t\t\t\t\t_jsel = cur.value;\n\t\t\t\t\t\tbreak; //found\n\t\t\t\t\t}\n\t\t\t\t\t++cur.value;\n\t\t\t\t}\n\t\t\t}\n\t}","commit_id":"03add39c224f4cd1ee2ead803a52b61526e47d6a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the number of radio buttons in this group.\n\t */\n\tpublic int getItemCount() {\n\t\treturn countItems(this);\n\t}","id":87160,"modified_method":"/** Returns the number of radio buttons in this group.\n\t */\n\tpublic int getItemCount() {\n\t\tint sum = countItems(this);\n\t\tif (_externs != null)\n\t\t\tfor (Iterator it = _externs.iterator(); it.hasNext();) {\n\t\t\t\tfinal Radio radio = (Radio)it.next();\n\t\t\t\tif (!isRedudant(radio))\n\t\t\t\t\t++sum;\n\t\t\t}\n\t\treturn sum;\n\t}","commit_id":"03add39c224f4cd1ee2ead803a52b61526e47d6a","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the radio button at the specified index.\n\t */\n\tpublic Radio getItemAtIndex(int index) {\n\t\tif (index < 0)\n\t\t\tthrow new IndexOutOfBoundsException(\"Wrong index: \"+index);\n\n\t\tfinal MutableInteger cur = new MutableInteger(0);\n\t\tfinal Radio radio = getAt(this, cur, index);\n\t\tif (radio == null)\n\t\t\tthrow new IndexOutOfBoundsException(index+\" out of 0..\"+(cur.value-1));\n\t\treturn radio;\n\t}","id":87161,"modified_method":"/** Returns the radio button at the specified index.\n\t */\n\tpublic Radio getItemAtIndex(int index) {\n\t\tif (index < 0)\n\t\t\tthrow new IndexOutOfBoundsException(\"Wrong index: \"+index);\n\n\t\tfinal MutableInteger cur = new MutableInteger(0);\n\t\tRadio radio = getAt(this, cur, index);\n\t\tif (radio != null)\n\t\t\treturn radio;\n\t\tif (_externs != null)\n\t\t\tfor (Iterator it = _externs.iterator(); it.hasNext();) {\n\t\t\t\tradio = (Radio)it.next();\n\t\t\t\tif (!isRedudant(radio) && cur.value++ == index)\n\t\t\t\t\treturn radio;\n\t\t\t}\n\t\tthrow new IndexOutOfBoundsException(index+\" out of 0..\"+(cur.value-1));\n\t}","commit_id":"03add39c224f4cd1ee2ead803a52b61526e47d6a","url":"https://github.com/zkoss/zk"},{"original_method":"/**  Removes the child radio button in the list box at the given index.\n\t * @return the removed radio button.\n\t */\n\tpublic Radio removeItemAt(int index) {\n\t\tfinal Radio item = getItemAtIndex(index);\n\t\tremoveChild(item);\n\t\treturn item;\n\t}","id":87162,"modified_method":"/**  Removes the child radio button in the radio group at the given index.\n\t * @return the removed radio button.\n\t */\n\tpublic Radio removeItemAt(int index) {\n\t\tfinal Radio item = getItemAtIndex(index);\n\t\tif (item != null && !removeExternal(item)) {\n\t\t\tfinal Component p = item.getParent();\n\t\t\tif (p != null)\n\t\t\t\tp.removeChild(item);\n\t\t}\n\t\treturn item;\n\t}","commit_id":"03add39c224f4cd1ee2ead803a52b61526e47d6a","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n     * @param ldr Loader.\n     */\n    private void onUndeploy0(final ClassLoader ldr) {\n        for (final GridCacheContext<K, V> cacheCtx : cctx.cacheContexts()) {\n            GridCacheAdapter<K, V> cache = cacheCtx.cache();\n\n            Set<K> keySet = cache.keySet(cacheCtx.vararg(\n                new P1<GridCacheEntry<K, V>>() {\n                    @Override public boolean apply(GridCacheEntry<K, V> e) {\n                        return cacheCtx.isNear() ? undeploy(e, cacheCtx.near()) || undeploy(e, cacheCtx.near().dht()) :\n                            undeploy(e, cacheCtx.cache());\n                    }\n\n                    /**\n                     * @param e Entry.\n                     * @param cache Cache.\n                     * @return {@code True} if entry should be undeployed.\n                     */\n                    private boolean undeploy(GridCacheEntry<K, V> e, GridCacheAdapter<K, V> cache) {\n                        K k = e.getKey();\n\n                        GridCacheEntryEx<K, V> entry = cache.peekEx(e.getKey());\n\n                        if (entry == null)\n                            return false;\n\n                        V v;\n\n                        try {\n                            v = entry.peek(GridCachePeekMode.GLOBAL, CU.<K, V>empty());\n                        }\n                        catch (GridCacheEntryRemovedException ignore) {\n                            return false;\n                        }\n                        catch (IgniteException ignore) {\n                            // Peek can throw runtime exception if unmarshalling failed.\n                            return true;\n                        }\n\n                        assert k != null : \"Key cannot be null for cache entry: \" + e;\n\n                        ClassLoader keyLdr = U.detectObjectClassLoader(k);\n                        ClassLoader valLdr = U.detectObjectClassLoader(v);\n\n                        boolean res = F.eq(ldr, keyLdr) || F.eq(ldr, valLdr);\n\n                        if (log.isDebugEnabled())\n                            log.debug(\"Finished examining entry [entryCls=\" + e.getClass() +\n                                \", key=\" + k + \", keyCls=\" + k.getClass() +\n                                \", valCls=\" + (v != null ? v.getClass() : \"null\") +\n                                \", keyLdr=\" + keyLdr + \", valLdr=\" + valLdr + \", res=\" + res + ']');\n\n                        return res;\n                    }\n                }));\n\n            Collection<K> keys = new ArrayList<>();\n\n            for (K k : keySet)\n                keys.add(k);\n\n            if (log.isDebugEnabled())\n                log.debug(\"Finished searching keys for undeploy [keysCnt=\" + keys.size() + ']');\n\n            cache.clearAll(keys, true);\n\n            if (cacheCtx.isNear())\n                cacheCtx.near().dht().clearAll(keys, true);\n\n            GridCacheQueryManager<K, V> qryMgr = cacheCtx.queries();\n\n            if (qryMgr != null)\n                qryMgr.onUndeploy(ldr);\n\n            // Examine swap for entries to undeploy.\n            int swapUndeployCnt = cacheCtx.isNear() ?\n                cacheCtx.near().dht().context().swap().onUndeploy(ldr) :\n                cacheCtx.swap().onUndeploy(ldr);\n\n            if (cacheCtx.system())\n                continue;\n\n            U.quietAndWarn(log, \"\");\n            U.quietAndWarn(\n                log,\n                \"Cleared all cache entries for undeployed class loader [cacheName=\" + cacheCtx.namexx() +\n                    \", undeployCnt=\" + keys.size() + \", swapUndeployCnt=\" + swapUndeployCnt +\n                    \", clsLdr=\" + ldr.getClass().getName() + ']',\n                \"Cleared all cache entries for undeployed class loader for cache: \" + cacheCtx.namexx());\n            U.quietAndWarn(\n                log,\n                \"  ^-- Cache auto-undeployment happens in SHARED deployment mode \" +\n                    \"(to turn off, switch to CONTINUOUS mode)\");\n            U.quietAndWarn(log, \"\");\n        }\n\n        // Avoid class caching issues inside classloader.\n        globalLdr = new CacheClassLoader();\n    }","id":87163,"modified_method":"/**\n     * @param ldr Loader.\n     */\n    private void onUndeploy0(final ClassLoader ldr, final GridCacheContext<K, V> cacheCtx) {\n        GridCacheAdapter<K, V> cache = cacheCtx.cache();\n\n        Set<K> keySet = cache.keySet(cacheCtx.vararg(\n            new P1<GridCacheEntry<K, V>>() {\n                @Override public boolean apply(GridCacheEntry<K, V> e) {\n                    return cacheCtx.isNear() ? undeploy(e, cacheCtx.near()) || undeploy(e, cacheCtx.near().dht()) :\n                        undeploy(e, cacheCtx.cache());\n                }\n\n                /**\n                 * @param e Entry.\n                 * @param cache Cache.\n                 * @return {@code True} if entry should be undeployed.\n                 */\n                private boolean undeploy(GridCacheEntry<K, V> e, GridCacheAdapter<K, V> cache) {\n                    K k = e.getKey();\n\n                    GridCacheEntryEx<K, V> entry = cache.peekEx(e.getKey());\n\n                    if (entry == null)\n                        return false;\n\n                    V v;\n\n                    try {\n                        v = entry.peek(GridCachePeekMode.GLOBAL, CU.<K, V>empty());\n                    }\n                    catch (GridCacheEntryRemovedException ignore) {\n                        return false;\n                    }\n                    catch (IgniteException ignore) {\n                        // Peek can throw runtime exception if unmarshalling failed.\n                        return true;\n                    }\n\n                    assert k != null : \"Key cannot be null for cache entry: \" + e;\n\n                    ClassLoader keyLdr = U.detectObjectClassLoader(k);\n                    ClassLoader valLdr = U.detectObjectClassLoader(v);\n\n                    boolean res = F.eq(ldr, keyLdr) || F.eq(ldr, valLdr);\n\n                    if (log.isDebugEnabled())\n                        log.debug(\"Finished examining entry [entryCls=\" + e.getClass() +\n                            \", key=\" + k + \", keyCls=\" + k.getClass() +\n                            \", valCls=\" + (v != null ? v.getClass() : \"null\") +\n                            \", keyLdr=\" + keyLdr + \", valLdr=\" + valLdr + \", res=\" + res + ']');\n\n                    return res;\n                }\n            }));\n\n        Collection<K> keys = new ArrayList<>();\n\n        for (K k : keySet)\n            keys.add(k);\n\n        if (log.isDebugEnabled())\n            log.debug(\"Finished searching keys for undeploy [keysCnt=\" + keys.size() + ']');\n\n        cache.clearAll(keys, true);\n\n        if (cacheCtx.isNear())\n            cacheCtx.near().dht().clearAll(keys, true);\n\n        GridCacheQueryManager<K, V> qryMgr = cacheCtx.queries();\n\n        if (qryMgr != null)\n            qryMgr.onUndeploy(ldr);\n\n        // Examine swap for entries to undeploy.\n        int swapUndeployCnt = cacheCtx.isNear() ?\n            cacheCtx.near().dht().context().swap().onUndeploy(ldr) :\n            cacheCtx.swap().onUndeploy(ldr);\n\n        if (!cacheCtx.system()) {\n            U.quietAndWarn(log, \"\");\n            U.quietAndWarn(\n                log,\n                \"Cleared all cache entries for undeployed class loader [cacheName=\" + cacheCtx.namexx() +\n                    \", undeployCnt=\" + keys.size() + \", swapUndeployCnt=\" + swapUndeployCnt +\n                    \", clsLdr=\" + ldr.getClass().getName() + ']',\n                \"Cleared all cache entries for undeployed class loader for cache: \" + cacheCtx.namexx());\n            U.quietAndWarn(\n                log,\n                \"  ^-- Cache auto-undeployment happens in SHARED deployment mode \" +\n                    \"(to turn off, switch to CONTINUOUS mode)\");\n            U.quietAndWarn(log, \"\");\n        }\n\n        // Avoid class caching issues inside classloader.\n        globalLdr = new CacheClassLoader();\n    }","commit_id":"42d94fe229477d9048d9b389a2472ff6f6ff2596","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Undeploys given class loader.\n     *\n     * @param ldr Class loader to undeploy.\n     */\n    public void onUndeploy(final ClassLoader ldr) {\n        assert ldr != null;\n\n        if (log.isDebugEnabled())\n            log.debug(\"Received onUndeploy() request [ldr=\" + ldr + \", cctx=\" + cctx + ']');\n\n        undeploys.add(new CA() {\n            @Override public void apply() {\n                onUndeploy0(ldr);\n            }\n        });\n\n        for (GridCacheContext<K, V> cacheCtx : cctx.cacheContexts()) {\n            // Unwind immediately for local and replicate caches.\n            // We go through preloader for proper synchronization.\n            if (cacheCtx.isLocal())\n                cacheCtx.preloader().unwindUndeploys();\n        }\n    }","id":87164,"modified_method":"/**\n     * Undeploys given class loader.\n     *\n     * @param ldr Class loader to undeploy.\n     */\n    public void onUndeploy(final ClassLoader ldr) {\n        assert ldr != null;\n\n        if (log.isDebugEnabled())\n            log.debug(\"Received onUndeploy() request [ldr=\" + ldr + \", cctx=\" + cctx + ']');\n\n        for (final GridCacheContext<K, V> cacheCtx : cctx.cacheContexts()) {\n            undeploys.putIfAbsent(cacheCtx, new ConcurrentLinkedQueue<CA>());\n\n            undeploys.get(cacheCtx).add(new CA() {\n                @Override\n                public void apply() {\n                    onUndeploy0(ldr, cacheCtx);\n                }\n            });\n        }\n\n        for (GridCacheContext<K, V> cacheCtx : cctx.cacheContexts()) {\n            // Unwind immediately for local and replicate caches.\n            // We go through preloader for proper synchronization.\n            if (cacheCtx.isLocal())\n                cacheCtx.preloader().unwindUndeploys();\n        }\n    }","commit_id":"42d94fe229477d9048d9b389a2472ff6f6ff2596","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void unwindUndeploys() {\n        cctx.deploy().unwind();\n    }","id":87165,"modified_method":"/** {@inheritDoc} */\n    @Override public void unwindUndeploys() {\n        cctx.deploy().unwind(cctx);\n    }","commit_id":"42d94fe229477d9048d9b389a2472ff6f6ff2596","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     *\n     */\n    void unwindUndeploys() {\n        demandLock.writeLock().lock();\n\n        try {\n            cctx.deploy().unwind();\n        }\n        finally {\n            demandLock.writeLock().unlock();\n        }\n    }","id":87166,"modified_method":"/**\n     *\n     */\n    void unwindUndeploys() {\n        demandLock.writeLock().lock();\n\n        try {\n            cctx.deploy().unwind(cctx);\n        }\n        finally {\n            demandLock.writeLock().unlock();\n        }\n    }","commit_id":"42d94fe229477d9048d9b389a2472ff6f6ff2596","url":"https://github.com/apache/ignite"},{"original_method":"public String getFieldHTMLByName(\n\t\t\tPageContext pageContext, String className, long classPK,\n\t\t\tString fieldName, int repeatableIndex, Fields fields,\n\t\t\tString namespace, String mode, boolean readOnly, Locale locale)\n\t\tthrows Exception {\n\n\t\tString xPathExpression =\n\t\t\t\"dynamic-element[@name=\".concat(\n\t\t\t\tHtmlUtil.escapeXPathAttribute(fieldName)).concat(\"]\");\n\n\t\tXPath xPathSelector = SAXReaderUtil.createXPath(xPathExpression);\n\n\t\tString xsd = DDMXSDUtil.getXSD(className, classPK);\n\n\t\tDocument document = SAXReaderUtil.read(xsd);\n\n\t\tNode node = xPathSelector.selectSingleNode(document.getRootElement());\n\n\t\tElement fieldElement = (Element)node.asXPathResult(node.getParent());\n\n\t\tif (repeatableIndex > 0) {\n\t\t\tfieldElement.addAttribute(\n\t\t\t\t\"repeatableIndex\", String.valueOf(repeatableIndex));\n\t\t}\n\n\t\treturn DDMXSDUtil.getFieldHTML(\n\t\t\tpageContext, fieldElement, fields, namespace, mode, readOnly,\n\t\t\tlocale);\n\t}","id":87167,"modified_method":"public String getFieldHTMLByName(\n\t\t\tPageContext pageContext, long classNameId, long classPK,\n\t\t\tString fieldName, int repeatableIndex, Fields fields,\n\t\t\tString namespace, String mode, boolean readOnly, Locale locale)\n\t\tthrows Exception {\n\n\t\tString xsd = DDMXSDUtil.getXSD(classNameId, classPK);\n\n\t\tDocument document = SAXReaderUtil.read(xsd);\n\n\t\tString xPathExpression =\n\t\t\t\"dynamic-element[@name=\".concat(\n\t\t\t\tHtmlUtil.escapeXPathAttribute(fieldName)).concat(\"]\");\n\n\t\tXPath xPathSelector = SAXReaderUtil.createXPath(xPathExpression);\n\n\t\tNode node = xPathSelector.selectSingleNode(document.getRootElement());\n\n\t\tElement fieldElement = (Element)node.asXPathResult(node.getParent());\n\n\t\tif (repeatableIndex > 0) {\n\t\t\tfieldElement.addAttribute(\n\t\t\t\t\"repeatableIndex\", String.valueOf(repeatableIndex));\n\t\t}\n\n\t\treturn DDMXSDUtil.getFieldHTML(\n\t\t\tpageContext, fieldElement, fields, namespace, mode, readOnly,\n\t\t\tlocale);\n\t}","commit_id":"2d56c82eb878a5b06497f2fa0733be7b955179a0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getXSD(String className, long classPK) throws Exception {\n\t\tString xsd = null;\n\n\t\tif (Validator.isNotNull(className) && (classPK > 0)) {\n\t\t\tif (className.equals(DDMTemplate.class.getName())) {\n\t\t\t\tDDMTemplate template = DDMTemplateServiceUtil.getTemplate(\n\t\t\t\t\tclassPK);\n\n\t\t\t\txsd = template.getScript();\n\t\t\t}\n\t\t\telse if (className.equals(DDMStructure.class.getName())) {\n\t\t\t\tDDMStructure structure = DDMStructureServiceUtil.getStructure(\n\t\t\t\t\tclassPK);\n\n\t\t\t\txsd = structure.getCompleteXsd();\n\t\t\t}\n\t\t}\n\n\t\treturn xsd;\n\t}","id":87168,"modified_method":"public String getXSD(long classNameId, long classPK) throws Exception {\n\t\tString xsd = null;\n\n\t\tif ((classNameId > 0) && (classPK > 0)) {\n\t\t\tlong ddmStructureClassNameId = PortalUtil.getClassNameId(\n\t\t\t\tDDMStructure.class);\n\n\t\t\tlong ddmTemplateClassNameId = PortalUtil.getClassNameId(\n\t\t\t\tDDMTemplate.class);\n\n\t\t\tif (classNameId == ddmStructureClassNameId) {\n\t\t\t\tDDMStructure structure = DDMStructureServiceUtil.getStructure(\n\t\t\t\t\tclassPK);\n\n\t\t\t\txsd = structure.getCompleteXsd();\n\t\t\t}\n\t\t\telse if (classNameId == ddmTemplateClassNameId) {\n\t\t\t\tDDMTemplate template = DDMTemplateServiceUtil.getTemplate(\n\t\t\t\t\tclassPK);\n\n\t\t\t\txsd = template.getScript();\n\t\t\t}\n\t\t}\n\n\t\treturn xsd;\n\t}","commit_id":"2d56c82eb878a5b06497f2fa0733be7b955179a0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getFieldHTMLByName(\n\t\t\tPageContext pageContext, String className, long classPK,\n\t\t\tString fieldName, int repeatableIndex, Fields fields,\n\t\t\tString namespace, String mode, boolean readOnly, Locale locale)\n\t\tthrows Exception {\n\n\t\treturn getDDMXSD().getFieldHTMLByName(\n\t\t\tpageContext, className, classPK, fieldName, repeatableIndex, fields,\n\t\t\tnamespace, mode, readOnly, locale);\n\t}","id":87169,"modified_method":"public static String getFieldHTMLByName(\n\t\t\tPageContext pageContext, long classNameId, long classPK,\n\t\t\tString fieldName, int repeatableIndex, Fields fields,\n\t\t\tString namespace, String mode, boolean readOnly, Locale locale)\n\t\tthrows Exception {\n\n\t\treturn getDDMXSD().getFieldHTMLByName(\n\t\t\tpageContext, classNameId, classPK, fieldName, repeatableIndex,\n\t\t\tfields, namespace, mode, readOnly, locale);\n\t}","commit_id":"2d56c82eb878a5b06497f2fa0733be7b955179a0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getXSD(String className, long classPK)\n\t\tthrows Exception {\n\n\t\treturn getDDMXSD().getXSD(className, classPK);\n\t}","id":87170,"modified_method":"public static String getXSD(long classNameId, long classPK)\n\t\tthrows Exception {\n\n\t\treturn getDDMXSD().getXSD(classNameId, classPK);\n\t}","commit_id":"2d56c82eb878a5b06497f2fa0733be7b955179a0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tJspFactory factory = JspFactory.getDefaultFactory();\n\n\t\t\tServlet servlet = getServlet();\n\n\t\t\tPageContext pageContext = factory.getPageContext(\n\t\t\t\tservlet, request, response, null, true,\n\t\t\t\tJspWriter.DEFAULT_BUFFER, true);\n\n\t\t\tString className = ParamUtil.getString(request, \"className\");\n\t\t\tlong classPK = ParamUtil.getLong(request, \"classPK\");\n\t\t\tString fieldName = ParamUtil.getString(request, \"fieldName\");\n\t\t\tboolean readOnly = ParamUtil.getBoolean(request, \"readOnly\");\n\t\t\tint repeatableIndex = ParamUtil.getInteger(\n\t\t\t\trequest, \"repeatableIndex\");\n\n\t\t\tLocale locale = PortalUtil.getLocale(request);\n\n\t\t\tString fieldHTML = DDMXSDUtil.getFieldHTMLByName(\n\t\t\t\tpageContext, className, classPK, fieldName, repeatableIndex,\n\t\t\t\tnull, null, null, readOnly, locale);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_HTML);\n\n\t\t\tServletResponseUtil.write(response, fieldHTML);\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPortalUtil.sendError(e, request, response);\n\n\t\t\treturn null;\n\t\t}\n\t}","id":87171,"modified_method":"@Override\n\tpublic ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tJspFactory factory = JspFactory.getDefaultFactory();\n\n\t\t\tServlet servlet = getServlet();\n\n\t\t\tPageContext pageContext = factory.getPageContext(\n\t\t\t\tservlet, request, response, null, true,\n\t\t\t\tJspWriter.DEFAULT_BUFFER, true);\n\n\t\t\tlong classNameId = ParamUtil.getLong(request, \"classNameId\");\n\t\t\tlong classPK = ParamUtil.getLong(request, \"classPK\");\n\t\t\tString fieldName = ParamUtil.getString(request, \"fieldName\");\n\t\t\tboolean readOnly = ParamUtil.getBoolean(request, \"readOnly\");\n\t\t\tint repeatableIndex = ParamUtil.getInteger(\n\t\t\t\trequest, \"repeatableIndex\");\n\n\t\t\tLocale locale = PortalUtil.getLocale(request);\n\n\t\t\tString fieldHTML = DDMXSDUtil.getFieldHTMLByName(\n\t\t\t\tpageContext, classNameId, classPK, fieldName, repeatableIndex,\n\t\t\t\tnull, null, null, readOnly, locale);\n\n\t\t\tresponse.setContentType(ContentTypes.TEXT_HTML);\n\n\t\t\tServletResponseUtil.write(response, fieldHTML);\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPortalUtil.sendError(e, request, response);\n\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"2d56c82eb878a5b06497f2fa0733be7b955179a0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteGroup(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tif (PortalUtil.isSystemGroup(group.getName())) {\n\t\t\tthrow new RequiredGroupException();\n\t\t}\n\n\t\t// Layout sets\n\n\t\ttry {\n\t\t\tlayoutSetLocalService.deleteLayoutSet(groupId, true);\n\t\t}\n\t\tcatch (NoSuchLayoutSetException nslse) {\n\t\t}\n\n\t\ttry {\n\t\t\tlayoutSetLocalService.deleteLayoutSet(groupId, false);\n\t\t}\n\t\tcatch (NoSuchLayoutSetException nslse) {\n\t\t}\n\n\t\t// Role\n\n\t\ttry {\n\t\t\tRole role = roleLocalService.getGroupRole(\n\t\t\t\tgroup.getCompanyId(), groupId);\n\n\t\t\troleLocalService.deleteRole(role.getRoleId());\n\t\t}\n\t\tcatch (NoSuchRoleException nsre) {\n\t\t}\n\n\t\t// Group roles\n\n\t\tuserGroupRoleLocalService.deleteUserGroupRolesByGroupId(groupId);\n\n\t\t// Membership requests\n\n\t\tmembershipRequestLocalService.deleteMembershipRequests(\n\t\t\tgroup.getGroupId());\n\n\t\t// Blogs\n\n\t\tblogsEntryLocalService.deleteEntries(groupId);\n\t\tblogsStatsUserLocalService.deleteStatsUserByGroupId(groupId);\n\n\t\t// Bookmarks\n\n\t\tbookmarksFolderLocalService.deleteFolders(groupId);\n\n\t\t// Calendar\n\n\t\tcalEventLocalService.deleteEvents(groupId);\n\n\t\t// Document library\n\n\t\tdlFolderLocalService.deleteFolders(groupId);\n\n\t\t// Image gallery\n\n\t\tigFolderLocalService.deleteFolders(groupId);\n\n\t\t// Journal\n\n\t\tjournalArticleLocalService.deleteArticles(groupId);\n\n\t\t// Message boards\n\n\t\tmbBanLocalService.deleteBansByGroupId(groupId);\n\t\tmbCategoryLocalService.deleteCategories(groupId);\n\t\tmbStatsUserLocalService.deleteStatsUserByGroupId(groupId);\n\n\t\t// Polls\n\n\t\tpollsQuestionLocalService.deleteQuestions(groupId);\n\n\t\t// Shopping\n\n\t\tshoppingCartLocalService.deleteGroupCarts(groupId);\n\n\t\t// Wiki\n\n\t\twikiNodeLocalService.deleteNodes(groupId);\n\n\t\t// Resources\n\n\t\tIterator itr = resourceFinder.findByC_P(\n\t\t\tgroup.getCompanyId(), String.valueOf(groupId)).iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tResource resource = (Resource)itr.next();\n\n\t\t\tresourceLocalService.deleteResource(resource);\n\t\t}\n\n\t\tString className = PortalUtil.getClassName(group.getClassNameId());\n\n\t\tif (((group.getClassNameId() <= 0) && (group.getClassPK() <= 0)) ||\n\t\t\t(className.equals(Organization.class.getName()))) {\n\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tgroup.getCompanyId(), Group.class.getName(),\n\t\t\t\tResourceImpl.SCOPE_INDIVIDUAL, group.getGroupId());\n\t\t}\n\n\t\t// Group\n\n\t\tgroupPersistence.remove(groupId);\n\n\t\t// Permission cache\n\n\t\tPermissionCacheUtil.clearCache();\n\t}","id":87172,"modified_method":"public void deleteGroup(long groupId)\n\t\tthrows PortalException, SystemException {\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tif (PortalUtil.isSystemGroup(group.getName())) {\n\t\t\tthrow new RequiredGroupException();\n\t\t}\n\n\t\t// Layout sets\n\n\t\ttry {\n\t\t\tlayoutSetLocalService.deleteLayoutSet(groupId, true);\n\t\t}\n\t\tcatch (NoSuchLayoutSetException nslse) {\n\t\t}\n\n\t\ttry {\n\t\t\tlayoutSetLocalService.deleteLayoutSet(groupId, false);\n\t\t}\n\t\tcatch (NoSuchLayoutSetException nslse) {\n\t\t}\n\n\t\t// Role\n\n\t\ttry {\n\t\t\tRole role = roleLocalService.getGroupRole(\n\t\t\t\tgroup.getCompanyId(), groupId);\n\n\t\t\troleLocalService.deleteRole(role.getRoleId());\n\t\t}\n\t\tcatch (NoSuchRoleException nsre) {\n\t\t}\n\n\t\t// Group roles\n\n\t\tuserGroupRoleLocalService.deleteUserGroupRolesByGroupId(groupId);\n\n\t\t// Membership requests\n\n\t\tmembershipRequestLocalService.deleteMembershipRequests(\n\t\t\tgroup.getGroupId());\n\n\t\t// Blogs\n\n\t\tblogsEntryLocalService.deleteEntries(groupId);\n\t\tblogsStatsUserLocalService.deleteStatsUserByGroupId(groupId);\n\n\t\t// Bookmarks\n\n\t\tbookmarksFolderLocalService.deleteFolders(groupId);\n\n\t\t// Calendar\n\n\t\tcalEventLocalService.deleteEvents(groupId);\n\n\t\t// Document library\n\n\t\tdlFolderLocalService.deleteFolders(groupId);\n\n\t\t// Image gallery\n\n\t\tigFolderLocalService.deleteFolders(groupId);\n\n\t\t// Journal\n\n\t\tjournalArticleLocalService.deleteArticles(groupId);\n\n\t\t// Message boards\n\n\t\tmbBanLocalService.deleteBansByGroupId(groupId);\n\t\tmbCategoryLocalService.deleteCategories(groupId);\n\t\tmbStatsUserLocalService.deleteStatsUserByGroupId(groupId);\n\n\t\t// Polls\n\n\t\tpollsQuestionLocalService.deleteQuestions(groupId);\n\n\t\t// Shopping\n\n\t\tshoppingCartLocalService.deleteGroupCarts(groupId);\n\n\t\t// Wiki\n\n\t\twikiNodeLocalService.deleteNodes(groupId);\n\n\t\t// Resources\n\n\t\tIterator itr = resourceFinder.findByC_P(\n\t\t\tgroup.getCompanyId(), String.valueOf(groupId)).iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tResource resource = (Resource)itr.next();\n\n\t\t\tresourceLocalService.deleteResource(resource);\n\t\t}\n\n\t\tlong organizationClassNameId = PortalUtil.getClassNameId(\n\t\t\tOrganization.class.getName());\n\n\t\tif (((group.getClassNameId() <= 0) && (group.getClassPK() <= 0)) ||\n\t\t\t(group.getClassNameId() == organizationClassNameId)) {\n\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tgroup.getCompanyId(), Group.class.getName(),\n\t\t\t\tResourceImpl.SCOPE_INDIVIDUAL, group.getGroupId());\n\t\t}\n\n\t\t// Group\n\n\t\tgroupPersistence.remove(groupId);\n\n\t\t// Permission cache\n\n\t\tPermissionCacheUtil.clearCache();\n\t}","commit_id":"1536e920025ac50ed01d853d3679383c390eaa20","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Add default NullnessAnnotations to given INullnessAnnotationDatabase.\n\t * \n\t * @param database an INullnessAnnotationDatabase\n\t */\n\tpublic static void addDefaultNullnessAnnotations(INullnessAnnotationDatabase database) {\n\t\tif (AnnotationDatabase.IGNORE_BUILTIN_ANNOTATIONS) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean missingClassWarningsSuppressed = AnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(true);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.lang.String\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"out\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"err\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"in\", \"Ljava/io/InputStream;\", true, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.ReferenceQueue\", \"poll\", \"()Ljava/lang/ref/Reference;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.Reference\", \"get\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"newInstance\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"forName\", \"(Ljava/lang/String;)Ljava/lang/Class;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.reflect.Method\", \"getParameterTypes\", \"()[Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"clone\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"toString\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"getClass\", \"()Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Object\", \"equals\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Arrays\", \"asList\", \"([Ljava/lang/Object;)Ljava/util/List;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"<init>\", \"(Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;I)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.nio.channels.SocketChannel\", \"open\", \"()Ljava/nio/channels/SocketChannel;\", true,  NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodAnnotation(\"java.sql.Statement\", \"executeQuery\", \"(Ljava/lang/String;)Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.PreparedStatement\", \"executeQuery\", \"()Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.Connection\", \"prepareStatement\", \"(Ljava/lang/String;)Ljava/sql/PreparedStatement;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.sql.DatabaseMetaData\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getConnection\", \"()Ljava/sql/Connection;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getAttributes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getColumns\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTables\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTypes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTimeDateFunctions\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTypeInfo\", \"()Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getURL\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.package-info\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArrayList\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArraySet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentLinkedQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.Exchanger\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.FutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$WaitQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ThreadPoolExecutor$Worker\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.AbstractExecutorService\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$ConcurrentSkipListSubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$HeadIndex\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Index\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$SubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListSet$ConcurrentSkipListSubSet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingDeque$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue$QNode\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferStack\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Transferer\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.FutureTask\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors\", \"callable\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;\", true, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addWorker\", \"(Ljava/lang/Runnable;Z)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentHashMap$Segment\", \"remove\", \"(Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;\", false, 2, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.CyclicBarrier\", \"<init>\", \"(ILjava/lang/Runnable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors$RunnableAdapter\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentSkipListMap\", \"doRemove\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\tif (ICSE10_NULLNESS_PAPER) {\n\t\tdatabase.addMethodAnnotation(\"java.util.HashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.TreeMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t}\n\t\t\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\n\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$ReadLock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$WriteLock;\", false, NullnessAnnotation.NONNULL);\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorServiceNullnessAnnotationDatabase\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/RunnableFuture;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addIfUnderCorePoolSize\", \"(Ljava/lang/Runnable;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addThread\", \"(Ljava/lang/Runnable;)Ljava/lang/Thread;\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"afterExecute\", \"(Ljava/lang/Runnable;Ljava/lang/Throwable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"containsKey\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"add\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"remove\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tif (true) {\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsValue\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"javax.swing.UIDefaults\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"getProperty\", \"(Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 1, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"org.w3c.dom.Element\", \"setAttribute\", \"(Ljava/lang/String;Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\t\n\t\t}\n\n\n\t\t// addMethodAnnotation(\"java.util.Queue\", \"poll\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.io.BufferedReader\", \"readLine\", \"()Ljava/lang/String;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tAnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(missingClassWarningsSuppressed);\n\t\t\n\t}","id":87173,"modified_method":"/**\n\t * Add default NullnessAnnotations to given INullnessAnnotationDatabase.\n\t * \n\t * @param database an INullnessAnnotationDatabase\n\t */\n\tpublic static void addDefaultNullnessAnnotations(INullnessAnnotationDatabase database) {\n\t\tif (AnnotationDatabase.IGNORE_BUILTIN_ANNOTATIONS) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean missingClassWarningsSuppressed = AnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(true);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.lang.String\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"out\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"err\", \"Ljava/io/PrintStream;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addFieldAnnotation(\"java.lang.System\", \"in\", \"Ljava/io/InputStream;\", true, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.ReferenceQueue\", \"poll\", \"()Ljava/lang/ref/Reference;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.ref.Reference\", \"get\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"newInstance\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Class\", \"forName\", \"(Ljava/lang/String;)Ljava/lang/Class;\", true, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.reflect.Method\", \"getParameterTypes\", \"()[Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"clone\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"toString\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.lang.Object\", \"getClass\", \"()Ljava/lang/Class;\", false, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Object\", \"equals\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Arrays\", \"asList\", \"([Ljava/lang/Object;)Ljava/util/List;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"<init>\", \"(Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;I)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.lang.Integer\", \"parseInt\", \"(Ljava/lang/String;)I\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.nio.channels.SocketChannel\", \"open\", \"()Ljava/nio/channels/SocketChannel;\", true,  NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodAnnotation(\"java.sql.Statement\", \"executeQuery\", \"(Ljava/lang/String;)Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.PreparedStatement\", \"executeQuery\", \"()Ljava/sql/ResultSet;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.Connection\", \"prepareStatement\", \"(Ljava/lang/String;)Ljava/sql/PreparedStatement;\", false,  NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.METHOD, \"java.sql.DatabaseMetaData\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getConnection\", \"()Ljava/sql/Connection;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getAttributes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getColumns\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTables\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getSuperTypes\", \"(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTimeDateFunctions\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getTypeInfo\", \"()Ljava/sql/ResultSet;\", false, NullnessAnnotation.NULLABLE);\n\t\tdatabase.addMethodAnnotation(\"java.sql.DatabaseMetaData\", \"getURL\", \"()Ljava/lang/String;\", false, NullnessAnnotation.NULLABLE);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.package-info\", NullnessAnnotation.NONNULL);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArrayList\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.CopyOnWriteArraySet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentLinkedQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.Exchanger\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.FutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$WaitQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ThreadPoolExecutor$Worker\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.AbstractExecutorService\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$ConcurrentSkipListSubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$HeadIndex\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\t\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Index\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListMap$SubMap\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.ConcurrentSkipListSet$ConcurrentSkipListSubSet\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.LinkedBlockingDeque$Node\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferQueue$QNode\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$TransferStack\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\t\tdatabase.addDefaultAnnotation(AnnotationDatabase.Target.PARAMETER, \"java.util.concurrent.SynchronousQueue$Transferer\", NullnessAnnotation.UNKNOWN_NULLNESS);\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.FutureTask\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors\", \"callable\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;\", true, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addWorker\", \"(Ljava/lang/Runnable;Z)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentHashMap$Segment\", \"remove\", \"(Ljava/lang/Object;ILjava/lang/Object;)Ljava/lang/Object;\", false, 2, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.CyclicBarrier\", \"<init>\", \"(ILjava/lang/Runnable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.Executors$RunnableAdapter\", \"<init>\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ConcurrentSkipListMap\", \"doRemove\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\tif (ICSE10_NULLNESS_PAPER) {\n\t\tdatabase.addMethodAnnotation(\"java.util.HashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.TreeMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t}\n\t\t\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.ConcurrentHashMap\", \"putIfAbsent\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\n\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/Lock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"readLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$ReadLock;\", false, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodAnnotation(\"java.util.concurrent.locks.ReentrantReadWriteLock\", \"writeLock\", \"()Ljava/util/concurrent/locks/ReentrantReadWriteLock$WriteLock;\", false, NullnessAnnotation.NONNULL);\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"submit\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.AbstractExecutorServiceNullnessAnnotationDatabase\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ExecutorCompletionService\", \"newTaskFor\", \"(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/RunnableFuture;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addIfUnderCorePoolSize\", \"(Ljava/lang/Runnable;)Z\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"addThread\", \"(Ljava/lang/Runnable;)Ljava/lang/Thread;\", false, 0, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.concurrent.ThreadPoolExecutor\", \"afterExecute\", \"(Ljava/lang/Runnable;Ljava/lang/Throwable;)V\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\n\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.EnumMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"containsKey\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedMap\", \"remove\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"add\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"remove\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.SortedSet\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsKey\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"containsValue\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"contains\", \"(Ljava/lang/Object;)Z\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Hashtable\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"javax.swing.UIDefaults\", \"put\", \"(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\", false, 1, NullnessAnnotation.CHECK_FOR_NULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"getProperty\", \"(Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 1, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.util.Properties\", \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"org.w3c.dom.Element\", \"setAttribute\", \"(Ljava/lang/String;Ljava/lang/String;)V\", false, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\tdatabase.addMethodParameterAnnotation(\"java.text.DateFormat\", \"parse\", \"(Ljava/lang/String;)Ljava/util/Date;\", true, 0, NullnessAnnotation.NONNULL);\n\t\t\n\t\t\n\t\t\n\n\n\t\t// addMethodAnnotation(\"java.util.Queue\", \"poll\", \"()Ljava/lang/Object;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\t\tdatabase.addMethodAnnotation(\"java.io.BufferedReader\", \"readLine\", \"()Ljava/lang/String;\", false, NullnessAnnotation.CHECK_FOR_NULL);\n\n\t\tAnalysisContext.currentAnalysisContext().setMissingClassWarningsSuppressed(missingClassWarningsSuppressed);\n\t\t\n\t}","commit_id":"0a5a48620c1862685c5ac30a84677f0c553cabff","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\r\n   * Performs the add function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item add(final QueryContext ctx) throws QueryException {\r\n    checkWrite(ctx);\r\n\r\n    final Data data = data(0, ctx);\r\n    final Item it = checkItem(expr[1], ctx);\r\n    final String path = expr.length < 3 ? \"\" : path(2, ctx);\r\n\r\n    ctx.updates.add(new DBAdd(data, it, path, ctx.context, info), ctx);\r\n    return null;\r\n  }","id":87174,"modified_method":"/**\r\n   * Performs the add function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item add(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final Item it = checkItem(expr[1], ctx);\r\n    final String path = expr.length < 3 ? \"\" : path(2, ctx);\r\n\r\n    ctx.updates.add(new DBAdd(data, it, path, ctx.context, info), ctx);\r\n    return null;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the flush function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item flush(final QueryContext ctx) throws QueryException {\r\n    checkWrite(ctx);\r\n    ctx.updates.add(new DBFlush(data(0, ctx), info), ctx);\r\n    return null;\r\n  }","id":87175,"modified_method":"/**\r\n   * Performs the flush function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item flush(final QueryContext ctx) throws QueryException {\r\n    ctx.updates.add(new DBFlush(checkWrite(data(0, ctx), ctx), info), ctx);\r\n    return null;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the optimize function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item optimize(final QueryContext ctx) throws QueryException {\r\n    checkWrite(ctx);\r\n\r\n    final Data data = data(0, ctx);\r\n    final boolean all = expr.length == 2 && checkBln(expr[1], ctx);\r\n    ctx.updates.add(new DBOptimize(data, ctx.context, all, info), ctx);\r\n    return null;\r\n  }","id":87176,"modified_method":"/**\r\n   * Performs the optimize function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item optimize(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final boolean all = expr.length == 2 && checkBln(expr[1], ctx);\r\n    ctx.updates.add(new DBOptimize(data, ctx.context, all, info), ctx);\r\n    return null;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the store function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item store(final QueryContext ctx) throws QueryException {\r\n    checkWrite(ctx);\r\n\r\n    final Data data = data(0, ctx);\r\n    final String path = path(1, ctx);\r\n    if(data.inMemory()) BXDB_MEM.thrw(info, data.meta.name);\r\n    final IOFile file = data.meta.binary(path);\r\n    if(file == null || file.isDir()) RESINV.thrw(info, path);\r\n\r\n    final Item it = checkItem(expr[2], ctx);\r\n    ctx.updates.add(new DBStore(data, path, it, info), ctx);\r\n    return null;\r\n  }","id":87177,"modified_method":"/**\r\n   * Performs the store function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item store(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final String path = path(1, ctx);\r\n    if(data.inMemory()) BXDB_MEM.thrw(info, data.meta.name);\r\n    final IOFile file = data.meta.binary(path);\r\n    if(file == null || file.isDir()) RESINV.thrw(info, path);\r\n\r\n    final Item it = checkItem(expr[2], ctx);\r\n    ctx.updates.add(new DBStore(data, path, it, info), ctx);\r\n    return null;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the replace function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item replace(final QueryContext ctx) throws QueryException {\r\n    checkWrite(ctx);\r\n\r\n    final Data data = data(0, ctx);\r\n    final String path = path(1, ctx);\r\n    final Item doc = checkItem(expr[2], ctx);\r\n\r\n    // remove old documents\r\n    final Resources res = data.resources;\r\n    final IntList pre = res.docs(path, true);\r\n    for(int p = 0; p < pre.size(); p++) {\r\n      ctx.updates.add(new DeleteNode(pre.get(p), data, info), ctx);\r\n    }\r\n\r\n    // delete binary resources\r\n    final IOFile bin = data.inMemory() ? null : data.meta.binary(path);\r\n    if(bin != null) {\r\n      if(bin.exists()) {\r\n        if(bin.isDir()) BXDB_SINGLE.thrw(info);\r\n        ctx.updates.add(new DBStore(data, path, doc, info), ctx);\r\n      } else {\r\n        ctx.updates.add(new DBAdd(data, doc, path, ctx.context, info), ctx);\r\n      }\r\n    }\r\n    return null;\r\n  }","id":87178,"modified_method":"/**\r\n   * Performs the replace function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item replace(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final String path = path(1, ctx);\r\n    final Item doc = checkItem(expr[2], ctx);\r\n\r\n    // remove old documents\r\n    final Resources res = data.resources;\r\n    final IntList pre = res.docs(path, true);\r\n    for(int p = 0; p < pre.size(); p++) {\r\n      ctx.updates.add(new DeleteNode(pre.get(p), data, info), ctx);\r\n    }\r\n\r\n    // delete binary resources\r\n    final IOFile bin = data.inMemory() ? null : data.meta.binary(path);\r\n    if(bin != null) {\r\n      if(bin.exists()) {\r\n        if(bin.isDir()) BXDB_SINGLE.thrw(info);\r\n        ctx.updates.add(new DBStore(data, path, doc, info), ctx);\r\n      } else {\r\n        ctx.updates.add(new DBAdd(data, doc, path, ctx.context, info), ctx);\r\n      }\r\n    }\r\n    return null;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the rename function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item rename(final QueryContext ctx) throws QueryException {\r\n    checkWrite(ctx);\r\n\r\n    final Data data = data(0, ctx);\r\n    final String source = path(1, ctx);\r\n    final String target = path(2, ctx);\r\n\r\n    // the first step of the path should be the database name\r\n    final IntList il = data.resources.docs(source);\r\n    for(int i = 0, is = il.size(); i < is; i++) {\r\n      final int pre = il.get(i);\r\n      final String trg = Rename.target(data, pre, source, target);\r\n      if(trg.isEmpty()) BXDB_EMPTY.thrw(info, this);\r\n      ctx.updates.add(new ReplaceValue(pre, data, info, token(trg)), ctx);\r\n    }\r\n    // rename files\r\n    if(!data.inMemory()) {\r\n      final IOFile src = data.meta.binary(source);\r\n      final IOFile trg = data.meta.binary(target);\r\n      if(src == null || trg == null) UPDBRENAMEERR.thrw(info, src);\r\n      ctx.updates.add(new DBRename(data, src.path(), trg.path(), info), ctx);\r\n    }\r\n    return null;\r\n  }","id":87179,"modified_method":"/**\r\n   * Performs the rename function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item rename(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final String source = path(1, ctx);\r\n    final String target = path(2, ctx);\r\n\r\n    // the first step of the path should be the database name\r\n    final IntList il = data.resources.docs(source);\r\n    for(int i = 0, is = il.size(); i < is; i++) {\r\n      final int pre = il.get(i);\r\n      final String trg = Rename.target(data, pre, source, target);\r\n      if(trg.isEmpty()) BXDB_EMPTY.thrw(info, this);\r\n      ctx.updates.add(new ReplaceValue(pre, data, info, token(trg)), ctx);\r\n    }\r\n    // rename files\r\n    if(!data.inMemory()) {\r\n      final IOFile src = data.meta.binary(source);\r\n      final IOFile trg = data.meta.binary(target);\r\n      if(src == null || trg == null) UPDBRENAMEERR.thrw(info, src);\r\n      ctx.updates.add(new DBRename(data, src.path(), trg.path(), info), ctx);\r\n    }\r\n    return null;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs the delete function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item delete(final QueryContext ctx) throws QueryException {\r\n    checkWrite(ctx);\r\n\r\n    final Data data = data(0, ctx);\r\n    final String path = path(1, ctx);\r\n\r\n    // delete XML resources\r\n    final IntList docs = data.resources.docs(path);\r\n    for(int i = 0, is = docs.size(); i < is; i++) {\r\n      ctx.updates.add(new DeleteNode(docs.get(i), data, info), ctx);\r\n    }\r\n    // delete raw resources\r\n    if(!data.inMemory()) {\r\n      final IOFile bin = data.meta.binary(path);\r\n      if(bin == null) UPDBDELERR.thrw(info, path);\r\n      ctx.updates.add(new DBDelete(data, path, info), ctx);\r\n    }\r\n    return null;\r\n  }","id":87180,"modified_method":"/**\r\n   * Performs the delete function.\r\n   * @param ctx query context\r\n   * @return {@code null}\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item delete(final QueryContext ctx) throws QueryException {\r\n    final Data data = checkWrite(data(0, ctx), ctx);\r\n    final String path = path(1, ctx);\r\n\r\n    // delete XML resources\r\n    final IntList docs = data.resources.docs(path);\r\n    for(int i = 0, is = docs.size(); i < is; i++) {\r\n      ctx.updates.add(new DeleteNode(docs.get(i), data, info), ctx);\r\n    }\r\n    // delete raw resources\r\n    if(!data.inMemory()) {\r\n      final IOFile bin = data.meta.binary(path);\r\n      if(bin == null) UPDBDELERR.thrw(info, path);\r\n      ctx.updates.add(new DBDelete(data, path, info), ctx);\r\n    }\r\n    return null;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Checks if the current user has write permissions. If negative, an\r\n   * exception is thrown.\r\n   * @param ctx query context\r\n   * @throws QueryException query exception\r\n   */\r\n  public final void checkWrite(final QueryContext ctx) throws QueryException {\r\n    checkPerm(ctx, Perm.WRITE);\r\n  }","id":87181,"modified_method":"/**\r\n   * Checks if the current user has write permissions for the specified database.\r\n   * If negative, an exception is thrown.\r\n   * @param data data reference\r\n   * @param ctx query context\r\n   * @return data reference\r\n   * @throws QueryException query exception\r\n   */\r\n  public final Data checkWrite(final Data data, final QueryContext ctx)\r\n      throws QueryException {\r\n\r\n    if(!ctx.context.perm(Perm.WRITE, data.meta)) BASX_PERM.thrw(info, Perm.WRITE);\r\n    return data;\r\n  }","commit_id":"e2740cb894adfedd090e98304dac821016a8fd2e","url":"https://github.com/BaseXdb/basex"},{"original_method":"private static int getFirstNonSpaceCharOffset(@NotNull Document document, int lineNumber) {\n    int lineStart = document.getLineStartOffset(lineNumber);\n    int lineEnd = document.getLineEndOffset(lineNumber);\n    CharSequence text = document.getImmutableCharSequence();\n    for (int i = lineStart; i < lineEnd; i++) {\n      char c = text.charAt(i);\n      if (c != ' ' && c != '\\t') {\n        return i;\n      }\n    }\n    return lineStart;\n  }","id":87182,"modified_method":"public static int getFirstNonSpaceCharOffset(@NotNull Document document, int line) {\n    int startOffset = document.getLineStartOffset(line);\n    int endOffset = document.getLineEndOffset(line);\n    return getFirstNonSpaceCharOffset(document, startOffset, endOffset);\n  }","commit_id":"d173a3eff64f0b377042eaad2c13df1712718a08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public RangeHighlighter addPersistentLineHighlighter(int lineNumber, int layer, TextAttributes textAttributes) {\n    if (isNotValidLine(lineNumber)) {\n      return null;\n    }\n\n    int offset = getFirstNonSpaceCharOffset(getDocument(), lineNumber);\n    return addRangeHighlighterAndChangeAttributes(offset, offset, layer, textAttributes, HighlighterTargetArea.LINES_IN_RANGE, true, null);\n  }","id":87183,"modified_method":"@Override\n  @Nullable\n  public RangeHighlighter addPersistentLineHighlighter(int lineNumber, int layer, TextAttributes textAttributes) {\n    if (isNotValidLine(lineNumber)) {\n      return null;\n    }\n\n    int offset = getFirstNonSpaceCharOffset(getDocument(), lineNumber);\n    return addRangeHighlighter(PersistentRangeHighlighterImpl.create(this, offset, layer, HighlighterTargetArea.LINES_IN_RANGE, null, false), null);\n  }","commit_id":"d173a3eff64f0b377042eaad2c13df1712718a08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public RangeHighlighterEx addRangeHighlighterAndChangeAttributes(int startOffset,\n                                                                   int endOffset,\n                                                                   int layer,\n                                                                   TextAttributes textAttributes,\n                                                                   @NotNull HighlighterTargetArea targetArea,\n                                                                   boolean isPersistent,\n                                                                   @Nullable Consumer<RangeHighlighterEx> changeAttributesAction) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    RangeHighlighterEx highlighter = isPersistent\n                                     ? new PersistentRangeHighlighterImpl(this, startOffset, layer, targetArea, textAttributes)\n                                     : new RangeHighlighterImpl(this, startOffset, endOffset, layer, targetArea, textAttributes, false,\n                                                                false);\n\n    myCachedHighlighters = null;\n    if (changeAttributesAction != null) {\n      ((RangeHighlighterImpl)highlighter).changeAttributesNoEvents(changeAttributesAction);\n    }\n    fireAfterAdded(highlighter);\n    return highlighter;\n  }","id":87184,"modified_method":"@Override\n  public RangeHighlighterEx addRangeHighlighterAndChangeAttributes(int startOffset,\n                                                                   int endOffset,\n                                                                   int layer,\n                                                                   TextAttributes textAttributes,\n                                                                   @NotNull HighlighterTargetArea targetArea,\n                                                                   boolean isPersistent,\n                                                                   @Nullable Consumer<RangeHighlighterEx> changeAttributesAction) {\n    return addRangeHighlighter(isPersistent\n                               ? PersistentRangeHighlighterImpl.create(this, startOffset, layer, targetArea, textAttributes, true)\n                               : new RangeHighlighterImpl(this, startOffset, endOffset, layer, targetArea, textAttributes, false,\n                                                          false), changeAttributesAction);\n  }","commit_id":"d173a3eff64f0b377042eaad2c13df1712718a08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void changedUpdateImpl(DocumentEvent e) {\n    // todo Denis Zhdanov\n    DocumentEventImpl event = (DocumentEventImpl)e;\n    final boolean shouldTranslateViaDiff = PersistentRangeMarkerUtil.shouldTranslateViaDiff(event, this);\n    boolean wasTranslatedViaDiff = shouldTranslateViaDiff;\n    if (shouldTranslateViaDiff) {\n      wasTranslatedViaDiff = translatedViaDiff(e, event);\n    }\n    if (!wasTranslatedViaDiff) {\n      super.changedUpdateImpl(e);\n      if (isValid()) {\n        setLine(getDocument().getLineNumber(getStartOffset()));\n        int endLine = getDocument().getLineNumber(getEndOffset());\n        if (endLine != getLine()) {\n          setIntervalEnd(getDocument().getLineEndOffset(getLine()));\n        }\n      }\n    }\n    if (isValid() && getTargetArea() == HighlighterTargetArea.LINES_IN_RANGE) {\n      setIntervalStart(getDocument().getLineStartOffset(getLine()));\n      setIntervalEnd(getDocument().getLineEndOffset(getLine()));\n    }\n  }","id":87185,"modified_method":"@Override\n  protected void changedUpdateImpl(DocumentEvent e) {\n    // todo Denis Zhdanov\n    DocumentEventImpl event = (DocumentEventImpl)e;\n    final boolean shouldTranslateViaDiff = PersistentRangeMarkerUtil.shouldTranslateViaDiff(event, this);\n    boolean wasTranslatedViaDiff = shouldTranslateViaDiff;\n    if (shouldTranslateViaDiff) {\n      wasTranslatedViaDiff = translatedViaDiff(e, event);\n    }\n    if (!wasTranslatedViaDiff) {\n      super.changedUpdateImpl(e);\n      if (isValid()) {\n        setLine(getDocument().getLineNumber(getStartOffset()));\n        int endLine = getDocument().getLineNumber(getEndOffset());\n        if (endLine != getLine()) {\n          setIntervalEnd(getDocument().getLineEndOffset(getLine()));\n        }\n      }\n    }\n    if (isValid() && getTargetArea() == HighlighterTargetArea.LINES_IN_RANGE) {\n      setIntervalStart(MarkupModelImpl.getFirstNonSpaceCharOffset(getDocument(), getLine()));\n      setIntervalEnd(getDocument().getLineEndOffset(getLine()));\n    }\n  }","commit_id":"d173a3eff64f0b377042eaad2c13df1712718a08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"PersistentRangeHighlighterImpl(@NotNull MarkupModel model,\n                                 int offset,\n                                 int layer,\n                                 @NotNull HighlighterTargetArea target,\n                                 TextAttributes textAttributes) {\n    super(model, model.getDocument().getLineStartOffset(model.getDocument().getLineNumber(offset)), model.getDocument().getLineEndOffset(model.getDocument().getLineNumber(offset)),layer, target, textAttributes,\n          false, false);\n    setLine(model.getDocument().getLineNumber(offset));\n  }","id":87186,"modified_method":"private PersistentRangeHighlighterImpl(@NotNull MarkupModel model,\n                                         int startOffset,\n                                         int line,\n                                         int layer,\n                                         @NotNull HighlighterTargetArea target,\n                                         @Nullable TextAttributes textAttributes) {\n    super(model, startOffset, model.getDocument().getLineEndOffset(line), layer, target, textAttributes, false, false);\n\n    setLine(line);\n  }","commit_id":"d173a3eff64f0b377042eaad2c13df1712718a08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateUI() {\n    if (myDisposed) return;\n    if (ApplicationManager.getApplication().isUnitTestMode()) return;\n\n    Document document = getDocument();\n    if (document == null) return;\n\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    TextAttributes attributes = scheme.getAttributes(DebuggerColors.BREAKPOINT_ATTRIBUTES);\n\n    removeHighlighter();\n    MarkupModelEx markupModel = (MarkupModelEx)DocumentMarkupModel.forDocument(document, getProject(), true);\n    RangeHighlighter highlighter = markupModel.addPersistentLineHighlighter(getLine(), DebuggerColors.BREAKPOINT_HIGHLIGHTER_LAYER,\n                                                                            attributes);\n    if (highlighter != null) {\n      updateIcon();\n      highlighter.setGutterIconRenderer(createGutterIconRenderer());\n      highlighter.putUserData(DebuggerColors.BREAKPOINT_HIGHLIGHTER_KEY, Boolean.TRUE);\n    }\n    myHighlighter = highlighter;\n  }","id":87187,"modified_method":"public void updateUI() {\n    if (myDisposed || ApplicationManager.getApplication().isUnitTestMode()) {\n      return;\n    }\n\n    Document document = getDocument();\n    if (document == null) {\n      return;\n    }\n\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    TextAttributes attributes = scheme.getAttributes(DebuggerColors.BREAKPOINT_ATTRIBUTES);\n\n    RangeHighlighter highlighter = myHighlighter;\n    if (highlighter != null && highlighter.isValid() && document.getLineNumber(highlighter.getStartOffset()) != getLine()) {\n      highlighter.dispose();\n      myHighlighter = null;\n      highlighter = null;\n    }\n\n    if (highlighter == null) {\n      MarkupModelEx markupModel = (MarkupModelEx)DocumentMarkupModel.forDocument(document, getProject(), true);\n      highlighter = markupModel.addPersistentLineHighlighter(getLine(), DebuggerColors.BREAKPOINT_HIGHLIGHTER_LAYER, attributes);\n      if (highlighter != null) {\n        highlighter.setGutterIconRenderer(createGutterIconRenderer());\n        highlighter.putUserData(DebuggerColors.BREAKPOINT_HIGHLIGHTER_KEY, Boolean.TRUE);\n        myHighlighter = highlighter;\n      }\n    }\n\n    if (highlighter != null) {\n      updateIcon();\n    }\n  }","commit_id":"d173a3eff64f0b377042eaad2c13df1712718a08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Sets the {@link OtrContactMenu#otrPolicy} and, if necessary, rebuilds the\n     * menuitems to match the passed in otrPolicy.\n     * \n     * @param otrPolicy\n     */\n    private void setOtrPolicy(OtrPolicy otrPolicy)\n    {\n        if (!otrPolicy.equals(this.otrPolicy))\n        {\n            this.otrPolicy = otrPolicy;\n\n            if (isPopupMenuVisible() || inMacOSXScreenMenuBar)\n                rebuildMenu();\n        }\n    }","id":87188,"modified_method":"/**\n     * Sets the {@link OtrContactMenu#otrPolicy} and, if necessary, rebuilds the\n     * menuitems to match the passed in otrPolicy.\n     * \n     * @param otrPolicy\n     */\n    private void setOtrPolicy(OtrPolicy otrPolicy)\n    {\n        if (!otrPolicy.equals(this.otrPolicy))\n        {\n            this.otrPolicy = otrPolicy;\n\n            if (separateMenu != null\n                && (separateMenu.isPopupMenuVisible() || inMacOSXScreenMenuBar))\n                buildMenu();\n        }\n    }","commit_id":"afa430d8374c805a21fe2f0a96549ce832381caf","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the {@link OtrContactMenu#sessionStatus} value, updates the menu\n     * icon and, if necessary, rebuilds the menuitems to match the passed in\n     * sessionStatus.\n     * \n     * @param sessionStatus the {@link SessionStatus}.\n     */\n    private void setSessionStatus(SessionStatus sessionStatus)\n    {\n        if (sessionStatus != this.sessionStatus)\n        {\n            this.sessionStatus = sessionStatus;\n\n            updateIcon();\n            if (isPopupMenuVisible() || inMacOSXScreenMenuBar)\n                rebuildMenu();\n        }\n    }","id":87189,"modified_method":"/**\n     * Sets the {@link OtrContactMenu#sessionStatus} value, updates the menu\n     * icon and, if necessary, rebuilds the menuitems to match the passed in\n     * sessionStatus.\n     * \n     * @param sessionStatus the {@link SessionStatus}.\n     */\n    private void setSessionStatus(SessionStatus sessionStatus)\n    {\n        if (sessionStatus != this.sessionStatus)\n        {\n            this.sessionStatus = sessionStatus;\n\n            if (separateMenu != null)\n            {\n                updateIcon();\n\n                if (separateMenu.isPopupMenuVisible() || inMacOSXScreenMenuBar)\n                    buildMenu();\n            }\n        }\n    }","commit_id":"afa430d8374c805a21fe2f0a96549ce832381caf","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * The OtrContactMenu constructor.\n     * \n     * @param contact the Contact this menu refers to.\n     * @param inMacOSXScreenMenuBar <tt>true<\/tt> if the new menu is to be\n     * displayed in the Mac OS X screen menu bar; <tt>false<\/tt>, otherwise\n     */\n    public OtrContactMenu(Contact contact, boolean inMacOSXScreenMenuBar)\n    {\n        this.contact = contact;\n        this.inMacOSXScreenMenuBar = inMacOSXScreenMenuBar;\n\n        this.setText(contact.getAddress());\n\n        /*\n         * Setup populating this JMenu on demand because it's not always\n         * necessary.\n         */\n        if (!this.inMacOSXScreenMenuBar)\n            getPopupMenu().addPopupMenuListener(this);\n\n        OtrActivator.scOtrEngine.addListener(this);\n        OtrActivator.scOtrKeyManager.addListener(this);\n\n        setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(contact));\n        setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(contact));\n    }","id":87190,"modified_method":"/**\n     * The OtrContactMenu constructor.\n     * \n     * @param contact the Contact this menu refers to.\n     * @param inMacOSXScreenMenuBar <tt>true<\/tt> if the new menu is to be\n     * displayed in the Mac OS X screen menu bar; <tt>false<\/tt>, otherwise\n     * @param menu the parent menu\n     */\n    public OtrContactMenu(  Contact contact,\n                            boolean inMacOSXScreenMenuBar,\n                            JMenu menu,\n                            boolean isSeparateMenu)\n    {\n        this.contact = contact;\n        this.inMacOSXScreenMenuBar = inMacOSXScreenMenuBar;\n        this.parentMenu = menu;\n        this.isSeparateMenu = isSeparateMenu;\n\n        if (isSeparateMenu)\n        {\n            separateMenu = new JMenu(contact.getDisplayName());\n        }\n\n        OtrActivator.scOtrEngine.addListener(this);\n        OtrActivator.scOtrKeyManager.addListener(this);\n\n        setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(contact));\n        setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(contact));\n\n        buildMenu();\n    }","commit_id":"afa430d8374c805a21fe2f0a96549ce832381caf","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the menu icon based on {@link OtrContactMenu#sessionStatus}\n     * value.\n     */\n    private void updateIcon()\n    {\n        String imageID;\n\n        switch (sessionStatus)\n        {\n        case ENCRYPTED:\n            imageID\n                = OtrActivator.scOtrKeyManager.isVerified(contact)\n                    ? \"plugin.otr.ENCRYPTED_ICON_16x16\"\n                    : \"plugin.otr.ENCRYPTED_UNVERIFIED_ICON_16x16\";\n            break;\n\n        case FINISHED:\n            imageID = \"plugin.otr.FINISHED_ICON_16x16\";\n            break;\n\n        case PLAINTEXT:\n            imageID = \"plugin.otr.PLAINTEXT_ICON_16x16\";\n            break;\n\n        default:\n            return;\n        }\n\n        setIcon(OtrActivator.resourceService.getImage(imageID));\n    }","id":87191,"modified_method":"/**\n     * Updates the menu icon based on {@link OtrContactMenu#sessionStatus}\n     * value.\n     */\n    private void updateIcon()\n    {\n        if (!isSeparateMenu)\n            return;\n\n        String imageID;\n\n        switch (sessionStatus)\n        {\n        case ENCRYPTED:\n            imageID\n                = OtrActivator.scOtrKeyManager.isVerified(contact)\n                    ? \"plugin.otr.ENCRYPTED_ICON_16x16\"\n                    : \"plugin.otr.ENCRYPTED_UNVERIFIED_ICON_16x16\";\n            break;\n\n        case FINISHED:\n            imageID = \"plugin.otr.FINISHED_ICON_16x16\";\n            break;\n\n        case PLAINTEXT:\n            imageID = \"plugin.otr.PLAINTEXT_ICON_16x16\";\n            break;\n\n        default:\n            return;\n        }\n\n        separateMenu.setIcon(OtrActivator.resourceService.getImage(imageID));\n    }","commit_id":"afa430d8374c805a21fe2f0a96549ce832381caf","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Rebuilds own menuitems according to {@link OtrContactMenu#sessionStatus}\n     * and the {@link OtrPolicy} for {@link OtrContactMenu#contact}.\n     */\n    private void rebuildMenu()\n    {\n        this.removeAll();\n\n        OtrPolicy policy = OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n        JMenuItem endOtr = new JMenuItem();\n        endOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.END_OTR\"));\n        endOtr.setActionCommand(ACTION_COMMAND_END_OTR);\n        endOtr.addActionListener(this);\n\n        JMenuItem startOtr = new JMenuItem();\n        startOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.START_OTR\"));\n        startOtr.setEnabled(policy.getEnableManual());\n        startOtr.setActionCommand(ACTION_COMMAND_START_OTR);\n        startOtr.addActionListener(this);\n\n        switch (this.sessionStatus)\n        {\n        case ENCRYPTED:\n            JMenuItem refreshOtr = new JMenuItem();\n            refreshOtr.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.REFRESH_OTR\"));\n            refreshOtr.setEnabled(policy.getEnableManual());\n            refreshOtr.setActionCommand(ACTION_COMMAND_REFRESH_OTR);\n            refreshOtr.addActionListener(this);\n\n            JMenuItem authBuddy = new JMenuItem();\n            authBuddy.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.AUTHENTICATE_BUDDY\"));\n            authBuddy.setActionCommand(ACTION_COMMAND_AUTHENTICATE_BUDDY);\n            authBuddy.addActionListener(this);\n\n            this.add(endOtr);\n            this.add(refreshOtr);\n            this.add(authBuddy);\n            break;\n\n        case FINISHED:\n            this.add(endOtr);\n            this.add(startOtr);\n            break;\n\n        case PLAINTEXT:\n            this.add(startOtr);\n            break;\n        }\n\n        JCheckBoxMenuItem cbEnable = new JCheckBoxMenuItem();\n        cbEnable.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_ENABLE\"));\n        cbEnable.setState(policy.getEnableManual());\n        cbEnable.setActionCommand(ACTION_COMMAND_CB_ENABLE);\n        cbEnable.addActionListener(this);\n\n        JCheckBoxMenuItem cbAlways = new JCheckBoxMenuItem();\n        cbAlways.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_AUTO\"));\n        cbAlways.setEnabled(policy.getEnableManual());\n        cbAlways.setState(policy.getEnableAlways());\n        cbAlways.setActionCommand(ACTION_COMMAND_CB_AUTO);\n        cbAlways.addActionListener(this);\n\n        JCheckBoxMenuItem cbRequire = new JCheckBoxMenuItem();\n        cbRequire.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_REQUIRE\"));\n        cbRequire.setEnabled(policy.getEnableManual());\n        cbRequire.setState(policy.getRequireEncryption());\n        cbRequire.setActionCommand(ACTION_COMMAND_CB_REQUIRE);\n        cbRequire.addActionListener(this);\n\n        JMenuItem cbReset = new JMenuItem();\n        cbReset.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_RESET\"));\n        cbReset.setActionCommand(ACTION_COMMAND_CB_RESET);\n        cbReset.addActionListener(this);\n\n        this.addSeparator();\n        this.add(cbEnable);\n        this.add(cbAlways);\n        this.add(cbRequire);\n        this.addSeparator();\n        this.add(cbReset);\n    }","id":87192,"modified_method":"/**\n     * Rebuilds own menuitems according to {@link OtrContactMenu#sessionStatus}\n     * and the {@link OtrPolicy} for {@link OtrContactMenu#contact}.\n     */\n    private void buildMenu()\n    {\n        OtrPolicy policy = OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n        JMenuItem endOtr = new JMenuItem();\n        endOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.END_OTR\"));\n        endOtr.setActionCommand(ACTION_COMMAND_END_OTR);\n        endOtr.addActionListener(this);\n\n        JMenuItem startOtr = new JMenuItem();\n        startOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.START_OTR\"));\n        startOtr.setEnabled(policy.getEnableManual());\n        startOtr.setActionCommand(ACTION_COMMAND_START_OTR);\n        startOtr.addActionListener(this);\n\n        switch (this.sessionStatus)\n        {\n        case ENCRYPTED:\n            JMenuItem refreshOtr = new JMenuItem();\n            refreshOtr.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.REFRESH_OTR\"));\n            refreshOtr.setEnabled(policy.getEnableManual());\n            refreshOtr.setActionCommand(ACTION_COMMAND_REFRESH_OTR);\n            refreshOtr.addActionListener(this);\n\n            JMenuItem authBuddy = new JMenuItem();\n            authBuddy.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.AUTHENTICATE_BUDDY\"));\n            authBuddy.setActionCommand(ACTION_COMMAND_AUTHENTICATE_BUDDY);\n            authBuddy.addActionListener(this);\n\n            if (isSeparateMenu)\n            {\n                separateMenu.add(endOtr);\n                separateMenu.add(refreshOtr);\n                separateMenu.add(authBuddy);\n            }\n            else\n            {\n                parentMenu.add(endOtr);\n                parentMenu.add(refreshOtr);\n                parentMenu.add(authBuddy);\n            }\n\n            break;\n\n        case FINISHED:\n            if (isSeparateMenu)\n            {\n                separateMenu.add(endOtr);\n                separateMenu.add(startOtr);\n            }\n            else\n            {\n                parentMenu.add(endOtr);\n                parentMenu.add(startOtr);\n            }\n            break;\n\n        case PLAINTEXT:\n            if (isSeparateMenu)\n                separateMenu.add(startOtr);\n            else\n                parentMenu.add(startOtr);\n\n            break;\n        }\n\n        JCheckBoxMenuItem cbEnable = new JCheckBoxMenuItem();\n        cbEnable.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_ENABLE\"));\n        cbEnable.setState(policy.getEnableManual());\n        cbEnable.setActionCommand(ACTION_COMMAND_CB_ENABLE);\n        cbEnable.addActionListener(this);\n\n        JCheckBoxMenuItem cbAlways = new JCheckBoxMenuItem();\n        cbAlways.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_AUTO\"));\n        cbAlways.setEnabled(policy.getEnableManual());\n        cbAlways.setState(policy.getEnableAlways());\n        cbAlways.setActionCommand(ACTION_COMMAND_CB_AUTO);\n        cbAlways.addActionListener(this);\n\n        JCheckBoxMenuItem cbRequire = new JCheckBoxMenuItem();\n        cbRequire.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_REQUIRE\"));\n        cbRequire.setEnabled(policy.getEnableManual());\n        cbRequire.setState(policy.getRequireEncryption());\n        cbRequire.setActionCommand(ACTION_COMMAND_CB_REQUIRE);\n        cbRequire.addActionListener(this);\n\n        JMenuItem cbReset = new JMenuItem();\n        cbReset.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_RESET\"));\n        cbReset.setActionCommand(ACTION_COMMAND_CB_RESET);\n        cbReset.addActionListener(this);\n\n        if (isSeparateMenu)\n        {\n            separateMenu.addSeparator();\n            separateMenu.add(cbEnable);\n            separateMenu.add(cbAlways);\n            separateMenu.add(cbRequire);\n            separateMenu.addSeparator();\n            separateMenu.add(cbReset);\n\n            parentMenu.add(separateMenu);\n        }\n        else\n        {\n            parentMenu.addSeparator();\n            parentMenu.add(cbEnable);\n            parentMenu.add(cbAlways);\n            parentMenu.add(cbRequire);\n            parentMenu.addSeparator();\n            parentMenu.add(cbReset);\n        }\n    }","commit_id":"afa430d8374c805a21fe2f0a96549ce832381caf","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void popupMenuWillBecomeVisible(PopupMenuEvent e)\n    {\n        createOtrContactMenus(currentContact);\n\n        if (whatsThis == null)\n        {\n            JMenu menu = getMenu();\n\n            menu.addSeparator();\n\n            whatsThis = new JMenuItem();\n            whatsThis.setIcon(OtrActivator.resourceService\n                .getImage(\"plugin.otr.HELP_ICON_15x15\"));\n            whatsThis.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.WHATS_THIS\"));\n            whatsThis.addActionListener(this);\n            menu.add(whatsThis);\n        }\n    }","id":87193,"modified_method":"public void popupMenuWillBecomeVisible(PopupMenuEvent e)\n    {\n        createOtrContactMenus(currentContact);\n\n        JMenu menu = getMenu();\n\n        menu.addSeparator();\n\n        whatsThis = new JMenuItem();\n        whatsThis.setIcon(OtrActivator.resourceService\n            .getImage(\"plugin.otr.HELP_ICON_15x15\"));\n        whatsThis.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.WHATS_THIS\"));\n        whatsThis.addActionListener(this);\n        menu.add(whatsThis);\n    }","commit_id":"afa430d8374c805a21fe2f0a96549ce832381caf","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an {@link OtrContactMenu} for each {@link Contact} contained in\n     * the <tt>metaContact<\/tt>.\n     * \n     * @param metaContact The {@link MetaContact} this\n     *            {@link OtrMetaContactMenu} refers to.\n     */\n    private void createOtrContactMenus(MetaContact metaContact)\n    {\n        JMenu menu = getMenu();\n\n        // Remove any existing OtrContactMenu items.\n        for (int itemIndex = 0, itemCount = menu.getItemCount();\n                itemIndex < itemCount;)\n        {\n            JMenuItem menuItem = menu.getItem(itemIndex);\n\n            if (menuItem instanceof OtrContactMenu)\n            {\n                menu.remove(itemIndex);\n                itemCount--;\n\n                ((OtrContactMenu) menuItem).dispose();\n            }\n            else\n                itemIndex++;\n        }\n\n        // Create the new OtrContactMenu items.\n        if (metaContact != null)\n        {\n            Iterator<Contact> contacts = metaContact.getContacts();\n            int itemIndex = 0;\n            while (contacts.hasNext())\n            {\n                menu.insert(new OtrContactMenu(contacts.next(),\n                    inMacOSXScreenMenuBar), itemIndex);\n                itemIndex++;\n            }\n        }\n    }","id":87194,"modified_method":"/**\n     * Creates an {@link OtrContactMenu} for each {@link Contact} contained in\n     * the <tt>metaContact<\/tt>.\n     * \n     * @param metaContact The {@link MetaContact} this\n     *            {@link OtrMetaContactMenu} refers to.\n     */\n    private void createOtrContactMenus(MetaContact metaContact)\n    {\n        JMenu menu = getMenu();\n\n        // Remove any existing OtrContactMenu items.\n        menu.removeAll();\n\n        // Create the new OtrContactMenu items.\n        if (metaContact != null)\n        {\n            Iterator<Contact> contacts = metaContact.getContacts();\n\n            if (metaContact.getContactCount() == 1)\n            {\n                new OtrContactMenu(\n                    contacts.next(), inMacOSXScreenMenuBar, menu, false);\n            }\n            else\n                while (contacts.hasNext())\n                {\n                    new OtrContactMenu(\n                        contacts.next(), inMacOSXScreenMenuBar, menu, true);\n                }\n        }\n    }","commit_id":"afa430d8374c805a21fe2f0a96549ce832381caf","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void updateUI() {\n    Document document = getDocument();\n    if (document == null) return;\n\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    TextAttributes attributes = scheme.getAttributes(DebuggerColors.BREAKPOINT_ATTRIBUTES);\n\n    removeHighlighter();\n    MarkupModelEx markupModel = (MarkupModelEx)document.getMarkupModel(getProject());\n    RangeHighlighter highlighter = markupModel.addPersistentLineHighlighter(getLine(), DebuggerColors.BREAKPOINT_HIGHLIGHTER_LAYER,\n                                                                            attributes);\n    updateIcon();\n    setupGutterRenderer(highlighter);\n    myHighlighter = highlighter;\n  }","id":87195,"modified_method":"public void updateUI() {\n    Document document = getDocument();\n    if (document == null) return;\n\n    EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n    TextAttributes attributes = scheme.getAttributes(DebuggerColors.BREAKPOINT_ATTRIBUTES);\n\n    removeHighlighter();\n    MarkupModelEx markupModel = (MarkupModelEx)document.getMarkupModel(getProject());\n    RangeHighlighter highlighter = markupModel.addPersistentLineHighlighter(getLine(), DebuggerColors.BREAKPOINT_HIGHLIGHTER_LAYER,\n                                                                            attributes);\n    if (highlighter != null) {\n      updateIcon();\n      setupGutterRenderer(highlighter);\n    }\n    myHighlighter = highlighter;\n  }","commit_id":"435b39ae5121939d3aa6533470f809c84b81f82c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static final void main(String[] args) {\r\n        try {\r\n        \t\r\n        \t//load up the rulebase\r\n            RuleBase ruleBase = readRule();\r\n            WorkingMemory workingMemory = ruleBase.newStatefulSession();\r\n            WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger(workingMemory);\r\n\r\n            // set globals\r\n            RecommendationService recommendationService = new RecommendationService();\r\n            workingMemory.setGlobal(\"recommendationService\", recommendationService);\r\n            \r\n            // create patient\r\n            Patient patient = new Patient();\r\n            patient.setName(\"John Doe\");\r\n            patient.setAge(20);\r\n            workingMemory.insert(patient);\r\n            \r\n            // Go!\r\n            Diagnose diagnose = new Diagnose(Terminology.DIAGNOSE_X);\r\n            workingMemory.insert(diagnose);\r\n            workingMemory.fireAllRules();\r\n            \r\n            // Print out recommendations\r\n            List recommendations = recommendationService.getRecommendations();\r\n            for (Iterator iterator = recommendations.iterator(); iterator.hasNext(); ) {\r\n            \tSystem.out.println(iterator.next());\r\n            }\r\n            recommendations.clear();\r\n            \r\n            // Simulate a diagnose: incomplete results\r\n            diagnose = new Diagnose(Terminology.DIAGNOSE_X_TYPE_UNKNOWN);\r\n            workingMemory.insert(diagnose);\r\n            workingMemory.fireAllRules();\r\n            \r\n            // Print out recommendations\r\n            recommendations = recommendationService.getRecommendations();\r\n            for (Iterator iterator = recommendations.iterator(); iterator.hasNext(); ) {\r\n            \tSystem.out.println(iterator.next());\r\n            }\r\n            recommendations.clear();\r\n            \r\n            // Simulate a diagnose: type2\r\n            diagnose = new Diagnose(Terminology.DIAGNOSE_X_TYPE2);\r\n            workingMemory.insert(diagnose);\r\n            workingMemory.fireAllRules();\r\n            \r\n            logger.writeToDisk();\r\n\r\n        } catch (Throwable t) {\r\n            t.printStackTrace();\r\n        }\r\n    }","id":87196,"modified_method":"public static final void main(String[] args) {\r\n        try {\r\n\r\n            //load up the rulebase\r\n            KnowledgeBase knowledgeBase = readRule();\r\n\r\n            StatefulKnowledgeSession workingMemory = knowledgeBase.newStatefulKnowledgeSession();\r\n            WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( workingMemory );\r\n\r\n            // set globals\r\n            RecommendationService recommendationService = new RecommendationService();\r\n            workingMemory.setGlobal( \"recommendationService\",\r\n                                     recommendationService );\r\n\r\n            // create patient\r\n            Patient patient = new Patient();\r\n            patient.setName( \"John Doe\" );\r\n            patient.setAge( 20 );\r\n            workingMemory.insert( patient );\r\n\r\n            // Go!\r\n            Diagnose diagnose = new Diagnose( Terminology.DIAGNOSE_X );\r\n            workingMemory.insert( diagnose );\r\n            workingMemory.fireAllRules();\r\n\r\n            // Print out recommendations\r\n            List recommendations = recommendationService.getRecommendations();\r\n            for ( Iterator iterator = recommendations.iterator(); iterator.hasNext(); ) {\r\n                System.out.println( iterator.next() );\r\n            }\r\n            recommendations.clear();\r\n\r\n            // Simulate a diagnose: incomplete results\r\n            diagnose = new Diagnose( Terminology.DIAGNOSE_X_TYPE_UNKNOWN );\r\n            workingMemory.insert( diagnose );\r\n            workingMemory.fireAllRules();\r\n\r\n            // Print out recommendations\r\n            recommendations = recommendationService.getRecommendations();\r\n            for ( Iterator iterator = recommendations.iterator(); iterator.hasNext(); ) {\r\n                System.out.println( iterator.next() );\r\n            }\r\n            recommendations.clear();\r\n\r\n            // Simulate a diagnose: type2\r\n            diagnose = new Diagnose( Terminology.DIAGNOSE_X_TYPE2 );\r\n            workingMemory.insert( diagnose );\r\n            workingMemory.fireAllRules();\r\n\r\n            logger.writeToDisk();\r\n\r\n        } catch ( Throwable t ) {\r\n            t.printStackTrace();\r\n        }\r\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private static RuleBase readRule() throws Exception {\r\n\t\tPackageBuilder builder = new PackageBuilder();\r\n\t\tReader reader = new InputStreamReader(\r\n\t\t\tCDSSExample.class.getResourceAsStream(\"/org/drools/examples/cdss/GenericRules.drl\"));\r\n\t\tbuilder.addPackageFromDrl(reader);\r\n\t\treader = new InputStreamReader(\r\n\t\t\tCDSSExample.class.getResourceAsStream(\"/org/drools/examples/cdss/ClinicalPathwayX.drl\"));\r\n\t\tbuilder.addPackageFromDrl(reader);\r\n\t\treader = new InputStreamReader(\r\n\t\t\tCDSSExample.class.getResourceAsStream(\"/org/drools/examples/cdss/ClinicalPathwayX.rf\"));\r\n\t\tbuilder.addRuleFlow(reader);\r\n\t\treader = new InputStreamReader(\r\n\t\t\tCDSSExample.class.getResourceAsStream(\"/org/drools/examples/cdss/TreatmentX.rf\"));\r\n\t\tbuilder.addRuleFlow(reader);\r\n\t\treader = new InputStreamReader(\r\n\t\t\tCDSSExample.class.getResourceAsStream(\"/org/drools/examples/cdss/TreatmentY.rf\"));\r\n\t\tbuilder.addRuleFlow(reader);\r\n\r\n\t\tPackage pkg = builder.getPackage();\r\n\t\tRuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n\t\truleBase.addPackage( pkg );\r\n\t\treturn ruleBase;\r\n\t}","id":87197,"modified_method":"private static KnowledgeBase readRule() throws Exception {\r\n        KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        Reader reader = new InputStreamReader( CDSSExample.class.getResourceAsStream( \"/org/drools/examples/cdss/GenericRules.drl\" ) );\r\n        builder.addResource( reader,\r\n                             KnowledgeType.DRL );\r\n        reader = new InputStreamReader( CDSSExample.class.getResourceAsStream( \"/org/drools/examples/cdss/ClinicalPathwayX.drl\" ) );\r\n        builder.addResource( reader,\r\n                             KnowledgeType.DRL );\r\n        reader = new InputStreamReader( CDSSExample.class.getResourceAsStream( \"/org/drools/examples/cdss/ClinicalPathwayX.rf\" ) );\r\n        builder.addResource( reader,\r\n                             KnowledgeType.DRF );\r\n        reader = new InputStreamReader( CDSSExample.class.getResourceAsStream( \"/org/drools/examples/cdss/TreatmentX.rf\" ) );\r\n        builder.addResource( reader,\r\n                             KnowledgeType.DRF );\r\n        reader = new InputStreamReader( CDSSExample.class.getResourceAsStream( \"/org/drools/examples/cdss/TreatmentY.rf\" ) );\r\n        builder.addResource( reader,\r\n                             KnowledgeType.DRF );\r\n\r\n        KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        return knowledgeBase;\r\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static void main(final String[] args) throws Exception {\r\n\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        builder.addResource( new InputStreamReader( FibonacciExample.class.getResourceAsStream( \"Fibonacci.drl\" ) ),\r\n                             KnowledgeType.DRL );\r\n\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n\r\n        //        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n        //        logger.setFileName( \"log/fibonacci\" );\r\n\r\n        session.insert( new Fibonacci( 10 ) );\r\n\r\n        session.fireAllRules();\r\n\r\n        //        logger.writeToDisk();\r\n\r\n        session.dispose(); // Stateful rule session must always be disposed when finished\r\n\r\n    }","id":87198,"modified_method":"public static void main(final String[] args) throws Exception {\r\n\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        builder.addResource( new InputStreamReader( FibonacciExample.class.getResourceAsStream( \"Fibonacci.drl\" ) ),\r\n                             KnowledgeType.DRL );\r\n\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n\r\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n        logger.setFileName( \"log/fibonacci\" );\r\n\r\n        session.insert( new Fibonacci( 10 ) );\r\n\r\n        session.fireAllRules();\r\n\r\n        logger.writeToDisk();\r\n\r\n        session.dispose(); // Stateful rule session must always be disposed when finished\r\n\r\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static final void main(final String[] args) throws Exception {\r\n        //read in the source\r\n        final Reader source = new InputStreamReader( HelloWorldExample.class.getResourceAsStream( \"HelloWorld.drl\" ) );\r\n\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n\r\n        //this will parse and compile in one step\r\n        builder.addResource( source,\r\n                             KnowledgeType.DRL );\r\n\r\n        // Check the builder for errors\r\n        if ( builder.hasErrors() ) {\r\n            System.out.println( builder.getErrors().toString() );\r\n            throw new RuntimeException( \"Unable to compile \\\"HelloWorld.drl\\\".\" );\r\n        }\r\n\r\n        //get the compiled package (which is serializable)\r\n        final Collection<KnowledgePackage> pkgs = builder.getKnowledgePackages();\r\n\r\n        //add the package to a rulebase (deploy the rule package).\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( pkgs );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n        session.setGlobal( \"list\",\r\n                           new ArrayList() );\r\n\r\n//        session.addEventListener( new DebugAgendaEventListener() );\r\n//        session.addEventListener( new DebugWorkingMemoryEventListener() );\r\n        \r\n//        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n//        logger.setFileName( \"log/helloworld\" );        \r\n\r\n        final Message message = new Message();\r\n        message.setMessage( \"Hello World\" );\r\n        message.setStatus( Message.HELLO );\r\n        session.insert( message );\r\n        \r\n        session.fireAllRules();\r\n        \r\n//        logger.writeToDisk();\r\n        \r\n        session.dispose();\r\n    }","id":87199,"modified_method":"public static final void main(final String[] args) throws Exception {\r\n        //read in the source\r\n        final Reader source = new InputStreamReader( HelloWorldExample.class.getResourceAsStream( \"HelloWorld.drl\" ) );\r\n\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n\r\n        //this will parse and compile in one step\r\n        builder.addResource( source,\r\n                             KnowledgeType.DRL );\r\n\r\n        // Check the builder for errors\r\n        if ( builder.hasErrors() ) {\r\n            System.out.println( builder.getErrors().toString() );\r\n            throw new RuntimeException( \"Unable to compile \\\"HelloWorld.drl\\\".\" );\r\n        }\r\n\r\n        //get the compiled package (which is serializable)\r\n        final Collection<KnowledgePackage> pkgs = builder.getKnowledgePackages();\r\n\r\n        //add the package to a rulebase (deploy the rule package).\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( pkgs );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n        session.setGlobal( \"list\",\r\n                           new ArrayList() );\r\n\r\n        //        session.addEventListener( new DebugAgendaEventListener() );\r\n        //        session.addEventListener( new DebugWorkingMemoryEventListener() );\r\n\r\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n        logger.setFileName( \"log/helloworld\" );\r\n\r\n        final Message message = new Message();\r\n        message.setMessage( \"Hello World\" );\r\n        message.setStatus( Message.HELLO );\r\n        session.insert( message );\r\n\r\n        session.fireAllRules();\r\n\r\n        logger.writeToDisk();\r\n\r\n        session.dispose();\r\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * @param args\r\n     */\r\n    public static void main(final String[] args) throws Exception {\r\n\r\n        PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n        conf.setDumpDir( new File(\"target\") );\r\n        final PackageBuilder builder = new PackageBuilder(conf);\r\n        builder.addPackageFromDrl( new InputStreamReader( HonestPoliticianExample.class.getResourceAsStream( \"HonestPolitician.drl\" ) ) );\r\n\r\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n        ruleBase.addPackage( builder.getPackage() );\r\n\r\n        final StatefulSession session = ruleBase.newStatefulSession();\r\n\r\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n        logger.setFileName( \"log/honest-politician\" );\r\n\r\n        final Politician blair  = new Politician(\"blair\", true);\r\n        final Politician bush  = new Politician(\"bush\", true);\r\n        final Politician chirac  = new Politician(\"chirac\", true);\r\n        final Politician schroder   = new Politician(\"schroder\", true);\r\n        \r\n        session.insert( blair );\r\n        session.insert( bush );\r\n        session.insert( chirac );\r\n        session.insert( schroder );\r\n\r\n        session.fireAllRules();\r\n        \r\n        logger.writeToDisk();\r\n        \r\n        session.dispose();\r\n    }","id":87200,"modified_method":"/**\r\n     * @param args\r\n     */\r\n    public static void main(final String[] args) throws Exception {\r\n\r\n        KnowledgeBuilderConfiguration conf = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration();\r\n        conf.setProperty( \"drools.dump.dir\",\r\n                          \"target\" );\r\n\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        builder.addResource( new InputStreamReader( HonestPoliticianExample.class.getResourceAsStream( \"HonestPolitician.drl\" ) ),\r\n                             KnowledgeType.DRL );\r\n\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n\r\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n        logger.setFileName( \"log/honest-politician\" );\r\n\r\n        final Politician blair = new Politician( \"blair\",\r\n                                                 true );\r\n        final Politician bush = new Politician( \"bush\",\r\n                                                true );\r\n        final Politician chirac = new Politician( \"chirac\",\r\n                                                  true );\r\n        final Politician schroder = new Politician( \"schroder\",\r\n                                                    true );\r\n\r\n        session.insert( blair );\r\n        session.insert( bush );\r\n        session.insert( chirac );\r\n        session.insert( schroder );\r\n\r\n        session.fireAllRules();\r\n\r\n        logger.writeToDisk();\r\n\r\n        session.dispose();\r\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static final void main(String[] args) throws Exception {\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        builder.addResource( new InputStreamReader( ShoppingExample.class.getResourceAsStream( \"NumberGuess.drl\" ) ),\r\n                             KnowledgeType.DRL );\r\n        builder.addResource( new InputStreamReader( ShoppingExample.class.getResourceAsStream( \"NumberGuess.rf\" ) ),\r\n                             KnowledgeType.DRF );\r\n\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n\r\n//        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n//        logger.setFileName( \"log/numberguess\" );\r\n\r\n        session.insert( new GameRules( 100,\r\n                                       5 ) );\r\n        session.insert( new RandomNumber() );\r\n        session.insert( new Game() );\r\n\r\n        session.startProcess( \"Number Guess\" );\r\n        session.fireAllRules();\r\n\r\n//        logger.writeToDisk();\r\n\r\n        session.dispose();\r\n    }","id":87201,"modified_method":"public static final void main(String[] args) throws Exception {\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        builder.addResource( new InputStreamReader( ShoppingExample.class.getResourceAsStream( \"NumberGuess.drl\" ) ),\r\n                             KnowledgeType.DRL );\r\n        builder.addResource( new InputStreamReader( ShoppingExample.class.getResourceAsStream( \"NumberGuess.rf\" ) ),\r\n                             KnowledgeType.DRF );\r\n\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n\r\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\r\n        logger.setFileName( \"log/numberguess\" );\r\n\r\n        session.insert( new GameRules( 100,\r\n                                       5 ) );\r\n        session.insert( new RandomNumber() );\r\n        session.insert( new Game() );\r\n\r\n        session.startProcess( \"Number Guess\" );\r\n        session.fireAllRules();\r\n\r\n        logger.writeToDisk();\r\n\r\n        session.dispose();\r\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public int executeExample() throws Exception {\n    \t\n    \t//first we compile the decision table into a whole lot of rules.\n    \tSpreadsheetCompiler compiler = new SpreadsheetCompiler();\n    \tString drl = compiler.compile(getSpreadsheetStream(), InputType.XLS);\n\n    \t//UNCOMMENT ME TO SEE THE DRL THAT IS GENERATED\n    \t//System.out.println(drl);\n\n    \tRuleBase ruleBase = buildRuleBase(drl);\n    \t\n        // typical decision tables are used statelessly\n\t\tStatelessSession session = ruleBase.newStatelessSession();\n\t\t\n\t\t//now create some test data\n\t\tDriver driver = new Driver();\n\t\tPolicy policy = new Policy();\n\t\t\n        session.execute( new Object[] { driver, policy } );\n\t\t\n\t\tSystem.out.println(\"BASE PRICE IS: \" + policy.getBasePrice());\n\t\tSystem.out.println(\"DISCOUNT IS: \" + policy.getDiscountPercent());\n\t\t\n        return policy.getBasePrice();\n    \t\n    }","id":87202,"modified_method":"public int executeExample() throws Exception {\n\n        DecisionTableConfiguration conf = KnowledgeBuilderFactory.newDecisionTableConfiguration();\n        conf.setInputType( DecisionTableInputType.XLS );\n\n        KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        builder.addResource( new InputStreamReader( getSpreadsheetStream(),\n                                                    \"windows-1252\" ),\n                             KnowledgeType.DTABLE,\n                             conf );\n\n        KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\n\n        // typical decision tables are used statelessly\n        StatelessKnowledgeSession session = knowledgeBase.newStatelessKnowledgeSession();\n\n        //now create some test data\n        Driver driver = new Driver();\n        Policy policy = new Policy();\n\n        session.executeObject( new Object[]{driver, policy} );\n\n        System.out.println( \"BASE PRICE IS: \" + policy.getBasePrice() );\n        System.out.println( \"DISCOUNT IS: \" + policy.getDiscountPercent() );\n\n        return policy.getBasePrice();\n\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * @param args\r\n     */\r\n    public static void main(final String[] args) throws Exception {\r\n\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        builder.addResource( new InputStreamReader( TroubleTicketExample.class.getResourceAsStream( \"TroubleTicket.drl\" ) ),\r\n                             KnowledgeType.DRL );\r\n\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n\r\n        //        ThreadedWorkingMemoryFileLogger logger = new ThreadedWorkingMemoryFileLogger(session);\r\n        //        logger.setFileName( \"log/trouble_ticket\" );\r\n        //        logger.start(1000);\r\n\r\n        final Customer a = new Customer( \"A\",\r\n                                         \"Drools\",\r\n                                         \"Gold\" );\r\n        final Customer b = new Customer( \"B\",\r\n                                         \"Drools\",\r\n                                         \"Platinum\" );\r\n        final Customer c = new Customer( \"C\",\r\n                                         \"Drools\",\r\n                                         \"Silver\" );\r\n        final Customer d = new Customer( \"D\",\r\n                                         \"Drools\",\r\n                                         \"Silver\" );\r\n\r\n        final Ticket t1 = new Ticket( a );\r\n        final Ticket t2 = new Ticket( b );\r\n        final Ticket t3 = new Ticket( c );\r\n        final Ticket t4 = new Ticket( d );\r\n\r\n        session.insert( a );\r\n        session.insert( b );\r\n        session.insert( c );\r\n        session.insert( d );\r\n\r\n        session.insert( t1 );\r\n        session.insert( t2 );\r\n        final FactHandle ft3 = session.insert( t3 );\r\n        session.insert( t4 );\r\n\r\n        session.fireAllRules();\r\n\r\n        t3.setStatus( \"Done\" );\r\n\r\n        session.update( ft3,\r\n                        t3 );\r\n\r\n        try {\r\n            System.err.println( \"[[ Sleeping 5 seconds ]]\" );\r\n            Thread.sleep( 5000 );\r\n        } catch ( final InterruptedException e ) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.err.println( \"[[ awake ]]\" );\r\n\r\n        session.dispose();\r\n\r\n        //        logger.stop();\r\n        //        logger.writeToDisk();\r\n    }","id":87203,"modified_method":"/**\r\n     * @param args\r\n     */\r\n    public static void main(final String[] args) throws Exception {\r\n\r\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        builder.addResource( new InputStreamReader( TroubleTicketExample.class.getResourceAsStream( \"TroubleTicket.drl\" ) ),\r\n                             KnowledgeType.DRL );\r\n\r\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\r\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\r\n\r\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\r\n\r\n        ThreadedWorkingMemoryFileLogger logger = new ThreadedWorkingMemoryFileLogger( session );\r\n        logger.setFileName( \"log/trouble_ticket\" );\r\n        logger.start( 1000 );\r\n\r\n        final Customer a = new Customer( \"A\",\r\n                                         \"Drools\",\r\n                                         \"Gold\" );\r\n        final Customer b = new Customer( \"B\",\r\n                                         \"Drools\",\r\n                                         \"Platinum\" );\r\n        final Customer c = new Customer( \"C\",\r\n                                         \"Drools\",\r\n                                         \"Silver\" );\r\n        final Customer d = new Customer( \"D\",\r\n                                         \"Drools\",\r\n                                         \"Silver\" );\r\n\r\n        final Ticket t1 = new Ticket( a );\r\n        final Ticket t2 = new Ticket( b );\r\n        final Ticket t3 = new Ticket( c );\r\n        final Ticket t4 = new Ticket( d );\r\n\r\n        session.insert( a );\r\n        session.insert( b );\r\n        session.insert( c );\r\n        session.insert( d );\r\n\r\n        session.insert( t1 );\r\n        session.insert( t2 );\r\n        final FactHandle ft3 = session.insert( t3 );\r\n        session.insert( t4 );\r\n\r\n        session.fireAllRules();\r\n\r\n        t3.setStatus( \"Done\" );\r\n\r\n        session.update( ft3,\r\n                        t3 );\r\n\r\n        try {\r\n            System.err.println( \"[[ Sleeping 5 seconds ]]\" );\r\n            Thread.sleep( 5000 );\r\n        } catch ( final InterruptedException e ) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.err.println( \"[[ awake ]]\" );\r\n\r\n        session.dispose();\r\n\r\n        logger.stop();\r\n        logger.writeToDisk();\r\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @param args\n     */\n    public static void main(final String[] args) throws Exception {\n\n        final PackageBuilder builder = new PackageBuilder();\n        builder.addPackageFromDrl( getSource(),\n                                   getDSL() );\n\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\n        ruleBase.addPackage( builder.getPackage() );\n\n        final StatefulSession session = ruleBase.newStatefulSession();\n\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\n        logger.setFileName( \"log/state\" );\n\n        final Customer a = new Customer( \"A\",\n                                         \"Drools\",\n                                         \"Gold\" );\n        final Customer b = new Customer( \"B\",\n                                         \"Drools\",\n                                         \"Platinum\" );\n        final Customer c = new Customer( \"C\",\n                                         \"Drools\",\n                                         \"Silver\" );\n        final Customer d = new Customer( \"D\",\n                                         \"Drools\",\n                                         \"Silver\" );\n\n        final Ticket t1 = new Ticket( a );\n        final Ticket t2 = new Ticket( b );\n        final Ticket t3 = new Ticket( c );\n        final Ticket t4 = new Ticket( d );\n\n        final FactHandle fa = session.insert( a );\n        final FactHandle fb = session.insert( b );\n        final FactHandle fc = session.insert( c );\n        final FactHandle fd = session.insert( d );\n\n        final FactHandle ft1 = session.insert( t1 );\n        final FactHandle ft2 = session.insert( t2 );\n        final FactHandle ft3 = session.insert( t3 );\n        final FactHandle ft4 = session.insert( t4 );\n\n        session.fireAllRules();\n\n        t3.setStatus( \"Done\" );\n\n        session.update( ft3,\n                        t3 );\n\n        try {\n            System.err.println( \"[[ Sleeping 5 seconds ]]\" );\n            Thread.sleep( 5000 );\n        } catch ( final InterruptedException e ) {\n            e.printStackTrace();\n        }\n        \n        System.err.println( \"[[ awake ]]\" );\n\n        session.fireAllRules();\n\n        session.dispose();\n\n        logger.writeToDisk();\n    }","id":87204,"modified_method":"/**\n     * @param args\n     */\n    public static void main(final String[] args) throws Exception {\n\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n\n        builder.addResource( getDSL(),\n                             KnowledgeType.DSL );\n        builder.addResource( getSource(),\n                             KnowledgeType.DSLR );\n\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\n\n        final StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\n\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\n        logger.setFileName( \"log/state\" );\n\n        final Customer a = new Customer( \"A\",\n                                         \"Drools\",\n                                         \"Gold\" );\n        final Customer b = new Customer( \"B\",\n                                         \"Drools\",\n                                         \"Platinum\" );\n        final Customer c = new Customer( \"C\",\n                                         \"Drools\",\n                                         \"Silver\" );\n        final Customer d = new Customer( \"D\",\n                                         \"Drools\",\n                                         \"Silver\" );\n\n        final Ticket t1 = new Ticket( a );\n        final Ticket t2 = new Ticket( b );\n        final Ticket t3 = new Ticket( c );\n        final Ticket t4 = new Ticket( d );\n\n        final FactHandle fa = session.insert( a );\n        final FactHandle fb = session.insert( b );\n        final FactHandle fc = session.insert( c );\n        final FactHandle fd = session.insert( d );\n\n        final FactHandle ft1 = session.insert( t1 );\n        final FactHandle ft2 = session.insert( t2 );\n        final FactHandle ft3 = session.insert( t3 );\n        final FactHandle ft4 = session.insert( t4 );\n\n        session.fireAllRules();\n\n        t3.setStatus( \"Done\" );\n\n        session.update( ft3,\n                        t3 );\n\n        try {\n            System.err.println( \"[[ Sleeping 5 seconds ]]\" );\n            Thread.sleep( 5000 );\n        } catch ( final InterruptedException e ) {\n            e.printStackTrace();\n        }\n\n        System.err.println( \"[[ awake ]]\" );\n\n        session.fireAllRules();\n\n        session.dispose();\n\n        logger.writeToDisk();\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void executeExample() throws Exception {\n    \t\n    \t//first we compile the decision table into a whole lot of rules.\n    \tSpreadsheetCompiler compiler = new SpreadsheetCompiler();\n    \tString drl = compiler.compile(getSpreadsheetStream(), InputType.XLS);\n\n    \t//UNCOMMENT ME TO SEE THE DRL THAT IS GENERATED\n    \t//System.out.println(drl);\n\n    \tRuleBase ruleBase = buildRuleBase(drl);\n    \t\n        // typical decision tables are used statelessly\n\t\tStatefulSession session = ruleBase.newStatefulSession();\n\t\t\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\n        logger.setFileName( \"log/trouble_ticket\" );\n\n        final Customer a = new Customer( \"A\",\n                                         \"Drools\",\n                                         \"Gold\" );\n        final Customer b = new Customer( \"B\",\n                                         \"Drools\",\n                                         \"Platinum\" );\n        final Customer c = new Customer( \"C\",\n                                         \"Drools\",\n                                         \"Silver\" );\n        final Customer d = new Customer( \"D\",\n                                         \"Drools\",\n                                         \"Silver\" );\n\n        final Ticket t1 = new Ticket( a );\n        final Ticket t2 = new Ticket( b );\n        final Ticket t3 = new Ticket( c );\n        final Ticket t4 = new Ticket( d );\n\n        session.insert( a );\n        session.insert( b );\n        session.insert( c );\n        session.insert( d );\n\n        session.insert( t1 );\n        session.insert( t2 );\n        final FactHandle ft3 = session.insert( t3 );\n        session.insert( t4 );\n\n        session.fireAllRules();\n\n        t3.setStatus( \"Done\" );\n\n        session.update( ft3,\n                        t3 );\n\n        try {\n            System.err.println( \"[[ Sleeping 5 seconds ]]\" );\n            Thread.sleep( 5000 );\n        } catch ( final InterruptedException e ) {\n            e.printStackTrace();\n        }\n\n        System.err.println( \"[[ awake ]]\" );\n\n        session.dispose();\n\n        logger.writeToDisk();\n    \t\n    }","id":87205,"modified_method":"public void executeExample() throws Exception {\n\n        final DecisionTableConfiguration conf = KnowledgeBuilderFactory.newDecisionTableConfiguration();\n        conf.setInputType( DecisionTableInputType.XLS );\n\n        final KnowledgeBuilder builder = KnowledgeBuilderFactory.newKnowledgeBuilder();\n        builder.addResource( new InputStreamReader( getSpreadsheetStream(),\n                                                    \"windows-1252\" ),\n                             KnowledgeType.DTABLE,\n                             conf );\n\n        final KnowledgeBase knowledgeBase = KnowledgeBaseFactory.newKnowledgeBase();\n        knowledgeBase.addKnowledgePackages( builder.getKnowledgePackages() );\n\n        // typical decision tables are used statelessly\n        StatefulKnowledgeSession session = knowledgeBase.newStatefulKnowledgeSession();\n\n        final WorkingMemoryFileLogger logger = new WorkingMemoryFileLogger( session );\n        logger.setFileName( \"log/trouble_ticket\" );\n\n        final Customer a = new Customer( \"A\",\n                                         \"Drools\",\n                                         \"Gold\" );\n        final Customer b = new Customer( \"B\",\n                                         \"Drools\",\n                                         \"Platinum\" );\n        final Customer c = new Customer( \"C\",\n                                         \"Drools\",\n                                         \"Silver\" );\n        final Customer d = new Customer( \"D\",\n                                         \"Drools\",\n                                         \"Silver\" );\n\n        final Ticket t1 = new Ticket( a );\n        final Ticket t2 = new Ticket( b );\n        final Ticket t3 = new Ticket( c );\n        final Ticket t4 = new Ticket( d );\n\n        session.insert( a );\n        session.insert( b );\n        session.insert( c );\n        session.insert( d );\n\n        session.insert( t1 );\n        session.insert( t2 );\n        final FactHandle ft3 = session.insert( t3 );\n        session.insert( t4 );\n\n        session.fireAllRules();\n\n        t3.setStatus( \"Done\" );\n\n        session.update( ft3,\n                        t3 );\n\n        try {\n            System.err.println( \"[[ Sleeping 5 seconds ]]\" );\n            Thread.sleep( 5000 );\n        } catch ( final InterruptedException e ) {\n            e.printStackTrace();\n        }\n\n        System.err.println( \"[[ awake ]]\" );\n\n        session.dispose();\n\n        logger.writeToDisk();\n\n    }","commit_id":"f30d10e71059860b5fdae7c0eec7418ca4c29ac9","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private byte[] doIssuedTokenSignature(Token token, \n                                          SignedEncryptedParts signdParts,\n                                          TokenWrapper wrapper,\n                                          SecurityToken securityTok) throws Exception {\n        Document doc = saaj.getSOAPPart();\n        \n        //Get the issued token\n        SecurityToken secTok = securityTok;\n        if (secTok == null) {\n            secTok = getSecurityToken();\n        }\n   \n        SPConstants.IncludeTokenType inclusion = token.getInclusion();\n        boolean tokenIncluded = false;\n        \n        List<WSEncryptionPart> sigParts = new ArrayList<WSEncryptionPart>();\n        if (inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS\n            || ((inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS_TO_RECIPIENT \n                || inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ONCE) \n                && isRequestor())) {\n          \n            //Add the token\n            Element el = cloneElement(secTok.getToken());\n            if (securityTok != null) {\n                //do we need to sign this as well?\n                //String id = addWsuIdToElement(el);\n                //sigParts.add(new WSEncryptionPart(id));                          \n            }\n            \n            addEncryptedKeyElement(el);\n            tokenIncluded = true;\n        }\n        \n        if (timestampEl != null) {\n            WSEncryptionPart timestampPart = convertToEncryptionPart(timestampEl.getElement());\n            sigParts.add(timestampPart);                          \n        }\n        \n        if (signdParts != null) {\n            if (signdParts.isBody()) {\n                WSEncryptionPart bodyPart = convertToEncryptionPart(saaj.getSOAPBody());\n                sigParts.add(bodyPart);\n            }\n            if (secTok.getX509Certificate() != null\n                || securityTok != null) {\n                //the \"getX509Certificate\" this is to workaround an issue in WCF\n                //In WCF, for TransportBinding, in most cases, it doesn't want any of\n                //the headers signed even if the policy says so.   HOWEVER, for KeyValue\n                //IssuedTokens, it DOES want them signed\n                for (Header header : signdParts.getHeaders()) {\n                    WSEncryptionPart wep = new WSEncryptionPart(header.getName(), \n                            header.getNamespace(),\n                            \"Content\");\n                    sigParts.add(wep);\n                }\n            }\n        }\n        \n        //check for derived keys\n        AlgorithmSuite algorithmSuite = tbinding.getAlgorithmSuite();\n        if (token.isDerivedKeys()) {\n            //Do Signature with derived keys\n            WSSecDKSign dkSign = new WSSecDKSign(wssConfig);\n          \n            //Setting the AttachedReference or the UnattachedReference according to the flag\n            Element ref;\n            if (tokenIncluded) {\n                ref = secTok.getAttachedReference();\n            } else {\n                ref = secTok.getUnattachedReference();\n            }\n          \n            if (ref != null) {\n                dkSign.setExternalKey(secTok.getSecret(), cloneElement(ref));\n            } else {\n                dkSign.setExternalKey(secTok.getSecret(), secTok.getId());\n            }\n          \n            // Set the algo info\n            dkSign.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            dkSign.setDerivedKeyLength(algorithmSuite.getSignatureDerivedKeyLength() / 8);\n            if (token.getSPConstants() == SP12Constants.INSTANCE) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_12);\n            }\n            dkSign.prepare(doc, secHeader);\n          \n            addDerivedKeyElement(dkSign.getdktElement());\n          \n            dkSign.setParts(sigParts);\n            List<Reference> referenceList = dkSign.addReferencesToSign(sigParts, secHeader);\n          \n            //Do signature\n            dkSign.computeSignature(referenceList, false, null);\n          \n            return dkSign.getSignatureValue();\n        } else {\n            WSSecSignature sig = new WSSecSignature(wssConfig);\n            if (secTok.getTokenType() == null) {\n                sig.setCustomTokenId(secTok.getId());\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                String id = secTok.getWsuId();\n                if (id == null) {\n                    sig.setCustomTokenId(secTok.getId());\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n                } else {\n                    sig.setCustomTokenId(secTok.getWsuId());\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n                }\n                String tokenType = secTok.getTokenType();\n                if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                } else {\n                    sig.setCustomTokenValueType(tokenType);\n                }\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n            }\n            Crypto crypto = null;\n            if (secTok.getSecret() == null) {\n                sig.setX509Certificate(secTok.getX509Certificate());\n                \n                crypto = secTok.getCrypto();\n                String uname = crypto.getX509Identifier(secTok.getX509Certificate());\n                String password = getPassword(uname, token, WSPasswordCallback.SIGNATURE);\n                if (password == null) {\n                    password = \"\";\n                }\n                sig.setUserInfo(uname, password);\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n            } else {\n                crypto = getSignatureCrypto(wrapper);\n                sig.setSecretKey(secTok.getSecret());\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getSymmetricSignature());\n            }\n            sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n\n            sig.prepare(doc, crypto, secHeader);\n\n            sig.setParts(sigParts);\n            List<Reference> referenceList = sig.addReferencesToSign(sigParts, secHeader);\n\n            //Do signature\n            if (bottomUpElement == null) {\n                sig.computeSignature(referenceList, false, null);\n            } else {\n                sig.computeSignature(referenceList, true, bottomUpElement);\n            }\n            bottomUpElement = sig.getSignatureElement();\n            mainSigId = sig.getId();\n        \n            return sig.getSignatureValue();\n        }\n    }","id":87206,"modified_method":"private byte[] doIssuedTokenSignature(Token token, \n                                          SignedEncryptedParts signdParts,\n                                          TokenWrapper wrapper,\n                                          SecurityToken securityTok) throws Exception {\n        Document doc = saaj.getSOAPPart();\n        \n        //Get the issued token\n        SecurityToken secTok = securityTok;\n        if (secTok == null) {\n            secTok = getSecurityToken();\n        }\n   \n        SPConstants.IncludeTokenType inclusion = token.getInclusion();\n        boolean tokenIncluded = false;\n        \n        List<WSEncryptionPart> sigParts = new ArrayList<WSEncryptionPart>();\n        if (inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS\n            || ((inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS_TO_RECIPIENT \n                || inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ONCE) \n                && isRequestor())) {\n          \n            //Add the token\n            Element el = cloneElement(secTok.getToken());\n            if (securityTok != null) {\n                //do we need to sign this as well?\n                //String id = addWsuIdToElement(el);\n                //sigParts.add(new WSEncryptionPart(id));                          \n            }\n            \n            addEncryptedKeyElement(el);\n            tokenIncluded = true;\n        }\n        \n        if (timestampEl != null) {\n            WSEncryptionPart timestampPart = convertToEncryptionPart(timestampEl.getElement());\n            sigParts.add(timestampPart);                          \n        }\n        \n        if (signdParts != null) {\n            if (signdParts.isBody()) {\n                WSEncryptionPart bodyPart = convertToEncryptionPart(saaj.getSOAPBody());\n                sigParts.add(bodyPart);\n            }\n            if (secTok.getX509Certificate() != null\n                || securityTok != null) {\n                //the \"getX509Certificate\" this is to workaround an issue in WCF\n                //In WCF, for TransportBinding, in most cases, it doesn't want any of\n                //the headers signed even if the policy says so.   HOWEVER, for KeyValue\n                //IssuedTokens, it DOES want them signed\n                for (Header header : signdParts.getHeaders()) {\n                    WSEncryptionPart wep = new WSEncryptionPart(header.getName(), \n                            header.getNamespace(),\n                            \"Content\");\n                    sigParts.add(wep);\n                }\n            }\n        }\n        \n        //check for derived keys\n        AlgorithmSuite algorithmSuite = tbinding.getAlgorithmSuite();\n        if (token.isDerivedKeys()) {\n            //Do Signature with derived keys\n            WSSecDKSign dkSign = new WSSecDKSign(wssConfig);\n          \n            //Setting the AttachedReference or the UnattachedReference according to the flag\n            Element ref;\n            if (tokenIncluded) {\n                ref = secTok.getAttachedReference();\n            } else {\n                ref = secTok.getUnattachedReference();\n            }\n          \n            if (ref != null) {\n                dkSign.setExternalKey(secTok.getSecret(), cloneElement(ref));\n            } else {\n                dkSign.setExternalKey(secTok.getSecret(), secTok.getId());\n            }\n          \n            // Set the algo info\n            dkSign.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            dkSign.setDerivedKeyLength(algorithmSuite.getSignatureDerivedKeyLength() / 8);\n            if (token.getSPConstants() == SP12Constants.INSTANCE) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_12);\n            }\n            dkSign.prepare(doc, secHeader);\n          \n            addDerivedKeyElement(dkSign.getdktElement());\n          \n            dkSign.setParts(sigParts);\n            List<Reference> referenceList = dkSign.addReferencesToSign(sigParts, secHeader);\n          \n            //Do signature\n            dkSign.computeSignature(referenceList, false, null);\n          \n            return dkSign.getSignatureValue();\n        } else {\n            WSSecSignature sig = new WSSecSignature(wssConfig);\n            if (secTok.getTokenType() == null) {\n                sig.setCustomTokenId(secTok.getId());\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                String id = secTok.getWsuId();\n                if (id == null) {\n                    sig.setCustomTokenId(secTok.getId());\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n                } else {\n                    sig.setCustomTokenId(secTok.getWsuId());\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n                }\n                String tokenType = secTok.getTokenType();\n                if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else {\n                    sig.setCustomTokenValueType(tokenType);\n                }\n            }\n            Crypto crypto = null;\n            if (secTok.getSecret() == null) {\n                sig.setX509Certificate(secTok.getX509Certificate());\n                \n                crypto = secTok.getCrypto();\n                String uname = crypto.getX509Identifier(secTok.getX509Certificate());\n                String password = getPassword(uname, token, WSPasswordCallback.SIGNATURE);\n                if (password == null) {\n                    password = \"\";\n                }\n                sig.setUserInfo(uname, password);\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n            } else {\n                crypto = getSignatureCrypto(wrapper);\n                sig.setSecretKey(secTok.getSecret());\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getSymmetricSignature());\n            }\n            sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n\n            sig.prepare(doc, crypto, secHeader);\n\n            sig.setParts(sigParts);\n            List<Reference> referenceList = sig.addReferencesToSign(sigParts, secHeader);\n\n            //Do signature\n            if (bottomUpElement == null) {\n                sig.computeSignature(referenceList, false, null);\n            } else {\n                sig.computeSignature(referenceList, true, bottomUpElement);\n            }\n            bottomUpElement = sig.getSignatureElement();\n            mainSigId = sig.getId();\n        \n            return sig.getSignatureValue();\n        }\n    }","commit_id":"12cd35a24844b9fbca4f0c81552c7fcdd6d786bb","url":"https://github.com/apache/cxf"},{"original_method":"protected WSSecSignature getSignatureBuilder(\n        TokenWrapper wrapper, Token token, boolean attached, boolean endorse\n    ) throws WSSecurityException {\n        WSSecSignature sig = new WSSecSignature(wssConfig);\n        checkForX509PkiPath(sig, token);\n        if (token instanceof IssuedToken) {\n            policyAsserted(token);\n            policyAsserted(wrapper);\n            SecurityToken securityToken = getSecurityToken();\n            String tokenType = securityToken.getTokenType();\n            \n            int type = attached ? WSConstants.CUSTOM_SYMM_SIGNING \n                : WSConstants.CUSTOM_SYMM_SIGNING_DIRECT;\n            if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML_NS.equals(tokenType)) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML2_NS.equals(tokenType)) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                sig.setCustomTokenValueType(tokenType);\n                sig.setKeyIdentifierType(type);\n            }\n            \n            String sigTokId;\n            if (attached) {\n                sigTokId = securityToken.getWsuId();\n                if (sigTokId == null) {\n                    sigTokId = securityToken.getId();                    \n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            } else {\n                sigTokId = securityToken.getId();\n            }\n            \n            sig.setCustomTokenId(sigTokId);\n        } else {\n            setKeyIdentifierType(sig, wrapper, token);\n        }\n        \n        boolean encryptCrypto = false;\n        String userNameKey = SecurityConstants.SIGNATURE_USERNAME;\n        String type = \"signature\";\n        if (binding instanceof SymmetricBinding && !endorse) {\n            encryptCrypto = ((SymmetricBinding)binding).getProtectionToken() != null;\n            userNameKey = SecurityConstants.ENCRYPT_USERNAME;\n        }\n\n        Crypto crypto = encryptCrypto ? getEncryptionCrypto(wrapper) \n            : getSignatureCrypto(wrapper);\n        \n        if (endorse && crypto == null && binding instanceof SymmetricBinding) {\n            userNameKey = SecurityConstants.ENCRYPT_USERNAME;\n            crypto = getEncryptionCrypto(wrapper);\n        }\n        \n        if (!endorse) {\n            message.getExchange().put(SecurityConstants.SIGNATURE_CRYPTO, crypto);\n        }\n        String user = (String)message.getContextualProperty(userNameKey);\n        if (crypto != null && StringUtils.isEmpty(user)) {\n            try {\n                user = crypto.getDefaultX509Identifier();\n            } catch (WSSecurityException e1) {\n                throw new Fault(e1);\n            }\n        }\n        if (StringUtils.isEmpty(user)) {\n            policyNotAsserted(token, \"No \" + type + \" username found.\");\n            return null;\n        }\n\n        String password = getPassword(user, token, WSPasswordCallback.SIGNATURE);\n        if (password == null) {\n            password = \"\";\n        }\n        sig.setUserInfo(user, password);\n        sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n        sig.setDigestAlgo(binding.getAlgorithmSuite().getDigest());\n        sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n        sig.setWsConfig(wssConfig);\n        try {\n            sig.prepare(saaj.getSOAPPart(), crypto, secHeader);\n        } catch (WSSecurityException e) {\n            policyNotAsserted(token, e);\n        }\n        \n        return sig;\n    }","id":87207,"modified_method":"protected WSSecSignature getSignatureBuilder(\n        TokenWrapper wrapper, Token token, boolean attached, boolean endorse\n    ) throws WSSecurityException {\n        WSSecSignature sig = new WSSecSignature(wssConfig);\n        checkForX509PkiPath(sig, token);\n        if (token instanceof IssuedToken) {\n            policyAsserted(token);\n            policyAsserted(wrapper);\n            SecurityToken securityToken = getSecurityToken();\n            String tokenType = securityToken.getTokenType();\n            \n            Element ref;\n            if (attached) {\n                ref = securityToken.getAttachedReference();\n            } else {\n                ref = securityToken.getUnattachedReference();\n            }\n            \n            if (ref != null) {\n                SecurityTokenReference secRef = \n                    new SecurityTokenReference(cloneElement(ref), false);\n                sig.setSecurityTokenReference(secRef);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                int type = attached ? WSConstants.CUSTOM_SYMM_SIGNING \n                    : WSConstants.CUSTOM_SYMM_SIGNING_DIRECT;\n                if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                    || WSConstants.SAML_NS.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                    || WSConstants.SAML2_NS.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else {\n                    sig.setCustomTokenValueType(tokenType);\n                    sig.setKeyIdentifierType(type);\n                }\n            }\n            \n            String sigTokId;\n            if (attached) {\n                sigTokId = securityToken.getWsuId();\n                if (sigTokId == null) {\n                    sigTokId = securityToken.getId();                    \n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            } else {\n                sigTokId = securityToken.getId();\n            }\n            \n            sig.setCustomTokenId(sigTokId);\n        } else {\n            setKeyIdentifierType(sig, wrapper, token);\n        }\n        \n        boolean encryptCrypto = false;\n        String userNameKey = SecurityConstants.SIGNATURE_USERNAME;\n        String type = \"signature\";\n        if (binding instanceof SymmetricBinding && !endorse) {\n            encryptCrypto = ((SymmetricBinding)binding).getProtectionToken() != null;\n            userNameKey = SecurityConstants.ENCRYPT_USERNAME;\n        }\n\n        Crypto crypto = encryptCrypto ? getEncryptionCrypto(wrapper) \n            : getSignatureCrypto(wrapper);\n        \n        if (endorse && crypto == null && binding instanceof SymmetricBinding) {\n            userNameKey = SecurityConstants.ENCRYPT_USERNAME;\n            crypto = getEncryptionCrypto(wrapper);\n        }\n        \n        if (!endorse) {\n            message.getExchange().put(SecurityConstants.SIGNATURE_CRYPTO, crypto);\n        }\n        String user = (String)message.getContextualProperty(userNameKey);\n        if (crypto != null && StringUtils.isEmpty(user)) {\n            try {\n                user = crypto.getDefaultX509Identifier();\n            } catch (WSSecurityException e1) {\n                throw new Fault(e1);\n            }\n        }\n        if (StringUtils.isEmpty(user)) {\n            policyNotAsserted(token, \"No \" + type + \" username found.\");\n            return null;\n        }\n\n        String password = getPassword(user, token, WSPasswordCallback.SIGNATURE);\n        if (password == null) {\n            password = \"\";\n        }\n        sig.setUserInfo(user, password);\n        sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n        sig.setDigestAlgo(binding.getAlgorithmSuite().getDigest());\n        sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n        sig.setWsConfig(wssConfig);\n        try {\n            sig.prepare(saaj.getSOAPPart(), crypto, secHeader);\n        } catch (WSSecurityException e) {\n            policyNotAsserted(token, e);\n        }\n        \n        return sig;\n    }","commit_id":"02a1e56b6fee9db4990cbf6defd4da72deb0b5f2","url":"https://github.com/apache/cxf"},{"original_method":"private byte[] doSignature(List<WSEncryptionPart> sigs,\n                             TokenWrapper policyTokenWrapper, \n                             Token policyToken, \n                             SecurityToken tok,\n                             boolean included) throws WSSecurityException {\n        if (policyToken.isDerivedKeys()) {\n            return doSignatureDK(sigs, policyTokenWrapper, policyToken, tok, included);\n        } else {\n            WSSecSignature sig = new WSSecSignature(wssConfig);\n            sig.setWsConfig(wssConfig);\n            // If a EncryptedKeyToken is used, set the correct value type to\n            // be used in the wsse:Reference in ds:KeyInfo\n            int type = included ? WSConstants.CUSTOM_SYMM_SIGNING \n                : WSConstants.CUSTOM_SYMM_SIGNING_DIRECT;\n            if (policyToken instanceof X509Token) {\n                if (isRequestor()) {\n                    sig.setCustomTokenValueType(\n                        WSConstants.SOAPMESSAGE_NS11 + \"#\" + WSConstants.ENC_KEY_VALUE_TYPE\n                    );\n                    sig.setKeyIdentifierType(type);\n                } else {\n                    //the tok has to be an EncryptedKey token\n                    sig.setEncrKeySha1value(tok.getSHA1());\n                    sig.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);\n                }\n            } else {\n                String tokenType = tok.getTokenType();\n                if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                    || WSConstants.SAML_NS.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                    || WSConstants.SAML2_NS.equals(tokenType)) {\n                    sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else {\n                    sig.setCustomTokenValueType(tokenType);\n                    sig.setKeyIdentifierType(type);\n                }\n            }\n            \n            String sigTokId;\n            if (included) {\n                sigTokId = tok.getWsuId();\n                if (sigTokId == null) {\n                    if (policyToken instanceof SecureConversationToken) {\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n                    }\n                    sigTokId = tok.getId();                    \n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            } else {\n                sigTokId = tok.getId();\n            }\n                           \n            \n            sig.setCustomTokenId(sigTokId);\n            sig.setSecretKey(tok.getSecret());\n            sig.setSignatureAlgorithm(sbinding.getAlgorithmSuite().getSymmetricSignature());\n            Crypto crypto = null;\n            if (sbinding.getProtectionToken() != null) {\n                crypto = getEncryptionCrypto(sbinding.getProtectionToken());\n            } else {\n                crypto = getSignatureCrypto(policyTokenWrapper);\n            }\n            this.message.getExchange().put(SecurityConstants.SIGNATURE_CRYPTO, crypto);\n            sig.prepare(saaj.getSOAPPart(), crypto, secHeader);\n            sig.setParts(sigs);\n            List<Reference> referenceList = sig.addReferencesToSign(sigs, secHeader);\n\n            //Do signature\n            if (bottomUpElement == null) {\n                sig.computeSignature(referenceList, false, null);\n            } else {\n                sig.computeSignature(referenceList, true, bottomUpElement);\n            }\n            bottomUpElement = sig.getSignatureElement();\n\n            this.mainSigId = sig.getId();\n            return sig.getSignatureValue();\n        }\n    }","id":87208,"modified_method":"private byte[] doSignature(List<WSEncryptionPart> sigs,\n                             TokenWrapper policyTokenWrapper, \n                             Token policyToken, \n                             SecurityToken tok,\n                             boolean included) throws WSSecurityException {\n        if (policyToken.isDerivedKeys()) {\n            return doSignatureDK(sigs, policyTokenWrapper, policyToken, tok, included);\n        } else {\n            WSSecSignature sig = new WSSecSignature(wssConfig);\n            sig.setWsConfig(wssConfig);\n            // If a EncryptedKeyToken is used, set the correct value type to\n            // be used in the wsse:Reference in ds:KeyInfo\n            int type = included ? WSConstants.CUSTOM_SYMM_SIGNING \n                : WSConstants.CUSTOM_SYMM_SIGNING_DIRECT;\n            if (policyToken instanceof X509Token) {\n                if (isRequestor()) {\n                    sig.setCustomTokenValueType(\n                        WSConstants.SOAPMESSAGE_NS11 + \"#\" + WSConstants.ENC_KEY_VALUE_TYPE\n                    );\n                    sig.setKeyIdentifierType(type);\n                } else {\n                    //the tok has to be an EncryptedKey token\n                    sig.setEncrKeySha1value(tok.getSHA1());\n                    sig.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);\n                }\n            } else {\n                //Setting the AttachedReference or the UnattachedReference according to the flag\n                Element ref;\n                if (included) {\n                    ref = tok.getAttachedReference();\n                } else {\n                    ref = tok.getUnattachedReference();\n                }\n                \n                if (ref != null) {\n                    SecurityTokenReference secRef = \n                        new SecurityTokenReference(cloneElement(ref), false);\n                    sig.setSecurityTokenReference(secRef);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else {\n                    String tokenType = tok.getTokenType();\n                    if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                        || WSConstants.SAML_NS.equals(tokenType)) {\n                        sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                        || WSConstants.SAML2_NS.equals(tokenType)) {\n                        sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    } else {\n                        sig.setCustomTokenValueType(tokenType);\n                        sig.setKeyIdentifierType(type);\n                    }\n                }\n            }\n            \n            String sigTokId;\n            if (included) {\n                sigTokId = tok.getWsuId();\n                if (sigTokId == null) {\n                    if (policyToken instanceof SecureConversationToken) {\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n                    }\n                    sigTokId = tok.getId();                    \n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            } else {\n                sigTokId = tok.getId();\n            }\n                           \n            \n            sig.setCustomTokenId(sigTokId);\n            sig.setSecretKey(tok.getSecret());\n            sig.setSignatureAlgorithm(sbinding.getAlgorithmSuite().getSymmetricSignature());\n            Crypto crypto = null;\n            if (sbinding.getProtectionToken() != null) {\n                crypto = getEncryptionCrypto(sbinding.getProtectionToken());\n            } else {\n                crypto = getSignatureCrypto(policyTokenWrapper);\n            }\n            this.message.getExchange().put(SecurityConstants.SIGNATURE_CRYPTO, crypto);\n            sig.prepare(saaj.getSOAPPart(), crypto, secHeader);\n            sig.setParts(sigs);\n            List<Reference> referenceList = sig.addReferencesToSign(sigs, secHeader);\n\n            //Do signature\n            if (bottomUpElement == null) {\n                sig.computeSignature(referenceList, false, null);\n            } else {\n                sig.computeSignature(referenceList, true, bottomUpElement);\n            }\n            bottomUpElement = sig.getSignatureElement();\n\n            this.mainSigId = sig.getId();\n            return sig.getSignatureValue();\n        }\n    }","commit_id":"02a1e56b6fee9db4990cbf6defd4da72deb0b5f2","url":"https://github.com/apache/cxf"},{"original_method":"private WSSecBase doEncryption(TokenWrapper recToken,\n                                   SecurityToken encrTok,\n                                   boolean attached,\n                                   List<WSEncryptionPart> encrParts,\n                                   boolean atEnd) {\n        //Do encryption\n        if (recToken != null && recToken.getToken() != null && encrParts.size() > 0) {\n            Token encrToken = recToken.getToken();\n            policyAsserted(recToken);\n            policyAsserted(encrToken);\n            AlgorithmSuite algorithmSuite = sbinding.getAlgorithmSuite();\n            if (encrToken.isDerivedKeys()) {\n                return doEncryptionDerived(recToken, encrTok, encrToken,\n                                           attached, encrParts, atEnd);\n            } else {\n                try {\n                    WSSecEncrypt encr = new WSSecEncrypt(wssConfig);\n                    String encrTokId = encrTok.getId();\n                    if (attached) {\n                        encrTokId = encrTok.getWsuId();\n                        if (encrTokId == null && encrToken instanceof SecureConversationToken) {\n                            encr.setEncKeyIdDirectId(true);\n                            encrTokId = encrTok.getId();\n                        } else if (encrTokId == null) {\n                            encrTokId = encrTok.getId();\n                        }\n                        if (encrTokId.startsWith(\"#\")) {\n                            encrTokId = encrTokId.substring(1);\n                        }\n                    } else {\n                        encr.setEncKeyIdDirectId(true);\n                    }\n                    if (encrTok.getTokenType() != null) {\n                        encr.setCustomReferenceValue(encrTok.getTokenType());\n                    }\n                    encr.setEncKeyId(encrTokId);\n                    encr.setEphemeralKey(encrTok.getSecret());\n                    Crypto crypto = getEncryptionCrypto(recToken);\n                    if (crypto != null) {\n                        this.message.getExchange().put(SecurityConstants.ENCRYPT_CRYPTO, crypto);\n                        setEncryptionUser(encr, recToken, false, crypto);\n                    }\n                    \n                    encr.setDocument(saaj.getSOAPPart());\n                    encr.setEncryptSymmKey(false);\n                    encr.setSymmetricEncAlgorithm(algorithmSuite.getEncryption());\n                    \n                    if (!isRequestor()) {\n                        if (encrTok.getSHA1() != null) {\n                            encr.setCustomReferenceValue(encrTok.getSHA1());\n                            encr.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);\n                        } else {\n                            encr.setKeyIdentifierType(WSConstants.EMBED_SECURITY_TOKEN_REF);\n                        }\n                    } else {\n                        if (encrToken instanceof IssuedToken) {\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                            String tokenType = encrTok.getTokenType();\n                            if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                                || WSConstants.SAML_NS.equals(tokenType)) {\n                                encr.setCustomReferenceValue(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                            } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                                || WSConstants.SAML2_NS.equals(tokenType)) {\n                                encr.setCustomReferenceValue(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                            } else {\n                                encr.setCustomReferenceValue(tokenType);\n                            }\n                        }\n                    }\n\n                    encr.prepare(saaj.getSOAPPart(), crypto);\n                   \n                    if (encr.getBSTTokenId() != null) {\n                        encr.prependBSTElementToHeader(secHeader);\n                    }\n                   \n                   \n                    Element refList = encr.encryptForRef(null, encrParts);\n                    if (atEnd) {\n                        this.insertBeforeBottomUp(refList);\n                    } else {\n                        this.addDerivedKeyElement(refList);                        \n                    }\n                    return encr;\n                } catch (WSSecurityException e) {\n                    policyNotAsserted(recToken, e.getMessage());\n                }    \n            }\n        }\n        return null;\n    }","id":87209,"modified_method":"private WSSecBase doEncryption(TokenWrapper recToken,\n                                   SecurityToken encrTok,\n                                   boolean attached,\n                                   List<WSEncryptionPart> encrParts,\n                                   boolean atEnd) {\n        //Do encryption\n        if (recToken != null && recToken.getToken() != null && encrParts.size() > 0) {\n            Token encrToken = recToken.getToken();\n            policyAsserted(recToken);\n            policyAsserted(encrToken);\n            AlgorithmSuite algorithmSuite = sbinding.getAlgorithmSuite();\n            if (encrToken.isDerivedKeys()) {\n                return doEncryptionDerived(recToken, encrTok, encrToken,\n                                           attached, encrParts, atEnd);\n            } else {\n                try {\n                    WSSecEncrypt encr = new WSSecEncrypt(wssConfig);\n                    String encrTokId = encrTok.getId();\n                    if (attached) {\n                        encrTokId = encrTok.getWsuId();\n                        if (encrTokId == null && encrToken instanceof SecureConversationToken) {\n                            encr.setEncKeyIdDirectId(true);\n                            encrTokId = encrTok.getId();\n                        } else if (encrTokId == null) {\n                            encrTokId = encrTok.getId();\n                        }\n                        if (encrTokId.startsWith(\"#\")) {\n                            encrTokId = encrTokId.substring(1);\n                        }\n                    } else {\n                        encr.setEncKeyIdDirectId(true);\n                    }\n                    if (encrTok.getTokenType() != null) {\n                        encr.setCustomReferenceValue(encrTok.getTokenType());\n                    }\n                    encr.setEncKeyId(encrTokId);\n                    encr.setEphemeralKey(encrTok.getSecret());\n                    Crypto crypto = getEncryptionCrypto(recToken);\n                    if (crypto != null) {\n                        this.message.getExchange().put(SecurityConstants.ENCRYPT_CRYPTO, crypto);\n                        setEncryptionUser(encr, recToken, false, crypto);\n                    }\n                    \n                    encr.setDocument(saaj.getSOAPPart());\n                    encr.setEncryptSymmKey(false);\n                    encr.setSymmetricEncAlgorithm(algorithmSuite.getEncryption());\n                    \n                    if (encrToken instanceof IssuedToken) {\n                        //Setting the AttachedReference or the UnattachedReference according to the flag\n                        Element ref;\n                        if (attached) {\n                            ref = encrTok.getAttachedReference();\n                        } else {\n                            ref = encrTok.getUnattachedReference();\n                        }\n\n                        String tokenType = encrTok.getTokenType();\n                        if (ref != null) {\n                            SecurityTokenReference secRef = \n                                new SecurityTokenReference(cloneElement(ref), false);\n                            encr.setSecurityTokenReference(secRef);\n                        } else if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                            || WSConstants.SAML_NS.equals(tokenType)) {\n                            encr.setCustomReferenceValue(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                        } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                            || WSConstants.SAML2_NS.equals(tokenType)) {\n                            encr.setCustomReferenceValue(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                        } else {\n                            encr.setCustomReferenceValue(tokenType);\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                        }\n                    } else if (!isRequestor()) {\n                        if (encrTok.getSHA1() != null) {\n                            encr.setCustomReferenceValue(encrTok.getSHA1());\n                            encr.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);\n                        } else {\n                            encr.setKeyIdentifierType(WSConstants.EMBED_SECURITY_TOKEN_REF);\n                        }\n                    }\n\n                    encr.prepare(saaj.getSOAPPart(), crypto);\n                   \n                    if (encr.getBSTTokenId() != null) {\n                        encr.prependBSTElementToHeader(secHeader);\n                    }\n                   \n                   \n                    Element refList = encr.encryptForRef(null, encrParts);\n                    if (atEnd) {\n                        this.insertBeforeBottomUp(refList);\n                    } else {\n                        this.addDerivedKeyElement(refList);                        \n                    }\n                    return encr;\n                } catch (WSSecurityException e) {\n                    policyNotAsserted(recToken, e.getMessage());\n                }    \n            }\n        }\n        return null;\n    }","commit_id":"02a1e56b6fee9db4990cbf6defd4da72deb0b5f2","url":"https://github.com/apache/cxf"},{"original_method":"private byte[] doSignature(\n        boolean tokenIncluded,\n        SecurityToken secTok,\n        Token token,\n        TokenWrapper wrapper,\n        List<WSEncryptionPart> sigParts\n    ) throws Exception {\n        WSSecSignature sig = new WSSecSignature(wssConfig);\n        if (secTok.getTokenType() == null) {\n            sig.setCustomTokenId(secTok.getId());\n            sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n            sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n        } else {\n            String id = secTok.getWsuId();\n            if (id == null) {\n                sig.setCustomTokenId(secTok.getId());\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n            } else {\n                sig.setCustomTokenId(secTok.getWsuId());\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n            }\n            String tokenType = secTok.getTokenType();\n            if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML_NS.equals(tokenType)) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML2_NS.equals(tokenType)) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                sig.setCustomTokenValueType(tokenType);\n            }\n        }\n        Crypto crypto = null;\n        if (secTok.getSecret() == null) {\n            sig.setX509Certificate(secTok.getX509Certificate());\n\n            crypto = secTok.getCrypto();\n            String uname = crypto.getX509Identifier(secTok.getX509Certificate());\n            String password = getPassword(uname, token, WSPasswordCallback.SIGNATURE);\n            if (password == null) {\n                password = \"\";\n            }\n            sig.setUserInfo(uname, password);\n            sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n        } else {\n            crypto = getSignatureCrypto(wrapper);\n            sig.setSecretKey(secTok.getSecret());\n            sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getSymmetricSignature());\n        }\n        sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n\n        Document doc = saaj.getSOAPPart();\n        sig.prepare(doc, crypto, secHeader);\n\n        sig.setParts(sigParts);\n        List<Reference> referenceList = sig.addReferencesToSign(sigParts, secHeader);\n\n        //Do signature\n        if (bottomUpElement == null) {\n            sig.computeSignature(referenceList, false, null);\n        } else {\n            sig.computeSignature(referenceList, true, bottomUpElement);\n        }\n        bottomUpElement = sig.getSignatureElement();\n        mainSigId = sig.getId();\n\n        return sig.getSignatureValue();\n    }","id":87210,"modified_method":"private byte[] doSignature(\n        boolean tokenIncluded,\n        SecurityToken secTok,\n        Token token,\n        TokenWrapper wrapper,\n        List<WSEncryptionPart> sigParts\n    ) throws Exception {\n        WSSecSignature sig = new WSSecSignature(wssConfig);\n        \n        //Setting the AttachedReference or the UnattachedReference according to the flag\n        Element ref;\n        if (tokenIncluded) {\n            ref = secTok.getAttachedReference();\n        } else {\n            ref = secTok.getUnattachedReference();\n        }\n        \n        if (ref != null) {\n            SecurityTokenReference secRef = \n                new SecurityTokenReference(cloneElement(ref), false);\n            sig.setSecurityTokenReference(secRef);\n            sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n        } else if (secTok.getTokenType() == null) {\n            sig.setCustomTokenId(secTok.getId());\n            sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n            sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n        } else {\n            String id = secTok.getWsuId();\n            if (id == null) {\n                sig.setCustomTokenId(secTok.getId());\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n            } else {\n                sig.setCustomTokenId(secTok.getWsuId());\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n            }\n            String tokenType = secTok.getTokenType();\n            if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML_NS.equals(tokenType)) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML2_NS.equals(tokenType)) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                sig.setCustomTokenValueType(tokenType);\n            }\n        }\n        Crypto crypto = null;\n        if (secTok.getSecret() == null) {\n            sig.setX509Certificate(secTok.getX509Certificate());\n\n            crypto = secTok.getCrypto();\n            String uname = crypto.getX509Identifier(secTok.getX509Certificate());\n            String password = getPassword(uname, token, WSPasswordCallback.SIGNATURE);\n            if (password == null) {\n                password = \"\";\n            }\n            sig.setUserInfo(uname, password);\n            sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n        } else {\n            crypto = getSignatureCrypto(wrapper);\n            sig.setSecretKey(secTok.getSecret());\n            sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getSymmetricSignature());\n        }\n        sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n\n        Document doc = saaj.getSOAPPart();\n        sig.prepare(doc, crypto, secHeader);\n\n        sig.setParts(sigParts);\n        List<Reference> referenceList = sig.addReferencesToSign(sigParts, secHeader);\n\n        //Do signature\n        if (bottomUpElement == null) {\n            sig.computeSignature(referenceList, false, null);\n        } else {\n            sig.computeSignature(referenceList, true, bottomUpElement);\n        }\n        bottomUpElement = sig.getSignatureElement();\n        mainSigId = sig.getId();\n\n        return sig.getSignatureValue();\n    }","commit_id":"02a1e56b6fee9db4990cbf6defd4da72deb0b5f2","url":"https://github.com/apache/cxf"},{"original_method":"protected WSSecUsernameToken addUsernameToken(UsernameToken token) {\n        \n        AssertionInfo info = null;\n        Collection<AssertionInfo> ais = aim.getAssertionInfo(token.getName());\n        for (AssertionInfo ai : ais) {\n            if (ai.getAssertion() == token) {\n                info = ai;\n                if (!isRequestor()) {\n                    info.setAsserted(true);\n                    return null;\n                }\n            }\n        }\n        \n        String userName = (String)message.getContextualProperty(SecurityConstants.USERNAME);\n        \n        if (!StringUtils.isEmpty(userName)) {\n            // If NoPassword property is set we don't need to set the password\n            if (token.isNoPassword()) {\n                WSSecUsernameToken utBuilder = new WSSecUsernameToken();\n                utBuilder.setUserInfo(userName, null);\n                utBuilder.setPasswordType(null);\n                info.setAsserted(true);\n                return utBuilder;\n            }\n            \n            String password = (String)message.getContextualProperty(SecurityConstants.PASSWORD);\n            if (StringUtils.isEmpty(password)) {\n                password = getPassword(userName, token, WSPasswordCallback.USERNAME_TOKEN);\n            }\n            \n            if (!StringUtils.isEmpty(password)) {\n                //If the password is available then build the token\n                WSSecUsernameToken utBuilder = new WSSecUsernameToken();\n                if (token.isHashPassword()) {\n                    utBuilder.setPasswordType(WSConstants.PASSWORD_DIGEST);  \n                } else {\n                    utBuilder.setPasswordType(WSConstants.PASSWORD_TEXT);\n                }\n                \n                utBuilder.setUserInfo(userName, password);\n                info.setAsserted(true);\n                return utBuilder;\n            } else {\n                info.setNotAsserted(\"No password available\");\n            }\n        } else {\n            info.setNotAsserted(\"No username available\");\n        }\n        return null;\n    }","id":87211,"modified_method":"protected WSSecUsernameToken addUsernameToken(UsernameToken token) {\n        \n        AssertionInfo info = null;\n        Collection<AssertionInfo> ais = aim.getAssertionInfo(token.getName());\n        for (AssertionInfo ai : ais) {\n            if (ai.getAssertion() == token) {\n                info = ai;\n                if (!isRequestor()) {\n                    info.setAsserted(true);\n                    return null;\n                }\n            }\n        }\n        \n        String userName = (String)message.getContextualProperty(SecurityConstants.USERNAME);\n        \n        if (!StringUtils.isEmpty(userName)) {\n            // If NoPassword property is set we don't need to set the password\n            if (token.isNoPassword()) {\n                WSSecUsernameToken utBuilder = new WSSecUsernameToken();\n                utBuilder.setUserInfo(userName, null);\n                utBuilder.setPasswordType(null);\n                info.setAsserted(true);\n                return utBuilder;\n            }\n            \n            String password = (String)message.getContextualProperty(SecurityConstants.PASSWORD);\n            if (StringUtils.isEmpty(password)) {\n                password = getPassword(userName, token, WSPasswordCallback.USERNAME_TOKEN);\n            }\n            \n            if (!StringUtils.isEmpty(password)) {\n                //If the password is available then build the token\n                WSSecUsernameToken utBuilder = new WSSecUsernameToken();\n                if (token.isHashPassword()) {\n                    utBuilder.setPasswordType(WSConstants.PASSWORD_DIGEST);  \n                } else {\n                    utBuilder.setPasswordType(WSConstants.PASSWORD_TEXT);\n                }\n                \n                utBuilder.setUserInfo(userName, password);\n                info.setAsserted(true);\n                return utBuilder;\n            } else {\n                policyNotAsserted(token, \"No username available\");\n            }\n        } else {\n            policyNotAsserted(token, \"No username available\");\n        }\n        return null;\n    }","commit_id":"d40eb75cb6810398fe74e676c0b508286677ef89","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This method assigns the various TLS parameters on the HttpsURLConnection\n     * from the TLS Client Parameters. Connection parameter is of supertype HttpURLConnection, \n     * which allows internal cast to potentially divergent subtype (https) implementations.\n     */\n    protected synchronized void decorateWithTLS(HttpURLConnection connection)\n        throws NoSuchAlgorithmException,\n               NoSuchProviderException,\n               KeyManagementException {\n\n        // First see if an SSLSocketFactory was set.  This allows easy interop\n        // with not-yet-commons-ssl.jar, or even just people who like doing their\n        // own JSSE.\n        if (socketFactory == null) {\n            SSLSocketFactory preSetFactory = tlsClientParameters.getSSLSocketFactory();\n            if (preSetFactory != null) {\n                socketFactory = preSetFactory;\n            }\n        }\n\n        // Okay, no SSLSocketFactory available in TLSClientParameters.  Maybe\n        // TrustManagers, KeyManagers, etc?\n        if (socketFactory == null) {\n            String provider = tlsClientParameters.getJsseProvider();\n            \n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null\n                      ? tlsClientParameters.getSecureSocketProtocol()\n                      : \"TLS\";\n                      \n            SSLContext ctx = provider == null\n                      ? SSLContext.getInstance(protocol)\n                      : SSLContext.getInstance(protocol, provider);\n            \n            ctx.init(\n                tlsClientParameters.getKeyManagers(), \n                tlsClientParameters.getTrustManagers(), \n                tlsClientParameters.getSecureRandom());\n            \n            // The \"false\" argument means opposite of exclude.\n            String[] cipherSuites =\n                SSLUtils.getCiphersuites(tlsClientParameters.getCipherSuites(),\n                                         SSLUtils.getSupportedCipherSuites(ctx),\n                                         tlsClientParameters.getCipherSuitesFilter(),\n                                         LOG, false);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(),\n                                                        cipherSuites,\n                                                        tlsClientParameters.getSecureSocketProtocol());\n        }\n        \n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            if (tlsClientParameters.isDisableCNCheck()) {\n                conn.setHostnameVerifier(CertificateHostnameVerifier.ALLOW_ALL);\n            } else {\n                conn.setHostnameVerifier(CertificateHostnameVerifier.DEFAULT);\n            }\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case\n            try {\n                Class connectionClass = getDeprecatedSunHttpsURLConnectionClass();\n                Class verifierClass = getDeprecatedSunHostnameVerifierClass();\n                Method setHostnameVerifier = connectionClass.getMethod(\"setHostnameVerifier\", verifierClass);\n                InvocationHandler handler = new InvocationHandler() {\n                    public Object invoke(Object proxy, \n                                         Method method, \n                                         Object[] args) throws Throwable {\n                        return true;\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                          new Class[] {verifierClass},\n                                                                          handler);\n                setHostnameVerifier.invoke(connectionClass.cast(connection), verifierClass.cast(proxy));\n                Method setSSLSocketFactory = connectionClass.getMethod(\"setSSLSocketFactory\", \n                                                                       SSLSocketFactory.class);\n                setSSLSocketFactory.invoke(connectionClass.cast(connection), socketFactory);\n            } catch (Exception ex) {\n                throw new IllegalArgumentException(\"Error decorating connection class \" \n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }","id":87212,"modified_method":"/**\n     * This method assigns the various TLS parameters on the HttpsURLConnection\n     * from the TLS Client Parameters. Connection parameter is of supertype HttpURLConnection, \n     * which allows internal cast to potentially divergent subtype (https) implementations.\n     */\n    protected synchronized void decorateWithTLS(HttpURLConnection connection)\n        throws NoSuchAlgorithmException,\n               NoSuchProviderException,\n               KeyManagementException {\n\n        // First see if an SSLSocketFactory was set.  This allows easy interop\n        // with not-yet-commons-ssl.jar, or even just people who like doing their\n        // own JSSE.\n        if (socketFactory == null) {\n            SSLSocketFactory preSetFactory = tlsClientParameters.getSSLSocketFactory();\n            if (preSetFactory != null) {\n                socketFactory = preSetFactory;\n            }\n        }\n\n        // Okay, no SSLSocketFactory available in TLSClientParameters.  Maybe\n        // TrustManagers, KeyManagers, etc?\n        if (socketFactory == null) {\n            String provider = tlsClientParameters.getJsseProvider();\n            \n            String protocol = tlsClientParameters.getSecureSocketProtocol() != null\n                      ? tlsClientParameters.getSecureSocketProtocol()\n                      : \"TLS\";\n                      \n            SSLContext ctx = provider == null\n                      ? SSLContext.getInstance(protocol)\n                      : SSLContext.getInstance(protocol, provider);\n            \n                      \n\n            TrustManager[] trustAllCerts = tlsClientParameters.getTrustManagers();\n            /*\n            TrustManager[] trustAllCerts = new TrustManager[] {\n                new javax.net.ssl.X509TrustManager() {\n                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                    public void checkClientTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                    }\n                    public void checkServerTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                    }\n                }\n            };\n            */         \n            ctx.init(\n                tlsClientParameters.getKeyManagers(),\n                trustAllCerts, \n                tlsClientParameters.getSecureRandom());\n            \n            // The \"false\" argument means opposite of exclude.\n            String[] cipherSuites =\n                SSLUtils.getCiphersuites(tlsClientParameters.getCipherSuites(),\n                                         SSLUtils.getSupportedCipherSuites(ctx),\n                                         tlsClientParameters.getCipherSuitesFilter(),\n                                         LOG, false);\n            // The SSLSocketFactoryWrapper enables certain cipher suites\n            // from the policy.\n            socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(),\n                                                        cipherSuites,\n                                                        tlsClientParameters.getSecureSocketProtocol());\n        }\n        \n        if (connection instanceof HttpsURLConnection) {\n            // handle the expected case (javax.net.ssl)\n            HttpsURLConnection conn = (HttpsURLConnection) connection;\n            if (tlsClientParameters.isDisableCNCheck()) {\n                conn.setHostnameVerifier(CertificateHostnameVerifier.ALLOW_ALL);\n            } else {\n                conn.setHostnameVerifier(CertificateHostnameVerifier.DEFAULT);\n            }\n            conn.setSSLSocketFactory(socketFactory);\n        } else {\n            // handle the deprecated sun case\n            try {\n                Class connectionClass = getDeprecatedSunHttpsURLConnectionClass();\n                Class verifierClass = getDeprecatedSunHostnameVerifierClass();\n                Method setHostnameVerifier = connectionClass.getMethod(\"setHostnameVerifier\", verifierClass);\n                InvocationHandler handler = new InvocationHandler() {\n                    public Object invoke(Object proxy, \n                                         Method method, \n                                         Object[] args) throws Throwable {\n                        return true;\n                    }\n                };\n                Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                          new Class[] {verifierClass},\n                                                                          handler);\n                setHostnameVerifier.invoke(connectionClass.cast(connection), verifierClass.cast(proxy));\n                Method setSSLSocketFactory = connectionClass.getMethod(\"setSSLSocketFactory\", \n                                                                       SSLSocketFactory.class);\n                setSSLSocketFactory.invoke(connectionClass.cast(connection), socketFactory);\n            } catch (Exception ex) {\n                throw new IllegalArgumentException(\"Error decorating connection class \" \n                        + connection.getClass().getName(), ex);\n            }\n        }\n    }","commit_id":"d40eb75cb6810398fe74e676c0b508286677ef89","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Create a HttpURLConnection, proxified if necessary.\n     * \n     * \n     * @param proxy This parameter is non-null if connection should be proxied.\n     * @param url   The target URL. This parameter must be an https url.\n     * \n     * @return The HttpsURLConnection for the given URL.\n     * @throws IOException This exception is thrown if \n     *         the \"url\" is not \"https\" or other IOException\n     *         is thrown. \n     *                     \n     */\n    public HttpURLConnection createConnection(Proxy proxy, URL url)\n        throws IOException {\n\n        if (!url.getProtocol().equals(HTTPS_URL_PROTOCOL_ID)) {\n            throw new IOException(\"Illegal Protocol \" \n                    + url.getProtocol() \n                    + \" for HTTPS URLConnection Factory.\");\n        }\n        \n        HttpURLConnection connection =\n            (HttpURLConnection) (proxy != null \n                                   ? url.openConnection(proxy)\n                                   : url.openConnection());\n                                   \n        if (tlsClientParameters != null) {\n            Exception ex = null;\n            try {\n                decorateWithTLS(connection);\n            } catch (Exception e) {\n                ex = e;\n            } finally {\n                if (ex != null) {\n                    if (ex instanceof IOException) {\n                        throw (IOException) ex;\n                    }\n                    throw new IIOException(\"Error while initializing secure socket\", ex);\n                }\n            }\n        } else {\n            assert false;\n        }\n\n        return connection;\n    }","id":87213,"modified_method":"/**\n     * Create a HttpURLConnection, proxified if necessary.\n     * \n     * \n     * @param proxy This parameter is non-null if connection should be proxied.\n     * @param url   The target URL. This parameter must be an https url.\n     * \n     * @return The HttpsURLConnection for the given URL.\n     * @throws IOException This exception is thrown if \n     *         the \"url\" is not \"https\" or other IOException\n     *         is thrown. \n     *                     \n     */\n    public HttpURLConnection createConnection(Proxy proxy, URL url)\n        throws IOException {\n\n        if (!url.getProtocol().equals(HTTPS_URL_PROTOCOL_ID)) {\n            throw new IOException(\"Illegal Protocol \" \n                    + url.getProtocol() \n                    + \" for HTTPS URLConnection Factory.\");\n        }\n        \n        HttpURLConnection connection =\n            (HttpURLConnection) (proxy != null \n                                   ? url.openConnection(proxy)\n                                   : url.openConnection());\n                                   \n        if (tlsClientParameters != null) {\n            Exception ex = null;\n            try {\n                decorateWithTLS(connection);\n            } catch (Exception e) {\n                ex = e;\n            } finally {\n                if (ex != null) {\n                    if (ex instanceof IOException) {\n                        throw (IOException) ex;\n                    }\n                    throw new IIOException(\"Error while initializing secure socket\", ex);\n                }\n            }\n        }\n\n        return connection;\n    }","commit_id":"d40eb75cb6810398fe74e676c0b508286677ef89","url":"https://github.com/apache/cxf"},{"original_method":"private boolean assertTransportBinding(AssertionInfoMap aim) {\n        assertPolicy(aim, SP12Constants.TRANSPORT_TOKEN);\n        assertPolicy(aim, SP12Constants.ENCRYPTED_PARTS);\n        return !assertPolicy(aim, SP12Constants.TRANSPORT_BINDING);\n    }","id":87214,"modified_method":"private boolean assertTransportBinding(AssertionInfoMap aim) {\n        assertPolicy(aim, SP12Constants.TRANSPORT_TOKEN);\n        assertPolicy(aim, SP12Constants.ENCRYPTED_PARTS);\n        assertPolicy(aim, SP12Constants.SIGNED_PARTS);\n        return !assertPolicy(aim, SP12Constants.TRANSPORT_BINDING);\n    }","commit_id":"d40eb75cb6810398fe74e676c0b508286677ef89","url":"https://github.com/apache/cxf"},{"original_method":"private byte[] doIssuedTokenSignature(Token token, \n                                          SignedEncryptedParts signdParts,\n                                          TokenWrapper wrapper,\n                                          SecurityToken securityTok) throws Exception {\n        Document doc = saaj.getSOAPPart();\n        \n        //Get the issued token\n        SecurityToken secTok = securityTok;\n        if (secTok == null) {\n            secTok = getSecurityToken();\n        }\n   \n        SPConstants.IncludeTokenType inclusion = token.getInclusion();\n        boolean tokenIncluded = false;\n        \n        Vector<WSEncryptionPart> sigParts = new Vector<WSEncryptionPart>();\n        if (inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS\n            || ((inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS_TO_RECIPIENT \n                || inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ONCE) \n                && isRequestor())) {\n          \n            //Add the token\n            Element el = cloneElement(secTok.getToken());\n            if (securityTok != null) {\n                //do we need to sign this as well?\n                //String id = addWsuIdToElement(el);\n                //sigParts.add(new WSEncryptionPart(id));                          \n            }\n            \n            addEncyptedKeyElement(el);\n            tokenIncluded = true;\n        }\n        \n        if (timestampEl != null) {\n            sigParts.add(new WSEncryptionPart(timestampEl.getId()));                          \n        }\n        \n        if (signdParts != null) {\n            if (signdParts.isBody()) {\n                sigParts.add(new WSEncryptionPart(addWsuIdToElement(saaj.getSOAPBody())));\n            }\n            if (secTok.getX509Certificate() != null\n                || securityTok != null) {\n                //the \"getX509Certificate\" this is to workaround an issue in WCF\n                //In WCF, for TransportBinding, in most cases, it doesn't wan't any of\n                //the headers signed even if the policy sais so.   HOWEVER, for KeyValue\n                //IssuedTokends, it DOES want them signed\n                for (Header header : signdParts.getHeaders()) {\n                    WSEncryptionPart wep = new WSEncryptionPart(header.getName(), \n                            header.getNamespace(),\n                            \"Content\");\n                    sigParts.add(wep);\n                }\n            }\n        }\n        \n        //check for derived keys\n        AlgorithmSuite algorithmSuite = tbinding.getAlgorithmSuite();\n        if (token.isDerivedKeys()) {\n            //Do Signature with derived keys\n            WSSecDKSign dkSign = new WSSecDKSign();\n          \n            //Setting the AttachedReference or the UnattachedReference according to the flag\n            Element ref;\n            if (tokenIncluded) {\n                ref = secTok.getAttachedReference();\n            } else {\n                ref = secTok.getUnattachedReference();\n            }\n          \n            if (ref != null) {\n                dkSign.setExternalKey(secTok.getSecret(), cloneElement(ref));\n            } else {\n                dkSign.setExternalKey(secTok.getSecret(), secTok.getId());\n            }\n          \n            //    Set the algo info\n            dkSign.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            dkSign.setDerivedKeyLength(algorithmSuite.getSignatureDerivedKeyLength() / 8);\n            if (token.getSPConstants() == SP12Constants.INSTANCE) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_12);\n            }\n            dkSign.prepare(doc, secHeader);\n          \n            addDerivedKeyElement(dkSign.getdktElement());\n          \n            dkSign.setParts(sigParts);\n            dkSign.addReferencesToSign(sigParts, secHeader);\n          \n            //Do signature\n            dkSign.computeSignature();\n          \n            dkSign.appendSigToHeader(secHeader);\n          \n            return dkSign.getSignatureValue();\n        } else {\n            WSSecSignature sig = new WSSecSignature();\n            sig.setCustomTokenId(secTok.getId());\n            if (secTok.getTokenType() == null) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_NS\n                                            + WSConstants.SAML_ASSERTION_ID);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                sig.setCustomTokenValueType(secTok.getTokenType());\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n            }\n            Crypto crypto = null;\n            if (secTok.getSecret() == null) {\n                sig.setX509Certificate(secTok.getX509Certificate());\n                \n                crypto = secTok.getCrypto();\n                String uname = crypto.getKeyStore().getCertificateAlias(secTok.getX509Certificate());\n                String password = getPassword(uname, token, WSPasswordCallback.SIGNATURE);\n                if (password == null) {\n                    password = \"\";\n                }\n                sig.setUserInfo(uname, password);\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n            } else {\n                crypto = getSignatureCrypto(wrapper);\n                sig.setSecretKey(secTok.getSecret());\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getSymmetricSignature());\n            }\n            sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n\n            sig.prepare(doc, crypto, secHeader);\n\n            sig.setParts(sigParts);\n            sig.addReferencesToSign(sigParts, secHeader);\n\n            //Do signature\n            sig.computeSignature();\n\n            //Add elements to header\n            insertBeforeBottomUp(sig.getSignatureElement());\n\n            return sig.getSignatureValue();\n        }\n    }","id":87215,"modified_method":"private byte[] doIssuedTokenSignature(Token token, \n                                          SignedEncryptedParts signdParts,\n                                          TokenWrapper wrapper,\n                                          SecurityToken securityTok) throws Exception {\n        Document doc = saaj.getSOAPPart();\n        \n        //Get the issued token\n        SecurityToken secTok = securityTok;\n        if (secTok == null) {\n            secTok = getSecurityToken();\n        }\n   \n        SPConstants.IncludeTokenType inclusion = token.getInclusion();\n        boolean tokenIncluded = false;\n        \n        Vector<WSEncryptionPart> sigParts = new Vector<WSEncryptionPart>();\n        if (inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS\n            || ((inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS_TO_RECIPIENT \n                || inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ONCE) \n                && isRequestor())) {\n          \n            //Add the token\n            Element el = cloneElement(secTok.getToken());\n            if (securityTok != null) {\n                //do we need to sign this as well?\n                //String id = addWsuIdToElement(el);\n                //sigParts.add(new WSEncryptionPart(id));                          \n            }\n            \n            addEncyptedKeyElement(el);\n            tokenIncluded = true;\n        }\n        \n        if (timestampEl != null) {\n            sigParts.add(new WSEncryptionPart(timestampEl.getId()));                          \n        }\n        \n        if (signdParts != null) {\n            if (signdParts.isBody()) {\n                sigParts.add(new WSEncryptionPart(addWsuIdToElement(saaj.getSOAPBody())));\n            }\n            if (secTok.getX509Certificate() != null\n                || securityTok != null) {\n                //the \"getX509Certificate\" this is to workaround an issue in WCF\n                //In WCF, for TransportBinding, in most cases, it doesn't wan't any of\n                //the headers signed even if the policy sais so.   HOWEVER, for KeyValue\n                //IssuedTokends, it DOES want them signed\n                for (Header header : signdParts.getHeaders()) {\n                    WSEncryptionPart wep = new WSEncryptionPart(header.getName(), \n                            header.getNamespace(),\n                            \"Content\");\n                    sigParts.add(wep);\n                }\n            }\n        }\n        \n        //check for derived keys\n        AlgorithmSuite algorithmSuite = tbinding.getAlgorithmSuite();\n        if (token.isDerivedKeys()) {\n            //Do Signature with derived keys\n            WSSecDKSign dkSign = new WSSecDKSign();\n          \n            //Setting the AttachedReference or the UnattachedReference according to the flag\n            Element ref;\n            if (tokenIncluded) {\n                ref = secTok.getAttachedReference();\n            } else {\n                ref = secTok.getUnattachedReference();\n            }\n          \n            if (ref != null) {\n                dkSign.setExternalKey(secTok.getSecret(), cloneElement(ref));\n            } else {\n                dkSign.setExternalKey(secTok.getSecret(), secTok.getId());\n            }\n          \n            //    Set the algo info\n            dkSign.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            dkSign.setDerivedKeyLength(algorithmSuite.getSignatureDerivedKeyLength() / 8);\n            if (token.getSPConstants() == SP12Constants.INSTANCE) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_12);\n            }\n            dkSign.prepare(doc, secHeader);\n          \n            addDerivedKeyElement(dkSign.getdktElement());\n          \n            dkSign.setParts(sigParts);\n            dkSign.addReferencesToSign(sigParts, secHeader);\n          \n            //Do signature\n            dkSign.computeSignature();\n          \n            dkSign.appendSigToHeader(secHeader);\n          \n            return dkSign.getSignatureValue();\n        } else {\n            WSSecSignature sig = new WSSecSignature();\n            if (secTok.getTokenType() == null) {\n                sig.setCustomTokenId(secTok.getId());\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_NS\n                                            + WSConstants.SAML_ASSERTION_ID);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                String id = secTok.getWsuId();\n                if (id == null) {\n                    sig.setCustomTokenId(secTok.getId());\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n                } else {\n                    sig.setCustomTokenId(secTok.getWsuId());\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n                }\n                sig.setCustomTokenValueType(secTok.getTokenType());\n                sig.setCustomTokenValueType(secTok.getTokenType());\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n            }\n            Crypto crypto = null;\n            if (secTok.getSecret() == null) {\n                sig.setX509Certificate(secTok.getX509Certificate());\n                \n                crypto = secTok.getCrypto();\n                String uname = crypto.getKeyStore().getCertificateAlias(secTok.getX509Certificate());\n                String password = getPassword(uname, token, WSPasswordCallback.SIGNATURE);\n                if (password == null) {\n                    password = \"\";\n                }\n                sig.setUserInfo(uname, password);\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getAsymmetricSignature());\n            } else {\n                crypto = getSignatureCrypto(wrapper);\n                sig.setSecretKey(secTok.getSecret());\n                sig.setSignatureAlgorithm(binding.getAlgorithmSuite().getSymmetricSignature());\n            }\n            sig.setSigCanonicalization(binding.getAlgorithmSuite().getInclusiveC14n());\n\n            sig.prepare(doc, crypto, secHeader);\n\n            sig.setParts(sigParts);\n            sig.addReferencesToSign(sigParts, secHeader);\n\n            //Do signature\n            sig.computeSignature();\n\n            //Add elements to header\n            insertBeforeBottomUp(sig.getSignatureElement());\n\n            return sig.getSignatureValue();\n        }\n    }","commit_id":"d40eb75cb6810398fe74e676c0b508286677ef89","url":"https://github.com/apache/cxf"},{"original_method":"private SecurityToken createSecurityToken(Document document, byte[] requestorEntropy) \n        throws WSSecurityException {\n        \n        Element el = document.getDocumentElement();\n        if (\"RequestSecurityTokenResponseCollection\".equals(el.getLocalName())) {\n            el = DOMUtils.getFirstElement(el);\n        }\n        if (!\"RequestSecurityTokenResponse\".equals(el.getLocalName())) {\n            throw new Fault(\"Unexpected element \" + el.getLocalName(), LOG);\n        }\n        el = DOMUtils.getFirstElement(el);\n        Element rst = null;\n        Element rar = null;\n        Element rur = null;\n        Element rpt = null;\n        Element lte = null;\n        Element entropy = null;\n        \n        while (el != null) {\n            String ln = el.getLocalName();\n            if (namespace.equals(el.getNamespaceURI())) {\n                if (\"Lifetime\".equals(ln)) {\n                    lte = el;\n                } else if (\"RequestedSecurityToken\".equals(ln)) {\n                    rst = DOMUtils.getFirstElement(el);\n                } else if (\"RequestedAttachedReference\".equals(ln)) {\n                    rar = DOMUtils.getFirstElement(el);\n                } else if (\"RequestedUnattachedReference\".equals(ln)) {\n                    rur = DOMUtils.getFirstElement(el);\n                } else if (\"RequestedProofToken\".equals(ln)) {\n                    rpt = el;\n                } else if (\"Entropy\".equals(ln)) {\n                    entropy = el;\n                }\n            }\n            el = DOMUtils.getNextElement(el);\n        }\n        \n        String id = findID(rar, rur, rst);\n        if (StringUtils.isEmpty(id)) {\n            throw new TrustException(new Message(\"NO_ID\", LOG));\n        }\n        \n        SecurityToken token = new SecurityToken(id, copyElement(rst), copyElement(lte));\n        token.setAttachedReference(copyElement(rar));\n        token.setUnattachedReference(copyElement(rur));\n        token.setIssuerAddress(location);\n                \n        \n        byte[] secret = null;\n\n        if (rpt != null) {\n            Element child = DOMUtils.getFirstElement(rpt);\n            QName childQname = DOMUtils.getElementQName(child);\n            if (childQname.equals(new QName(namespace, \"BinarySecret\"))) {\n                //First check for the binary secret\n                String b64Secret = DOMUtils.getContent(child);\n                secret = Base64.decode(b64Secret);\n            } else if (childQname.equals(new QName(namespace, WSConstants.ENC_KEY_LN))) {\n                try {\n\n\n                    EncryptedKeyProcessor processor = new EncryptedKeyProcessor();\n\n                    processor.handleToken(child, null, crypto,\n                                          cbHandler, null, new Vector(),\n                                          null);\n\n                    secret = processor.getDecryptedBytes();\n                } catch (WSSecurityException e) {\n                    throw new TrustException(new Message(\"ENCRYPTED_KEY_ERROR\", LOG), e);\n                }\n            } else if (childQname.equals(new QName(namespace, \"ComputedKey\"))) {\n                //Handle the computed key\n                Element binSecElem = entropy == null ? null \n                    : DOMUtils.getFirstElement(entropy);\n                String content = binSecElem == null ? null\n                    : DOMUtils.getContent(binSecElem);\n                if (content != null && !StringUtils.isEmpty(content.trim())) {\n\n                    byte[] serviceEntr = Base64.decode(content);\n\n                    //Right now we only use PSHA1 as the computed key algo                    \n                    P_SHA1 psha1 = new P_SHA1();\n\n                    int length = (keySize > 0) ? keySize\n                                 : algorithmSuite\n                                     .getMaximumSymmetricKeyLength();\n                    try {\n                        secret = psha1.createKey(requestorEntropy, serviceEntr, 0, length / 8);\n                    } catch (ConversationException e) {\n                        throw new TrustException(new Message(\"DERIVED_KEY_ERROR\", LOG), e);\n                    }\n                } else {\n                    //Service entropy missing\n                    throw new TrustException(new Message(\"NO_ENTROPY\", LOG));\n                }\n            }\n        } else if (requestorEntropy != null) {\n            //Use requester entropy as the key\n            secret = requestorEntropy;\n        }\n        token.setSecret(secret);\n        \n        return token;\n    }","id":87216,"modified_method":"private SecurityToken createSecurityToken(Document document, byte[] requestorEntropy) \n        throws WSSecurityException {\n        \n        Element el = document.getDocumentElement();\n        if (\"RequestSecurityTokenResponseCollection\".equals(el.getLocalName())) {\n            el = DOMUtils.getFirstElement(el);\n        }\n        if (!\"RequestSecurityTokenResponse\".equals(el.getLocalName())) {\n            throw new Fault(\"Unexpected element \" + el.getLocalName(), LOG);\n        }\n        el = DOMUtils.getFirstElement(el);\n        Element rst = null;\n        Element rar = null;\n        Element rur = null;\n        Element rpt = null;\n        Element lte = null;\n        Element entropy = null;\n        \n        while (el != null) {\n            String ln = el.getLocalName();\n            if (namespace.equals(el.getNamespaceURI())) {\n                if (\"Lifetime\".equals(ln)) {\n                    lte = el;\n                } else if (\"RequestedSecurityToken\".equals(ln)) {\n                    rst = DOMUtils.getFirstElement(el);\n                } else if (\"RequestedAttachedReference\".equals(ln)) {\n                    rar = DOMUtils.getFirstElement(el);\n                } else if (\"RequestedUnattachedReference\".equals(ln)) {\n                    rur = DOMUtils.getFirstElement(el);\n                } else if (\"RequestedProofToken\".equals(ln)) {\n                    rpt = el;\n                } else if (\"Entropy\".equals(ln)) {\n                    entropy = el;\n                }\n            }\n            el = DOMUtils.getNextElement(el);\n        }\n        Element rstDec = rst;\n        try {\n            rstDec = decrypt(rst);\n        } catch (IOException e1) {\n            throw new TrustException(e1);\n        }\n        \n        String id = findID(rar, rur, rst);\n        if (StringUtils.isEmpty(id)) {\n            throw new TrustException(new Message(\"NO_ID\", LOG));\n        }\n        \n        SecurityToken token = new SecurityToken(id, rstDec, lte);\n        token.setAttachedReference(rar);\n        token.setUnattachedReference(rur);\n        token.setIssuerAddress(location);\n                \n        \n        byte[] secret = null;\n\n        if (rpt != null) {\n            Element child = DOMUtils.getFirstElement(rpt);\n            QName childQname = DOMUtils.getElementQName(child);\n            if (childQname.equals(new QName(namespace, \"BinarySecret\"))) {\n                //First check for the binary secret\n                String b64Secret = DOMUtils.getContent(child);\n                secret = Base64.decode(b64Secret);\n            } else if (childQname.equals(new QName(namespace, WSConstants.ENC_KEY_LN))) {\n                try {\n\n\n                    EncryptedKeyProcessor processor = new EncryptedKeyProcessor();\n\n                    processor.handleToken(child, null, createCrypto(),\n                                          createHandler(), null, new Vector(),\n                                          null);\n\n                    secret = processor.getDecryptedBytes();\n                } catch (IOException e) {\n                    throw new TrustException(new Message(\"ENCRYPTED_KEY_ERROR\", LOG), e);\n                }\n            } else if (childQname.equals(new QName(namespace, \"ComputedKey\"))) {\n                //Handle the computed key\n                Element binSecElem = entropy == null ? null \n                    : DOMUtils.getFirstElement(entropy);\n                String content = binSecElem == null ? null\n                    : DOMUtils.getContent(binSecElem);\n                if (content != null && !StringUtils.isEmpty(content.trim())) {\n\n                    byte[] serviceEntr = Base64.decode(content);\n\n                    //Right now we only use PSHA1 as the computed key algo                    \n                    P_SHA1 psha1 = new P_SHA1();\n\n                    int length = (keySize > 0) ? keySize\n                                 : algorithmSuite\n                                     .getMaximumSymmetricKeyLength();\n                    try {\n                        secret = psha1.createKey(requestorEntropy, serviceEntr, 0, length / 8);\n                    } catch (ConversationException e) {\n                        throw new TrustException(new Message(\"DERIVED_KEY_ERROR\", LOG), e);\n                    }\n                } else {\n                    //Service entropy missing\n                    throw new TrustException(new Message(\"NO_ENTROPY\", LOG));\n                }\n            }\n        } else if (requestorEntropy != null) {\n            //Use requester entropy as the key\n            secret = requestorEntropy;\n        }\n        token.setSecret(secret);\n        \n        return token;\n    }","commit_id":"172ef551ef356af4c62a9958cd5f0eb01cc5e4f2","url":"https://github.com/apache/cxf"},{"original_method":"private Element copyElement(Element el) {\n        if (el == null) {\n            return null;\n        }\n        try {\n            W3CDOMStreamWriter writer = new W3CDOMStreamWriter();\n            writer.setNsRepairing(true);\n            StaxUtils.copy(el, writer);\n            return writer.getDocument().getDocumentElement();\n        } catch (Exception ex) {\n            return el;\n        }\n    }","id":87217,"modified_method":"protected Element decrypt(Element firstElement) throws IOException {\n        if (\"EncryptedData\".equals(firstElement.getLocalName())\n            && \"http://www.w3.org/2001/04/xmlenc#\".equals(firstElement.getNamespaceURI())) {\n            \n            Node parent = firstElement.getParentNode();\n            Node prev = firstElement.getPreviousSibling();\n            \n            //encrypted even more.  WCF seems to do this periodically\n            EncryptedDataProcessor processor = new EncryptedDataProcessor();\n\n            processor.handleToken(firstElement, null, createCrypto(),\n                                  createHandler(), null, new Vector(),\n                                  null);\n            \n            if (prev == null) {\n                firstElement = (Element)parent.getFirstChild();\n            } else {\n                firstElement = (Element)prev.getNextSibling();\n            }\n\n        }\n        return firstElement;\n    }","commit_id":"172ef551ef356af4c62a9958cd5f0eb01cc5e4f2","url":"https://github.com/apache/cxf"},{"original_method":"private byte[] doIssuedTokenSignature(Token token, SignedEncryptedParts signdParts,\n                                          TokenWrapper wrapper) throws Exception {\n        Document doc = saaj.getSOAPPart();\n        \n        //Get the issued token\n        SecurityToken secTok = getSecurityToken();\n   \n        SPConstants.IncludeTokenType inclusion = token.getInclusion();\n        boolean tokenIncluded = false;\n        \n        if (inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS\n            || ((inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS_TO_RECIPIENT \n                || inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ONCE) \n                && isRequestor())) {\n          \n            //Add the token\n            addEncyptedKeyElement(cloneElement(secTok.getToken()));\n            tokenIncluded = true;\n        }\n\n        Vector<WSEncryptionPart> sigParts = new Vector<WSEncryptionPart>();\n        \n        if (timestampEl != null) {\n            sigParts.add(new WSEncryptionPart(timestampEl.getId()));                          \n        }\n        \n        /*\n        if (tbinding.isTokenProtection() && tokenIncluded) {\n            sigParts.add(new WSEncryptionPart(secTok.getId()));\n        }\n        */\n        \n        if (signdParts != null) {\n            if (signdParts.isBody()) {\n                sigParts.add(new WSEncryptionPart(addWsuIdToElement(saaj.getSOAPBody())));\n            }\n    \n            for (Header header : signdParts.getHeaders()) {\n                WSEncryptionPart wep = new WSEncryptionPart(header.getName(), \n                        header.getNamespace(),\n                        \"Content\");\n                sigParts.add(wep);\n            }\n        }\n        \n        //check for derived keys\n        AlgorithmSuite algorithmSuite = tbinding.getAlgorithmSuite();\n        if (token.isDerivedKeys()) {\n            //Do Signature with derived keys\n            WSSecDKSign dkSign = new WSSecDKSign();\n          \n            //Setting the AttachedReference or the UnattachedReference according to the flag\n            Element ref;\n            if (tokenIncluded) {\n                ref = secTok.getAttachedReference();\n            } else {\n                ref = secTok.getUnattachedReference();\n            }\n          \n            if (ref != null) {\n                dkSign.setExternalKey(secTok.getSecret(), cloneElement(ref));\n            } else {\n                dkSign.setExternalKey(secTok.getSecret(), secTok.getId());\n            }\n          \n            //    Set the algo info\n            dkSign.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            dkSign.setDerivedKeyLength(algorithmSuite.getSignatureDerivedKeyLength() / 8);\n            if (token.getSPConstants() == SP12Constants.INSTANCE) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_12);\n            }\n            dkSign.prepare(doc, secHeader);\n          \n            addDerivedKeyElement(dkSign.getdktElement());\n          \n            dkSign.setParts(sigParts);\n            dkSign.addReferencesToSign(sigParts, secHeader);\n          \n            //Do signature\n            dkSign.computeSignature();\n          \n            dkSign.appendSigToHeader(secHeader);\n          \n            return dkSign.getSignatureValue();\n        } else {\n            WSSecSignature sig = new WSSecSignature();\n            sig.setCustomTokenId(secTok.getId().substring(1));\n            sig.setCustomTokenValueType(WSConstants.WSS_SAML_NS\n                                        + WSConstants.SAML_ASSERTION_ID);\n            sig.setSecretKey(secTok.getSecret());\n            sig.setSignatureAlgorithm(algorithmSuite.getAsymmetricSignature());\n            sig.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n            sig.prepare(doc, getSignatureCrypto(wrapper), secHeader);\n\n            sig.setParts(sigParts);\n            sig.addReferencesToSign(sigParts, secHeader);\n\n            //Do signature\n            sig.computeSignature();\n\n            //Add elements to header\n            insertBeforeBottomUp(sig.getSignatureElement());\n\n            return sig.getSignatureValue();\n        }\n    }","id":87218,"modified_method":"private byte[] doIssuedTokenSignature(Token token, SignedEncryptedParts signdParts,\n                                          TokenWrapper wrapper) throws Exception {\n        Document doc = saaj.getSOAPPart();\n        \n        //Get the issued token\n        SecurityToken secTok = getSecurityToken();\n   \n        SPConstants.IncludeTokenType inclusion = token.getInclusion();\n        boolean tokenIncluded = false;\n        \n        if (inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS\n            || ((inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ALWAYS_TO_RECIPIENT \n                || inclusion == SPConstants.IncludeTokenType.INCLUDE_TOKEN_ONCE) \n                && isRequestor())) {\n          \n            //Add the token\n            addEncyptedKeyElement(cloneElement(secTok.getToken()));\n            tokenIncluded = true;\n        }\n\n        Vector<WSEncryptionPart> sigParts = new Vector<WSEncryptionPart>();\n        \n        if (timestampEl != null) {\n            sigParts.add(new WSEncryptionPart(timestampEl.getId()));                          \n        }\n        \n        /*\n        if (tbinding.isTokenProtection() && tokenIncluded) {\n            sigParts.add(new WSEncryptionPart(secTok.getId()));\n        }\n        */\n        \n        if (signdParts != null) {\n            if (signdParts.isBody()) {\n                sigParts.add(new WSEncryptionPart(addWsuIdToElement(saaj.getSOAPBody())));\n            }\n    \n            for (Header header : signdParts.getHeaders()) {\n                WSEncryptionPart wep = new WSEncryptionPart(header.getName(), \n                        header.getNamespace(),\n                        \"Content\");\n                sigParts.add(wep);\n            }\n        }\n        \n        //check for derived keys\n        AlgorithmSuite algorithmSuite = tbinding.getAlgorithmSuite();\n        if (token.isDerivedKeys()) {\n            //Do Signature with derived keys\n            WSSecDKSign dkSign = new WSSecDKSign();\n          \n            //Setting the AttachedReference or the UnattachedReference according to the flag\n            Element ref;\n            if (tokenIncluded) {\n                ref = secTok.getAttachedReference();\n            } else {\n                ref = secTok.getUnattachedReference();\n            }\n          \n            if (ref != null) {\n                dkSign.setExternalKey(secTok.getSecret(), cloneElement(ref));\n            } else {\n                dkSign.setExternalKey(secTok.getSecret(), secTok.getId());\n            }\n          \n            //    Set the algo info\n            dkSign.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            dkSign.setDerivedKeyLength(algorithmSuite.getSignatureDerivedKeyLength() / 8);\n            if (token.getSPConstants() == SP12Constants.INSTANCE) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_12);\n            }\n            dkSign.prepare(doc, secHeader);\n          \n            addDerivedKeyElement(dkSign.getdktElement());\n          \n            dkSign.setParts(sigParts);\n            dkSign.addReferencesToSign(sigParts, secHeader);\n          \n            //Do signature\n            dkSign.computeSignature();\n          \n            dkSign.appendSigToHeader(secHeader);\n          \n            return dkSign.getSignatureValue();\n        } else {\n            WSSecSignature sig = new WSSecSignature();\n            sig.setCustomTokenId(secTok.getId());\n            if (secTok.getTokenType() == null) {\n                sig.setCustomTokenValueType(WSConstants.WSS_SAML_NS\n                                            + WSConstants.SAML_ASSERTION_ID);\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n            } else {\n                sig.setCustomTokenValueType(secTok.getTokenType());\n                sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING);\n            }\n            sig.setSecretKey(secTok.getSecret());\n            sig.setSignatureAlgorithm(algorithmSuite.getAsymmetricSignature());\n            sig.setSignatureAlgorithm(algorithmSuite.getSymmetricSignature());\n            sig.prepare(doc, getSignatureCrypto(wrapper), secHeader);\n\n            sig.setParts(sigParts);\n            sig.addReferencesToSign(sigParts, secHeader);\n\n            //Do signature\n            sig.computeSignature();\n\n            //Add elements to header\n            insertBeforeBottomUp(sig.getSignatureElement());\n\n            return sig.getSignatureValue();\n        }\n    }","commit_id":"172ef551ef356af4c62a9958cd5f0eb01cc5e4f2","url":"https://github.com/apache/cxf"},{"original_method":"public OntologyBrowser(boolean delayedLoading, DockWindow ontologyDock,DockWindow typeDock) \n    {\n        //super(new BorderLayout());\n        //super(new java.awt.GridLayout(0,1));\n        setName(\"Ontologies\");\n        \n        this.dockWindow = ontologyDock;\n        this.ontologyDock = ontologyDock;\n        this.typeDock = typeDock;\n        this.ontologiesPanel = this;\n        \n        if(delayedLoading)\n        {\n            //TBD see DRBrowser for likely path to take..\n        }\n        else\n        {\n            loadOntologyViewer();\n        }\n        \n        buildSingleDockWindow();\n        \n        //$\n          javax.swing.JButton button = new javax.swing.JButton(\"update\");\n          button.addActionListener(new java.awt.event.ActionListener(){\n            public void actionPerformed(java.awt.event.ActionEvent e)\n            {\n               java.util.List<edu.tufts.vue.ontology.Ontology> list = edu.tufts.vue.ontology.OntManager.getOntManager().getOntList();\n               /*for(int i=0;i<list.size();i++)\n               {\n                   \n               }*/\n               System.out.println(\"Ontology Browser: OntManager list size: \" + list.size());\n               System.out.println(\"Ontology Browser: ontology viewer model size: \" + ontologyViewer.getList().getModel().getSize());\n               ontologyViewer.updateUI();\n               ontologyViewer.getList().updateUI();\n               revalidate();\n               repaint();\n               ontologyViewer.repaint();\n               updateUI();\n            }\n          });\n          add(button);\n          \n          Action[] actions = {\n            new edu.tufts.vue.ontology.action.OntologyOpenAction(\"Add an Ontology\"),\n            new edu.tufts.vue.ontology.action.RDFSOntologyOpenAction(\"RDFS\"),\n            new edu.tufts.vue.ontology.action.OwlOntologyOpenAction(\"OWL\")\n          };\n          tufts.vue.gui.Widget.setMenuActions(this,actions);\n        //$\n          \n    }","id":87219,"modified_method":"public OntologyBrowser(boolean delayedLoading, DockWindow ontologyDock,DockWindow typeDock) \n    {\n        //super(new BorderLayout());\n        //super(new java.awt.GridLayout(0,1));\n        setName(\"Ontologies\");\n        \n        this.dockWindow = ontologyDock;\n        this.ontologyDock = ontologyDock;\n        this.typeDock = typeDock;\n        this.ontologiesPanel = this;\n        \n        if(delayedLoading)\n        {\n            //TBD see DRBrowser for likely path to take..\n        }\n        else\n        {\n            loadOntologyViewer();\n        }\n        \n        buildSingleDockWindow();\n        \n        //$\n          javax.swing.JButton button = new javax.swing.JButton(\"update\");\n          button.addActionListener(new java.awt.event.ActionListener(){\n            public void actionPerformed(java.awt.event.ActionEvent e)\n            {\n               java.util.List<edu.tufts.vue.ontology.Ontology> list = edu.tufts.vue.ontology.OntManager.getOntManager().getOntList();\n               /*for(int i=0;i<list.size();i++)\n               {\n                   \n               }*/\n               System.out.println(\"Ontology Browser: OntManager list size: \" + list.size());\n               System.out.println(\"Ontology Browser: ontology viewer model size: \" + ontologyViewer.getList().getModel().getSize());\n               ontologyViewer.updateUI();\n               ontologyViewer.getList().updateUI();\n               revalidate();\n               repaint();\n               ontologyViewer.repaint();\n               updateUI();\n            }\n          });\n          add(button);\n          \n          tufts.vue.VueAction addRDFSToBrowser = new tufts.vue.VueAction()\n          {\n              {\n                  setActionName(\"RDF in browser\");\n              }\n              \n              public void actionPerformed(java.awt.event.ActionEvent e)\n              {\n                 setName(\"Browser rdfs\");\n                 edu.tufts.vue.ontology.action.RDFSOntologyOpenAction rdfsooa = new edu.tufts.vue.ontology.action.RDFSOntologyOpenAction(\"Browser - RDFS\");\n                 rdfsooa.setViewer(ontologyViewer);\n                 rdfsooa.actionPerformed(e);\n                 rdfsooa.setViewer(null);\n              }\n          };\n          \n          tufts.vue.VueAction addOWLToBrowser = new tufts.vue.VueAction()\n          {\n              {\n                  setActionName(\"OWL in browser\");\n              }\n              \n              public void actionPerformed(java.awt.event.ActionEvent e)\n              {\n                 setName(\"Browser owl\");\n                 edu.tufts.vue.ontology.action.OwlOntologyOpenAction owlsooa = new edu.tufts.vue.ontology.action.OwlOntologyOpenAction(\"OWL - RDFS\");\n                 owlsooa.setViewer(ontologyViewer);\n                 owlsooa.actionPerformed(e);\n                 owlsooa.setViewer(null);\n              }\n          };\n          \n          Action[] actions = {\n            new edu.tufts.vue.ontology.action.OntologyOpenAction(\"Add an Ontology\"),\n            new edu.tufts.vue.ontology.action.RDFSOntologyOpenAction(\"RDFS\"),\n            new edu.tufts.vue.ontology.action.OwlOntologyOpenAction(\"OWL\"),\n            addRDFSToBrowser,\n            addOWLToBrowser\n          };\n          tufts.vue.gui.Widget.setMenuActions(this,actions);\n        //$\n          \n    }","commit_id":"911c9e286b041a8c90aa84b1e91a388af9150ff9","url":"https://github.com/VUE/VUE"},{"original_method":"public OntologyViewer(OntologyBrowser browser) \n    {\n        ontologyList = new OntologyList(this);\n        add(ontologyList);\n        \n        /*Action[] actions = {\n            new edu.tufts.vue.ontology.action.RDFSOntologyOpenAction(\"RDFS\"),\n            new edu.tufts.vue.ontology.action.OwlOntologyOpenAction(\"OWL\")\n        };\n        tufts.vue.gui.Widget.setMenuActions(browser,actions);*/\n    }","id":87220,"modified_method":"public OntologyViewer(OntologyBrowser browser) \n    {\n        ontologyBrowser = browser;\n        ontologyList = new OntologyList(this);\n        add(ontologyList);\n        \n        /*Action[] actions = {\n            new edu.tufts.vue.ontology.action.RDFSOntologyOpenAction(\"RDFS\"),\n            new edu.tufts.vue.ontology.action.OwlOntologyOpenAction(\"OWL\")\n        };\n        tufts.vue.gui.Widget.setMenuActions(browser,actions);*/\n    }","commit_id":"911c9e286b041a8c90aa84b1e91a388af9150ff9","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     *\n     * Use FileChoosers as first step until create windows to read file or \n     * url.\n     *\n     * DockWindows for seperate instances of the typelist panel seem to need to\n     * have unique names for now.\n     *\n     **/\n    public void actionPerformed(java.awt.event.ActionEvent e)\n    {\n        javax.swing.JFileChooser chooser = new javax.swing.JFileChooser();\n        javax.swing.JFileChooser styleChooser = new javax.swing.JFileChooser();\n        chooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File file = chooser.getSelectedFile();\n        styleChooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File styleFile = styleChooser.getSelectedFile();\n        System.out.println(\"OWLooa: file, stylefile: \" + file + \",\" + styleFile);\n        if(file!=null && styleFile!=null )\n        {\n          TypeList typeList = new TypeList();\n          try\n          {\n            java.net.URL fileURL = new java.net.URL(\"file:////\"+file.getAbsolutePath());\n            java.net.URL cssURL = new java.net.URL(\"file:////\" + styleFile.getAbsolutePath());\n              \n            System.out.println(\"owl open action: fileURL, cssURL: \" + fileURL + \",\" + cssURL);\n            \n            typeList.loadOntology(fileURL,\n                                  cssURL,\n                                  edu.tufts.vue.ontology.OntManager.OWL,true);\n          }\n          catch(Exception ex)\n          {\n              tufts.vue.VueUtil.alert(\"Couldn't load Ontology or Style\",\"Error\");\n              System.out.println(\"Exception in owl ontology load: \" + ex);\n          }\n          \n          javax.swing.JScrollPane scroll = new javax.swing.JScrollPane(typeList);\n          \n          tufts.vue.gui.DockWindow typeWindow = tufts.vue.gui.GUI.createDockWindow(chooser.getSelectedFile() + \": \" + (TypeList.count++),\n                                                scroll);\n          typeWindow.setLocation(200,100);\n          typeWindow.pack();\n          typeWindow.setVisible(true);\n        }\n    }","id":87221,"modified_method":"/**\n     *\n     * Use FileChoosers as first step until create windows to read file or \n     * url.\n     *\n     * DockWindows for seperate instances of the typelist panel seem to need to\n     * have unique names for now.\n     *\n     **/\n    public void actionPerformed(java.awt.event.ActionEvent e)\n    {\n        javax.swing.JFileChooser chooser = new javax.swing.JFileChooser();\n        javax.swing.JFileChooser styleChooser = new javax.swing.JFileChooser();\n        chooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File file = chooser.getSelectedFile();\n        styleChooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File styleFile = styleChooser.getSelectedFile();\n        System.out.println(\"OWLooa: file, stylefile: \" + file + \",\" + styleFile);\n        if(file!=null && styleFile!=null )\n        {\n          TypeList typeList = new TypeList();\n          try\n          {\n            java.net.URL fileURL = new java.net.URL(\"file:////\"+file.getAbsolutePath());\n            java.net.URL cssURL = new java.net.URL(\"file:////\" + styleFile.getAbsolutePath());\n              \n            System.out.println(\"owl open action: fileURL, cssURL: \" + fileURL + \",\" + cssURL);\n            \n            typeList.loadOntology(fileURL,\n                                  cssURL,\n                                  edu.tufts.vue.ontology.OntManager.OWL,true);\n          }\n          catch(Exception ex)\n          {\n              tufts.vue.VueUtil.alert(\"Couldn't load Ontology or Style\",\"Error\");\n              System.out.println(\"Exception in owl ontology load: \" + ex);\n          }\n          \n          javax.swing.JScrollPane scroll = new javax.swing.JScrollPane(typeList);\n          if(viewer==null)\n          {\n            tufts.vue.gui.DockWindow typeWindow = tufts.vue.gui.GUI.createDockWindow(chooser.getSelectedFile() + \": \" + (TypeList.count++),\n                                                scroll);\n            typeWindow.setLocation(200,100);\n            typeWindow.pack();\n            typeWindow.setVisible(true);\n          }\n          else\n          {\n              //viewer.add(typeList);\n              viewer.getBrowser().getPopulatePane().add(typeList);\n              viewer.revalidate();\n          }\n        }\n    }","commit_id":"911c9e286b041a8c90aa84b1e91a388af9150ff9","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     *\n     * Use FileChoosers as first step until create windows to read file or \n     * url.\n     *\n     * DockWindows for seperate instances of the typelist panel seem to need to\n     * have unique names for now.\n     *\n     **/\n    public void actionPerformed(java.awt.event.ActionEvent e)\n    {\n        javax.swing.JFileChooser chooser = new javax.swing.JFileChooser();\n        javax.swing.JFileChooser styleChooser = new javax.swing.JFileChooser();\n        chooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File file = chooser.getSelectedFile();\n        styleChooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File styleFile = styleChooser.getSelectedFile();\n        System.out.println(\"RDFSooa: file, stylefile: \" + file + \",\" + styleFile);\n        if(file!=null && styleFile!=null )\n        {\n          TypeList typeList = new TypeList();\n          try\n          {\n            java.net.URL fileURL = new java.net.URL(\"file:////\"+file.getAbsolutePath());\n            java.net.URL cssURL = new java.net.URL(\"file:////\" + styleFile.getAbsolutePath());\n              \n            System.out.println(\"RDFS open action: fileURL, cssURL: \" + fileURL + \",\" + cssURL);\n            \n            typeList.loadOntology(fileURL,\n                                  cssURL,\n                                  edu.tufts.vue.ontology.OntManager.RDFS,true);\n          }\n          catch(Exception ex)\n          {\n              tufts.vue.VueUtil.alert(\"Couldn't load Ontology or Style\",\"Error\");\n              System.out.println(\"Exception in rdfs ontology load: \" + ex);\n          }\n          tufts.vue.gui.DockWindow typeWindow = tufts.vue.gui.GUI.createDockWindow(chooser.getSelectedFile() + \": \" + (TypeList.count++),\n                                                typeList);\n          typeWindow.setLocation(200,100);\n          typeWindow.pack();\n          typeWindow.setVisible(true);\n        }\n    }","id":87222,"modified_method":"/**\n     *\n     * Use FileChoosers as first step until create windows to read file or \n     * url.\n     *\n     * DockWindows for seperate instances of the typelist panel seem to need to\n     * have unique names for now.\n     *\n     **/\n    public void actionPerformed(java.awt.event.ActionEvent e)\n    {\n        javax.swing.JFileChooser chooser = new javax.swing.JFileChooser();\n        javax.swing.JFileChooser styleChooser = new javax.swing.JFileChooser();\n        chooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File file = chooser.getSelectedFile();\n        styleChooser.showOpenDialog(tufts.vue.VUE.getActiveViewer());\n        java.io.File styleFile = styleChooser.getSelectedFile();\n        System.out.println(\"RDFSooa: file, stylefile: \" + file + \",\" + styleFile);\n        if(file!=null && styleFile!=null )\n        {\n          TypeList typeList = new TypeList();\n          try\n          {\n            java.net.URL fileURL = new java.net.URL(\"file:////\"+file.getAbsolutePath());\n            java.net.URL cssURL = new java.net.URL(\"file:////\" + styleFile.getAbsolutePath());\n              \n            System.out.println(\"RDFS open action: fileURL, cssURL: \" + fileURL + \",\" + cssURL);\n            \n            typeList.loadOntology(fileURL,\n                                  cssURL,\n                                  edu.tufts.vue.ontology.OntManager.RDFS,true);\n          }\n          catch(Exception ex)\n          {\n              tufts.vue.VueUtil.alert(\"Couldn't load Ontology or Style\",\"Error\");\n              System.out.println(\"Exception in rdfs ontology load: \" + ex);\n          }\n          if(viewer==null)\n          {    \n            tufts.vue.gui.DockWindow typeWindow = tufts.vue.gui.GUI.createDockWindow(chooser.getSelectedFile() + \": \" + (TypeList.count++),\n                                                typeList);\n            typeWindow.setLocation(200,100);\n            typeWindow.pack();\n            typeWindow.setVisible(true);\n          }\n          else\n          {\n              //viewer.getBrowser().getPopulatePane().addImpl(typeList,edu.tufts.vue.ontology.ui.OntologyBrowser.POPULATE_TYPES,edu.tufts.vue.ontology.OntManager.getOntManager().getOntList().size()+1);\n              \n              //System.out.println(\"rdfsooa: viewer: \" + viewer);\n              //System.out.println(\"rdfsooa: viewer.getBrowser() \" + viewer.getBrowser());\n              //System.out.println(\"rdfsooa: getPopulatePane() \" + viewer.getBrowser().getPopulatePane());\n              \n              viewer.getBrowser().getPopulatePane().add(typeList);\n              viewer.revalidate();\n              viewer.getBrowser().revalidate();\n          }\n        }\n    }","commit_id":"911c9e286b041a8c90aa84b1e91a388af9150ff9","url":"https://github.com/VUE/VUE"},{"original_method":"private void fillList(Ontology ontology)\n    {\n        List<OntType> types = ontology.getOntTypes();\n        \n        //System.out.println(\"TypeList: types size \" + types.size());\n        \n        \n        //$\n          int count = 0;\n        //$\n        \n        Iterator<OntType> iter = types.iterator();\n        while(iter.hasNext() && (count++) < 1000)\n        {\n            OntType ot = iter.next();\n            \n            System.out.println(\"TypeList: \" + ot.getComment());\n            System.out.println(\"tl: isNode: \" + ot.getId() + \" isNode?:\" + isNode(ot));\n            \n            Style style = ot.getStyle();\n            if(isNode(ot))\n            {\n                LWNode node = new LWNode(ot.getLabel());\n                  \n                //node.setLabel(ot.getLabel());\n\n                node.setAutoSized(false);\n                \n                node.setAbsoluteSize(25,25);\n                \n\n                NodeTool.SubTool st = NodeTool.getActiveSubTool();\n                node.setShape(st.getShape());\n                node.applyCSS(style);\n                addType(node);\n            }\n            else\n            {    \n              LWLink link = new LWLink();\n              link.setLabel(ot.getLabel() + \"-->\" + count);\n              link.setHeadPoint(10,25);\n              link.setTailPoint(40,25);\n              link.setAbsoluteSize(30,50);\n              //link.setArrowState(LWLink.ARROW_HEAD);\n              //link.setWeight(Integer.parseInt(style.getAttribute(\"weight\")));\n              link.applyCSS(style);\n              addType(link);\n            }\n        }\n        \n        if(ontology == fedoraOntology)\n        {\n          OntType fedoraObject = new OntType();  \n          Style style = new NodeStyle(\"fedora object\");\n          addNode(fedoraObject,ontology,style);\n        }\n        \n    }","id":87223,"modified_method":"private void fillList(Ontology ontology)\n    {\n        List<OntType> types = ontology.getOntTypes();\n        \n        //System.out.println(\"TypeList: types size \" + types.size());\n        \n        \n        //$\n          int count = 0;\n        //$\n        \n        Iterator<OntType> iter = types.iterator();\n        while(iter.hasNext() && (count++) < 1000)\n        {\n            OntType ot = iter.next();\n            \n            System.out.println(\"TypeList: \" + ot.getComment());\n            System.out.println(\"tl: isNode: \" + ot.getId() + \" isNode?:\" + isNode(ot));\n            \n            Style style = ot.getStyle();\n            if(isNode(ot))\n            {\n                addNode(ot,ontology,style);\n                \n                /*LWNode node = new LWNode(ot.getLabel());\n                  \n                //node.setLabel(ot.getLabel());\n\n                node.setAutoSized(false);\n                \n                node.setAbsoluteSize(25,25);\n                \n\n                NodeTool.SubTool st = NodeTool.getActiveSubTool();\n                node.setShape(st.getShape());\n                node.applyCSS(style);\n                addType(node);*/\n            }\n            else\n            {   \n              addLink(ot,ontology,style);  \n                \n              /*LWLink link = new LWLink();\n              link.setLabel(ot.getLabel() + \"-->\" + count);\n              link.setHeadPoint(10,25);\n              link.setTailPoint(40,25);\n              link.setAbsoluteSize(30,50);\n              //link.setArrowState(LWLink.ARROW_HEAD);\n              //link.setWeight(Integer.parseInt(style.getAttribute(\"weight\")));\n              link.applyCSS(style);\n              addType(link);*/\n            }\n        }\n        \n        if(ontology == fedoraOntology)\n        {\n          OntType fedoraObject = new OntType();  \n          Style style = new NodeStyle(\"fedora object\");\n          addNode(fedoraObject,ontology,style);\n        }\n        \n    }","commit_id":"911c9e286b041a8c90aa84b1e91a388af9150ff9","url":"https://github.com/VUE/VUE"},{"original_method":"private void addNode(OntType ontType,Ontology ontology,Style style)\n    {\n          if(ontology == fedoraOntology)\n          {\n            LWNode node = new LWNode(\"Fedora Object\");\n            node.setAbsoluteSize(25,50);\n            NodeTool.SubTool st = NodeTool.getActiveSubTool();\n            node.setShape(st.getShape());\n            addType(node);\n          }\n          else\n          {\n            LWNode node = new LWNode(ontType.getLabel());\n            //node.setLabel(ot.getLabel());\n                \n            node.setAbsoluteSize(25,50);\n            NodeTool.SubTool st = NodeTool.getActiveSubTool();\n            node.setShape(st.getShape());\n            node.applyCSS(style);\n            addType(node);\n          }\n          \n    }","id":87224,"modified_method":"private void addNode(OntType ontType,Ontology ontology,Style style)\n    {\n          if(ontology == fedoraOntology)\n          {\n            LWNode node = new LWNode(\"Fedora Object\");\n            node.setAbsoluteSize(25,50);\n            NodeTool.SubTool st = NodeTool.getActiveSubTool();\n            node.setShape(st.getShape());\n            addType(node);\n          }\n          else\n          {\n            /*LWNode node = new LWNode(ontType.getLabel());\n            //node.setLabel(ot.getLabel());\n                \n            node.setAbsoluteSize(25,50);\n            NodeTool.SubTool st = NodeTool.getActiveSubTool();\n            node.setShape(st.getShape());\n            node.applyCSS(style);\n            addType(node);*/\n              \n                LWNode node = new LWNode(ontType.getLabel());\n                  \n                //node.setLabel(ot.getLabel());\n\n                node.setAutoSized(false);\n                \n                node.setAbsoluteSize(25,25);\n                \n\n                NodeTool.SubTool st = NodeTool.getActiveSubTool();\n                node.setShape(st.getShape());\n                node.applyCSS(style);\n                addType(node);\n   \n          }\n          \n    }","commit_id":"911c9e286b041a8c90aa84b1e91a388af9150ff9","url":"https://github.com/VUE/VUE"},{"original_method":"private void addLink(OntType ontType,Ontology ontology, Style style)\n    {\n        \n    }","id":87225,"modified_method":"private void addLink(OntType ontType,Ontology ontology, Style style)\n    {\n        \n              LWLink link = new LWLink();\n              link.setLabel(ontType.getLabel() + \"-->\" + count);\n              link.setHeadPoint(10,25);\n              link.setTailPoint(40,25);\n              link.setAbsoluteSize(30,50);\n              //link.setArrowState(LWLink.ARROW_HEAD);\n              //link.setWeight(Integer.parseInt(style.getAttribute(\"weight\")));\n              link.applyCSS(style);\n              addType(link);\n        \n    }","commit_id":"911c9e286b041a8c90aa84b1e91a388af9150ff9","url":"https://github.com/VUE/VUE"},{"original_method":"private void setFunComponent(JComponent c) {\n    myDialog.myFunPanel.removeAll();\n    if (c != null) {\n      myDialog.myFunPanel.add(new JSeparator(), BorderLayout.NORTH);\n      myDialog.myFunPanel.add(c, BorderLayout.CENTER);\n    }\n\n    final Window wnd = SwingUtilities.windowForComponent(myDialog.myPanel);\n    wnd.pack();\n  }","id":87226,"modified_method":"private void setFunComponent(JComponent c) {\n    myDialog.myFunPanel.removeAll();\n    if (c != null) {\n      myDialog.myFunPanel.add(new JSeparator(), BorderLayout.NORTH);\n      myDialog.myFunPanel.add(c, BorderLayout.CENTER);\n    }\n\n    final Window wnd = SwingUtilities.windowForComponent(myDialog.myPanel);\n    if (wnd != null) { // Can be null if just hidden\n      wnd.pack();\n    }\n  }","commit_id":"a431ddd2d2b75c621ada3c08592dfa57f9fc751d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Loads the given error message in the current dialog, by re-validating the\n     * content.\n     *\n     * @param errorMessage The error message to load.\n     */\n    private void loadErrorMessage(String errorMessage)\n    {\n        JEditorPane errorMessagePane = new JEditorPane();\n        errorMessagePane.setOpaque(false);\n        errorMessagePane.setText(errorMessage);\n\n        errorMessagePane.setForeground(Color.RED);\n\n        accountPanel.add(errorMessagePane, BorderLayout.NORTH);\n        accountPanel.revalidate();\n        accountPanel.repaint();\n\n        this.pack();\n\n        //WORKAROUND: there's something wrong happening in this pack and\n        //components get cluttered, partially hiding the password text field.\n        //I am under the impression that this has something to do with the\n        //message pane preferred size being ignored (or being 0) which is why\n        //I am adding it's height to the dialog. It's quite ugly so please fix\n        //if you have something better in mind.\n        this.setSize(getWidth(), getHeight()+errorMessagePane.getHeight());\n    }","id":87227,"modified_method":"/**\n     * Loads the given error message in the current dialog, by re-validating the\n     * content.\n     *\n     * @param errorMessage The error message to load.\n     */\n    private void loadErrorMessage(String errorMessage)\n    {\n        if (errorMessagePane == null)\n        {\n            errorMessagePane = new JEditorPane();\n            errorMessagePane.setOpaque(false);\n            errorMessagePane.setForeground(Color.RED);\n\n            accountPanel.add(errorMessagePane, BorderLayout.NORTH);\n\n            if (isVisible())\n                pack();\n\n            //WORKAROUND: there's something wrong happening in this pack and\n            //components get cluttered, partially hiding the password text\n            // field. I am under the impression that this has something to do\n            // with the message pane preferred size being ignored (or being 0)\n            // which is why I am adding it's height to the dialog. It's quite\n            // ugly so please fix if you have something better in mind.\n            this.setSize(getWidth(), getHeight()+errorMessagePane.getHeight());\n        }\n\n        errorMessagePane.setText(errorMessage);\n\n        accountPanel.revalidate();\n        accountPanel.repaint();\n    }","commit_id":"42fffdfdfe8aec8c80e3f5fafcc9446093fedd80","url":"https://github.com/jitsi/jitsi"},{"original_method":"public ParameterInfoController(@NotNull Project project,\n                                 @NotNull Editor editor,\n                                 int lbraceOffset,\n                                 @NotNull LightweightHint hint,\n                                 @NotNull ParameterInfoHandler handler,\n                                 @NotNull ShowParameterInfoHandler.BestLocationPointProvider provider) {\n    myProject = project;\n    myEditor = editor;\n    myHandler = handler;\n    myProvider = provider;\n    myLbraceMarker = editor.getDocument().createRangeMarker(lbraceOffset, lbraceOffset);\n    myHint = hint;\n    myComponent = (ParameterInfoComponent)myHint.getComponent();\n\n    List<ParameterInfoController> allControllers = getAllControllers(myEditor);\n    allControllers.add(this);\n\n    myEditorCaretListener = new CaretAdapter(){\n      @Override\n      public void caretPositionChanged(CaretEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    };\n    myEditor.getCaretModel().addCaretListener(myEditorCaretListener);\n\n    myEditor.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    }, this);\n\n    PropertyChangeListener lookupListener = new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (LookupManager.PROP_ACTIVE_LOOKUP.equals(evt.getPropertyName())) {\n          final LookupImpl lookup = (LookupImpl)evt.getNewValue();\n          if (lookup != null && lookup.isShown()) {\n            adjustPositionForLookup(lookup);\n          }\n        }\n      }\n    };\n    LookupManager.getInstance(project).addPropertyChangeListener(lookupListener, this);\n\n    updateComponent();\n    if (myEditor instanceof EditorImpl) {\n      Disposer.register(((EditorImpl)myEditor).getDisposable(), this);\n    }\n  }","id":87228,"modified_method":"public ParameterInfoController(@NotNull Project project,\n                                 @NotNull Editor editor,\n                                 int lbraceOffset,\n                                 @NotNull LightweightHint hint,\n                                 @NotNull ParameterInfoHandler handler,\n                                 @NotNull ShowParameterInfoHandler.BestLocationPointProvider provider) {\n    myProject = project;\n    myEditor = editor;\n    myHandler = handler;\n    myProvider = provider;\n    myLbraceMarker = editor.getDocument().createRangeMarker(lbraceOffset, lbraceOffset);\n    myHint = hint;\n    myComponent = (ParameterInfoComponent)myHint.getComponent();\n\n    List<ParameterInfoController> allControllers = getAllControllers(myEditor);\n    allControllers.add(this);\n\n    myEditorCaretListener = new CaretAdapter(){\n      @Override\n      public void caretPositionChanged(CaretEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    };\n    myEditor.getCaretModel().addCaretListener(myEditorCaretListener);\n\n    myEditor.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        myAlarm.cancelAllRequests();\n        addAlarmRequest();\n      }\n    }, this);\n\n    PropertyChangeListener lookupListener = new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (LookupManager.PROP_ACTIVE_LOOKUP.equals(evt.getPropertyName())) {\n          Lookup lookup = (Lookup)evt.getNewValue();\n          if (lookup != null) {\n            adjustPositionForLookup(lookup);\n          }\n        }\n      }\n    };\n    LookupManager.getInstance(project).addPropertyChangeListener(lookupListener, this);\n\n    updateComponent();\n    if (myEditor instanceof EditorImpl) {\n      Disposer.register(((EditorImpl)myEditor).getDisposable(), this);\n    }\n  }","commit_id":"7e33cc8a8222c65128ce7ce73b73dfaafea5beca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateComponent(){\n    if (!myHint.isVisible()){\n      Disposer.dispose(this);\n      return;\n    }\n\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    final PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument());\n    CharSequence chars = myEditor.getDocument().getCharsSequence();\n    final int offset = CharArrayUtil.shiftBackward(chars, myEditor.getCaretModel().getOffset() - 1, \" \\t\") + 1;\n\n    final UpdateParameterInfoContext context = new MyUpdateParameterInfoContext(offset, file);\n    final Object elementForUpdating = myHandler.findElementForUpdatingParameterInfo(context);\n\n    if (elementForUpdating != null) {\n      myHandler.updateParameterInfo(elementForUpdating, context);\n      if (!myDisposed && myHint.isVisible() && myEditor.getComponent().getRootPane() != null) {\n        myComponent.update();\n        Pair<Point,Short> pos = myProvider.getBestPointPosition(myHint, (PsiElement)elementForUpdating, offset, true, HintManager.UNDER);\n        HintManagerImpl.adjustEditorHintPosition(myHint, myEditor, pos.getFirst(), pos.getSecond());\n      }\n    }\n    else {\n      context.removeHint();\n    }\n  }","id":87229,"modified_method":"private void updateComponent(){\n    if (!myHint.isVisible()){\n      Disposer.dispose(this);\n      return;\n    }\n\n    PsiDocumentManager.getInstance(myProject).commitAllDocuments();\n\n    final PsiFile file = PsiDocumentManager.getInstance(myProject).getPsiFile(myEditor.getDocument());\n    CharSequence chars = myEditor.getDocument().getCharsSequence();\n    final int offset = CharArrayUtil.shiftBackward(chars, myEditor.getCaretModel().getOffset() - 1, \" \\t\") + 1;\n\n    final UpdateParameterInfoContext context = new MyUpdateParameterInfoContext(offset, file);\n    final Object elementForUpdating = myHandler.findElementForUpdatingParameterInfo(context);\n\n    if (elementForUpdating != null) {\n      myHandler.updateParameterInfo(elementForUpdating, context);\n      if (!myDisposed && myHint.isVisible() && myEditor.getComponent().getRootPane() != null) {\n        myComponent.update();\n        IdeTooltip tooltip = myHint.getCurrentIdeTooltip();\n        short position = tooltip != null\n                         ? toShort(tooltip.getPreferredPosition())\n                         : HintManager.UNDER;\n        Pair<Point, Short> pos = myProvider.getBestPointPosition(myHint, (PsiElement)elementForUpdating, offset, true, position);\n        HintManagerImpl.adjustEditorHintPosition(myHint, myEditor, pos.getFirst(), pos.getSecond());\n      }\n    }\n    else {\n      context.removeHint();\n    }\n  }","commit_id":"7e33cc8a8222c65128ce7ce73b73dfaafea5beca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void adjustPositionForLookup(@NotNull Lookup lookup) {\n    if (!myHint.isVisible() || myEditor.isDisposed()) {\n      Disposer.dispose(this);\n      return;\n    }\n\n    HintManagerImpl hintManager = HintManagerImpl.getInstanceImpl();\n    short constraint = lookup.isPositionedAboveCaret() ? HintManager.UNDER : HintManager.ABOVE;\n    Point p = hintManager.getHintPosition(myHint, myEditor, constraint);\n    //Dimension hintSize = myHint.getComponent().getPreferredSize();\n    //JLayeredPane layeredPane = myEditor.getComponent().getRootPane().getLayeredPane();\n    //p.x = Math.min(p.x, layeredPane.getWidth() - hintSize.width);\n    //p.x = Math.max(p.x, 0);\n    myHint.pack();\n    myHint.updateLocation(p.x, p.y);\n  }","id":87230,"modified_method":"private void adjustPositionForLookup(@NotNull Lookup lookup) {\n    if (!myHint.isVisible() || myEditor.isDisposed()) {\n      Disposer.dispose(this);\n      return;\n    }\n\n    IdeTooltip tooltip = myHint.getCurrentIdeTooltip();\n    if (tooltip != null) {\n      JRootPane root = myEditor.getComponent().getRootPane();\n      if (root != null) {\n        Point p = tooltip.getShowingPoint().getPoint(root.getLayeredPane());\n        if (lookup.isPositionedAboveCaret()) {\n          if (Position.above == tooltip.getPreferredPosition()) {\n            myHint.pack();\n            myHint.updatePosition(Position.below);\n            myHint.updateLocation(p.x, p.y + tooltip.getPositionChangeY());\n          }\n        }\n        else {\n          if (Position.below == tooltip.getPreferredPosition()) {\n            myHint.pack();\n            myHint.updatePosition(Position.above);\n            myHint.updateLocation(p.x, p.y - tooltip.getPositionChangeY());\n          }\n        }\n      }\n    }\n  }","commit_id":"7e33cc8a8222c65128ce7ce73b73dfaafea5beca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void close(ServerSocket socket) throws IOException {\n        final SocketBindingManager.UnnamedBindingRegistry registry = this.manager.getUnnamedRegistry();\n        registry.unregisterSocket(socket);\n        this.factory.close(socket);\n    }","id":87231,"modified_method":"@Override\n    public void close(ServerSocket socket) throws IOException {\n        if (socket != null) {\n            this.manager.getUnnamedRegistry().unregisterSocket(socket);\n            this.factory.close(socket);\n        }\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MulticastSocket register(final MulticastSocket socket) {\n        final SocketBindingManager.UnnamedBindingRegistry registry = this.manager.getUnnamedRegistry();\n        registry.registerSocket(socket);\n        return socket;\n    }","id":87232,"modified_method":"private MulticastSocket register(final MulticastSocket socket) {\n        this.manager.getUnnamedRegistry().registerSocket(socket);\n        return socket;\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void close(DatagramSocket socket) {\n        final SocketBindingManager.UnnamedBindingRegistry registry = this.manager.getUnnamedRegistry();\n        registry.unregisterSocket(socket);\n        this.factory.close(socket);\n    }","id":87233,"modified_method":"@Override\n    public void close(DatagramSocket socket) {\n        if (socket != null) {\n            this.manager.getUnnamedRegistry().unregisterSocket(socket);\n            this.factory.close(socket);\n        }\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ServerSocket register(final ServerSocket socket) {\n        final SocketBindingManager.UnnamedBindingRegistry registry = this.manager.getUnnamedRegistry();\n        registry.registerSocket(socket);\n        return socket;\n    }","id":87234,"modified_method":"private ServerSocket register(final ServerSocket socket) {\n        this.manager.getUnnamedRegistry().registerSocket(socket);\n        return socket;\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void close(Socket socket) throws IOException {\n        final SocketBindingManager.UnnamedBindingRegistry registry = this.manager.getUnnamedRegistry();\n        registry.unregisterSocket(socket);\n        this.factory.close(socket);\n    }","id":87235,"modified_method":"@Override\n    public void close(Socket socket) throws IOException {\n        if (socket != null) {\n            this.manager.getUnnamedRegistry().unregisterSocket(socket);\n            this.factory.close(socket);\n        }\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Socket register(final Socket socket) {\n        final SocketBindingManager.UnnamedBindingRegistry registry = this.manager.getUnnamedRegistry();\n        registry.registerSocket(socket);\n        return socket;\n    }","id":87236,"modified_method":"private Socket register(final Socket socket) {\n        this.manager.getUnnamedRegistry().registerSocket(socket);\n        return socket;\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"private DatagramSocket register(final DatagramSocket socket) {\n        SocketBindingManager.UnnamedBindingRegistry registry = this.manager.getUnnamedRegistry();\n        registry.registerSocket(socket);\n        return socket;\n    }","id":87237,"modified_method":"private DatagramSocket register(final DatagramSocket socket) {\n        this.manager.getUnnamedRegistry().registerSocket(socket);\n        return socket;\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static <T> boolean wait(ServiceController<T> controller, Collection<ServiceController.State> expectedStates, ServiceController.State targetState) {\n        if (controller.getState() == targetState) return true;\n        ServiceListener<T> listener = new NotifyingServiceListener<T>();\n        controller.addListener(listener);\n        try {\n            synchronized (controller) {\n                while (expectedStates.contains(controller.getState())) {\n                    controller.wait();\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        controller.removeListener(listener);\n        return controller.getState() == targetState;\n    }","id":87238,"modified_method":"private static <T> boolean wait(ServiceController<T> controller, Collection<ServiceController.State> expectedStates, ServiceController.State targetState) {\n        if (controller.getState() == targetState) return true;\n        ServiceListener<T> listener = new NotifyingServiceListener<T>(controller);\n        controller.addListener(listener);\n        try {\n            synchronized (controller) {\n                ServiceController.State state = controller.getState();\n                while (expectedStates.contains(state)) {\n                    log.tracef(\"Waiting for %s transition from %s to %s, unavailable dependencies: %s\", controller.getName(), state, targetState, controller.getImmediateUnavailableDependencies());\n                    controller.wait();\n                    state = controller.getState();\n                    log.tracef(\"%s state is now %s\", controller.getName(), state);\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        controller.removeListener(listener);\n        return controller.getState() == targetState;\n    }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void transition(ServiceController<? extends T> controller, Transition transition) {\n            synchronized (controller) {\n                controller.notify();\n            }\n        }","id":87239,"modified_method":"@Override\n        public void transition(ServiceController<? extends T> controller, Transition transition) {\n            log.tracef(\"%s transitioned from %s\", controller.getName(), transition);\n            synchronized (this.controller) {\n                this.controller.notify();\n            }\n        }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            PathAddress stackAddress = PathAddress.pathAddress(operation.get(OP_ADDR));\n            String stackName = stackAddress.getLastElement().getValue();\n\n            ServiceName serviceName = ChannelFactoryService.getServiceName(stackName);\n            Channel channel = null;\n            try {\n                ServiceController<?> controller = context.getServiceRegistry(false).getRequiredService(serviceName);\n                ChannelFactory factory = ServiceContainerHelper.getValue(controller, ChannelFactory.class);\n                // Create a temporary channel, but don't connect it\n                channel = factory.createChannel(UUID.randomUUID().toString());\n                // ProtocolStack.printProtocolSpecAsXML() is very hacky and only works on an uninitialized stack\n                List<Protocol> protocols = channel.getProtocolStack().getProtocols();\n                Collections.reverse(protocols);\n                ProtocolStack stack = new ProtocolStack();\n                stack.addProtocols(protocols);\n                context.getResult().set(stack.printProtocolSpecAsXML());\n                context.completeStep();\n            } catch (Exception e) {\n                throw new OperationFailedException(e.getLocalizedMessage(), e);\n            } finally {\n                if (channel != null) {\n                    channel.close();\n                }\n            }\n        }","id":87240,"modified_method":"@Override\n        protected void executeRuntimeStep(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n            PathAddress stackAddress = PathAddress.pathAddress(operation.get(OP_ADDR));\n            String stackName = stackAddress.getLastElement().getValue();\n\n            ServiceRegistry registry = context.getServiceRegistry(false);\n            ServiceName serviceName = ChannelFactoryService.getServiceName(stackName);\n            try {\n                ServiceController<?> controller = registry.getRequiredService(serviceName);\n                controller.setMode(ServiceController.Mode.ACTIVE);\n                try {\n                    ChannelFactory factory = ServiceContainerHelper.getValue(controller, ChannelFactory.class);\n                    // Create a temporary channel, but don't connect it\n                    Channel channel = factory.createChannel(UUID.randomUUID().toString());\n                    try {\n                        // ProtocolStack.printProtocolSpecAsXML() is very hacky and only works on an uninitialized stack\n                        List<Protocol> protocols = channel.getProtocolStack().getProtocols();\n                        Collections.reverse(protocols);\n                        ProtocolStack stack = new ProtocolStack();\n                        stack.addProtocols(protocols);\n                        context.getResult().set(stack.printProtocolSpecAsXML());\n                        context.completeStep();\n                    } finally {\n                        channel.close();\n                    }\n                } finally {\n                    controller.setMode(ServiceController.Mode.ON_DEMAND);\n                }\n            } catch (Exception e) {\n                throw new OperationFailedException(e.getLocalizedMessage(), e);\n            }\n        }","commit_id":"d218ab3cdd086501d5d4bf585971b9358d303a60","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected IPortalRequestInfo parseLegacyPortalUrl(HttpServletRequest request, Map<String, String[]> parameterMap) {\n        final PortalRequestInfoImpl portalRequestInfo = new PortalRequestInfoImpl();\n        \n        final String[] fname = parameterMap.remove(LEGACY_PARAM_PORTLET_FNAME);\n        if (fname != null && fname.length > 0) {\n            final IPortletWindow portletWindow = this.portletWindowRegistry.getOrCreateDefaultPortletWindowByFname(request, fname[0]);\n            if (portletWindow != null) {\n                logger.debug(\"Legacy fname parameter {} resolved to {}\", fname[0], portletWindow);\n                \n                final IPortletWindowId portletWindowId = portletWindow.getPortletWindowId();\n                portalRequestInfo.setTargetedPortletWindowId(portletWindowId);\n\n                final PortletRequestInfoImpl portletRequestInfo = portalRequestInfo.getPortletRequestInfo(portletWindowId);\n                \n                //Check the portlet request type\n                final String[] type = parameterMap.remove(LEGACY_PARAM_PORTLET_REQUEST_TYPE);\n                if (type != null && type.length > 0 && \"ACTION\".equals(type[0])) {\n                    portalRequestInfo.setUrlType(UrlType.ACTION);\n                }\n                \n                //Set the window state\n                final String[] state = parameterMap.remove(LEGACY_PARAM_PORTLET_STATE);\n                if (state != null && state.length > 0) {\n                    final WindowState windowState = PortletUtils.getWindowState(state[0]);\n                    portletRequestInfo.setWindowState(windowState);\n                }\n                \n                //Set the portlet mode\n                final String[] mode = parameterMap.remove(LEGACY_PARAM_PORTLET_MODE);\n                if (mode != null && mode.length > 0) {\n                    final PortletMode portletMode = PortletUtils.getPortletMode(mode[0]);\n                    portletRequestInfo.setPortletMode(portletMode);\n                }\n                \n                //Set the parameters\n                final Map<String, List<String>> portletParameters = portletRequestInfo.getPortletParameters();\n                for (final Map.Entry<String, String[]> parameterEntry : parameterMap.entrySet()) {\n                    final String prefixedName = parameterEntry.getKey();\n                    \n                    //If the parameter starts with the portlet param prefix\n                    if (prefixedName.startsWith(LEGACY_PARAM_PORTLET_PARAM_PREFX)) {\n                        final String name = prefixedName.substring(LEGACY_PARAM_PORTLET_PARAM_PREFX.length()); \n                        \n                        portletParameters.put(name, Arrays.asList(parameterEntry.getValue()));\n                    }\n                }\n                \n                //Set the url state based on the window state\n                final UrlState urlState = this.determineUrlState(portletWindow, portletRequestInfo.getWindowState());\n                portalRequestInfo.setUrlState(urlState);\n            }\n            else {\n                logger.debug(\"Could not find portlet for legacy fname fname parameter {}\", fname[0]);\n            }\n        }\n        \n        //Check root=uP_root\n        final String[] root = parameterMap.remove(LEGACY_PARAM_LAYOUT_ROOT);\n        if (root != null && root.length > 0) {\n            if (LEGACY_PARAM_LAYOUT_ROOT_VALUE.equals(root[0])) {\n                \n                //Check uP_sparam=activeTab\n                final String[] structParam = parameterMap.remove(LEGACY_PARAM_LAYOUT_STRUCT_PARAM);\n                if (structParam != null && structParam.length > 0) {\n                    if (LEGACY_PARAM_LAYOUT_TAB_ID.equals(structParam[0])) {\n                        \n                        //Get the active tab id\n                        final String[] activeTabId = parameterMap.remove(LEGACY_PARAM_LAYOUT_TAB_ID);\n                        if (activeTabId != null && activeTabId.length > 0) {\n                            //Get the user's layout and do xpath for tab at index=activeTabId[0]\n                            final IUserInstance userInstance = this.userInstanceManager.getUserInstance(request);\n                            final IUserPreferencesManager preferencesManager = userInstance.getPreferencesManager();\n                            final IUserLayoutManager userLayoutManager = preferencesManager.getUserLayoutManager();\n                            final IUserLayout userLayout = userLayoutManager.getUserLayout();\n                            \n                            final String nodeId = this.xpathOperations.doWithExpression(\n                                    \"/layout/folder/folder[@type='regular' and @hidden='false'][position() = $activeTabId]/@ID\", \n                                    Collections.singletonMap(\"activeTabId\", activeTabId[0]), \n                                    new Function<XPathExpression, String>() {\n                                        @Override\n                                        public String apply(XPathExpression xPathExpression) {\n                                            return userLayout.findNodeId(xPathExpression);\n                                        }\n                                    });\n\n                            //Found nodeId for activeTabId\n                            if (nodeId != null) {\n                                logger.debug(\"Found layout node {} for legacy activeTabId parameter {}\", nodeId, activeTabId[0]);\n                                portalRequestInfo.setTargetedLayoutNodeId(nodeId);\n                            }\n                            else {\n                                logger.debug(\"No layoout node found for legacy activeTabId parameter {}\", activeTabId[0]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        \n        return portalRequestInfo;\n    }","id":87241,"modified_method":"protected IPortalRequestInfo parseLegacyPortalUrl(HttpServletRequest request, Map<String, String[]> parameterMap) {\n        final PortalRequestInfoImpl portalRequestInfo = new PortalRequestInfoImpl();\n        \n        final String[] fname = parameterMap.remove(LEGACY_PARAM_PORTLET_FNAME);\n        if (fname != null && fname.length > 0) {\n            final IPortletWindow portletWindow = this.portletWindowRegistry.getOrCreateDefaultPortletWindowByFname(request, fname[0]);\n            if (portletWindow != null) {\n                logger.debug(\"Legacy fname parameter {} resolved to {}\", fname[0], portletWindow);\n                \n                final IPortletWindowId portletWindowId = portletWindow.getPortletWindowId();\n                portalRequestInfo.setTargetedPortletWindowId(portletWindowId);\n\n                final PortletRequestInfoImpl portletRequestInfo = portalRequestInfo.getPortletRequestInfo(portletWindowId);\n                \n                //Check the portlet request type\n                final String[] type = parameterMap.remove(LEGACY_PARAM_PORTLET_REQUEST_TYPE);\n                if (type != null && type.length > 0 && \"ACTION\".equals(type[0])) {\n                    portalRequestInfo.setUrlType(UrlType.ACTION);\n                }\n                \n                //Set the window state\n                final String[] state = parameterMap.remove(LEGACY_PARAM_PORTLET_STATE);\n                if (state != null && state.length > 0) {\n                    final WindowState windowState = PortletUtils.getWindowState(state[0]);\n\n                    //If this isn't an action request only allow PATH communicated WindowStates as none of the other options make sense \n                    if (portalRequestInfo.getUrlType() == UrlType.ACTION || PATH_WINDOW_STATES.contains(windowState)) {\n                        portletRequestInfo.setWindowState(windowState);\n                    }\n                }\n                \n                //If no window state was set assume MAXIMIZED\n                if (portletRequestInfo.getWindowState() == null) {\n                    portletRequestInfo.setWindowState(WindowState.MAXIMIZED);\n                }\n                \n                //Set the portlet mode\n                final String[] mode = parameterMap.remove(LEGACY_PARAM_PORTLET_MODE);\n                if (mode != null && mode.length > 0) {\n                    final PortletMode portletMode = PortletUtils.getPortletMode(mode[0]);\n                    portletRequestInfo.setPortletMode(portletMode);\n                }\n                \n                //Set the parameters\n                final Map<String, List<String>> portletParameters = portletRequestInfo.getPortletParameters();\n                for (final Map.Entry<String, String[]> parameterEntry : parameterMap.entrySet()) {\n                    final String prefixedName = parameterEntry.getKey();\n                    \n                    //If the parameter starts with the portlet param prefix\n                    if (prefixedName.startsWith(LEGACY_PARAM_PORTLET_PARAM_PREFX)) {\n                        final String name = prefixedName.substring(LEGACY_PARAM_PORTLET_PARAM_PREFX.length()); \n                        \n                        portletParameters.put(name, Arrays.asList(parameterEntry.getValue()));\n                    }\n                }\n                \n                //Set the url state based on the window state\n                final UrlState urlState = this.determineUrlState(portletWindow, portletRequestInfo.getWindowState());\n                portalRequestInfo.setUrlState(urlState);\n            }\n            else {\n                logger.debug(\"Could not find portlet for legacy fname fname parameter {}\", fname[0]);\n            }\n        }\n        \n        //Check root=uP_root\n        final String[] root = parameterMap.remove(LEGACY_PARAM_LAYOUT_ROOT);\n        if (root != null && root.length > 0) {\n            if (LEGACY_PARAM_LAYOUT_ROOT_VALUE.equals(root[0])) {\n                \n                //Check uP_sparam=activeTab\n                final String[] structParam = parameterMap.remove(LEGACY_PARAM_LAYOUT_STRUCT_PARAM);\n                if (structParam != null && structParam.length > 0) {\n                    if (LEGACY_PARAM_LAYOUT_TAB_ID.equals(structParam[0])) {\n                        \n                        //Get the active tab id\n                        final String[] activeTabId = parameterMap.remove(LEGACY_PARAM_LAYOUT_TAB_ID);\n                        if (activeTabId != null && activeTabId.length > 0) {\n                            //Get the user's layout and do xpath for tab at index=activeTabId[0]\n                            final IUserInstance userInstance = this.userInstanceManager.getUserInstance(request);\n                            final IUserPreferencesManager preferencesManager = userInstance.getPreferencesManager();\n                            final IUserLayoutManager userLayoutManager = preferencesManager.getUserLayoutManager();\n                            final IUserLayout userLayout = userLayoutManager.getUserLayout();\n                            \n                            final String nodeId = this.xpathOperations.doWithExpression(\n                                    \"/layout/folder/folder[@type='regular' and @hidden='false'][position() = $activeTabId]/@ID\", \n                                    Collections.singletonMap(\"activeTabId\", activeTabId[0]), \n                                    new Function<XPathExpression, String>() {\n                                        @Override\n                                        public String apply(XPathExpression xPathExpression) {\n                                            return userLayout.findNodeId(xPathExpression);\n                                        }\n                                    });\n\n                            //Found nodeId for activeTabId\n                            if (nodeId != null) {\n                                logger.debug(\"Found layout node {} for legacy activeTabId parameter {}\", nodeId, activeTabId[0]);\n                                portalRequestInfo.setTargetedLayoutNodeId(nodeId);\n                            }\n                            else {\n                                logger.debug(\"No layoout node found for legacy activeTabId parameter {}\", activeTabId[0]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        \n        return portalRequestInfo;\n    }","commit_id":"c6bcab0b34e9b3797d3583757ec812b062529e1e","url":"https://github.com/Jasig/uPortal"},{"original_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tString callback = ParamUtil.getString(req, \"callback\");\n\t\tString instance = ParamUtil.getString(req, \"inst\");\n\n\t\tString json = null;\n\t\tString ajaxId = req.getHeader(\"Ajax-ID\");\n\n\t\ttry {\n\t\t\tjson = getJSON(mapping, form, req, res);\n\n\t\t\tif (Validator.isNotNull(callback)) {\n\t\t\t\tjson = callback + \"(\" + json + \");\";\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(instance)) {\n\t\t\t\tjson = \"var \" + instance + \"=\" + json + \";\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tres.sendError(\n\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (Validator.isNotNull(json)) {\n\t\t\tres.setContentType(Constants.TEXT_JAVASCRIPT);\n\t\t\tres.setHeader(HttpHeaders.CACHE_CONTROL, \"no-cache\");\n\n\t\t\tif (ajaxId != null && !ajaxId.equals(\"\")) {\n\t\t\t\tres.setHeader(\"Ajax-ID\", ajaxId);\n\t\t\t}\n\n\t\t\tPrintWriter pw = res.getWriter();\n\n\t\t\tpw.write(json);\n\n\t\t\tpw.close();\n\t\t}\n\n\t\treturn null;\n\t}","id":87242,"modified_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tString ajaxId = req.getHeader(\"Ajax-ID\");\n\n\t\tString callback = ParamUtil.getString(req, \"callback\");\n\t\tString instance = ParamUtil.getString(req, \"inst\");\n\n\t\tString json = null;\n\n\t\ttry {\n\t\t\tjson = getJSON(mapping, form, req, res);\n\n\t\t\tif (Validator.isNotNull(callback)) {\n\t\t\t\tjson = callback + \"(\" + json + \");\";\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(instance)) {\n\t\t\t\tjson = \"var \" + instance + \"=\" + json + \";\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tres.sendError(\n\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (Validator.isNotNull(json)) {\n\t\t\tres.setContentType(Constants.TEXT_JAVASCRIPT);\n\t\t\tres.setHeader(HttpHeaders.CACHE_CONTROL, \"no-cache\");\n\n\t\t\tif (ajaxId != null && !ajaxId.equals(\"\")) {\n\t\t\t\tres.setHeader(\"Ajax-ID\", ajaxId);\n\t\t\t}\n\n\t\t\tPrintWriter pw = res.getWriter();\n\n\t\t\tpw.write(json);\n\n\t\t\tpw.close();\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"9d17f3582a9e6648479066a297ff51d53ae958d0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void doEndTag(\n\t\t\tPageContext pageContext, String redirect, String modelResource,\n\t\t\tString modelResourceDescription, String resourcePrimKey, String var)\n\t\tthrows JspException {\n\n\t\ttry {\n\t\t\tHttpServletRequest req =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tif (Validator.isNull(redirect)) {\n\t\t\t\tRenderRequest renderRequest =\n\t\t\t\t\t(RenderRequest)req.getAttribute(\n\t\t\t\t\t\tWebKeys.JAVAX_PORTLET_REQUEST);\n\n\t\t\t\tRenderResponse renderResponse =\n\t\t\t\t\t(RenderResponse)req.getAttribute(\n\t\t\t\t\t\tWebKeys.JAVAX_PORTLET_RESPONSE);\n\n\t\t\t\tredirect = PortletURLUtil.getCurrent(\n\t\t\t\t\trenderRequest, renderResponse).toString();\n\t\t\t}\n\n\t\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\t\treq, PortletKeys.PORTLET_CONFIGURATION, layout.getPlid(),\n\t\t\t\tfalse);\n\n\t\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/portlet_configuration/edit_permissions\");\n\t\t\tportletURL.setParameter(\"redirect\", redirect);\n\t\t\tportletURL.setParameter(\"portletResource\", portletDisplay.getId());\n\t\t\tportletURL.setParameter(\"modelResource\", modelResource);\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"modelResourceDescription\", modelResourceDescription);\n\t\t\tportletURL.setParameter(\"resourcePrimKey\", resourcePrimKey);\n\n\t\t\tString portletURLToString = portletURL.toString();\n\n\t\t\tif (Validator.isNotNull(var)) {\n\t\t\t\tpageContext.setAttribute(var, portletURLToString);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpageContext.getOut().print(portletURLToString);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t}","id":87243,"modified_method":"public static void doEndTag(\n\t\t\tPageContext pageContext, String redirect, String modelResource,\n\t\t\tString modelResourceDescription, String resourcePrimKey, String var)\n\t\tthrows JspException {\n\n\t\ttry {\n\t\t\tHttpServletRequest req =\n\t\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tRenderRequest renderRequest =\n\t\t\t\t(RenderRequest)req.getAttribute(WebKeys.JAVAX_PORTLET_REQUEST);\n\n\t\t\tRenderResponse renderResponse =\n\t\t\t\t(RenderResponse)req.getAttribute(\n\t\t\t\t\tWebKeys.JAVAX_PORTLET_RESPONSE);\n\n\t\t\tif (Validator.isNull(redirect)) {\n\t\t\t\tredirect = PortletURLUtil.getCurrent(\n\t\t\t\t\trenderRequest, renderResponse).toString();\n\t\t\t}\n\n\t\t\tPortletURL portletURL = new PortletURLImpl(\n\t\t\t\treq, PortletKeys.PORTLET_CONFIGURATION, layout.getPlid(),\n\t\t\t\tfalse);\n\n\t\t\tif (themeDisplay.isStatePopUp()) {\n\t\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tportletURL.setWindowState(WindowState.MAXIMIZED);\n\t\t\t}\n\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/portlet_configuration/edit_permissions\");\n\t\t\tportletURL.setParameter(\"redirect\", redirect);\n\t\t\tportletURL.setParameter(\"portletResource\", portletDisplay.getId());\n\t\t\tportletURL.setParameter(\"modelResource\", modelResource);\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"modelResourceDescription\", modelResourceDescription);\n\t\t\tportletURL.setParameter(\"resourcePrimKey\", resourcePrimKey);\n\n\t\t\tString portletURLToString = portletURL.toString();\n\n\t\t\tif (Validator.isNotNull(var)) {\n\t\t\t\tpageContext.setAttribute(var, portletURLToString);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpageContext.getOut().print(portletURLToString);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new JspException(e);\n\t\t}\n\t}","commit_id":"9d17f3582a9e6648479066a297ff51d53ae958d0","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n    public boolean appConnect(IConnection conn, Object[] params) {\r\n    \tString userid = ((String) params[0]).toString();\r\n        String username = ((String) params[1]).toString();\r\n        String clientId = Red5.getConnectionLocal().getClient().getId();\r\n        String remoteHost = Red5.getConnectionLocal().getRemoteAddress();\r\n        int remotePort = Red5.getConnectionLocal().getRemotePort();\r\n        \r\n        if ((userid == null) || (\"\".equals(userid))) userid = \"unknown-userid\";\r\n        if ((username == null) || (\"\".equals(username))) username = \"UNKNOWN-CALLER\";\r\n        Red5.getConnectionLocal().setAttribute(\"USERID\", userid);\r\n        Red5.getConnectionLocal().setAttribute(\"USERNAME\", username);\r\n        \r\n        log.info(\"{} [clientid={}] has connected to the voice conf app.\", username + \"[uid=\" + userid + \"]\", clientId);\r\n        log.info(\"[clientid={}] connected from {}.\", clientId, remoteHost + \":\" + remotePort);\r\n        \r\n        clientConnManager.createClient(clientId, userid, username, (IServiceCapableConnection) Red5.getConnectionLocal());\r\n        return super.appConnect(conn, params);\r\n    }","id":87244,"modified_method":"@Override\r\n    public boolean appConnect(IConnection conn, Object[] params) {\r\n    \tString meetingId = ((String) params[0]).toString();\r\n    \tString userId = ((String) params[1]).toString();\r\n      String username = ((String) params[2]).toString();\r\n      String clientId = Red5.getConnectionLocal().getClient().getId();\r\n      String remoteHost = Red5.getConnectionLocal().getRemoteAddress();\r\n      int remotePort = Red5.getConnectionLocal().getRemotePort();\r\n        \r\n      if ((userId == null) || (\"\".equals(userId))) userId = \"unknown-userid\";\r\n      if ((username == null) || (\"\".equals(username))) username = \"UNKNOWN-CALLER\";\r\n      Red5.getConnectionLocal().setAttribute(\"MEETING_ID\", meetingId);\r\n      Red5.getConnectionLocal().setAttribute(\"USERID\", userId);\r\n      Red5.getConnectionLocal().setAttribute(\"USERNAME\", username);\r\n        \r\n      log.info(\"{} [clientid={}] has connected to the voice conf app.\", username + \"[uid=\" + userId + \"]\", clientId);\r\n      log.info(\"[clientid={}] connected from {}.\", clientId, remoteHost + \":\" + remotePort);\r\n      \r\n  \t\tString connType = getConnectionType(Red5.getConnectionLocal().getType());\r\n  \t\tString userFullname = username;\r\n  \t\tString connId = Red5.getConnectionLocal().getSessionId();\r\n  \t\t\r\n  \t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n  \t\tlogData.put(\"meetingId\", meetingId);\r\n  \t\tlogData.put(\"connType\", connType);\r\n  \t\tlogData.put(\"connId\", connId);\r\n  \t\tlogData.put(\"userId\", userId);\r\n  \t\tlogData.put(\"username\", userFullname);\r\n  \t\tlogData.put(\"event\", \"user_joining_bbb_voice\");\r\n  \t\tlogData.put(\"description\", \"User joining BBB Voice.\");\r\n  \t\t\r\n  \t\tGson gson = new Gson();\r\n      String logStr =  gson.toJson(logData);\r\n  \t\t\r\n  \t\tlog.info(\"User joining bbb-voice: data={}\", logStr);\r\n      \r\n      clientConnManager.createClient(clientId, userId, username, (IServiceCapableConnection) Red5.getConnectionLocal());\r\n      return super.appConnect(conn, params);\r\n    }","commit_id":"000ddbd9d7545a3132b76db7fa4186f5b65137dc","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n    public void appDisconnect(IConnection conn) {\r\n    \tString clientId = Red5.getConnectionLocal().getClient().getId();\r\n    \tString userid = getUserId();\r\n    \tString username = getUsername();\r\n    \t\r\n        String remoteHost = Red5.getConnectionLocal().getRemoteAddress();\r\n        int remotePort = Red5.getConnectionLocal().getRemotePort();    \t\r\n    \tlog.info(\"[clientid={}] disconnnected from {}.\", clientId, remoteHost + \":\" + remotePort);\r\n        log.debug(\"{} [clientid={}] is leaving the voice conf app. Removing from ConnectionManager.\", username + \"[uid=\" + userid + \"]\", clientId);\r\n    \t\r\n        clientConnManager.removeClient(clientId);\r\n\r\n        String peerId = (String) Red5.getConnectionLocal().getAttribute(\"VOICE_CONF_PEER\");\r\n        if (peerId != null) {\r\n\t\t\ttry {\r\n\t\t\t\tlog.debug(\"Forcing hang up {} [clientid={}] in case the user is still in the conference.\", username + \"[uid=\" + userid + \"]\", clientId);\r\n\t\t\t\tsipPeerManager.hangup(peerId, clientId);\r\n\t\t\t} catch (PeerNotFoundException e) {\r\n\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n        }\r\n        super.appDisconnect(conn);\r\n    }","id":87245,"modified_method":"@Override\r\n    public void appDisconnect(IConnection conn) {\r\n    \tString clientId = Red5.getConnectionLocal().getClient().getId();\r\n    \tString userId = getUserId();\r\n    \tString username = getUsername();\r\n    \t\r\n      String remoteHost = Red5.getConnectionLocal().getRemoteAddress();\r\n      int remotePort = Red5.getConnectionLocal().getRemotePort();    \t\r\n    \tlog.info(\"[clientid={}] disconnnected from {}.\", clientId, remoteHost + \":\" + remotePort);\r\n      log.debug(\"{} [clientid={}] is leaving the voice conf app. Removing from ConnectionManager.\", username + \"[uid=\" + userId + \"]\", clientId);\r\n    \t\r\n  \t\tString connType = getConnectionType(Red5.getConnectionLocal().getType());\r\n  \t\tString userFullname = username;\r\n  \t\tString connId = Red5.getConnectionLocal().getSessionId();\r\n  \t\t\r\n  \t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n  \t\tlogData.put(\"meetingId\", getMeetingId());\r\n  \t\tlogData.put(\"connType\", connType);\r\n  \t\tlogData.put(\"connId\", connId);\r\n  \t\tlogData.put(\"userId\", userId);\r\n  \t\tlogData.put(\"username\", userFullname);\r\n  \t\tlogData.put(\"event\", \"user_leaving_bbb_voice\");\r\n  \t\tlogData.put(\"description\", \"User leaving BBB Voice.\");\r\n  \t\t\r\n  \t\tGson gson = new Gson();\r\n      String logStr =  gson.toJson(logData);\r\n  \t\t\r\n  \t\tlog.info(\"User leaving bbb-voice: data={}\", logStr);\r\n      \r\n      clientConnManager.removeClient(clientId);\r\n\r\n      String peerId = (String) Red5.getConnectionLocal().getAttribute(\"VOICE_CONF_PEER\");\r\n      if (peerId != null) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlog.debug(\"Forcing hang up {} [clientid={}] in case the user is still in the conference.\", username + \"[uid=\" + userId + \"]\", clientId);\r\n\t\t\t\t\tsipPeerManager.hangup(peerId, clientId);\r\n\t\t\t\t} catch (PeerNotFoundException e) {\r\n\t\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n      }\r\n      super.appDisconnect(conn);\r\n    }","commit_id":"000ddbd9d7545a3132b76db7fa4186f5b65137dc","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n\tpublic boolean roomConnect(IConnection connection, Object[] params) {\n\t\tlog.debug(\"***** \" + APP + \" [ \" + \" roomConnect [ \" + connection.getScope().getName() + \"] *********\");\n\t\t\n\t\tString username = ((String) params[0]).toString();\n\t\tString role = ((String) params[1]).toString();\n\t\tString room = ((String)params[2]).toString();\n               \n\t\tString voiceBridge = ((String) params[3]).toString();\n\t\t\n\t\tboolean record = (Boolean)params[4];\n\t\t\n\t\tString externalUserID = ((String) params[5]).toString();\n\t\tString internalUserID = ((String) params[6]).toString();\n    \t\n\t\tBoolean locked = false;\n\t\tif (params.length >= 7 && ((Boolean) params[7])) {\n\t\t\tlocked = true;\n\t\t}\n    \t\n\t\tBoolean muted  = false;\n\t\tif (params.length >= 8 && ((Boolean) params[8])) {\n\t\t\tmuted = true;\n\t\t}\n    \t\n\t\tMap<String, Boolean> lsMap = null;\n\t\tif (params.length >= 9) {\n\t\t\ttry {\n\t\t\t\tlsMap = (Map<String, Boolean> ) params[9];\n\t\t\t} catch(Exception e){\n\t\t\t\tlsMap = new HashMap<String, Boolean>();\n\t\t\t}\n\t\t}\n    \t   \t    \t\n\t\tif (record == true) {\n\t\t\trecorderApplication.createRecordSession(room);\n\t\t}\n\t\t\t\n\t\tBigBlueButtonSession bbbSession = new BigBlueButtonSession(room, internalUserID,  username, role, \n    \t\t\tvoiceBridge, record, externalUserID, muted);\n\t\tconnection.setAttribute(Constants.SESSION, bbbSession);        \n\t\tconnection.setAttribute(\"INTERNAL_USER_ID\", internalUserID);\n        \n\t\tString debugInfo = \"internalUserID=\" + internalUserID + \",username=\" + username + \",role=\" +  role + \",\" + \n        \t\t\t\t\t\",voiceConf=\" + voiceBridge + \",room=\" + room + \",externalUserid=\" + externalUserID;\n\t\tlog.debug(\"User [{}] connected to room [{}]\", debugInfo, room); \n\n\t\tbbbGW.initLockSettings(room, locked, lsMap);\n\t\t\n\t\tconnInvokerService.addConnection(bbbSession.getInternalUserID(), connection);\n\n\t\tlog.info(\"User connected: sessionId=[\" + Red5.getConnectionLocal().getSessionId() + \"], encoding=[\" + Red5.getConnectionLocal().getType() +\n\t\t\t\t\"(persistent=RTMP,polling=RTMPT)], meetingId= [\" + bbbSession.getRoom() + \"], userId=[\" + bbbSession.getInternalUserID() + \"] username=[\" + bbbSession.getUsername() +\"]\");\n\n\t\t\n\t\treturn super.roomConnect(connection, params);\n        \n\t}","id":87246,"modified_method":"@Override\n\tpublic boolean roomConnect(IConnection connection, Object[] params) {\n\t\tlog.debug(\"***** \" + APP + \" [ \" + \" roomConnect [ \" + connection.getScope().getName() + \"] *********\");\n\t\t\n\t\tString username = ((String) params[0]).toString();\n\t\tString role = ((String) params[1]).toString();\n\t\tString room = ((String)params[2]).toString();\n               \n\t\tString voiceBridge = ((String) params[3]).toString();\n\t\t\n\t\tboolean record = (Boolean)params[4];\n\t\t\n\t\tString externalUserID = ((String) params[5]).toString();\n\t\tString internalUserID = ((String) params[6]).toString();\n    \t\n\t\tBoolean locked = false;\n\t\tif (params.length >= 7 && ((Boolean) params[7])) {\n\t\t\tlocked = true;\n\t\t}\n    \t\n\t\tBoolean muted  = false;\n\t\tif (params.length >= 8 && ((Boolean) params[8])) {\n\t\t\tmuted = true;\n\t\t}\n    \t\n\t\tMap<String, Boolean> lsMap = null;\n\t\tif (params.length >= 9) {\n\t\t\ttry {\n\t\t\t\tlsMap = (Map<String, Boolean> ) params[9];\n\t\t\t} catch(Exception e){\n\t\t\t\tlsMap = new HashMap<String, Boolean>();\n\t\t\t}\n\t\t}\n    \t   \t    \t\n\t\tif (record == true) {\n\t\t\trecorderApplication.createRecordSession(room);\n\t\t}\n\t\t\t\n\t\tBigBlueButtonSession bbbSession = new BigBlueButtonSession(room, internalUserID,  username, role, \n    \t\t\tvoiceBridge, record, externalUserID, muted);\n\t\tconnection.setAttribute(Constants.SESSION, bbbSession);        \n\t\tconnection.setAttribute(\"INTERNAL_USER_ID\", internalUserID);\n        \n\t\tString debugInfo = \"internalUserID=\" + internalUserID + \",username=\" + username + \",role=\" +  role + \",\" + \n        \t\t\t\t\t\",voiceConf=\" + voiceBridge + \",room=\" + room + \",externalUserid=\" + externalUserID;\n\t\tlog.debug(\"User [{}] connected to room [{}]\", debugInfo, room); \n\n\t\tbbbGW.initLockSettings(room, locked, lsMap);\n\t\t\n\t\tconnInvokerService.addConnection(bbbSession.getInternalUserID(), connection);\n\n\t\tString meetingId = bbbSession.getRoom();\n\t\tString userId = bbbSession.getInternalUserID();\n\t\tString connType = getConnectionType(Red5.getConnectionLocal().getType());\n\t\tString userFullname = bbbSession.getUsername();\n\t\tString connId = Red5.getConnectionLocal().getSessionId();\n\t\t\n\t\tlog.info(\"User connected: sessionId=[\" + connId + \"], encoding=[\" + connType +\n\t\t\t\t\"(persistent=RTMP,polling=RTMPT)], meetingId= [\" + meetingId\n\t\t\t\t+ \"], userId=[\" + userId + \"] username=[\" + userFullname +\"]\");\n\n\n\t\tMap<String, Object> logData = new HashMap<String, Object>();\n\t\tlogData.put(\"meetingId\", meetingId);\n\t\tlogData.put(\"connType\", connType);\n\t\tlogData.put(\"connId\", connId);\n\t\tlogData.put(\"userId\", userId);\n\t\tlogData.put(\"username\", userFullname);\n\t\tlogData.put(\"event\", \"user_joining_bbb_apps\");\n\t\tlogData.put(\"description\", \"User joining BBB Apps.\");\n\t\t\n\t\tGson gson = new Gson();\n    String logStr =  gson.toJson(logData);\n\t\t\n\t\tlog.info(\"User joining bbbb-aps: data={}\", logStr);\n\t\t\n\t\treturn super.roomConnect(connection, params);\n        \n\t}","commit_id":"000ddbd9d7545a3132b76db7fa4186f5b65137dc","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n\tpublic void roomDisconnect(IConnection conn) {\n\t\tlog.debug(\"***** \" + APP + \" [ \" + \" roomDisconnect [ \" + conn.getScope().getName() + \"] *********\");\n\t\t\n\t\tString remoteHost = Red5.getConnectionLocal().getRemoteAddress();\n\t\tint remotePort = Red5.getConnectionLocal().getRemotePort();    \t\n\t\tString clientId = Red5.getConnectionLocal().getClient().getId();\n\t\tlog.info(\"***** \" + APP + \"[clientid=\" + clientId + \"] disconnnected from \" + remoteHost + \":\" + remotePort + \".\");\n    \t\n\t\tconnInvokerService.removeConnection(getBbbSession().getInternalUserID());\n    \t\n\t\tBigBlueButtonSession bbbSession = (BigBlueButtonSession) Red5.getConnectionLocal().getAttribute(Constants.SESSION);\n\t\tlog.info(\"User disconnected: sessionId=[\" + Red5.getConnectionLocal().getSessionId() + \"], encoding=[\" + Red5.getConnectionLocal().getType() +\n\t\t\t\t\"(persistent=RTMP,polling=RTMPT)], meetingId= [\" + bbbSession.getRoom() + \"], userId=[\" + bbbSession.getInternalUserID() + \"] username=[\" + bbbSession.getUsername() +\"]\");\n\t\t\n\t\tbbbGW.userLeft(bbbSession.getRoom(), getBbbSession().getInternalUserID());\n\t\t\n\t\tsuper.roomDisconnect(conn);\n\t}","id":87247,"modified_method":"@Override\n\tpublic void roomDisconnect(IConnection conn) {\n\t\tlog.debug(\"***** \" + APP + \" [ \" + \" roomDisconnect [ \" + conn.getScope().getName() + \"] *********\");\n\t\t\n\t\tString remoteHost = Red5.getConnectionLocal().getRemoteAddress();\n\t\tint remotePort = Red5.getConnectionLocal().getRemotePort();    \t\n\t\tString clientId = Red5.getConnectionLocal().getClient().getId();\n\t\tlog.info(\"***** \" + APP + \"[clientid=\" + clientId + \"] disconnnected from \" + remoteHost + \":\" + remotePort + \".\");\n    \t\n\t\tconnInvokerService.removeConnection(getBbbSession().getInternalUserID());\n    \t\n\t\tBigBlueButtonSession bbbSession = (BigBlueButtonSession) Red5.getConnectionLocal().getAttribute(Constants.SESSION);\n\t\t\n\t\tString meetingId = bbbSession.getRoom();\n\t\tString userId = bbbSession.getInternalUserID();\n\t\tString connType = getConnectionType(Red5.getConnectionLocal().getType());\n\t\tString userFullname = bbbSession.getUsername();\n\t\tString connId = Red5.getConnectionLocal().getSessionId();\n\t\t\n\t\tlog.info(\"User disconnected: sessionId=[\" + connId + \"], encoding=[\" + connType +\n\t\t\t\t\"(persistent=RTMP,polling=RTMPT)], meetingId= [\" + meetingId + \"], userId=[\" + userId + \"] username=[\" + userFullname +\"]\");\n\t\n\t\tMap<String, Object> logData = new HashMap<String, Object>();\n\t\tlogData.put(\"meetingId\", meetingId);\n\t\tlogData.put(\"connType\", connType);\n\t\tlogData.put(\"connId\", connId);\n\t\tlogData.put(\"userId\", userId);\n\t\tlogData.put(\"username\", userFullname);\n\t\tlogData.put(\"event\", \"user_leaving_bbb_apps\");\n\t\tlogData.put(\"description\", \"User leaving BBB Apps.\");\n\t\t\n\t\tbbbGW.userLeft(bbbSession.getRoom(), getBbbSession().getInternalUserID());\n\t\t\n\t\tsuper.roomDisconnect(conn);\n\t}","commit_id":"000ddbd9d7545a3132b76db7fa4186f5b65137dc","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n\tpublic boolean appStart(IScope app) {\r\n\t    super.appStart(app);\r\n\t\tlog.info(\"oflaDemo appStart\");\r\n\t\tSystem.out.println(\"oflaDemo appStart\");    \t\r\n\t\tappScope = app;\r\n\t\treturn true;\r\n\t}","id":87248,"modified_method":"@Override\r\n\tpublic boolean appStart(IScope app) {\r\n\t    super.appStart(app);\r\n\t\tlog.info(\"BBB Video appStart\");\r\n\t\tSystem.out.println(\"BBB Video appStart\");    \t\r\n\t\tappScope = app;\r\n\t\treturn true;\r\n\t}","commit_id":"000ddbd9d7545a3132b76db7fa4186f5b65137dc","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n\tpublic void appDisconnect(IConnection conn) {\r\n\t\tlog.info(\"oflaDemo appDisconnect\");\r\n\t\tif (appScope == conn.getScope() && serverStream != null) {\r\n\t\t\tserverStream.close();\r\n\t\t}\r\n\t\tsuper.appDisconnect(conn);\r\n\t}","id":87249,"modified_method":"@Override\r\n\tpublic void appDisconnect(IConnection conn) {\r\n\t\tlog.info(\"BBB Video appDisconnect\");\r\n\t\tif (appScope == conn.getScope() && serverStream != null) {\r\n\t\t\tserverStream.close();\r\n\t\t}\r\n\t\t\r\n\t\tString connType = getConnectionType(Red5.getConnectionLocal().getType());\r\n\t\tString connId = Red5.getConnectionLocal().getSessionId();\r\n\t\t\r\n\t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n\t\tlogData.put(\"meetingId\", getMeetingId());\r\n\t\tlogData.put(\"userId\", getUserId());\r\n\t\tlogData.put(\"connType\", connType);\r\n\t\tlogData.put(\"connId\", connId);\r\n\t\tlogData.put(\"event\", \"user_leaving_bbb_video\");\r\n\t\tlogData.put(\"description\", \"User leaving BBB Video.\");\r\n\t\t\r\n\t\tGson gson = new Gson();\r\n    String logStr =  gson.toJson(logData);\r\n\t\t\r\n\t\tlog.info(\"User leaving bbb-video: data={}\", logStr);\r\n\t\t\r\n\t\tsuper.appDisconnect(conn);\r\n\t}","commit_id":"000ddbd9d7545a3132b76db7fa4186f5b65137dc","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n\tpublic boolean appConnect(IConnection conn, Object[] params) {\r\n\t\tlog.info(\"oflaDemo appConnect\"); \r\n\t\treturn super.appConnect(conn, params);\r\n\t}","id":87250,"modified_method":"@Override\r\n\tpublic boolean appConnect(IConnection conn, Object[] params) {\r\n\t\tlog.info(\"BBB Video appConnect\"); \t\t\r\n\t\treturn super.appConnect(conn, params);\r\n\t}","commit_id":"000ddbd9d7545a3132b76db7fa4186f5b65137dc","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void sendPrivateMessage(Map<String, Object> msg){\n\t\tString chatType = msg.get(ChatKeyUtil.CHAT_TYPE).toString(); \n\t\tString fromUserID = msg.get(ChatKeyUtil.FROM_USERID).toString();\n\t\tString fromUsername = msg.get(ChatKeyUtil.FROM_USERNAME ).toString();\n\t\tString fromColor = msg.get(ChatKeyUtil.FROM_COLOR).toString();\n\t\tString fromTime = msg.get(ChatKeyUtil.FROM_TIME).toString();   \n\t\tString fromTimezoneOffset = msg.get(ChatKeyUtil.FROM_TZ_OFFSET).toString();\n\t\tString toUserID = msg.get(ChatKeyUtil.TO_USERID).toString();\n\t\tString toUsername = msg.get(ChatKeyUtil.TO_USERNAME).toString();\n\t\tString chatText = msg.get(ChatKeyUtil.MESSAGE).toString();\n\t\t\n\t\tMap<String, String> message = new HashMap<String, String>();\n\t\tmessage.put(ChatKeyUtil.CHAT_TYPE, chatType); \n\t\tmessage.put(ChatKeyUtil.FROM_USERID, fromUserID);\n\t\tmessage.put(ChatKeyUtil.FROM_USERNAME, fromUsername);\n\t\tmessage.put(ChatKeyUtil.FROM_COLOR, fromColor);\n\t\tmessage.put(ChatKeyUtil.FROM_TIME, fromTime);   \n\t\tmessage.put(ChatKeyUtil.FROM_TZ_OFFSET, fromTimezoneOffset);\n\t\tmessage.put(ChatKeyUtil.TO_USERID, toUserID);\n\t\tmessage.put(ChatKeyUtil.TO_USERNAME, toUsername);\n\t\tmessage.put(ChatKeyUtil.MESSAGE, chatText);\n\t\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t\n\t\tapplication.sendPrivateMessage(meetingID, requesterID, message);\n\n\t}","id":87251,"modified_method":"public void sendPrivateMessage(Map<String, Object> msg){\n\t\tString chatType = msg.get(ChatKeyUtil.CHAT_TYPE).toString(); \n\t\tString fromUserID = msg.get(ChatKeyUtil.FROM_USERID).toString();\n\t\tString fromUsername = msg.get(ChatKeyUtil.FROM_USERNAME ).toString();\n\t\tString fromColor = msg.get(ChatKeyUtil.FROM_COLOR).toString();\n\t\tString fromTime = msg.get(ChatKeyUtil.FROM_TIME).toString();   \n\t\tString fromTimezoneOffset = msg.get(ChatKeyUtil.FROM_TZ_OFFSET).toString();\n\t\tString toUserID = msg.get(ChatKeyUtil.TO_USERID).toString();\n\t\tString toUsername = msg.get(ChatKeyUtil.TO_USERNAME).toString();\n\t\tString chatText = msg.get(ChatKeyUtil.MESSAGE).toString();\n\t\t\n\t\tMap<String, String> message = new HashMap<String, String>();\n\t\tmessage.put(ChatKeyUtil.CHAT_TYPE, chatType); \n\t\tmessage.put(ChatKeyUtil.FROM_USERID, fromUserID);\n\t\tmessage.put(ChatKeyUtil.FROM_USERNAME, fromUsername);\n\t\tmessage.put(ChatKeyUtil.FROM_COLOR, fromColor);\n\t\tmessage.put(ChatKeyUtil.FROM_TIME, fromTime);   \n\t\tmessage.put(ChatKeyUtil.FROM_TZ_OFFSET, fromTimezoneOffset);\n\t\tmessage.put(ChatKeyUtil.TO_USERID, toUserID);\n\t\tmessage.put(ChatKeyUtil.TO_USERNAME, toUsername);\n\t\tmessage.put(ChatKeyUtil.MESSAGE, chatText);\n\t\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t\n\t\tbbbInGW.sendPrivateMessage(meetingID, requesterID, message);\n\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void sendPublicChatHistory() {\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t\n\t\tapplication.sendPublicChatHistory(meetingID, requesterID);\n\t}","id":87252,"modified_method":"public void sendPublicChatHistory() {\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t// Just hardcode as we don't really need it for flash client. (ralam may 7, 2014)\n\t\tString replyTo = meetingID + \"/\" + requesterID; \n\t\t\n\t\tbbbInGW.getChatHistory(meetingID, requesterID, replyTo);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void sendPublicMessage(Map<String, Object> msg) {\n\t\t\n\t\tString chatType = msg.get(ChatKeyUtil.CHAT_TYPE).toString(); \n\t\tString fromUserID = msg.get(ChatKeyUtil.FROM_USERID).toString();\n\t\tString fromUsername = msg.get(ChatKeyUtil.FROM_USERNAME ).toString();\n\t\tString fromColor = msg.get(ChatKeyUtil.FROM_COLOR).toString();\n\t\tString fromTime = msg.get(ChatKeyUtil.FROM_TIME).toString();   \n\t\tString fromTimezoneOffset = msg.get(ChatKeyUtil.FROM_TZ_OFFSET).toString();\n\t\tString toUserID = msg.get(ChatKeyUtil.TO_USERID).toString();\n\t\tString toUsername = msg.get(ChatKeyUtil.TO_USERNAME).toString();\n\t\tString chatText = msg.get(ChatKeyUtil.MESSAGE).toString();\n\t\t\n\t\tMap<String, String> message = new HashMap<String, String>();\n\t\tmessage.put(ChatKeyUtil.CHAT_TYPE, chatType); \n\t\tmessage.put(ChatKeyUtil.FROM_USERID, fromUserID);\n\t\tmessage.put(ChatKeyUtil.FROM_USERNAME, fromUsername);\n\t\tmessage.put(ChatKeyUtil.FROM_COLOR, fromColor);\n\t\tmessage.put(ChatKeyUtil.FROM_TIME, fromTime);   \n\t\tmessage.put(ChatKeyUtil.FROM_TZ_OFFSET, fromTimezoneOffset);\n\t\tmessage.put(ChatKeyUtil.TO_USERID, toUserID);\n\t\tmessage.put(ChatKeyUtil.TO_USERNAME, toUsername);\n\t\tmessage.put(ChatKeyUtil.MESSAGE, chatText);\n\t\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t\n\t\tapplication.sendPublicMessage(meetingID, requesterID, message);\n\t}","id":87253,"modified_method":"public void sendPublicMessage(Map<String, Object> msg) {\n\t\t\n\t\tString chatType = msg.get(ChatKeyUtil.CHAT_TYPE).toString(); \n\t\tString fromUserID = msg.get(ChatKeyUtil.FROM_USERID).toString();\n\t\tString fromUsername = msg.get(ChatKeyUtil.FROM_USERNAME ).toString();\n\t\tString fromColor = msg.get(ChatKeyUtil.FROM_COLOR).toString();\n\t\tString fromTime = msg.get(ChatKeyUtil.FROM_TIME).toString();   \n\t\tString fromTimezoneOffset = msg.get(ChatKeyUtil.FROM_TZ_OFFSET).toString();\n\t\tString toUserID = msg.get(ChatKeyUtil.TO_USERID).toString();\n\t\tString toUsername = msg.get(ChatKeyUtil.TO_USERNAME).toString();\n\t\tString chatText = msg.get(ChatKeyUtil.MESSAGE).toString();\n\t\t\n\t\tMap<String, String> message = new HashMap<String, String>();\n\t\tmessage.put(ChatKeyUtil.CHAT_TYPE, chatType); \n\t\tmessage.put(ChatKeyUtil.FROM_USERID, fromUserID);\n\t\tmessage.put(ChatKeyUtil.FROM_USERNAME, fromUsername);\n\t\tmessage.put(ChatKeyUtil.FROM_COLOR, fromColor);\n\t\tmessage.put(ChatKeyUtil.FROM_TIME, fromTime);   \n\t\tmessage.put(ChatKeyUtil.FROM_TZ_OFFSET, fromTimezoneOffset);\n\t\tmessage.put(ChatKeyUtil.TO_USERID, toUserID);\n\t\tmessage.put(ChatKeyUtil.TO_USERNAME, toUsername);\n\t\tmessage.put(ChatKeyUtil.MESSAGE, chatText);\n\t\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t\n\t\tbbbInGW.sendPublicMessage(meetingID, requesterID, message);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private void sendMessageToClient(ClientMessage message) {\r\n\t\tif (message instanceof BroadcastClientMessage) {\r\n\t\t\tsendBroadcastMessage((BroadcastClientMessage) message);\r\n\t\t} else if (message instanceof DirectClientMessage) {\r\n\t\t\tsendDirectMessage((DirectClientMessage) message);\r\n\t\t} else if (message instanceof SharedObjectClientMessage) {\r\n\t\t\tsendSharedObjectMessage((SharedObjectClientMessage) message);\r\n\t\t} else if (message instanceof DisconnectClientMessage) {\r\n\t\t\thandlDisconnectClientMessage((DisconnectClientMessage) message);\r\n\t\t} else if (message instanceof DisconnectAllClientsMessage) {\r\n\t\t\thandleDisconnectAllClientsMessage((DisconnectAllClientsMessage) message);\r\n\t\t}\r\n\t}","id":87254,"modified_method":"private void sendMessageToClient(ClientMessage message) {\r\n\t\tif (message instanceof BroadcastClientMessage) {\r\n\t\t\tsendBroadcastMessage((BroadcastClientMessage) message);\r\n\t\t} else if (message instanceof DirectClientMessage) {\r\n\t\t\tsendDirectMessage((DirectClientMessage) message);\r\n\t\t} else if (message instanceof DisconnectClientMessage) {\r\n\t\t\thandlDisconnectClientMessage((DisconnectClientMessage) message);\r\n\t\t} else if (message instanceof DisconnectAllClientsMessage) {\r\n\t\t\thandleDisconnectAllClientsMessage((DisconnectAllClientsMessage) message);\r\n\t\t}\r\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void broadcast(Map<String, Object> message) {\n\t\tlog.debug(\"Received broadcast layout request\");\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString newlayout = (String) message.get(\"layout\");\n\n\t\tif (newlayout == null || newlayout.isEmpty()) {\n\t\t\tlog.error(\"Invalid Broadcast Layout message. layout is null or empty.\");\n\t\t\treturn;\n\t\t}\n\t\t\t\t\t\n\t\tapplication.broadcastLayout(meetingID, getBbbSession().getInternalUserID(), newlayout);\n\t}","id":87255,"modified_method":"public void broadcast(Map<String, Object> message) {\n\t\tlog.debug(\"Received broadcast layout request\");\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tString newlayout = (String) message.get(\"layout\");\n\n\t\tif (newlayout == null || newlayout.isEmpty()) {\n\t\t\tlog.error(\"Invalid Broadcast Layout message. layout is null or empty.\");\n\t\t\treturn;\n\t\t}\n\t\t\t\t\t\n\t\tbbbInGW.broadcastLayout(meetingID, getBbbSession().getInternalUserID(), newlayout);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void getCurrentLayout() {\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tlog.debug(\"Received get current layout request\");\n\t\tapplication.getCurrentLayout(meetingID, getBbbSession().getInternalUserID());\n\t}","id":87256,"modified_method":"public void getCurrentLayout() {\n\t\tString meetingID = Red5.getConnectionLocal().getScope().getName();\n\t\tlog.debug(\"Received get current layout request\");\n\t\tbbbInGW.getCurrentLayout(meetingID, getBbbSession().getInternalUserID());\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void setParticipantStatus(Map<String, Object> msg) {\n\t\tString roomName = Red5.getConnectionLocal().getScope().getName();\n\n\t\tapplication.setParticipantStatus(roomName, (String) msg.get(\"userID\"), (String) msg.get(\"status\"), (Object) msg.get(\"value\"));\n\t}","id":87257,"modified_method":"public void setParticipantStatus(Map<String, Object> msg) {\n\t\tString roomName = Red5.getConnectionLocal().getScope().getName();\n\t\tbbbInGW.setUserStatus(roomName, (String) msg.get(\"userID\"), (String) msg.get(\"status\"), (Object) msg.get(\"value\"));\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void userRaiseHand() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString userId = getBbbSession().getInternalUserID();\n\t\tapplication.userRaiseHand(scope.getName(), userId);\n\t}","id":87258,"modified_method":"public void userRaiseHand() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString userId = getBbbSession().getInternalUserID();\n\t\tbbbInGW.userRaiseHand(scope.getName(), userId);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void unshareWebcam(String stream) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString userId = getBbbSession().getInternalUserID();\n\t\tapplication.unshareWebcam(scope.getName(), userId, stream);\n\t}","id":87259,"modified_method":"public void unshareWebcam(String stream) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString userId = getBbbSession().getInternalUserID();\n\t\tbbbInGW.unshareWebcam(scope.getName(), userId, stream);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void lowerHand(Map<String, String> msg) {\n\t\tString userId = (String) msg.get(\"userId\");\n\t\tString loweredBy = (String) msg.get(\"loweredBy\");\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tapplication.lowerHand(scope.getName(), userId, loweredBy);\n\t}","id":87260,"modified_method":"public void lowerHand(Map<String, String> msg) {\n\t\tString userId = (String) msg.get(\"userId\");\n\t\tString loweredBy = (String) msg.get(\"loweredBy\");\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tbbbInGW.lowerHand(scope.getName(), userId, loweredBy);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void getParticipants() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n        String connId = Red5.getConnectionLocal().getSessionId();    \n        String sessionId =  CONN + connId + \"-\" + getBbbSession().getInternalUserID();\n\t\tapplication.getUsers(scope.getName(), getBbbSession().getInternalUserID(), sessionId);\n\t}","id":87261,"modified_method":"public void getParticipants() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n        String connId = Red5.getConnectionLocal().getSessionId();    \n        bbbInGW.getUsers(scope.getName(), getBbbSession().getInternalUserID());\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void getRecordingStatus() {\n\t\tString roomName = Red5.getConnectionLocal().getScope().getName();\n\t\tapplication.getRecordingStatus(roomName, getMyUserId());\n\t}","id":87262,"modified_method":"public void getRecordingStatus() {\n\t\tString roomName = Red5.getConnectionLocal().getScope().getName();\n\t\tbbbInGW.getRecordingStatus(roomName, getMyUserId());\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void setRecordingStatus(Map<String, Object> msg) {\n\t\tString roomName = Red5.getConnectionLocal().getScope().getName();\n\t\tapplication.setRecordingStatus(roomName, (String)msg.get(\"userId\"), (Boolean) msg.get(\"recording\"));\n\t}","id":87263,"modified_method":"public void setRecordingStatus(Map<String, Object> msg) {\n\t\tString roomName = Red5.getConnectionLocal().getScope().getName();\n\t\tbbbInGW.setRecordingStatus(roomName, (String)msg.get(\"userId\"), (Boolean) msg.get(\"recording\"));\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void assignPresenter(Map<String, String> msg) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tapplication.assignPresenter(scope.getName(), (String) msg.get(\"newPresenterID\"), (String) msg.get(\"newPresenterName\"), (String) msg.get(\"assignedBy\"));\n\t}","id":87264,"modified_method":"public void assignPresenter(Map<String, String> msg) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tbbbInGW.assignPresenter(scope.getName(), (String) msg.get(\"newPresenterID\"), (String) msg.get(\"newPresenterName\"), (String) msg.get(\"assignedBy\"));\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void ejectUserFromMeeting(Map<String, String> msg) {\n\t\tString userId = (String) msg.get(\"userId\");\n\t\tString ejectedBy = (String) msg.get(\"ejectedBy\");\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tapplication.ejectUserFromMeeting(scope.getName(), userId, ejectedBy);\n\t}","id":87265,"modified_method":"public void ejectUserFromMeeting(Map<String, String> msg) {\n\t\tString userId = (String) msg.get(\"userId\");\n\t\tString ejectedBy = (String) msg.get(\"ejectedBy\");\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tbbbInGW.ejectUserFromMeeting(scope.getName(), userId, ejectedBy);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void shareWebcam(String stream) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString userId = getBbbSession().getInternalUserID();\n\t\tapplication.shareWebcam(scope.getName(), userId, stream);\t\t\n\t}","id":87266,"modified_method":"public void shareWebcam(String stream) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString userId = getBbbSession().getInternalUserID();\n\t\tbbbInGW.shareWebcam(scope.getName(), userId, stream);\t\t\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void getPresentationInfo() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tlog.debug(\"Getting presentation info for meeting [{}]\", scope.getName());\n\t\tpresentationApplication.getPresentationInfo(scope.getName(), getBbbSession().getInternalUserID());\n\t}","id":87267,"modified_method":"public void getPresentationInfo() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString meetingID = scope.getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t// Just hardcode as we don't really need it for flash client. (ralam may 7, 2014)\n\t\tString replyTo = meetingID + \"/\" + requesterID; \n\t\tbbbInGW.getPresentationInfo(meetingID, requesterID, replyTo);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void sendCursorUpdate(Map<String, Object> msg) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\t\n\t\tDouble xPercent;\n\t\tif (msg.get(\"xPercent\") instanceof Integer) {\n\t\t\tInteger tempXOffset = (Integer) msg.get(\"xPercent\");\n\t\t\txPercent = tempXOffset.doubleValue();\n\t\t} else {\n\t\t\txPercent = (Double) msg.get(\"xPercent\");\n\t\t}\n\n\t\tDouble yPercent;\n\t\t\n\t\tif (msg.get(\"yPercent\") instanceof Integer) {\n\t\t\tInteger tempYOffset = (Integer) msg.get(\"yPercent\");\n\t\t\tyPercent = tempYOffset.doubleValue();\n\t\t} else {\n\t\t\tyPercent = (Double) msg.get(\"yPercent\");\n\t\t}\n\t\t\n\t\tpresentationApplication.sendCursorUpdate(scope.getName(), xPercent, yPercent);\n\t}","id":87268,"modified_method":"public void sendCursorUpdate(Map<String, Object> msg) {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\t\n\t\tDouble xPercent;\n\t\tif (msg.get(\"xPercent\") instanceof Integer) {\n\t\t\tInteger tempXOffset = (Integer) msg.get(\"xPercent\");\n\t\t\txPercent = tempXOffset.doubleValue();\n\t\t} else {\n\t\t\txPercent = (Double) msg.get(\"xPercent\");\n\t\t}\n\n\t\tDouble yPercent;\n\t\t\n\t\tif (msg.get(\"yPercent\") instanceof Integer) {\n\t\t\tInteger tempYOffset = (Integer) msg.get(\"yPercent\");\n\t\t\tyPercent = tempYOffset.doubleValue();\n\t\t} else {\n\t\t\tyPercent = (Double) msg.get(\"yPercent\");\n\t\t}\n\t\t\n\t\tbbbInGW.sendCursorUpdate(scope.getName(), xPercent, yPercent);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void resizeAndMoveSlide(Map<String, Object> msg) {\n\t\tDouble xOffset;\n\t\tif (msg.get(\"xOffset\") instanceof Integer) {\n\t\t\tInteger tempXOffset = (Integer) msg.get(\"xOffset\");\n\t\t\txOffset = tempXOffset.doubleValue();\n\t\t} else {\n\t\t\txOffset = (Double) msg.get(\"xOffset\");\n\t\t}\n\n\t\tDouble yOffset;\n\t\t\n\t\tif (msg.get(\"yOffset\") instanceof Integer) {\n\t\t\tInteger tempYOffset = (Integer) msg.get(\"yOffset\");\n\t\t\tyOffset = tempYOffset.doubleValue();\n\t\t} else {\n\t\t\tyOffset = (Double) msg.get(\"yOffset\");\n\t\t}\n\t\t \n\t\tDouble widthRatio;\n\t\tif (msg.get(\"widthRatio\") instanceof Integer) {\n\t\t\tInteger tempWRatio = (Integer) msg.get(\"widthRatio\");\n\t\t\twidthRatio = tempWRatio.doubleValue();\n\t\t} else {\n\t\t\twidthRatio = (Double) msg.get(\"widthRatio\");\n\t\t}\n\t\t\t\t\n\t\t\n\t\tDouble heightRatio;\n\t\tif (msg.get(\"heightRatio\") instanceof Integer) {\n\t\t\tInteger tempHRatio = (Integer) msg.get(\"heightRatio\");\n\t\t\theightRatio = tempHRatio.doubleValue();\n\t\t} else {\n\t\t\theightRatio = (Double) msg.get(\"heightRatio\");\n\t\t}\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tpresentationApplication.resizeAndMoveSlide(scope.getName(), xOffset, yOffset, widthRatio, heightRatio);\n\t}","id":87269,"modified_method":"public void resizeAndMoveSlide(Map<String, Object> msg) {\n\t\tDouble xOffset;\n\t\tif (msg.get(\"xOffset\") instanceof Integer) {\n\t\t\tInteger tempXOffset = (Integer) msg.get(\"xOffset\");\n\t\t\txOffset = tempXOffset.doubleValue();\n\t\t} else {\n\t\t\txOffset = (Double) msg.get(\"xOffset\");\n\t\t}\n\n\t\tDouble yOffset;\n\t\t\n\t\tif (msg.get(\"yOffset\") instanceof Integer) {\n\t\t\tInteger tempYOffset = (Integer) msg.get(\"yOffset\");\n\t\t\tyOffset = tempYOffset.doubleValue();\n\t\t} else {\n\t\t\tyOffset = (Double) msg.get(\"yOffset\");\n\t\t}\n\t\t \n\t\tDouble widthRatio;\n\t\tif (msg.get(\"widthRatio\") instanceof Integer) {\n\t\t\tInteger tempWRatio = (Integer) msg.get(\"widthRatio\");\n\t\t\twidthRatio = tempWRatio.doubleValue();\n\t\t} else {\n\t\t\twidthRatio = (Double) msg.get(\"widthRatio\");\n\t\t}\n\t\t\t\t\n\t\t\n\t\tDouble heightRatio;\n\t\tif (msg.get(\"heightRatio\") instanceof Integer) {\n\t\t\tInteger tempHRatio = (Integer) msg.get(\"heightRatio\");\n\t\t\theightRatio = tempHRatio.doubleValue();\n\t\t} else {\n\t\t\theightRatio = (Double) msg.get(\"heightRatio\");\n\t\t}\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tbbbInGW.resizeAndMoveSlide(scope.getName(), xOffset, yOffset, widthRatio, heightRatio);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void removePresentation(Map<String, Object> msg) {\n\t\tString presentationID = (String) msg.get(\"presentationID\");\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tpresentationApplication.removePresentation(scope.getName(), presentationID);\n\t}","id":87270,"modified_method":"public void removePresentation(Map<String, Object> msg) {\n\t\tString presentationID = (String) msg.get(\"presentationID\");\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tbbbInGW.removePresentation(scope.getName(), presentationID);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void gotoSlide(Map<String, Object> msg) {\n\t\tString pageId = (String) msg.get(\"page\");\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tlog.debug(\"Got GotoSlide for meeting [{}] page=[{}]\", scope.getName(), pageId);\n\n\t\tpresentationApplication.gotoSlide(scope.getName(), pageId);\n\t}","id":87271,"modified_method":"public void gotoSlide(Map<String, Object> msg) {\n\t\tString pageId = (String) msg.get(\"page\");\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tlog.debug(\"Got GotoSlide for meeting [{}] page=[{}]\", scope.getName(), pageId);\n\n\t\tbbbInGW.gotoSlide(scope.getName(), pageId);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void getSlideInfo() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tlog.debug(\"Getting slide info for meeting [{}]\", scope.getName());\n\t\tpresentationApplication.getSlideInfo(scope.getName(), getBbbSession().getInternalUserID());\t\t\n\t}","id":87272,"modified_method":"public void getSlideInfo() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tString meetingID = scope.getName();\n\t\tString requesterID = getBbbSession().getInternalUserID();\n\t\t// Just hardcode as we don't really need it for flash client. (ralam may 7, 2014)\n\t\tString replyTo = meetingID + \"/\" + requesterID; \n\t\tbbbInGW.getSlideInfo(meetingID, requesterID, replyTo);\t\t\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void sharePresentation(Map<String, Object> msg) {\n\t\tString presentationID = (String) msg.get(\"presentationID\");\n\t\tBoolean share = (Boolean) msg.get(\"share\");\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tpresentationApplication.sharePresentation(scope.getName(), presentationID, share);\n\t}","id":87273,"modified_method":"public void sharePresentation(Map<String, Object> msg) {\n\t\tString presentationID = (String) msg.get(\"presentationID\");\n\t\tBoolean share = (Boolean) msg.get(\"share\");\n\t\t\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tbbbInGW.sharePresentation(scope.getName(), presentationID, share);\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void clear() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tpresentationApplication.clear(scope.getName());\n\t}","id":87274,"modified_method":"public void clear() {\n\t\tIScope scope = Red5.getConnectionLocal().getScope();\n\t\tbbbInGW.clear(scope.getName());\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void isWhiteboardEnabled() {\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\t\t\r\n\t\tapplication.setIsWhiteboardEnabled(meetingID, requesterID);\r\n\t}","id":87275,"modified_method":"public void isWhiteboardEnabled() {\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\t\t\r\n\t\t// Just hardcode as we don't really need it for flash client. (ralam may 7, 2014)\r\n\t\tString replyTo = meetingID + \"/\" + requesterID; \r\n\t\tbbbInGW.isWhiteboardEnabled(meetingID, requesterID, replyTo);\r\n\t\t\r\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void undo(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - Deleting last graphic\");\r\n\t\t\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tString wbId = (String) message.get(WB_ID);\r\n\t\tif (wbId != null) {\r\n\t\t\tapplication.undoWhiteboard(meetingID, requesterID, wbId);\r\n\t\t}\r\n\t}","id":87276,"modified_method":"public void undo(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - Deleting last graphic\");\r\n\t\t\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tString wbId = (String) message.get(WB_ID);\r\n\t\tif (wbId != null) {\r\n\t\t\tbbbInGW.undoWhiteboard(meetingID, requesterID, wbId);\r\n\t\t}\r\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void sendAnnotation(Map<String, Object> annotation) {\r\n//\t\tfor (Map.Entry<String, Object> entry : annotation.entrySet()) {\r\n//\t\t    String key = entry.getKey();\r\n//\t\t    Object value = entry.getValue();\r\n\t\t    \r\n//\t\t    if (key.equals(\"points\")) {\r\n//\t\t    \tString points = \"points=[\";\r\n//\t\t    \tArrayList<Double> v = (ArrayList<Double>) value;\r\n//\t\t    \tlog.debug(points + pointsToString(v) + \"]\");\r\n//\t\t    } else {\r\n//\t\t    \tlog.debug(key + \"=[\" + value + \"]\");\r\n//\t\t    }\r\n//\t\t}\r\n\t\t\t\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\t\r\n\t\tif (validMessage(annotation)) {\r\n\t\t\tapplication.sendWhiteboardAnnotation(meetingID, requesterID, annotation);\r\n\t\t}\t\t\r\n\t}","id":87277,"modified_method":"public void sendAnnotation(Map<String, Object> annotation) {\r\n//\t\tfor (Map.Entry<String, Object> entry : annotation.entrySet()) {\r\n//\t\t    String key = entry.getKey();\r\n//\t\t    Object value = entry.getValue();\r\n\t\t    \r\n//\t\t    if (key.equals(\"points\")) {\r\n//\t\t    \tString points = \"points=[\";\r\n//\t\t    \tArrayList<Double> v = (ArrayList<Double>) value;\r\n//\t\t    \tlog.debug(points + pointsToString(v) + \"]\");\r\n//\t\t    } else {\r\n//\t\t    \tlog.debug(key + \"=[\" + value + \"]\");\r\n//\t\t    }\r\n//\t\t}\r\n\t\t\t\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\t\r\n\t\tif (validMessage(annotation)) {\r\n\t\t\tbbbInGW.sendWhiteboardAnnotation(meetingID, requesterID, annotation);\r\n\t\t}\t\t\r\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void requestAnnotationHistory(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - requestAnnotationHistory\");\r\n\t\t\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tString wbId = (String) message.get(WB_ID);\r\n\t\tif (wbId != null) {\r\n\t\t\tapplication.requestAnnotationHistory(meetingID, requesterID, wbId);\t\r\n\t\t}\t\t\r\n\t}","id":87278,"modified_method":"public void requestAnnotationHistory(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - requestAnnotationHistory\");\r\n\t\t\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tString whiteboardId = (String) message.get(WB_ID);\r\n\t\tif (whiteboardId != null) {\r\n\t\t\t// Just hardcode as we don't really need it for flash client. (ralam may 7, 2014)\r\n\t\t\tString replyTo = meetingID + \"/\" + requesterID; \r\n\t\t\tbbbInGW.requestWhiteboardAnnotationHistory(meetingID, requesterID, whiteboardId, replyTo);\r\n\t\t}\t\t\r\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void clear(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - Clearing board\");\r\n\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tString wbId = (String) message.get(WB_ID);\r\n\t\tif (wbId != null) {\r\n\t\t\tapplication.clearWhiteboard(meetingID, requesterID, wbId);\r\n\t\t}\t\t\t\t\r\n\t}","id":87279,"modified_method":"public void clear(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - Clearing board\");\r\n\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tString wbId = (String) message.get(WB_ID);\r\n\t\tif (wbId != null) {\r\n\t\t\tbbbInGW.clearWhiteboard(meetingID, requesterID, wbId);\r\n\t\t}\t\t\t\t\r\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void enableWhiteboard(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - Setting whiteboard enabled: \" + (Boolean)message.get(\"enabled\"));\r\n\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tBoolean enable = (Boolean)message.get(\"enabled\");\r\n\t\t\r\n\t\tapplication.setWhiteboardEnable(meetingID, requesterID, enable);\r\n\t}","id":87280,"modified_method":"public void enableWhiteboard(Map<String, Object> message) {\r\n\t\tlog.info(\"WhiteboardApplication - Setting whiteboard enabled: \" + (Boolean)message.get(\"enabled\"));\r\n\r\n\t\tString meetingID = getMeetingId();\r\n\t\tString requesterID = getBbbSession().getInternalUserID();\r\n\t\tBoolean enable = (Boolean)message.get(\"enabled\");\r\n\t\tbbbInGW.enableWhiteboard(meetingID, requesterID, enable);\r\n\t}","commit_id":"09b7d5e14e1de743ec74bc9f1da307b0118488ff","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private ModelNode resolveExpressions(OperationContext context, ModelNode ssl) throws OperationFailedException {\n        ModelNode result = new ModelNode();\n        for (AttributeDefinition def : WebSSLDefinition.SSL_ATTRIBUTES) {\n            result.get(def.getName()).set(def.resolveModelAttribute(context, ssl));\n        }\n        return result;\n    }","id":87281,"modified_method":"private ModelNode resolveSslExpressions(OperationContext context, ModelNode ssl) throws OperationFailedException {\n        ModelNode result = new ModelNode();\n        for (AttributeDefinition def : WebSSLDefinition.SSL_ATTRIBUTES) {\n            result.get(def.getName()).set(def.resolveModelAttribute(context, ssl));\n        }\n        return result;\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final String bindingRef = WebConnectorDefinition.SOCKET_BINDING.resolveModelAttribute(context, fullModel).asString();\n\n        final boolean enabled = WebConnectorDefinition.ENABLED.resolveModelAttribute(context, fullModel).asBoolean();\n        final String protocol = WebConnectorDefinition.PROTOCOL.resolveModelAttribute(context, fullModel).asString();\n        final String scheme = WebConnectorDefinition.SCHEME.resolveModelAttribute(context, fullModel).asString();\n        final WebConnectorService service = new WebConnectorService(protocol, scheme);\n        service.setSecure(WebConnectorDefinition.SECURE.resolveModelAttribute(context, fullModel).asBoolean());\n        service.setEnableLookups(WebConnectorDefinition.ENABLE_LOOKUPS.resolveModelAttribute(context, fullModel).asBoolean());\n        ModelNode resolved;\n        if (operation.hasDefined(PROXY_NAME) && (resolved =  WebConnectorDefinition.PROXY_NAME.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setProxyName(resolved.asString());\n        }\n        if (operation.hasDefined(PROXY_PORT)&& (resolved =  WebConnectorDefinition.PROXY_PORT.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setProxyPort(resolved.asInt());\n        }\n        if (operation.hasDefined(REDIRECT_PORT)&& (resolved =  WebConnectorDefinition.REDIRECT_PORT.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setRedirectPort(resolved.asInt());\n        }\n        if (operation.hasDefined(MAX_POST_SIZE)&& (resolved =  WebConnectorDefinition.MAX_POST_SIZE.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxPostSize(resolved.asInt());\n        }\n        if (operation.hasDefined(MAX_SAVE_POST_SIZE)&& (resolved =  WebConnectorDefinition.MAX_SAVE_POST_SIZE.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxSavePostSize(resolved.asInt());\n        }\n        if (operation.hasDefined(MAX_CONNECTIONS)&& (resolved =  WebConnectorDefinition.MAX_CONNECTIONS.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxConnections(resolved.asInt());\n        }\n        if (operation.hasDefined(VIRTUAL_SERVER)&& (resolved =  WebConnectorDefinition.VIRTUAL_SERVER.resolveModelAttribute(context, fullModel)).isDefined()) {\n            List<String> vServers = new LinkedList<String>();\n            for (ModelNode vServer:resolved.asList()){\n                vServers.add(vServer.asString());\n            }\n            service.setVirtualServers(vServers);\n        }\n        if (fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue()).isDefined()) {\n            service.setSsl(resolveExpressions(context, fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue())));\n        }\n        final ServiceBuilder<Connector> serviceBuilder = context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB_CONNECTOR.append(name), service)\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getServer())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(bindingRef), SocketBinding.class, service.getBinding());\n        if (operation.hasDefined(EXECUTOR)) {\n            String executorRef = operation.get(EXECUTOR).asString();\n            serviceBuilder.addDependency(ThreadsServices.executorName(executorRef), Executor.class, service.getExecutor());\n        }\n        serviceBuilder.setInitialMode(enabled ? Mode.ACTIVE : Mode.NEVER);\n        if (enabled) {\n            serviceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController<Connector> serviceController = serviceBuilder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n    }","id":87282,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final String bindingRef = WebConnectorDefinition.SOCKET_BINDING.resolveModelAttribute(context, fullModel).asString();\n\n        final boolean enabled = WebConnectorDefinition.ENABLED.resolveModelAttribute(context, fullModel).asBoolean();\n        final String protocol = WebConnectorDefinition.PROTOCOL.resolveModelAttribute(context, fullModel).asString();\n        final String scheme = WebConnectorDefinition.SCHEME.resolveModelAttribute(context, fullModel).asString();\n        final WebConnectorService service = new WebConnectorService(protocol, scheme);\n        service.setSecure(WebConnectorDefinition.SECURE.resolveModelAttribute(context, fullModel).asBoolean());\n        service.setEnableLookups(WebConnectorDefinition.ENABLE_LOOKUPS.resolveModelAttribute(context, fullModel).asBoolean());\n        ModelNode resolved;\n        if ((resolved =  WebConnectorDefinition.PROXY_NAME.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setProxyName(resolved.asString());\n        }\n        if ((resolved =  WebConnectorDefinition.PROXY_PORT.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setProxyPort(resolved.asInt());\n        }\n        if ((resolved =  WebConnectorDefinition.REDIRECT_PORT.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setRedirectPort(resolved.asInt());\n        }\n        if ((resolved =  WebConnectorDefinition.MAX_POST_SIZE.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxPostSize(resolved.asInt());\n        }\n        if ((resolved =  WebConnectorDefinition.MAX_SAVE_POST_SIZE.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxSavePostSize(resolved.asInt());\n        }\n        if ((resolved =  WebConnectorDefinition.MAX_CONNECTIONS.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxConnections(resolved.asInt());\n        }\n        if ((resolved =  WebConnectorDefinition.VIRTUAL_SERVER.resolveModelAttribute(context, fullModel)).isDefined()) {\n            List<String> vServers = new LinkedList<String>();\n            for (ModelNode vServer:resolved.asList()){\n                vServers.add(vServer.asString());\n            }\n            service.setVirtualServers(vServers);\n        }\n        if (fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue()).isDefined()) {\n            service.setSsl(resolveSslExpressions(context, fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue())));\n        }\n        final ServiceBuilder<Connector> serviceBuilder = context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB_CONNECTOR.append(name), service)\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getServer())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(bindingRef), SocketBinding.class, service.getBinding());\n        if ((resolved =  WebConnectorDefinition.EXECUTOR.resolveModelAttribute(context, fullModel)).isDefined()) {\n            String executorRef = resolved.asString();\n            serviceBuilder.addDependency(ThreadsServices.executorName(executorRef), Executor.class, service.getExecutor());\n        }\n        serviceBuilder.setInitialMode(enabled ? Mode.ACTIVE : Mode.NEVER);\n        if (enabled) {\n            serviceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController<Connector> serviceController = serviceBuilder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        PATTERN.validateAndSet(operation,model);\n        FLAGS.validateAndSet(operation, model);\n        SUBSTITUTION.validateAndSet(operation, model);\n    }","id":87283,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        for (AttributeDefinition ad : WebReWriteDefinition.ATTRIBUTES) {\n            ad.validateAndSet(operation, model);\n        }\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        FLAGS.validateAndSet(operation,model);\n        TEST.validateAndSet(operation,model);\n        PATTERN.validateAndSet(operation, model);\n    }","id":87284,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        for (AttributeDefinition ad : WebReWriteConditionDefinition.ATTRIBUTES) {\n            ad.validateAndSet(operation, model);\n        }\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode baseOperation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        ModelNode operation = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final PathAddress address = PathAddress.pathAddress(baseOperation.get(OP_ADDR));\n\n        final String name = address.getLastElement().getValue();\n        String classname = null;\n        if (WebValveDefinition.CLASS_NAME.resolveModelAttribute(context, operation).isDefined())\n            classname = WebValveDefinition.CLASS_NAME.resolveModelAttribute(context, operation).asString();\n        String module = null;\n        if (WebValveDefinition.MODULE.resolveModelAttribute(context, operation).isDefined())\n            module = WebValveDefinition.MODULE.resolveModelAttribute(context, operation).asString();\n\n        final boolean enabled = WebValveDefinition.ENABLED.resolveModelAttribute(context, operation).asBoolean();\n        final WebValveService service = new WebValveService(name, classname, module);\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final ServiceBuilder<?> serviceBuilder = serviceTarget.addService(WebSubsystemServices.JBOSS_WEB_VALVE.append(name), service)\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer());\n\n        if (operation.hasDefined(PARAM)) {\n            service.setParam(operation.get(PARAM).clone());\n        }\n\n        serviceBuilder.setInitialMode(enabled ? Mode.ACTIVE : Mode.NEVER);\n        if (enabled)\n            serviceBuilder.addListener(verificationHandler);\n        newControllers.add(serviceBuilder.install());\n    }","id":87285,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode baseOperation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final PathAddress address = PathAddress.pathAddress(baseOperation.get(OP_ADDR));\n\n        final String name = address.getLastElement().getValue();\n        String classname = null;\n        ModelNode resolved;\n        if ((resolved =  WebValveDefinition.CLASS_NAME.resolveModelAttribute(context, fullModel)).isDefined()) {\n            classname = resolved.asString();\n        }\n        String module = null;\n        if ((resolved =  WebValveDefinition.MODULE.resolveModelAttribute(context, fullModel)).isDefined()) {\n            module = resolved.asString();\n        }\n\n        final boolean enabled = WebValveDefinition.ENABLED.resolveModelAttribute(context, fullModel).asBoolean();\n        final WebValveService service = new WebValveService(name, classname, module);\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final ServiceBuilder<?> serviceBuilder = serviceTarget.addService(WebSubsystemServices.JBOSS_WEB_VALVE.append(name), service)\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer());\n\n        if ((resolved =  WebValveDefinition.PARAMS.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setParam(resolved.clone());\n        }\n\n        serviceBuilder.setInitialMode(enabled ? Mode.ACTIVE : Mode.NEVER);\n        if (enabled)\n            serviceBuilder.addListener(verificationHandler);\n        newControllers.add(serviceBuilder.install());\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode baseOperation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        ModelNode operation = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final PathAddress address = PathAddress.pathAddress(baseOperation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        boolean welcome = WebVirtualHostDefinition.ENABLE_WELCOME_ROOT.resolveModelAttribute(context, operation).asBoolean();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final WebVirtualHostService service = new WebVirtualHostService(name, aliases(operation), welcome, TEMP_DIR);\n        final ServiceBuilder<?> serviceBuilder = serviceTarget.addService(WebSubsystemServices.JBOSS_WEB_HOST.append(name), service)\n                .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, service.getPathManagerInjector())\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer());\n        if (operation.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue()).isDefined()) {\n            final ModelNode accessLog = operation.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue());\n            service.setAccessLog(accessLog.clone());\n            service.setAccessLogPaths(getPath(context, accessLog, name), getRelativeTo(context, accessLog, name));\n        }\n        if (operation.hasDefined(Constants.REWRITE)) {\n            service.setRewrite(operation.get(Constants.REWRITE).clone());\n        }\n        if (operation.get(SSO_PATH.getKey(), SSO_PATH.getValue()).isDefined()) {\n            ModelNode sso = operation.get(SSO_PATH.getKey(), SSO_PATH.getValue()).clone();\n            service.setSso(sso);\n            if (sso.hasDefined(Constants.CACHE_CONTAINER)) {\n                ServiceName ssoName = WebSubsystemServices.JBOSS_WEB_HOST.append(name, Constants.SSO);\n                serviceBuilder.addDependency(ssoName, SSOClusterManager.class, service.getSSOClusterManager());\n\n                SSOClusterManagerService ssoService = new SSOClusterManagerService();\n                SSOClusterManager ssoManager = ssoService.getValue();\n                ssoManager.setCacheContainerName(sso.get(Constants.CACHE_CONTAINER).asString());\n                if (sso.hasDefined(Constants.CACHE_NAME)) {\n                    ssoManager.setCacheName(sso.get(Constants.CACHE_NAME).asString());\n                }\n                ServiceBuilder<SSOClusterManager> builder = serviceTarget.addService(ssoName, ssoService);\n                ssoService.getValue().addDependencies(serviceTarget, builder);\n                newControllers.add(builder.setInitialMode(ServiceController.Mode.ON_DEMAND).install());\n            }\n        }\n\n        if (operation.hasDefined(Constants.DEFAULT_WEB_MODULE)) {\n            if (welcome) { throw new OperationFailedException(new ModelNode().set(MESSAGES.noRootWebappWithWelcomeWebapp())); }\n            service.setDefaultWebModule(operation.get(Constants.DEFAULT_WEB_MODULE).asString());\n        }\n\n        serviceBuilder.addListener(verificationHandler);\n        newControllers.add(serviceBuilder.install());\n\n        if (welcome) {\n            final WelcomeContextService welcomeService = new WelcomeContextService(HOME_DIR);\n            newControllers.add(context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB.append(name).append(\"welcome\"), welcomeService)\n                    .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, welcomeService.getPathManagerInjector())\n                    .addDependency(WebSubsystemServices.JBOSS_WEB_HOST.append(name), VirtualHost.class, welcomeService.getHostInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, HttpManagementService.SERVICE_NAME, HttpManagement.class, welcomeService.getHttpManagementInjector())\n                    .addListener(verificationHandler)\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install());\n        }\n    }","id":87286,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode baseOperation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final PathAddress address = PathAddress.pathAddress(baseOperation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        boolean welcome = WebVirtualHostDefinition.ENABLE_WELCOME_ROOT.resolveModelAttribute(context, fullModel).asBoolean();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final WebVirtualHostService service = new WebVirtualHostService(name, aliases(fullModel), welcome, TEMP_DIR);\n        final ServiceBuilder<?> serviceBuilder = serviceTarget.addService(WebSubsystemServices.JBOSS_WEB_HOST.append(name), service)\n                .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, service.getPathManagerInjector())\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getWebServer());\n\n        if (fullModel.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue()).isDefined()) {\n            final ModelNode unresolved = fullModel.get(ACCESS_LOG_PATH.getKey(), ACCESS_LOG_PATH.getValue());\n\n            service.setAccessLog(resolveExpressions(context, unresolved, WebAccessLogDefinition.ACCESS_LOG_ATTRIBUTES));\n\n            final ModelNode accessLogDir = unresolved.get(DIRECTORY_PATH.getKey(), DIRECTORY_PATH.getValue());\n            String relativeTo = WebAccessLogDirectoryDefinition.RELATIVE_TO.resolveModelAttribute(context, accessLogDir).asString();\n            ModelNode pathNode = WebAccessLogDirectoryDefinition.PATH.resolveModelAttribute(context, accessLogDir);\n            service.setAccessLogPaths(pathNode.isDefined() ? pathNode.asString() : name, relativeTo);\n        }\n        if (fullModel.hasDefined(Constants.REWRITE)) {\n            ModelNode resolvedRewrite = resolveRewriteExpressions(context, fullModel.get(Constants.REWRITE));\n            service.setRewrite(resolvedRewrite);\n        }\n        if (fullModel.get(SSO_PATH.getKey(), SSO_PATH.getValue()).isDefined()) {\n            ModelNode sso = resolveExpressions(context, fullModel.get(SSO_PATH.getKey(), SSO_PATH.getValue()).clone(), WebSSODefinition.SSO_ATTRIBUTES);\n            service.setSso(sso);\n            if (sso.hasDefined(Constants.CACHE_CONTAINER)) {\n                ServiceName ssoName = WebSubsystemServices.JBOSS_WEB_HOST.append(name, Constants.SSO);\n                serviceBuilder.addDependency(ssoName, SSOClusterManager.class, service.getSSOClusterManager());\n\n                SSOClusterManagerService ssoService = new SSOClusterManagerService();\n                SSOClusterManager ssoManager = ssoService.getValue();\n                ssoManager.setCacheContainerName(sso.get(Constants.CACHE_CONTAINER).asString());\n                if (sso.hasDefined(Constants.CACHE_NAME)) {\n                    ssoManager.setCacheName(sso.get(Constants.CACHE_NAME).asString());\n                }\n                ServiceBuilder<SSOClusterManager> builder = serviceTarget.addService(ssoName, ssoService);\n                ssoService.getValue().addDependencies(serviceTarget, builder);\n                newControllers.add(builder.setInitialMode(ServiceController.Mode.ON_DEMAND).install());\n            }\n        }\n\n        // Don't follow the standard pattern of resolving and then checking isDefined() here\n        // because the default value from resolving will look like a conflict with 'welcome'\n        if (fullModel.hasDefined(WebVirtualHostDefinition.DEFAULT_WEB_MODULE.getName())) {\n            if (welcome) { throw new OperationFailedException(new ModelNode().set(MESSAGES.noRootWebappWithWelcomeWebapp())); }\n            service.setDefaultWebModule(WebVirtualHostDefinition.DEFAULT_WEB_MODULE.resolveModelAttribute(context, fullModel).asString());\n        }\n\n        serviceBuilder.addListener(verificationHandler);\n        newControllers.add(serviceBuilder.install());\n\n        if (welcome) {\n            final WelcomeContextService welcomeService = new WelcomeContextService(HOME_DIR);\n            newControllers.add(context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB.append(name).append(\"welcome\"), welcomeService)\n                    .addDependency(PathManagerService.SERVICE_NAME, PathManager.class, welcomeService.getPathManagerInjector())\n                    .addDependency(WebSubsystemServices.JBOSS_WEB_HOST.append(name), VirtualHost.class, welcomeService.getHostInjector())\n                    .addDependency(ServiceBuilder.DependencyType.OPTIONAL, HttpManagementService.SERVICE_NAME, HttpManagement.class, welcomeService.getHttpManagementInjector())\n                    .addListener(verificationHandler)\n                    .setInitialMode(ServiceController.Mode.ACTIVE)\n                    .install());\n        }\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"static String getRelativeTo(OperationContext context, ModelNode node, String hostName) throws OperationFailedException {\n        return getPath(context, node, hostName, true);\n    }","id":87287,"modified_method":"private ModelNode resolveRewriteExpressions(OperationContext context, ModelNode unresolvedRewriteChildren) throws OperationFailedException {\n        ModelNode result = new ModelNode();\n        for (Property prop : unresolvedRewriteChildren.asPropertyList()) {\n            ModelNode resolvedParent = resolveExpressions(context, prop.getValue(), WebReWriteDefinition.ATTRIBUTES);\n            result.get(prop.getName()).set(resolvedParent);\n            if (prop.getValue().hasDefined(Constants.CONDITION)) {\n                for (Property conditionProp : prop.getValue().get(Constants.CONDITION).asPropertyList()) {\n                    ModelNode resolvedCondition = resolveExpressions(context, conditionProp.getValue(), WebReWriteConditionDefinition.ATTRIBUTES);\n                    resolvedParent.get(Constants.CONDITION, conditionProp.getName()).set(resolvedCondition);\n                }\n            }\n        }\n        return result;\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"void setSso(final ModelNode sso) {\n        this.sso = sso;\n    }","id":87288,"modified_method":"void setSso(final ModelNode resolvedSsoModel) {\n        this.sso = resolvedSsoModel;\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"void setAccessLog(final ModelNode accessLog) {\n        this.accessLog = accessLog;\n    }","id":87289,"modified_method":"void setAccessLog(final ModelNode resolvedAccessLogModel) {\n        this.accessLog = resolvedAccessLogModel;\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Valve createRewriteValve(final Container container, final ModelNode element) throws StartException {\n        final RewriteValve rewriteValve = new RewriteValve();\n        rewriteValve.setContainer(container);\n        StringBuffer configuration = new StringBuffer();\n        for (final ModelNode rewriteElement : element.asList()) {\n            final ModelNode rewrite = rewriteElement.asProperty().getValue();\n            if (rewrite.has(Constants.CONDITION)) {\n                for (final ModelNode conditionElement : rewrite.get(Constants.CONDITION).asList()) {\n                    final ModelNode condition = conditionElement.asProperty().getValue();\n                    configuration.append(\"RewriteCond \")\n                    .append(condition.get(Constants.TEST).asString())\n                    .append(\" \").append(condition.get(Constants.PATTERN).asString());\n                    if (condition.hasDefined(Constants.FLAGS)) {\n                        configuration.append(\" [\").append(condition.get(Constants.FLAGS).asString()).append(\"]\\r\\n\");\n                    } else {\n                        configuration.append(\"\\r\\n\");\n                    }\n                }\n            }\n            configuration.append(\"RewriteRule \")\n            .append(rewrite.get(Constants.PATTERN).asString())\n            .append(\" \").append(rewrite.get(Constants.SUBSTITUTION).asString());\n            if (rewrite.hasDefined(Constants.FLAGS)) {\n                configuration.append(\" [\").append(rewrite.get(Constants.FLAGS).asString()).append(\"]\\r\\n\");\n            } else {\n                configuration.append(\"\\r\\n\");\n            }\n        }\n        try {\n            rewriteValve.setConfiguration(configuration.toString());\n        } catch(Exception e) {\n            throw new StartException(e);\n        }\n        return rewriteValve;\n    }","id":87290,"modified_method":"static Valve createRewriteValve(final Container container, final ModelNode element) throws StartException {\n        final RewriteValve rewriteValve = new RewriteValve();\n        rewriteValve.setContainer(container);\n        StringBuilder configuration = new StringBuilder();\n        for (final ModelNode rewriteElement : element.asList()) {\n            final ModelNode rewrite = rewriteElement.asProperty().getValue();\n            if (rewrite.has(Constants.CONDITION)) {\n                for (final ModelNode conditionElement : rewrite.get(Constants.CONDITION).asList()) {\n                    final ModelNode condition = conditionElement.asProperty().getValue();\n                    configuration.append(\"RewriteCond \")\n                    .append(condition.get(Constants.TEST).asString())\n                    .append(\" \").append(condition.get(Constants.PATTERN).asString());\n                    if (condition.hasDefined(Constants.FLAGS)) {\n                        configuration.append(\" [\").append(condition.get(Constants.FLAGS).asString()).append(\"]\\r\\n\");\n                    } else {\n                        configuration.append(\"\\r\\n\");\n                    }\n                }\n            }\n            configuration.append(\"RewriteRule \")\n            .append(rewrite.get(Constants.PATTERN).asString())\n            .append(\" \").append(rewrite.get(Constants.SUBSTITUTION).asString());\n            if (rewrite.hasDefined(Constants.FLAGS)) {\n                configuration.append(\" [\").append(rewrite.get(Constants.FLAGS).asString()).append(\"]\\r\\n\");\n            } else {\n                configuration.append(\"\\r\\n\");\n            }\n        }\n        try {\n            rewriteValve.setConfiguration(configuration.toString());\n        } catch(Exception e) {\n            throw new StartException(e);\n        }\n        return rewriteValve;\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Valve createAccessLogValve(final String logDirectory, final ModelNode element) {\n        //todo this should all use AD.resolveModelAttribute()\n        boolean extended = false;\n        if (element.hasDefined(Constants.EXTENDED)) {\n            extended = element.get(Constants.EXTENDED).asBoolean();\n        }\n        String pattern = null;\n        if (element.hasDefined(Constants.PATTERN)) {\n            pattern = element.get(Constants.PATTERN).asString();\n        }\n\n        final AccessLogValve log;\n        if (extended) {\n            log = new ExtendedAccessLogValve();\n        } else {\n            log = new AccessLogValve();\n        }\n        log.setDirectory(logDirectory);\n        if (element.hasDefined(Constants.RESOLVE_HOSTS)) log.setResolveHosts(element.get(Constants.RESOLVE_HOSTS).asBoolean());\n        if (element.hasDefined(Constants.ROTATE)) log.setRotatable(element.get(Constants.ROTATE).asBoolean());\n        if (pattern != null) {\n            log.setPattern(pattern);\n        } else {\n            if (extended) {\n                log.setPattern(\"time cs-method cs-uri sc-status sc(Referer)\");\n            } else {\n                log.setPattern(\"common\");\n            }\n        }\n\n        if (element.hasDefined(Constants.PREFIX)) log.setPrefix(element.get(Constants.PREFIX).asString());\n        return log;\n    }","id":87291,"modified_method":"static Valve createAccessLogValve(final String logDirectory, final ModelNode element) {\n        boolean extended = element.get(Constants.EXTENDED).asBoolean(false);\n        String pattern = null;\n        if (element.hasDefined(Constants.PATTERN)) {\n            pattern = element.get(Constants.PATTERN).asString();\n        }\n\n        final AccessLogValve log;\n        if (extended) {\n            log = new ExtendedAccessLogValve();\n        } else {\n            log = new AccessLogValve();\n        }\n        log.setDirectory(logDirectory);\n        if (element.hasDefined(Constants.RESOLVE_HOSTS)) log.setResolveHosts(element.get(Constants.RESOLVE_HOSTS).asBoolean());\n        if (element.hasDefined(Constants.ROTATE)) log.setRotatable(element.get(Constants.ROTATE).asBoolean());\n        if (pattern != null) {\n            log.setPattern(pattern);\n        } else {\n            if (extended) {\n                log.setPattern(\"time cs-method cs-uri sc-status sc(Referer)\");\n            } else {\n                log.setPattern(\"common\");\n            }\n        }\n\n        if (element.hasDefined(Constants.PREFIX)) log.setPrefix(element.get(Constants.PREFIX).asString());\n        return log;\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"void setRewrite(ModelNode rewrite) {\n        this.rewrite = rewrite;\n    }","id":87292,"modified_method":"void setRewrite(ModelNode resolvedRewriteModel) {\n        this.rewrite = resolvedRewriteModel;\n    }","commit_id":"8cb3bf19b365fe1c5ad8e8745b1e2ee406f0b7b9","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final String bindingRef = WebConnectorDefinition.SOCKET_BINDING.resolveModelAttribute(context, fullModel).asString();\n\n        final boolean enabled = WebConnectorDefinition.ENABLED.resolveModelAttribute(context, fullModel).asBoolean();\n        final String protocol = WebConnectorDefinition.PROTOCOL.resolveModelAttribute(context, fullModel).asString();\n        final String scheme = WebConnectorDefinition.SCHEME.resolveModelAttribute(context, fullModel).asString();\n        final WebConnectorService service = new WebConnectorService(protocol, scheme);\n        service.setSecure(WebConnectorDefinition.SECURE.resolveModelAttribute(context, fullModel).asBoolean());\n        service.setEnableLookups(WebConnectorDefinition.ENABLE_LOOKUPS.resolveModelAttribute(context, fullModel).asBoolean());\n        if (operation.hasDefined(PROXY_NAME)) {\n            service.setProxyName(WebConnectorDefinition.PROXY_NAME.resolveModelAttribute(context, fullModel).asString());\n        }\n        if (operation.hasDefined(PROXY_PORT)) {\n            service.setProxyPort(WebConnectorDefinition.PROXY_PORT.resolveModelAttribute(context, fullModel).asInt());\n        }\n        if (operation.hasDefined(REDIRECT_PORT)) {\n            service.setRedirectPort(WebConnectorDefinition.REDIRECT_PORT.resolveModelAttribute(context, fullModel).asInt());\n        }\n        if (operation.hasDefined(MAX_POST_SIZE)) {\n            service.setMaxPostSize(WebConnectorDefinition.MAX_POST_SIZE.resolveModelAttribute(context, fullModel).asInt());\n        }\n        if (operation.hasDefined(MAX_SAVE_POST_SIZE)) {\n            service.setMaxSavePostSize(WebConnectorDefinition.MAX_SAVE_POST_SIZE.resolveModelAttribute(context, fullModel).asInt());\n        }\n        if (operation.hasDefined(MAX_CONNECTIONS)) {\n            service.setMaxConnections(WebConnectorDefinition.MAX_CONNECTIONS.resolveModelAttribute(context, fullModel).asInt());\n        }\n        if (operation.hasDefined(VIRTUAL_SERVER)) {\n            List<String> vServers = new LinkedList<String>();\n            for (ModelNode vServer:WebConnectorDefinition.VIRTUAL_SERVER.resolveModelAttribute(context,fullModel).asList()){\n                vServers.add(vServer.asString());\n            }\n            service.setVirtualServers(vServers);\n        }\n        if (fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue()).isDefined()) {\n            service.setSsl(resolveExpressions(context, fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue())));\n        }\n        final ServiceBuilder<Connector> serviceBuilder = context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB_CONNECTOR.append(name), service)\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getServer())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(bindingRef), SocketBinding.class, service.getBinding());\n        if (operation.hasDefined(EXECUTOR)) {\n            String executorRef = operation.get(EXECUTOR).asString();\n            serviceBuilder.addDependency(ThreadsServices.executorName(executorRef), Executor.class, service.getExecutor());\n        }\n        serviceBuilder.setInitialMode(enabled ? Mode.ACTIVE : Mode.NEVER);\n        if (enabled) {\n            serviceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController<Connector> serviceController = serviceBuilder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n    }","id":87293,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        ModelNode fullModel = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        final String bindingRef = WebConnectorDefinition.SOCKET_BINDING.resolveModelAttribute(context, fullModel).asString();\n\n        final boolean enabled = WebConnectorDefinition.ENABLED.resolveModelAttribute(context, fullModel).asBoolean();\n        final String protocol = WebConnectorDefinition.PROTOCOL.resolveModelAttribute(context, fullModel).asString();\n        final String scheme = WebConnectorDefinition.SCHEME.resolveModelAttribute(context, fullModel).asString();\n        final WebConnectorService service = new WebConnectorService(protocol, scheme);\n        service.setSecure(WebConnectorDefinition.SECURE.resolveModelAttribute(context, fullModel).asBoolean());\n        service.setEnableLookups(WebConnectorDefinition.ENABLE_LOOKUPS.resolveModelAttribute(context, fullModel).asBoolean());\n        ModelNode resolved;\n        if (operation.hasDefined(PROXY_NAME) && (resolved =  WebConnectorDefinition.PROXY_NAME.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setProxyName(resolved.asString());\n        }\n        if (operation.hasDefined(PROXY_PORT)&& (resolved =  WebConnectorDefinition.PROXY_PORT.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setProxyPort(resolved.asInt());\n        }\n        if (operation.hasDefined(REDIRECT_PORT)&& (resolved =  WebConnectorDefinition.REDIRECT_PORT.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setRedirectPort(resolved.asInt());\n        }\n        if (operation.hasDefined(MAX_POST_SIZE)&& (resolved =  WebConnectorDefinition.MAX_POST_SIZE.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxPostSize(resolved.asInt());\n        }\n        if (operation.hasDefined(MAX_SAVE_POST_SIZE)&& (resolved =  WebConnectorDefinition.MAX_SAVE_POST_SIZE.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxSavePostSize(resolved.asInt());\n        }\n        if (operation.hasDefined(MAX_CONNECTIONS)&& (resolved =  WebConnectorDefinition.MAX_CONNECTIONS.resolveModelAttribute(context, fullModel)).isDefined()) {\n            service.setMaxConnections(resolved.asInt());\n        }\n        if (operation.hasDefined(VIRTUAL_SERVER)&& (resolved =  WebConnectorDefinition.VIRTUAL_SERVER.resolveModelAttribute(context, fullModel)).isDefined()) {\n            List<String> vServers = new LinkedList<String>();\n            for (ModelNode vServer:resolved.asList()){\n                vServers.add(vServer.asString());\n            }\n            service.setVirtualServers(vServers);\n        }\n        if (fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue()).isDefined()) {\n            service.setSsl(resolveExpressions(context, fullModel.get(SSL_PATH.getKey(), SSL_PATH.getValue())));\n        }\n        final ServiceBuilder<Connector> serviceBuilder = context.getServiceTarget().addService(WebSubsystemServices.JBOSS_WEB_CONNECTOR.append(name), service)\n                .addDependency(WebSubsystemServices.JBOSS_WEB, WebServer.class, service.getServer())\n                .addDependency(SocketBinding.JBOSS_BINDING_NAME.append(bindingRef), SocketBinding.class, service.getBinding());\n        if (operation.hasDefined(EXECUTOR)) {\n            String executorRef = operation.get(EXECUTOR).asString();\n            serviceBuilder.addDependency(ThreadsServices.executorName(executorRef), Executor.class, service.getExecutor());\n        }\n        serviceBuilder.setInitialMode(enabled ? Mode.ACTIVE : Mode.NEVER);\n        if (enabled) {\n            serviceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController<Connector> serviceController = serviceBuilder.install();\n        if (newControllers != null) {\n            newControllers.add(serviceController);\n        }\n    }","commit_id":"22382323c5139e01981d436a639273f7b5a5e7d6","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void registerTransformers_1_1_0(SubsystemRegistration registration) {\n\n        final TransformersSubRegistration transformers = registration.registerModelTransformers(ModelVersion.create(1, 1, 0), new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n            @Override\n            protected ModelNode transformModel(TransformationContext context, ModelNode model) {\n                if (model.hasDefined(Constants.CONNECTOR)) {\n                    for (String name : model.get(Constants.CONNECTOR).keys()) {\n                        swap(model.get(Constants.CONNECTOR, name), SSL_PATH, SSL_ALIAS);\n                    }\n                }\n                if (model.hasDefined(Constants.VIRTUAL_SERVER)) {\n                    for (String name : model.get(Constants.VIRTUAL_SERVER).keys()) {\n                        ModelNode virtualServer = model.get(Constants.VIRTUAL_SERVER, name);\n                        swap(virtualServer, SSO_PATH, SSO_ALIAS);\n                        swap(virtualServer, ACCESS_LOG_PATH, ACCESS_LOG_ALIAS);\n                        ModelNode accessLog = virtualServer.get(ACCESS_LOG_ALIAS.getKey(), ACCESS_LOG_ALIAS.getValue());\n                        swap(accessLog, DIRECTORY_PATH, DIRECTORY_ALIAS);\n                    }\n                }\n\n                return model;\n            }\n\n            private void swap(ModelNode parent, PathElement original, PathElement old) {\n                if (parent.hasDefined(original.getKey()) && parent.get(original.getKey()).hasDefined(original.getValue())) {\n                    ModelNode sslConfig = parent.get(original.getKey(),original.getValue());\n                    parent.get(old.getKey(), old.getValue()).set(sslConfig.clone());\n                    parent.get(original.getKey()).remove(original.getValue());\n                    if (parent.get(original.getKey()).asList().isEmpty()){\n                        parent.remove(original.getKey());\n                    }\n                }\n            }\n        });\n\n        TransformersSubRegistration connectors = transformers.registerSubResource(CONNECTOR_PATH);\n        connectors.registerOperationTransformer(ADD, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n\n                //Don't error on the way out, it might be ignored on the slave\n                final boolean hasDefinedVirtualServer = operation.hasDefined(Constants.VIRTUAL_SERVER);\n                return new TransformedOperation(operation, new OperationResultTransformer() {\n\n                    @Override\n                    public ModelNode transformResult(ModelNode result) {\n                        if (!hasDefinedVirtualServer) {\n                            return result;\n                        }\n                        if (result.get(OUTCOME).asString().equals(FAILED)) {\n                            result.get(FAILURE_DESCRIPTION).set(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314());\n                        }\n                        return result;\n                    }\n                });\n            }\n        });\n        connectors.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new OperationTransformer() {\n\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n\n                //Don't error on the way out, it might be ignored on the slave\n                final boolean isVirtualServer = operation.get(NAME).asString().equals(Constants.VIRTUAL_SERVER);\n                return new TransformedOperation(operation, new OperationResultTransformer() {\n\n                    @Override\n                    public ModelNode transformResult(ModelNode result) {\n                        if (!isVirtualServer) {\n                            return result;\n                        }\n                        if (result.get(OUTCOME).asString().equals(FAILED)) {\n                            result.get(FAILURE_DESCRIPTION).set(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314());\n                        }\n                        return result;\n                    }\n                });\n                }\n            });\n\n\n        TransformersSubRegistration ssl = connectors.registerSubResource(SSL_PATH, AliasOperationTransformer.replaceLastElement(SSL_ALIAS));\n        TransformersSubRegistration virtualServer = transformers.registerSubResource(HOST_PATH);\n        TransformersSubRegistration sso = virtualServer.registerSubResource(SSO_PATH, AliasOperationTransformer.replaceLastElement(SSO_ALIAS));\n        TransformersSubRegistration accessLog = virtualServer.registerSubResource(ACCESS_LOG_PATH, AliasOperationTransformer.replaceLastElement(ACCESS_LOG_ALIAS));\n        TransformersSubRegistration accessLogDir = accessLog.registerSubResource(DIRECTORY_PATH, AliasOperationTransformer.create(new AddressTransformer() {\n            @Override\n            public PathAddress transformAddress(PathAddress address) {\n                PathAddress copy = PathAddress.EMPTY_ADDRESS;\n                for (PathElement element : address) {\n                    if (element.getKey().equals(Constants.CONFIGURATION)) {\n                        copy = copy.append(ACCESS_LOG_ALIAS);\n                    } else if (element.getKey().equals(Constants.SETTING)) {\n                        copy = copy.append(DIRECTORY_ALIAS);\n                    } else {\n                        copy = copy.append(element);\n                    }\n                }\n                return copy;\n            }\n        }));\n    }","id":87294,"modified_method":"private void registerTransformers_1_1_0(SubsystemRegistration registration) {\n\n        final TransformersSubRegistration transformers = registration.registerModelTransformers(ModelVersion.create(1, 1, 0), new AbstractSubsystemTransformer(SUBSYSTEM_NAME) {\n            @Override\n            protected ModelNode transformModel(TransformationContext context, ModelNode model) {\n                if (model.hasDefined(Constants.CONNECTOR)) {\n                    for (String name : model.get(Constants.CONNECTOR).keys()) {\n                        swap(model.get(Constants.CONNECTOR, name), SSL_PATH, SSL_ALIAS);\n                    }\n                }\n                if (model.hasDefined(Constants.VIRTUAL_SERVER)) {\n                    for (String name : model.get(Constants.VIRTUAL_SERVER).keys()) {\n                        ModelNode virtualServer = model.get(Constants.VIRTUAL_SERVER, name);\n                        swap(virtualServer, SSO_PATH, SSO_ALIAS);\n                        swap(virtualServer, ACCESS_LOG_PATH, ACCESS_LOG_ALIAS);\n                        ModelNode accessLog = virtualServer.get(ACCESS_LOG_ALIAS.getKey(), ACCESS_LOG_ALIAS.getValue());\n                        swap(accessLog, DIRECTORY_PATH, DIRECTORY_ALIAS);\n                    }\n                }\n\n                return model;\n            }\n\n            private void swap(ModelNode parent, PathElement original, PathElement old) {\n                if (parent.hasDefined(original.getKey()) && parent.get(original.getKey()).hasDefined(original.getValue())) {\n                    ModelNode sslConfig = parent.get(original.getKey(),original.getValue());\n                    parent.get(old.getKey(), old.getValue()).set(sslConfig.clone());\n                    parent.get(original.getKey()).remove(original.getValue());\n                    if (parent.get(original.getKey()).asList().isEmpty()){\n                        parent.remove(original.getKey());\n                    }\n                }\n            }\n        });\n        transformers.registerSubResource(VALVE_PATH, true);\n\n        TransformersSubRegistration connectors = transformers.registerSubResource(CONNECTOR_PATH);\n        connectors.registerOperationTransformer(ADD, new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n\n                //Don't error on the way out, it might be ignored on the slave\n                final boolean hasDefinedVirtualServer = operation.hasDefined(Constants.VIRTUAL_SERVER);\n                return new TransformedOperation(operation, new OperationResultTransformer() {\n\n                    @Override\n                    public ModelNode transformResult(ModelNode result) {\n                        if (!hasDefinedVirtualServer) {\n                            return result;\n                        }\n                        if (result.get(OUTCOME).asString().equals(FAILED)) {\n                            result.get(FAILURE_DESCRIPTION).set(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314());\n                        }\n                        return result;\n                    }\n                });\n            }\n        });\n        connectors.registerOperationTransformer(WRITE_ATTRIBUTE_OPERATION, new OperationTransformer() {\n\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext context, final PathAddress address, final ModelNode operation)\n                    throws OperationFailedException {\n\n                //Don't error on the way out, it might be ignored on the slave\n                final boolean isVirtualServer = operation.get(NAME).asString().equals(Constants.VIRTUAL_SERVER);\n                return new TransformedOperation(operation, new OperationResultTransformer() {\n\n                    @Override\n                    public ModelNode transformResult(ModelNode result) {\n                        if (!isVirtualServer) {\n                            return result;\n                        }\n                        if (result.get(OUTCOME).asString().equals(FAILED)) {\n                            result.get(FAILURE_DESCRIPTION).set(WebMessages.MESSAGES.transformationVersion_1_1_0_JBPAPP_9314());\n                        }\n                        return result;\n                    }\n                });\n                }\n            });\n\n\n        TransformersSubRegistration ssl = connectors.registerSubResource(SSL_PATH, AliasOperationTransformer.replaceLastElement(SSL_ALIAS));\n        TransformersSubRegistration virtualServer = transformers.registerSubResource(HOST_PATH);\n        TransformersSubRegistration sso = virtualServer.registerSubResource(SSO_PATH, AliasOperationTransformer.replaceLastElement(SSO_ALIAS));\n        TransformersSubRegistration accessLog = virtualServer.registerSubResource(ACCESS_LOG_PATH, AliasOperationTransformer.replaceLastElement(ACCESS_LOG_ALIAS));\n        TransformersSubRegistration accessLogDir = accessLog.registerSubResource(DIRECTORY_PATH, AliasOperationTransformer.create(new AddressTransformer() {\n            @Override\n            public PathAddress transformAddress(PathAddress address) {\n                PathAddress copy = PathAddress.EMPTY_ADDRESS;\n                for (PathElement element : address) {\n                    if (element.getKey().equals(Constants.CONFIGURATION)) {\n                        copy = copy.append(ACCESS_LOG_ALIAS);\n                    } else if (element.getKey().equals(Constants.SETTING)) {\n                        copy = copy.append(DIRECTORY_ALIAS);\n                    } else {\n                        copy = copy.append(element);\n                    }\n                }\n                return copy;\n            }\n        }));\n    }","commit_id":"22382323c5139e01981d436a639273f7b5a5e7d6","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected AlertCondition getDummyAlertCondition(Map<String, Object> parameters) {\n        return new AlertCondition(core, stream, CONDITION_ID, null, Tools.iso8601(), STREAM_CREATOR, parameters) {\n            @Override\n            public String getDescription() {\n                return null;  //To change body of implemented methods use File | Settings | File Templates.\n            }\n\n            @Override\n            protected CheckResult runCheck() {\n                return null;  //To change body of implemented methods use File | Settings | File Templates.\n            }\n        };\n    }","id":87295,"modified_method":"protected AlertCondition getDummyAlertCondition(Map<String, Object> parameters) {\n        return new AlertCondition(core, stream, CONDITION_ID, null, Tools.iso8601(), STREAM_CREATOR, parameters) {\n            @Override\n            public String getDescription() {\n                return null;\n            }\n\n            @Override\n            protected CheckResult runCheck() {\n                return null;\n            }\n\n            @Override\n            public SearchHits getSearchHits() {\n                return null;\n            }\n        };\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public CheckResult(boolean isTriggered) {\n            this(false, null, null, null);\n        }","id":87296,"modified_method":"public CheckResult(boolean isTriggered) {\n            this(false, null, null, null);\n            if (isTriggered)\n                throw new RuntimeException(\"Boolean only constructor should only be called if CheckResult is not triggered!\");\n        }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(core);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, core);\n                        alert.save();\n\n                        // Send alerts.\n                        if (stream.getAlertReceivers().size() > 0) {\n                            try {\n                                AlertSender sender = new AlertSender(core);\n                                sender.sendEmails(stream, result);\n                            } catch (TransportConfigurationException e) {\n                                Notification notification = Notification.buildNow(server)\n                                        .addThisNode()\n                                        .addType(Notification.Type.EMAIL_TRANSPORT_CONFIGURATION_INVALID)\n                                        .addDetail(\"stream_id\", stream.getId())\n                                        .addDetail(\"exception\", e);\n                                notification.publishIfFirst();\n                                LOG.warn(\"Stream [{}] has alert receivers and is triggered, but email transport is not configured.\", stream);\n                            } catch (Exception e) {\n                                Notification notification = Notification.buildNow(server)\n                                        .addThisNode()\n                                        .addType(Notification.Type.EMAIL_TRANSPORT_FAILED)\n                                        .addDetail(\"stream_id\", stream.getId())\n                                        .addDetail(\"exception\", e);\n                                notification.publishIfFirst();\n                                LOG.error(\"Stream [{}] has alert receivers and is triggered, but sending emails failed\", stream, e);\n                            }\n                        }\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","id":87297,"modified_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(core);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, core);\n                        alert.save();\n\n                        // Send alerts.\n                        if (stream.getAlertReceivers().size() > 0) {\n                            try {\n                                AlertSender sender = new AlertSender(core);\n                                if (alertCondition.getBacklog() > 0 && alertCondition.getSearchHits() != null) {\n                                    List<Message> backlog = Lists.newArrayList();\n                                    for (SearchHit searchHit : alertCondition.getSearchHits().getHits()) {\n                                        backlog.add(new Message(searchHit.getSource()));\n                                    }\n                                    sender.sendEmails(stream, result, backlog.subList(0, alertCondition.getBacklog()));\n                                } else {\n                                    sender.sendEmails(stream, result);\n                                }\n                            } catch (TransportConfigurationException e) {\n                                Notification notification = Notification.buildNow(server)\n                                        .addThisNode()\n                                        .addType(Notification.Type.EMAIL_TRANSPORT_CONFIGURATION_INVALID)\n                                        .addDetail(\"stream_id\", stream.getId())\n                                        .addDetail(\"exception\", e);\n                                notification.publishIfFirst();\n                                LOG.warn(\"Stream [{}] has alert receivers and is triggered, but email transport is not configured.\", stream);\n                            } catch (Exception e) {\n                                Notification notification = Notification.buildNow(server)\n                                        .addThisNode()\n                                        .addType(Notification.Type.EMAIL_TRANSPORT_FAILED)\n                                        .addDetail(\"stream_id\", stream.getId())\n                                        .addDetail(\"exception\", e);\n                                notification.publishIfFirst();\n                                LOG.error(\"Stream [{}] has alert receivers and is triggered, but sending emails failed\", stream, e);\n                            }\n                        }\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        Email email = new SimpleEmail();\n        email.setHostName(core.getConfiguration().getEmailTransportHostname());\n        email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n        if (core.getConfiguration().isEmailTransportUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n        }\n\n        if(core.getConfiguration().isEmailTransportUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    core.getConfiguration().getEmailTransportUsername(),\n                    core.getConfiguration().getEmailTransportPassword()\n            ));\n        }\n\n        email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n        email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n        email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n        email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n        email.setMsg(buildBody(stream, checkResult));\n        email.addTo(emailAddress);\n\n        email.send();\n    }","id":87298,"modified_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult, List<Message> backlog) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        Email email = new SimpleEmail();\n        email.setHostName(core.getConfiguration().getEmailTransportHostname());\n        email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n        if (core.getConfiguration().isEmailTransportUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n        }\n\n        if(core.getConfiguration().isEmailTransportUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    core.getConfiguration().getEmailTransportUsername(),\n                    core.getConfiguration().getEmailTransportPassword()\n            ));\n        }\n\n        email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n        email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n        email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n        email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n\n        StringBuilder body = new StringBuilder();\n        body.append(buildBody(stream, checkResult));\n        if (backlog != null) {\n            body.append(buildBacklogSummary(backlog));\n        }\n        email.setMsg(body.toString());\n        email.addTo(emailAddress);\n\n        email.send();\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        if (stream.getAlertReceivers() == null || stream.getAlertReceivers().isEmpty()) {\n            throw new RuntimeException(\"Stream [\" + stream + \"] has no alert receivers.\");\n        }\n\n        // Send emails to subscribed users.\n        if(stream.getAlertReceivers().get(\"users\") != null) {\n            for (String username : stream.getAlertReceivers().get(\"users\")) {\n                User user = User.load(username, core);\n\n                if(user != null && user.getEmail() != null && !user.getEmail().isEmpty()) {\n                    sendEmail(user.getEmail(), stream, checkResult);\n                }\n            }\n        }\n\n        // Send emails to directly subscribed email addresses.\n        if(stream.getAlertReceivers().get(\"emails\") != null) {\n            for (String email : stream.getAlertReceivers().get(\"emails\")) {\n                if(!email.isEmpty()) {\n                    sendEmail(email, stream, checkResult);\n                }\n            }\n        }\n\n    }","id":87299,"modified_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        sendEmails(stream, checkResult, null);\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected CheckResult runCheck() {\n        try {\n            String filter = \"streams:\"+stream.getId();\n            FieldStatsResult fieldStatsResult = core.getIndexer().searches().fieldStats(field, \"*\", filter, new RelativeRange(time * 60));\n\n            if (fieldStatsResult.getCount() == 0) {\n                LOG.debug(\"Alert check <{}> did not match any messages. Returning not triggered.\", type);\n                return new CheckResult(false);\n            }\n\n            double result;\n            switch (type) {\n                case MEAN:\n                    result = fieldStatsResult.getMean();\n                    break;\n                case MIN:\n                    result = fieldStatsResult.getMin();\n                    break;\n                case MAX:\n                    result = fieldStatsResult.getMax();\n                    break;\n                case SUM:\n                    result = fieldStatsResult.getSum();\n                    break;\n                case STDDEV:\n                    result = fieldStatsResult.getStdDeviation();\n                    break;\n                default:\n                    LOG.error(\"No such field value check type: [{}]. Returning not triggered.\", type);\n                    return new CheckResult(false);\n            }\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, result);\n\n            if(Double.isInfinite(result)) {\n                // This happens when there are no ES results/docs.\n                LOG.debug(\"Infinite value. Returning not triggered.\");\n                return new CheckResult(false);\n            }\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case HIGHER:\n                    triggered = result > threshold.doubleValue();\n                    break;\n                case LOWER:\n                    triggered = result < threshold.doubleValue();\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Field \").append(field).append(\" had a \")\n                        .append(type.toString().toLowerCase()).append(\" of \")\n                        .append(result).append(\" in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\". \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        } catch (Searches.FieldTypeException e) {\n            LOG.debug(\"Field [{}] seems not to have a numerical type or doesn't even exist at all. Returning not triggered.\", field, e);\n            return new CheckResult(false);\n        }\n    }","id":87300,"modified_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = null;\n        try {\n            String filter = \"streams:\"+stream.getId();\n            FieldStatsResult fieldStatsResult = core.getIndexer().searches().fieldStats(field, \"*\", filter, new RelativeRange(time * 60));\n            this.searchHits = fieldStatsResult.getSearchHits();\n\n            if (fieldStatsResult.getCount() == 0) {\n                LOG.debug(\"Alert check <{}> did not match any messages. Returning not triggered.\", type);\n                return new CheckResult(false);\n            }\n\n            double result;\n            switch (type) {\n                case MEAN:\n                    result = fieldStatsResult.getMean();\n                    break;\n                case MIN:\n                    result = fieldStatsResult.getMin();\n                    break;\n                case MAX:\n                    result = fieldStatsResult.getMax();\n                    break;\n                case SUM:\n                    result = fieldStatsResult.getSum();\n                    break;\n                case STDDEV:\n                    result = fieldStatsResult.getStdDeviation();\n                    break;\n                default:\n                    LOG.error(\"No such field value check type: [{}]. Returning not triggered.\", type);\n                    return new CheckResult(false);\n            }\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, result);\n\n            if(Double.isInfinite(result)) {\n                // This happens when there are no ES results/docs.\n                LOG.debug(\"Infinite value. Returning not triggered.\");\n                return new CheckResult(false);\n            }\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case HIGHER:\n                    triggered = result > threshold.doubleValue();\n                    break;\n                case LOWER:\n                    triggered = result < threshold.doubleValue();\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Field \").append(field).append(\" had a \")\n                        .append(type.toString().toLowerCase()).append(\" of \")\n                        .append(result).append(\" in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\". \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        } catch (Searches.FieldTypeException e) {\n            LOG.debug(\"Field [{}] seems not to have a numerical type or doesn't even exist at all. Returning not triggered.\", field, e);\n            return new CheckResult(false);\n        }\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected CheckResult runCheck() {\n        try {\n            String filter = \"streams:\"+stream.getId();\n            long count = core.getIndexer().searches().count(\"*\", new RelativeRange(time * 60), filter).getCount();\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, count);\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case MORE:\n                    triggered = count > threshold;\n                    break;\n                case LESS:\n                    triggered = count < threshold;\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Stream had \").append(count).append(\" messages in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\" messages. \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        }\n    }","id":87301,"modified_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = null;\n        try {\n            String filter = \"streams:\"+stream.getId();\n            CountResult result = core.getIndexer().searches().count(\"*\", new RelativeRange(time * 60), filter);\n            long count = result.getCount();\n            this.searchHits = result.getSearchHits();\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, count);\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case MORE:\n                    triggered = count > threshold;\n                    break;\n                case LESS:\n                    triggered = count < threshold;\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Stream had \").append(count).append(\" messages in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\" messages. \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        }\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public CountResult count(String query, TimeRange range, String filter) throws IndexHelper.InvalidRangeFormatException {\n        Set<String> indices = IndexHelper.determineAffectedIndices(server, range);\n\n        SearchRequest request;\n        if (filter == null) {\n            request = standardSearchRequest(query, indices, range).request();\n        } else {\n            request = filteredSearchRequest(query, filter, indices, range).request();\n        }\n        request.searchType(SearchType.COUNT);\n\n        SearchResponse r = c.search(request).actionGet();\n        return new CountResult(r.getHits().getTotalHits(), r.getTookInMillis());\n    }","id":87302,"modified_method":"public CountResult count(String query, TimeRange range, String filter) throws IndexHelper.InvalidRangeFormatException {\n        Set<String> indices = IndexHelper.determineAffectedIndices(server, range);\n\n        SearchRequest request;\n        if (filter == null) {\n            request = standardSearchRequest(query, indices, range).request();\n        } else {\n            request = filteredSearchRequest(query, filter, indices, range).request();\n        }\n        request.searchType(SearchType.COUNT);\n\n        SearchResponse r = c.search(request).actionGet();\n        return new CountResult(r.getHits().getTotalHits(), r.getTookInMillis(), r.getHits());\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public FieldStatsResult fieldStats(String field, String query, String filter, TimeRange range) throws FieldTypeException, IndexHelper.InvalidRangeFormatException {\n        SearchRequestBuilder srb;\n\n        if (filter == null) {\n            srb = standardSearchRequest(query, IndexHelper.determineAffectedIndices(server, range));\n        } else {\n            srb = filteredSearchRequest(query, filter, IndexHelper.determineAffectedIndices(server, range));\n        }\n\n        StatisticalFacetBuilder stats = new StatisticalFacetBuilder(STATS_FACET_NAME);\n        stats.global(false);\n\n        stats.facetFilter(standardFilters(range, filter));\n\n        stats.field(field);\n\n        srb.addFacet(stats);\n\n        SearchResponse r;\n        final SearchRequest request;\n        try {\n            request = srb.request();\n            r = c.search(request).actionGet();\n        }  catch (org.elasticsearch.action.search.SearchPhaseExecutionException e) {\n            throw new FieldTypeException(e);\n        }\n\n        return new FieldStatsResult(\n                (StatisticalFacet) r.getFacets().facet(STATS_FACET_NAME),\n                query,\n                request.source(),\n                r.getTook()\n        );\n    }","id":87303,"modified_method":"public FieldStatsResult fieldStats(String field, String query, String filter, TimeRange range) throws FieldTypeException, IndexHelper.InvalidRangeFormatException {\n        SearchRequestBuilder srb;\n\n        if (filter == null) {\n            srb = standardSearchRequest(query, IndexHelper.determineAffectedIndices(server, range));\n        } else {\n            srb = filteredSearchRequest(query, filter, IndexHelper.determineAffectedIndices(server, range));\n        }\n\n        StatisticalFacetBuilder stats = new StatisticalFacetBuilder(STATS_FACET_NAME);\n        stats.global(false);\n\n        stats.facetFilter(standardFilters(range, filter));\n\n        stats.field(field);\n\n        srb.addFacet(stats);\n\n        SearchResponse r;\n        final SearchRequest request;\n        try {\n            request = srb.request();\n            r = c.search(request).actionGet();\n        }  catch (org.elasticsearch.action.search.SearchPhaseExecutionException e) {\n            throw new FieldTypeException(e);\n        }\n\n        return new FieldStatsResult(\n                (StatisticalFacet) r.getFacets().facet(STATS_FACET_NAME),\n                r.getHits(),\n                query,\n                request.source(),\n                r.getTook()\n        );\n    }","commit_id":"5ae43fcbf8333546501f6a14534a3c5345605771","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(server);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, server);\n                        alert.save();\n\n                        // Send alerts.\n                        AlertSender sender = new AlertSender(server);\n                        sender.sendEmails(stream, result);\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","id":87304,"modified_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(server);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, server);\n                        alert.save();\n\n                        // Send alerts.\n                        if (stream.getAlertReceivers().size() > 0) {\n                            try {\n                                AlertSender sender = new AlertSender(server);\n                                sender.sendEmails(stream, result);\n                            } catch (TransportConfigurationException e) {\n                                LOG.warn(\"Stream [{}] has alert receivers and is triggered, but email transport is not configured.\", stream);\n                            } catch (Exception e) {\n                                LOG.error(\"Stream [{}] has alert receivers and is triggered, but sending emails failed: \", stream, e);\n                            }\n                        }\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","commit_id":"236c43a20186ecea056afb2b1ec956e7a0ab7c47","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            LOG.info(\"Email transport is disabled. Not sending email alerts.\");\n            return;\n        }\n\n        if (stream.getAlertReceivers() == null || stream.getAlertReceivers().isEmpty()) {\n            LOG.debug(\"Stream [{}] has no alert receivers.\", stream);\n            return;\n        }\n\n        // Send emails to subscribed users.\n        if(stream.getAlertReceivers().get(\"users\") != null) {\n            for (String username : stream.getAlertReceivers().get(\"users\")) {\n                User user = User.load(username, core);\n\n                if(user != null && user.getEmail() != null && !user.getEmail().isEmpty()) {\n                    sendEmail(user.getEmail(), stream, checkResult);\n                }\n            }\n        }\n\n        // Send emails to directly subscribed email addresses.\n        if(stream.getAlertReceivers().get(\"emails\") != null) {\n            for (String email : stream.getAlertReceivers().get(\"emails\")) {\n                if(!email.isEmpty()) {\n                    sendEmail(email, stream, checkResult);\n                }\n            }\n        }\n\n    }","id":87305,"modified_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        if (stream.getAlertReceivers() == null || stream.getAlertReceivers().isEmpty()) {\n            throw new RuntimeException(\"Stream [\" + stream + \"] has no alert receivers.\");\n        }\n\n        // Send emails to subscribed users.\n        if(stream.getAlertReceivers().get(\"users\") != null) {\n            for (String username : stream.getAlertReceivers().get(\"users\")) {\n                User user = User.load(username, core);\n\n                if(user != null && user.getEmail() != null && !user.getEmail().isEmpty()) {\n                    sendEmail(user.getEmail(), stream, checkResult);\n                }\n            }\n        }\n\n        // Send emails to directly subscribed email addresses.\n        if(stream.getAlertReceivers().get(\"emails\") != null) {\n            for (String email : stream.getAlertReceivers().get(\"emails\")) {\n                if(!email.isEmpty()) {\n                    sendEmail(email, stream, checkResult);\n                }\n            }\n        }\n\n    }","commit_id":"236c43a20186ecea056afb2b1ec956e7a0ab7c47","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult) {\n        try {\n            Email email = new SimpleEmail();\n            email.setHostName(core.getConfiguration().getEmailTransportHostname());\n            email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n            if (core.getConfiguration().isEmailTransportUseSsl()) {\n                email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n            }\n\n            if(core.getConfiguration().isEmailTransportUseAuth()) {\n                email.setAuthenticator(new DefaultAuthenticator(\n                        core.getConfiguration().getEmailTransportUsername(),\n                        core.getConfiguration().getEmailTransportPassword()\n                ));\n            }\n\n            email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n            email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n            email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n            email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n            email.setMsg(buildBody(stream, checkResult));\n            email.addTo(emailAddress);\n\n            email.send();\n        } catch(EmailException e) {\n            LOG.error(\"Could not send alert email.\", e);\n        }\n    }","id":87306,"modified_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        Email email = new SimpleEmail();\n        email.setHostName(core.getConfiguration().getEmailTransportHostname());\n        email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n        if (core.getConfiguration().isEmailTransportUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n        }\n\n        if(core.getConfiguration().isEmailTransportUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    core.getConfiguration().getEmailTransportUsername(),\n                    core.getConfiguration().getEmailTransportPassword()\n            ));\n        }\n\n        email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n        email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n        email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n        email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n        email.setMsg(buildBody(stream, checkResult));\n        email.addTo(emailAddress);\n\n        email.send();\n    }","commit_id":"236c43a20186ecea056afb2b1ec956e7a0ab7c47","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(server);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, server);\n                        alert.save();\n\n                        // Send alerts.\n                        AlertSender sender = new AlertSender(server);\n                        sender.sendEmails(stream, result);\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","id":87307,"modified_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(server);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, server);\n                        alert.save();\n\n                        // Send alerts.\n                        if (stream.getAlertReceivers().size() > 0) {\n                            try {\n                                AlertSender sender = new AlertSender(server);\n                                sender.sendEmails(stream, result);\n                            } catch (TransportConfigurationException e) {\n                                LOG.warn(\"Stream [{}] has alert receivers and is triggered, but email transport is not configured.\", stream);\n                            } catch (Exception e) {\n                                LOG.error(\"Stream [{}] has alert receivers and is triggered, but sending emails failed: \", stream, e);\n                            }\n                        }\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","commit_id":"19938c95d0a8a6321d3d0e583c8a3e22467c21d3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            LOG.info(\"Email transport is disabled. Not sending email alerts.\");\n            return;\n        }\n\n        if (stream.getAlertReceivers() == null || stream.getAlertReceivers().isEmpty()) {\n            LOG.debug(\"Stream [{}] has no alert receivers.\", stream);\n            return;\n        }\n\n        // Send emails to subscribed users.\n        if(stream.getAlertReceivers().get(\"users\") != null) {\n            for (String username : stream.getAlertReceivers().get(\"users\")) {\n                User user = User.load(username, core);\n\n                if(user != null && user.getEmail() != null && !user.getEmail().isEmpty()) {\n                    sendEmail(user.getEmail(), stream, checkResult);\n                }\n            }\n        }\n\n        // Send emails to directly subscribed email addresses.\n        if(stream.getAlertReceivers().get(\"emails\") != null) {\n            for (String email : stream.getAlertReceivers().get(\"emails\")) {\n                if(!email.isEmpty()) {\n                    sendEmail(email, stream, checkResult);\n                }\n            }\n        }\n\n    }","id":87308,"modified_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        if (stream.getAlertReceivers() == null || stream.getAlertReceivers().isEmpty()) {\n            throw new RuntimeException(\"Stream [\" + stream + \"] has no alert receivers.\");\n        }\n\n        // Send emails to subscribed users.\n        if(stream.getAlertReceivers().get(\"users\") != null) {\n            for (String username : stream.getAlertReceivers().get(\"users\")) {\n                User user = User.load(username, core);\n\n                if(user != null && user.getEmail() != null && !user.getEmail().isEmpty()) {\n                    sendEmail(user.getEmail(), stream, checkResult);\n                }\n            }\n        }\n\n        // Send emails to directly subscribed email addresses.\n        if(stream.getAlertReceivers().get(\"emails\") != null) {\n            for (String email : stream.getAlertReceivers().get(\"emails\")) {\n                if(!email.isEmpty()) {\n                    sendEmail(email, stream, checkResult);\n                }\n            }\n        }\n\n    }","commit_id":"19938c95d0a8a6321d3d0e583c8a3e22467c21d3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult) {\n        try {\n            Email email = new SimpleEmail();\n            email.setHostName(core.getConfiguration().getEmailTransportHostname());\n            email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n            if (core.getConfiguration().isEmailTransportUseSsl()) {\n                email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n            }\n\n            if(core.getConfiguration().isEmailTransportUseAuth()) {\n                email.setAuthenticator(new DefaultAuthenticator(\n                        core.getConfiguration().getEmailTransportUsername(),\n                        core.getConfiguration().getEmailTransportPassword()\n                ));\n            }\n\n            email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n            email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n            email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n            email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n            email.setMsg(buildBody(stream, checkResult));\n            email.addTo(emailAddress);\n\n            email.send();\n        } catch(EmailException e) {\n            LOG.error(\"Could not send alert email.\", e);\n        }\n    }","id":87309,"modified_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        Email email = new SimpleEmail();\n        email.setHostName(core.getConfiguration().getEmailTransportHostname());\n        email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n        if (core.getConfiguration().isEmailTransportUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n        }\n\n        if(core.getConfiguration().isEmailTransportUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    core.getConfiguration().getEmailTransportUsername(),\n                    core.getConfiguration().getEmailTransportPassword()\n            ));\n        }\n\n        email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n        email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n        email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n        email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n        email.setMsg(buildBody(stream, checkResult));\n        email.addTo(emailAddress);\n\n        email.send();\n    }","commit_id":"19938c95d0a8a6321d3d0e583c8a3e22467c21d3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"protected AlertCondition getDummyAlertCondition(Map<String, Object> parameters) {\n        return new AlertCondition(core, stream, CONDITION_ID, null, Tools.iso8601(), STREAM_CREATOR, parameters) {\n            @Override\n            public String getDescription() {\n                return null;  //To change body of implemented methods use File | Settings | File Templates.\n            }\n\n            @Override\n            protected CheckResult runCheck() {\n                return null;  //To change body of implemented methods use File | Settings | File Templates.\n            }\n        };\n    }","id":87310,"modified_method":"protected AlertCondition getDummyAlertCondition(Map<String, Object> parameters) {\n        return new AlertCondition(core, stream, CONDITION_ID, null, Tools.iso8601(), STREAM_CREATOR, parameters) {\n            @Override\n            public String getDescription() {\n                return null;\n            }\n\n            @Override\n            protected CheckResult runCheck() {\n                return null;\n            }\n\n            @Override\n            public SearchHits getSearchHits() {\n                return null;\n            }\n        };\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public CheckResult(boolean isTriggered) {\n            this(false, null, null, null);\n        }","id":87311,"modified_method":"public CheckResult(boolean isTriggered) {\n            this(false, null, null, null);\n            if (isTriggered)\n                throw new RuntimeException(\"Boolean only constructor should only be called if CheckResult is not triggered!\");\n        }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(core);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, core);\n                        alert.save();\n\n                        // Send alerts.\n                        if (stream.getAlertReceivers().size() > 0) {\n                            try {\n                                AlertSender sender = new AlertSender(core);\n                                sender.sendEmails(stream, result);\n                            } catch (TransportConfigurationException e) {\n                                LOG.warn(\"Stream [{}] has alert receivers and is triggered, but email transport is not configured.\", stream);\n                            } catch (Exception e) {\n                                LOG.error(\"Stream [{}] has alert receivers and is triggered, but sending emails failed: \", stream, e);\n                            }\n                        }\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","id":87312,"modified_method":"@Override\n    public void run() {\n        LOG.debug(\"Running alert checks.\");\n\n        List<Stream> alertedStreams = StreamImpl.loadAllWithConfiguredAlertConditions(core);\n\n        LOG.debug(\"There are {}streams with configured alert conditions.\", alertedStreams.size());\n\n        // Load all streams that have configured alert conditions.\n        for (Stream streamIF : alertedStreams) {\n            StreamImpl stream = (StreamImpl) streamIF;\n\n            LOG.debug(\"Stream [{}] has [{}] configured alert conditions.\", stream, stream.getAlertConditions().size());\n\n            // Check if a threshold is reached.\n            for (AlertCondition alertCondition : stream.getAlertConditions()) {\n                try {\n                    AlertCondition.CheckResult result = alertCondition.triggered();\n                    if (result.isTriggered()) {\n                        // Alert is triggered!\n                        LOG.info(\"Alert condition [{}] is triggered. Sending alerts.\", alertCondition);\n\n                        // Persist alert.\n                        Alert alert = Alert.factory(result, core);\n                        alert.save();\n\n                        // Send alerts.\n                        if (stream.getAlertReceivers().size() > 0) {\n                            try {\n                                AlertSender sender = new AlertSender(core);\n                                if (alertCondition.getBacklog() > 0 && alertCondition.getSearchHits() != null) {\n                                    List<Message> backlog = Lists.newArrayList();\n                                    for (SearchHit searchHit : alertCondition.getSearchHits().getHits()) {\n                                        backlog.add(new Message(searchHit.getSource()));\n                                    }\n                                    sender.sendEmails(stream, result, backlog.subList(0, alertCondition.getBacklog()));\n                                } else {\n                                    sender.sendEmails(stream, result);\n                                }\n                            } catch (TransportConfigurationException e) {\n                                LOG.warn(\"Stream [{}] has alert receivers and is triggered, but email transport is not configured.\", stream);\n                            } catch (Exception e) {\n                                LOG.error(\"Stream [{}] has alert receivers and is triggered, but sending emails failed: \", stream, e);\n                            }\n                        }\n                    } else {\n                        // Alert not triggered.\n                        LOG.debug(\"Alert condition [{}]is triggered.\", alertCondition);\n                    }\n                } catch(Exception e) {\n                    LOG.error(\"Skipping alert check that threw an exception.\", e);\n                    continue;\n                }\n            }\n\n        }\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        if (stream.getAlertReceivers() == null || stream.getAlertReceivers().isEmpty()) {\n            throw new RuntimeException(\"Stream [\" + stream + \"] has no alert receivers.\");\n        }\n\n        // Send emails to subscribed users.\n        if(stream.getAlertReceivers().get(\"users\") != null) {\n            for (String username : stream.getAlertReceivers().get(\"users\")) {\n                User user = User.load(username, core);\n\n                if(user != null && user.getEmail() != null && !user.getEmail().isEmpty()) {\n                    sendEmail(user.getEmail(), stream, checkResult);\n                }\n            }\n        }\n\n        // Send emails to directly subscribed email addresses.\n        if(stream.getAlertReceivers().get(\"emails\") != null) {\n            for (String email : stream.getAlertReceivers().get(\"emails\")) {\n                if(!email.isEmpty()) {\n                    sendEmail(email, stream, checkResult);\n                }\n            }\n        }\n\n    }","id":87313,"modified_method":"public void sendEmails(StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        sendEmails(stream, checkResult, null);\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        Email email = new SimpleEmail();\n        email.setHostName(core.getConfiguration().getEmailTransportHostname());\n        email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n        if (core.getConfiguration().isEmailTransportUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n        }\n\n        if(core.getConfiguration().isEmailTransportUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    core.getConfiguration().getEmailTransportUsername(),\n                    core.getConfiguration().getEmailTransportPassword()\n            ));\n        }\n\n        email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n        email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n        email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n        email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n        email.setMsg(buildBody(stream, checkResult));\n        email.addTo(emailAddress);\n\n        email.send();\n    }","id":87314,"modified_method":"private void sendEmail(String emailAddress, StreamImpl stream, AlertCondition.CheckResult checkResult, List<Message> backlog) throws TransportConfigurationException, EmailException {\n        if(!core.getConfiguration().isEmailTransportEnabled()) {\n            throw new TransportConfigurationException();\n        }\n\n        Email email = new SimpleEmail();\n        email.setHostName(core.getConfiguration().getEmailTransportHostname());\n        email.setSmtpPort(core.getConfiguration().getEmailTransportPort());\n        if (core.getConfiguration().isEmailTransportUseSsl()) {\n            email.setSslSmtpPort(Integer.toString(core.getConfiguration().getEmailTransportPort()));\n        }\n\n        if(core.getConfiguration().isEmailTransportUseAuth()) {\n            email.setAuthenticator(new DefaultAuthenticator(\n                    core.getConfiguration().getEmailTransportUsername(),\n                    core.getConfiguration().getEmailTransportPassword()\n            ));\n        }\n\n        email.setSSLOnConnect(core.getConfiguration().isEmailTransportUseSsl());\n        email.setStartTLSEnabled(core.getConfiguration().isEmailTransportUseTls());\n        email.setFrom(core.getConfiguration().getEmailTransportFromEmail());\n        email.setSubject(buildSubject(stream, checkResult, core.getConfiguration()));\n\n        StringBuilder body = new StringBuilder();\n        body.append(buildBody(stream, checkResult));\n        if (backlog != null) {\n            body.append(buildBacklogSummary(backlog));\n        }\n        email.setMsg(body.toString());\n        email.addTo(emailAddress);\n\n        email.send();\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected CheckResult runCheck() {\n        try {\n            String filter = \"streams:\"+stream.getId();\n            FieldStatsResult fieldStatsResult = core.getIndexer().searches().fieldStats(field, \"*\", filter, new RelativeRange(time * 60));\n\n            if (fieldStatsResult.getCount() == 0) {\n                LOG.debug(\"Alert check <{}> did not match any messages. Returning not triggered.\", type);\n                return new CheckResult(false);\n            }\n\n            double result;\n            switch (type) {\n                case MEAN:\n                    result = fieldStatsResult.getMean();\n                    break;\n                case MIN:\n                    result = fieldStatsResult.getMin();\n                    break;\n                case MAX:\n                    result = fieldStatsResult.getMax();\n                    break;\n                case SUM:\n                    result = fieldStatsResult.getSum();\n                    break;\n                case STDDEV:\n                    result = fieldStatsResult.getStdDeviation();\n                    break;\n                default:\n                    LOG.error(\"No such field value check type: [{}]. Returning not triggered.\", type);\n                    return new CheckResult(false);\n            }\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, result);\n\n            if(Double.isInfinite(result)) {\n                // This happens when there are no ES results/docs.\n                LOG.debug(\"Infinite value. Returning not triggered.\");\n                return new CheckResult(false);\n            }\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case HIGHER:\n                    triggered = result > threshold.doubleValue();\n                    break;\n                case LOWER:\n                    triggered = result < threshold.doubleValue();\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Field \").append(field).append(\" had a \")\n                        .append(type.toString().toLowerCase()).append(\" of \")\n                        .append(result).append(\" in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\". \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        } catch (Searches.FieldTypeException e) {\n            LOG.debug(\"Field [{}] seems not to have a numerical type or doesn't even exist at all. Returning not triggered.\", field, e);\n            return new CheckResult(false);\n        }\n    }","id":87315,"modified_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = null;\n        try {\n            String filter = \"streams:\"+stream.getId();\n            FieldStatsResult fieldStatsResult = core.getIndexer().searches().fieldStats(field, \"*\", filter, new RelativeRange(time * 60));\n            this.searchHits = fieldStatsResult.getSearchHits();\n\n            if (fieldStatsResult.getCount() == 0) {\n                LOG.debug(\"Alert check <{}> did not match any messages. Returning not triggered.\", type);\n                return new CheckResult(false);\n            }\n\n            double result;\n            switch (type) {\n                case MEAN:\n                    result = fieldStatsResult.getMean();\n                    break;\n                case MIN:\n                    result = fieldStatsResult.getMin();\n                    break;\n                case MAX:\n                    result = fieldStatsResult.getMax();\n                    break;\n                case SUM:\n                    result = fieldStatsResult.getSum();\n                    break;\n                case STDDEV:\n                    result = fieldStatsResult.getStdDeviation();\n                    break;\n                default:\n                    LOG.error(\"No such field value check type: [{}]. Returning not triggered.\", type);\n                    return new CheckResult(false);\n            }\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, result);\n\n            if(Double.isInfinite(result)) {\n                // This happens when there are no ES results/docs.\n                LOG.debug(\"Infinite value. Returning not triggered.\");\n                return new CheckResult(false);\n            }\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case HIGHER:\n                    triggered = result > threshold.doubleValue();\n                    break;\n                case LOWER:\n                    triggered = result < threshold.doubleValue();\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Field \").append(field).append(\" had a \")\n                        .append(type.toString().toLowerCase()).append(\" of \")\n                        .append(result).append(\" in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\". \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        } catch (Searches.FieldTypeException e) {\n            LOG.debug(\"Field [{}] seems not to have a numerical type or doesn't even exist at all. Returning not triggered.\", field, e);\n            return new CheckResult(false);\n        }\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected CheckResult runCheck() {\n        try {\n            String filter = \"streams:\"+stream.getId();\n            long count = core.getIndexer().searches().count(\"*\", new RelativeRange(time * 60), filter).getCount();\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, count);\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case MORE:\n                    triggered = count > threshold;\n                    break;\n                case LESS:\n                    triggered = count < threshold;\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Stream had \").append(count).append(\" messages in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\" messages. \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        }\n    }","id":87316,"modified_method":"@Override\n    protected CheckResult runCheck() {\n        this.searchHits = null;\n        try {\n            String filter = \"streams:\"+stream.getId();\n            CountResult result = core.getIndexer().searches().count(\"*\", new RelativeRange(time * 60), filter);\n            long count = result.getCount();\n            this.searchHits = result.getSearchHits();\n\n            LOG.debug(\"Alert check <{}> result: [{}]\", id, count);\n\n            boolean triggered = false;\n            switch (thresholdType) {\n                case MORE:\n                    triggered = count > threshold;\n                    break;\n                case LESS:\n                    triggered = count < threshold;\n                    break;\n            }\n\n            if (triggered) {\n                StringBuilder resultDescription = new StringBuilder();\n\n                resultDescription.append(\"Stream had \").append(count).append(\" messages in the last \")\n                        .append(time).append(\" minutes with trigger condition \")\n                        .append(thresholdType.toString().toLowerCase()).append(\" than \")\n                        .append(threshold).append(\" messages. \")\n                        .append(\"(Current grace time: \").append(grace).append(\" minutes)\");\n\n                return new CheckResult(true, this, resultDescription.toString(), Tools.iso8601());\n            } else {\n                return new CheckResult(false);\n            }\n        } catch (InvalidRangeParametersException e) {\n            // cannot happen lol\n            LOG.error(\"Invalid timerange.\", e);\n            return null;\n        } catch (IndexHelper.InvalidRangeFormatException e) {\n            // lol same here\n            LOG.error(\"Invalid timerange format.\", e);\n            return null;\n        }\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public FieldStatsResult fieldStats(String field, String query, String filter, TimeRange range) throws FieldTypeException, IndexHelper.InvalidRangeFormatException {\n        SearchRequestBuilder srb;\n\n        if (filter == null) {\n            srb = standardSearchRequest(query, IndexHelper.determineAffectedIndices(server, range));\n        } else {\n            srb = filteredSearchRequest(query, filter, IndexHelper.determineAffectedIndices(server, range));\n        }\n\n        StatisticalFacetBuilder stats = new StatisticalFacetBuilder(STATS_FACET_NAME);\n        stats.global(false);\n\n        stats.facetFilter(standardFilters(range, filter));\n\n        stats.field(field);\n\n        srb.addFacet(stats);\n\n        SearchResponse r;\n        final SearchRequest request;\n        try {\n            request = srb.request();\n            r = c.search(request).actionGet();\n        }  catch (org.elasticsearch.action.search.SearchPhaseExecutionException e) {\n            throw new FieldTypeException(e);\n        }\n\n        return new FieldStatsResult(\n                (StatisticalFacet) r.getFacets().facet(STATS_FACET_NAME),\n                query,\n                request.source(),\n                r.getTook()\n        );\n    }","id":87317,"modified_method":"public FieldStatsResult fieldStats(String field, String query, String filter, TimeRange range) throws FieldTypeException, IndexHelper.InvalidRangeFormatException {\n        SearchRequestBuilder srb;\n\n        if (filter == null) {\n            srb = standardSearchRequest(query, IndexHelper.determineAffectedIndices(server, range));\n        } else {\n            srb = filteredSearchRequest(query, filter, IndexHelper.determineAffectedIndices(server, range));\n        }\n\n        StatisticalFacetBuilder stats = new StatisticalFacetBuilder(STATS_FACET_NAME);\n        stats.global(false);\n\n        stats.facetFilter(standardFilters(range, filter));\n\n        stats.field(field);\n\n        srb.addFacet(stats);\n\n        SearchResponse r;\n        final SearchRequest request;\n        try {\n            request = srb.request();\n            r = c.search(request).actionGet();\n        }  catch (org.elasticsearch.action.search.SearchPhaseExecutionException e) {\n            throw new FieldTypeException(e);\n        }\n\n        return new FieldStatsResult(\n                (StatisticalFacet) r.getFacets().facet(STATS_FACET_NAME),\n                r.getHits(),\n                query,\n                request.source(),\n                r.getTook()\n        );\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public CountResult count(String query, TimeRange range, String filter) throws IndexHelper.InvalidRangeFormatException {\n        Set<String> indices = IndexHelper.determineAffectedIndices(server, range);\n\n        SearchRequest request;\n        if (filter == null) {\n            request = standardSearchRequest(query, indices, range).request();\n        } else {\n            request = filteredSearchRequest(query, filter, indices, range).request();\n        }\n        request.searchType(SearchType.COUNT);\n\n        SearchResponse r = c.search(request).actionGet();\n        return new CountResult(r.getHits().getTotalHits(), r.getTookInMillis());\n    }","id":87318,"modified_method":"public CountResult count(String query, TimeRange range, String filter) throws IndexHelper.InvalidRangeFormatException {\n        Set<String> indices = IndexHelper.determineAffectedIndices(server, range);\n\n        SearchRequest request;\n        if (filter == null) {\n            request = standardSearchRequest(query, indices, range).request();\n        } else {\n            request = filteredSearchRequest(query, filter, indices, range).request();\n        }\n        request.searchType(SearchType.COUNT);\n\n        SearchResponse r = c.search(request).actionGet();\n        return new CountResult(r.getHits().getTotalHits(), r.getTookInMillis(), r.getHits());\n    }","commit_id":"7bb71f68d2d3ed2b20ffeb9f7cb8e90d265e7bda","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        if (!m_txnState.isReadOnly() && !m_completeMsg.isRollback()) {\n            // ENG-5276: Need to set the last committed spHandle so that the rejoining site gets the accurate\n            // per-partition txnId set for the next snapshot. Normally, this is done through undo log truncation.\n            // Since the task is not run here, we need to set the last committed spHandle explicitly.\n            //\n            // How does this work?\n            // - Blocking rejoin with idle cluster: The spHandle is updated here with the spHandle of the stream\n            //   snapshot that transfers the rejoin data. So the snapshot right after rejoin should have the spHandle\n            //   passed here.\n            // - Live rejoin with idle cluster: Same as blocking rejoin.\n            // - Live rejoin with workload: Transactions will be logged and replayed afterward. The spHandle will be\n            //   updated when they commit and truncate undo logs. So at the end of replay,\n            //   the spHandle should have the latest value. If all replayed transactions rolled back,\n            //   the spHandle is still guaranteed to be the spHandle of the stream snapshot that transfered the\n            //   rejoin data, which is the correct value.\n            siteConnection.setSpHandleForSnapshotDigest(m_txnState.m_spHandle);\n        }\n\n        if (!m_completeMsg.isRestart()) {\n            // future: offer to siteConnection.IBS for replay.\n            doCommonSPICompleteActions();\n        }\n        // We need to log the restarting message to the task log so we'll replay the whole\n        // stream faithfully\n        taskLog.logTask(m_completeMsg);\n    }","id":87319,"modified_method":"@Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        if (!m_txnState.isReadOnly() && !m_completeMsg.isRollback()) {\n            // ENG-5276: Need to set the last committed spHandle so that the rejoining site gets the accurate\n            // per-partition txnId set for the next snapshot. Normally, this is done through undo log truncation.\n            // Since the task is not run here, we need to set the last committed spHandle explicitly.\n            //\n            // How does this work?\n            // - Blocking rejoin with idle cluster: The spHandle is updated here with the spHandle of the stream\n            //   snapshot that transfers the rejoin data. So the snapshot right after rejoin should have the spHandle\n            //   passed here.\n            // - Live rejoin with idle cluster: Same as blocking rejoin.\n            // - Live rejoin with workload: Transactions will be logged and replayed afterward. The spHandle will be\n            //   updated when they commit and truncate undo logs. So at the end of replay,\n            //   the spHandle should have the latest value. If all replayed transactions rolled back,\n            //   the spHandle is still guaranteed to be the spHandle of the stream snapshot that transfered the\n            //   rejoin data, which is the correct value.\n            siteConnection.setSpHandleForSnapshotDigest(m_txnState.m_spHandle);\n        }\n\n        if (!m_completeMsg.isRestart()) {\n            // future: offer to siteConnection.IBS for replay.\n            doCommonSPICompleteActions();\n        }\n\n        if (!m_txnState.isReadOnly()) {\n            // We need to log the restarting message to the task log so we'll replay the whole\n            // stream faithfully\n            taskLog.logTask(m_completeMsg);\n        }\n    }","commit_id":"ba0064945953d7837c58ed53735cece11dbd412e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Produce a rejoining response.\n     */\n    @Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        taskLog.logTask(m_fragmentMsg);\n        final FragmentResponseMessage response =\n            new FragmentResponseMessage(m_fragmentMsg, m_initiator.getHSId());\n        response.m_sourceHSId = m_initiator.getHSId();\n        response.setRecovering(true);\n        response.setStatus(FragmentResponseMessage.SUCCESS, null);\n\n        // Set the dependencies even if this is a dummy response. This site could be the master\n        // on elastic join, so the fragment response message is actually going to the MPI.\n        VoltTable depTable = new VoltTable(new ColumnInfo(\"STATUS\", VoltType.TINYINT));\n        depTable.setStatusCode(VoltTableUtil.NULL_DEPENDENCY_STATUS);\n        for (int frag = 0; frag < m_fragmentMsg.getFragmentCount(); frag++) {\n            final int outputDepId = m_fragmentMsg.getOutputDepId(frag);\n            response.addDependency(outputDepId, depTable);\n        }\n\n        m_initiator.deliver(response);\n        completeFragment();\n    }","id":87320,"modified_method":"/**\n     * Produce a rejoining response.\n     */\n    @Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        if (!m_txnState.isReadOnly()) {\n            taskLog.logTask(m_fragmentMsg);\n        }\n\n        final FragmentResponseMessage response =\n            new FragmentResponseMessage(m_fragmentMsg, m_initiator.getHSId());\n        response.m_sourceHSId = m_initiator.getHSId();\n        response.setRecovering(true);\n        response.setStatus(FragmentResponseMessage.SUCCESS, null);\n\n        // Set the dependencies even if this is a dummy response. This site could be the master\n        // on elastic join, so the fragment response message is actually going to the MPI.\n        VoltTable depTable = new VoltTable(new ColumnInfo(\"STATUS\", VoltType.TINYINT));\n        depTable.setStatusCode(VoltTableUtil.NULL_DEPENDENCY_STATUS);\n        for (int frag = 0; frag < m_fragmentMsg.getFragmentCount(); frag++) {\n            final int outputDepId = m_fragmentMsg.getOutputDepId(frag);\n            response.addDependency(outputDepId, depTable);\n        }\n\n        m_initiator.deliver(response);\n        completeFragment();\n    }","commit_id":"ba0064945953d7837c58ed53735cece11dbd412e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        taskLog.logTask(m_txnState.getNotice());\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response =\n            new InitiateResponseMessage(txnState.m_initiationMsg);\n        response.m_sourceHSId = m_initiator.getHSId();\n        response.setRecovering(true);\n\n        // add an empty dummy response\n        response.setResults(new ClientResponseImpl(\n                    ClientResponse.SUCCESS,\n                    new VoltTable[0],\n                    null));\n\n        m_initiator.deliver(response);\n    }","id":87321,"modified_method":"@Override\n    public void runForRejoin(SiteProcedureConnection siteConnection, TaskLog taskLog)\n    throws IOException\n    {\n        if (!m_txnState.isReadOnly()) {\n            taskLog.logTask(m_txnState.getNotice());\n        }\n\n        SpTransactionState txnState = (SpTransactionState)m_txnState;\n        final InitiateResponseMessage response =\n            new InitiateResponseMessage(txnState.m_initiationMsg);\n        response.m_sourceHSId = m_initiator.getHSId();\n        response.setRecovering(true);\n\n        // add an empty dummy response\n        response.setResults(new ClientResponseImpl(\n                    ClientResponse.SUCCESS,\n                    new VoltTable[0],\n                    null));\n\n        m_initiator.deliver(response);\n    }","commit_id":"ba0064945953d7837c58ed53735cece11dbd412e","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference parseLinkReference(String linkReferenceAsString,\n        org.xwiki.gwt.wysiwyg.client.wiki.EntityReference baseReference)\n    {\n        ResourceReference linkReference = linkReferenceParser.parse(linkReferenceAsString);\n        org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference clientLinkReference =\n            new org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference();\n        clientLinkReference.setType(org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference.ResourceType\n            .forScheme(linkReference.getType().getScheme()));\n        clientLinkReference.setTyped(linkReference.isTyped());\n        clientLinkReference.getParameters().putAll(linkReference.getParameters());\n        clientLinkReference.setEntityReference(parseEntityReferenceFromResourceReference(linkReference.getReference(),\n            clientLinkReference.getType(), baseReference));\n        return clientLinkReference;\n    }","id":87322,"modified_method":"@Override\n    public org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference parseLinkReference(String linkReferenceAsString,\n        org.xwiki.gwt.wysiwyg.client.wiki.EntityReference baseReference)\n    {\n        ResourceReference linkReference = linkReferenceParser.parse(linkReferenceAsString);\n\n        ResourceType linkResourceType = linkReference.getType();\n        if (ResourceType.SPACE.equals(linkResourceType)) {\n            // Treat space resources the same as documents in order to reuse the UI.\n            linkResourceType = ResourceType.DOCUMENT;\n        }\n\n        org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference clientLinkReference =\n            new org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference();\n        clientLinkReference.setType(org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference.ResourceType\n            .forScheme(linkResourceType.getScheme()));\n        clientLinkReference.setTyped(linkReference.isTyped());\n        clientLinkReference.getParameters().putAll(linkReference.getParameters());\n        clientLinkReference.setEntityReference(parseEntityReferenceFromResourceReference(linkReference,\n            clientLinkReference.getType(), baseReference));\n\n        return clientLinkReference;\n    }","commit_id":"bb76d48940ce3541cc53a812321286e325a57ca1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Parses a client entity reference from a link/resource reference.\n     * \n     * @param stringEntityReference a string entity reference extracted from a link/resource reference\n     * @param resourceType the type of resource the string entity reference was extracted from\n     * @param baseReference the client entity reference that is used to resolve the parsed entity reference relative to\n     * @return an untyped client entity reference\n     */\n    private org.xwiki.gwt.wysiwyg.client.wiki.EntityReference parseEntityReferenceFromResourceReference(\n        String stringEntityReference, org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference.ResourceType resourceType,\n        org.xwiki.gwt.wysiwyg.client.wiki.EntityReference baseReference)\n    {\n        org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType entityType;\n        switch (resourceType) {\n            case DOCUMENT:\n                entityType = org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.DOCUMENT;\n                break;\n            case ATTACHMENT:\n                entityType = org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.ATTACHMENT;\n                break;\n            default:\n                entityType = org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.EXTERNAL;\n                break;\n        }\n        if (entityType == org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.EXTERNAL) {\n            return new URIReference(stringEntityReference).getEntityReference();\n        } else {\n            return entityReferenceConverter.convert(explicitStringEntityReferenceResolver.resolve(\n                stringEntityReference, EntityType.valueOf(entityType.toString()),\n                entityReferenceConverter.convert(baseReference)));\n        }\n    }","id":87323,"modified_method":"/**\n     * Parses a client entity reference from a link/resource reference.\n     *\n     * @param resourceReference the resource reference to parse\n     * @param clientResourceType the previously resolved client-side type of the passed resource reference\n     * @param baseReference the client entity reference that is used to resolve the parsed entity reference relative to\n     * @return an untyped client entity reference\n     */\n    private org.xwiki.gwt.wysiwyg.client.wiki.EntityReference parseEntityReferenceFromResourceReference(\n        ResourceReference resourceReference,\n        org.xwiki.gwt.wysiwyg.client.wiki.ResourceReference.ResourceType clientResourceType,\n        org.xwiki.gwt.wysiwyg.client.wiki.EntityReference baseReference)\n    {\n        org.xwiki.gwt.wysiwyg.client.wiki.EntityReference result = null;\n\n        org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType clientEntityType;\n        switch (clientResourceType) {\n            case DOCUMENT:\n                clientEntityType = org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.DOCUMENT;\n                break;\n            case ATTACHMENT:\n                clientEntityType = org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.ATTACHMENT;\n                break;\n            default:\n                clientEntityType = org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.EXTERNAL;\n                break;\n        }\n\n        if (clientEntityType == org.xwiki.gwt.wysiwyg.client.wiki.EntityReference.EntityType.EXTERNAL) {\n            result = new URIReference(resourceReference.getReference()).getEntityReference();\n        } else {\n            EntityReference serverEntityReference =\n                parseServerEntityReferenceFromResourceReference(resourceReference, baseReference);\n\n            result = entityReferenceConverter.convert(serverEntityReference);\n        }\n\n        return result;\n    }","commit_id":"bb76d48940ce3541cc53a812321286e325a57ca1","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n\t * Compile the filter conditions only the first time.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic OCommandExecutorSQLSelect parse(final OCommandRequestText iRequest) {\r\n\t\tiRequest.getDatabase().checkSecurity(ODatabaseSecurityResources.COMMAND, ORole.PERMISSION_READ);\r\n\r\n\t\tinit(iRequest.getDatabase(), iRequest.getText());\r\n\r\n\t\tif (iRequest instanceof OSQLSynchQuery) {\r\n\t\t\trequest = (OSQLSynchQuery<ORecordSchemaAware<?>>) iRequest;\r\n\t\t\trangeFrom = request.getBeginRange().isValid() ? request.getBeginRange() : null;\r\n\t\t\trangeTo = request.getEndRange().isValid() ? request.getEndRange() : null;\r\n\t\t} else if (iRequest instanceof OSQLAsynchQuery)\r\n\t\t\trequest = (OSQLAsynchQuery<ORecordSchemaAware<?>>) iRequest;\r\n\t\telse {\r\n\t\t\t// BUILD A QUERY OBJECT FROM THE COMMAND REQUEST\r\n\t\t\trequest = new OSQLSynchQuery<ORecordSchemaAware<?>>(iRequest.getText());\r\n\t\t\trequest.setDatabase(iRequest.getDatabase());\r\n\t\t\tif (iRequest.getResultListener() != null)\r\n\t\t\t\trequest.setResultListener(iRequest.getResultListener());\r\n\t\t}\r\n\r\n\t\tint pos = extractProjections();\r\n\t\tif (pos == -1)\r\n\t\t\treturn this;\r\n\r\n\t\tint endPosition = textUpperCase.indexOf(\" \" + OCommandExecutorSQLSelect.KEYWORD_ORDER_BY, currentPos);\r\n\t\tif (endPosition == -1) {\r\n\t\t\tendPosition = textUpperCase.indexOf(\" \" + OCommandExecutorSQLSelect.KEYWORD_RANGE, currentPos);\r\n\t\t\tif (endPosition == -1) {\r\n\t\t\t\tendPosition = textUpperCase.indexOf(\" \" + OCommandExecutorSQLSelect.KEYWORD_LIMIT, currentPos);\r\n\t\t\t\tif (endPosition == -1) {\r\n\t\t\t\t\t// NO OTHER STUFF: GET UNTIL THE END AND ASSURE TO RETURN FALSE IN ORDER TO AVOID PARSING OF CONDITIONS\r\n\t\t\t\t\tendPosition = text.length();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcompiledFilter = OSQLEngine.getInstance().parseWhereCondition(iRequest.getDatabase(), text.substring(pos, endPosition));\r\n\r\n\t\tcurrentPos = compiledFilter.currentPos + pos;\r\n\r\n\t\tif (currentPos > -1 && currentPos < text.length()) {\r\n\t\t\tcurrentPos = OStringParser.jump(text, currentPos, \" \\r\\n\");\r\n\r\n\t\t\tfinal StringBuilder word = new StringBuilder();\r\n\t\t\tString w;\r\n\r\n\t\t\twhile (currentPos > -1) {\r\n\t\t\t\tcurrentPos = OSQLHelper.nextWord(text, textUpperCase, currentPos, word, true);\r\n\r\n\t\t\t\tif (currentPos > -1) {\r\n\t\t\t\t\tw = word.toString();\r\n\t\t\t\t\tif (w.equals(KEYWORD_ORDER))\r\n\t\t\t\t\t\textractOrderBy(word);\r\n\t\t\t\t\telse if (w.equals(KEYWORD_RANGE))\r\n\t\t\t\t\t\textractRange(word);\r\n\t\t\t\t\telse if (w.equals(KEYWORD_LIMIT))\r\n\t\t\t\t\t\textractLimit(word);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}","id":87324,"modified_method":"/**\r\n\t * Compile the filter conditions only the first time.\r\n\t */\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic OCommandExecutorSQLSelect parse(final OCommandRequestText iRequest) {\r\n\t\tiRequest.getDatabase().checkSecurity(ODatabaseSecurityResources.COMMAND, ORole.PERMISSION_READ);\r\n\r\n\t\tinit(iRequest.getDatabase(), iRequest.getText());\r\n\r\n\t\tif (iRequest instanceof OSQLSynchQuery) {\r\n\t\t\trequest = (OSQLSynchQuery<ORecordSchemaAware<?>>) iRequest;\r\n\t\t\trangeFrom = request.getBeginRange().isValid() ? request.getBeginRange() : null;\r\n\t\t\trangeTo = request.getEndRange().isValid() ? request.getEndRange() : null;\r\n\t\t} else if (iRequest instanceof OSQLAsynchQuery)\r\n\t\t\trequest = (OSQLAsynchQuery<ORecordSchemaAware<?>>) iRequest;\r\n\t\telse {\r\n\t\t\t// BUILD A QUERY OBJECT FROM THE COMMAND REQUEST\r\n\t\t\trequest = new OSQLSynchQuery<ORecordSchemaAware<?>>(iRequest.getText());\r\n\t\t\trequest.setDatabase(iRequest.getDatabase());\r\n\t\t\tif (iRequest.getResultListener() != null)\r\n\t\t\t\trequest.setResultListener(iRequest.getResultListener());\r\n\t\t}\r\n\r\n\t\tfinal int pos = extractProjections();\r\n\t\tif (pos == -1)\r\n\t\t\treturn this;\r\n\r\n\t\tint endPosition = textUpperCase.indexOf(\" \" + OCommandExecutorSQLSelect.KEYWORD_ORDER_BY, currentPos);\r\n\t\tif (endPosition == -1) {\r\n\t\t\tendPosition = textUpperCase.indexOf(\" \" + OCommandExecutorSQLSelect.KEYWORD_RANGE, currentPos);\r\n\t\t\tif (endPosition == -1) {\r\n\t\t\t\tendPosition = textUpperCase.indexOf(\" \" + OCommandExecutorSQLSelect.KEYWORD_LIMIT, currentPos);\r\n\t\t\t\tif (endPosition == -1) {\r\n\t\t\t\t\t// NO OTHER STUFF: GET UNTIL THE END AND ASSURE TO RETURN FALSE IN ORDER TO AVOID PARSING OF CONDITIONS\r\n\t\t\t\t\tendPosition = text.length();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcompiledFilter = OSQLEngine.getInstance().parseWhereCondition(iRequest.getDatabase(), text.substring(pos, endPosition));\r\n\r\n\t\tcurrentPos = compiledFilter.currentPos + pos;\r\n\r\n\t\tif (currentPos > -1 && currentPos < text.length()) {\r\n\t\t\tcurrentPos = OStringParser.jump(text, currentPos, \" \\r\\n\");\r\n\r\n\t\t\tfinal StringBuilder word = new StringBuilder();\r\n\t\t\tString w;\r\n\r\n\t\t\twhile (currentPos > -1) {\r\n\t\t\t\tcurrentPos = OSQLHelper.nextWord(text, textUpperCase, currentPos, word, true);\r\n\r\n\t\t\t\tif (currentPos > -1) {\r\n\t\t\t\t\tw = word.toString();\r\n\t\t\t\t\tif (w.equals(KEYWORD_ORDER))\r\n\t\t\t\t\t\textractOrderBy(word);\r\n\t\t\t\t\telse if (w.equals(KEYWORD_RANGE))\r\n\t\t\t\t\t\textractRange(word);\r\n\t\t\t\t\telse if (w.equals(KEYWORD_LIMIT))\r\n\t\t\t\t\t\textractLimit(word);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}","commit_id":"06a365860bcfac9ad5f7a1f781967d6076e4234c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private <RET> RET convertField(final String iPropertyName, final Class<?> iType, RET iValue) {\r\n\t\tif (iType == null)\r\n\t\t\treturn iValue;\r\n\r\n\t\tif (iValue instanceof ORID && !ORID.class.equals(iType) && !ORecordId.class.equals(iType)) {\r\n\t\t\t// CREATE THE DOCUMENT OBJECT IN LAZY WAY\r\n\t\t\tiValue = (RET) new ODocument(_database, (ORID) iValue);\r\n\t\t\t_fieldValues.put(iPropertyName, iValue);\r\n\r\n\t\t} else if (ORID.class.equals(iType)) {\r\n\t\t\tif (iValue instanceof ORecord<?>)\r\n\t\t\t\treturn (RET) ((ORecord<?>) iValue).getIdentity();\r\n\t\t} else if (Set.class.isAssignableFrom(iType) && !(iValue instanceof Set)) {\r\n\t\t\t// CONVERT IT TO SET\r\n\t\t\tfinal Collection<?> newValue;\r\n\r\n\t\t\tif (iValue instanceof ORecordLazyList || iValue instanceof ORecordLazyMap)\r\n\t\t\t\tnewValue = new ORecordLazySet(this);\r\n\t\t\telse\r\n\t\t\t\tnewValue = new OTrackedSet<Object>(this);\r\n\r\n\t\t\tif (iValue instanceof Collection<?>)\r\n\t\t\t\t((Collection<Object>) newValue).addAll((Collection<Object>) iValue);\r\n\t\t\telse if (iValue instanceof Map)\r\n\t\t\t\t((Collection<Object>) newValue).addAll(((Map<String, Object>) iValue).values());\r\n\r\n\t\t\t_fieldValues.put(iPropertyName, newValue);\r\n\t\t\tiValue = (RET) newValue;\r\n\r\n\t\t} else if (List.class.isAssignableFrom(iType) && !(iValue instanceof List)) {\r\n\t\t\t// CONVERT IT TO LIST\r\n\t\t\tfinal Collection<?> newValue;\r\n\r\n\t\t\tif (iValue instanceof ORecordLazySet || iValue instanceof ORecordLazyMap)\r\n\t\t\t\tnewValue = new ORecordLazyList(this);\r\n\t\t\telse\r\n\t\t\t\tnewValue = new OTrackedList<Object>(this);\r\n\r\n\t\t\tif (iValue instanceof Collection)\r\n\t\t\t\t((Collection<Object>) newValue).addAll((Collection<Object>) iValue);\r\n\t\t\telse if (iValue instanceof Map)\r\n\t\t\t\t((Collection<Object>) newValue).addAll(((Map<String, Object>) iValue).values());\r\n\r\n\t\t\t_fieldValues.put(iPropertyName, newValue);\r\n\t\t\tiValue = (RET) newValue;\r\n\t\t} else\r\n\t\t\tiValue = (RET) OType.convert(iValue, iType);\r\n\r\n\t\treturn iValue;\r\n\t}","id":87325,"modified_method":"private <RET> RET convertField(final String iPropertyName, final Class<?> iType, Object iValue) {\r\n\t\tif (iType == null)\r\n\t\t\treturn (RET) iValue;\r\n\r\n\t\tif (iValue instanceof ORID && !ORID.class.equals(iType) && !ORecordId.class.equals(iType)) {\r\n\t\t\t// CREATE THE DOCUMENT OBJECT IN LAZY WAY\r\n\t\t\tiValue = (RET) new ODocument(_database, (ORID) iValue);\r\n\t\t\t_fieldValues.put(iPropertyName, iValue);\r\n\r\n\t\t} else if (ORID.class.equals(iType)) {\r\n\t\t\tif (iValue instanceof ORecord<?>)\r\n\t\t\t\treturn (RET) ((ORecord<?>) iValue).getIdentity();\r\n\t\t} else if (Set.class.isAssignableFrom(iType) && !(iValue instanceof Set)) {\r\n\t\t\t// CONVERT IT TO SET\r\n\t\t\tfinal Collection<?> newValue;\r\n\r\n\t\t\tif (iValue instanceof ORecordLazyList || iValue instanceof ORecordLazyMap)\r\n\t\t\t\tnewValue = new ORecordLazySet(this);\r\n\t\t\telse\r\n\t\t\t\tnewValue = new OTrackedSet<Object>(this);\r\n\r\n\t\t\tif (iValue instanceof Collection<?>)\r\n\t\t\t\t((Collection<Object>) newValue).addAll((Collection<Object>) iValue);\r\n\t\t\telse if (iValue instanceof Map)\r\n\t\t\t\t((Collection<Object>) newValue).addAll(((Map<String, Object>) iValue).values());\r\n\r\n\t\t\t_fieldValues.put(iPropertyName, newValue);\r\n\t\t\tiValue = (RET) newValue;\r\n\r\n\t\t} else if (List.class.isAssignableFrom(iType) && !(iValue instanceof List)) {\r\n\t\t\t// CONVERT IT TO LIST\r\n\t\t\tfinal Collection<?> newValue;\r\n\r\n\t\t\tif (iValue instanceof ORecordLazySet || iValue instanceof ORecordLazyMap)\r\n\t\t\t\tnewValue = new ORecordLazyList(this);\r\n\t\t\telse\r\n\t\t\t\tnewValue = new OTrackedList<Object>(this);\r\n\r\n\t\t\tif (iValue instanceof Collection)\r\n\t\t\t\t((Collection<Object>) newValue).addAll((Collection<Object>) iValue);\r\n\t\t\telse if (iValue instanceof Map)\r\n\t\t\t\t((Collection<Object>) newValue).addAll(((Map<String, Object>) iValue).values());\r\n\r\n\t\t\t_fieldValues.put(iPropertyName, newValue);\r\n\t\t\tiValue = (RET) newValue;\r\n\t\t} else if (iValue instanceof Enum) {\r\n\t\t\t// ENUM\r\n\t\t\tif (iType.isAssignableFrom(Integer.TYPE))\r\n\t\t\t\tiValue = ((Enum<?>) iValue).ordinal();\r\n\t\t\telse\r\n\t\t\t\tiValue = ((Enum<?>) iValue).name();\r\n\r\n\t\t\tif (!(iValue instanceof String) && !iType.isAssignableFrom(iValue.getClass()))\r\n\t\t\t\tthrow new IllegalArgumentException(\"Property '\" + iPropertyName + \"' of type '\" + iType + \"' can't accept value of type: \"\r\n\t\t\t\t\t\t+ iValue.getClass());\r\n\t\t}\r\n\r\n\t\tiValue = OType.convert(iValue, iType);\r\n\r\n\t\treturn (RET) iValue;\r\n\t}","commit_id":"06a365860bcfac9ad5f7a1f781967d6076e4234c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Reads the field value.\r\n\t * \r\n\t * @param iPropertyName\r\n\t *          field name\r\n\t * @return field value if defined, otherwise null\r\n\t */\r\n\tpublic <RET> RET field(final String iPropertyName) {\r\n\t\tRET value = this.<RET> rawField(iPropertyName);\r\n\r\n\t\tfinal OType t = fieldType(iPropertyName);\r\n\r\n\t\tif (_lazyLoad && value instanceof ORID && t != OType.LINK) {\r\n\t\t\t// CREATE THE DOCUMENT OBJECT IN LAZY WAY\r\n\t\t\tvalue = (RET) _database.load((ORID) value);\r\n\t\t\t_fieldValues.put(iPropertyName, value);\r\n\t\t}\r\n\r\n\t\t// CHECK FOR CONVERSION\r\n\t\tif (t != null) {\r\n\t\t\tif (t == OType.BINARY && value instanceof String) {\r\n\t\t\t\tbyte[] buffer = OBase64Utils.decode((String) value);\r\n\t\t\t\tfield(iPropertyName, buffer);\r\n\t\t\t\tvalue = (RET) buffer;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t}","id":87326,"modified_method":"/**\r\n\t * Reads the field value.\r\n\t * \r\n\t * @param iPropertyName\r\n\t *          field name\r\n\t * @return field value if defined, otherwise null\r\n\t */\r\n\tpublic <RET> RET field(final String iPropertyName) {\r\n\t\tRET value = this.<RET> rawField(iPropertyName);\r\n\r\n\t\tfinal OType t = fieldType(iPropertyName);\r\n\r\n\t\tif (_lazyLoad && value instanceof ORID && t != OType.LINK) {\r\n\t\t\t// CREATE THE DOCUMENT OBJECT IN LAZY WAY\r\n\t\t\tvalue = (RET) _database.load((ORID) value);\r\n\t\t\t_fieldValues.put(iPropertyName, value);\r\n\t\t}\r\n\r\n\t\t// CHECK FOR CONVERSION\r\n\t\tif (t != null) {\r\n\t\t\tObject newValue = null;\r\n\r\n\t\t\tif (t == OType.BINARY && value instanceof String)\r\n\t\t\t\tnewValue = OBase64Utils.decode((String) value);\r\n\t\t\telse if (t == OType.DATE && value instanceof Long)\r\n\t\t\t\tnewValue = (RET) new Date(((Long) value).longValue());\r\n\r\n\t\t\tif (newValue != null) {\r\n\t\t\t\t// VALUE CHANGED: SET THE NEW ONE\r\n\t\t\t\t_fieldValues.put(iPropertyName, newValue);\r\n\t\t\t\tvalue = (RET) newValue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t}","commit_id":"06a365860bcfac9ad5f7a1f781967d6076e4234c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Writes the field value forcing the type.\r\n\t * \r\n\t * @param iPropertyName\r\n\t *          field name\r\n\t * @param iPropertyValue\r\n\t *          field value\r\n\t * @param iType\r\n\t *          Forced type (not auto-determined)\r\n\t * @return The Record instance itself giving a \"fluent interface\". Useful to call multiple methods in chain.\r\n\t */\r\n\tpublic ODocument field(final String iPropertyName, Object iPropertyValue, OType iType) {\r\n\t\tcheckForLoading();\r\n\t\tcheckForFields();\r\n\r\n\t\tfinal boolean knownProperty = _fieldValues.containsKey(iPropertyName);\r\n\t\tfinal Object oldValue = _fieldValues.get(iPropertyName);\r\n\r\n\t\tif (knownProperty)\r\n\t\t\t// CHECK IF IS REALLY CHANGED\r\n\t\t\tif (iPropertyValue == null) {\r\n\t\t\t\tif (oldValue == null)\r\n\t\t\t\t\t// BOTH NULL: UNCHANGED\r\n\t\t\t\t\treturn this;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (iPropertyValue == oldValue)\r\n\t\t\t\t\t\t// BOTH NULL: UNCHANGED\r\n\t\t\t\t\t\treturn this;\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tOLogManager.instance().warn(this, \"Error on checking the value of property %s against the record %s\", e, iPropertyName,\r\n\t\t\t\t\t\t\tgetIdentity());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\tif (_clazz != null) {\r\n\t\t\tOProperty prop = _clazz.getProperty(iPropertyName);\r\n\r\n\t\t\tif (prop != null) {\r\n\t\t\t\tif (iPropertyValue instanceof Enum)\r\n\t\t\t\t\t// ENUM\r\n\t\t\t\t\tif (prop.getType().isAssignableFrom(1))\r\n\t\t\t\t\t\tiPropertyValue = ((Enum<?>) iPropertyValue).ordinal();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tiPropertyValue = ((Enum<?>) iPropertyValue).name();\r\n\r\n\t\t\t\tif (!(iPropertyValue instanceof String) && !prop.getType().isAssignableFrom(iPropertyValue))\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Property '\" + iPropertyName + \"' of type '\" + prop.getType()\r\n\t\t\t\t\t\t\t+ \"' can't accept value of type: \" + iPropertyValue.getClass());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (_status != STATUS.UNMARSHALLING) {\r\n\t\t\tsetDirty();\r\n\r\n\t\t\tif (knownProperty && _trackingChanges) {\r\n\t\t\t\t// SAVE THE OLD VALUE IN A SEPARATE MAP\r\n\t\t\t\tif (_fieldOriginalValues == null)\r\n\t\t\t\t\t_fieldOriginalValues = new HashMap<String, Object>();\r\n\r\n\t\t\t\t// INSERT IT ONLY IF NOT EXISTS TO AVOID LOOSE OF THE ORIGINAL VALUE (FUNDAMENTAL FOR INDEX HOOK)\r\n\t\t\t\tif (!_fieldOriginalValues.containsKey(iPropertyName))\r\n\t\t\t\t\t_fieldOriginalValues.put(iPropertyName, oldValue);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (oldValue != null) {\r\n\t\t\t// DETERMINE THE TYPE FROM THE PREVIOUS CONTENT\r\n\t\t\tif (oldValue instanceof ORecord<?> && iPropertyValue instanceof String)\r\n\t\t\t\t// CONVERT TO RECORD-ID\r\n\t\t\t\tiPropertyValue = new ORecordId((String) iPropertyValue);\r\n\t\t\telse if (oldValue instanceof Collection<?> && iPropertyValue instanceof String) {\r\n\t\t\t\t// CONVERT TO COLLECTION\r\n\t\t\t\tfinal List<ODocument> newValue = new ArrayList<ODocument>();\r\n\t\t\t\tiPropertyValue = newValue;\r\n\r\n\t\t\t\tfinal String stringValue = (String) iPropertyValue;\r\n\r\n\t\t\t\tif (stringValue != null && stringValue.length() > 0) {\r\n\t\t\t\t\tfinal String[] items = stringValue.split(\",\");\r\n\t\t\t\t\tfor (String s : items) {\r\n\t\t\t\t\t\tnewValue.add(new ODocument(_database, new ORecordId(s)));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (iPropertyValue instanceof Enum) {\r\n\t\t\t\t// ENUM\r\n\t\t\t\tif (oldValue instanceof Number)\r\n\t\t\t\t\tiPropertyValue = ((Enum<?>) iPropertyValue).ordinal();\r\n\t\t\t\telse\r\n\t\t\t\t\tiPropertyValue = iPropertyValue.toString();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (iPropertyValue instanceof Enum)\r\n\t\t\t\t// ENUM\r\n\t\t\t\tiPropertyValue = iPropertyValue.toString();\r\n\t\t}\r\n\r\n\t\t_fieldValues.put(iPropertyName, iPropertyValue);\r\n\r\n\t\tsetFieldType(iPropertyName, iType);\r\n\r\n\t\treturn this;\r\n\t}","id":87327,"modified_method":"/**\r\n\t * Writes the field value forcing the type.\r\n\t * \r\n\t * @param iPropertyName\r\n\t *          field name\r\n\t * @param iPropertyValue\r\n\t *          field value\r\n\t * @param iType\r\n\t *          Forced type (not auto-determined)\r\n\t * @return The Record instance itself giving a \"fluent interface\". Useful to call multiple methods in chain.\r\n\t */\r\n\tpublic ODocument field(String iPropertyName, Object iPropertyValue, OType iType) {\r\n\t\tiPropertyName = checkFieldName(iPropertyName);\r\n\r\n\t\tcheckForLoading();\r\n\t\tcheckForFields();\r\n\r\n\t\tfinal boolean knownProperty = _fieldValues.containsKey(iPropertyName);\r\n\t\tfinal Object oldValue = _fieldValues.get(iPropertyName);\r\n\r\n\t\tif (knownProperty)\r\n\t\t\t// CHECK IF IS REALLY CHANGED\r\n\t\t\tif (iPropertyValue == null) {\r\n\t\t\t\tif (oldValue == null)\r\n\t\t\t\t\t// BOTH NULL: UNCHANGED\r\n\t\t\t\t\treturn this;\r\n\t\t\t} else {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (iPropertyValue == oldValue)\r\n\t\t\t\t\t\t// BOTH NULL: UNCHANGED\r\n\t\t\t\t\t\treturn this;\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\tOLogManager.instance().warn(this, \"Error on checking the value of property %s against the record %s\", e, iPropertyName,\r\n\t\t\t\t\t\t\tgetIdentity());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\tif (iType != null)\r\n\t\t\tsetFieldType(iPropertyName, iType);\r\n\t\telse if (_clazz != null) {\r\n\t\t\t// SCHEMAFULL?\r\n\t\t\tfinal OProperty prop = _clazz.getProperty(iPropertyName);\r\n\t\t\tif (prop != null)\r\n\t\t\t\tiType = prop.getType();\r\n\t\t}\r\n\r\n\t\tif (iType != null)\r\n\t\t\tconvertField(iPropertyName, iType.getDefaultJavaType(), iPropertyValue);\r\n\r\n\t\tif (_status != STATUS.UNMARSHALLING) {\r\n\t\t\tsetDirty();\r\n\r\n\t\t\tif (knownProperty && _trackingChanges) {\r\n\t\t\t\t// SAVE THE OLD VALUE IN A SEPARATE MAP\r\n\t\t\t\tif (_fieldOriginalValues == null)\r\n\t\t\t\t\t_fieldOriginalValues = new HashMap<String, Object>();\r\n\r\n\t\t\t\t// INSERT IT ONLY IF NOT EXISTS TO AVOID LOOSE OF THE ORIGINAL VALUE (FUNDAMENTAL FOR INDEX HOOK)\r\n\t\t\t\tif (!_fieldOriginalValues.containsKey(iPropertyName))\r\n\t\t\t\t\t_fieldOriginalValues.put(iPropertyName, oldValue);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (oldValue != null && iType != null) {\r\n\t\t\t// DETERMINE THE TYPE FROM THE PREVIOUS CONTENT\r\n\t\t\tif (oldValue instanceof ORecord<?> && iPropertyValue instanceof String)\r\n\t\t\t\t// CONVERT TO RECORD-ID\r\n\t\t\t\tiPropertyValue = new ORecordId((String) iPropertyValue);\r\n\t\t\telse if (oldValue instanceof Collection<?> && iPropertyValue instanceof String) {\r\n\t\t\t\t// CONVERT TO COLLECTION\r\n\t\t\t\tfinal List<ODocument> newValue = new ArrayList<ODocument>();\r\n\t\t\t\tiPropertyValue = newValue;\r\n\r\n\t\t\t\tfinal String stringValue = (String) iPropertyValue;\r\n\r\n\t\t\t\tif (stringValue != null && stringValue.length() > 0) {\r\n\t\t\t\t\tfinal String[] items = stringValue.split(\",\");\r\n\t\t\t\t\tfor (String s : items) {\r\n\t\t\t\t\t\tnewValue.add(new ODocument(_database, new ORecordId(s)));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (iPropertyValue instanceof Enum) {\r\n\t\t\t\t// ENUM\r\n\t\t\t\tif (oldValue instanceof Number)\r\n\t\t\t\t\tiPropertyValue = ((Enum<?>) iPropertyValue).ordinal();\r\n\t\t\t\telse\r\n\t\t\t\t\tiPropertyValue = iPropertyValue.toString();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (iPropertyValue instanceof Enum)\r\n\t\t\t\t// ENUM\r\n\t\t\t\tiPropertyValue = iPropertyValue.toString();\r\n\t\t}\r\n\r\n\t\t_fieldValues.put(iPropertyName, iPropertyValue);\r\n\r\n\t\treturn this;\r\n\t}","commit_id":"06a365860bcfac9ad5f7a1f781967d6076e4234c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\r\n\tpublic void queryLogicalCluster() throws ParseException {\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tString rangeFrom = \"2009-09-30\";\r\n\t\tString rangeTo = \"2009-11-01\";\r\n\r\n\t\tDate rangeFromDate = database.getStorage().getConfiguration().getDateFormatInstance().parse(rangeFrom);\r\n\t\tDate rangeToDate = database.getStorage().getConfiguration().getDateFormatInstance().parse(rangeTo);\r\n\r\n\t\tList<ODocument> result = database.command(\r\n\t\t\t\tnew OSQLSynchQuery<ODocument>(\"select * from cluster:Order where date > '\" + rangeFrom + \"' and date < '\" + rangeTo + \"'\"))\r\n\t\t\t\t.execute();\r\n\r\n\t\tfor (int i = 0; i < result.size(); ++i) {\r\n\t\t\trecord = result.get(i);\r\n\r\n\t\t\tOrientTest.printRecord(i, record);\r\n\r\n\t\t\tAssert.assertTrue(record.getClassName().equalsIgnoreCase(\"order\"));\r\n\t\t\tAssert.assertTrue(((Date) record.field(\"date\")).after(rangeFromDate));\r\n\t\t\tAssert.assertTrue(((Date) record.field(\"date\")).before(rangeToDate));\r\n\t\t\tAssert.assertTrue(record.field(\"name\").toString().startsWith(\"G\"));\r\n\t\t}\r\n\r\n\t\tdatabase.close();\r\n\t}","id":87328,"modified_method":"@Test\r\n\tpublic void queryLogicalCluster() throws ParseException {\r\n\t\tdatabase.open(\"admin\", \"admin\");\r\n\r\n\t\tList<ODocument> result = database.command(new OSQLSynchQuery<ODocument>(\"select * from cluster:Order\")).execute();\r\n\r\n\t\tfor (int i = 0; i < result.size(); ++i) {\r\n\t\t\trecord = result.get(i);\r\n\t\t}\r\n\r\n\t\tdatabase.close();\r\n\t}","commit_id":"06a365860bcfac9ad5f7a1f781967d6076e4234c","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String renderDDMTemplate(\n\t\t\tPageContext pageContext, long ddmTemplateId, List<?> entries,\n\t\t\tMap<String, Object> contextObjects)\n\t\tthrows Exception {\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.DDM_TEMPLATE_ID, ddmTemplateId);\n\t\tcontextObjects.put(PortletDisplayTemplateConstants.ENTRIES, entries);\n\n\t\tif (entries.size() == 1) {\n\t\t\tcontextObjects.put(\n\t\t\t\tPortletDisplayTemplateConstants.ENTRY, entries.get(0));\n\t\t}\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.LOCALE, request.getLocale());\n\n\t\tcontextObjects.put(PortletDisplayTemplateConstants.REQUEST, request);\n\n\t\tRenderRequest renderRequest = (RenderRequest)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_PORTLET_REQUEST);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.RENDER_REQUEST, renderRequest);\n\n\t\tRenderResponse renderResponse = (RenderResponse)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_PORTLET_RESPONSE);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.RENDER_RESPONSE, renderResponse);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.THEME_DISPLAY, themeDisplay);\n\n\t\tcontextObjects.putAll(_getPortletPreferences(renderRequest));\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tServletContext servletContext =\n\t\t\trequest.getSession().getServletContext();\n\n\t\tWriter writer = pageContext.getOut();\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext, null);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.TAGLIB_LIFERAY, velocityTaglib);\n\n\t\tDDMTemplate ddmTemplate = DDMTemplateLocalServiceUtil.getTemplate(\n\t\t\tddmTemplateId);\n\n\t\treturn _transformer.transform(\n\t\t\tthemeDisplay, contextObjects, ddmTemplate.getScript(),\n\t\t\tddmTemplate.getLanguage());\n\t}","id":87329,"modified_method":"public String renderDDMTemplate(\n\t\t\tPageContext pageContext, long ddmTemplateId, List<?> entries,\n\t\t\tMap<String, Object> contextObjects)\n\t\tthrows Exception {\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.DDM_TEMPLATE_ID, ddmTemplateId);\n\t\tcontextObjects.put(PortletDisplayTemplateConstants.ENTRIES, entries);\n\n\t\tif (entries.size() == 1) {\n\t\t\tcontextObjects.put(\n\t\t\t\tPortletDisplayTemplateConstants.ENTRY, entries.get(0));\n\t\t}\n\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.LOCALE, request.getLocale());\n\n\t\tcontextObjects.put(PortletDisplayTemplateConstants.REQUEST, request);\n\n\t\tRenderRequest renderRequest = (RenderRequest)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_PORTLET_REQUEST);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.RENDER_REQUEST, renderRequest);\n\n\t\tRenderResponse renderResponse = (RenderResponse)request.getAttribute(\n\t\t\tJavaConstants.JAVAX_PORTLET_RESPONSE);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.RENDER_RESPONSE, renderResponse);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.TAGLIB_LIFERAY,\n\t\t\t_getVelocityTaglib(pageContext));\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tcontextObjects.put(\n\t\t\tPortletDisplayTemplateConstants.THEME_DISPLAY, themeDisplay);\n\n\t\tcontextObjects.putAll(_getPortletPreferences(renderRequest));\n\n\t\tDDMTemplate ddmTemplate = DDMTemplateLocalServiceUtil.getTemplate(\n\t\t\tddmTemplateId);\n\n\t\treturn _transformer.transform(\n\t\t\tthemeDisplay, contextObjects, ddmTemplate.getScript(),\n\t\t\tddmTemplate.getLanguage());\n\t}","commit_id":"912967e523557550b01554656478f44a336468aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String doIncludeFTL(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String path, Theme theme,\n\t\t\tTemplateContextType templateContextType, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the FreeMarker template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString portletId = getPortletId(request);\n\n\t\tString resourcePath = theme.getResourcePath(\n\t\t\tservletContext, portletId, path);\n\n\t\tif (Validator.isNotNull(portletId) &&\n\t\t\tPortletConstants.hasInstanceId(portletId) &&\n\t\t\t!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath)) {\n\n\t\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\t\tresourcePath = theme.getResourcePath(\n\t\t\t\tservletContext, rootPortletId, path);\n\t\t}\n\n\t\tif (Validator.isNotNull(portletId) &&\n\t\t\t!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath)) {\n\n\t\t\tresourcePath = theme.getResourcePath(servletContext, null, path);\n\t\t}\n\n\t\tif (!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath)) {\n\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tTemplateResource templateResource =\n\t\t\tTemplateResourceLoaderUtil.getTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath);\n\n\t\tTemplate template = TemplateManagerUtil.getTemplate(\n\t\t\tTemplateManager.FREEMARKER, templateResource,\n\t\t\tTemplateContextType.STANDARD);\n\n\t\t// FreeMarker variables\n\n\t\ttemplate.prepare(request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\ttemplate.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\n\t\t\t// Wrapping is needed because of a bug in FreeMarker\n\n\t\t\twriter = UnsyncPrintWriterPool.borrow(pageContext.getOut());\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext, template);\n\n\t\ttemplate.put(\"taglibLiferay\", velocityTaglib);\n\t\ttemplate.put(\"theme\", velocityTaglib);\n\t\ttemplate.put(TemplateContext.WRITER, writer);\n\n\t\t// Portal JSP tag library factory\n\n\t\tTemplateHashModel portalTaglib =\n\t\t\tFreeMarkerTaglibFactoryUtil.createTaglibFactory(servletContext);\n\n\t\ttemplate.put(\"PortalJspTagLibs\", portalTaglib);\n\n\t\t// Theme JSP tag library factory\n\n\t\tTemplateHashModel themeTaglib =\n\t\t\tFreeMarkerTaglibFactoryUtil.createTaglibFactory(\n\t\t\t\tthemeServletContext);\n\n\t\ttemplate.put(\"ThemeJspTaglibs\", themeTaglib);\n\n\t\t// FreeMarker JSP tag library support\n\n\t\tfinal Servlet servlet = (Servlet)pageContext.getPage();\n\n\t\tGenericServlet genericServlet = null;\n\n\t\tif (servlet instanceof GenericServlet) {\n\t\t\tgenericServlet = (GenericServlet) servlet;\n\t\t}\n\t\telse {\n\t\t\tgenericServlet = new GenericServlet() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void service(\n\t\t\t\t\t\tServletRequest servletRequest,\n\t\t\t\t\t\tServletResponse servletResponse)\n\t\t\t\t\tthrows IOException, ServletException {\n\n\t\t\t\t\tservlet.service(servletRequest, servletResponse);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tgenericServlet.init(pageContext.getServletConfig());\n\t\t}\n\n\t\tServletContextHashModel servletContextHashModel =\n\t\t\tnew ServletContextHashModel(\n\t\t\t\tgenericServlet, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\ttemplate.put(\"Application\", servletContextHashModel);\n\n\t\tHttpRequestHashModel httpRequestHashModel = new HttpRequestHashModel(\n\t\t\trequest, response, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\ttemplate.put(\"Request\", httpRequestHashModel);\n\n\t\t// Merge templates\n\n\t\ttemplate.processTemplate(writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn writer.toString();\n\t\t}\n\t}","id":87330,"modified_method":"protected static String doIncludeFTL(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String path, Theme theme,\n\t\t\tTemplateContextType templateContextType, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the FreeMarker template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString portletId = getPortletId(request);\n\n\t\tString resourcePath = theme.getResourcePath(\n\t\t\tservletContext, portletId, path);\n\n\t\tif (Validator.isNotNull(portletId) &&\n\t\t\tPortletConstants.hasInstanceId(portletId) &&\n\t\t\t!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath)) {\n\n\t\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\t\tresourcePath = theme.getResourcePath(\n\t\t\t\tservletContext, rootPortletId, path);\n\t\t}\n\n\t\tif (Validator.isNotNull(portletId) &&\n\t\t\t!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath)) {\n\n\t\t\tresourcePath = theme.getResourcePath(servletContext, null, path);\n\t\t}\n\n\t\tif (!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath)) {\n\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tTemplateResource templateResource =\n\t\t\tTemplateResourceLoaderUtil.getTemplateResource(\n\t\t\t\tTemplateManager.FREEMARKER, resourcePath);\n\n\t\tTemplate template = TemplateManagerUtil.getTemplate(\n\t\t\tTemplateManager.FREEMARKER, templateResource,\n\t\t\tTemplateContextType.STANDARD);\n\n\t\t// FreeMarker variables\n\n\t\ttemplate.prepare(request);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\ttemplate.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\n\t\t\t// Wrapping is needed because of a bug in FreeMarker\n\n\t\t\twriter = UnsyncPrintWriterPool.borrow(pageContext.getOut());\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext, template);\n\n\t\ttemplate.put(TemplateContext.WRITER, writer);\n\t\ttemplate.put(\"taglibLiferay\", velocityTaglib);\n\t\ttemplate.put(\"theme\", velocityTaglib);\n\n\t\t// Portal JSP tag library factory\n\n\t\tTemplateHashModel portalTaglib =\n\t\t\tFreeMarkerTaglibFactoryUtil.createTaglibFactory(servletContext);\n\n\t\ttemplate.put(\"PortalJspTagLibs\", portalTaglib);\n\n\t\t// Theme JSP tag library factory\n\n\t\tTemplateHashModel themeTaglib =\n\t\t\tFreeMarkerTaglibFactoryUtil.createTaglibFactory(\n\t\t\t\tthemeServletContext);\n\n\t\ttemplate.put(\"ThemeJspTaglibs\", themeTaglib);\n\n\t\t// FreeMarker JSP tag library support\n\n\t\tfinal Servlet servlet = (Servlet)pageContext.getPage();\n\n\t\tGenericServlet genericServlet = null;\n\n\t\tif (servlet instanceof GenericServlet) {\n\t\t\tgenericServlet = (GenericServlet) servlet;\n\t\t}\n\t\telse {\n\t\t\tgenericServlet = new GenericServlet() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void service(\n\t\t\t\t\t\tServletRequest servletRequest,\n\t\t\t\t\t\tServletResponse servletResponse)\n\t\t\t\t\tthrows IOException, ServletException {\n\n\t\t\t\t\tservlet.service(servletRequest, servletResponse);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tgenericServlet.init(pageContext.getServletConfig());\n\t\t}\n\n\t\tServletContextHashModel servletContextHashModel =\n\t\t\tnew ServletContextHashModel(\n\t\t\t\tgenericServlet, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\ttemplate.put(\"Application\", servletContextHashModel);\n\n\t\tHttpRequestHashModel httpRequestHashModel = new HttpRequestHashModel(\n\t\t\trequest, response, ObjectWrapper.DEFAULT_WRAPPER);\n\n\t\ttemplate.put(\"Request\", httpRequestHashModel);\n\n\t\t// Merge templates\n\n\t\ttemplate.processTemplate(writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn writer.toString();\n\t\t}\n\t}","commit_id":"912967e523557550b01554656478f44a336468aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static String doIncludeVM(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme,\n\t\t\tTemplateContextType templateContextType, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the Velocity template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString portletId = getPortletId(request);\n\n\t\tString resourcePath = theme.getResourcePath(\n\t\t\tservletContext, portletId, page);\n\n\t\tboolean checkResourceExists = true;\n\n\t\tif (Validator.isNotNull(portletId)) {\n\t\t\tif (PortletConstants.hasInstanceId(portletId) &&\n\t\t\t\t(checkResourceExists = !\n\t\t\t\tTemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\t\tTemplateManager.VELOCITY, resourcePath))) {\n\n\t\t\t\tString rootPortletId = PortletConstants.getRootPortletId(\n\t\t\t\t\tportletId);\n\n\t\t\t\tresourcePath = theme.getResourcePath(\n\t\t\t\t\tservletContext, rootPortletId, page);\n\t\t\t}\n\n\t\t\tif (checkResourceExists &&\n\t\t\t\t(checkResourceExists = !\n\t\t\t\tTemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\t\tTemplateManager.VELOCITY, resourcePath))) {\n\n\t\t\t\tresourcePath = theme.getResourcePath(\n\t\t\t\t\tservletContext, null, page);\n\t\t\t}\n\t\t}\n\n\t\tif (checkResourceExists &&\n\t\t\t!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.VELOCITY, resourcePath)) {\n\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tTemplateResource templateResource =\n\t\t\tTemplateResourceLoaderUtil.getTemplateResource(\n\t\t\t\tTemplateManager.VELOCITY, resourcePath);\n\n\t\tif (templateResource == null) {\n\t\t\tthrow new Exception(\n\t\t\t\t\"Unable to load template resource \" + resourcePath);\n\t\t}\n\n\t\tTemplate template = TemplateManagerUtil.getTemplate(\n\t\t\tTemplateManager.VELOCITY, templateResource,\n\t\t\tTemplateContextType.STANDARD);\n\n\t\t// Velocity variables\n\n\t\ttemplate.prepare(request);\n\n\t\t// Page context\n\n\t\ttemplate.put(\"pageContext\", pageContext);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\ttemplate.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\t\t\twriter = pageContext.getOut();\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext, template);\n\n\t\ttemplate.put(\"taglibLiferay\", velocityTaglib);\n\t\ttemplate.put(\"theme\", velocityTaglib);\n\t\ttemplate.put(TemplateContext.WRITER, writer);\n\n\t\t// Merge templates\n\n\t\ttemplate.processTemplate(writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn ((UnsyncStringWriter)writer).toString();\n\t\t}\n\t}","id":87331,"modified_method":"protected static String doIncludeVM(\n\t\t\tServletContext servletContext, HttpServletRequest request,\n\t\t\tPageContext pageContext, String page, Theme theme,\n\t\t\tTemplateContextType templateContextType, boolean write)\n\t\tthrows Exception {\n\n\t\t// The servlet context name will be null when the theme is deployed to\n\t\t// the root directory in Tomcat. See\n\t\t// com.liferay.portal.servlet.MainServlet and\n\t\t// com.liferay.portlet.PortletContextImpl for other cases where a null\n\t\t// servlet context name is also converted to an empty string.\n\n\t\tString servletContextName = GetterUtil.getString(\n\t\t\ttheme.getServletContextName());\n\n\t\tif (ServletContextPool.get(servletContextName) == null) {\n\n\t\t\t// This should only happen if the Velocity template is the first\n\t\t\t// page to be accessed in the system\n\n\t\t\tServletContextPool.put(servletContextName, servletContext);\n\t\t}\n\n\t\tString portletId = getPortletId(request);\n\n\t\tString resourcePath = theme.getResourcePath(\n\t\t\tservletContext, portletId, page);\n\n\t\tboolean checkResourceExists = true;\n\n\t\tif (Validator.isNotNull(portletId)) {\n\t\t\tif (PortletConstants.hasInstanceId(portletId) &&\n\t\t\t\t(checkResourceExists = !\n\t\t\t\tTemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\t\tTemplateManager.VELOCITY, resourcePath))) {\n\n\t\t\t\tString rootPortletId = PortletConstants.getRootPortletId(\n\t\t\t\t\tportletId);\n\n\t\t\t\tresourcePath = theme.getResourcePath(\n\t\t\t\t\tservletContext, rootPortletId, page);\n\t\t\t}\n\n\t\t\tif (checkResourceExists &&\n\t\t\t\t(checkResourceExists = !\n\t\t\t\tTemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\t\tTemplateManager.VELOCITY, resourcePath))) {\n\n\t\t\t\tresourcePath = theme.getResourcePath(\n\t\t\t\t\tservletContext, null, page);\n\t\t\t}\n\t\t}\n\n\t\tif (checkResourceExists &&\n\t\t\t!TemplateResourceLoaderUtil.hasTemplateResource(\n\t\t\t\tTemplateManager.VELOCITY, resourcePath)) {\n\n\t\t\t_log.error(resourcePath + \" does not exist\");\n\n\t\t\treturn null;\n\t\t}\n\n\t\tTemplateResource templateResource =\n\t\t\tTemplateResourceLoaderUtil.getTemplateResource(\n\t\t\t\tTemplateManager.VELOCITY, resourcePath);\n\n\t\tif (templateResource == null) {\n\t\t\tthrow new Exception(\n\t\t\t\t\"Unable to load template resource \" + resourcePath);\n\t\t}\n\n\t\tTemplate template = TemplateManagerUtil.getTemplate(\n\t\t\tTemplateManager.VELOCITY, templateResource,\n\t\t\tTemplateContextType.STANDARD);\n\n\t\t// Velocity variables\n\n\t\ttemplate.prepare(request);\n\n\t\t// Page context\n\n\t\ttemplate.put(\"pageContext\", pageContext);\n\n\t\t// Theme servlet context\n\n\t\tServletContext themeServletContext = ServletContextPool.get(\n\t\t\tservletContextName);\n\n\t\ttemplate.put(\"themeServletContext\", themeServletContext);\n\n\t\t// Tag libraries\n\n\t\tHttpServletResponse response =\n\t\t\t(HttpServletResponse)pageContext.getResponse();\n\n\t\tWriter writer = null;\n\n\t\tif (write) {\n\t\t\twriter = pageContext.getOut();\n\t\t}\n\t\telse {\n\t\t\twriter = new UnsyncStringWriter();\n\t\t}\n\n\t\tVelocityTaglib velocityTaglib = new VelocityTaglib(\n\t\t\tservletContext, request,\n\t\t\tnew PipingServletResponse(response, writer), pageContext, template);\n\n\t\ttemplate.put(TemplateContext.WRITER, writer);\n\t\ttemplate.put(\"taglibLiferay\", velocityTaglib);\n\t\ttemplate.put(\"theme\", velocityTaglib);\n\n\t\t// Merge templates\n\n\t\ttemplate.processTemplate(writer);\n\n\t\tif (write) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\treturn ((UnsyncStringWriter)writer).toString();\n\t\t}\n\t}","commit_id":"912967e523557550b01554656478f44a336468aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getFormattedContent(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse,\n\t\t\tWikiPage wikiPage, PortletURL viewPageURL, PortletURL editPageURL,\n\t\t\tString title, boolean preview)\n\t\tthrows Exception {\n\n\t\tHttpServletRequest request = PortalUtil.getHttpServletRequest(\n\t\t\trenderRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tdouble version = ParamUtil.getDouble(request, \"version\");\n\n\t\tPortletURL curViewPageURL = PortletURLUtil.clone(\n\t\t\tviewPageURL, renderResponse);\n\t\tPortletURL curEditPageURL = PortletURLUtil.clone(\n\t\t\teditPageURL, renderResponse);\n\n\t\tString attachmentURLPrefix =\n\t\t\tthemeDisplay.getPathMain() + \"/wiki/get_page_attachment?p_l_id=\" +\n\t\t\tthemeDisplay.getPlid() + \"&nodeId=\" + wikiPage.getNodeId() +\n\t\t\t\"&title=\" + HttpUtil.encodeURL(wikiPage.getTitle()) + \"&fileName=\";\n\n\t\tWikiPageDisplay pageDisplay = null;\n\n\t\tif (!preview && (version == 0)) {\n\t\t\tpageDisplay = WikiCacheUtil.getDisplay(\n\t\t\t\twikiPage.getNodeId(), title, curViewPageURL, curEditPageURL,\n\t\t\t\tattachmentURLPrefix);\n\t\t}\n\n\t\tString formattedContent = null;\n\n\t\tif (pageDisplay != null) {\n\t\t\tformattedContent = pageDisplay.getFormattedContent();\n\t\t}\n\t\telse {\n\t\t\tformattedContent = WikiUtil.convert(\n\t\t\t\twikiPage, curViewPageURL, curEditPageURL, attachmentURLPrefix);\n\t\t}\n\n\t\treturn formattedContent;\n\t}","id":87332,"modified_method":"public static String getFormattedContent(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse,\n\t\t\tWikiPage wikiPage, PortletURL viewPageURL, PortletURL editPageURL,\n\t\t\tString title, boolean preview)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)renderRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tdouble version = ParamUtil.getDouble(renderRequest, \"version\");\n\n\t\tPortletURL curViewPageURL = PortletURLUtil.clone(\n\t\t\tviewPageURL, renderResponse);\n\t\tPortletURL curEditPageURL = PortletURLUtil.clone(\n\t\t\teditPageURL, renderResponse);\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tsb.append(themeDisplay.getPathMain());\n\t\tsb.append(\"/wiki/get_page_attachment?p_l_id=\");\n\t\tsb.append(themeDisplay.getPlid());\n\t\tsb.append(\"&nodeId=\");\n\t\tsb.append(wikiPage.getNodeId());\n\t\tsb.append(\"&title=\");\n\t\tsb.append(HttpUtil.encodeURL(wikiPage.getTitle()));\n\t\tsb.append(\"&fileName=\");\n\n\t\tString attachmentURLPrefix = sb.toString();\n\n\t\tif (!preview && (version == 0)) {\n\t\t\tWikiPageDisplay pageDisplay = WikiCacheUtil.getDisplay(\n\t\t\t\twikiPage.getNodeId(), title, curViewPageURL, curEditPageURL,\n\t\t\t\tattachmentURLPrefix);\n\n\t\t\tif (pageDisplay != null) {\n\t\t\t\treturn pageDisplay.getFormattedContent();\n\t\t\t}\n\t\t}\n\n\t\treturn WikiUtil.convert(\n\t\t\twikiPage, curViewPageURL, curEditPageURL, attachmentURLPrefix);\n\t}","commit_id":"912967e523557550b01554656478f44a336468aa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@BodyParser.Of(BodyParser.FormUrlEncoded.class)\n    public Result create() {\n        Map<String, String> params = flattenFormUrlEncoded(request().body().asFormUrlEncoded());\n\n        CreateSavedSearchRequest request = Json.fromJson(Json.parse(params.get(\"params\")), CreateSavedSearchRequest.class);\n\n        try {\n            savedSearchService.create(request);\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n\n        return status(202);\n    }","id":87333,"modified_method":"@BodyParser.Of(BodyParser.Json.class)\n    public Result create() {\n        CreateSavedSearchRequest request = Json.fromJson(request().body().asJson(), CreateSavedSearchRequest.class);\n\n        try {\n            savedSearchService.create(request);\n        } catch (IOException e) {\n            return internalServerError(\"io exception\");\n        } catch (APIException e) {\n            return internalServerError(\"api exception \" + e);\n        }\n\n        return status(202);\n    }","commit_id":"c0ab6455a5174713d47414f30cc196bf99836d69","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@BodyParser.Of(BodyParser.FormUrlEncoded.class)\n    public Result addWidget(String dashboardId) {\n        try {\n            final Map<String, String> params = flattenFormUrlEncoded(request().body().asFormUrlEncoded());\n\n            String query = params.get(\"query\");\n            String rangeType = params.get(\"rangeType\");\n            String description = params.get(\"description\");\n\n            Dashboard dashboard = dashboardService.get(dashboardId);\n\n            // Determine timerange type.\n            TimeRange timerange;\n            try {\n                int relative = 0;\n                if (params.get(\"relative\") != null) {\n                    relative = Integer.parseInt(params.get(\"relative\"));\n                }\n\n                timerange = TimeRange.factory(rangeType, relative, params.get(\"from\"), params.get(\"to\"), params.get(\"keyword\"));\n            } catch (InvalidRangeParametersException e2) {\n                return status(400, views.html.errors.error.render(\"Invalid range parameters provided.\", e2, request()));\n            } catch (IllegalArgumentException e1) {\n                return status(400, views.html.errors.error.render(\"Invalid range type provided.\", e1, request()));\n            }\n\n            String streamId;\n            if (params.containsKey(\"streamId\")) {\n                streamId = params.get(\"streamId\");\n            } else {\n                streamId = params.get(\"streamid\");\n            }\n\n            final DashboardWidget widget;\n            try {\n                final DashboardWidget.Type widgetType = DashboardWidget.Type.valueOf(params.get(\"widgetType\"));\n                switch (widgetType) {\n                    case SEARCH_RESULT_COUNT: {\n                        final Boolean trend = Boolean.parseBoolean(params.get(\"trend\"));\n                        if (trend) {\n                            if (!rangeType.equals(\"relative\")) {\n                                Logger.error(\"Cannot add search result count widget with trend on a non relative time range\");\n                                return badRequest();\n                            }\n                            final Boolean lowerIsBetter = Boolean.parseBoolean(params.get(\"lowerIsBetter\"));\n                            widget = new SearchResultCountWidget(dashboard, query, timerange, description, trend, lowerIsBetter);\n                        } else {\n                            widget = new SearchResultCountWidget(dashboard, query, timerange, description);\n                        }\n                        break;\n                    }\n                    case STREAM_SEARCH_RESULT_COUNT: {\n                        if (!canReadStream(streamId)) return unauthorized();\n                        final Boolean trend = Boolean.parseBoolean(params.get(\"trend\"));\n                        if (trend) {\n                            if (!rangeType.equals(\"relative\")) {\n                                Logger.error(\"Cannot add search result count widget with trend on a non relative time range\");\n                                return badRequest();\n                            }\n                            final Boolean lowerIsBetter = Boolean.parseBoolean(params.get(\"lowerIsBetter\"));\n                            widget = new StreamSearchResultCountWidget(dashboard, query, timerange, description, trend, lowerIsBetter, streamId);\n                        } else {\n                            widget = new StreamSearchResultCountWidget(dashboard, query, timerange, description, streamId);\n                        }\n                        break;\n                    }\n                    case FIELD_CHART:\n                        Map<String, Object> config = new HashMap<String, Object>() {{\n                            put(\"field\", params.get(\"field\"));\n                            put(\"valuetype\", params.get(\"valuetype\"));\n                            put(\"renderer\", params.get(\"renderer\"));\n                            put(\"interpolation\", params.get(\"interpolation\"));\n                            put(\"interval\", params.get(\"interval\"));\n                        }};\n                        if (!canReadStream(streamId)) return unauthorized();\n\n                        widget = new FieldChartWidget(dashboard, query, timerange, description, streamId, config);\n                        break;\n                    case QUICKVALUES:\n                        if (!canReadStream(streamId)) return unauthorized();\n                        widget = new QuickvaluesWidget(dashboard, query, timerange, params.get(\"field\"), description, streamId);\n                        break;\n                    case SEARCH_RESULT_CHART:\n                        if (!canReadStream(streamId)) return unauthorized();\n                        widget = new SearchResultChartWidget(dashboard, query, timerange, description, streamId, params.get(\"interval\"));\n                        break;\n                    case STATS_COUNT: {\n                        final String field = params.get(\"field\");\n                        final String statsFunction = params.get(\"statsFunction\");\n                        final Boolean trend = Boolean.parseBoolean(params.get(\"trend\"));\n                        if (trend) {\n                            if (!rangeType.equals(\"relative\")) {\n                                Logger.error(\"Cannot add statistical count widget with trend on a non relative time range\");\n                                return badRequest();\n                            }\n                            final Boolean lowerIsBetter = Boolean.parseBoolean(params.get(\"lowerIsBetter\"));\n                            widget = new StatisticalCountWidget(dashboard, query, timerange, description, trend, lowerIsBetter, field, statsFunction, streamId);\n                        } else {\n                            widget = new StatisticalCountWidget(dashboard, query, timerange, description, field, statsFunction, streamId);\n                        }\n                        break;\n                    }\n                    default:\n                        throw new IllegalArgumentException();\n                }\n            } catch (IllegalArgumentException e) {\n                Logger.error(\"No such widget type: \" + params.get(\"widgetType\"));\n                return badRequest();\n            }\n\n            dashboard.addWidget(widget);\n\n            return created();\n        } catch (APIException e) {\n            String message = \"Could not add widget. We got a HTTP \" + e.getHttpCode() + \".\";\n            return status(504, views.html.errors.error.render(message, e, request()));\n        } catch (IOException e) {\n            return status(504, views.html.errors.error.render(ApiClient.ERROR_MSG_IO, e, request()));\n        }\n    }","id":87334,"modified_method":"@BodyParser.Of(BodyParser.Json.class)\n    public Result addWidget(String dashboardId) {\n        try {\n            final AddWidgetRequest request = Json.fromJson(request().body().asJson(), AddWidgetRequest.class);\n\n            String query = (String) request.config().get(\"query\");\n            String rangeType = (String) request.config().get(\"range_type\");\n            String description = request.description();\n\n            Dashboard dashboard = dashboardService.get(dashboardId);\n\n            // Determine timerange type.\n            TimeRange timerange;\n            try {\n                int relative = 0;\n                Object relativeTimeRange = request.config().get(\"relative\");\n                if (relativeTimeRange != null) {\n                    relative = (Integer) relativeTimeRange;\n                }\n\n                timerange = TimeRange.factory(\n                        rangeType, relative,\n                        (String) request.config().get(\"from\"),\n                        (String) request.config().get(\"to\"),\n                        (String) request.config().get(\"keyword\"));\n            } catch (InvalidRangeParametersException e2) {\n                return status(400, views.html.errors.error.render(\"Invalid range parameters provided.\", e2, request()));\n            } catch (IllegalArgumentException e1) {\n                return status(400, views.html.errors.error.render(\"Invalid range type provided.\", e1, request()));\n            }\n\n            String streamId = \"\";\n\n            if (request.config().containsKey(\"streamId\")) {\n                streamId = (String) request.config().get(\"streamId\");\n            }\n\n            final DashboardWidget widget;\n            try {\n                final DashboardWidget.Type widgetType = DashboardWidget.Type.valueOf(request.type());\n                switch (widgetType) {\n                    case SEARCH_RESULT_COUNT: {\n                        final Map<String, Boolean> trendInformation = this.extractCountTrendInformation(request.config());\n                        if (trendInformation.get(\"trend\")) {\n                            if (!rangeType.equals(\"relative\")) {\n                                Logger.error(\"Cannot add search count widget with trend on a non relative time range\");\n                                return badRequest();\n                            }\n                            widget = new SearchResultCountWidget(dashboard, query, timerange, description, trendInformation.get(\"trend\"), trendInformation.get(\"lowerIsBetter\"));\n                        } else {\n                            widget = new SearchResultCountWidget(dashboard, query, timerange, description);\n                        }\n                        break;\n                    }\n                    case STREAM_SEARCH_RESULT_COUNT: {\n                        if (!canReadStream(streamId)) return unauthorized();\n                        final Map<String, Boolean> trendInformation = this.extractCountTrendInformation(request.config());\n                        if (trendInformation.get(\"trend\")) {\n                            if (!rangeType.equals(\"relative\")) {\n                                Logger.error(\"Cannot add search result count widget with trend on a non relative time range\");\n                                return badRequest();\n                            }\n                            widget = new StreamSearchResultCountWidget(dashboard, query, timerange, description, trendInformation.get(\"trend\"), trendInformation.get(\"lowerIsBetter\"), streamId);\n                        } else {\n                            widget = new StreamSearchResultCountWidget(dashboard, query, timerange, description, streamId);\n                        }\n                        break;\n                    }\n                    case FIELD_CHART:\n                        Map<String, Object> config = new HashMap<String, Object>() {{\n                            put(\"field\", request.config().get(\"field\"));\n                            put(\"valuetype\", request.config().get(\"valuetype\"));\n                            put(\"renderer\", request.config().get(\"renderer\"));\n                            put(\"interpolation\", request.config().get(\"interpolation\"));\n                            put(\"interval\", request.config().get(\"interval\"));\n                        }};\n                        if (!canReadStream(streamId)) return unauthorized();\n\n                        widget = new FieldChartWidget(dashboard, query, timerange, description, streamId, config);\n                        break;\n                    case QUICKVALUES:\n                        if (!canReadStream(streamId)) return unauthorized();\n                        widget = new QuickvaluesWidget(dashboard, query, timerange, (String) request.config().get(\"field\"), description, streamId);\n                        break;\n                    case SEARCH_RESULT_CHART:\n                        if (!canReadStream(streamId)) return unauthorized();\n                        widget = new SearchResultChartWidget(dashboard, query, timerange, description, streamId, (String) request.config().get(\"interval\"));\n                        break;\n                    case STATS_COUNT: {\n                        final String field = (String) request.config().get(\"field\");\n                        final String statsFunction = (String) request.config().get(\"statsFunction\");\n                        final Map<String, Boolean> trendInformation = this.extractCountTrendInformation(request.config());\n                        if (trendInformation.get(\"trend\")) {\n                            if (!rangeType.equals(\"relative\")) {\n                                Logger.error(\"Cannot add statistical count widget with trend on a non relative time range\");\n                                return badRequest();\n                            }\n                            widget = new StatisticalCountWidget(dashboard, query, timerange, description, trendInformation.get(\"trend\"), trendInformation.get(\"lowerIsBetter\"), field, statsFunction, streamId);\n                        } else {\n                            widget = new StatisticalCountWidget(dashboard, query, timerange, description, field, statsFunction, streamId);\n                        }\n                        break;\n                    }\n                    default:\n                        throw new IllegalArgumentException();\n                }\n            } catch (IllegalArgumentException e) {\n                Logger.error(\"No such widget type: \" + request.type());\n                return badRequest();\n            }\n\n            dashboard.addWidget(widget);\n\n            return created();\n        } catch (APIException e) {\n            String message = \"Could not add widget. We got a HTTP \" + e.getHttpCode() + \".\";\n            return status(504, views.html.errors.error.render(message, e, request()));\n        } catch (IOException e) {\n            return status(504, views.html.errors.error.render(ApiClient.ERROR_MSG_IO, e, request()));\n        }\n    }","commit_id":"bf5741487b6bc3f22af6143d6372cee535ee63dc","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void block() {\n         blockReceived = true;\n         flushStartReceived.countDown();\n      }","id":87335,"modified_method":"public void block() {\n            blockReceived=true;\n            if(flushStartReceived != null)\n                flushStartReceived.countDown();\n            events.add(new BlockEvent());\n        }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"Listener(JChannel channel, CountDownLatch flushStartReceived, CountDownLatch flushStopReceived) {\n         this.channel = channel;\n         this.flushStartReceived = flushStartReceived;\n         this.flushStopReceived = flushStopReceived;\n         this.channel.setReceiver(this);\n      }","id":87336,"modified_method":"Listener(String name, JChannel channel, CountDownLatch flushStartReceived, CountDownLatch flushStopReceived) {\n            this.name=name;\n            this.channel=channel;\n            this.flushStartReceived=flushStartReceived;\n            this.flushStopReceived=flushStopReceived;\n            this.channel.setReceiver(this);\n        }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests 2 channels calling partial FLUSHes and one calling FLUSH simultaneously\n    */\n   @Test\n   public void testConcurrentFlushAndPartialFlush() throws Exception {\n      c1 = createChannel(true, 3);\n      c1.connect(\"testConcurrentFlushAndPartialFlush\");\n\n      c2 = createChannel(c1);\n      c2.connect(\"testConcurrentFlushAndPartialFlush\");\n\n      c3 = createChannel(c1);\n      c3.connect(\"testConcurrentFlushAndPartialFlush\");\n      assertViewsReceived(c1, c2, c3);\n\n      final CountDownLatch startFlushLatch = new CountDownLatch(1);\n      final CountDownLatch stopFlushLatch = new CountDownLatch(1);\n\n      // 2 because either total or partial has to finish first\n      final CountDownLatch flushStartReceived = new CountDownLatch(2);\n\n      // 5 because we have total and partial flush\n      final CountDownLatch flushStopReceived = new CountDownLatch(5);\n\n      Thread t1 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               Util.startFlush(c1);\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c1.stopFlush();\n            }\n         }\n      };\n\n      Thread t2 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               // partial, only between c2 and c3\n               Util.startFlush(c2, (Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress())));\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c2.stopFlush(Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress()));\n            }\n         }\n      };\n\n      Listener l1 = new Listener(c1, flushStartReceived, flushStopReceived);\n      Listener l2 = new Listener(c2, flushStartReceived, flushStopReceived);\n      Listener l3 = new Listener(c3, flushStartReceived, flushStopReceived);\n\n      t1.start();\n      t2.start();\n\n      startFlushLatch.countDown();\n\n      assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n      // at this stage both channels should have started a flush?\n      stopFlushLatch.countDown();\n      \n      t1.join();\n      t2.join();\n\n      assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n\n      assertTrue(l1.blockReceived);\n      assertTrue(l1.unblockReceived);\n      assertTrue(l2.blockReceived);\n      assertTrue(l2.unblockReceived);\n      assertTrue(l3.blockReceived);\n      assertTrue(l3.unblockReceived);\n   }","id":87337,"modified_method":"/**\n     * Tests 2 channels calling partial FLUSHes and one calling FLUSH simultaneously\n     */\n    @Test\n    public void testConcurrentFlushAndPartialFlush() throws Exception {\n        c1=createChannel(true, 3);\n        c1.connect(\"testConcurrentFlushAndPartialFlush\");\n\n        c2=createChannel(c1);\n        c2.connect(\"testConcurrentFlushAndPartialFlush\");\n\n        c3=createChannel(c1);\n        c3.connect(\"testConcurrentFlushAndPartialFlush\");\n        assertViewsReceived(c1, c2, c3);\n\n        final CountDownLatch startFlushLatch=new CountDownLatch(1);\n        final CountDownLatch stopFlushLatch=new CountDownLatch(1);\n\n        // 2 because either total or partial has to finish first\n        final CountDownLatch flushStartReceived=new CountDownLatch(2);\n\n        // 5 because we have total and partial flush\n        final CountDownLatch flushStopReceived=new CountDownLatch(5);\n\n        Thread t1=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    boolean rc=Util.startFlush(c1);\n                    System.out.println(\"t1: rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c1.stopFlush();\n                }\n            }\n        };\n\n        Thread t2=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    // partial, only between c2 and c3\n                    boolean rc=Util.startFlush(c2, (Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress())));\n                    System.out.println(\"t2: partial flush rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c2.stopFlush(Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress()));\n                }\n            }\n        };\n\n        Listener l1=new Listener(\"c1\", c1, flushStartReceived, flushStopReceived);\n        Listener l2=new Listener(\"c2\", c2, flushStartReceived, flushStopReceived);\n        Listener l3=new Listener(\"c3\", c3, flushStartReceived, flushStopReceived);\n\n        t1.start();\n        t2.start();\n\n        startFlushLatch.countDown();\n\n        assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n        // at this stage both channels should have started a flush?\n        stopFlushLatch.countDown();\n\n        t1.join();\n        t2.join();\n\n        assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n\n        assert l1.blockReceived;\n        assert l1.unblockReceived;\n        assert l2.blockReceived;\n        assert l2.unblockReceived;\n        assert l3.blockReceived;\n        assert l3.unblockReceived;\n    }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests A.startFlush(), followed by another A.startFlush()\n    */\n   @Test\n   public void testTwoStartFlushesOnSameMemberWithTotalFlush() throws Exception {\n      c1 = createChannel(true, 3);\n      c1.connect(\"testTwoStartFlushes\");\n      c2 = createChannel(c1);\n      c2.connect(\"testTwoStartFlushes\");\n      assertViewsReceived(c1, c2);\n\n      startFlush(c1, false);\n\n      new Thread() {\n         public void run() {\n            stopFlush(c1);\n         }\n      }.start();\n\n      boolean rc = startFlush(c1, false);\n      assert rc;\n      stopFlush(c1);\n\n      rc = startFlush(c1, false);\n      assert rc;\n      stopFlush(c1);\n\n      rc = startFlush(c1, true);\n      assert rc;\n\n      rc = startFlush(c1, true);\n\n      rc = startFlush(c2, true);\n   }","id":87338,"modified_method":"/**\n     * Tests A.startFlush(), followed by another A.startFlush()\n     */\n    @Test\n    public void testTwoStartFlushesOnSameMemberWithTotalFlush() throws Exception {\n        c1=createChannel(true, 3);\n        c1.connect(\"testTwoStartFlushes\");\n        c2=createChannel(c1);\n        c2.connect(\"testTwoStartFlushes\");\n        assertViewsReceived(c1, c2);\n\n        boolean rc=startFlush(c1, true);\n        assert rc;\n\n        rc=startFlush(c1, false);\n        assert rc;\n\n        rc=startFlush(c1, 1, 500, false);\n        assert !rc;\n        stopFlush(c1);\n\n        rc=startFlush(c1, true);\n        assert rc;\n    }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests A.startFlush(), followed by another A.startFlush()\n    */\n   public void testTwoStartFlushesOnDifferentMembersWithTotalFlush() throws Exception {\n      c1 = createChannel(true, 3);\n      c1.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n      c2 = createChannel(c1);\n      c2.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n      assertViewsReceived(c1, c2);\n\n      boolean rc = startFlush(c1, false);\n      assert rc;\n\n      rc = startFlush(c2, false);\n      assert !rc;\n\n      new Thread() {\n         public void run() {\n            stopFlush(c1);\n         }\n      }.start();\n\n      rc = startFlush(c2, false);\n      assert rc;\n      stopFlush(c2);\n\n      rc = startFlush(c1, false);\n      assert rc;\n      stopFlush(c1);\n\n      rc = startFlush(c2, true);\n      assert rc;\n\n      rc = startFlush(c1, true);\n\n      rc = startFlush(c2, true);\n   }","id":87339,"modified_method":"/**\n     * Tests A.startFlush(), followed by another A.startFlush()\n     */\n    public void testTwoStartFlushesOnDifferentMembersWithTotalFlush() throws Exception {\n        c1=createChannel(true, 3);\n        c1.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n        c2=createChannel(c1);\n        c2.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n        assertViewsReceived(c1, c2);\n\n        boolean rc=startFlush(c1, false);\n        assert rc;\n\n        rc=startFlush(c2, 1, 500, false);\n        assert !rc;\n\n        stopFlush(c1);\n\n        rc=startFlush(c2, false);\n        assert rc;\n        stopFlush(c2);\n\n        rc=startFlush(c1, false);\n        assert rc;\n        stopFlush(c2); // c2 can actually stop a flush started by c1\n\n        rc=startFlush(c2, true);\n        assert rc;\n    }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean startFlush(Channel ch, boolean automatic_resume) {\n      log.debug(\"starting flush on \" + ch.getLocalAddress() + \" with automatic resume=\"\n               + automatic_resume);\n      boolean result = Util.startFlush(ch);\n      if (automatic_resume) {\n         ch.stopFlush();\n      }\n      return result;\n   }","id":87340,"modified_method":"private boolean startFlush(Channel ch, boolean automatic_resume) {\n        log.debug(\"starting flush on \" + ch.getAddress() + \" with automatic resume=\" + automatic_resume);\n        boolean result=Util.startFlush(ch);\n        if(automatic_resume) {\n            ch.stopFlush();\n        }\n        return result;\n    }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests 2 channels calling FLUSH simultaneously\n    */\n   @Test\n   public void testConcurrentFlush() throws Exception {\n      c1 = createChannel(true, 2);\n      c1.connect(\"testConcurrentFlush\");\n      c2 = createChannel(c1);\n      c2.connect(\"testConcurrentFlush\");\n\n      assertViewsReceived(c1, c2);\n\n      final CountDownLatch startFlushLatch = new CountDownLatch(1);\n      final CountDownLatch stopFlushLatch = new CountDownLatch(1);\n      final CountDownLatch flushStartReceived = new CountDownLatch(2);\n      final CountDownLatch flushStopReceived = new CountDownLatch(2);\n\n      Thread t1 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               Util.startFlush(c1);\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c1.stopFlush();\n            }\n         }\n      };\n\n      Thread t2 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               Util.startFlush(c2);\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c2.stopFlush();\n            }\n         }\n      };\n\n      Listener l1 = new Listener(c1, flushStartReceived, flushStopReceived);\n      Listener l2 = new Listener(c2, flushStartReceived, flushStopReceived);\n      t1.start();\n      t2.start();\n\n      startFlushLatch.countDown();\n\n      assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n      // at this stage both channels should have started a flush\n      stopFlushLatch.countDown();\n      \n      t1.join();\n      t2.join();\n\n      assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n      \n\n      assert l1.blockReceived;\n      assert l1.unblockReceived;\n      assert l2.blockReceived;\n      assert l2.unblockReceived;\n   }","id":87341,"modified_method":"/**\n     * Tests 2 channels calling FLUSH simultaneously\n     */\n    @Test\n    public void testConcurrentFlush() throws Exception {\n        c1=createChannel(true, 2);\n        c1.connect(\"testConcurrentFlush\");\n        c2=createChannel(c1);\n        c2.connect(\"testConcurrentFlush\");\n\n        assertViewsReceived(c1, c2);\n\n        final CountDownLatch startFlushLatch=new CountDownLatch(1);\n        final CountDownLatch stopFlushLatch=new CountDownLatch(1);\n        final CountDownLatch flushStartReceived=new CountDownLatch(2);\n        final CountDownLatch flushStopReceived=new CountDownLatch(2);\n\n        Thread t1=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    boolean rc=Util.startFlush(c1);\n                    System.out.println(\"t1: rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c1.stopFlush();\n                }\n            }\n        };\n\n        Thread t2=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    boolean rc=Util.startFlush(c2);\n                    System.out.println(\"t2: rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c2.stopFlush();\n                }\n            }\n        };\n\n        Listener l1=new Listener(\"c1\", c1, flushStartReceived, flushStopReceived);\n        Listener l2=new Listener(\"c2\", c2, flushStartReceived, flushStopReceived);\n        t1.start();\n        t2.start();\n\n        startFlushLatch.countDown();\n\n        assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n        // at this stage both channels should have started a flush\n        stopFlushLatch.countDown();\n\n        t1.join();\n        t2.join();\n\n        assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n\n\n        assert l1.blockReceived;\n        assert l1.unblockReceived;\n        assert l2.blockReceived;\n        assert l2.unblockReceived;\n    }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void unblock() {\n         unblockReceived = true;\n         flushStopReceived.countDown();\n      }","id":87342,"modified_method":"public void unblock() {\n            unblockReceived=true;\n            if(flushStopReceived != null)\n                flushStopReceived.countDown();\n            events.add(new UnblockEvent());\n        }","commit_id":"e3e8ce1d54159fb03260025a915827ff37e64e3b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests A.startFlush(), followed by another A.startFlush()\n    */\n   public void testTwoStartFlushesOnDifferentMembersWithTotalFlush() throws Exception {\n      c1 = createChannel(true, 3);\n      c1.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n      c2 = createChannel(c1);\n      c2.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n      assertViewsReceived(c1, c2);\n\n      boolean rc = startFlush(c1, false);\n      assert rc;\n\n      rc = startFlush(c2, false);\n      assert !rc;\n\n      new Thread() {\n         public void run() {\n            stopFlush(c1);\n         }\n      }.start();\n\n      rc = startFlush(c2, false);\n      assert rc;\n      stopFlush(c2);\n\n      rc = startFlush(c1, false);\n      assert rc;\n      stopFlush(c1);\n\n      rc = startFlush(c2, true);\n      assert rc;\n\n      rc = startFlush(c1, true);\n\n      rc = startFlush(c2, true);\n   }","id":87343,"modified_method":"/**\n     * Tests A.startFlush(), followed by another A.startFlush()\n     */\n    public void testTwoStartFlushesOnDifferentMembersWithTotalFlush() throws Exception {\n        c1=createChannel(true, 3);\n        c1.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n        c2=createChannel(c1);\n        c2.connect(\"testTwoStartFlushesOnDifferentMembersWithTotalFlush\");\n        assertViewsReceived(c1, c2);\n\n        boolean rc=startFlush(c1, false);\n        assert rc;\n\n        rc=startFlush(c2, 1, 500, false);\n        assert !rc;\n\n        stopFlush(c1);\n\n        rc=startFlush(c2, false);\n        assert rc;\n        stopFlush(c2);\n\n        rc=startFlush(c1, false);\n        assert rc;\n        stopFlush(c2); // c2 can actually stop a flush started by c1\n\n        rc=startFlush(c2, true);\n        assert rc;\n    }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"Listener(JChannel channel, CountDownLatch flushStartReceived, CountDownLatch flushStopReceived) {\n         this.channel = channel;\n         this.flushStartReceived = flushStartReceived;\n         this.flushStopReceived = flushStopReceived;\n         this.channel.setReceiver(this);\n      }","id":87344,"modified_method":"Listener(String name, JChannel channel, CountDownLatch flushStartReceived, CountDownLatch flushStopReceived) {\n            this.name=name;\n            this.channel=channel;\n            this.flushStartReceived=flushStartReceived;\n            this.flushStopReceived=flushStopReceived;\n            this.channel.setReceiver(this);\n        }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"private boolean startFlush(Channel ch, boolean automatic_resume) {\n      log.debug(\"starting flush on \" + ch.getLocalAddress() + \" with automatic resume=\"\n               + automatic_resume);\n      boolean result = Util.startFlush(ch);\n      if (automatic_resume) {\n         ch.stopFlush();\n      }\n      return result;\n   }","id":87345,"modified_method":"private boolean startFlush(Channel ch, boolean automatic_resume) {\n        log.debug(\"starting flush on \" + ch.getAddress() + \" with automatic resume=\" + automatic_resume);\n        boolean result=Util.startFlush(ch);\n        if(automatic_resume) {\n            ch.stopFlush();\n        }\n        return result;\n    }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"public void unblock() {\n         unblockReceived = true;\n         flushStopReceived.countDown();\n      }","id":87346,"modified_method":"public void unblock() {\n            unblockReceived=true;\n            if(flushStopReceived != null)\n                flushStopReceived.countDown();\n            events.add(new UnblockEvent());\n        }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests 2 channels calling FLUSH simultaneously\n    */\n   @Test\n   public void testConcurrentFlush() throws Exception {\n      c1 = createChannel(true, 2);\n      c1.connect(\"testConcurrentFlush\");\n      c2 = createChannel(c1);\n      c2.connect(\"testConcurrentFlush\");\n\n      assertViewsReceived(c1, c2);\n\n      final CountDownLatch startFlushLatch = new CountDownLatch(1);\n      final CountDownLatch stopFlushLatch = new CountDownLatch(1);\n      final CountDownLatch flushStartReceived = new CountDownLatch(2);\n      final CountDownLatch flushStopReceived = new CountDownLatch(2);\n\n      Thread t1 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               Util.startFlush(c1);\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c1.stopFlush();\n            }\n         }\n      };\n\n      Thread t2 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               Util.startFlush(c2);\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c2.stopFlush();\n            }\n         }\n      };\n\n      Listener l1 = new Listener(c1, flushStartReceived, flushStopReceived);\n      Listener l2 = new Listener(c2, flushStartReceived, flushStopReceived);\n      t1.start();\n      t2.start();\n\n      startFlushLatch.countDown();\n\n      assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n      // at this stage both channels should have started a flush\n      stopFlushLatch.countDown();\n      \n      t1.join();\n      t2.join();\n\n      assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n      \n\n      assert l1.blockReceived;\n      assert l1.unblockReceived;\n      assert l2.blockReceived;\n      assert l2.unblockReceived;\n   }","id":87347,"modified_method":"/**\n     * Tests 2 channels calling FLUSH simultaneously\n     */\n    @Test\n    public void testConcurrentFlush() throws Exception {\n        c1=createChannel(true, 2);\n        c1.connect(\"testConcurrentFlush\");\n        c2=createChannel(c1);\n        c2.connect(\"testConcurrentFlush\");\n\n        assertViewsReceived(c1, c2);\n\n        final CountDownLatch startFlushLatch=new CountDownLatch(1);\n        final CountDownLatch stopFlushLatch=new CountDownLatch(1);\n        final CountDownLatch flushStartReceived=new CountDownLatch(2);\n        final CountDownLatch flushStopReceived=new CountDownLatch(2);\n\n        Thread t1=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    boolean rc=Util.startFlush(c1);\n                    System.out.println(\"t1: rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c1.stopFlush();\n                }\n            }\n        };\n\n        Thread t2=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    boolean rc=Util.startFlush(c2);\n                    System.out.println(\"t2: rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c2.stopFlush();\n                }\n            }\n        };\n\n        Listener l1=new Listener(\"c1\", c1, flushStartReceived, flushStopReceived);\n        Listener l2=new Listener(\"c2\", c2, flushStartReceived, flushStopReceived);\n        t1.start();\n        t2.start();\n\n        startFlushLatch.countDown();\n\n        assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n        // at this stage both channels should have started a flush\n        stopFlushLatch.countDown();\n\n        t1.join();\n        t2.join();\n\n        assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n\n\n        assert l1.blockReceived;\n        assert l1.unblockReceived;\n        assert l2.blockReceived;\n        assert l2.unblockReceived;\n    }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests 2 channels calling partial FLUSHes and one calling FLUSH simultaneously\n    */\n   @Test\n   public void testConcurrentFlushAndPartialFlush() throws Exception {\n      c1 = createChannel(true, 3);\n      c1.connect(\"testConcurrentFlushAndPartialFlush\");\n\n      c2 = createChannel(c1);\n      c2.connect(\"testConcurrentFlushAndPartialFlush\");\n\n      c3 = createChannel(c1);\n      c3.connect(\"testConcurrentFlushAndPartialFlush\");\n      assertViewsReceived(c1, c2, c3);\n\n      final CountDownLatch startFlushLatch = new CountDownLatch(1);\n      final CountDownLatch stopFlushLatch = new CountDownLatch(1);\n\n      // 2 because either total or partial has to finish first\n      final CountDownLatch flushStartReceived = new CountDownLatch(2);\n\n      // 5 because we have total and partial flush\n      final CountDownLatch flushStopReceived = new CountDownLatch(5);\n\n      Thread t1 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               Util.startFlush(c1);\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c1.stopFlush();\n            }\n         }\n      };\n\n      Thread t2 = new Thread() {\n         public void run() {\n            try {\n               startFlushLatch.await();\n               // partial, only between c2 and c3\n               Util.startFlush(c2, (Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress())));\n            } catch (InterruptedException e) {\n               interrupt();\n            }\n\n            try {\n               stopFlushLatch.await();\n            } catch (InterruptedException e) {\n               interrupt();\n            } finally {\n               c2.stopFlush(Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress()));\n            }\n         }\n      };\n\n      Listener l1 = new Listener(c1, flushStartReceived, flushStopReceived);\n      Listener l2 = new Listener(c2, flushStartReceived, flushStopReceived);\n      Listener l3 = new Listener(c3, flushStartReceived, flushStopReceived);\n\n      t1.start();\n      t2.start();\n\n      startFlushLatch.countDown();\n\n      assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n      // at this stage both channels should have started a flush?\n      stopFlushLatch.countDown();\n      \n      t1.join();\n      t2.join();\n\n      assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n\n      assertTrue(l1.blockReceived);\n      assertTrue(l1.unblockReceived);\n      assertTrue(l2.blockReceived);\n      assertTrue(l2.unblockReceived);\n      assertTrue(l3.blockReceived);\n      assertTrue(l3.unblockReceived);\n   }","id":87348,"modified_method":"/**\n     * Tests 2 channels calling partial FLUSHes and one calling FLUSH simultaneously\n     */\n    @Test\n    public void testConcurrentFlushAndPartialFlush() throws Exception {\n        c1=createChannel(true, 3);\n        c1.connect(\"testConcurrentFlushAndPartialFlush\");\n\n        c2=createChannel(c1);\n        c2.connect(\"testConcurrentFlushAndPartialFlush\");\n\n        c3=createChannel(c1);\n        c3.connect(\"testConcurrentFlushAndPartialFlush\");\n        assertViewsReceived(c1, c2, c3);\n\n        final CountDownLatch startFlushLatch=new CountDownLatch(1);\n        final CountDownLatch stopFlushLatch=new CountDownLatch(1);\n\n        // 2 because either total or partial has to finish first\n        final CountDownLatch flushStartReceived=new CountDownLatch(2);\n\n        // 5 because we have total and partial flush\n        final CountDownLatch flushStopReceived=new CountDownLatch(5);\n\n        Thread t1=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    boolean rc=Util.startFlush(c1);\n                    System.out.println(\"t1: rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c1.stopFlush();\n                }\n            }\n        };\n\n        Thread t2=new Thread() {\n            public void run() {\n                try {\n                    startFlushLatch.await();\n                    // partial, only between c2 and c3\n                    boolean rc=Util.startFlush(c2, (Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress())));\n                    System.out.println(\"t2: partial flush rc=\" + rc);\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n\n                try {\n                    stopFlushLatch.await();\n                }\n                catch(InterruptedException e) {\n                    interrupt();\n                }\n                finally {\n                    c2.stopFlush(Arrays.asList(c2.getLocalAddress(), c3.getLocalAddress()));\n                }\n            }\n        };\n\n        Listener l1=new Listener(\"c1\", c1, flushStartReceived, flushStopReceived);\n        Listener l2=new Listener(\"c2\", c2, flushStartReceived, flushStopReceived);\n        Listener l3=new Listener(\"c3\", c3, flushStartReceived, flushStopReceived);\n\n        t1.start();\n        t2.start();\n\n        startFlushLatch.countDown();\n\n        assertTrue(flushStartReceived.await(60, TimeUnit.SECONDS));\n\n        // at this stage both channels should have started a flush?\n        stopFlushLatch.countDown();\n\n        t1.join();\n        t2.join();\n\n        assertTrue(flushStopReceived.await(60, TimeUnit.SECONDS));\n\n        assert l1.blockReceived;\n        assert l1.unblockReceived;\n        assert l2.blockReceived;\n        assert l2.unblockReceived;\n        assert l3.blockReceived;\n        assert l3.unblockReceived;\n    }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Tests A.startFlush(), followed by another A.startFlush()\n    */\n   @Test\n   public void testTwoStartFlushesOnSameMemberWithTotalFlush() throws Exception {\n      c1 = createChannel(true, 3);\n      c1.connect(\"testTwoStartFlushes\");\n      c2 = createChannel(c1);\n      c2.connect(\"testTwoStartFlushes\");\n      assertViewsReceived(c1, c2);\n\n      startFlush(c1, false);\n\n      new Thread() {\n         public void run() {\n            stopFlush(c1);\n         }\n      }.start();\n\n      boolean rc = startFlush(c1, false);\n      assert rc;\n      stopFlush(c1);\n\n      rc = startFlush(c1, false);\n      assert rc;\n      stopFlush(c1);\n\n      rc = startFlush(c1, true);\n      assert rc;\n\n      rc = startFlush(c1, true);\n\n      rc = startFlush(c2, true);\n   }","id":87349,"modified_method":"/**\n     * Tests A.startFlush(), followed by another A.startFlush()\n     */\n    @Test\n    public void testTwoStartFlushesOnSameMemberWithTotalFlush() throws Exception {\n        c1=createChannel(true, 3);\n        c1.connect(\"testTwoStartFlushes\");\n        c2=createChannel(c1);\n        c2.connect(\"testTwoStartFlushes\");\n        assertViewsReceived(c1, c2);\n\n        boolean rc=startFlush(c1, true);\n        assert rc;\n\n        rc=startFlush(c1, false);\n        assert rc;\n\n        rc=startFlush(c1, 1, 500, false);\n        assert !rc;\n        stopFlush(c1);\n\n        rc=startFlush(c1, true);\n        assert rc;\n    }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"public void block() {\n         blockReceived = true;\n         flushStartReceived.countDown();\n      }","id":87350,"modified_method":"public void block() {\n            blockReceived=true;\n            if(flushStartReceived != null)\n                flushStartReceived.countDown();\n            events.add(new BlockEvent());\n        }","commit_id":"09cfc9a8c6503918d41ba0f45151c52c4b315ac6","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n  public void stop() {\n    try {\n      logFileWriter.flush();\n      logFileWriter.close();\n\n      if (logWriterFuture != null && !logWriterFuture.isCancelled() && !logWriterFuture.isDone()) {\n        logWriterFuture.cancel(false);\n        logWriterFuture = null;\n      }\n\n      if (cleanupFuture != null && !cleanupFuture.isCancelled() && !cleanupFuture.isDone()) {\n        cleanupFuture.cancel(false);\n        cleanupFuture = null;\n      }\n\n      countDownLatch.countDown();\n\n      if (scheduledExecutor != null) {\n        scheduledExecutor.shutdown();\n      }\n    } catch (Exception e) {\n      LOG.error(\"Caught exception while closing logWriter {}\", e.getMessage(), e);\n    }\n    messageTable.clear();\n  }","id":87351,"modified_method":"@Override\n  public void stop() {\n    try {\n      if (countDownLatch != null) {\n        countDownLatch.countDown();\n      }\n\n      if (scheduledExecutor != null) {\n        scheduledExecutor.shutdown();\n      }\n\n      scheduledExecutor.awaitTermination(5, TimeUnit.MINUTES);\n\n      logFileWriter.flush();\n      logFileWriter.close();\n\n    } catch (Exception e) {\n      LOG.error(\"Caught exception while closing logWriter {}\", e.getMessage(), e);\n    }\n    messageTable.clear();\n  }","commit_id":"6afadafc8512c82b3222abcf7c3ce11a837214b2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void onReceived(Iterator<FetchedMessage> messages) {\n\n    try {\n      if (stopLatch.await(50, TimeUnit.MICROSECONDS)) {\n        // if count down occurred return\n        LOG.info(\"Returning since callback is cancelled.\");\n        return;\n      }\n    } catch (InterruptedException e) {\n      LOG.error(\"Exception: \", e);\n      Thread.currentThread().interrupt();\n      return;\n    }\n\n    int count = 0;\n\n    while (messages.hasNext()) {\n      FetchedMessage message = messages.next();\n      try {\n        GenericRecord genericRecord = serializer.toGenericRecord(message.getPayload());\n        ILoggingEvent event = serializer.fromGenericRecord(genericRecord);\n\n        LoggingContext loggingContext = LoggingContextHelper.getLoggingContext(event.getMDCPropertyMap());\n        KafkaLogEvent logEvent = new KafkaLogEvent(genericRecord, event, loggingContext,\n                                                   message.getTopicPartition().getPartition(),\n                                                   message.getNextOffset());\n\n        for (KafkaLogProcessor processor : kafkaLogProcessors) {\n          processor.process(logEvent);\n        }\n      } catch (Throwable th) {\n        LOG.error(\"Error processing message at topic {} parition {}\",\n                  message.getTopicPartition().getTopic(),\n                  message.getTopicPartition().getPartition());\n      }\n\n      count++;\n    }\n    LOG.trace(\"Got {} messages from kafka\", count);\n  }","id":87352,"modified_method":"@Override\n  public void onReceived(Iterator<FetchedMessage> messages) {\n\n    try {\n      if (stopLatch.await(50, TimeUnit.MICROSECONDS)) {\n        // if count down occurred return\n        LOG.info(\"Returning since callback is cancelled.\");\n        return;\n      }\n    } catch (InterruptedException e) {\n      LOG.error(\"Exception: \", e);\n      Thread.currentThread().interrupt();\n      return;\n    }\n\n    int count = 0;\n\n    while (messages.hasNext()) {\n      FetchedMessage message = messages.next();\n      try {\n        GenericRecord genericRecord = serializer.toGenericRecord(message.getPayload());\n        ILoggingEvent event = serializer.fromGenericRecord(genericRecord);\n\n        LoggingContext loggingContext = LoggingContextHelper.getLoggingContext(event.getMDCPropertyMap());\n        KafkaLogEvent logEvent = new KafkaLogEvent(genericRecord, event, loggingContext,\n                                                   message.getTopicPartition().getPartition(),\n                                                   message.getNextOffset());\n\n        for (KafkaLogProcessor processor : kafkaLogProcessors) {\n          try {\n            processor.process(logEvent);\n          } catch (Throwable th) {\n            LOG.error(\"Error processing kafka log event in processor {}\",\n                      processor.getClass().getSimpleName());\n          }\n        }\n      } catch (Throwable th) {\n        LOG.error(\"Error processing message at topic {} parition {}\",\n                  message.getTopicPartition().getTopic(),\n                  message.getTopicPartition().getPartition());\n      }\n\n      count++;\n    }\n    LOG.trace(\"Got {} messages from kafka\", count);\n  }","commit_id":"6afadafc8512c82b3222abcf7c3ce11a837214b2","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * This method is called by the responding callee thread and should return the\n     * aggregated response message\n     * \n     * @param message\n     * @return\n     * @throws RoutingException\n     */\n    public UMOMessage getResponse(UMOMessage message) throws RoutingException\n    {\n        Object responseId = getCallResponseAggregateIdentifier(message);\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Waiting for response for message id: \" + responseId + \" in \" + this);\n        }\n\n        Latch l;\n        synchronized (locks)\n        {\n            l = (Latch)locks.get(responseId);\n\n            if (l == null)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"Got response but no one is waiting for it yet. Creating latch for \"\n                                 + responseId + \" in \" + this);\n                }\n\n                l = new Latch();\n                locks.put(responseId, l);\n            }\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Got latch for message: \" + responseId);\n        }\n\n        boolean b = false;\n        try\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Waiting for response to message: \" + responseId);\n            }\n\n            // How long should we wait for the lock?\n            if (getTimeout() <= 0)\n            {\n                l.await();\n                b = true;\n            }\n            else\n            {\n                b = l.await(this.getTimeout(), TimeUnit.MILLISECONDS);\n            }\n        }\n        catch (InterruptedException e)\n        {\n            logger.error(e.getMessage(), e);\n        }\n\n        if (!b)\n        {\n            if (logger.isTraceEnabled())\n            {\n                synchronized (responseEvents)\n                {\n                    logger.trace(\"Current responses are: \\n\"\n                                 + PropertiesUtils.propertiesToString(responseEvents, true));\n                }\n            }\n\n            responseEvents.remove(responseId);\n\n            synchronized (locks)\n            {\n                locks.remove(responseId);\n            }\n\n            throw new ResponseTimeoutException(new Message(Messages.RESPONSE_TIMED_OUT_X_WAITING_FOR_ID_X,\n                String.valueOf(getTimeout()), responseId), message, null);\n        }\n\n        UMOMessage result = (UMOMessage)responseEvents.remove(responseId);\n\n        synchronized (locks)\n        {\n            locks.remove(responseId);\n        }\n\n        if (result == null)\n        {\n            // this should never happen, just using it as a safe guard for now\n            throw new IllegalStateException(\"Response Message is null\");\n        }\n\n        return result;\n    }","id":87353,"modified_method":"/**\n     * This method is called by the responding callee thread and should return the\n     * aggregated response message\n     * \n     * @param message\n     * @return\n     * @throws RoutingException\n     */\n    public UMOMessage getResponse(UMOMessage message) throws RoutingException\n    {\n        Object responseId = getCallResponseAggregateIdentifier(message);\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Waiting for response for message id: \" + responseId + \" in \" + this);\n        }\n\n        Latch l = (Latch)locks.get(responseId);\n        if (l == null)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Got response but no one is waiting for it yet. Creating latch for \"\n                             + responseId + \" in \" + this);\n            }\n\n            l = new Latch();\n            Latch previous = (Latch)locks.putIfAbsent(responseId, l);\n            if (previous != null)\n            {\n                l = previous;\n            }\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Got latch for message: \" + responseId);\n        }\n\n        // the final result message\n        UMOMessage result;\n\n        // indicates whether waiting for the result timed out\n        boolean b = false;\n\n        try\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Waiting for response to message: \" + responseId);\n            }\n\n            // how long should we wait for the lock?\n            if (getTimeout() <= 0)\n            {\n                l.await();\n                b = true;\n            }\n            else\n            {\n                b = l.await(this.getTimeout(), TimeUnit.MILLISECONDS);\n            }\n        }\n        catch (InterruptedException e)\n        {\n            logger.error(e.getMessage(), e);\n        }\n        finally\n        {\n            locks.remove(responseId);\n            result = (UMOMessage)responseEvents.remove(responseId);\n        }\n\n        if (!b)\n        {\n            if (logger.isTraceEnabled())\n            {\n                logger.trace(\"Current responses are: \\n\"\n                             + PropertiesUtils.propertiesToString(responseEvents, true));\n            }\n\n            throw new ResponseTimeoutException(new Message(Messages.RESPONSE_TIMED_OUT_X_WAITING_FOR_ID_X,\n                String.valueOf(getTimeout()), responseId), message, null);\n        }\n\n        if (result == null)\n        {\n            // this should never happen, just using it as a safe guard for now\n            throw new IllegalStateException(\"Response Message is null\");\n        }\n\n        return result;\n    }","commit_id":"5b7922525a5c9bd8033c6e5f1ee4f9d834aefa8d","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void removeGroup(Object id)\n    {\n        eventGroups.remove(id);\n    }","id":87354,"modified_method":"protected void removeEventGroup(Object id)\n    {\n        eventGroups.remove(id);\n    }","commit_id":"5b7922525a5c9bd8033c6e5f1ee4f9d834aefa8d","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Adds the event to an event group. Groups are defined by the correlationId on\n     * the message. If no 'correlation Id' is returned from calling\n     * <code>getReplyAggregateIdentifier()<\/code> a routing exception will be\n     * thrown\n     * \n     * @param event the reply event received by the response router\n     * @return The event group for the current event or a new group if the current\n     *         event doesn't belong to an existing group\n     */\n    protected EventGroup addEvent(UMOEvent event) throws RoutingException\n    {\n        Object cId = getReplyAggregateIdentifier(event.getMessage());\n\n        if (cId == null || cId.equals(\"-1\"))\n        {\n            throw new RoutingException(new Message(Messages.NO_CORRELATION_ID), event.getMessage(),\n                event.getEndpoint());\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Adding event to response aggregator group: \" + cId);\n        }\n\n        EventGroup eg = (EventGroup)eventGroups.get(cId);\n        if (eg == null)\n        {\n            eg = createEventGroup(cId, event);\n            eg.addEvent(event);\n            eventGroups.put(eg.getGroupId(), eg);\n        }\n        else\n        {\n            eg.addEvent(event);\n        }\n\n        return eg;\n    }","id":87355,"modified_method":"/**\n     * Adds the event to an event group. Groups are defined by the correlationId on\n     * the message. If no 'correlation Id' is returned from calling\n     * <code>getReplyAggregateIdentifier()<\/code> a routing exception will be\n     * thrown\n     * \n     * @param event the reply event received by the response router\n     * @return The event group for the current event or a new group if the current\n     *         event doesn't belong to an existing group\n     */\n    protected EventGroup addEvent(UMOEvent event) throws RoutingException\n    {\n        Object cId = getReplyAggregateIdentifier(event.getMessage());\n\n        if (cId == null || cId.equals(\"-1\"))\n        {\n            throw new RoutingException(new Message(Messages.NO_CORRELATION_ID), event.getMessage(),\n                event.getEndpoint());\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Adding event to response aggregator group: \" + cId);\n        }\n\n        EventGroup eg = (EventGroup)eventGroups.get(cId);\n        if (eg == null)\n        {\n            eg = createEventGroup(cId, event);\n            EventGroup previous = (EventGroup)eventGroups.putIfAbsent(eg.getGroupId(), eg);\n            if (previous != null)\n            {\n                eg = previous;\n            }\n        }\n\n        eg.addEvent(event);\n\n        return eg;\n    }","commit_id":"5b7922525a5c9bd8033c6e5f1ee4f9d834aefa8d","url":"https://github.com/mulesoft/mule"},{"original_method":"public void process(UMOEvent event) throws RoutingException\n    {\n        // add new event to an event group (it will create a new group if one does\n        // not exist for the event correlation ID)\n        EventGroup eg = addEvent(event);\n\n        // check to see if the event group is ready to be aggregated\n        if (shouldAggregate(eg))\n        {\n            // create the response message\n            UMOMessage returnMessage = aggregateEvents(eg);\n            Object id = eg.getGroupId();\n\n            // remove the eventGroup as no further message will be received for this\n            // group once we aggregate\n            removeGroup(id);\n\n            // add the new response message so that it can be collected by the\n            // response Thread\n            responseEvents.put(id, returnMessage);\n\n            // will get/create a latch for the response Message ID and release it,\n            // notifying other threads that the response message is available\n            synchronized (locks)\n            {\n                Latch l = (Latch)locks.get(id);\n\n                if (l == null)\n                {\n                    if (logger.isDebugEnabled())\n                    {\n                        logger.debug(\"Creating latch for \" + id + \" in \" + this);\n                    }\n\n                    l = new Latch();\n                    locks.put(id, l);\n                }\n\n                l.countDown();\n            }\n        }\n    }","id":87356,"modified_method":"public void process(UMOEvent event) throws RoutingException\n    {\n        // add new event to an event group (it will create a new group if one does\n        // not exist for the event correlation ID)\n        EventGroup eg = addEvent(event);\n\n        // check to see if the event group is ready to be aggregated\n        if (shouldAggregate(eg))\n        {\n            // create the response message\n            UMOMessage returnMessage = aggregateEvents(eg);\n            Object id = eg.getGroupId();\n\n            // remove the eventGroup as no further message will be received for this\n            // group once we aggregate\n            removeEventGroup(id);\n\n            // add the new response message so that it can be collected by the\n            // response Thread\n            UMOMessage previousResult = (UMOMessage)responseEvents.putIfAbsent(id, returnMessage);\n            if (previousResult != null)\n            {\n                // this would indicate that we need a better way to prevent continued\n                // aggregation for a group that is currently being processed. Can\n                // this actually happen?\n                throw new IllegalStateException(\"Detected duplicate aggregation result message with id: \"\n                                                + id);\n            }\n\n            // will get/create a latch for the response Message ID and release it,\n            // notifying other threads that the response message is available\n            Latch l = (Latch)locks.get(id);\n            if (l == null)\n            {\n                if (logger.isDebugEnabled())\n                {\n                    logger.debug(\"Creating latch for \" + id + \" in \" + this);\n                }\n\n                l = new Latch();\n                Latch previous = (Latch)locks.putIfAbsent(id, l);\n                if (previous != null)\n                {\n                    l = previous;\n                }\n            }\n\n            l.countDown();\n        }\n    }","commit_id":"5b7922525a5c9bd8033c6e5f1ee4f9d834aefa8d","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates a new event group with the given Id and can use other properties on\n     * the event Custom implementations can even overload the eventGroup object here\n     * \n     * @param id The Event group Id for the new Group\n     * @param event the current event\n     * @return a New event group for the incoming event\n     */\n    protected EventGroup createEventGroup(Object id, UMOEvent event)\n    {\n        return new EventGroup(id);\n    }","id":87357,"modified_method":"/**\n     * Creates a new event group with the given Id and can use other properties on\n     * the event Custom implementations can even overload the eventGroup object here\n     * \n     * @param id The Event group Id for the new Group\n     * @param event the current event\n     * @return a New event group for the incoming event\n     */\n    protected EventGroup createEventGroup(Object id, UMOEvent event)\n    {\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Creating new event group: \" + id + \" in \" + this);\n        }\n        return new EventGroup(id);\n    }","commit_id":"5b7922525a5c9bd8033c6e5f1ee4f9d834aefa8d","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Determines if the event group is ready to be aggregated. if the group is ready\n     * to be aggregated (this is entirely up to the application. it could be\n     * determined by volume, last modified time or some oher criteria based on the\n     * last event received)\n     * \n     * @param events\n     * @return true if the event group is ready of aggregation\n     */\n    protected boolean shouldAggregate(EventGroup events)\n    {\n        int expected = events.expectedSize();\n        if (expected == -1)\n        {\n            logger.warn(\"Correlation Group Size not set, but CorrelationAggregator is being used.  Message is being forwarded\");\n            return true;\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            synchronized (eventGroups)\n            {\n                logger.info(\"Aggregator: EventGroups size = \" + eventGroups.size());\n            }\n            logger.info(\"Correlation size is \" + expected + \". current event group size is \" + events.size()\n                        + \" for correlation \" + events.getGroupId());\n        }\n\n        return expected == events.size();\n    }","id":87358,"modified_method":"/**\n     * Determines if the event group is ready to be aggregated. if the group is ready\n     * to be aggregated (this is entirely up to the application. it could be\n     * determined by volume, last modified time or some oher criteria based on the\n     * last event received)\n     * \n     * @param events\n     * @return true if the event group is ready of aggregation\n     */\n    protected boolean shouldAggregate(EventGroup events)\n    {\n        int expected = events.expectedSize();\n        if (expected == -1)\n        {\n            logger.warn(\"Correlation Group Size not set, but CorrelationAggregator is being used.  Message is being forwarded\");\n            return true;\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.info(\"Aggregator: EventGroups size = \" + eventGroups.size());\n            logger.info(\"Correlation size is \" + expected + \". current event group size is \" + events.size()\n                        + \" for correlation \" + events.getGroupId());\n        }\n\n        return expected == events.size();\n    }","commit_id":"5b7922525a5c9bd8033c6e5f1ee4f9d834aefa8d","url":"https://github.com/mulesoft/mule"},{"original_method":"private static boolean parseAnnotationMemberValueSinglePair(PsiBuilder builder) {\n    PsiBuilder.Marker annmvp = builder.mark();\n\n    if (!ParserUtils.getToken(builder, mIDENT)) {\n      annmvp.rollbackTo();\n      return false;\n    }\n\n    if (!ParserUtils.getToken(builder, mASSIGN)) {\n      annmvp.rollbackTo();\n      return false;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (parseAnnotationMemberValueInitializer(builder)) {\n      annmvp.done(ANNOTATION_MEMBER_VALUE_PAIR);\n      return true;\n    }\n\n    annmvp.rollbackTo();\n    return true;\n  }","id":87359,"modified_method":"private static boolean parseAnnotationMemberValueSinglePair(PsiBuilder builder) {\n    PsiBuilder.Marker annmvp = builder.mark();\n\n    if (!ParserUtils.getToken(builder, mIDENT)) {\n      annmvp.rollbackTo();\n      return false;\n    }\n\n    if (!ParserUtils.getToken(builder, mASSIGN)) {\n      annmvp.rollbackTo();\n      return false;\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!parseAnnotationMemberValueInitializer(builder)) {\n      builder.error(GroovyBundle.message(\"annotation.member.value.initializer.expected\"));\n    }\n\n    annmvp.done(ANNOTATION_MEMBER_VALUE_PAIR);\n    return true;\n  }","commit_id":"e97aea4c23acd4e1c11bb2f6a43c6d0d8f2ca1eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annArgs = builder.mark();\n    if (!ParserUtils.getToken(builder, mLPAREN)) {\n      annArgs.done(ANNOTATION_ARGUMENTS);\n      return;\n    }\n\n    final PsiBuilder.Marker marker = builder.mark();\n    if (!parseAnnotationMemberValueInitializer(builder)) {\n      marker.rollbackTo();\n\n      if (!parseAnnotationMemberValuePairs(builder)) {\n        annArgs.rollbackTo();\n        return;\n      }\n    } else marker.drop();\n\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!ParserUtils.getToken(builder, mRPAREN)) {\n      builder.error(GroovyBundle.message(\"rparen.expected\"));\n    }\n    annArgs.done(ANNOTATION_ARGUMENTS);\n  }","id":87360,"modified_method":"public static void parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annArgs = builder.mark();\n    if (!ParserUtils.getToken(builder, mLPAREN)) {\n      annArgs.done(ANNOTATION_ARGUMENTS);\n      return;\n    }\n\n    if (ParserUtils.lookAhead(builder, mIDENT, mASSIGN)) {\n      if (!parseAnnotationMemberValuePairs(builder)) {\n        annArgs.rollbackTo();\n        return;\n      }\n    } else {\n      PsiBuilder.Marker pairMarker = builder.mark();\n      if (!parseAnnotationMemberValueInitializer(builder)) {\n        pairMarker.drop();\n        annArgs.rollbackTo();\n        return;\n      } else {\n        pairMarker.done(ANNOTATION_MEMBER_VALUE_PAIR);\n      }\n    }\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!ParserUtils.getToken(builder, mRPAREN)) {\n      builder.error(GroovyBundle.message(\"rparen.expected\"));\n    }\n    annArgs.done(ANNOTATION_ARGUMENTS);\n  }","commit_id":"e97aea4c23acd4e1c11bb2f6a43c6d0d8f2ca1eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiAnnotationMemberValue getValue() {\n    return findChildByClass(PsiAnnotationMemberValue.class);\n  }","id":87361,"modified_method":"public GrAnnotationMemberValue getValue() {\n    return findChildByClass(GrAnnotationMemberValue.class);\n  }","commit_id":"e97aea4c23acd4e1c11bb2f6a43c6d0d8f2ca1eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PsiElement getNameIdentifierGroovy() {\n    return findChildByType(GroovyElementTypes.mIDENT);\n  }","id":87362,"modified_method":"@Nullable\n  public PsiElement getNameIdentifierGroovy() {\n    return findChildByType(GroovyElementTypes.mIDENT);\n  }","commit_id":"e97aea4c23acd4e1c11bb2f6a43c6d0d8f2ca1eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parseDefinitions(PsiBuilder builder,\n                                                   boolean isInClass,\n                                                   boolean isEnumConstantMember,\n                                                   boolean isAnnotationMember,\n                                                   boolean mustBeMethod,\n                                                   boolean hasModifiers) {\n    if (!(builder.getTokenType() == mIDENT || builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL)) {\n      builder.error(GroovyBundle.message(\"indentifier.or.string.literal.expected\"));\n      return WRONGWAY;\n    }\n\n    PsiBuilder.Marker varMarker = builder.mark();\n    boolean isStringName = builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL;\n\n    if (isAnnotationMember && isStringName) {\n      builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n    }\n\n    //eaten one of these tokens\n    boolean eaten = ParserUtils.getToken(builder, mIDENT) || ParserUtils.getToken(builder, mSTRING_LITERAL) || ParserUtils.getToken(builder, mGSTRING_LITERAL);\n\n    if (!eaten) return WRONGWAY;\n\n    if (mustBeMethod && mLPAREN != builder.getTokenType()) {\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (!hasModifiers && mLPAREN == builder.getTokenType()) {\n      builder.error(GroovyBundle.message(\"method.definition.without.modifier\"));\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (ParserUtils.getToken(builder, mLPAREN)) {\n      ParameterList.parse(builder, mRPAREN);\n\n      if (isEnumConstantMember && !isStringName) {\n        builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n      }\n\n      ParserUtils.getToken(builder, mNLS);\n      if (!ParserUtils.getToken(builder, mRPAREN)) {\n        builder.error(GroovyBundle.message(\"rparen.expected\"));\n        varMarker.drop();\n        return METHOD_DEFINITION;\n      }\n\n      varMarker.drop();\n      if (builder.getTokenType() == kDEFAULT) {\n        PsiBuilder.Marker defaultValueMarker = builder.mark();\n        ParserUtils.getToken(builder, GroovyTokenTypes.kDEFAULT);\n        ParserUtils.getToken(builder, GroovyTokenTypes.mNLS);\n\n        if (AnnotationArguments.parseAnnotationMemberValueInitializer(builder)) {\n          defaultValueMarker.done(DEFAULT_ANNOTATION_VALUE);\n        } else {\n          defaultValueMarker.error(GroovyBundle.message(\"annotation.initializer.expected\"));\n        }\n        return DEFAULT_ANNOTATION_MEMBER;\n      }\n\n      ThrowClause.parse(builder);\n\n      if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n        ParserUtils.getToken(builder, mNLS);\n        OpenOrClosableBlock.parseOpenBlock(builder);\n      }\n\n//      if (isAnnotationMember && !NONE.equals(paramDeclList) && OPEN_BLOCK.equals(openBlock)) {\n//        builder.error(GroovyBundle.message(\"empty.parameter.list.expected\"));\n//      }\n\n      return METHOD_DEFINITION;\n    } else {\n      varMarker.rollbackTo();\n\n      // a = b, c = d\n      PsiBuilder.Marker varAssMarker = builder.mark();\n      if (ParserUtils.getToken(builder, mIDENT)) {\n\n        if (parseAssignment(builder)) { // a = b, c = d\n          if (isInClass) {\n            varAssMarker.done(FIELD);\n          } else {\n            varAssMarker.done(VARIABLE);\n          }\n\n          while (ParserUtils.getToken(builder, mCOMMA)) {\n            ParserUtils.getToken(builder, mNLS);\n\n            if (WRONGWAY.equals(parseVariableDeclarator(builder, isInClass)))\n              return VARIABLE_DEFINITION_ERROR; //parse b = d\n          }\n          return VARIABLE_DEFINITION;\n        } else {\n          if (isInClass) {\n            varAssMarker.done(FIELD);\n          } else {\n            varAssMarker.done(VARIABLE);\n          }\n//          varAssMarker.drop();\n          while (ParserUtils.getToken(builder, mCOMMA)) {// a, b = d, c = d\n            ParserUtils.getToken(builder, mNLS);\n            if (WRONGWAY.equals(parseVariableDeclarator(builder, isInClass))) return VARIABLE_DEFINITION_ERROR;\n          }\n\n          return VARIABLE_DEFINITION;\n        }\n      } else {\n        varAssMarker.drop();\n        builder.error(GroovyBundle.message(\"identifier.expected\"));\n        return VARIABLE_DEFINITION_ERROR;\n      }\n\n    }\n  }","id":87363,"modified_method":"public static GroovyElementType parseDefinitions(PsiBuilder builder,\n                                                   boolean isInClass,\n                                                   boolean isEnumConstantMember,\n                                                   boolean isAnnotationMember,\n                                                   boolean mustBeMethod,\n                                                   boolean hasModifiers) {\n    if (!(builder.getTokenType() == mIDENT || builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL)) {\n      builder.error(GroovyBundle.message(\"indentifier.or.string.literal.expected\"));\n      return WRONGWAY;\n    }\n\n    PsiBuilder.Marker varMarker = builder.mark();\n    boolean isStringName = builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL;\n\n    if (isAnnotationMember && isStringName) {\n      builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n    }\n\n    //eaten one of these tokens\n    boolean eaten = ParserUtils.getToken(builder, mIDENT) || ParserUtils.getToken(builder, mSTRING_LITERAL) || ParserUtils.getToken(builder, mGSTRING_LITERAL);\n\n    if (!eaten) return WRONGWAY;\n\n    if (mustBeMethod && mLPAREN != builder.getTokenType()) {\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (!hasModifiers && mLPAREN == builder.getTokenType()) {\n      builder.error(GroovyBundle.message(\"method.definition.without.modifier\"));\n      varMarker.drop();\n      return WRONGWAY;\n    }\n\n    if (ParserUtils.getToken(builder, mLPAREN)) {\n      ParameterList.parse(builder, mRPAREN);\n\n      if (isEnumConstantMember && !isStringName) {\n        builder.error(GroovyBundle.message(\"string.name.unexpected\"));\n      }\n\n      ParserUtils.getToken(builder, mNLS);\n      if (!ParserUtils.getToken(builder, mRPAREN)) {\n        builder.error(GroovyBundle.message(\"rparen.expected\"));\n        varMarker.drop();\n        return METHOD_DEFINITION;\n      }\n\n      varMarker.drop();\n      if (builder.getTokenType() == kDEFAULT) {\n        PsiBuilder.Marker defaultValueMarker = builder.mark();\n        ParserUtils.getToken(builder, GroovyTokenTypes.kDEFAULT);\n        ParserUtils.getToken(builder, GroovyTokenTypes.mNLS);\n\n        if (!AnnotationArguments.parseAnnotationMemberValueInitializer(builder)) {\n          builder.error(GroovyBundle.message(\"annotation.initializer.expected\"));\n        }\n        \n        defaultValueMarker.done(DEFAULT_ANNOTATION_VALUE);\n        return DEFAULT_ANNOTATION_MEMBER;\n      }\n\n      ThrowClause.parse(builder);\n\n      if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder, mNLS, mLCURLY)) {\n        ParserUtils.getToken(builder, mNLS);\n        OpenOrClosableBlock.parseOpenBlock(builder);\n      }\n\n//      if (isAnnotationMember && !NONE.equals(paramDeclList) && OPEN_BLOCK.equals(openBlock)) {\n//        builder.error(GroovyBundle.message(\"empty.parameter.list.expected\"));\n//      }\n\n      return METHOD_DEFINITION;\n    } else {\n      varMarker.rollbackTo();\n\n      // a = b, c = d\n      PsiBuilder.Marker varAssMarker = builder.mark();\n      if (ParserUtils.getToken(builder, mIDENT)) {\n\n        if (parseAssignment(builder)) { // a = b, c = d\n          if (isInClass) {\n            varAssMarker.done(FIELD);\n          } else {\n            varAssMarker.done(VARIABLE);\n          }\n\n          while (ParserUtils.getToken(builder, mCOMMA)) {\n            ParserUtils.getToken(builder, mNLS);\n\n            if (WRONGWAY.equals(parseVariableDeclarator(builder, isInClass)))\n              return VARIABLE_DEFINITION_ERROR; //parse b = d\n          }\n          return VARIABLE_DEFINITION;\n        } else {\n          if (isInClass) {\n            varAssMarker.done(FIELD);\n          } else {\n            varAssMarker.done(VARIABLE);\n          }\n//          varAssMarker.drop();\n          while (ParserUtils.getToken(builder, mCOMMA)) {// a, b = d, c = d\n            ParserUtils.getToken(builder, mNLS);\n            if (WRONGWAY.equals(parseVariableDeclarator(builder, isInClass))) return VARIABLE_DEFINITION_ERROR;\n          }\n\n          return VARIABLE_DEFINITION;\n        }\n      } else {\n        varAssMarker.drop();\n        builder.error(GroovyBundle.message(\"identifier.expected\"));\n        return VARIABLE_DEFINITION_ERROR;\n      }\n\n    }\n  }","commit_id":"96d1fe8096874e6d5b7a0ad85e918756b5cf046a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, mAT)) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    if (!ParserUtils.getToken(builder, mLPAREN)) {\n      annMarker.done(ANNOTATION);\n      return ANNOTATION;\n    }\n\n    AnnotationArguments.parse(builder);\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!ParserUtils.getToken(builder, mRPAREN)) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    annMarker.done(ANNOTATION);\n    return ANNOTATION;\n  }","id":87364,"modified_method":"public static GroovyElementType parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annMarker = builder.mark();\n\n    if (!ParserUtils.getToken(builder, mAT)) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n\n    if (WRONGWAY.equals(ReferenceElement.parseReferenceElement(builder))) {\n      annMarker.rollbackTo();\n      return WRONGWAY;\n    }\n\n    AnnotationArguments.parse(builder);\n\n    annMarker.done(ANNOTATION);\n    return ANNOTATION;\n  }","commit_id":"1f3d52b6e8f131e864a48845497733a23e94c416","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static GroovyElementType parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annArgs = builder.mark();\n    if (parseAnnotationMemberValueInitializer(builder)) {\n      annArgs.done(ANNOTATION_ARGUMENTS);\n      return ANNOTATION_ARGUMENTS;\n    }\n    annArgs.rollbackTo();\n\n    annArgs = builder.mark();\n    if (!WRONGWAY.equals(parseAnnotationMemberValuePairs(builder))) {\n      annArgs.done(ANNOTATION_ARGUMENTS);\n      return ANNOTATION_ARGUMENTS;\n    }\n\n    annArgs.rollbackTo();\n    return WRONGWAY;\n  }","id":87365,"modified_method":"public static void parse(PsiBuilder builder) {\n\n    PsiBuilder.Marker annArgs = builder.mark();\n    if (!ParserUtils.getToken(builder, mLPAREN)) {\n      annArgs.done(ANNOTATION_ARGUMENTS);\n      return;\n    }\n\n    final PsiBuilder.Marker marker = builder.mark();\n    if (!parseAnnotationMemberValueInitializer(builder)) {\n      marker.rollbackTo();\n\n      if (WRONGWAY.equals(parseAnnotationMemberValuePairs(builder))) {\n        annArgs.rollbackTo();\n        return;\n      }\n    } else marker.drop();\n\n\n    ParserUtils.getToken(builder, mNLS);\n\n    if (!ParserUtils.getToken(builder, mRPAREN)) {\n      builder.error(GroovyBundle.message(\"rparen.expected\"));\n    }\n    annArgs.done(ANNOTATION_ARGUMENTS);\n  }","commit_id":"1f3d52b6e8f131e864a48845497733a23e94c416","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrIfStatement)) {\n      return false;\n    }\n    final GrIfStatement ifStatement = (GrIfStatement) element;\n    final GrCondition thenBranch = ifStatement.getThenBranch();\n    if (!(thenBranch instanceof GrStatement)) {\n      return false;\n    }\n    final GrCondition elseBranch = ifStatement.getElseBranch();\n    if (!(elseBranch instanceof GrOpenBlock)) {\n      return false;\n    }\n    final GrOpenBlock block = ((GrOpenBlock) elseBranch);\n    final GrStatement[] statements = block.getStatements();\n    return statements.length == 1 &&\n        statements[0] instanceof GrIfStatement;\n  }","id":87366,"modified_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrIfStatement)) {\n      return false;\n    }\n    final GrIfStatement ifStatement = (GrIfStatement) element;\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    if (thenBranch == null) {\n      return false;\n    }\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n    if (!(elseBranch instanceof GrBlockStatement)) {\n      return false;\n    }\n    final GrOpenBlock block = ((GrBlockStatement) elseBranch).getBlock();\n    final GrStatement[] statements = block.getStatements();\n    return statements.length == 1 &&\n        statements[0] instanceof GrIfStatement;\n  }","commit_id":"1f3d52b6e8f131e864a48845497733a23e94c416","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrIfStatement)) {\n      return false;\n    }\n    final GrIfStatement ifStatement = (GrIfStatement) element;\n    if (ErrorUtil.containsError(ifStatement)) {\n      return false;\n    }\n    GrCondition thenBranch = ifStatement.getThenBranch();\n    if (!(thenBranch instanceof GrStatement)) {\n      return false;\n    }\n    thenBranch = ConditionalUtils.stripBraces((GrStatement) thenBranch);\n    if (!(thenBranch instanceof GrIfStatement)) {\n      return false;\n    }\n    GrCondition elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      elseBranch = ConditionalUtils.stripBraces((GrStatement) elseBranch);\n      if (elseBranch != null) {\n        return false;\n      }\n    }\n\n    final GrIfStatement childIfStatement = (GrIfStatement) thenBranch;\n\n    return childIfStatement.getElseBranch() == null;\n  }","id":87367,"modified_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrIfStatement)) {\n      return false;\n    }\n    final GrIfStatement ifStatement = (GrIfStatement) element;\n    if (ErrorUtil.containsError(ifStatement)) {\n      return false;\n    }\n    GrStatement thenBranch = ifStatement.getThenBranch();\n    if (thenBranch == null) {\n      return false;\n    }\n    thenBranch = ConditionalUtils.stripBraces((GrStatement) thenBranch);\n    if (!(thenBranch instanceof GrIfStatement)) {\n      return false;\n    }\n    GrStatement elseBranch = ifStatement.getElseBranch();\n    if (elseBranch != null) {\n      elseBranch = ConditionalUtils.stripBraces(elseBranch);\n      if (elseBranch != null) {\n        return false;\n      }\n    }\n\n    final GrIfStatement childIfStatement = (GrIfStatement) thenBranch;\n\n    return childIfStatement.getElseBranch() == null;\n  }","commit_id":"1f3d52b6e8f131e864a48845497733a23e94c416","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processIntention(PsiElement element)\n      throws IncorrectOperationException {\n    final GrIfStatement parentStatement = (GrIfStatement) element;\n    assert parentStatement != null;\n    final GrCondition elseBranch = parentStatement.getElseBranch();\n    IntentionUtils.replaceStatement(\"if(\" + parentStatement.getCondition().getText()+ \")\"+ parentStatement.getThenBranch().getText() +\n        \"else{\\n\" + elseBranch.getText() +\"\\n}\", parentStatement);\n  }","id":87368,"modified_method":"public void processIntention(PsiElement element)\n      throws IncorrectOperationException {\n    final GrIfStatement parentStatement = (GrIfStatement) element;\n    assert parentStatement != null;\n    final GrStatement elseBranch = parentStatement.getElseBranch();\n    IntentionUtils.replaceStatement(\"if(\" + parentStatement.getCondition().getText()+ \")\"+ parentStatement.getThenBranch().getText() +\n        \"else{\\n\" + elseBranch.getText() +\"\\n}\", parentStatement);\n  }","commit_id":"1f3d52b6e8f131e864a48845497733a23e94c416","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrIfStatement)) {\n      return false;\n    }\n    final GrIfStatement ifStatement = (GrIfStatement) element;\n    final GrCondition thenBranch = ifStatement.getThenBranch();\n    if (!(thenBranch instanceof GrStatement)) {\n      return false;\n    }\n    final GrCondition elseBranch = ifStatement.getElseBranch();\n    return elseBranch instanceof GrIfStatement;\n  }","id":87369,"modified_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrIfStatement)) {\n      return false;\n    }\n    final GrIfStatement ifStatement = (GrIfStatement) element;\n    final GrStatement thenBranch = ifStatement.getThenBranch();\n    if (thenBranch == null) {\n      return false;\n    }\n    final GrStatement elseBranch = ifStatement.getElseBranch();\n    return elseBranch instanceof GrIfStatement;\n  }","commit_id":"1f3d52b6e8f131e864a48845497733a23e94c416","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void writeResult(ImmutableBytesWritable key, Result result, Context context)\n    throws IOException, InterruptedException {\n      Put put = null;\n      Delete delete = null;\n      for (KeyValue kv : result.raw()) {\n        if(cfRenameMap != null) {\n            // If there's a rename mapping for this CF, create a new KeyValue\n            byte[] newCfName = cfRenameMap.get(kv.getFamily());\n            if(newCfName != null) {\n                kv = new KeyValue(kv.getBuffer(), // row buffer \n                        kv.getRowOffset(),        // row offset\n                        kv.getRowLength(),        // row length\n                        newCfName,                // CF buffer\n                        0,                        // CF offset \n                        newCfName.length,         // CF length \n                        kv.getBuffer(),           // qualifier buffer\n                        kv.getQualifierOffset(),  // qualifier offset\n                        kv.getQualifierLength(),  // qualifier length\n                        kv.getTimestamp(),        // timestamp\n                        KeyValue.Type.codeToType(kv.getType()), // KV Type\n                        kv.getBuffer(),           // value buffer \n                        kv.getValueOffset(),      // value offset\n                        kv.getValueLength());     // value length\n            } \n        }\n        // Deletes and Puts are gathered and written when finished\n        if (kv.isDelete()) {\n          if (delete == null) {\n            delete = new Delete(key.get());\n          }\n          delete.addDeleteMarker(kv);\n        } else {\n          if (put == null) { \n            put = new Put(key.get());\n          }\n          put.add(kv);\n        }\n      }\n      if (put != null) {\n        context.write(key, put);\n      }\n      if (delete != null) {\n        context.write(key, delete);\n      }\n    }","id":87370,"modified_method":"private void writeResult(ImmutableBytesWritable key, Result result, Context context)\n    throws IOException, InterruptedException {\n      Put put = null;\n      Delete delete = null;\n      for (KeyValue kv : result.raw()) {\n        kv = convertKv(kv, cfRenameMap);\n        // Deletes and Puts are gathered and written when finished\n        if (kv.isDelete()) {\n          if (delete == null) {\n            delete = new Delete(key.get());\n          }\n          delete.addDeleteMarker(kv);\n        } else {\n          if (put == null) { \n            put = new Put(key.get());\n          }\n          put.add(kv);\n        }\n      }\n      if (put != null) {\n        context.write(key, put);\n      }\n      if (delete != null) {\n        context.write(key, delete);\n      }\n    }","commit_id":"a54ec1b7cc55cd087cf84f3e7591b458c07bf48e","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void setup(Context context) {\n      // Make a map from sourceCfName to destCfName by parsing a config key\n      cfRenameMap = null;\n      String allMappingsPropVal = context.getConfiguration().get(CF_RENAME_PROP);\n      if(allMappingsPropVal != null) {\n        // The conf value format should be sourceCf1:destCf1,sourceCf2:destCf2,...\n        String[] allMappings = allMappingsPropVal.split(\",\");\n        for (String mapping: allMappings) {\n          if(cfRenameMap == null) {\n              cfRenameMap = new TreeMap<byte[],byte[]>(Bytes.BYTES_COMPARATOR);\n          }\n          String [] srcAndDest = mapping.split(\":\");\n          if(srcAndDest.length != 2) {\n              continue;\n          }\n          cfRenameMap.put(srcAndDest[0].getBytes(), srcAndDest[1].getBytes());\n        }\n      }\n    }","id":87371,"modified_method":"@Override\n    public void setup(Context context) {\n      cfRenameMap = createCfRenameMap(context.getConfiguration());\n    }","commit_id":"a54ec1b7cc55cd087cf84f3e7591b458c07bf48e","url":"https://github.com/apache/hbase"},{"original_method":"private static void usage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    System.err.println(\"Usage: Import <tablename> <inputdir>\");\n  }","id":87372,"modified_method":"private static void usage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    System.err.println(\"Usage: Import [options] <tablename> <inputdir>\");\n    System.err.println(\"By default Import will load data directly into HBase. To instead generate\");\n    System.err.println(\"HFiles of data to prepare for a bulk data load, pass the option:\");\n    System.err.println(\"  -D\" + BULK_OUTPUT_CONF_KEY + \"=/path/for/output\");\n  }","commit_id":"a54ec1b7cc55cd087cf84f3e7591b458c07bf48e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Sets up the actual job.\n   *\n   * @param conf  The current configuration.\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  public static Job createSubmittableJob(Configuration conf, String[] args)\n  throws IOException {\n    String tableName = args[0];\n    Path inputDir = new Path(args[1]);\n    Job job = new Job(conf, NAME + \"_\" + tableName);\n    job.setJarByClass(Importer.class);\n    FileInputFormat.setInputPaths(job, inputDir);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    job.setMapperClass(Importer.class);\n    // No reducers.  Just write straight to table.  Call initTableReducerJob\n    // because it sets up the TableOutputFormat.\n    TableMapReduceUtil.initTableReducerJob(tableName, null, job);\n    job.setNumReduceTasks(0);\n    return job;\n  }","id":87373,"modified_method":"/**\n   * Sets up the actual job.\n   *\n   * @param conf  The current configuration.\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  public static Job createSubmittableJob(Configuration conf, String[] args)\n  throws IOException {\n    String tableName = args[0];\n    Path inputDir = new Path(args[1]);\n    Job job = new Job(conf, NAME + \"_\" + tableName);\n    job.setJarByClass(Importer.class);\n    FileInputFormat.setInputPaths(job, inputDir);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    String hfileOutPath = conf.get(BULK_OUTPUT_CONF_KEY);\n    if (hfileOutPath != null) {\n      job.setMapperClass(KeyValueImporter.class);\n      HTable table = new HTable(conf, tableName);\n      job.setReducerClass(KeyValueSortReducer.class);\n      Path outputDir = new Path(hfileOutPath);\n      FileOutputFormat.setOutputPath(job, outputDir);\n      job.setMapOutputKeyClass(ImmutableBytesWritable.class);\n      job.setMapOutputValueClass(KeyValue.class);\n      HFileOutputFormat.configureIncrementalLoad(job, table);\n      TableMapReduceUtil.addDependencyJars(job.getConfiguration(),\n          com.google.common.base.Preconditions.class);\n    } else {\n      // No reducers.  Just write straight to table.  Call initTableReducerJob\n      // because it sets up the TableOutputFormat.\n      job.setMapperClass(Importer.class);\n      TableMapReduceUtil.initTableReducerJob(tableName, null, job);\n      job.setNumReduceTasks(0);\n    }\n    return job;\n  }","commit_id":"a54ec1b7cc55cd087cf84f3e7591b458c07bf48e","url":"https://github.com/apache/hbase"},{"original_method":"private static PsiReferenceProcessor createReferenceProcessor(@NotNull final List<UsagesProcessor> processors,\n                                                                final GlobalInspectionContext context) {\n    return new PsiReferenceProcessor() {\n      @Override\n      public boolean execute(PsiReference reference) {\n        AnalysisScope scope = context.getRefManager().getScope();\n        if (scope.contains(reference.getElement()) && reference.getElement().getLanguage() == StdLanguages.JAVA ||\n            PsiTreeUtil.getParentOfType(reference.getElement(), PsiDocComment.class) != null) {\n          return true;\n        }\n\n        synchronized (processors) {\n          UsagesProcessor[] processorsArrayed = processors.toArray(new UsagesProcessor[processors.size()]);\n          for (UsagesProcessor processor : processorsArrayed) {\n            if (!processor.process(reference)) {\n              processors.remove(processor);\n            }\n          }\n        }\n\n        return !processors.isEmpty();\n      }\n    };\n  }","id":87374,"modified_method":"private static PsiReferenceProcessor createReferenceProcessor(@NotNull final List<UsagesProcessor> processors,\n                                                                final GlobalInspectionContext context) {\n    return new PsiReferenceProcessor() {\n      @Override\n      public boolean execute(PsiReference reference) {\n        AnalysisScope scope = context.getRefManager().getScope();\n        if (scope != null && scope.contains(reference.getElement()) && reference.getElement().getLanguage() == StdLanguages.JAVA ||\n            PsiTreeUtil.getParentOfType(reference.getElement(), PsiDocComment.class) != null) {\n          return true;\n        }\n\n        synchronized (processors) {\n          UsagesProcessor[] processorsArrayed = processors.toArray(new UsagesProcessor[processors.size()]);\n          for (UsagesProcessor processor : processorsArrayed) {\n            if (!processor.process(reference)) {\n              processors.remove(processor);\n            }\n          }\n        }\n\n        return !processors.isEmpty();\n      }\n    };\n  }","commit_id":"9e30dc382c1e8a9905759e9b6d44508ceee0d403","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processSearchRequests(final GlobalInspectionContext context) {\n    final RefManager refManager = context.getRefManager();\n    final AnalysisScope scope = refManager.getScope();\n\n    final SearchScope searchScope = new GlobalSearchScope(refManager.getProject()) {\n      @Override\n      public boolean contains(@NotNull VirtualFile file) {\n        return !scope.contains(file) || file.getFileType() != StdFileTypes.JAVA;\n      }\n\n      @Override\n      public int compare(@NotNull VirtualFile file1, @NotNull VirtualFile file2) {\n        return 0;\n      }\n\n      @Override\n      public boolean isSearchInModuleContent(@NotNull Module aModule) {\n        return true;\n      }\n\n      @Override\n      public boolean isSearchInLibraries() {\n        return false;\n      }\n    };\n\n    if (myDerivedClassesRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myDerivedClassesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiClass psiClass = (PsiClass)dereferenceInReadAction(sortedID);\n        if (psiClass == null) continue;\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, ApplicationManager.getApplication().runReadAction(\n          new Computable<String>() {\n            @Override\n            public String compute() {\n              return psiClass.getQualifiedName();\n            }\n          }\n        ));\n\n        final List<DerivedClassesProcessor> processors = myDerivedClassesRequests.get(sortedID);\n        LOG.assertTrue(processors != null, psiClass.getClass().getName());\n        ClassInheritorsSearch.search(psiClass, searchScope, false)\n          .forEach(createMembersProcessor(processors, scope));\n      }\n\n      myDerivedClassesRequests = null;\n    }\n\n    if (myDerivedMethodsRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myDerivedMethodsRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiMethod psiMethod = (PsiMethod)dereferenceInReadAction(sortedID);\n        if (psiMethod == null) continue;\n        final RefMethod refMethod = (RefMethod)refManager.getReference(psiMethod);\n\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, refManager.getQualifiedName(refMethod));\n\n        final List<DerivedMethodsProcessor> processors = myDerivedMethodsRequests.get(sortedID);\n        LOG.assertTrue(processors != null, psiMethod.getClass().getName());\n        OverridingMethodsSearch.search(psiMethod, searchScope, true)\n          .forEach(createMembersProcessor(processors, scope));\n      }\n\n      myDerivedMethodsRequests = null;\n    }\n\n    if (myFieldUsagesRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myFieldUsagesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiField psiField = (PsiField)dereferenceInReadAction(sortedID);\n        if (psiField == null) continue;\n        final List<UsagesProcessor> processors = myFieldUsagesRequests.get(sortedID);\n\n        LOG.assertTrue(processors != null, psiField.getClass().getName());\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, refManager.getQualifiedName(refManager.getReference(psiField)));\n\n        ReferencesSearch.search(psiField, searchScope, false)\n          .forEach(new PsiReferenceProcessorAdapter(createReferenceProcessor(processors, context)));\n      }\n\n      myFieldUsagesRequests = null;\n    }\n\n    if (myClassUsagesRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myClassUsagesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiClass psiClass = (PsiClass)dereferenceInReadAction(sortedID);\n        if (psiClass == null) continue;\n        final List<UsagesProcessor> processors = myClassUsagesRequests.get(sortedID);\n\n        LOG.assertTrue(processors != null, psiClass.getClass().getName());\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, ApplicationManager.getApplication().runReadAction(\n          new Computable<String>() {\n            @Override\n            public String compute() {\n              return psiClass.getQualifiedName();\n            }\n          }\n        ));\n\n        ReferencesSearch.search(psiClass, searchScope, false)\n          .forEach(new PsiReferenceProcessorAdapter(createReferenceProcessor(processors, context)));\n      }\n\n      myClassUsagesRequests = null;\n    }\n\n    if (myMethodUsagesRequests != null) {\n      List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myMethodUsagesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiMethod psiMethod = (PsiMethod)dereferenceInReadAction(sortedID);\n        if (psiMethod == null) continue;\n        final List<UsagesProcessor> processors = myMethodUsagesRequests.get(sortedID);\n\n        LOG.assertTrue(processors != null, psiMethod.getClass().getName());\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, refManager.getQualifiedName(refManager.getReference(psiMethod)));\n\n        MethodReferencesSearch.search(psiMethod, searchScope, true)\n          .forEach(new PsiReferenceProcessorAdapter(createReferenceProcessor(processors, context)));\n      }\n\n      myMethodUsagesRequests = null;\n    }\n  }","id":87375,"modified_method":"public void processSearchRequests(final GlobalInspectionContext context) {\n    final RefManager refManager = context.getRefManager();\n    final AnalysisScope scope = refManager.getScope();\n\n    final SearchScope searchScope = new GlobalSearchScope(refManager.getProject()) {\n      @Override\n      public boolean contains(@NotNull VirtualFile file) {\n        return scope != null && !scope.contains(file) || file.getFileType() != StdFileTypes.JAVA;\n      }\n\n      @Override\n      public int compare(@NotNull VirtualFile file1, @NotNull VirtualFile file2) {\n        return 0;\n      }\n\n      @Override\n      public boolean isSearchInModuleContent(@NotNull Module aModule) {\n        return true;\n      }\n\n      @Override\n      public boolean isSearchInLibraries() {\n        return false;\n      }\n    };\n\n    if (myDerivedClassesRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myDerivedClassesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiClass psiClass = (PsiClass)dereferenceInReadAction(sortedID);\n        if (psiClass == null) continue;\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, ApplicationManager.getApplication().runReadAction(\n          new Computable<String>() {\n            @Override\n            public String compute() {\n              return psiClass.getQualifiedName();\n            }\n          }\n        ));\n\n        final List<DerivedClassesProcessor> processors = myDerivedClassesRequests.get(sortedID);\n        LOG.assertTrue(processors != null, psiClass.getClass().getName());\n        ClassInheritorsSearch.search(psiClass, searchScope, false)\n          .forEach(createMembersProcessor(processors, scope));\n      }\n\n      myDerivedClassesRequests = null;\n    }\n\n    if (myDerivedMethodsRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myDerivedMethodsRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiMethod psiMethod = (PsiMethod)dereferenceInReadAction(sortedID);\n        if (psiMethod == null) continue;\n        final RefMethod refMethod = (RefMethod)refManager.getReference(psiMethod);\n\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, refManager.getQualifiedName(refMethod));\n\n        final List<DerivedMethodsProcessor> processors = myDerivedMethodsRequests.get(sortedID);\n        LOG.assertTrue(processors != null, psiMethod.getClass().getName());\n        OverridingMethodsSearch.search(psiMethod, searchScope, true)\n          .forEach(createMembersProcessor(processors, scope));\n      }\n\n      myDerivedMethodsRequests = null;\n    }\n\n    if (myFieldUsagesRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myFieldUsagesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiField psiField = (PsiField)dereferenceInReadAction(sortedID);\n        if (psiField == null) continue;\n        final List<UsagesProcessor> processors = myFieldUsagesRequests.get(sortedID);\n\n        LOG.assertTrue(processors != null, psiField.getClass().getName());\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, refManager.getQualifiedName(refManager.getReference(psiField)));\n\n        ReferencesSearch.search(psiField, searchScope, false)\n          .forEach(new PsiReferenceProcessorAdapter(createReferenceProcessor(processors, context)));\n      }\n\n      myFieldUsagesRequests = null;\n    }\n\n    if (myClassUsagesRequests != null) {\n      final List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myClassUsagesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiClass psiClass = (PsiClass)dereferenceInReadAction(sortedID);\n        if (psiClass == null) continue;\n        final List<UsagesProcessor> processors = myClassUsagesRequests.get(sortedID);\n\n        LOG.assertTrue(processors != null, psiClass.getClass().getName());\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, ApplicationManager.getApplication().runReadAction(\n          new Computable<String>() {\n            @Override\n            public String compute() {\n              return psiClass.getQualifiedName();\n            }\n          }\n        ));\n\n        ReferencesSearch.search(psiClass, searchScope, false)\n          .forEach(new PsiReferenceProcessorAdapter(createReferenceProcessor(processors, context)));\n      }\n\n      myClassUsagesRequests = null;\n    }\n\n    if (myMethodUsagesRequests != null) {\n      List<SmartPsiElementPointer> sortedIDs = getSortedIDs(myMethodUsagesRequests);\n      for (SmartPsiElementPointer sortedID : sortedIDs) {\n        final PsiMethod psiMethod = (PsiMethod)dereferenceInReadAction(sortedID);\n        if (psiMethod == null) continue;\n        final List<UsagesProcessor> processors = myMethodUsagesRequests.get(sortedID);\n\n        LOG.assertTrue(processors != null, psiMethod.getClass().getName());\n        context.incrementJobDoneAmount(context.getStdJobDescriptors().FIND_EXTERNAL_USAGES, refManager.getQualifiedName(refManager.getReference(psiMethod)));\n\n        MethodReferencesSearch.search(psiMethod, searchScope, true)\n          .forEach(new PsiReferenceProcessorAdapter(createReferenceProcessor(processors, context)));\n      }\n\n      myMethodUsagesRequests = null;\n    }\n  }","commit_id":"9e30dc382c1e8a9905759e9b6d44508ceee0d403","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void findAllDeclarations() {\n    if (!myDeclarationsFound) {\n      long before = System.currentTimeMillis();\n      final AnalysisScope scope = getScope();\n      scope.accept(myProjectIterator);\n      myDeclarationsFound = true;\n\n      LOG.info(\"Total duration of processing project usages:\" + (System.currentTimeMillis() - before));\n    }\n  }","id":87376,"modified_method":"public void findAllDeclarations() {\n    if (!myDeclarationsFound) {\n      long before = System.currentTimeMillis();\n      final AnalysisScope scope = getScope();\n      if (scope != null) {\n        scope.accept(myProjectIterator);\n      }\n      myDeclarationsFound = true;\n\n      LOG.info(\"Total duration of processing project usages:\" + (System.currentTimeMillis() - before));\n    }\n  }","commit_id":"9e30dc382c1e8a9905759e9b6d44508ceee0d403","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean queryExternalUsagesRequests(@NotNull final RefManager manager, @NotNull final GlobalJavaInspectionContext globalContext,\n                                                @NotNull final ProblemDescriptionsProcessor processor) {\n    final Project project = manager.getProject();\n    for (RefElement entryPoint : globalContext.getEntryPointsManager(manager).getEntryPoints()) {\n      processor.ignoreElement(entryPoint);\n    }\n\n    final PsiSearchHelper helper = PsiSearchHelper.SERVICE.getInstance(project);\n    final AnalysisScope scope = manager.getScope();\n    manager.iterate(new RefJavaVisitor() {\n      @Override\n      public void visitElement(@NotNull RefEntity refEntity) {\n        if (refEntity instanceof RefMethod) {\n          RefMethod refMethod = (RefMethod)refEntity;\n          final PsiModifierListOwner element = refMethod.getElement();\n          if (element instanceof PsiMethod) { //implicit constructors are invisible\n            PsiMethod psiMethod = (PsiMethod)element;\n            if (!refMethod.isStatic() && !refMethod.isConstructor() && !PsiModifier.PRIVATE.equals(refMethod.getAccessModifier())) {\n              final ArrayList<RefParameter> unusedParameters = getUnusedParameters(refMethod);\n              if (unusedParameters.isEmpty()) return;\n              PsiMethod[] derived = OverridingMethodsSearch.search(psiMethod, true).toArray(PsiMethod.EMPTY_ARRAY);\n              for (final RefParameter refParameter : unusedParameters) {\n                if (refMethod.isAbstract() && derived.length == 0) {\n                  refParameter.parameterReferenced(false);\n                  processor.ignoreElement(refParameter);\n                }\n                else {\n                  int idx = refParameter.getIndex();\n                  final boolean[] found = {false};\n                  for (int i = 0; i < derived.length && !found[0]; i++) {\n                    if (!scope.contains(derived[i])) {\n                      final PsiParameter[] parameters = derived[i].getParameterList().getParameters();\n                      if (parameters.length >= idx) continue;\n                      PsiParameter psiParameter = parameters[idx];\n                      ReferencesSearch.search(psiParameter, helper.getUseScope(psiParameter), false)\n                        .forEach(new PsiReferenceProcessorAdapter(\n                          new PsiReferenceProcessor() {\n                            @Override\n                            public boolean execute(PsiReference element) {\n                              refParameter.parameterReferenced(false);\n                              processor.ignoreElement(refParameter);\n                              found[0] = true;\n                              return false;\n                            }\n                          }));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n    return false;\n  }","id":87377,"modified_method":"@Override\n  protected boolean queryExternalUsagesRequests(@NotNull final RefManager manager, @NotNull final GlobalJavaInspectionContext globalContext,\n                                                @NotNull final ProblemDescriptionsProcessor processor) {\n    final Project project = manager.getProject();\n    for (RefElement entryPoint : globalContext.getEntryPointsManager(manager).getEntryPoints()) {\n      processor.ignoreElement(entryPoint);\n    }\n\n    final PsiSearchHelper helper = PsiSearchHelper.SERVICE.getInstance(project);\n    final AnalysisScope scope = manager.getScope();\n    manager.iterate(new RefJavaVisitor() {\n      @Override\n      public void visitElement(@NotNull RefEntity refEntity) {\n        if (refEntity instanceof RefMethod) {\n          RefMethod refMethod = (RefMethod)refEntity;\n          final PsiModifierListOwner element = refMethod.getElement();\n          if (element instanceof PsiMethod) { //implicit constructors are invisible\n            PsiMethod psiMethod = (PsiMethod)element;\n            if (!refMethod.isStatic() && !refMethod.isConstructor() && !PsiModifier.PRIVATE.equals(refMethod.getAccessModifier())) {\n              final ArrayList<RefParameter> unusedParameters = getUnusedParameters(refMethod);\n              if (unusedParameters.isEmpty()) return;\n              PsiMethod[] derived = OverridingMethodsSearch.search(psiMethod, true).toArray(PsiMethod.EMPTY_ARRAY);\n              for (final RefParameter refParameter : unusedParameters) {\n                if (refMethod.isAbstract() && derived.length == 0) {\n                  refParameter.parameterReferenced(false);\n                  processor.ignoreElement(refParameter);\n                }\n                else {\n                  int idx = refParameter.getIndex();\n                  final boolean[] found = {false};\n                  for (int i = 0; i < derived.length && !found[0]; i++) {\n                    if (scope == null || !scope.contains(derived[i])) {\n                      final PsiParameter[] parameters = derived[i].getParameterList().getParameters();\n                      if (parameters.length >= idx) continue;\n                      PsiParameter psiParameter = parameters[idx];\n                      ReferencesSearch.search(psiParameter, helper.getUseScope(psiParameter), false)\n                        .forEach(new PsiReferenceProcessorAdapter(\n                          new PsiReferenceProcessor() {\n                            @Override\n                            public boolean execute(PsiReference element) {\n                              refParameter.parameterReferenced(false);\n                              processor.ignoreElement(refParameter);\n                              found[0] = true;\n                              return false;\n                            }\n                          }));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n    return false;\n  }","commit_id":"9e30dc382c1e8a9905759e9b6d44508ceee0d403","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Test suite() {\n      TestSuite suite = new TestSuite(\"Tests for org.eclipse.xtext.ui.integration.tests\");\n      suite.addTestSuite(org.eclipse.xtext.ui.core.builder.impl.JarWalkerTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.resource.Storage2UriMapperJdtImplTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.resource.Storage2UriMapperTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.BundleClasspathUriResolverTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.JdtClasspathUriResolverTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.JdtUtilTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.WorkspaceClasspathUriResolverTest.class);\n      return suite;\n   }","id":87378,"modified_method":"public static Test suite() {\n      TestSuite suite = new TestSuite(\"Tests for org.eclipse.xtext.ui.integration.tests\");\n      suite.addTestSuite(org.eclipse.xtext.ui.core.builder.impl.PackageFragmentRootWalkerTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.resource.Storage2UriMapperJdtImplTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.resource.Storage2UriMapperTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.BundleClasspathUriResolverTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.JdtClasspathUriResolverTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.JdtUtilTest.class);\n      suite.addTestSuite(org.eclipse.xtext.ui.core.util.WorkspaceClasspathUriResolverTest.class);\n      return suite;\n   }","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"private Resource createResourceFor(IJarEntryResource storage) {\n\t\tXtextResourceSet resourceSet = getResourceSet(storage);\n\t\tURI uri = jdtURIUtil.getURI(storage);\n\t\tconfigureResourceSet(resourceSet, uri);\n\t\tXtextResource resource = getResource(resourceSet, uri);\n\t\tresource.setValidationDisabled(true);\n\t\treturn resource;\n\t}","id":87379,"modified_method":"private Resource createResourceFor(IJarEntryResource storage) {\n\t\tXtextResourceSet resourceSet = getResourceSet(storage);\n\t\tURI uri = storageToUriMapper.getUri(storage);\n\t\tconfigureResourceSet(resourceSet, uri);\n\t\tXtextResource resource = getResource(resourceSet, uri);\n\t\tresource.setValidationDisabled(true);\n\t\treturn resource;\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void doInitContainedURIs(String containerHandle, Collection<URI> result) {\n\t\tIJavaElement javaElement = JavaCore.create(containerHandle);\n\t\tif (javaElement instanceof IPackageFragmentRoot) {\n\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot) javaElement;\n\t\t\tfinal List<URI> uris = Lists.newArrayList();\n\t\t\tif (root.isArchive()) {\n\t\t\t\ttry {\n\t\t\t\t\tnew JarWalker<Void>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Void handle(IJarEntryResource jarEntry) {\n\t\t\t\t\t\t\tURI uri = getUri(jarEntry);\n\t\t\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\t\t\turis.add(uri);\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}.traverse(root, false);\n\t\t\t\t\tresult.addAll(uris);\n\t\t\t\t} catch (JavaModelException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t\tresult.clear();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\troot.getResource().accept(new IResourceVisitor() {\n\t\t\t\t\t\tpublic boolean visit(IResource resource) throws CoreException {\n\t\t\t\t\t\t\tif (resource instanceof IStorage) {\n\t\t\t\t\t\t\t\tURI uri = getUri((IStorage) resource);\n\t\t\t\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\t\t\t\turis.add(uri);\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tresult.addAll(uris);\n\t\t\t\t} catch (CoreException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t\tresult.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":87380,"modified_method":"@Override\n\tprotected void doInitContainedURIs(String containerHandle, Collection<URI> result) {\n\t\tIJavaElement javaElement = JavaCore.create(containerHandle);\n\t\tif (javaElement instanceof IPackageFragmentRoot) {\n\t\t\tIPackageFragmentRoot root = (IPackageFragmentRoot) javaElement;\n\t\t\tfinal List<URI> uris = Lists.newArrayList();\n\t\t\tif (root.isArchive() || root.isExternal()) {\n\t\t\t\ttry {\n\t\t\t\t\tnew PackageFragmentRootWalker<Void>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Void handle(IJarEntryResource jarEntry, TraversalState state) {\n\t\t\t\t\t\t\tURI uri = getUri(jarEntry);\n\t\t\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\t\t\turis.add(uri);\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}.traverse(root, false);\n\t\t\t\t\tresult.addAll(uris);\n\t\t\t\t} catch (JavaModelException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t\tresult.clear();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tIResource resource = root.getResource();\n\t\t\t\t\tif (resource != null) {\n\t\t\t\t\t\tresource.accept(new IResourceVisitor() {\n\t\t\t\t\t\t\tpublic boolean visit(IResource resource) throws CoreException {\n\t\t\t\t\t\t\t\tif (resource instanceof IStorage) {\n\t\t\t\t\t\t\t\t\tURI uri = getUri((IStorage) resource);\n\t\t\t\t\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\t\t\t\t\turis.add(uri);\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tresult.addAll(uris);\n\t\t\t\t} catch (CoreException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t\tresult.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"protected IPackageFragmentRoot getPackageFragmentRoot(URI uri) {\n\t\tif (uri.isArchive()) {\n\t\t\treturn getJarWithEntry(uri);\n\t\t}\n\t\tfinal IFile file = getWorkspaceRoot().getFile(new Path(uri.toPlatformString(true)));\n\t\tif (file == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn getJavaElement(file);\n\t}","id":87381,"modified_method":"protected IPackageFragmentRoot getPackageFragmentRoot(URI uri) {\n\t\tif (uri.isArchive()) {\n\t\t\treturn getJarWithEntry(uri);\n\t\t}\n\t\tfinal IFile file = getWorkspaceRoot().getFile(new Path(uri.toPlatformString(true)));\n\t\tif (file == null) {\n\t\t\treturn getJarWithEntry(uri);\n\t\t}\n\t\tIPackageFragmentRoot root = getJavaElement(file);\n\t\tif (root == null)\n\t\t\treturn getJarWithEntry(uri);\n\t\treturn root;\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tjavaProject1 = makeJavaProject(project1);\n\t\taddSourceFolder(javaProject1, \"src2\");\n\t\turi1 = createFileAndRegisterResource(project1, \"src/file1\");\n\t\turi2 = createFileAndRegisterResource(project1, \"src/file2\");\n\t\turi3 = createFileAndRegisterResource(project2, \"src2/file3\");\n\t\tIResource member = javaProject1.getProject().findMember(\"src\");\n\t\tsrcRoot = javaProject1.getPackageFragmentRoot(member);\n\t\tIStorage2UriMapper mapper = new Storage2UriMapperJavaImpl() {\n\t\t\t@Override\n\t\t\tprotected boolean isValidUri(URI uri) {\n\t\t\t\treturn uri != null;\n\t\t\t}\n\t\t};\n\t\tprojectsState = new JavaProjectsState();\n\t\tprojectsState.setMapper(mapper);\n\t}","id":87382,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\tjavaProject1 = makeJavaProject(project1);\n\t\taddSourceFolder(javaProject1, \"src2\");\n\t\turi1 = createFileAndRegisterResource(project1, \"src/file1\");\n\t\turi2 = createFileAndRegisterResource(project1, \"src/file2\");\n\t\turi3 = createFileAndRegisterResource(project2, \"src2/file3\");\n\t\tIResource member = javaProject1.getProject().findMember(\"src\");\n\t\tsrcRoot = javaProject1.getPackageFragmentRoot(member);\n\t\tIStorage2UriMapper mapper = new Storage2UriMapperJavaImpl() {\n\t\t\t@Override\n\t\t\tpublic boolean isValidUri(URI uri) {\n\t\t\t\treturn uri != null;\n\t\t\t}\n\t\t};\n\t\tprojectsState = new JavaProjectsState();\n\t\tprojectsState.setMapper(mapper);\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"protected URI findResourceInWorkspace(IJavaProject javaProject, URI classpathUri) throws JavaModelException,\n\t\t\tCoreException {\n\t\tif (javaProject.exists()) {\n\t\t\tString path = classpathUri.trimSegments(1).path();\n\t\t\tString fullPath = classpathUri.path();\n\t\t\tfinal String name = classpathUri.lastSegment();\n\t\t\tString packageName = path.substring(1).replace('/', '.');\t\n\t\t\tfor(IPackageFragmentRoot packageFragmentRoot: javaProject.getAllPackageFragmentRoots()) {\n\t\t\t\tIJavaElement foundElement = packageFragmentRoot.getPackageFragment(packageName);\n\t\t\t\tif (foundElement instanceof IPackageFragment && foundElement.exists()) {\n\t\t\t\t\tIPackageFragment packageFragment = (IPackageFragment) foundElement;\n\t\t\t\t\tIResource packageFragmentResource = packageFragment.getResource();\n\t\t\t\t\tif (packageFragmentResource == null || packageFragmentResource instanceof IFile) {\n\t\t\t\t\t\tObject[] nonJavaResources = packageFragment.getNonJavaResources();\n\t\t\t\t\t\tfor(Object nonJavaResource: nonJavaResources) {\n\t\t\t\t\t\t\t// we have to check for concrete class because getFullPath\n\t\t\t\t\t\t\t// behaves differently\n\t\t\t\t\t\t\tif (nonJavaResource instanceof JarEntryResource) {\n\t\t\t\t\t\t\t\tJarEntryResource jarEntryResource = (JarEntryResource) nonJavaResource;\n\t\t\t\t\t\t\t\tif (fullPath.equals(jarEntryResource.getFullPath().toString())) {\n\t\t\t\t\t\t\t\t\tIResource packageFragmentRootResource = packageFragmentRoot.getResource();\n\t\t\t\t\t\t\t\t\tif (packageFragmentRootResource != null) { // we have a resource - use nested platform/resource\n\t\t\t\t\t\t\t\t\t\tURI packageFragmentRootURI = createPlatformResourceURI(packageFragmentRootResource);\n\t\t\t\t\t\t\t\t\t\tURI result = createArchiveURI(packageFragmentRootURI, fullPath);\n\t\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// no resource - use file uri\n\t\t\t\t\t\t\t\t\t\tIPath packageFragmentRootPath = packageFragmentRoot.getPath();\n\t\t\t\t\t\t\t\t\t\tURI packageFragmentRootURI = URI.createFileURI(packageFragmentRootPath.toString());\n\t\t\t\t\t\t\t\t\t\tURI result = createArchiveURI(packageFragmentRootURI, fullPath);\n\t\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (nonJavaResource instanceof NonJavaResource) {\n\t\t\t\t\t\t\t\tString nonJavaResourceName = ((NonJavaResource) nonJavaResource).getName();\n\t\t\t\t\t\t\t\tif (name.equals(nonJavaResourceName)) {\n\t\t\t\t\t\t\t\t\tif (packageFragmentRoot instanceof ExternalPackageFragmentRoot) {\n\t\t\t\t\t\t\t\t\t\tIResource resource = ((ExternalPackageFragmentRoot) packageFragmentRoot).resource();\n\t\t\t\t\t\t\t\t\t\tIPath absolutePath = resource.getFullPath();\n\t\t\t\t\t\t\t\t\t\tabsolutePath = absolutePath.append(fullPath);\n\t\t\t\t\t\t\t\t\t\treturn createPlatformResourceURI(absolutePath);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinal Wrapper<IResource> result = Wrapper.<IResource>wrap(null);\n\t\t\t\t\t\tpackageFragmentResource.accept(new IResourceVisitor() {\n\t\t\t\t\t\t\tpublic boolean visit(IResource resource) throws CoreException {\n\t\t\t\t\t\t\t\tif (name.equals(resource.getName()))\n\t\t\t\t\t\t\t\t\tresult.set(resource);\n\t\t\t\t\t\t\t\treturn result.get() == null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, IResource.DEPTH_ONE, IResource.NONE);\n\t\t\t\t\t\tif (result.get() != null)\n\t\t\t\t\t\t\treturn createPlatformResourceURI(result.get());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn classpathUri;\n\t}","id":87383,"modified_method":"protected URI findResourceInWorkspace(IJavaProject javaProject, URI classpathUri) throws JavaModelException,\n\t\t\tCoreException {\n\t\tif (javaProject.exists()) {\n\t\t\tString path = classpathUri.trimSegments(1).path();\n\t\t\tString fullPath = classpathUri.path();\n\t\t\tfinal String name = classpathUri.lastSegment();\n\t\t\tString packageName = path.substring(1).replace('/', '.');\t\n\t\t\tfor(IPackageFragmentRoot packageFragmentRoot: javaProject.getAllPackageFragmentRoots()) {\n\t\t\t\tIJavaElement foundElement = packageFragmentRoot.getPackageFragment(packageName);\n\t\t\t\tif (foundElement instanceof IPackageFragment && foundElement.exists()) {\n\t\t\t\t\tIPackageFragment packageFragment = (IPackageFragment) foundElement;\n\t\t\t\t\tIResource packageFragmentResource = packageFragment.getResource();\n\t\t\t\t\tif (packageFragmentResource == null || packageFragmentResource instanceof IFile) {\n\t\t\t\t\t\tObject[] nonJavaResources = packageFragment.getNonJavaResources();\n\t\t\t\t\t\tfor(Object nonJavaResource: nonJavaResources) {\n\t\t\t\t\t\t\t// we have to check for concrete class because getFullPath\n\t\t\t\t\t\t\t// behaves differently\n\t\t\t\t\t\t\tIJarEntryResource jarEntryResource = (IJarEntryResource) nonJavaResource;\n\t\t\t\t\t\t\tif (packageFragmentRoot.isArchive()) {\n\t\t\t\t\t\t\t\tif (fullPath.equals(jarEntryResource.getFullPath().toString())) {\n\t\t\t\t\t\t\t\t\tIResource packageFragmentRootResource = packageFragmentRoot.getResource();\n\t\t\t\t\t\t\t\t\tif (packageFragmentRootResource != null) { // we have a resource - use nested platform/resource\n\t\t\t\t\t\t\t\t\t\tURI packageFragmentRootURI = createPlatformResourceURI(packageFragmentRootResource);\n\t\t\t\t\t\t\t\t\t\tURI result = createArchiveURI(packageFragmentRootURI, fullPath);\n\t\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// no resource - use file uri\n\t\t\t\t\t\t\t\t\t\tIPath packageFragmentRootPath = packageFragmentRoot.getPath();\n\t\t\t\t\t\t\t\t\t\tURI packageFragmentRootURI = URI.createFileURI(packageFragmentRootPath.toString());\n\t\t\t\t\t\t\t\t\t\tURI result = createArchiveURI(packageFragmentRootURI, fullPath);\n\t\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tString nonJavaResourceName = jarEntryResource.getName();\n\t\t\t\t\t\t\t\tif (name.equals(nonJavaResourceName)) {\n\t\t\t\t\t\t\t\t\tif (packageFragmentRoot.isExternal()) {\n\t\t\t\t\t\t\t\t\t\t// the following code will return null\n//\t\t\t\t\t\t\t\t\t\tIResource resource = packageFragmentRoot.getUnderlyingResource();\n\t\t\t\t\t\t\t\t\t\tif (!(packageFragmentRoot instanceof ExternalPackageFragmentRoot))\n\t\t\t\t\t\t\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t\t\t\t\t\t\t\tIResource resource = ((ExternalPackageFragmentRoot)packageFragmentRoot).resource();\n\t\t\t\t\t\t\t\t\t\tIPath absolutePath = resource.getFullPath();\n\t\t\t\t\t\t\t\t\t\tabsolutePath = absolutePath.append(fullPath);\n\t\t\t\t\t\t\t\t\t\treturn createPlatformResourceURI(absolutePath);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinal Wrapper<IResource> result = Wrapper.<IResource>wrap(null);\n\t\t\t\t\t\tpackageFragmentResource.accept(new IResourceVisitor() {\n\t\t\t\t\t\t\tpublic boolean visit(IResource resource) throws CoreException {\n\t\t\t\t\t\t\t\tif (name.equals(resource.getName()))\n\t\t\t\t\t\t\t\t\tresult.set(resource);\n\t\t\t\t\t\t\t\treturn result.get() == null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, IResource.DEPTH_ONE, IResource.NONE);\n\t\t\t\t\t\tif (result.get() != null)\n\t\t\t\t\t\t\treturn createPlatformResourceURI(result.get());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn classpathUri;\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean isValidUri(URI uri) {\n\t\treturn uri!=null && (resourceFactoryRegistry.getFactory(uri) != null);\n\t}","id":87384,"modified_method":"public boolean isValidUri(URI uri) {\n\t\treturn uri!=null && (resourceFactoryRegistry.getFactory(uri) != null);\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Iterable<IStorage> findStoragesInJarsOrExternalClassFolders(URI uri) {\n\t\tSet<IStorage> result = Sets.newHashSet();\n\t\tif (uri.isArchive()) {\n\t\t\tURI toArchive = getPathToArchive(uri);\n\t\t\tIProject[] projects = getWorkspaceRoot().getProjects();\n\t\t\tfor (IProject iProject : projects) {\n\t\t\t\tif (iProject.isAccessible()) {\n\t\t\t\t\tIJavaProject project = JavaCore.create(iProject);\n\t\t\t\t\tfindStoragesInJarsOrExternalFoldersOfProject(toArchive, uri, project, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":87385,"modified_method":"protected Iterable<IStorage> findStoragesInJarsOrExternalClassFolders(URI uri) {\n\t\tSet<IStorage> result = Sets.newHashSet();\n\t\tif (uri.isArchive()) {\n\t\t\tURI toArchive = getPathToArchive(uri);\n\t\t\tIProject[] projects = getWorkspaceRoot().getProjects();\n\t\t\tfor (IProject iProject : projects) {\n\t\t\t\tif (iProject.isAccessible()) {\n\t\t\t\t\tIJavaProject project = JavaCore.create(iProject);\n\t\t\t\t\tfindStoragesInJarsOfProject(toArchive, uri, project, result);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tIProject[] projects = getWorkspaceRoot().getProjects();\n\t\t\tfor (IProject project : projects) {\n\t\t\t\tif (project.isAccessible()) {\n\t\t\t\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\t\t\t\tfindStoragesInExternalFoldersOfProject(uri, javaProject, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void findStoragesInJarsOrExternalFoldersOfProject(URI toArchive, URI uri, IJavaProject project,\n\t\t\tSet<IStorage> storages) {\n\t\tif (project.exists()) {\n\t\t\ttry {\n\t\t\t\tIPackageFragmentRoot[] fragmentRoots = project.getAllPackageFragmentRoots();\n\t\t\t\tfor (IPackageFragmentRoot fragRoot : fragmentRoots) {\n\t\t\t\t\tif (!\"org.eclipse.jdt.launching.JRE_CONTAINER\".equals(fragRoot.getRawClasspathEntry().getPath()\n\t\t\t\t\t\t\t.toString())) {\n\t\t\t\t\t\tif (getUriForPackageFragmentRoot(fragRoot).equals(toArchive)) {\n\t\t\t\t\t\t\tIStorage storage = findStorageInJar(uri, fragRoot);\n\t\t\t\t\t\t\tif (storage != null)\n\t\t\t\t\t\t\t\tstorages.add(storage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","id":87386,"modified_method":"protected void findStoragesInExternalFoldersOfProject(URI uri, IJavaProject project,\n\t\t\tSet<IStorage> storages) {\n\t\tif (project.exists()) {\n\t\t\ttry {\n\t\t\t\tIPackageFragmentRoot[] fragmentRoots = project.getAllPackageFragmentRoots();\n\t\t\t\tJarEntryLocator locator = new JarEntryLocator();\n\t\t\t\tfor (IPackageFragmentRoot fragRoot : fragmentRoots) {\n\t\t\t\t\tif (fragRoot.isExternal() && !fragRoot.isArchive()) {\n\t\t\t\t\t\tIStorage storage = locator.getJarEntry(uri, fragRoot);\n\t\t\t\t\t\tif (storage != null)\n\t\t\t\t\t\t\tstorages.add(storage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (JavaModelException e) {\n\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"protected URI getUriForIJarEntryResource(IJarEntryResource jarEntry) {\n\t\tIPackageFragmentRoot root = jarEntry.getPackageFragmentRoot();\n\t\tif (root.isArchive()) {\n\t\t\tURI jarURI = getUriForPackageFragmentRoot(root);\n\t\t\tURI storageURI = URI.createURI(jarEntry.getFullPath().toString());\n\t\t\treturn createJarURI(root.isArchive(), jarURI, storageURI);\n\t\t}\n\t\treturn null;\n\t}","id":87387,"modified_method":"protected URI getUriForIJarEntryResource(IJarEntryResource jarEntry) {\n\t\treturn new JarEntryLocator().getURI(jarEntry);\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testResourceInJar() throws Exception {\n\t\tIJavaProject project = createJavaProject(\"foo\");\n\t\tIFile file = project.getProject().getFile(\"foo.jar\");\n\t\tfile.create(jarInputStream(new TextFile(\"foo/bar.txt\", \"...\")), true, monitor());\n\t\taddJarToClasspath(project, file);\n\t\t\n\t\tStorage2UriMapperJavaImpl impl = new Storage2UriMapperJavaImpl() {\n\t\t\t@Override\n\t\t\tprotected boolean isValidUri(URI uri) {\n\t\t\t\treturn uri!=null;\n\t\t\t}\n\t\t};\n\t\tURI uri = URI.createURI(\"archive:platform:/resource/foo/foo.jar!/foo/bar.txt\");\n\t\tIterable<IStorage> storages = impl.getStorages(uri);\n\t\tIterator<IStorage> iterator = storages.iterator();\n\t\tIStorage next = iterator.next();\n\t\tassertFalse(iterator.hasNext());\n\t\tassertEquals(uri, impl.getUri(next));\n\t\t\n\t}","id":87388,"modified_method":"public void testResourceInJar() throws Exception {\n\t\tIJavaProject project = createJavaProject(\"foo\");\n\t\tIFile file = project.getProject().getFile(\"foo.jar\");\n\t\tfile.create(jarInputStream(new TextFile(\"foo/bar.txt\", \"...\")), true, monitor());\n\t\taddJarToClasspath(project, file);\n\t\t\n\t\tStorage2UriMapperJavaImpl impl = new Storage2UriMapperJavaImpl() {\n\t\t\t@Override\n\t\t\tpublic boolean isValidUri(URI uri) {\n\t\t\t\treturn uri!=null;\n\t\t\t}\n\t\t};\n\t\tURI uri = URI.createURI(\"archive:platform:/resource/foo/foo.jar!/foo/bar.txt\");\n\t\tIterable<IStorage> storages = impl.getStorages(uri);\n\t\tIterator<IStorage> iterator = storages.iterator();\n\t\tIStorage next = iterator.next();\n\t\tassertFalse(iterator.hasNext());\n\t\tassertEquals(uri, impl.getUri(next));\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testSimpleFileInProject() throws Exception {\n\t\tcreateProject(\"foo\");\n\t\tIFile file = createFile(\"foo/bar/baz.txt\", \"\");\n\t\t\n\t\tStorage2UriMapperImpl mapper = new Storage2UriMapperImpl() {\n\t\t\t@Override\n\t\t\tprotected boolean isValidUri(URI uri) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tURI uri = mapper.getUri(file);\n\t\tassertEquals(URI.createPlatformResourceURI(file.getFullPath().toString(),true),uri);\n\t\tassertEquals(file,mapper.getStorages(uri).iterator().next());\n\t}","id":87389,"modified_method":"public void testSimpleFileInProject() throws Exception {\n\t\tcreateProject(\"foo\");\n\t\tIFile file = createFile(\"foo/bar/baz.txt\", \"\");\n\t\t\n\t\tStorage2UriMapperImpl mapper = new Storage2UriMapperImpl() {\n\t\t\t@Override\n\t\t\tpublic boolean isValidUri(URI uri) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tURI uri = mapper.getUri(file);\n\t\tassertEquals(URI.createPlatformResourceURI(file.getFullPath().toString(),true),uri);\n\t\tassertEquals(file,mapper.getStorages(uri).iterator().next());\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"public void register(Injector injector) {\n\tif (!EPackage.Registry.INSTANCE.containsKey(\"http://www.eclipse.org/xtext/test/unicodeChars\")) {\n\t\tEPackage.Registry.INSTANCE.put(\"http://www.eclipse.org/xtext/test/unicodeChars\", org.eclipse.xtext.parser.unicodeTest.UnicodeTestPackage.eINSTANCE);\n\t}\n\n\t\torg.eclipse.xtext.resource.IResourceFactory resourceFactory = injector.getInstance(org.eclipse.xtext.resource.IResourceFactory.class);\n\t\torg.eclipse.xtext.resource.IResourceServiceProvider serviceProvider = injector.getInstance(org.eclipse.xtext.resource.IResourceServiceProvider.class);\n\t\tResource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put(\"unicodecharactertestlanguage\", resourceFactory);\n\t\torg.eclipse.xtext.resource.IResourceServiceProvider.Registry.INSTANCE.getExtensionToFactoryMap().put(\"unicodecharactertestlanguage\", serviceProvider);\n\t\t\n\n\t}","id":87390,"modified_method":"public void register(Injector injector) {\n\tif (!EPackage.Registry.INSTANCE.containsKey(\"http://www.eclipse.org/xtext/test/unicodeChars\")) {\n//\t\tEPackage.Registry.INSTANCE.put(\"http://www.eclipse.org/xtext/test/unicodeChars\", org.eclipse.xtext.parser.unicodeTest.UnicodeTestPackage.eINSTANCE);\n\t}\n\n\t\torg.eclipse.xtext.resource.IResourceFactory resourceFactory = injector.getInstance(org.eclipse.xtext.resource.IResourceFactory.class);\n\t\torg.eclipse.xtext.resource.IResourceServiceProvider serviceProvider = injector.getInstance(org.eclipse.xtext.resource.IResourceServiceProvider.class);\n\t\tResource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put(\"unicodecharactertestlanguage\", resourceFactory);\n\t\torg.eclipse.xtext.resource.IResourceServiceProvider.Registry.INSTANCE.getExtensionToFactoryMap().put(\"unicodecharactertestlanguage\", serviceProvider);\n\t\t\n\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"public Injector createInjector() {\n\t\treturn Guice.createInjector(new org.eclipse.xtext.parser.UnicodeCharacterTestLanguageRuntimeModule());\n\t}","id":87391,"modified_method":"public Injector createInjector() {\n\t\treturn Guice.createInjector(/*new org.eclipse.xtext.parser.UnicodeCharacterTestLanguageRuntimeModule()*/);\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\turi1 = createFileAndRegisterResource(project1, \"file1\");\n\t\turi2 = createFileAndRegisterResource(project1, \"file2\");\n\t\turi3 = createFileAndRegisterResource(project2, \"file3\");\n\t\tIStorage2UriMapper mapper = new Storage2UriMapperImpl() {\n\t\t\t@Override\n\t\t\tprotected boolean isValidUri(URI uri) {\n\t\t\t\treturn uri != null && !uri.toString().endsWith(\"/.project\");\n\t\t\t}\n\t\t};\n\t\tprojectsState = new WorkspaceProjectsState();\n\t\tprojectsState.setMapper(mapper);\n\t}","id":87392,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\turi1 = createFileAndRegisterResource(project1, \"file1\");\n\t\turi2 = createFileAndRegisterResource(project1, \"file2\");\n\t\turi3 = createFileAndRegisterResource(project2, \"file3\");\n\t\tIStorage2UriMapper mapper = new Storage2UriMapperImpl() {\n\t\t\t@Override\n\t\t\tpublic boolean isValidUri(URI uri) {\n\t\t\t\treturn uri != null && !uri.toString().endsWith(\"/.project\");\n\t\t\t}\n\t\t};\n\t\tprojectsState = new WorkspaceProjectsState();\n\t\tprojectsState.setMapper(mapper);\n\t}","commit_id":"13c47c66671e46da7ab6e87c6169f80482bf650f","url":"https://github.com/eclipse/xtext"},{"original_method":"public Object visitClassType(PsiClassType classType) {\n                final PsiClassType rawType = classType.rawType();\n                typeString.append(rawType.getCanonicalText());\n                final PsiType[] parameterTypes = classType.getParameters();\n                if (parameterTypes.length > 0) {\n                    typeString.append('<');\n                    parameterTypes[0].accept(this);\n                    for (int i = 1; i < parameterTypes.length; i++) {\n                        typeString.append(',');\n                        PsiType parameterType = parameterTypes[i];\n                        parameterType.accept(this);\n                    }\n                    typeString.append('>');\n                }\n                return null;\n            }","id":87393,"modified_method":"public Object visitClassType(PsiClassType classType) {\n                final PsiClassType rawType = classType.rawType();\n                typeString.append(rawType.getCanonicalText());\n                final PsiType[] parameterTypes = classType.getParameters();\n                if (parameterTypes.length > 0) {\n                    typeString.append('<');\n                    final PsiType parameterType1 = parameterTypes[0];\n                    // IDEADEV-25549 says this can be null\n                    if (parameterType1 != null) {\n                        parameterType1.accept(this);\n                    }\n                    for (int i = 1; i < parameterTypes.length; i++) {\n                        typeString.append(',');\n                        PsiType parameterType = parameterTypes[i];\n                        // IDEADEV-25549 again\n                        if (parameterType != null) {\n                            parameterType.accept(this);\n                        }\n                    }\n                    typeString.append('>');\n                }\n                return null;\n            }","commit_id":"92145d910149d4b3f247a37775887130b5c10127","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiReferenceExpression[] collectExpressions(final PsiExpression expression, Class<? extends PsiElement>... scopes) {\n    PsiElement parent = PsiTreeUtil.getParentOfType(expression, scopes);\n\n    final List<PsiReferenceExpression> result = new ArrayList<PsiReferenceExpression>();\n    JavaRecursiveElementWalkingVisitor visitor = new JavaRecursiveElementWalkingVisitor() {\n      public List getResult() {\n        return result;\n      }\n\n      @Override public void visitReferenceExpression(PsiReferenceExpression expr) {\n        if (expression instanceof PsiReferenceExpression) {\n          if (expr.textMatches(expression) && expr.resolve() == null) {\n            result.add(expr);\n          }\n        }\n        visitElement(expr);\n      }\n\n      @Override public void visitMethodCallExpression(PsiMethodCallExpression expr) {\n        if (expression instanceof PsiMethodCallExpression) {\n          PsiReferenceExpression methodExpression = expr.getMethodExpression();\n          if (methodExpression.textMatches(((PsiMethodCallExpression) expression).getMethodExpression())) {\n            result.add(expr.getMethodExpression());\n          }\n        }\n        visitElement(expr);\n      }\n    };\n\n    parent.accept(visitor);\n    return result.toArray(new PsiReferenceExpression[result.size()]);\n  }","id":87394,"modified_method":"public static PsiReferenceExpression[] collectExpressions(final PsiExpression expression, Class<? extends PsiElement>... scopes) {\n    PsiElement parent = PsiTreeUtil.getParentOfType(expression, scopes);\n\n    final List<PsiReferenceExpression> result = new ArrayList<PsiReferenceExpression>();\n    JavaRecursiveElementWalkingVisitor visitor = new JavaRecursiveElementWalkingVisitor() {\n      public List getResult() {\n        return result;\n      }\n\n      @Override public void visitReferenceExpression(PsiReferenceExpression expr) {\n        if (expression instanceof PsiReferenceExpression) {\n          if (expr.textMatches(expression) && expr.resolve() == null) {\n            result.add(expr);\n          }\n        }\n        visitElement(expr);\n      }\n\n      @Override public void visitMethodCallExpression(PsiMethodCallExpression expr) {\n        if (expression instanceof PsiMethodCallExpression) {\n          PsiReferenceExpression methodExpression = expr.getMethodExpression();\n          if (methodExpression.textMatches(((PsiMethodCallExpression) expression).getMethodExpression())) {\n            result.add(expr.getMethodExpression());\n          }\n        }\n        visitElement(expr);\n      }\n    };\n\n    if (parent != null) {\n      parent.accept(visitor);\n    }\n    return result.toArray(new PsiReferenceExpression[result.size()]);\n  }","commit_id":"1d34a95b0f2deee90003c1b426a5bbf1b4acedf8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!myRefExpr.isValid() || !myRefExpr.getManager().isInProject(myRefExpr)) return false;\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement refName = myRefExpr.getReferenceNameElement();\n    if (refName == null) return false;\n    TextRange textRange = refName.getTextRange();\n    if (textRange == null || offset < textRange.getStartOffset() ||\n        offset > textRange.getEndOffset()) {\n      return false;\n    }\n\n    return !CreateFromUsageUtils.isValidReference(myRefExpr, false);\n  }","id":87395,"modified_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!myRefExpr.isValid() || !myRefExpr.getManager().isInProject(myRefExpr)) return false;\n    int offset = editor.getCaretModel().getOffset();\n    PsiElement refName = myRefExpr.getReferenceNameElement();\n    if (refName == null) return false;\n    TextRange textRange = refName.getTextRange();\n    if (textRange == null || offset < textRange.getStartOffset() ||\n        offset > textRange.getEndOffset()) {\n      return false;\n    }\n\n    return !CreateFromUsageUtils.isValidReference(myRefExpr, false) && CreateFromUsageUtils.collectExpressions(myRefExpr, PsiMember.class, PsiFile.class).length > 0;\n  }","commit_id":"1d34a95b0f2deee90003c1b426a5bbf1b4acedf8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processCall(PsiCallExpression expression){\n      PsiExpressionList argumentList = expression.getArgumentList();\n      if (argumentList == null) return;\n      PsiExpression[] args = argumentList.getExpressions();\n      PsiMethod oldMethod = expression.resolveMethod();\n      if (oldMethod == null) return;\n      PsiParameter[] parameters = oldMethod.getParameterList().getParameters();\n\n      try {\n        for (int i = 0; i < args.length; i++) {\n          final PsiExpression arg = deparenthesizeExpression(args[i]);\n          if (arg instanceof PsiTypeCastExpression) {\n            PsiTypeCastExpression cast = (PsiTypeCastExpression)arg;\n            if (i == args.length - 1 && args.length == parameters.length && parameters[i].isVarArgs()) {\n              //do not mark cast to resolve ambiguity for calling varargs method with inexact argument\n              continue;\n            }\n            PsiCallExpression newCall = (PsiCallExpression) expression.copy();\n            final PsiExpressionList argList = newCall.getArgumentList();\n            LOG.assertTrue(argList != null);\n            PsiExpression[] newArgs = argList.getExpressions();\n            PsiTypeCastExpression castExpression = (PsiTypeCastExpression) deparenthesizeExpression(newArgs[i]);\n            PsiExpression castOperand = castExpression.getOperand();\n            if (castOperand == null) return;\n            castExpression.replace(castOperand);\n            final JavaResolveResult newResult = newCall.resolveMethodGenerics();\n            if (oldMethod.equals(newResult.getElement()) && newResult.isValidResult() &&\n                Comparing.equal(newCall.getType(), expression.getType())) {\n              addToResults(cast);\n            }\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        return;\n      }\n\n      for (PsiExpression arg : args) {\n        if (arg instanceof PsiTypeCastExpression) {\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          castOperand.accept(this);\n        }\n        else {\n          arg.accept(this);\n        }\n      }\n    }","id":87396,"modified_method":"private void processCall(PsiCallExpression expression){\n      PsiExpressionList argumentList = expression.getArgumentList();\n      if (argumentList == null) return;\n      PsiExpression[] args = argumentList.getExpressions();\n      PsiMethod oldMethod = expression.resolveMethod();\n      if (oldMethod == null) return;\n      PsiParameter[] parameters = oldMethod.getParameterList().getParameters();\n\n      try {\n        for (int i = 0; i < args.length; i++) {\n          final PsiExpression arg = deparenthesizeExpression(args[i]);\n          if (arg instanceof PsiTypeCastExpression) {\n            PsiTypeCastExpression cast = (PsiTypeCastExpression)arg;\n            if (i == args.length - 1 && args.length == parameters.length && parameters[i].isVarArgs()) {\n              //do not mark cast to resolve ambiguity for calling varargs method with inexact argument\n              continue;\n            }\n            PsiCallExpression newCall = (PsiCallExpression) expression.copy();\n            final PsiExpressionList argList = newCall.getArgumentList();\n            LOG.assertTrue(argList != null);\n            PsiExpression[] newArgs = argList.getExpressions();\n            PsiTypeCastExpression castExpression = (PsiTypeCastExpression) deparenthesizeExpression(newArgs[i]);\n            PsiExpression castOperand = castExpression.getOperand();\n            if (castOperand == null) return;\n            castExpression.replace(castOperand);\n            final JavaResolveResult newResult = newCall.resolveMethodGenerics();\n            if (oldMethod.equals(newResult.getElement()) && newResult.isValidResult() &&\n                Comparing.equal(newCall.getType(), expression.getType())) {\n              addToResults(cast);\n            }\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        return;\n      }\n\n      for (PsiExpression arg : args) {\n        if (arg instanceof PsiTypeCastExpression) {\n          PsiExpression castOperand = ((PsiTypeCastExpression)arg).getOperand();\n          if (castOperand != null) {\n            castOperand.accept(this);\n          }\n        }\n        else {\n          arg.accept(this);\n        }\n      }\n    }","commit_id":"cd16d97851fb92f8a8d3e29de07127252454d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MyCollectingVisitor() {\n      super(true);\n    }","id":87397,"modified_method":"private MyCollectingVisitor() {\n      super(true);\n    }","commit_id":"cd16d97851fb92f8a8d3e29de07127252454d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MyIsRedundantVisitor(final boolean recursive) {\n      myRecursive = recursive;\n    }","id":87398,"modified_method":"private MyIsRedundantVisitor(final boolean recursive) {\n      myRecursive = recursive;\n    }","commit_id":"cd16d97851fb92f8a8d3e29de07127252454d434","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static ExpectedTypeInfo[] getExpectedTypes(@Nullable PsiExpression expr, boolean forCompletion, ExpectedClassProvider classProvider,\n                                                    final boolean voidable, boolean usedAfter) {\n    if (expr == null) return ExpectedTypeInfo.EMPTY_ARRAY;\n    PsiElement parent = expr.getParent();\n    while (parent instanceof PsiParenthesizedExpression) {\n      expr = (PsiExpression)parent;\n      parent = parent.getParent();\n    }\n    MyParentVisitor visitor = new MyParentVisitor(expr, forCompletion, classProvider, voidable, usedAfter);\n    parent.accept(visitor);\n    return visitor.getResult();\n  }","id":87399,"modified_method":"@NotNull\n  public static ExpectedTypeInfo[] getExpectedTypes(@Nullable PsiExpression expr, boolean forCompletion, ExpectedClassProvider classProvider,\n                                                    final boolean voidable, boolean usedAfter) {\n    if (expr == null) return ExpectedTypeInfo.EMPTY_ARRAY;\n    PsiElement parent = expr.getParent();\n    while (parent instanceof PsiParenthesizedExpression) {\n      expr = (PsiExpression)parent;\n      parent = parent.getParent();\n    }\n    MyParentVisitor visitor = new MyParentVisitor(expr, forCompletion, classProvider, voidable, usedAfter);\n    if (parent != null) {\n      parent.accept(visitor);\n    }\n    return visitor.getResult();\n  }","commit_id":"0bbf4ee0d4809078a339d8fc6bbcaaae5c155640","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitForStatement(GrForStatement forStatement) {\n    final GrForClause clause = forStatement.getClause();\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrCondition initializer : ((GrTraditionalForClause) clause).getInitialization()) {\n        initializer.accept(this);\n      }\n    } else if (clause instanceof GrForInClause) {\n      final GrExpression expression = ((GrForInClause) clause).getIteratedExpression();\n      expression.accept(this);\n    }\n\n    InstructionImpl instruction = startNode(forStatement);\n    if (clause instanceof GrTraditionalForClause) {\n      final GrExpression condition = ((GrTraditionalForClause) clause).getCondition();\n      if (condition != null) {\n        condition.accept(this);\n      }\n    }\n    addPendingEdge(forStatement, myHead); //break cycle\n\n    final GrStatement body = forStatement.getBody();\n    if (body != null) {\n      InstructionImpl bodyInstruction = startNode(body);\n      body.accept(this);\n      finishNode(bodyInstruction);\n    }\n    checkPending(instruction); //check for breaks targeted here\n\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrExpression expression : ((GrTraditionalForClause) clause).getUpdate()) {\n        expression.accept(this);\n      }\n    }\n    if (myHead != null) addEdge(myHead, instruction);  //loop\n    flowAbrupted();\n\n    finishNode(instruction);\n  }","id":87400,"modified_method":"public void visitForStatement(GrForStatement forStatement) {\n    final GrForClause clause = forStatement.getClause();\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrCondition initializer : ((GrTraditionalForClause) clause).getInitialization()) {\n        initializer.accept(this);\n      }\n    } else if (clause instanceof GrForInClause) {\n      final GrExpression expression = ((GrForInClause) clause).getIteratedExpression();\n      if (expression != null) {\n        expression.accept(this);\n      }\n    }\n\n    InstructionImpl instruction = startNode(forStatement);\n    if (clause instanceof GrTraditionalForClause) {\n      final GrExpression condition = ((GrTraditionalForClause) clause).getCondition();\n      if (condition != null) {\n        condition.accept(this);\n      }\n    }\n    addPendingEdge(forStatement, myHead); //break cycle\n\n    final GrStatement body = forStatement.getBody();\n    if (body != null) {\n      InstructionImpl bodyInstruction = startNode(body);\n      body.accept(this);\n      finishNode(bodyInstruction);\n    }\n    checkPending(instruction); //check for breaks targeted here\n\n    if (clause instanceof GrTraditionalForClause) {\n      for (GrExpression expression : ((GrTraditionalForClause) clause).getUpdate()) {\n        expression.accept(this);\n      }\n    }\n    if (myHead != null) addEdge(myHead, instruction);  //loop\n    flowAbrupted();\n\n    finishNode(instruction);\n  }","commit_id":"be25267a7fea1a7fd9d19ca540d2174830e99cba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processIntention(PsiElement element)\n      throws IncorrectOperationException {\n    final GrForStatement parentStatement =\n        (GrForStatement) element;\n    assert parentStatement != null;\n    final GrForInClause clause = (GrForInClause) parentStatement.getClause();\n    final GrVariable var = clause.getDeclaredVariables()[0];\n    final GrStatement body = parentStatement.getBody();\n    final String bodyText;\n    if (body instanceof GrBlockStatement) {\n      final String text = body.getText();\n      bodyText = text.substring(1, text.length()-1);\n    } else {\n      bodyText = body.getText();\n\n    }\n\n    final GrExpression collection = clause.getIteratedExpression();\n    @NonNls final String statement = collection.getText() + \".each{\" + var.getText() + \" -> \" + bodyText + \" }\";\n    replaceStatement(statement, parentStatement);\n  }","id":87401,"modified_method":"public void processIntention(PsiElement element)\n      throws IncorrectOperationException {\n    final GrForStatement parentStatement =\n        (GrForStatement) element;\n    assert parentStatement != null;\n    final GrForInClause clause = (GrForInClause) parentStatement.getClause();\n    final GrVariable var = clause.getDeclaredVariables()[0];\n    final GrStatement body = parentStatement.getBody();\n    final String bodyText;\n    if (body instanceof GrBlockStatement) {\n      final String text = body.getText();\n      bodyText = text.substring(1, text.length()-1);\n    } else {\n      bodyText = body.getText();\n\n    }\n\n    final GrExpression collection = clause.getIteratedExpression();\n    assert collection != null;\n    @NonNls final String statement = collection.getText() + \".each{\" + var.getText() + \" -> \" + bodyText + \" }\";\n    replaceStatement(statement, parentStatement);\n  }","commit_id":"be25267a7fea1a7fd9d19ca540d2174830e99cba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrForStatement)) {\n      return false;\n    }\n    final GrForStatement statement = (GrForStatement) element;\n    final GrForClause clause = statement.getClause();\n    if (!(clause instanceof GrForInClause)) {\n      return false;\n    }\n    return !ErrorUtil.containsError(element);\n  }","id":87402,"modified_method":"public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof GrForStatement)) {\n      return false;\n    }\n    final GrForStatement statement = (GrForStatement) element;\n    final GrForClause clause = statement.getClause();\n    if (!(clause instanceof GrForInClause) || ((GrForInClause) clause).getIteratedExpression() == null) {\n      return false;\n    }\n    return !ErrorUtil.containsError(element);\n  }","commit_id":"be25267a7fea1a7fd9d19ca540d2174830e99cba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitJavaFile(PsiJavaFile file) {\n            final PsiImportList importList = file.getImportList();\n            if (importList == null) {\n                return;\n            }\n            final PsiClass[] classes = file.getClasses();\n            final PsiPackageStatement packageStatement =\n                    file.getPackageStatement();\n            if (packageStatement == null) return;\n            final PsiModifierList annotationList =\n                    packageStatement.getAnnotationList();\n            final PsiImportStatement[] importStatements =\n                    importList.getImportStatements();\n            checkImports(importStatements, classes, annotationList);\n            final PsiImportStaticStatement[] importStaticStatements =\n                    importList.getImportStaticStatements();\n            checkStaticImports(importStaticStatements, classes);\n        }","id":87403,"modified_method":"public void visitJavaFile(PsiJavaFile file) {\n            final PsiImportList importList = file.getImportList();\n            if (importList == null) {\n                return;\n            }\n            final PsiClass[] classes = file.getClasses();\n            final PsiPackageStatement packageStatement =\n                    file.getPackageStatement();\n            final PsiModifierList annotationList;\n            if (packageStatement != null) {\n                annotationList = packageStatement.getAnnotationList();\n            } else {\n                annotationList =  null;\n            }\n            final PsiImportStatement[] importStatements =\n                    importList.getImportStatements();\n            checkImports(importStatements, classes, annotationList);\n            final PsiImportStaticStatement[] importStaticStatements =\n                    importList.getImportStaticStatements();\n            checkStaticImports(importStaticStatements, classes);\n        }","commit_id":"2119fe817357cd339ba7d9bef84d58158bb1a619","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkStaticImports(\n                PsiImportStaticStatement[] importStaticStatements,\n                PsiClass[] classes) {\n            final StaticImportsAreUsedVisitor visitor =\n                    new StaticImportsAreUsedVisitor(importStaticStatements);\n            for (PsiClass aClass : classes) {\n                aClass.accept(visitor);\n            }\n            final PsiImportStaticStatement[] unusedImportStaticStatements =\n                    visitor.getUnusedImportStaticStatements();\n            for (PsiImportStaticStatement importStaticStatement :\n                    unusedImportStaticStatements) {\n                registerError(importStaticStatement);\n            }\n        }","id":87404,"modified_method":"private void checkStaticImports(\n                PsiImportStaticStatement[] importStaticStatements,\n                PsiClass[] classes) {\n            if (importStaticStatements.length == 0) {\n                return;\n            }\n            final StaticImportsAreUsedVisitor visitor =\n                    new StaticImportsAreUsedVisitor(importStaticStatements);\n            for (PsiClass aClass : classes) {\n                aClass.accept(visitor);\n            }\n            final PsiImportStaticStatement[] unusedImportStaticStatements =\n                    visitor.getUnusedImportStaticStatements();\n            for (PsiImportStaticStatement importStaticStatement :\n                    unusedImportStaticStatements) {\n                registerError(importStaticStatement);\n            }\n        }","commit_id":"2119fe817357cd339ba7d9bef84d58158bb1a619","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkImports(PsiImportStatement[] importStatements,\n                                  PsiClass[] classes,\n                                  PsiModifierList annotationList) {\n            final ImportsAreUsedVisitor visitor =\n                    new ImportsAreUsedVisitor(importStatements);\n            for (PsiClass aClass : classes) {\n                aClass.accept(visitor);\n            }\n            annotationList.accept(visitor);\n            final PsiImportStatement[] unusedImportStatements =\n                    visitor.getUnusedImportStatements();\n            for (PsiImportStatement unusedImportStatement :\n                    unusedImportStatements) {\n                registerError(unusedImportStatement);\n            }\n        }","id":87405,"modified_method":"private void checkImports(PsiImportStatement[] importStatements,\n                                  PsiClass[] classes,\n                                  @Nullable PsiModifierList annotationList) {\n            if (importStatements.length == 0) {\n                return;\n            }\n            final ImportsAreUsedVisitor visitor =\n                    new ImportsAreUsedVisitor(importStatements);\n            for (PsiClass aClass : classes) {\n                aClass.accept(visitor);\n            }\n            if (annotationList != null) {\n                annotationList.accept(visitor);\n            }\n            final PsiImportStatement[] unusedImportStatements =\n                    visitor.getUnusedImportStatements();\n            for (PsiImportStatement unusedImportStatement :\n                    unusedImportStatements) {\n                registerError(unusedImportStatement);\n            }\n        }","commit_id":"2119fe817357cd339ba7d9bef84d58158bb1a619","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String[] getUnserolvedReferences(final PsiElement parentOfType, final boolean referenceOnMethod) {\n    final List<String> unresolvedRefs = new ArrayList<String>();\n    parentOfType.accept(new PsiRecursiveElementVisitor() {\n      public void visitReferenceExpression(PsiReferenceExpression reference) {\n        final PsiElement parent = reference.getParent();\n        if(parent instanceof PsiReference) return;\n        if(referenceOnMethod && parent instanceof PsiMethodCallExpression && reference == ((PsiMethodCallExpression)parent).getMethodExpression()) {\n          if (reference.resolve() == null) unresolvedRefs.add(reference.getReferenceName());\n        }\n        else if(!referenceOnMethod && reference.resolve() == null) unresolvedRefs.add(reference.getReferenceName());\n      }\n    });\n    return unresolvedRefs.toArray(new String[unresolvedRefs.size()]);\n  }","id":87406,"modified_method":"public static String[] getUnserolvedReferences(final PsiElement parentOfType, final boolean referenceOnMethod) {\n    final List<String> unresolvedRefs = new ArrayList<String>();\n    if (parentOfType != null) {\n      parentOfType.accept(new PsiRecursiveElementVisitor() {\n        public void visitReferenceExpression(PsiReferenceExpression reference) {\n          final PsiElement parent = reference.getParent();\n          if(parent instanceof PsiReference) return;\n          if(referenceOnMethod && parent instanceof PsiMethodCallExpression && reference == ((PsiMethodCallExpression)parent).getMethodExpression()) {\n            if (reference.resolve() == null) unresolvedRefs.add(reference.getReferenceName());\n          }\n          else if(!referenceOnMethod && reference.resolve() == null) unresolvedRefs.add(reference.getReferenceName());\n        }\n      });\n    }\n    return unresolvedRefs.toArray(new String[unresolvedRefs.size()]);\n  }","commit_id":"c6ab0e9054440d4692c1e22176d8932d95568069","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitBuiltinTypeClassExpression(GrBuiltinTypeClassExpression expression) {\n    final IElementType type = expression.getFirstChild().getNode().getElementType();\n    final String boxed = TypesUtil.getBoxedTypeName(type);\n    builder.append(boxed);\n    if (expression.getParent() instanceof GrIndexProperty) {\n      builder.append(\"[]\");\n    }\n    builder.append(\".class\");\n  }","id":87407,"modified_method":"@Override\n  public void visitBuiltinTypeClassExpression(GrBuiltinTypeClassExpression expression) {\n    PsiElement firstChild = expression.getFirstChild();\n    LOG.assertTrue(firstChild != null);\n    ASTNode node = firstChild.getNode();\n    LOG.assertTrue(node != null);\n    final IElementType type = node.getElementType();\n    final String boxed = TypesUtil.getBoxedTypeName(type);\n    builder.append(boxed);\n    if (expression.getParent() instanceof GrIndexProperty) {\n      builder.append(\"[]\");\n    }\n    builder.append(\".class\");\n  }","commit_id":"a38b0baf1c159e30e84cb8e94d02e2f7155b9ce2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitIndexProperty(GrIndexProperty expression) {\n    final GrExpression selectedExpression = expression.getSelectedExpression();\n    final PsiType thisType = selectedExpression.getType();\n\n    final GrArgumentList argList = expression.getArgumentList();\n\n    if (argList.getAllArguments().length == 0) {                       // int[] or String[]\n      if (selectedExpression instanceof GrBuiltinTypeClassExpression) {\n        selectedExpression.accept(this);\n        return;\n      }\n      else if (selectedExpression instanceof GrReferenceExpression &&\n               ((GrReferenceExpression)selectedExpression).resolve() instanceof PsiClass) {\n        builder.append(((PsiClass)((GrReferenceExpression)selectedExpression).resolve()).getQualifiedName());\n        builder.append(\"[].class\");\n        return;\n      }\n    }\n    final PsiType[] argTypes = PsiUtil.getArgumentTypes(argList);\n    final PsiManager manager = expression.getManager();\n    final GlobalSearchScope resolveScope = expression.getResolveScope();\n\n    final GrExpression[] exprArgs = argList.getExpressionArguments();\n    final GrNamedArgument[] namedArgs = argList.getNamedArguments();\n\n    if (!PsiImplUtil.isSimpleArrayAccess(thisType, argTypes, manager, resolveScope)) {\n      final GroovyResolveResult candidate = PsiImplUtil.extractUniqueResult(expression.multiResolve(false));\n      PsiElement element = candidate.getElement();\n      if (element != null || !PsiUtil.isLValue(expression)) {                     //see the case of l-value in assignment expression\n        if (element instanceof GrGdkMethod && ((GrGdkMethod)element).getStaticMethod().getParameterList().getParameters()[0].getType().equalsToText(\"java.util.Map<K,V>\")) {\n          PsiClass map = JavaPsiFacade.getInstance(context.project).findClass(CommonClassNames.JAVA_UTIL_MAP, expression.getResolveScope());\n          if (map != null) {\n            PsiMethod[] gets = map.findMethodsByName(\"get\", false);\n            invokeMethodOn(gets[0], selectedExpression, exprArgs, namedArgs, EMPTY_ARRAY, PsiSubstitutor.EMPTY, expression);\n            return;\n          }\n        }\n        else if (element instanceof GrGdkMethod && ((GrGdkMethod)element).getStaticMethod().getParameterList().getParameters()[0].getType().equalsToText(\"java.util.List<T>\")) {\n          PsiClass list = JavaPsiFacade.getInstance(context.project).findClass(CommonClassNames.JAVA_UTIL_LIST, expression.getResolveScope());\n          if (list != null) {\n            PsiMethod[] gets = list.findMethodsByName(\"get\", false);\n            invokeMethodOn(gets[0], selectedExpression, exprArgs, namedArgs, EMPTY_ARRAY, PsiSubstitutor.EMPTY, expression);\n            return;\n          }\n          \n        }\n        invokeMethodByResolveResult(selectedExpression, candidate, \"getAt\", exprArgs, namedArgs, EMPTY_ARRAY, this, expression);\n        return;\n      }\n    }\n\n    selectedExpression.accept(this);\n    builder.append('[');\n    final GrExpression arg = exprArgs[0];\n    arg.accept(this);\n    builder.append(']');\n  }","id":87408,"modified_method":"@Override\n  public void visitIndexProperty(GrIndexProperty expression) {\n    final GrExpression selectedExpression = expression.getSelectedExpression();\n    final PsiType thisType = selectedExpression.getType();\n\n    final GrArgumentList argList = expression.getArgumentList();\n\n    if (argList.getAllArguments().length == 0) {                       // int[] or String[]\n      if (selectedExpression instanceof GrBuiltinTypeClassExpression) {\n        selectedExpression.accept(this);\n        return;\n      }\n      else if (selectedExpression instanceof GrReferenceExpression) {\n        PsiElement resolved = ((GrReferenceExpression)selectedExpression).resolve();\n        if (resolved instanceof PsiClass) {\n          builder.append(((PsiClass)resolved).getQualifiedName());\n          builder.append(\"[].class\");\n          return;\n        }\n      }\n    }\n    final PsiType[] argTypes = PsiUtil.getArgumentTypes(argList);\n    final PsiManager manager = expression.getManager();\n    final GlobalSearchScope resolveScope = expression.getResolveScope();\n\n    final GrExpression[] exprArgs = argList.getExpressionArguments();\n    final GrNamedArgument[] namedArgs = argList.getNamedArguments();\n\n    if (!PsiImplUtil.isSimpleArrayAccess(thisType, argTypes, manager, resolveScope)) {\n      final GroovyResolveResult candidate = PsiImplUtil.extractUniqueResult(expression.multiResolve(false));\n      PsiElement element = candidate.getElement();\n      if (element != null || !PsiUtil.isLValue(expression)) {                     //see the case of l-value in assignment expression\n        if (element instanceof GrGdkMethod && ((GrGdkMethod)element).getStaticMethod().getParameterList().getParameters()[0].getType().equalsToText(\"java.util.Map<K,V>\")) {\n          PsiClass map = JavaPsiFacade.getInstance(context.project).findClass(CommonClassNames.JAVA_UTIL_MAP, expression.getResolveScope());\n          if (map != null) {\n            PsiMethod[] gets = map.findMethodsByName(\"get\", false);\n            invokeMethodOn(gets[0], selectedExpression, exprArgs, namedArgs, EMPTY_ARRAY, PsiSubstitutor.EMPTY, expression);\n            return;\n          }\n        }\n        else if (element instanceof GrGdkMethod && ((GrGdkMethod)element).getStaticMethod().getParameterList().getParameters()[0].getType().equalsToText(\"java.util.List<T>\")) {\n          PsiClass list = JavaPsiFacade.getInstance(context.project).findClass(CommonClassNames.JAVA_UTIL_LIST, expression.getResolveScope());\n          if (list != null) {\n            PsiMethod[] gets = list.findMethodsByName(\"get\", false);\n            invokeMethodOn(gets[0], selectedExpression, exprArgs, namedArgs, EMPTY_ARRAY, PsiSubstitutor.EMPTY, expression);\n            return;\n          }\n          \n        }\n        invokeMethodByResolveResult(selectedExpression, candidate, \"getAt\", exprArgs, namedArgs, EMPTY_ARRAY, this, expression);\n        return;\n      }\n    }\n\n    selectedExpression.accept(this);\n    builder.append('[');\n    final GrExpression arg = exprArgs[0];\n    arg.accept(this);\n    builder.append(']');\n  }","commit_id":"a38b0baf1c159e30e84cb8e94d02e2f7155b9ce2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitInstanceofExpression(GrInstanceOfExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    final GrTypeElement typeElement = expression.getTypeElement();\n    operand.accept(this);\n    builder.append(\" instanceof \");\n    typeElement.accept(this);\n  }","id":87409,"modified_method":"@Override\n  public void visitInstanceofExpression(GrInstanceOfExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    final GrTypeElement typeElement = expression.getTypeElement();\n    operand.accept(this);\n    builder.append(\" instanceof \");\n\n    if (typeElement != null) {\n      typeElement.accept(this);\n    }\n  }","commit_id":"a38b0baf1c159e30e84cb8e94d02e2f7155b9ce2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void accept(@NotNull final PsiElementVisitor visitor, final boolean needReadAction) {\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    final FileIndex fileIndex = getFileIndex();\n    accept(new Processor<VirtualFile>() {\n      @Override\n      public boolean process(VirtualFile file) {\n        return processFile(file, visitor, fileIndex, psiManager, needReadAction);\n      }\n    });\n  }","id":87410,"modified_method":"private void accept(@NotNull final PsiElementVisitor visitor, final boolean clearResolveCache) {\n    final boolean needReadAction = !ApplicationManager.getApplication().isReadAccessAllowed();\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    final FileIndex fileIndex = getFileIndex();\n    accept(new Processor<VirtualFile>() {\n      @Override\n      public boolean process(VirtualFile file) {\n        if (file.isDirectory()) return true;\n        if (ProjectCoreUtil.isProjectOrWorkspaceFile(file)) return true;\n        if (fileIndex.isInContent(file) && (myIncludeTestSource || !fileIndex.isInTestSourceContent(file))\n            && !isInGeneratedSources(file, myProject)) {\n          return processFile(file, visitor, psiManager, needReadAction, clearResolveCache);\n        }\n        return true;\n      }\n    });\n  }","commit_id":"95a8299e196ca96ee6fe5c1dd53d17aba0e71fc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void accept(@NotNull final PsiElementVisitor visitor) {\n    accept(visitor, !ApplicationManager.getApplication().isReadAccessAllowed());\n  }","id":87411,"modified_method":"public void accept(@NotNull final PsiElementVisitor visitor) {\n    accept(visitor, true);\n  }","commit_id":"95a8299e196ca96ee6fe5c1dd53d17aba0e71fc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processFile(@NotNull final VirtualFile fileOrDir,\n                              @NotNull final PsiElementVisitor visitor,\n                              @NotNull final FileIndex fileIndex,\n                              @NotNull final PsiManager psiManager,\n                              final boolean needReadAction) {\n    if (fileOrDir.isDirectory()) return true;\n    if (ProjectCoreUtil.isProjectOrWorkspaceFile(fileOrDir)) return true;\n    if (fileIndex.isInContent(fileOrDir) && (myIncludeTestSource || !fileIndex.isInTestSourceContent(fileOrDir))\n        && !isInGeneratedSources(fileOrDir, psiManager.getProject())) {\n      return processFile(fileOrDir, visitor, psiManager, needReadAction);\n    }\n    return true;\n  }","id":87412,"modified_method":"private static void doProcessFile(@NotNull PsiElementVisitor visitor, @NotNull PsiManager psiManager, @NotNull VirtualFile vFile,\n                                    boolean clearResolveCache) {\n    if (!vFile.isValid()) return;\n\n    PsiFile psiFile = psiManager.findFile(vFile);\n    if (psiFile == null || !shouldHighlightFile(psiFile)) return;\n\n    psiFile.accept(visitor);\n    if (clearResolveCache) {\n      psiManager.dropResolveCaches();\n      InjectedLanguageManager.getInstance(psiManager.getProject()).dropFileCaches(psiFile);\n    }\n  }","commit_id":"95a8299e196ca96ee6fe5c1dd53d17aba0e71fc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean processFile(@NotNull final VirtualFile fileOrDir,\n                                     @NotNull final PsiElementVisitor visitor,\n                                     @NotNull final PsiManager psiManager,\n                                     final boolean needReadAction) {\n    final PsiFile file;\n\n    AccessToken accessToken = ReadAction.start();\n    try {\n      if (!fileOrDir.isValid()) return false;\n\n      file = psiManager.findFile(fileOrDir);\n      if (file == null) {\n        //skip .class files under src directory\n        return true;\n      }\n\n      if (!shouldHighlightFile(file)) return true;\n    }\n    finally {\n      accessToken.finish();\n    }\n\n    final Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        doProcessFile(visitor, psiManager, file);\n      }\n    };\n    if (needReadAction && !ApplicationManager.getApplication().isDispatchThread()) {\n      commitAndRunInSmartMode(runnable, psiManager.getProject());\n    }\n    else {\n      runnable.run();\n    }\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    return indicator == null || !indicator.isCanceled();\n  }","id":87413,"modified_method":"private static boolean processFile(@NotNull final VirtualFile vFile,\n                                     @NotNull final PsiElementVisitor visitor,\n                                     @NotNull final PsiManager psiManager,\n                                     final boolean needReadAction, \n                                     final boolean clearResolveCache) {\n    final Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        doProcessFile(visitor, psiManager, vFile, clearResolveCache);\n      }\n    };\n    if (needReadAction && !ApplicationManager.getApplication().isDispatchThread()) {\n      commitAndRunInSmartMode(runnable, psiManager.getProject());\n    }\n    else {\n      runnable.run();\n    }\n    final ProgressIndicator indicator = ProgressManager.getInstance().getProgressIndicator();\n    return indicator == null || !indicator.isCanceled();\n  }","commit_id":"95a8299e196ca96ee6fe5c1dd53d17aba0e71fc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void initFilesSet() {\n    if (myType == FILE) {\n      myFilesSet = new HashSet<VirtualFile>(1);\n      myFilesSet.add(((PsiFileSystemItem)myElement).getVirtualFile());\n    }\n    else if (myType == DIRECTORY || myType == PROJECT || myType == MODULES || myType == MODULE || myType == CUSTOM) {\n      myFilesSet = new HashSet<VirtualFile>();\n      accept(createFileSearcher());\n    }\n    else if (myType == VIRTUAL_FILES) {\n      myFilesSet = new HashSet<VirtualFile>();\n      final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n      for (Iterator<VirtualFile> iterator = myVFiles.iterator(); iterator.hasNext(); ) {\n        final VirtualFile vFile = iterator.next();\n        VfsUtilCore.visitChildrenRecursively(vFile, new VirtualFileVisitor() {\n          @NotNull\n          @Override\n          public Result visitFileEx(@NotNull VirtualFile file) {\n            boolean ignored = fileIndex.isExcluded(file);\n            if (!ignored && !file.isDirectory()) {\n              myFilesSet.add(file);\n            }\n            return ignored ? SKIP_CHILDREN : CONTINUE;\n          }\n        });\n\n        if (vFile.isDirectory()) {\n          iterator.remove();\n        }\n      }\n    }\n  }","id":87414,"modified_method":"protected void initFilesSet() {\n    if (myType == FILE) {\n      myFilesSet = new HashSet<VirtualFile>(1);\n      myFilesSet.add(((PsiFileSystemItem)myElement).getVirtualFile());\n    }\n    else if (myType == DIRECTORY || myType == PROJECT || myType == MODULES || myType == MODULE || myType == CUSTOM) {\n      myFilesSet = new HashSet<VirtualFile>();\n      accept(createFileSearcher(), false);\n    }\n    else if (myType == VIRTUAL_FILES) {\n      myFilesSet = new HashSet<VirtualFile>();\n      final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(myProject).getFileIndex();\n      for (Iterator<VirtualFile> iterator = myVFiles.iterator(); iterator.hasNext(); ) {\n        final VirtualFile vFile = iterator.next();\n        VfsUtilCore.visitChildrenRecursively(vFile, new VirtualFileVisitor() {\n          @NotNull\n          @Override\n          public Result visitFileEx(@NotNull VirtualFile file) {\n            boolean ignored = fileIndex.isExcluded(file);\n            if (!ignored && !file.isDirectory()) {\n              myFilesSet.add(file);\n            }\n            return ignored ? SKIP_CHILDREN : CONTINUE;\n          }\n        });\n\n        if (vFile.isDirectory()) {\n          iterator.remove();\n        }\n      }\n    }\n  }","commit_id":"95a8299e196ca96ee6fe5c1dd53d17aba0e71fc5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String createVarByInitializer(GrExpression initializer) {\n    if (initializer instanceof GrReferenceExpression) {\n      final GrExpression qualifier = ((GrReferenceExpression)initializer).getQualifier();\n      if (qualifier == null) {\n        final PsiElement resolved = ((GrReferenceExpression)initializer).resolve();\n        if (resolved instanceof GrVariable && GroovyRefactoringUtil.isLocalVariable((GrVariable)resolved)) {\n\n          //don't create new var. it is already exists\n          return ((GrVariable)resolved).getName();\n        }\n      }\n    }\n    final String name = suggestVarName(initializer, context);\n    final StringBuilder builder = new StringBuilder();\n    builder.append(\"final \");\n    writeType(builder, initializer.getType(), initializer);\n    builder.append(' ').append(name).append(\" = \");\n    initializer.accept(new ExpressionGenerator(builder, context));\n    builder.append(';');\n    context.myStatements.add(builder.toString());\n    return name;\n  }","id":87415,"modified_method":"private String createVarByInitializer(GrExpression initializer) {\n    GrExpression inner = initializer;\n    while (inner instanceof GrParenthesizedExpression) inner = ((GrParenthesizedExpression)inner).getOperand();\n    if (inner != null) initializer = inner;\n\n    if (initializer instanceof GrReferenceExpression) {\n      final GrExpression qualifier = ((GrReferenceExpression)initializer).getQualifier();\n      if (qualifier == null) {\n        final PsiElement resolved = ((GrReferenceExpression)initializer).resolve();\n        if (resolved instanceof GrVariable && !(resolved instanceof GrField)) {\n\n          //don't create new var. it is already exists\n          return ((GrVariable)resolved).getName();\n        }\n      }\n    }\n    final String name = suggestVarName(initializer, context);\n    final StringBuilder builder = new StringBuilder();\n    builder.append(\"final \");\n    writeType(builder, initializer.getType(), initializer);\n    builder.append(' ').append(name).append(\" = \");\n    initializer.accept(new ExpressionGenerator(builder, context));\n    builder.append(';');\n    context.myStatements.add(builder.toString());\n    return name;\n  }","commit_id":"697ec130fb1fa8c2c44e39e999036e0fb2e6b199","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitConditionalExpression(GrConditionalExpression expression) {\n    final GrExpression condition = expression.getCondition();\n    final GrExpression thenBranch = expression.getThenBranch();\n    final GrExpression elseBranch = expression.getElseBranch();\n\n    final PsiType type = condition.getType();\n    if (type == null || TypesUtil.unboxPrimitiveTypeWrapper(type) == PsiType.BOOLEAN) {\n      condition.accept(this);\n    }\n    else {\n      GenerationUtil.invokeMethodByName(\n        condition,\n        \"asBoolean\",\n        GrExpression.EMPTY_ARRAY, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        this,\n        expression\n      );\n    }\n\n    builder.append(\"?\");\n    thenBranch.accept(this);\n    builder.append(\":\");\n    elseBranch.accept(this);\n  }","id":87416,"modified_method":"@Override\n  public void visitConditionalExpression(GrConditionalExpression expression) {\n    final GrExpression condition = expression.getCondition();\n    final GrExpression thenBranch = expression.getThenBranch();\n    final GrExpression elseBranch = expression.getElseBranch();\n\n    final boolean elvis = expression instanceof GrElvisExpression;\n    final String var;\n    if (elvis) {\n      var = createVarByInitializer(condition);\n    }\n    else {\n      var = null;\n    }\n    final PsiType type = condition.getType();\n    if (type == null || TypesUtil.unboxPrimitiveTypeWrapper(type) == PsiType.BOOLEAN) {\n      if (elvis) {\n        builder.append(var);\n      }\n      else {\n        condition.accept(this);\n      }\n    }\n    else {\n      final GroovyResolveResult[] results = ResolveUtil.getMethodCandidates(type, \"asBoolean\", expression, PsiType.EMPTY_ARRAY);\n      final GroovyResolveResult result = PsiImplUtil.extractUniqueResult(results);\n      GenerationUtil.invokeMethodByResolveResult(\n        elvis ? factory.createReferenceExpressionFromText(var, expression) : condition,\n        result,\n        \"asBoolean\",\n        GrExpression.EMPTY_ARRAY, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        this,\n        expression\n      );\n    }\n\n    builder.append(\"?\");\n    if (thenBranch != null) {\n      if (elvis) {\n        builder.append(var);\n      }\n      else {\n        thenBranch.accept(this);\n      }\n    }\n\n    builder.append(\":\");\n    if (elseBranch != null) {\n      elseBranch.accept(this);\n    }\n  }","commit_id":"697ec130fb1fa8c2c44e39e999036e0fb2e6b199","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    final GrExpression qualifier = referenceExpression.getQualifier();\n    final GroovyResolveResult resolveResult = referenceExpression.advancedResolve();\n    final PsiElement resolved = resolveResult.getElement();\n\n    if (qualifier == null && (resolved == null || resolved instanceof LightElement) &&\n        !(referenceExpression.getParent() instanceof GrCall) &&\n        PsiUtil.isInScriptContext(referenceExpression)) {\n      final GrExpression thisExpr = factory.createExpressionFromText(\"this\", referenceExpression);\n      thisExpr.accept(this);\n      builder.append(\".getBinding().getProperty(\\\"\").append(referenceExpression.getName()).append(\"\\\")\");\n      return;\n    }\n\n    final IElementType type = referenceExpression.getDotTokenType();\n\n    GrExpression qualifierToUse = qualifier;\n\n    if (type == mMEMBER_POINTER) {\n      LOG.assertTrue(qualifier != null);\n      builder.append(\"new \").append(GroovyCommonClassNames.ORG_CODEHAUS_GROOVY_RUNTIME_METHOD_CLOSURE).append(\"(\");\n      qualifier.accept(this);\n      builder.append(\", \\\"\").append(referenceExpression.getReferenceName()).append(\"\\\")\");\n      return;\n    }\n\n    if (type == mOPTIONAL_DOT) {\n      LOG.assertTrue(qualifier != null);\n\n      String qualifierName = createVarByInitializer(qualifier);\n      builder.append(qualifierName).append(\" == null ? null : \");\n\n      qualifierToUse = factory.createReferenceExpressionFromText(qualifierName, referenceExpression);\n    }\n\n\n    if (resolveResult.isInvokedOnProperty()) {\n      LOG.assertTrue(resolved instanceof PsiMethod);\n      invokeMethodOn(\n        ((PsiMethod)resolved),\n        qualifierToUse,\n        GrExpression.EMPTY_ARRAY,\n        GrNamedArgument.EMPTY_ARRAY,\n        GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        referenceExpression\n      );\n    }\n    else {\n      if (qualifierToUse != null) {\n        qualifierToUse.accept(this);\n        builder.append('.');\n      }\n      if (resolved instanceof PsiNamedElement) {\n        final String refName = ((PsiNamedElement)resolved).getName();\n\n        if (resolved instanceof GrVariable && context.analyzedVars.toWrap((GrVariable)resolved)) {\n          builder.append(context.analyzedVars.toVarName((GrVariable)resolved));\n          if (!PsiUtil.isAccessedForWriting(referenceExpression)) {\n            builder.append(\".get()\");\n          }\n        }\n        else {\n          builder.append(refName);\n        }\n      }\n      else {\n        final String refName = referenceExpression.getReferenceName();\n        if (refName != null) {\n          builder.append(refName);\n        }\n        else {\n          final PsiElement nameElement = referenceExpression.getReferenceNameElement();\n          if (nameElement instanceof GrExpression) {\n            ((GrExpression)nameElement).accept(this);\n          }\n          else if (nameElement != null) {\n            builder.append(nameElement.toString());\n          }\n        }\n      }\n    }\n  }","id":87417,"modified_method":"@Override\n  public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    final GrExpression qualifier = referenceExpression.getQualifier();\n    final GroovyResolveResult resolveResult = referenceExpression.advancedResolve();\n    final PsiElement resolved = resolveResult.getElement();\n\n    if (resolved == null && qualifier == null && context.myUsedVarNames.contains(referenceExpression.getReferenceName())) {\n      builder.append(referenceExpression.getReferenceName());\n      return;\n    }\n    if (qualifier == null && (resolved == null || resolved instanceof LightElement) &&\n        !(referenceExpression.getParent() instanceof GrCall) &&\n        PsiUtil.isInScriptContext(referenceExpression)) {\n      final GrExpression thisExpr = factory.createExpressionFromText(\"this\", referenceExpression);\n      thisExpr.accept(this);\n      builder.append(\".getBinding().getProperty(\\\"\").append(referenceExpression.getName()).append(\"\\\")\");\n      return;\n    }\n\n    final IElementType type = referenceExpression.getDotTokenType();\n\n    GrExpression qualifierToUse = qualifier;\n\n    if (type == mMEMBER_POINTER) {\n      LOG.assertTrue(qualifier != null);\n      builder.append(\"new \").append(GroovyCommonClassNames.ORG_CODEHAUS_GROOVY_RUNTIME_METHOD_CLOSURE).append(\"(\");\n      qualifier.accept(this);\n      builder.append(\", \\\"\").append(referenceExpression.getReferenceName()).append(\"\\\")\");\n      return;\n    }\n\n    if (type == mOPTIONAL_DOT) {\n      LOG.assertTrue(qualifier != null);\n\n      String qualifierName = createVarByInitializer(qualifier);\n      builder.append(qualifierName).append(\" == null ? null : \");\n\n      qualifierToUse = factory.createReferenceExpressionFromText(qualifierName, referenceExpression);\n    }\n\n\n    if (resolveResult.isInvokedOnProperty()) {\n      LOG.assertTrue(resolved instanceof PsiMethod);\n      invokeMethodOn(\n        ((PsiMethod)resolved),\n        qualifierToUse,\n        GrExpression.EMPTY_ARRAY,\n        GrNamedArgument.EMPTY_ARRAY,\n        GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        referenceExpression\n      );\n    }\n    else {\n      if (qualifierToUse != null) {\n        qualifierToUse.accept(this);\n        builder.append('.');\n      }\n      if (resolved instanceof PsiNamedElement) {\n        final String refName = ((PsiNamedElement)resolved).getName();\n\n        if (resolved instanceof GrVariable && context.analyzedVars.toWrap((GrVariable)resolved)) {\n          builder.append(context.analyzedVars.toVarName((GrVariable)resolved));\n          if (!PsiUtil.isAccessedForWriting(referenceExpression)) {\n            builder.append(\".get()\");\n          }\n        }\n        else {\n          builder.append(refName);\n        }\n      }\n      else {\n        final String refName = referenceExpression.getReferenceName();\n        if (refName != null) {\n          builder.append(refName);\n        }\n        else {\n          final PsiElement nameElement = referenceExpression.getReferenceNameElement();\n          if (nameElement instanceof GrExpression) {\n            ((GrExpression)nameElement).accept(this);\n          }\n          else if (nameElement != null) {\n            builder.append(nameElement.toString());\n          }\n        }\n      }\n    }\n  }","commit_id":"697ec130fb1fa8c2c44e39e999036e0fb2e6b199","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DescribeImagesResponseType DescribeImages( DescribeImagesType request ) throws EucalyptusCloudException {\n    DescribeImagesResponseType reply = ( DescribeImagesResponseType ) request.getReply();\n\n    ArrayList<String> remList = Lists.newArrayList();\n    //:: remove all deregistered images ::/\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n    List<ImageInfo> imgList = db.query( ImageInfo.deregistered() );\n    for ( ImageInfo deregImg : imgList )\n      db.delete( deregImg );\n    db.commit();\n/*\nIf you specify one or more AMI IDs, only AMIs that have the specified IDs are returned.\nIf you specify an invalid AMI ID, a fault is returned.\nIf you specify an AMI ID for which you do not have access, it will not be included in the returned results.\n*/\n\n/*\nIf you specify one or more AMI owners, only AMIs from the specified owners and for which you have access are returned. The results can include the account IDs of the specified owners, amazon for AMIs owned by Amazon or self for AMIs that you own.\n\nIf you specify a list of executable users, only users that have launch permissions for the AMIs are returned. You can specify account IDs (if you own the AMI(s)), self for AMIs for which you own or have explicit permissions, or all for public AMIs.\n */\n    db = new EntityWrapper<ImageInfo>();\n    String userId = request.getUserId();\n    Boolean isAdmin = request.isAdministrator();\n    UserInfo user = null;\n    try {\n      user = db.recast( UserInfo.class ).getUnique( new UserInfo( userId ) );\n    } catch ( EucalyptusCloudException e ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"Failed to find user information for: \" + userId );\n    }\n\n    ArrayList<String> imageList = request.getImagesSet();\n    if ( imageList == null ) imageList = Lists.newArrayList();\n    ArrayList<String> owners = request.getOwnersSet();\n    if ( owners == null ) owners = Lists.newArrayList();\n    ArrayList<String> executable = request.getExecutableBySet();\n    if ( executable == null ) executable = Lists.newArrayList();\n\n    List<ImageDetails> repList = reply.getImagesSet();\n    //:: handle easy case first ::/\n    if ( imageList.isEmpty() && owners.isEmpty() && executable.isEmpty() )\n      executable.add( \"self\" );\n\n    if ( !owners.isEmpty() ) {\n      if ( owners.remove( \"self\" ) ) owners.add( user.getUserName() );\n      for ( String userName : owners ) {\n        List<ImageInfo> results = db.query( ImageInfo.byOwnerId( userName ) );\n        for ( ImageInfo img : results ) {\n          ImageDetails imgDetails = img.getAsImageDetails();\n          if ( img.isAllowed( user ) && !repList.contains( imgDetails ) && ( imgList.isEmpty() || imgList.contains( imgDetails.getImageId() ) ) )\n            repList.add( imgDetails );\n        }\n      }\n    }\n    if ( !executable.isEmpty() ) {\n      if ( executable.remove( \"self\" ) ) {\n        List<ImageInfo> results = db.query( new ImageInfo() );\n        for ( ImageInfo img : results ) {\n          ImageDetails imgDetails = img.getAsImageDetails();\n          if ( img.isAllowed( user ) && !repList.contains( imgDetails ) && ( imgList.isEmpty() || imgList.contains( imgDetails.getImageId() ) ) )\n            repList.add( imgDetails );\n        }\n      }\n      for ( String execUserId : executable ) {\n        try {\n          UserInfo execUser = db.recast( UserInfo.class ).getUnique( new UserInfo( execUserId ) );\n          List<ImageInfo> results = db.query( new ImageInfo() );\n          for ( ImageInfo img : results ) {\n            ImageDetails imgDetails = img.getAsImageDetails();\n            if ( img.isAllowed( execUser ) && img.getImageOwnerId().equals( user.getUserName() ) && !repList.contains( imgDetails ) )\n              repList.add( imgDetails );\n          }\n        } catch ( Exception e ) {}\n      }\n    }\n    db.commit();\n\n    return reply;\n  }","id":87418,"modified_method":"public DescribeImagesResponseType DescribeImages( DescribeImagesType request ) throws EucalyptusCloudException {\n    DescribeImagesResponseType reply = ( DescribeImagesResponseType ) request.getReply();\n\n    ArrayList<String> remList = Lists.newArrayList();\n    //:: remove all deregistered images ::/\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n    List<ImageInfo> imgList = db.query( ImageInfo.deregistered() );\n    for ( ImageInfo deregImg : imgList )\n      db.delete( deregImg );\n    db.commit();\n/*\nIf you specify one or more AMI IDs, only AMIs that have the specified IDs are returned.\nIf you specify an invalid AMI ID, a fault is returned.\nIf you specify an AMI ID for which you do not have access, it will not be included in the returned results.\n*/\n\n/*\nIf you specify one or more AMI owners, only AMIs from the specified owners and for which you have access are returned. The results can include the account IDs of the specified owners, amazon for AMIs owned by Amazon or self for AMIs that you own.\n\nIf you specify a list of executable users, only users that have launch permissions for the AMIs are returned. You can specify account IDs (if you own the AMI(s)), self for AMIs for which you own or have explicit permissions, or all for public AMIs.\n */\n    db = new EntityWrapper<ImageInfo>();\n    String userId = request.getUserId();\n    Boolean isAdmin = request.isAdministrator();\n    UserInfo user = null;\n    try {\n      user = db.recast( UserInfo.class ).getUnique( new UserInfo( userId ) );\n    } catch ( EucalyptusCloudException e ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"Failed to find user information for: \" + userId );\n    }\n\n    ArrayList<String> imageList = request.getImagesSet();\n    if ( imageList == null ) imageList = Lists.newArrayList();\n    ArrayList<String> owners = request.getOwnersSet();\n    if ( owners == null ) owners = Lists.newArrayList();\n    ArrayList<String> executable = request.getExecutableBySet();\n    if ( executable == null ) executable = Lists.newArrayList();\n\n    List<ImageDetails> repList = reply.getImagesSet();\n    //:: handle easy case first ::/\n    if ( owners.isEmpty() && executable.isEmpty() ) {\n      executable.add( \"self\" );\n    }\n\n    if ( !owners.isEmpty() ) {\n      if ( owners.remove( \"self\" ) ) owners.add( user.getUserName() );\n      for ( String userName : owners ) {\n        List<ImageInfo> results = db.query( ImageInfo.byOwnerId( userName ) );\n        for ( ImageInfo img : results ) {\n          ImageDetails imgDetails = img.getAsImageDetails();\n          if ( img.isAllowed( user ) && !repList.contains( imgDetails ) && ( imgList.isEmpty() || imgList.contains( imgDetails.getImageId() ) ) )\n            repList.add( imgDetails );\n        }\n      }\n    }\n    if ( !executable.isEmpty() ) {\n      if ( executable.remove( \"self\" ) ) {\n        List<ImageInfo> results = db.query( new ImageInfo() );\n        for ( ImageInfo img : results ) {\n          ImageDetails imgDetails = img.getAsImageDetails();\n          if ( img.isAllowed( user ) && !repList.contains( imgDetails ) && ( imgList.isEmpty() || imgList.contains( imgDetails.getImageId() ) ) )\n            repList.add( imgDetails );\n        }\n      }\n      for ( String execUserId : executable ) {\n        try {\n          UserInfo execUser = db.recast( UserInfo.class ).getUnique( new UserInfo( execUserId ) );\n          List<ImageInfo> results = db.query( new ImageInfo() );\n          for ( ImageInfo img : results ) {\n            ImageDetails imgDetails = img.getAsImageDetails();\n            if ( img.isAllowed( execUser ) && img.getImageOwnerId().equals( user.getUserName() ) && !repList.contains( imgDetails ) )\n              repList.add( imgDetails );\n          }\n        } catch ( Exception e ) {}\n      }\n    }\n    db.commit();\n\n    if( !imageList.isEmpty() ) {\n      ArrayList<ImageDetails> newList = Lists.newArrayList();\n      for( ImageDetails img : repList ) {\n        if( imageList.contains( img.getImageId() ) ) {\n          newList.add( img );\n        }\n      }\n      reply.setImagesSet( newList );\n    }\n\n    return reply;\n  }","commit_id":"9a73aa883dd643e547b2b63093c3b2692c168766","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ModifyImageAttributeResponseType ModifyImageAttribute( ModifyImageAttributeType request ) throws EucalyptusCloudException {\n    ModifyImageAttributeResponseType reply = ( ModifyImageAttributeResponseType ) request.getReply();\n\n    if ( request.getAttribute() != null )\n      request.applyAttribute();\n\n    if ( request.getProductCodes().isEmpty() ) {\n      reply.set_return( this.modifyImageInfo( request.getImageId(), request.getUserId(), request.isAdministrator(), request.getAdd(), request.getRemove() ) );\n    } else {\n      EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n      ImageInfo imgInfo = null;\n      try {\n        imgInfo = db.getUnique( new ImageInfo( request.getImageId() ) );\n        for ( String productCode : request.getProductCodes() )\n          imgInfo.getProductCodes().add( new ProductCode( productCode ) );\n        db.commit();\n        reply.set_return( true );\n      }\n      catch ( EucalyptusCloudException e ) {\n        db.rollback();\n        reply.set_return( false );\n      }\n    }\n    return reply;\n  }","id":87419,"modified_method":"public ModifyImageAttributeResponseType ModifyImageAttribute( ModifyImageAttributeType request ) throws EucalyptusCloudException {\n    ModifyImageAttributeResponseType reply = ( ModifyImageAttributeResponseType ) request.getReply();\n\n    if ( request.getAttribute() != null )\n      request.applyAttribute();\n\n    if ( request.getProductCodes().isEmpty() ) {\n      reply.set_return( this.modifyImageInfo( request.getImageId(), request.getUserId(), request.isAdministrator(), request.getAdd(), request.getRemove() ) );\n    } else {\n      EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n      ImageInfo imgInfo = null;\n      try {\n        imgInfo = db.getUnique( new ImageInfo( request.getImageId() ) );\n        for ( String productCode : request.getProductCodes() ) {\n          ProductCode prodCode = new ProductCode( productCode );\n          if( !imgInfo.getProductCodes().contains( prodCode  ) ) {\n            imgInfo.getProductCodes().add( prodCode );\n          }\n        }\n        db.commit();\n        reply.set_return( true );\n      }\n      catch ( EucalyptusCloudException e ) {\n        db.rollback();\n        reply.set_return( false );\n      }\n    }\n    return reply;\n  }","commit_id":"9a73aa883dd643e547b2b63093c3b2692c168766","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ConfirmProductInstanceResponseType ConfirmProductInstance( ConfirmProductInstanceType request ) throws EucalyptusCloudException {\n    ConfirmProductInstanceResponseType reply = ( ConfirmProductInstanceResponseType ) request.getReply();\n    reply.set_return( false );\n    VmInstance vm = null;\n    try {\n      vm = VmInstances.getInstance().lookup( request.getInstanceId() );\n    } catch ( NoSuchElementException e ) {\n      return reply;\n    }\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n    try {\n      ImageInfo found = db.getUnique( new ImageInfo( vm.getImageInfo().getImageId() ) );\n      if ( vm.getImageInfo().getImageId().equals( found ) ) {\n        reply.set_return( true );\n      }\n    } catch ( EucalyptusCloudException e ) {\n    } finally {\n      db.commit();\n    }\n    return reply;\n  }","id":87420,"modified_method":"public ConfirmProductInstanceResponseType ConfirmProductInstance( ConfirmProductInstanceType request ) throws EucalyptusCloudException {\n    ConfirmProductInstanceResponseType reply = ( ConfirmProductInstanceResponseType ) request.getReply();\n    reply.set_return( false );\n    VmInstance vm = null;\n    try {\n      vm = VmInstances.getInstance().lookup( request.getInstanceId() );\n      EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n      try {\n        ImageInfo found = db.getUnique( new ImageInfo( vm.getImageInfo().getImageId() ) );\n        if ( found.getProductCodes().contains( new ProductCode( request.getProductCode() ) ) ) {\n          reply.set_return( true );\n          reply.setOwnerId( found.getImageOwnerId() );\n        }\n      } catch ( EucalyptusCloudException e ) {\n      } finally {\n        db.commit();\n      }\n    } catch ( NoSuchElementException e ) {}\n    return reply;\n  }","commit_id":"9a73aa883dd643e547b2b63093c3b2692c168766","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private VmImageInfo getVmImageInfo( final String walrusUrl, final ImageInfo diskInfo, final ImageInfo kernelInfo, final ImageInfo ramdiskInfo ) throws EucalyptusCloudException {\n    String diskUrl = this.getImageUrl( walrusUrl, diskInfo );\n    String kernelUrl = this.getImageUrl( walrusUrl, kernelInfo );\n    String ramdiskUrl = null;\n    if ( ramdiskInfo != null )\n      ramdiskUrl = this.getImageUrl( walrusUrl, ramdiskInfo );\n\n    //:: create the response assets now since we might not have a ramdisk anyway :://\n    VmImageInfo vmImgInfo = new VmImageInfo( diskInfo.getImageId(), kernelInfo.getImageId(), ramdiskInfo == null ? null : ramdiskInfo.getImageId(),\n                                             diskUrl, kernelUrl, ramdiskInfo == null ? null : ramdiskUrl );\n    return vmImgInfo;\n  }","id":87421,"modified_method":"private VmImageInfo getVmImageInfo( final String walrusUrl, final ImageInfo diskInfo, final ImageInfo kernelInfo, final ImageInfo ramdiskInfo, final ArrayList<String> productCodes ) throws EucalyptusCloudException {\n    String diskUrl = this.getImageUrl( walrusUrl, diskInfo );\n    String kernelUrl = this.getImageUrl( walrusUrl, kernelInfo );\n    String ramdiskUrl = null;\n    if ( ramdiskInfo != null )\n      ramdiskUrl = this.getImageUrl( walrusUrl, ramdiskInfo );\n\n    //:: create the response assets now since we might not have a ramdisk anyway :://\n    VmImageInfo vmImgInfo = new VmImageInfo( diskInfo.getImageId(), kernelInfo.getImageId(), ramdiskInfo == null ? null : ramdiskInfo.getImageId(),\n                                             diskUrl, kernelUrl, ramdiskInfo == null ? null : ramdiskUrl, productCodes );\n    return vmImgInfo;\n  }","commit_id":"9a73aa883dd643e547b2b63093c3b2692c168766","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DescribeImageAttributeResponseType DescribeImageAttribute( DescribeImageAttributeType request ) throws EucalyptusCloudException {\n    DescribeImageAttributeResponseType reply = ( DescribeImageAttributeResponseType ) request.getReply();\n    reply.setImageId( request.getImageId() );\n\n    if ( request.getAttribute() != null )\n      request.applyAttribute();\n\n    if ( request.getBlockDeviceMapping() != null )\n      throw new EucalyptusCloudException( \"image attribute: block device mappings: not implemented\" );\n\n    reply.setProductCodes( null );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n    try {\n      ImageInfo imgInfo = db.getUnique( new ImageInfo( request.getImageId() ) );\n      if ( !imgInfo.isAllowed( db.recast( UserInfo.class ).getUnique( new UserInfo( request.getUserId() ) ) ) )\n        throw new EucalyptusCloudException( \"image attribute: not authorized.\" );\n      if ( request.getKernel() != null ) {\n        reply.setKernel( imgInfo.getKernelId() );\n      } else if ( request.getRamdisk() != null ) {\n        reply.setRamdisk( imgInfo.getRamdiskId() );\n      } else if ( request.getLaunchPermission() != null ) {\n        for ( UserGroupInfo userGroup : imgInfo.getUserGroups() )\n          reply.getLaunchPermission().add( LaunchPermissionItemType.getGroup( userGroup.getName() ) );\n        for ( UserInfo user : imgInfo.getPermissions() )\n          reply.getLaunchPermission().add( LaunchPermissionItemType.getUser( user.getUserName() ) );\n      } else if ( !request.getProductCodes().isEmpty() ) {\n        for ( ProductCode p : imgInfo.getProductCodes() ) {\n          reply.getProductCodes().add( p.getValue() );\n        }\n      } else {\n        throw new EucalyptusCloudException( \"invalid image attribute request.\" );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.commit();\n      throw e;\n    }\n    return reply;\n  }","id":87422,"modified_method":"public DescribeImageAttributeResponseType DescribeImageAttribute( DescribeImageAttributeType request ) throws EucalyptusCloudException {\n    DescribeImageAttributeResponseType reply = ( DescribeImageAttributeResponseType ) request.getReply();\n    reply.setImageId( request.getImageId() );\n\n    if ( request.getAttribute() != null )\n      request.applyAttribute();\n\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n    try {\n      ImageInfo imgInfo = db.getUnique( new ImageInfo( request.getImageId() ) );\n      if ( !imgInfo.isAllowed( db.recast( UserInfo.class ).getUnique( new UserInfo( request.getUserId() ) ) ) )\n        throw new EucalyptusCloudException( \"image attribute: not authorized.\" );\n      if ( request.getKernel() != null ) {\n        reply.setRealResponse( reply.getKernel() );\n        reply.getKernel().add(imgInfo.getKernelId() );\n      } else if ( request.getRamdisk() != null ) {\n        reply.setRealResponse( reply.getRamdisk() );\n        reply.getRamdisk().add( imgInfo.getRamdiskId() );\n      } else if ( request.getLaunchPermission() != null ) {\n        reply.setRealResponse( reply.getLaunchPermission() );\n        for ( UserGroupInfo userGroup : imgInfo.getUserGroups() )\n          reply.getLaunchPermission().add( LaunchPermissionItemType.getGroup( userGroup.getName() ) );\n        for ( UserInfo user : imgInfo.getPermissions() )\n          reply.getLaunchPermission().add( LaunchPermissionItemType.getUser( user.getUserName() ) );\n      } else if ( request.getProductCodes() != null ) {\n        reply.setRealResponse( reply.getProductCodes() );\n        for ( ProductCode p : imgInfo.getProductCodes() ) {\n          reply.getProductCodes().add( p.getValue() );\n        }\n      } else if ( request.getBlockDeviceMapping() != null ) {\n        reply.setRealResponse( reply.getBlockDeviceMapping() );\n        reply.getBlockDeviceMapping().add( EMI );\n        reply.getBlockDeviceMapping().add( EPHEMERAL );\n        reply.getBlockDeviceMapping().add( SWAP );\n        reply.getBlockDeviceMapping().add( ROOT );\n      } else {\n        throw new EucalyptusCloudException( \"invalid image attribute request.\" );\n      }\n    } catch ( EucalyptusCloudException e ) {\n      db.commit();\n      throw e;\n    }\n    return reply;\n  }","commit_id":"9a73aa883dd643e547b2b63093c3b2692c168766","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    SystemConfiguration conf = EucalyptusProperties.getSystemConfiguration();\n    String walrusUrl = getStorageUrl( conf );\n\n    RunInstancesType msg = vmAllocInfo.getRequest();\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId() );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n    ImageInfo diskInfo = null;\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n    } catch ( EucalyptusCloudException e ) {\n      throw new EucalyptusCloudException( \"Failed to find kernel image: \" + msg.getImageId() );\n    }\n    UserInfo user = db.recast( UserInfo.class ).getUnique( new UserInfo( msg.getUserId() ) );\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback();\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n\n    //:: now its time to determine the ramdisk and kernel info based on: 1) user input, 2) emi specific info, 3) system defaults ::/\n    String kernelId = this.getImageInfobyId( msg.getKernelId(), diskInfo.getKernelId(), conf.getDefaultKernel() );\n    if ( kernelId == null ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n    }\n\n    String ramdiskId = this.getImageInfobyId( msg.getRamdiskId(), diskInfo.getRamdiskId(), conf.getDefaultRamdisk() );\n\n    ImageInfo kernelInfo = null;\n    try {\n      kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n    } catch ( EucalyptusCloudException e ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId() );\n    }\n    if ( !kernelInfo.isAllowed( user ) ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId() );\n    }\n    ImageInfo ramdiskInfo = null;\n    if ( ramdiskId != null ) {\n      try {\n        ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n      } catch ( EucalyptusCloudException e ) {\n        throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n      }\n      if ( !ramdiskInfo.isAllowed( user ) ) {\n        db.commit();\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId() );\n      }\n    }\n\n    this.checkStoredImage( kernelInfo );\n    this.checkStoredImage( diskInfo );\n    this.checkStoredImage( ramdiskInfo );\n\n    //:: get together the required URLs ::/\n    VmImageInfo vmImgInfo = getVmImageInfo( walrusUrl, diskInfo, kernelInfo, ramdiskInfo );\n    vmAllocInfo.setImageInfo( vmImgInfo );\n    return vmAllocInfo;\n  }","id":87423,"modified_method":"public VmAllocationInfo verify( VmAllocationInfo vmAllocInfo ) throws EucalyptusCloudException {\n    SystemConfiguration conf = EucalyptusProperties.getSystemConfiguration();\n    String walrusUrl = getStorageUrl( conf );\n\n    RunInstancesType msg = vmAllocInfo.getRequest();\n    ImageInfo searchDiskInfo = new ImageInfo( msg.getImageId() );\n    EntityWrapper<ImageInfo> db = new EntityWrapper<ImageInfo>();\n    ImageInfo diskInfo = null;\n    ArrayList<String> productCodes = Lists.newArrayList();\n    try {\n      diskInfo = db.getUnique( searchDiskInfo );\n      for( ProductCode p : diskInfo.getProductCodes() ) {\n        productCodes.add( p.getValue());\n      }\n    } catch ( EucalyptusCloudException e ) {\n      throw new EucalyptusCloudException( \"Failed to find kernel image: \" + msg.getImageId() );\n    }\n    UserInfo user = db.recast( UserInfo.class ).getUnique( new UserInfo( msg.getUserId() ) );\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.rollback();\n      throw new EucalyptusCloudException( \"You do not have permissions to run this image.\" );\n    }\n\n    //:: now its time to determine the ramdisk and kernel info based on: 1) user input, 2) emi specific info, 3) system defaults ::/\n    String kernelId = this.getImageInfobyId( msg.getKernelId(), diskInfo.getKernelId(), conf.getDefaultKernel() );\n    if ( kernelId == null ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"Unable to determine required kernel image.\" );\n    }\n\n    String ramdiskId = this.getImageInfobyId( msg.getRamdiskId(), diskInfo.getRamdiskId(), conf.getDefaultRamdisk() );\n\n    ImageInfo kernelInfo = null;\n    try {\n      kernelInfo = db.getUnique( new ImageInfo( kernelId ) );\n    } catch ( EucalyptusCloudException e ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"Failed to find kernel image: \" + kernelId );\n    }\n    if ( !diskInfo.isAllowed( user ) ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + diskInfo.getImageId() );\n    }\n    if ( !kernelInfo.isAllowed( user ) ) {\n      db.commit();\n      throw new EucalyptusCloudException( \"You do not have permission to launch: \" + kernelInfo.getImageId() );\n    }\n    ImageInfo ramdiskInfo = null;\n    if ( ramdiskId != null ) {\n      try {\n        ramdiskInfo = db.getUnique( new ImageInfo( ramdiskId ) );\n      } catch ( EucalyptusCloudException e ) {\n        throw new EucalyptusCloudException( \"Failed to find ramdisk image: \" + ramdiskId );\n      }\n      if ( !ramdiskInfo.isAllowed( user ) ) {\n        db.commit();\n        throw new EucalyptusCloudException( \"You do not have permission to launch: \" + ramdiskInfo.getImageId() );\n      }\n    }\n\n    this.checkStoredImage( kernelInfo );\n    this.checkStoredImage( diskInfo );\n    this.checkStoredImage( ramdiskInfo );\n\n    //:: get together the required URLs ::/\n    VmImageInfo vmImgInfo = getVmImageInfo( walrusUrl, diskInfo, kernelInfo, ramdiskInfo, productCodes );\n    vmAllocInfo.setImageInfo( vmImgInfo );\n    return vmAllocInfo;\n  }","commit_id":"9a73aa883dd643e547b2b63093c3b2692c168766","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private Pair.NonNull<T,V> findNextClassInQueue(@NotNull HashSetQueue.PositionalIterator.IteratorPosition<T> position) {\n    // find the first class which is fit (not anonymous and not final and retrievable from PsiAnchor) and not already processed (flag PROCESSING_SUBCLASSES_STATUS in class user data)\n    // couldn't call iterator.next() until class is processed, so use position.peek()/position.next() which don't advance iterator\n    while (position != null) {\n      ProgressManager.checkCanceled();\n      T anchor = position.peek();\n      V value = myConvertor.fun(anchor);\n      boolean isAccepted = value != null && myApplicableFilter.apply(value);\n\n      if (isAccepted && !classesProcessed.contains(anchor) && classesBeingProcessed.add(anchor)) {\n        return Pair.createNonNull(anchor, value);\n      }\n      // the candidate is already being processed in the other thread, try the next one (not advancing iterator!)\n      position = position.next();\n    }\n    return null;\n  }","id":87424,"modified_method":"private Pair.NonNull<T,V> findNextClassInQueue(@NotNull HashSetQueue.PositionalIterator.IteratorPosition<T> position) {\n    // find the first class suitable for analyzing inheritors of (not anonymous and not final and retrievable from PsiAnchor) and not already processed or being processed (by other thread)\n    // couldn't call iterator.next() until class is processed, so use position.peek()/position.next() which don't advance iterator\n    while (position != null) {\n      ProgressManager.checkCanceled();\n      T anchor = position.peek();\n      if (!classesProcessed.contains(anchor) && !classesBeingProcessed.contains(anchor)) {\n        V value = myAnchorToValueConvertor.fun(anchor);\n        boolean isAccepted = value != null && myApplicableForGenerationFilter.apply(value);\n        if (isAccepted) {\n          return Pair.createNonNull(anchor, value);\n        }\n        classesProcessed.add(anchor);\n      }\n      // the candidate is already being processed in the other thread, try the next one (not advancing iterator!)\n      position = position.next();\n    }\n    return null;\n  }","commit_id":"be3519d14539d22dfe6d4054e5532469ced2943a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"LazyConcurrentCollection(@NotNull T seedElement,\n                           @NotNull Function<T, V> convertor,\n                           @NotNull Predicate<? super V> applicableFilter,\n                           @NotNull MoreElementsGenerator<T, V> generator) {\n    subClasses = new HashSetQueue<>();\n    subClasses.add(seedElement);\n    myConvertor = convertor;\n    myGenerator = generator;\n    myApplicableFilter = applicableFilter;\n    candidatesToFindSubclassesIterator = subClasses.iterator();\n  }","id":87425,"modified_method":"LazyConcurrentCollection(@NotNull T seedElement,\n                           @NotNull Function<T, V> convertor,\n                           @NotNull Predicate<? super V> applicableForGenerationFilter,\n                           @NotNull MoreElementsGenerator<T, V> generator) {\n    subClasses = new HashSetQueue<>();\n    subClasses.add(seedElement);\n    myAnchorToValueConvertor = convertor;\n    myGenerator = generator;\n    myApplicableForGenerationFilter = applicableForGenerationFilter;\n    candidatesToFindSubclassesIterator = subClasses.iterator();\n  }","commit_id":"be3519d14539d22dfe6d4054e5532469ced2943a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void advanceIteratorOnSuccess() {\n    HashSetQueue.PositionalIterator.IteratorPosition<T> position = candidatesToFindSubclassesIterator.position().next();\n    while (position != null) {\n      T next = position.peek();\n      if (classesProcessed.contains(next)) {\n        candidatesToFindSubclassesIterator.next();\n        classesProcessed.remove(next);\n      }\n      else {\n        break;\n      }\n      position = position.next();\n    }\n  }","id":87426,"modified_method":"private void advanceIteratorOnSuccess() {\n    while (candidatesToFindSubclassesIterator.hasNext()) {\n      T next = candidatesToFindSubclassesIterator.position().next().peek();\n      boolean removed = classesProcessed.remove(next);\n      if (removed) {\n        candidatesToFindSubclassesIterator.next();\n      }\n      else {\n        break;\n      }\n    }\n  }","commit_id":"be3519d14539d22dfe6d4054e5532469ced2943a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processMoreSubclasses(@NotNull Iterator<T> subClassIterator) {\n    while (true) {\n      ProgressManager.checkCanceled();\n\n      Pair.NonNull<T,V> pair =\n        ApplicationManager.getApplication().runReadAction(new Computable<Pair.NonNull<T,V>>() {\n          @Override\n          public Pair.NonNull<T,V> compute() {\n            synchronized (lock) {\n              // Find the classes in subClasses collection to operate on\n              // (without advancing the candidatesToFindSubclassesIterator iterator - it will be moved after the class successfully handled - to protect against PCE, INRE, etc)\n              // The found class will be marked as being analyzed - placed in classesBeingProcessed collection\n              HashSetQueue.PositionalIterator.IteratorPosition<T> startPosition = candidatesToFindSubclassesIterator.position().next();\n              Pair.NonNull<T,V> pair = startPosition == null ? null : findNextClassInQueue(startPosition);\n              if (pair != null) {\n                currentlyProcessingClasses.down();\n              }\n              return pair;\n            }\n          }\n        });\n      if (pair == null) {\n        // no candidates left in queue, exit\n        // but first, wait for other threads to process their candidates\n        break;\n      }\n\n      V candidate = pair.getSecond();\n      T anchor = pair.getFirst();\n      try {\n        myGenerator.generateMoreElementsFor(candidate, generatedElement -> {\n          synchronized (lock) {\n            subClasses.add(generatedElement);\n          }\n        });\n      }\n      finally {\n        currentlyProcessingClasses.up();\n      }\n\n      synchronized (lock) {\n        classesBeingProcessed.remove(anchor);\n        classesProcessed.add(anchor);\n        advanceIteratorOnSuccess();\n        if (subClassIterator.hasNext()) {\n          // we've added something to subClasses so we can return and the iterator can move forward at least once;\n          // more elements will be added on the subsequent call to .next()\n          return;\n        }\n      }\n    }\n\n    // Found nothing, have to wait for other threads because:\n    // The first thread comes and takes a class off the queue to search for inheritors,\n    // the second thread comes and sees there is no classes in the queue.\n    // The second thread should not return nothing, it should wait for the first thread to finish.\n    //\n    // Wait within managedBlock to signal FJP this thread is locked (to avoid thread starvation and deadlocks)\n    try {\n      ForkJoinPool.managedBlock(new ForkJoinPool.ManagedBlocker() {\n        @Override\n        public boolean block() throws InterruptedException {\n          currentlyProcessingClasses.waitFor(); // wait until other threads process their classes before giving up\n          return isReleasable();\n        }\n\n        @Override\n        public boolean isReleasable() {\n          synchronized (lock) {\n            return !currentlyProcessingClasses.isDown() || subClassIterator.hasNext();\n          }\n        }\n      });\n    }\n    catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":87427,"modified_method":"private boolean processMoreSubclasses(@NotNull Iterator<T> subClassIterator) {\n    while (true) {\n      ProgressManager.checkCanceled();\n\n      Pair.NonNull<T,V> pair =\n        ApplicationManager.getApplication().runReadAction((Computable<Pair.NonNull<T,V>>)() -> {\n          synchronized (lock) {\n            // Find the classes in subClasses collection to operate on\n            // (without advancing the candidatesToFindSubclassesIterator iterator - it will be moved after the class successfully handled - to protect against PCE, INRE, etc)\n            // The found class will be marked as being analyzed - placed in classesBeingProcessed collection\n            HashSetQueue.PositionalIterator.IteratorPosition<T> startPosition = candidatesToFindSubclassesIterator.position().next();\n            Pair.NonNull<T,V> next = startPosition == null ? null : findNextClassInQueue(startPosition);\n            if (next != null) {\n              currentlyProcessingClasses.down();\n              classesBeingProcessed.add(next.getFirst());\n            }\n            return next;\n          }\n        });\n      if (pair == null) {\n        // no candidates left in queue, exit\n        // but first, wait for other threads to process their candidates\n        synchronized (lock) {\n          advanceIteratorOnSuccess(); // to skip unsuitable classes like final etc from the queue\n          if (subClassIterator.hasNext()) {\n            return true;\n          }\n        }\n\n        boolean producedSomething = waitForOtherThreadsToFinishProcessing(subClassIterator);\n        if (producedSomething) {\n          return true;\n        }\n\n        // aaaaaaaa! Other threads were unable to produce anything. That can be because:\n        // - the whole queue has been processed. => exit, return false\n        // - the other thread has been interrupted. => check the queue again to pickup the work it dropped.\n        synchronized (lock) {\n          advanceIteratorOnSuccess(); // to skip unsuitable classes like final etc from the queue\n          if (!candidatesToFindSubclassesIterator.hasNext()) {\n            return false;\n          }\n        }\n\n        continue; // check again\n      }\n\n      V candidate = pair.getSecond();\n      T anchor = pair.getFirst();\n      try {\n        myGenerator.generateMoreElementsFor(candidate, generatedElement -> {\n          synchronized (lock) {\n            subClasses.add(generatedElement);\n          }\n        });\n        synchronized (lock) {\n          classesProcessed.add(anchor);\n          advanceIteratorOnSuccess();\n          if (subClassIterator.hasNext()) {\n            // we've added something to subClasses so we can return and the iterator can move forward at least once;\n            // more elements will be added on the subsequent call to .next()\n            return true;\n          }\n        }\n      }\n      finally {\n        synchronized (lock) {\n          classesBeingProcessed.remove(anchor);\n          currentlyProcessingClasses.up();\n        }\n      }\n    }\n  }","commit_id":"be3519d14539d22dfe6d4054e5532469ced2943a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Iterator<V> iterator() {\n    return new Iterator<V>() {\n      private final Iterator<T> subClassIterator = subClasses.iterator(); // guarded by lock\n      {\n        synchronized (lock) {\n          subClassIterator.next(); //skip the baseClass which stored in the subClasses first element\n        }\n      }\n      @Override\n      public boolean hasNext() {\n        synchronized (lock) {\n          if (subClassIterator.hasNext()) return true;\n        }\n\n        processMoreSubclasses(subClassIterator);\n\n        synchronized (lock) {\n          return subClassIterator.hasNext();\n        }\n      }\n\n      @Override\n      public V next() {\n        T next;\n        synchronized (lock) {\n          next = subClassIterator.next();\n        }\n        return myConvertor.fun(next);\n      }\n    };\n  }","id":87428,"modified_method":"@NotNull\n  @Override\n  public Iterator<V> iterator() {\n    return new Iterator<V>() {\n      private final Iterator<T> subClassIterator = subClasses.iterator(); // guarded by lock\n      {\n        synchronized (lock) {\n          subClassIterator.next(); //skip the baseClass which stored in the subClasses first element\n        }\n      }\n      @Override\n      public boolean hasNext() {\n        synchronized (lock) {\n          if (subClassIterator.hasNext()) return true;\n        }\n\n        processMoreSubclasses(subClassIterator);\n\n        synchronized (lock) {\n          return subClassIterator.hasNext();\n        }\n      }\n\n      @Override\n      public V next() {\n        T next;\n        synchronized (lock) {\n          next = subClassIterator.next();\n        }\n        return myAnchorToValueConvertor.fun(next);\n      }\n    };\n  }","commit_id":"be3519d14539d22dfe6d4054e5532469ced2943a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    IdeaPluginDescriptor[] selection = getPluginTable().getSelectedObjects();\n\n    if (userConfirm(selection)) {\n      ArrayList<PluginNode> list = new ArrayList<PluginNode>();\n      for (IdeaPluginDescriptor descr : selection) {\n        PluginNode pluginNode = null;\n        if (descr instanceof PluginNode) {\n          pluginNode = (PluginNode)descr;\n        }\n        else if (descr instanceof IdeaPluginDescriptorImpl) {\n          pluginNode = new PluginNode(descr.getPluginId());\n          pluginNode.setName(descr.getName());\n          pluginNode.setDepends(Arrays.asList(descr.getDependentPluginIds()), descr.getOptionalDependentPluginIds());\n          pluginNode.setSize(\"-1\");\n        }\n\n        if (pluginNode != null) {\n          list.add(pluginNode);\n        }\n      }\n      try {\n        if (PluginManagerMain.downloadPlugins(list, host.getPluginsModel().view)) {\n          for (PluginNode pluginNode : list) {\n            PluginManagerUISettings.getInstance().myInstalledPlugins.add(pluginNode.getPluginId().getIdString());\n          }\n          installed.getPluginsModel().updatePluginsList(new ArrayList<IdeaPluginDescriptor>(list));\n          installed.setRequireShutdown(true);\n        }\n      }\n      catch (IOException e1) {\n        PluginManagerMain.LOG.error(e1);\n        IOExceptionDialog.showErrorDialog(IdeBundle.message(\"action.download.and.install.plugin\"), IdeBundle.message(\"error.plugin.download.failed\"));\n      }\n      getPluginTable().updateUI();\n    }\n  }","id":87429,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    IdeaPluginDescriptor[] selection = getPluginTable().getSelectedObjects();\n\n    if (userConfirm(selection)) {\n      ArrayList<PluginNode> list = new ArrayList<PluginNode>();\n      for (IdeaPluginDescriptor descr : selection) {\n        PluginNode pluginNode = null;\n        if (descr instanceof PluginNode) {\n          pluginNode = (PluginNode)descr;\n        }\n        else if (descr instanceof IdeaPluginDescriptorImpl) {\n          pluginNode = new PluginNode(descr.getPluginId());\n          pluginNode.setName(descr.getName());\n          pluginNode.setDepends(Arrays.asList(descr.getDependentPluginIds()), descr.getOptionalDependentPluginIds());\n          pluginNode.setSize(\"-1\");\n        }\n\n        if (pluginNode != null) {\n          list.add(pluginNode);\n        }\n      }\n      try {\n        if (PluginManagerMain.downloadPlugins(list, host.getPluginsModel().view)) {\n          for (PluginNode pluginNode : list) {\n            final String idString = pluginNode.getPluginId().getIdString();\n            if (!PluginManagerUISettings.getInstance().myInstalledPlugins.contains(idString)) {\n              PluginManagerUISettings.getInstance().myInstalledPlugins.add(idString);\n            }\n          }\n          installed.getPluginsModel().updatePluginsList(new ArrayList<IdeaPluginDescriptor>(list));\n          installed.setRequireShutdown(true);\n        }\n      }\n      catch (IOException e1) {\n        PluginManagerMain.LOG.error(e1);\n        IOExceptionDialog.showErrorDialog(IdeBundle.message(\"action.download.and.install.plugin\"), IdeBundle.message(\"error.plugin.download.failed\"));\n      }\n      getPluginTable().updateUI();\n    }\n  }","commit_id":"1cf1290c618c651723885fed5937e2c9692b35b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void updateExistingPluginInfo(IdeaPluginDescriptor descr, IdeaPluginDescriptor existing) {\n    int state = StringUtil.compareVersionNumbers(descr.getVersion(), existing.getVersion());\n    final PluginId pluginId = existing.getPluginId();\n    final String idString = pluginId.getIdString();\n    final PluginManagerUISettings updateSettings = PluginManagerUISettings.getInstance();\n    if (state > 0 && !PluginManager.isIncompatible(descr) && !updatedPlugins.contains(descr.getPluginId())) {\n      NewVersions2Plugins.put(pluginId, 1);\n      if (!updateSettings.myOutdatedPlugins.contains(idString)) {\n        updateSettings.myOutdatedPlugins.add(idString);\n      }\n\n      final IdeaPluginDescriptorImpl plugin = (IdeaPluginDescriptorImpl)existing;\n      plugin.setDownloadsCount(descr.getDownloads());\n      plugin.setVendor(descr.getVendor());\n      plugin.setVendorEmail(descr.getVendorEmail());\n      plugin.setVendorUrl(descr.getVendorUrl());\n      plugin.setUrl(descr.getUrl());\n\n    } else {\n      updateSettings.myOutdatedPlugins.remove(idString);\n      if (NewVersions2Plugins.remove(pluginId) != null) {\n        updatedPlugins.add(pluginId);\n      }\n    }\n  }","id":87430,"modified_method":"private static void updateExistingPluginInfo(IdeaPluginDescriptor descr, IdeaPluginDescriptor existing) {\n    int state = StringUtil.compareVersionNumbers(descr.getVersion(), existing.getVersion());\n    final PluginId pluginId = existing.getPluginId();\n    final String idString = pluginId.getIdString();\n    final JDOMExternalizableStringList installedPlugins = PluginManagerUISettings.getInstance().myInstalledPlugins;\n    if (!installedPlugins.contains(idString)){\n      installedPlugins.add(idString);\n    }\n    final PluginManagerUISettings updateSettings = PluginManagerUISettings.getInstance();\n    if (state > 0 && !PluginManager.isIncompatible(descr) && !updatedPlugins.contains(descr.getPluginId())) {\n      NewVersions2Plugins.put(pluginId, 1);\n      if (!updateSettings.myOutdatedPlugins.contains(idString)) {\n        updateSettings.myOutdatedPlugins.add(idString);\n      }\n\n      final IdeaPluginDescriptorImpl plugin = (IdeaPluginDescriptorImpl)existing;\n      plugin.setDownloadsCount(descr.getDownloads());\n      plugin.setVendor(descr.getVendor());\n      plugin.setVendorEmail(descr.getVendorEmail());\n      plugin.setVendorUrl(descr.getVendorUrl());\n      plugin.setUrl(descr.getUrl());\n\n    } else {\n      updateSettings.myOutdatedPlugins.remove(idString);\n      if (NewVersions2Plugins.remove(pluginId) != null) {\n        updatedPlugins.add(pluginId);\n      }\n    }\n  }","commit_id":"1cf1290c618c651723885fed5937e2c9692b35b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String transform(\n\t\t\tMap tokens, String languageId, String xml, String script,\n\t\t\tString langType)\n\t\tthrows TransformException, UnsupportedEncodingException {\n\n\t\t// Setup Listeners\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Language \" + languageId);\n\n\t\t\tString tokensString = PropertiesUtil.list(tokens);\n\n\t\t\t_log.debug(\"Tokens\\n\" + tokensString);\n\n\t\t\t_log.debug(xml);\n\t\t}\n\n\t\tList listenersList = new ArrayList();\n\n\t\tString[] listeners = PropsUtil.getArray(\n\t\t\tPropsUtil.JOURNAL_TRANSFORMER_LISTENER);\n\n\t\tfor (int i = 0; i < listeners.length; i++) {\n\t\t\tTransformerListener listener = null;\n\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Instantiate listener \" + listeners[i]);\n\t\t\t\t}\n\n\t\t\t\tboolean templateDriven = Validator.isNotNull(langType);\n\n\t\t\t\tlistener = (TransformerListener)Class.forName(\n\t\t\t\t\tlisteners[i]).newInstance();\n\n\t\t\t\tlistener.setTemplateDriven(templateDriven);\n\t\t\t\tlistener.setLanguageId(languageId);\n\t\t\t\tlistener.setTokens(tokens);\n\n\t\t\t\tlistenersList.add(listener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\t// Modify XML\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"XML before listener\\n\" + xml);\n\t\t\t}\n\n\t\t\tif (listener != null) {\n\t\t\t\txml = listener.onXml(xml);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"XML after listener\\n\" + xml);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Modify script\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Transform script before listener\\n\" + script);\n\t\t\t}\n\n\t\t\tif (listener != null) {\n\t\t\t\tscript = listener.onScript(script);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Transform script after listener\\n\" + script);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Transform\n\n\t\tString output = null;\n\n\t\tif (Validator.isNull(langType)) {\n\t\t\toutput = xml;\n\t\t}\n\t\telse if (langType.equals(JournalTemplateImpl.LANG_TYPE_VM)) {\n\t\t\toutput = JournalVmUtil.transform(tokens, languageId, xml, script);\n\t\t}\n\t\telse if (langType.equals(JournalTemplateImpl.LANG_TYPE_XSL)) {\n\t\t\toutput = JournalXslUtil.transform(tokens, languageId, xml, script);\n\t\t}\n\n\t\t// Postprocess output\n\n\t\tfor (int i = 0; i < listenersList.size(); i++) {\n\t\t\tTransformerListener listener =\n\t\t\t\t(TransformerListener)listenersList.get(i);\n\n\t\t\t// Modify output\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Output before listener\\n\" + output);\n\t\t\t}\n\n\t\t\toutput = listener.onOutput(output);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Output after listener\\n\" + output);\n\t\t\t}\n\t\t}\n\n\t\treturn output;\n\t}","id":87431,"modified_method":"public static String transform(\n\t\t\tMap tokens, String languageId, String xml, String script,\n\t\t\tString langType)\n\t\tthrows TransformException, UnsupportedEncodingException {\n\n\t\t// Setup Listeners\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Language \" + languageId);\n\n\t\t\tString tokensString = PropertiesUtil.list(tokens);\n\n\t\t\t_log.debug(\"Tokens\\n\" + tokensString);\n\n\t\t\t_log.debug(\"XML before listeners\\n\" + xml);\n\t\t}\n\n\t\tList listenersList = new ArrayList();\n\n\t\tString[] listeners = PropsUtil.getArray(\n\t\t\tPropsUtil.JOURNAL_TRANSFORMER_LISTENER);\n\n\t\tfor (int i = 0; i < listeners.length; i++) {\n\t\t\tTransformerListener listener = null;\n\n\t\t\ttry {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Instantiate listener \" + listeners[i]);\n\t\t\t\t}\n\n\t\t\t\tboolean templateDriven = Validator.isNotNull(langType);\n\n\t\t\t\tlistener = (TransformerListener)Class.forName(\n\t\t\t\t\tlisteners[i]).newInstance();\n\n\t\t\t\tlistener.setTemplateDriven(templateDriven);\n\t\t\t\tlistener.setLanguageId(languageId);\n\t\t\t\tlistener.setTokens(tokens);\n\n\t\t\t\tlistenersList.add(listener);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\t// Modify XML\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"XML before listener\\n\" + xml);\n\t\t\t}\n\n\t\t\tif (listener != null) {\n\t\t\t\txml = listener.onXml(xml);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"XML after listener\\n\" + xml);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Modify script\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Transform script before listener\\n\" + script);\n\t\t\t}\n\n\t\t\tif (listener != null) {\n\t\t\t\tscript = listener.onScript(script);\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Transform script after listener\\n\" + script);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Transform\n\n\t\tString output = null;\n\n\t\tif (Validator.isNull(langType)) {\n\t\t\toutput = xml;\n\t\t}\n\t\telse if (langType.equals(JournalTemplateImpl.LANG_TYPE_VM)) {\n\t\t\toutput = JournalVmUtil.transform(tokens, languageId, xml, script);\n\t\t}\n\t\telse if (langType.equals(JournalTemplateImpl.LANG_TYPE_XSL)) {\n\t\t\toutput = JournalXslUtil.transform(tokens, languageId, xml, script);\n\t\t}\n\n\t\t// Postprocess output\n\n\t\tfor (int i = 0; i < listenersList.size(); i++) {\n\t\t\tTransformerListener listener =\n\t\t\t\t(TransformerListener)listenersList.get(i);\n\n\t\t\t// Modify output\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Output before listener\\n\" + output);\n\t\t\t}\n\n\t\t\toutput = listener.onOutput(output);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Output after listener\\n\" + output);\n\t\t\t}\n\t\t}\n\n\t\treturn output;\n\t}","commit_id":"dd0992345bede5e3cad9ed5688d06fb2e6065f28","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setLocation(Throwable exception) {\n\t\tSourceLocator locator = null;\n\t\tThrowable cause = exception;\n\t\tThrowable realCause = null;\n\n\t\tdo {\n\t\t\tif(cause instanceof SAXParseException) {\n\t\t\t\tlocator = new SAXSourceLocator((SAXParseException)cause);\n\t\t\t\trealCause = cause;\n\t\t\t}\n\t\t\telse if (cause instanceof TransformerException) {\n\t\t\t\tSourceLocator causeLocator =\n\t\t\t\t\t((TransformerException)cause).getLocator();\n\n\t\t\t\tif(causeLocator != null) {\n\t\t\t\t\tlocator = causeLocator;\n\t\t\t\t\trealCause = cause;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(cause instanceof TransformerException)\n\t\t\t\tcause = ((TransformerException)cause).getCause();\n\t\t\telse if(cause instanceof WrappedRuntimeException)\n\t\t\t\tcause = ((WrappedRuntimeException)cause).getException();\n\t\t\telse if(cause instanceof SAXException)\n\t\t\t\tcause = ((SAXException)cause).getException();\n\t\t\telse\n\t\t\t\tcause = null;\n\t\t}\n\t\twhile(cause != null);\n\n\t\t_message = realCause.getMessage();\n\n\t\tif(null != locator) {\n\t\t\t_location = XMLMessages.createXMLMessage(\"line\", null) +\n\t\t\t\tlocator.getLineNumber() + \"; \" +\n\t\t\t\t\tXMLMessages.createXMLMessage(\"column\", null) +\n\t\t\t\t\t\tlocator.getColumnNumber() + \"; \";\n\t\t}\n\t\telse {\n\t\t\t_location = \"\";\n\t\t}\n\t}","id":87432,"modified_method":"public void setLocation(Throwable exception) {\n\t\tSourceLocator locator = null;\n\t\tThrowable cause = exception;\n\t\tThrowable rootCause = null;\n\n\t\twhile (cause != null) {\n\t\t\tif (cause instanceof SAXParseException) {\n\t\t\t\tlocator = new SAXSourceLocator((SAXParseException)cause);\n\t\t\t\trootCause = cause;\n\t\t\t}\n\t\t\telse if (cause instanceof TransformerException) {\n\t\t\t\tSourceLocator causeLocator =\n\t\t\t\t\t((TransformerException)cause).getLocator();\n\n\t\t\t\tif (causeLocator != null) {\n\t\t\t\t\tlocator = causeLocator;\n\t\t\t\t\trootCause = cause;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cause instanceof TransformerException) {\n\t\t\t\tcause = ((TransformerException)cause).getCause();\n\t\t\t}\n\t\t\telse if (cause instanceof WrappedRuntimeException) {\n\t\t\t\tcause = ((WrappedRuntimeException)cause).getException();\n\t\t\t}\n\t\t\telse if (cause instanceof SAXException) {\n\t\t\t\tcause = ((SAXException)cause).getException();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcause = null;\n\t\t\t}\n\t\t}\n\n\t\t_message = rootCause.getMessage();\n\n\t\tif (locator != null) {\n\t\t\tStringMaker sm = new StringMaker();\n\n\t\t\tsm.append(XMLMessages.createXMLMessage(\"line\", null));\n\t\t\tsm.append(locator.getLineNumber());\n\t\t\tsm.append(\"; \");\n\t\t\tsm.append(XMLMessages.createXMLMessage(\"column\", null));\n\t\t\tsm.append(locator.getColumnNumber());\n\t\t\tsm.append(\"; \");\n\n\t\t\t_location = sm.toString();\n\t\t}\n\t\telse {\n\t\t\t_location = StringPool.BLANK;\n\t\t}\n\t}","commit_id":"dd0992345bede5e3cad9ed5688d06fb2e6065f28","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tUploadServletRequest uploadReq = null;\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tlong groupId = ParamUtil.getLong(req, \"groupId\");\n\t\t\tString articleId = ParamUtil.getString(req, \"articleId\");\n\t\t\tdouble version = ParamUtil.getDouble(\n\t\t\t\treq, \"version\", JournalArticleImpl.DEFAULT_VERSION);\n\n\t\t\tString languageId = LanguageUtil.getLanguageId(req);\n\n\t\t\tString output = null;\n\n\t\t\tif (cmd.equals(Constants.PREVIEW)) {\n\t\t\t\tuploadReq = new UploadServletRequest(req);\n\n\t\t\t\tString title = ParamUtil.getString(uploadReq, \"title\");\n\t\t\t\tString description = ParamUtil.getString(\n\t\t\t\t\tuploadReq, \"description\");\n\n\t\t\t\tDate now = new Date();\n\n\t\t\t\tDate createDate = now;\n\t\t\t\tDate modifiedDate = now;\n\t\t\t\tDate displayDate = now;\n\n\t\t\t\tUser user = PortalUtil.getUser(uploadReq);\n\n\t\t\t\tString xml = ParamUtil.getString(uploadReq, \"xml\");\n\n\t\t\t\tSAXReader reader = new SAXReader();\n\n\t\t\t\tDocument doc = reader.read(new StringReader(xml));\n\n\t\t\t\tElement root = doc.getRootElement();\n\n\t\t\t\tString previewArticleId =\n\t\t\t\t\t\"PREVIEW_\" +\n\t\t\t\t\tPwdGenerator.getPassword(PwdGenerator.KEY3, 10);\n\n\t\t\t\tformat(\n\t\t\t\t\tgroupId, articleId, version, previewArticleId, root,\n\t\t\t\t\tuploadReq);\n\n\t\t\t\tMap tokens = JournalUtil.getTokens(groupId, themeDisplay);\n\n\t\t\t\ttokens.put(\"article_resource_pk\", \"-1\");\n\n\t\t\t\tJournalArticle article = new JournalArticleImpl();\n\n\t\t\t\tarticle.setUserId(user.getUserId());\n\t\t\t\tarticle.setCreateDate(createDate);\n\t\t\t\tarticle.setModifiedDate(modifiedDate);\n\t\t\t\tarticle.setArticleId(articleId);\n\t\t\t\tarticle.setVersion(version);\n\t\t\t\tarticle.setTitle(title);\n\t\t\t\tarticle.setDescription(description);\n\t\t\t\tarticle.setDisplayDate(displayDate);\n\n\t\t\t\tJournalUtil.addAllReservedEls(root, tokens, article);\n\n\t\t\t\txml = JournalUtil.formatXML(doc);\n\n\t\t\t\tString templateId = ParamUtil.getString(\n\t\t\t\t\tuploadReq, \"templateId\");\n\n\t\t\t\tJournalTemplate template =\n\t\t\t\t\tJournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\t\tgroupId, templateId);\n\n\t\t\t\tString langType = template.getLangType();\n\t\t\t\tString script = template.getXsl();\n\n\t\t\t\ttry {\n\t\t\t\t\toutput = JournalUtil.transform(\n\t\t\t\t\t\ttokens, languageId, xml, script, langType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ee) {\n\t\t\t\t\t_log.error(ee, ee);\n\n\t\t\t\t\tPortalUtil.sendError(\n\t\t\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR, ee, req,\n\t\t\t\t\t\tres);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput = JournalArticleServiceUtil.getArticleContent(\n\t\t\t\t\tgroupId, articleId, version, languageId, themeDisplay);\n\t\t\t}\n\n\t\t\treq.setAttribute(WebKeys.JOURNAL_ARTICLE_CONTENT, output);\n\n\t\t\tif (output.startsWith(\"<?xml \")) {\n\t\t\t\treturn mapping.findForward(\n\t\t\t\t\t\"portlet.journal.raw_article_content\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn mapping.findForward(\n\t\t\t\t\t\"portlet.journal.view_article_content\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treq.setAttribute(PageContext.EXCEPTION, e);\n\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_ERROR);\n\t\t}\n\t\tfinally {\n\t\t\tif (uploadReq != null) {\n\t\t\t\tuploadReq.cleanUp();\n\t\t\t}\n\t\t}\n\t}","id":87433,"modified_method":"public ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tUploadServletRequest uploadReq = null;\n\n\t\ttry {\n\t\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay)req.getAttribute(WebKeys.THEME_DISPLAY);\n\n\t\t\tlong groupId = ParamUtil.getLong(req, \"groupId\");\n\t\t\tString articleId = ParamUtil.getString(req, \"articleId\");\n\t\t\tdouble version = ParamUtil.getDouble(\n\t\t\t\treq, \"version\", JournalArticleImpl.DEFAULT_VERSION);\n\n\t\t\tString languageId = LanguageUtil.getLanguageId(req);\n\n\t\t\tString output = null;\n\n\t\t\tif (cmd.equals(Constants.PREVIEW)) {\n\t\t\t\tuploadReq = new UploadServletRequest(req);\n\n\t\t\t\tString title = ParamUtil.getString(uploadReq, \"title\");\n\t\t\t\tString description = ParamUtil.getString(\n\t\t\t\t\tuploadReq, \"description\");\n\n\t\t\t\tDate now = new Date();\n\n\t\t\t\tDate createDate = now;\n\t\t\t\tDate modifiedDate = now;\n\t\t\t\tDate displayDate = now;\n\n\t\t\t\tUser user = PortalUtil.getUser(uploadReq);\n\n\t\t\t\tString xml = ParamUtil.getString(uploadReq, \"xml\");\n\n\t\t\t\tSAXReader reader = new SAXReader();\n\n\t\t\t\tDocument doc = reader.read(new StringReader(xml));\n\n\t\t\t\tElement root = doc.getRootElement();\n\n\t\t\t\tString previewArticleId =\n\t\t\t\t\t\"PREVIEW_\" +\n\t\t\t\t\tPwdGenerator.getPassword(PwdGenerator.KEY3, 10);\n\n\t\t\t\tformat(\n\t\t\t\t\tgroupId, articleId, version, previewArticleId, root,\n\t\t\t\t\tuploadReq);\n\n\t\t\t\tMap tokens = JournalUtil.getTokens(groupId, themeDisplay);\n\n\t\t\t\ttokens.put(\"article_resource_pk\", \"-1\");\n\n\t\t\t\tJournalArticle article = new JournalArticleImpl();\n\n\t\t\t\tarticle.setUserId(user.getUserId());\n\t\t\t\tarticle.setCreateDate(createDate);\n\t\t\t\tarticle.setModifiedDate(modifiedDate);\n\t\t\t\tarticle.setArticleId(articleId);\n\t\t\t\tarticle.setVersion(version);\n\t\t\t\tarticle.setTitle(title);\n\t\t\t\tarticle.setDescription(description);\n\t\t\t\tarticle.setDisplayDate(displayDate);\n\n\t\t\t\tJournalUtil.addAllReservedEls(root, tokens, article);\n\n\t\t\t\txml = JournalUtil.formatXML(doc);\n\n\t\t\t\tString templateId = ParamUtil.getString(\n\t\t\t\t\tuploadReq, \"templateId\");\n\n\t\t\t\tJournalTemplate template =\n\t\t\t\t\tJournalTemplateLocalServiceUtil.getTemplate(\n\t\t\t\t\t\tgroupId, templateId);\n\n\t\t\t\tString langType = template.getLangType();\n\t\t\t\tString script = template.getXsl();\n\n\t\t\t\ttry {\n\t\t\t\t\toutput = JournalUtil.transform(\n\t\t\t\t\t\ttokens, languageId, xml, script, langType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e1) {\n\t\t\t\t\t_log.error(e1, e1);\n\n\t\t\t\t\tPortalUtil.sendError(\n\t\t\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR, e1, req,\n\t\t\t\t\t\tres);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput = JournalArticleServiceUtil.getArticleContent(\n\t\t\t\t\tgroupId, articleId, version, languageId, themeDisplay);\n\t\t\t}\n\n\t\t\treq.setAttribute(WebKeys.JOURNAL_ARTICLE_CONTENT, output);\n\n\t\t\tif (output.startsWith(\"<?xml \")) {\n\t\t\t\treturn mapping.findForward(\n\t\t\t\t\t\"portlet.journal.raw_article_content\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn mapping.findForward(\n\t\t\t\t\t\"portlet.journal.view_article_content\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e2) {\n\t\t\treq.setAttribute(PageContext.EXCEPTION, e2);\n\n\t\t\treturn mapping.findForward(ActionConstants.COMMON_ERROR);\n\t\t}\n\t\tfinally {\n\t\t\tif (uploadReq != null) {\n\t\t\t\tuploadReq.cleanUp();\n\t\t\t}\n\t\t}\n\t}","commit_id":"dd0992345bede5e3cad9ed5688d06fb2e6065f28","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void fatalError(SAXParseException e) throws SAXException {\n        // log and re-throw exception\n        log.error(\"fatal error encountered at line: \" + e.getLineNumber()\n                + \", column: \" + e.getColumnNumber()\n                + \" while parsing XML stream: \" + e.toString());\n        throw e;\n    }","id":87434,"modified_method":"@Override\n    public void fatalError(SAXParseException e) throws SAXException {\n        // log and re-throw exception\n        log.error(\"fatal error encountered at line: {}, column: {} while parsing XML stream\",\n\t\t\t\te.getLineNumber(), e.getColumnNumber(), e);\n        throw e;\n    }","commit_id":"b5e93884cf6818af35f7187da665167b8d0805b2","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void warning(SAXParseException e) throws SAXException {\n        // log exception and carry on...\n        log.warn(\"warning encountered at line: \" + e.getLineNumber()\n                + \", column: \" + e.getColumnNumber()\n                + \" while parsing XML stream\", e);\n    }","id":87435,"modified_method":"@Override\n    public void warning(SAXParseException e) throws SAXException {\n        // log exception and carry on...\n        log.warn(\"warning encountered at line: {}, column: {} while parsing XML stream\", \n\t\t\t\te.getLineNumber(), e.getColumnNumber(), e);\n    }","commit_id":"b5e93884cf6818af35f7187da665167b8d0805b2","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void error(SAXParseException e) throws SAXException {\n        // log exception and carry on...\n        log.error(\"error encountered at line: \" + e.getLineNumber()\n                + \", column: \" + e.getColumnNumber()\n                + \" while parsing XML stream: \" + e.toString());\n    }","id":87436,"modified_method":"@Override\n    public void error(SAXParseException e) throws SAXException {\n        // log exception and carry on...\n        log.error(\"error encountered at line: {}, column: {} while parsing XML stream\", \n\t\t\t\te.getLineNumber(), e.getColumnNumber(), e);\n    }","commit_id":"b5e93884cf6818af35f7187da665167b8d0805b2","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n            throws RepositoryException {\n        Tree parent = parents.peek();\n        Tree tree = null;\n        String id = nodeInfo.getUUID();\n        String nodeName = nodeInfo.getName();\n        String ntName = nodeInfo.getPrimaryTypeName();\n\n        if (parent == null) {\n            log.debug(\"Skipping node: \" + nodeName);\n            // parent node was skipped, skip this child node too\n            parents.push(null); // push null onto stack for skipped node\n            // notify the p-i-importer\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n\n        NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            // skip protected node\n            parents.push(null);\n            log.debug(\"Skipping protected node: \" + nodeName);\n\n            if (pnImporter != null) {\n                // pnImporter was already started (current nodeInfo is a sibling)\n                // notify it about this child node.\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                // no importer defined yet:\n                // test if there is a ProtectedNodeImporter among the configured\n                // importers that can handle this.\n                // if there is one, notify the ProtectedNodeImporter about the\n                // start of a item tree that is protected by this parent. If it\n                // potentially is able to deal with it, notify it about the child node.\n                for (ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    } /* else: p-i-Importer isn't able to deal with the protected tree.\n                     try next. and if none can handle the passed parent the\n                     tree below will be skipped */\n                }\n            }\n            return;\n        }\n\n        if (parent.hasChild(nodeName)) {\n            // a node with that name already exists...\n            Tree existing = parent.getChild(nodeName);\n            NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                // existing doesn't allow same-name siblings,\n                // check for potential conflicts\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    /*\n                     use the existing node as parent for the possible subsequent\n                     import of a protected tree, that the protected node importer\n                     may or may not be able to deal with.\n                     -> upon the next 'startNode' the check for the parent being\n                        protected will notify the protected node importer.\n                     -> if the importer is able to deal with that node it needs\n                        to care of the complete subtree until it is notified\n                        during the 'endNode' call.\n                     -> if the import can't deal with that node or if that node\n                        is the a leaf in the tree to be imported 'end' will\n                        not have an effect on the importer, that was never started.\n                    */\n                    log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    /**\n                     * let ProtectedPropertyImporters handle the properties\n                     * associated with the imported node. this may include overwriting,\n                     * merging or just adding missing properties.\n                     */\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    // this node has already been auto-created, no need to create it\n                    tree = existing;\n                } else {\n                    // edge case: colliding node does have same uuid\n                    // (see http://issues.apache.org/jira/browse/JCR-1128)\n                    String existingIdentifier = IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id)\n                            && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING\n                            || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\n                        throw new ItemExistsException(\n                                \"Node with the same UUID exists:\" + existing);\n                    }\n                    // fall through\n                }\n            }\n        }\n\n        if (tree == null) {\n            // create node\n            if (id == null) {\n                // no potential uuid conflict, always add new node\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                // always create a new UUID even if no\n                // conflicting node exists. see OAK-1244\n                tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());\n                // remember uuid mapping\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n\n                Tree conflicting = idLookup.getConflictingTree(id);\n                if (conflicting != null && conflicting.exists()) {\n                    // resolve uuid conflict\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        // no new node has been created, so skip this node\n                        parents.push(null); // push null onto stack for skipped node\n                        log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    // create new with given uuid\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n\n        // process properties\n        importProperties(tree, propInfos, false);\n\n        if (tree.exists()) {\n            parents.push(tree);\n        }\n    }","id":87437,"modified_method":"@Override\n    public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n            throws RepositoryException {\n        Tree parent = parents.peek();\n        Tree tree = null;\n        String id = nodeInfo.getUUID();\n        String nodeName = nodeInfo.getName();\n        String ntName = nodeInfo.getPrimaryTypeName();\n\n        if (parent == null) {\n            log.debug(\"Skipping node: {}\", nodeName);\n            // parent node was skipped, skip this child node too\n            parents.push(null); // push null onto stack for skipped node\n            // notify the p-i-importer\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n\n        NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            // skip protected node\n            parents.push(null);\n            log.debug(\"Skipping protected node: {}\", nodeName);\n\n            if (pnImporter != null) {\n                // pnImporter was already started (current nodeInfo is a sibling)\n                // notify it about this child node.\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                // no importer defined yet:\n                // test if there is a ProtectedNodeImporter among the configured\n                // importers that can handle this.\n                // if there is one, notify the ProtectedNodeImporter about the\n                // start of a item tree that is protected by this parent. If it\n                // potentially is able to deal with it, notify it about the child node.\n                for (ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    } /* else: p-i-Importer isn't able to deal with the protected tree.\n                     try next. and if none can handle the passed parent the\n                     tree below will be skipped */\n                }\n            }\n            return;\n        }\n\n        if (parent.hasChild(nodeName)) {\n            // a node with that name already exists...\n            Tree existing = parent.getChild(nodeName);\n            NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                // existing doesn't allow same-name siblings,\n                // check for potential conflicts\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    /*\n                     use the existing node as parent for the possible subsequent\n                     import of a protected tree, that the protected node importer\n                     may or may not be able to deal with.\n                     -> upon the next 'startNode' the check for the parent being\n                        protected will notify the protected node importer.\n                     -> if the importer is able to deal with that node it needs\n                        to care of the complete subtree until it is notified\n                        during the 'endNode' call.\n                     -> if the import can't deal with that node or if that node\n                        is the a leaf in the tree to be imported 'end' will\n                        not have an effect on the importer, that was never started.\n                    */\n                    log.debug(\"Skipping protected node: {}\", existing);\n                    parents.push(existing);\n                    /**\n                     * let ProtectedPropertyImporters handle the properties\n                     * associated with the imported node. this may include overwriting,\n                     * merging or just adding missing properties.\n                     */\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    // this node has already been auto-created, no need to create it\n                    tree = existing;\n                } else {\n                    // edge case: colliding node does have same uuid\n                    // (see http://issues.apache.org/jira/browse/JCR-1128)\n                    String existingIdentifier = IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id)\n                            && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING\n                            || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\n                        throw new ItemExistsException(\n                                \"Node with the same UUID exists:\" + existing);\n                    }\n                    // fall through\n                }\n            }\n        }\n\n        if (tree == null) {\n            // create node\n            if (id == null) {\n                // no potential uuid conflict, always add new node\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                // always create a new UUID even if no\n                // conflicting node exists. see OAK-1244\n                tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());\n                // remember uuid mapping\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n\n                Tree conflicting = idLookup.getConflictingTree(id);\n                if (conflicting != null && conflicting.exists()) {\n                    // resolve uuid conflict\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        // no new node has been created, so skip this node\n                        parents.push(null); // push null onto stack for skipped node\n                        log.debug(\"Skipping existing node {}\", nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    // create new with given uuid\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n\n        // process properties\n        importProperties(tree, propInfos, false);\n\n        if (tree.exists()) {\n            parents.push(tree);\n        }\n    }","commit_id":"b5e93884cf6818af35f7187da665167b8d0805b2","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void importProperties(@Nonnull Tree tree,\n                                  @Nonnull List<PropInfo> propInfos,\n                                  boolean ignoreRegular) throws RepositoryException {\n        // process properties\n        for (PropInfo pi : propInfos) {\n            // find applicable definition\n            //TODO find better heuristics?\n            PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                // skip protected property\n                log.debug(\"Protected property \" + pi.getName());\n\n                // notify the ProtectedPropertyImporter.\n                for (ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    } /* else: p-i-Importer isn't able to deal with this property. try next pp-importer */\n                }\n            } else if (!ignoreRegular) {\n                // regular property -> create the property\n                createProperty(tree, pi, def);\n            }\n        }\n        for (ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }","id":87438,"modified_method":"private void importProperties(@Nonnull Tree tree,\n                                  @Nonnull List<PropInfo> propInfos,\n                                  boolean ignoreRegular) throws RepositoryException {\n        // process properties\n        for (PropInfo pi : propInfos) {\n            // find applicable definition\n            //TODO find better heuristics?\n            PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                // skip protected property\n                log.debug(\"Protected property {}\", pi.getName());\n\n                // notify the ProtectedPropertyImporter.\n                for (ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    } /* else: p-i-Importer isn't able to deal with this property. try next pp-importer */\n                }\n            } else if (!ignoreRegular) {\n                // regular property -> create the property\n                createProperty(tree, pi, def);\n            }\n        }\n        for (ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }","commit_id":"b5e93884cf6818af35f7187da665167b8d0805b2","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private synchronized MessageList getAvailableList(String name, boolean createIfNotFound) {\n    List<MessageList> lists = myMessageLists.containsKey(name) ? myMessageLists.get(name) : new ArrayList<MessageList>();\n    if (!myMessageLists.containsKey(name)) {\n      myMessageLists.put(name, lists);\n    }\n    for (int i=lists.size()-1; i>=0; --i) {\n      MessageList messageList = lists.get(i);\n      Content content = getMessagesService().getContentManager().getContent(messageList.getComponent());\n      if (content == null || !content.isPinned()) {\n        return messageList;\n      }\n    }\n    if (createIfNotFound) {\n      MessageList list = createList(name);\n      lists.add(list);\n      return list;\n    }\n    return null;\n  }","id":87439,"modified_method":"private synchronized MessageList getAvailableList(String name, boolean createIfNotFound) {\n    List<MessageList> lists = myMessageLists.containsKey(name) ? myMessageLists.get(name) : new ArrayList<MessageList>();\n    if (!myMessageLists.containsKey(name)) {\n      myMessageLists.put(name, lists);\n    }\n    for (int i=lists.size()-1; i>=0; --i) {\n      MessageList messageList = lists.get(i);\n      ContentManager contentManager = null;\n      try {\n      contentManager = getMessagesService().getContentManager();\n      }\n      catch (NullPointerException dumb) {}\n      Content content = contentManager != null ? contentManager.getContent(messageList.getComponent()) : null;\n      if (content == null || !content.isPinned()) {\n        return messageList;\n      }\n    }\n    if (createIfNotFound) {\n      MessageList list = createList(name);\n      lists.add(list);\n      return list;\n    }\n    return null;\n  }","commit_id":"1177b239b211abe767ce53c67a68d3c9fb98a0ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"private synchronized MessageList getAvailableList(String name, boolean createIfNotFound) {\n    List<MessageList> lists = myMessageLists.containsKey(name) ? myMessageLists.get(name) : new ArrayList<MessageList>();\n    if (!myMessageLists.containsKey(name)) {\n      myMessageLists.put(name, lists);\n    }\n    for (int i=lists.size()-1; i>=0; --i) {\n      MessageList messageList = lists.get(i);\n      Content content = getMessagesService().getContentManager().getContent(messageList.getComponent());\n      if (content == null || !content.isPinned()) {\n        return messageList;\n      }\n    }\n    if (createIfNotFound) {\n      MessageList list = createList(name);\n      lists.add(list);\n      return list;\n    }\n    return null;\n  }","id":87440,"modified_method":"private synchronized MessageList getAvailableList(String name, boolean createIfNotFound) {\n    List<MessageList> lists = myMessageLists.containsKey(name) ? myMessageLists.get(name) : new ArrayList<MessageList>();\n    if (!myMessageLists.containsKey(name)) {\n      myMessageLists.put(name, lists);\n    }\n    for (int i=lists.size()-1; i>=0; --i) {\n      MessageList messageList = lists.get(i);\n      ContentManager contentManager = null;\n      try {\n      contentManager = getMessagesService().getContentManager();\n      }\n      catch (NullPointerException dumb) {}\n      Content content = contentManager != null ? contentManager.getContent(messageList.getComponent()) : null;\n      if (content == null || !content.isPinned()) {\n        return messageList;\n      }\n    }\n    if (createIfNotFound) {\n      MessageList list = createList(name);\n      lists.add(list);\n      return list;\n    }\n    return null;\n  }","commit_id":"677622294c0cd685a5b70af300451e949b58bdd7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Subject authenticate(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException {\n\t\tString credentials = request.getHeader(\"Authorization\");\n\t\tString username = null;\n\t\tString password = null;\n\t\tif (credentials != null) {\n\t\t\tBase64Decoder dec = new Base64Decoder();\n\t\t\tdec.translate(credentials.substring(\"Basic \".length()));\n\t\t\tbyte[] c = dec.getByteArray();\n\t\t\tString s = new String(c);\n\t\t\t// LOG.debug(\"BASIC auth credentials: \"+s);\n\t\t\tint p = s.indexOf(':');\n\t\t\tusername = p < 0 ? s : s.substring(0, p);\n\t\t\tpassword = p < 0 ? null : s.substring(p + 1);\n\t\t}\n\n\t\t// get the user from the session if possible\n\t\tHttpSession session = request.getSession(false);\n\t\tSubject user = null;\n\t\tif (session != null) {\n\t\t\tuser = (Subject) session.getAttribute(XQueryContext.HTTP_SESSIONVAR_XMLDB_USER);\n\t\t\tif (user != null && (username == null || user.getName().equals(username))) {\n\t\t\t\treturn user;\n\t\t\t}\n\t\t}\n\n\t\tif (user != null) {\n\t\t\tsession.removeAttribute(XQueryContext.HTTP_SESSIONVAR_XMLDB_USER);\n\t\t}\n\n\t\t// get the credentials\n\t\tif (credentials == null) {\n\t\t\t// prompt for credentials\n\n\t\t\t// LOG.debug(\"Sending BASIC auth challenge.\");\n\t\t\tsendChallenge(request, response);\n\t\t\treturn null;\n\t\t}\n\n\t\t// authenticate the credentials\n\t\tSecurityManager secman = pool.getSecurityManager();\n\t\ttry {\n\t\t\tuser = secman.authenticate(username, password);\n\t\t} catch (AuthenticationException e) {\n\t\t\t// if authentication failed then send a challenge request again\n\t\t\tsendChallenge(request, response);\n\t\t\treturn null;\n\t\t}\n\n\t\t// store the user in the session\n\t\tif (session != null) {\n\t\t\tsession.setAttribute(XQueryContext.HTTP_SESSIONVAR_XMLDB_USER, user);\n\t\t}\n\n\t\t// return the authenticated user\n\t\treturn user;\n\t}","id":87441,"modified_method":"public Subject authenticate(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\treturn authenticate(request, response, true);\n\t}","commit_id":"9065c2ef97a72da2bedb78a77909db3219e00447","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n\tpublic Subject authenticate(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws IOException {\n\t\tString credentials = request.getHeader(\"Authorization\");\n\t\tif (credentials == null) {\n\t\t\tsendChallenge(request, response);\n\t\t\treturn null;\n\t\t}\n\t\tDigest digest = new Digest(request.getMethod());\n\t\tparseCredentials(digest, credentials);\n\t\tSecurityManager secman = pool.getSecurityManager();\n\t\tAccountImpl user = (AccountImpl)secman.getAccount(null, digest.username);\n\t\tif (user == null) {\n\t\t\t// If user does not exist then send a challenge request again\n\t\t\tsendChallenge(request, response);\n\t\t\treturn null;\n\t\t}\n\t\tif (!digest.check(user.getDigestPassword())) {\n\t\t\t// If password is incorrect then send a challenge request again\n\t\t\tsendChallenge(request, response);\n\t\t\treturn null;\n\t\t}\n\t\treturn new SubjectAccreditedImpl(user, this);\n\t}","id":87442,"modified_method":"public Subject authenticate(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\treturn authenticate(request, response, true);\n\t}","commit_id":"9065c2ef97a72da2bedb78a77909db3219e00447","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Processes incoming HTTP requests for XQuery\n     */\n    protected void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //first, adjust the path\n        String path = request.getPathTranslated();\n        if(path == null) {\n            path = request.getRequestURI().substring(request.getContextPath().length());\n            int p = path.lastIndexOf(';');\n            if(p != Constants.STRING_NOT_FOUND)\n                path = path.substring(0, p);\n            path = getServletContext().getRealPath(path);\n        }\n        \n        //second, perform descriptor actions\n        Descriptor descriptor = Descriptor.getDescriptorSingleton();\n        if(descriptor != null && !descriptor.requestsFiltered()) {\n            //logs the request if specified in the descriptor\n            descriptor.doLogRequestInReplayLog(request);\n            \n            //map's the path if a mapping is specified in the descriptor\n            path = descriptor.mapPath(path);\n        }\n        \n        \n//        if (request.getCharacterEncoding() == null)\n//            try {\n//                request.setCharacterEncoding(formEncoding);\n//            } catch (IllegalStateException e) {\n//            }\n        ServletOutputStream sout = response.getOutputStream();\n        PrintWriter output = new PrintWriter(new OutputStreamWriter(sout, formEncoding));\n//        response.setContentType(contentType + \"; charset=\" + formEncoding);\n        response.addHeader( \"pragma\", \"no-cache\" );\n        response.addHeader( \"Cache-Control\", \"no-cache\" );\n\n        String requestPath = request.getRequestURI();\n        int p = requestPath.lastIndexOf(\"/\");\n        if(p != Constants.STRING_NOT_FOUND)\n            requestPath = requestPath.substring(0, p);\n        \n        String moduleLoadPath;\n        Object loadPathAttrib = request.getAttribute(ATTR_MODULE_LOAD_PATH);\n        if (loadPathAttrib != null)\n        \tmoduleLoadPath = getValue(loadPathAttrib);\n        else\n        \tmoduleLoadPath = getServletContext().getRealPath(requestPath.substring(request.getContextPath().length()));\n\n        Subject user = defaultUser;\n\n        Subject requestUser = AccountImpl.getUserFromServletRequest(request);\n        if (requestUser != null)\n        \tuser = requestUser;\n\n        // to determine the user, first check the request attribute \"xquery.user\", then\n        // the current session attribute \"user\"\n        Object userAttrib = request.getAttribute(ATTR_XQUERY_USER);\n        HttpSession session = request.getSession( false );\n        if(userAttrib != null || (session != null && request.isRequestedSessionIdValid())) {\n            Object passwdAttrib = request.getAttribute(ATTR_XQUERY_PASSWORD);\n            String username;\n            String password;\n            if (userAttrib != null) {\n                username = getValue(userAttrib);\n                password = getValue(passwdAttrib);\n            } else {\n                username = getSessionAttribute(session, \"user\");\n                password = getSessionAttribute(session, \"password\");\n            }\n\t\t\ttry {\n\t\t\t\tif( username != null && password != null ) {\n\t\t\t\t\tSubject newUser = pool.getSecurityManager().authenticate(username, password);\n\t\t        \tif (newUser != null && newUser.isAuthenticated())\n\t\t        \t\tuser = newUser;\n\t\t\t\t}\n\t\t\t} catch (AuthenticationException e) {\n\t\t\t\tLOG.error(\"User can not be authenticated (\"+username+\").\");\n\t\t\t}\n        }\n        \n        Source source = null;\n        Object sourceAttrib = request.getAttribute(ATTR_XQUERY_SOURCE);\n        Object urlAttrib = request.getAttribute(ATTR_XQUERY_URL);\n        if (sourceAttrib != null) {\n            String s;\n            if (sourceAttrib instanceof Item)\n                try {\n                    s = ((Item) sourceAttrib).getStringValue();\n                } catch (XPathException e) {\n                    throw new ServletException(\"Failed to read XQuery source string from \" +\n                        \"request attribute '\" + ATTR_XQUERY_SOURCE + \"': \" + e.getMessage(), e);\n                }\n            else\n                s = sourceAttrib.toString();\n            source = new StringSource(s);\n        } else if (urlAttrib != null) {\n            DBBroker broker = null;\n            try {\n        \t    broker = pool.get(user);\n                source = SourceFactory.getSource(broker, moduleLoadPath, urlAttrib.toString(), true);\n            } catch (Exception e) {\n                LOG.error(e.getMessage(), e);\n                response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                sendError(output, \"Error\", e.getMessage());\n            } finally {\n                pool.release(broker);\n            }\n        } else {\n            File f = new File(path);\n            if(!f.canRead()) {\n                response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                sendError(output, \"Cannot read source file\", path);\n                return;\n            }\n            source = new FileSource(f, encoding, true);\n        }\n        if (source == null) {\n            response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n            sendError(output, \"Source not found\", path);\n        }\n        boolean reportErrors = false;\n        String errorOpt = (String) request.getAttribute(ATTR_XQUERY_REPORT_ERRORS);\n        if (errorOpt != null)\n            reportErrors = errorOpt.equalsIgnoreCase(\"YES\");\n        \n        //allow source viewing for GET?\n        if(request.getMethod().toUpperCase().equals(\"GET\")) {\n            String option;\n            boolean allowSource = false;\n            if((option = request.getParameter(\"_source\")) != null)\n                allowSource = option.equals(\"yes\");\n            \n            //Should we display the source of the XQuery or execute it\n            if(allowSource && descriptor != null) {\n                //show the source\n                \n                //check are we allowed to show the xquery source - descriptor.xml\n//                System.out.println(\"path=\"+path);\n                if(descriptor.allowSource(path)) {\n                \t\n                \ttry {\n\t\t\t\t\t\tsource.validate(user, Permission.READ);\n\t\t\t\t\t} catch (PermissionDeniedException e) {\n\t                   response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Permission to view XQuery source for: \" + path + \" denied. (no read access)\");\n\t                   return;\n\t\t\t\t\t}\n                    \n\t\t\t\t\t//Show the source of the XQuery\n                    //writeResourceAs(resource, broker, stylesheet, encoding, \"text/plain\", outputProperties, response);\n                    response.setContentType(\"text/plain; charset=\" + formEncoding);\n                    output.write(source.getContent());\n                    output.flush();\n                    return;\n                } else {\n                   \n                   response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Permission to view XQuery source for: \" + path + \" denied. Must be explicitly defined in descriptor.xml\");\n                   return;\n                }\n            }\n        }\n        \n        //-------------------------------\n        \n//        URI baseUri;\n//        try {\n//            baseUri = new URI(request.getScheme(),\n//                    null/*user info?*/, request.getLocalName(), request.getLocalPort(),\n//                    request.getRequestURI(), null, null);\n//        } catch(URISyntaxException e) {\n//            baseUri = null;\n//        }\n\n        String requestAttr = (String) request.getAttribute(ATTR_XQUERY_ATTRIBUTE);\n\n        DBBroker broker = null;\n        try {\n        \tbroker = pool.get(user);\n            XQuery xquery = broker.getXQueryService();\n            CompiledXQuery query = xquery.getXQueryPool().borrowCompiledXQuery(broker, source);\n\n            XQueryContext context;\n            if (query==null) {\n               context = xquery.newContext(AccessContext.REST);\n               context.setModuleLoadPath(moduleLoadPath);\n               try {\n            \t   query = xquery.compile(context, source);\n               } catch (XPathException ex) {\n                  throw new EXistException(\"Cannot compile xquery: \"+ ex.getMessage(), ex);\n               } catch (IOException ex) {\n                  throw new EXistException(\"I/O exception while compiling xquery: \" + ex.getMessage() ,ex);\n               }\n            } else {\n               context = query.getContext();\n               context.setModuleLoadPath(moduleLoadPath);\n            }\n\n            Properties outputProperties = new Properties();\n            outputProperties.put(\"base-uri\", collectionURI.toString());\n            \n            context.declareVariable(RequestModule.PREFIX + \":request\", new HttpRequestWrapper(request, formEncoding, containerEncoding));\n            context.declareVariable(ResponseModule.PREFIX + \":response\", new HttpResponseWrapper(response));\n            context.declareVariable(SessionModule.PREFIX + \":session\", ( session != null ? new HttpSessionWrapper( session ) : null ) );\n\n            DebuggeeFactory.checkForDebugRequest(request, context);\n\n            Sequence resultSequence;\n            try {\n                resultSequence = xquery.execute(query, null, outputProperties);\n            } finally {\n                xquery.getXQueryPool().returnCompiledXQuery(source, query);\n            }\n\n            String mediaType = outputProperties.getProperty(OutputKeys.MEDIA_TYPE);\n            if (mediaType != null) {\n                if (!response.isCommitted())\n                \tif (MimeTable.getInstance().isTextContent(mediaType))\n                \t\tresponse.setContentType(mediaType + \"; charset=\" + formEncoding);\n                \telse\n                \t\tresponse.setContentType(mediaType);\n            } else {\n\t            String contentType = this.contentType;\n\t            try {\n\t                contentType = getServletContext().getMimeType(path);\n\t                if (contentType == null)\n\t                    contentType = this.contentType;\n\t            } catch (Throwable e) {\n\t                contentType = this.contentType;\n\t            } finally {\n\t                if (MimeTable.getInstance().isTextContent(contentType))\n\t                    contentType += \"; charset=\" + formEncoding;\n\t                response.setContentType(contentType );\n\t            }\n            }\n            \n            if (requestAttr != null && (XmldbURI.API_LOCAL.equals(collectionURI.getApiName())) ) {\n                request.setAttribute(requestAttr, resultSequence);\n            } else {\n            \tSerializer serializer = broker.getSerializer();\n            \tserializer.reset();\n            \n            \tSerializerPool serializerPool = SerializerPool.getInstance();\n\n            \tSAXSerializer sax = (SAXSerializer) serializerPool.borrowObject(SAXSerializer.class);\n            \ttry {\n\t            \tsax.setOutput(output, outputProperties);\n\t            \tserializer.setProperties(outputProperties);\n\t            \tserializer.setSAXHandlers(sax, sax);\n\t            \t\n\t            \tserializer.toSAX(resultSequence, 1, resultSequence.getItemCount(), false);\n            \t} finally {\n            \t\tserializerPool.returnObject(sax);\n            \t}\n            }\n        } catch (Throwable e){\n            LOG.error(e.getMessage(), e);\n            if (reportErrors)\n            \twriteError(output, e);\n            else {\n            \tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            \tsendError(output, \"Error\", e.getMessage());\n            }\n        } finally {\n            pool.release(broker);\n        }\n\n        output.flush();\n        output.close();\n    }","id":87443,"modified_method":"/**\n     * Processes incoming HTTP requests for XQuery\n     */\n    protected void process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //first, adjust the path\n        String path = request.getPathTranslated();\n        if(path == null) {\n            path = request.getRequestURI().substring(request.getContextPath().length());\n            int p = path.lastIndexOf(';');\n            if(p != Constants.STRING_NOT_FOUND)\n                path = path.substring(0, p);\n            path = getServletContext().getRealPath(path);\n        }\n        \n        //second, perform descriptor actions\n        Descriptor descriptor = Descriptor.getDescriptorSingleton();\n        if(descriptor != null && !descriptor.requestsFiltered()) {\n            //logs the request if specified in the descriptor\n            descriptor.doLogRequestInReplayLog(request);\n            \n            //map's the path if a mapping is specified in the descriptor\n            path = descriptor.mapPath(path);\n        }\n        \n        \n//        if (request.getCharacterEncoding() == null)\n//            try {\n//                request.setCharacterEncoding(formEncoding);\n//            } catch (IllegalStateException e) {\n//            }\n        ServletOutputStream sout = response.getOutputStream();\n        PrintWriter output = new PrintWriter(new OutputStreamWriter(sout, formEncoding));\n//        response.setContentType(contentType + \"; charset=\" + formEncoding);\n        response.addHeader( \"pragma\", \"no-cache\" );\n        response.addHeader( \"Cache-Control\", \"no-cache\" );\n\n        String requestPath = request.getRequestURI();\n        int p = requestPath.lastIndexOf(\"/\");\n        if(p != Constants.STRING_NOT_FOUND)\n            requestPath = requestPath.substring(0, p);\n        \n        String moduleLoadPath;\n        Object loadPathAttrib = request.getAttribute(ATTR_MODULE_LOAD_PATH);\n        if (loadPathAttrib != null)\n        \tmoduleLoadPath = getValue(loadPathAttrib);\n        else\n        \tmoduleLoadPath = getServletContext().getRealPath(requestPath.substring(request.getContextPath().length()));\n\n        Subject user = defaultUser;\n\n        // to determine the user, first check the request attribute \"xquery.user\", then\n        // the current session attribute \"user\"\n        Object userAttrib = request.getAttribute(ATTR_XQUERY_USER);\n        HttpSession session = request.getSession( false );\n        if(userAttrib != null || (session != null && request.isRequestedSessionIdValid())) {\n            Object passwdAttrib = request.getAttribute(ATTR_XQUERY_PASSWORD);\n            String username;\n            String password;\n            if (userAttrib != null) {\n                username = getValue(userAttrib);\n                password = getValue(passwdAttrib);\n            } else {\n                username = getSessionAttribute(session, \"user\");\n                password = getSessionAttribute(session, \"password\");\n            }\n\t\t\ttry {\n\t\t\t\tif( username != null && password != null ) {\n\t\t\t\t\tSubject newUser = pool.getSecurityManager().authenticate(username, password);\n\t\t        \tif (newUser != null && newUser.isAuthenticated())\n\t\t        \t\tuser = newUser;\n\t\t\t\t}\n\t\t\t} catch (AuthenticationException e) {\n\t\t\t\tLOG.error(\"User can not be authenticated (\"+username+\").\");\n\t\t\t}\n        }\n        \n        if (user == defaultUser) {\n        \tSubject requestUser = AccountImpl.getUserFromServletRequest(request);\n        \tif (requestUser != null) {\n        \t\tuser = requestUser;\n        \t} else {\n        \t\trequestUser = authenticator.authenticate(request, response, false);\n        \t\tif (requestUser != null) \n        \t\t\tuser = requestUser;\n        \t}\n        }\n        \n        Source source = null;\n        Object sourceAttrib = request.getAttribute(ATTR_XQUERY_SOURCE);\n        Object urlAttrib = request.getAttribute(ATTR_XQUERY_URL);\n        if (sourceAttrib != null) {\n            String s;\n            if (sourceAttrib instanceof Item)\n                try {\n                    s = ((Item) sourceAttrib).getStringValue();\n                } catch (XPathException e) {\n                    throw new ServletException(\"Failed to read XQuery source string from \" +\n                        \"request attribute '\" + ATTR_XQUERY_SOURCE + \"': \" + e.getMessage(), e);\n                }\n            else\n                s = sourceAttrib.toString();\n            source = new StringSource(s);\n        } else if (urlAttrib != null) {\n            DBBroker broker = null;\n            try {\n        \t    broker = pool.get(user);\n                source = SourceFactory.getSource(broker, moduleLoadPath, urlAttrib.toString(), true);\n            } catch (Exception e) {\n                LOG.error(e.getMessage(), e);\n                response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                sendError(output, \"Error\", e.getMessage());\n            } finally {\n                pool.release(broker);\n            }\n        } else {\n            File f = new File(path);\n            if(!f.canRead()) {\n                response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n                sendError(output, \"Cannot read source file\", path);\n                return;\n            }\n            source = new FileSource(f, encoding, true);\n        }\n        if (source == null) {\n            response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n            sendError(output, \"Source not found\", path);\n        }\n        boolean reportErrors = false;\n        String errorOpt = (String) request.getAttribute(ATTR_XQUERY_REPORT_ERRORS);\n        if (errorOpt != null)\n            reportErrors = errorOpt.equalsIgnoreCase(\"YES\");\n        \n        //allow source viewing for GET?\n        if(request.getMethod().toUpperCase().equals(\"GET\")) {\n            String option;\n            boolean allowSource = false;\n            if((option = request.getParameter(\"_source\")) != null)\n                allowSource = option.equals(\"yes\");\n            \n            //Should we display the source of the XQuery or execute it\n            if(allowSource && descriptor != null) {\n                //show the source\n                \n                //check are we allowed to show the xquery source - descriptor.xml\n//                System.out.println(\"path=\"+path);\n                if(descriptor.allowSource(path)) {\n                \t\n                \ttry {\n\t\t\t\t\t\tsource.validate(user, Permission.READ);\n\t\t\t\t\t} catch (PermissionDeniedException e) {\n\t\t\t\t\t\tif (defaultUser.equals(user)) {\n\t\t\t\t\t\t\tauthenticator.sendChallenge(request, response);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN, \"Permission to view XQuery source for: \" + path + \" denied. (no read access)\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n                    \n\t\t\t\t\t//Show the source of the XQuery\n                    //writeResourceAs(resource, broker, stylesheet, encoding, \"text/plain\", outputProperties, response);\n                    response.setContentType(\"text/plain; charset=\" + formEncoding);\n                    output.write(source.getContent());\n                    output.flush();\n                    return;\n                } else {\n                   \n                   response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Permission to view XQuery source for: \" + path + \" denied. Must be explicitly defined in descriptor.xml\");\n                   return;\n                }\n            }\n        }\n        \n        //-------------------------------\n        \n//        URI baseUri;\n//        try {\n//            baseUri = new URI(request.getScheme(),\n//                    null/*user info?*/, request.getLocalName(), request.getLocalPort(),\n//                    request.getRequestURI(), null, null);\n//        } catch(URISyntaxException e) {\n//            baseUri = null;\n//        }\n\n        String requestAttr = (String) request.getAttribute(ATTR_XQUERY_ATTRIBUTE);\n\n        DBBroker broker = null;\n        try {\n        \tbroker = pool.get(user);\n            XQuery xquery = broker.getXQueryService();\n            CompiledXQuery query = xquery.getXQueryPool().borrowCompiledXQuery(broker, source);\n\n            XQueryContext context;\n            if (query==null) {\n               context = xquery.newContext(AccessContext.REST);\n               context.setModuleLoadPath(moduleLoadPath);\n               try {\n            \t   query = xquery.compile(context, source);\n               } catch (XPathException ex) {\n                  throw new EXistException(\"Cannot compile xquery: \"+ ex.getMessage(), ex);\n               } catch (IOException ex) {\n                  throw new EXistException(\"I/O exception while compiling xquery: \" + ex.getMessage() ,ex);\n               }\n            } else {\n               context = query.getContext();\n               context.setModuleLoadPath(moduleLoadPath);\n            }\n\n            Properties outputProperties = new Properties();\n            outputProperties.put(\"base-uri\", collectionURI.toString());\n            \n            context.declareVariable(RequestModule.PREFIX + \":request\", new HttpRequestWrapper(request, formEncoding, containerEncoding));\n            context.declareVariable(ResponseModule.PREFIX + \":response\", new HttpResponseWrapper(response));\n            context.declareVariable(SessionModule.PREFIX + \":session\", ( session != null ? new HttpSessionWrapper( session ) : null ) );\n\n            DebuggeeFactory.checkForDebugRequest(request, context);\n\n            Sequence resultSequence;\n            try {\n                resultSequence = xquery.execute(query, null, outputProperties);\n            } finally {\n                xquery.getXQueryPool().returnCompiledXQuery(source, query);\n            }\n\n            String mediaType = outputProperties.getProperty(OutputKeys.MEDIA_TYPE);\n            if (mediaType != null) {\n                if (!response.isCommitted())\n                \tif (MimeTable.getInstance().isTextContent(mediaType))\n                \t\tresponse.setContentType(mediaType + \"; charset=\" + formEncoding);\n                \telse\n                \t\tresponse.setContentType(mediaType);\n            } else {\n\t            String contentType = this.contentType;\n\t            try {\n\t                contentType = getServletContext().getMimeType(path);\n\t                if (contentType == null)\n\t                    contentType = this.contentType;\n\t            } catch (Throwable e) {\n\t                contentType = this.contentType;\n\t            } finally {\n\t                if (MimeTable.getInstance().isTextContent(contentType))\n\t                    contentType += \"; charset=\" + formEncoding;\n\t                response.setContentType(contentType );\n\t            }\n            }\n            \n            if (requestAttr != null && (XmldbURI.API_LOCAL.equals(collectionURI.getApiName())) ) {\n                request.setAttribute(requestAttr, resultSequence);\n            } else {\n            \tSerializer serializer = broker.getSerializer();\n            \tserializer.reset();\n            \n            \tSerializerPool serializerPool = SerializerPool.getInstance();\n\n            \tSAXSerializer sax = (SAXSerializer) serializerPool.borrowObject(SAXSerializer.class);\n            \ttry {\n\t            \tsax.setOutput(output, outputProperties);\n\t            \tserializer.setProperties(outputProperties);\n\t            \tserializer.setSAXHandlers(sax, sax);\n\t            \t\n\t            \tserializer.toSAX(resultSequence, 1, resultSequence.getItemCount(), false);\n            \t} finally {\n            \t\tserializerPool.returnObject(sax);\n            \t}\n            }\n\t\t} catch (PermissionDeniedException e) {\n\t\t\tif (defaultUser.equals(user)) {\n\t\t\t\tauthenticator.sendChallenge(request, response);\n\t\t\t} else {\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN, \"No permission to execute XQuery for: \" + path + \" denied.\");\n\t\t\t}\n\t\t\treturn;\n        } catch (Throwable e){\n            LOG.error(e.getMessage(), e);\n            if (reportErrors)\n            \twriteError(output, e);\n            else {\n            \tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            \tsendError(output, \"Error\", e.getMessage());\n            }\n        } finally {\n            pool.release(broker);\n        }\n\n        output.flush();\n        output.close();\n    }","commit_id":"9065c2ef97a72da2bedb78a77909db3219e00447","url":"https://github.com/eXist-db/exist"},{"original_method":"public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n\n        try {\n            Class<?> driver = Class.forName(DRIVER);\n            Database database = (Database)driver.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n        } catch(Exception e) {\n            String errorMessage=\"Failed to initialize database driver\";\n            LOG.error(errorMessage,e);\n            throw new ServletException(errorMessage+\": \" + e.getMessage(), e);\n        }\n\n        try {\n\t\t\tpool = BrokerPool.getInstance();\n\t\t} catch (EXistException e) {\n            throw new ServletException(\"Could not intialize db: \" + e.getMessage(), e);\n\t\t}\n        \n\t\tdefaultUser = pool.getSecurityManager().getGuestSubject();\n\t\t\n        String username = config.getInitParameter(\"user\");\n        if(username != null) {\n        \tString password = config.getInitParameter(\"password\");\n        \tSubject user;\n\t\t\ttry {\n\t\t\t\tuser = pool.getSecurityManager().authenticate(username, password);\n\t        \tif (user != null && user.isAuthenticated())\n\t        \t\tdefaultUser = user;\n\t\t\t} catch (AuthenticationException e) {\n\t\t\t\tLOG.error(\"User can not be authenticated (\"+username+\"), using default user.\");\n\t\t\t}\n        }\n        String confCollectionURI = config.getInitParameter(\"uri\");\n        if(confCollectionURI == null) {\n            collectionURI = DEFAULT_URI;\n        } else {\n            try {\n                collectionURI = XmldbURI.xmldbUriFor(confCollectionURI);\n            } catch (URISyntaxException e) {\n                throw new ServletException(\"Invalid XmldbURI for parameter 'uri': \"+e.getMessage(),e);\n            }\n        }\n        \n        formEncoding = config.getInitParameter(\"form-encoding\");\n        if(formEncoding == null)\n            formEncoding = DEFAULT_ENCODING;\n        LOG.info(\"form-encoding = \" + formEncoding);\n        \n        containerEncoding = config.getInitParameter(\"container-encoding\");\n        if(containerEncoding == null)\n            containerEncoding = DEFAULT_ENCODING;\n        LOG.info(\"container-encoding = \" + containerEncoding);\n        \n        encoding = config.getInitParameter(\"encoding\");\n        if(encoding == null)\n            encoding = DEFAULT_ENCODING;\n        LOG.info(\"encoding = \" + encoding);\n\n        contentType = config.getInitParameter(\"content-type\");\n        if(contentType == null)\n            contentType = DEFAULT_CONTENT_TYPE;\n    }","id":87444,"modified_method":"public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n\n        try {\n            Class<?> driver = Class.forName(DRIVER);\n            Database database = (Database)driver.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n        } catch(Exception e) {\n            String errorMessage=\"Failed to initialize database driver\";\n            LOG.error(errorMessage,e);\n            throw new ServletException(errorMessage+\": \" + e.getMessage(), e);\n        }\n\n        try {\n\t\t\tpool = BrokerPool.getInstance();\n\t\t} catch (EXistException e) {\n            throw new ServletException(\"Could not intialize db: \" + e.getMessage(), e);\n\t\t}\n        \n\t\tauthenticator = new BasicAuthenticator(pool);\n\t\tdefaultUser = pool.getSecurityManager().getGuestSubject();\n\t\t\n        String username = config.getInitParameter(\"user\");\n        if(username != null) {\n        \tString password = config.getInitParameter(\"password\");\n        \tSubject user;\n\t\t\ttry {\n\t\t\t\tuser = pool.getSecurityManager().authenticate(username, password);\n\t        \tif (user != null && user.isAuthenticated())\n\t        \t\tdefaultUser = user;\n\t\t\t} catch (AuthenticationException e) {\n\t\t\t\tLOG.error(\"User can not be authenticated (\"+username+\"), using default user.\");\n\t\t\t}\n        }\n        String confCollectionURI = config.getInitParameter(\"uri\");\n        if(confCollectionURI == null) {\n            collectionURI = DEFAULT_URI;\n        } else {\n            try {\n                collectionURI = XmldbURI.xmldbUriFor(confCollectionURI);\n            } catch (URISyntaxException e) {\n                throw new ServletException(\"Invalid XmldbURI for parameter 'uri': \"+e.getMessage(),e);\n            }\n        }\n        \n        formEncoding = config.getInitParameter(\"form-encoding\");\n        if(formEncoding == null)\n            formEncoding = DEFAULT_ENCODING;\n        LOG.info(\"form-encoding = \" + formEncoding);\n        \n        containerEncoding = config.getInitParameter(\"container-encoding\");\n        if(containerEncoding == null)\n            containerEncoding = DEFAULT_ENCODING;\n        LOG.info(\"container-encoding = \" + containerEncoding);\n        \n        encoding = config.getInitParameter(\"encoding\");\n        if(encoding == null)\n            encoding = DEFAULT_ENCODING;\n        LOG.info(\"encoding = \" + encoding);\n\n        contentType = config.getInitParameter(\"content-type\");\n        if(contentType == null)\n            contentType = DEFAULT_CONTENT_TYPE;\n    }","commit_id":"9065c2ef97a72da2bedb78a77909db3219e00447","url":"https://github.com/eXist-db/exist"},{"original_method":"@GET\n  @Path(\"/.*\")\n  public void serve(HttpRequest request, HttpResponder responder) {\n    try {\n\n      if (request.getUri().equals(\"/status\")) {\n        responder.sendString(HttpResponseStatus.OK, \"OK\\n\");\n        return;\n      }\n\n      String hostHeader = HttpHeaders.getHost(request);\n      if (hostHeader == null) {\n        responder.sendStatus(HttpResponseStatus.BAD_REQUEST);\n      }\n\n      String path = servePathGenerator.getServePath(hostHeader, request.getUri());\n      if (path == null) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      File file = new File(path);\n      if (!file.exists()) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      if (!file.isFile()) {\n        responder.sendStatus(HttpResponseStatus.FORBIDDEN);\n        return;\n      }\n\n      responder.sendFile(file, ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE,\n                                                    URLConnection.guessContentTypeFromName(file.getAbsolutePath())));\n\n    } catch (Throwable t) {\n      LOG.error(\"Got exception: \", t);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","id":87445,"modified_method":"@GET\n  @Path(\"/.*\")\n  public void serve(HttpRequest request, HttpResponder responder) {\n    try {\n\n      String path = request.getUri();\n      if (path == null) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      if (path.startsWith(\"/\") && path.length() > 1) {\n        path = path.substring(1);\n      }\n\n      File file = new File(path);\n      if (!file.exists()) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      if (!file.isFile()) {\n        responder.sendStatus(HttpResponseStatus.FORBIDDEN);\n        return;\n      }\n\n      responder.sendFile(file, ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE,\n                                                    mimeTypesMap.getContentType(file.getAbsolutePath())));\n\n    } catch (Throwable t) {\n      LOG.error(\"Got exception: \", t);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Construct HttpResourceHandler. Reads all annotations from all the handler classes and methods passed in, constructs\n   * patternPathRouter which is routable by path to {@code HttpResourceModel} as destination of the route.\n   *\n   * @param handlers Iterable of HttpHandler.\n   * @param handlerHooks Iterable of HandlerHook.\n   */\n  public HttpResourceHandler(Iterable<HttpHandler> handlers, Iterable<HandlerHook> handlerHooks){\n    //Store the handlers to call init and destroy on all handlers.\n    this.handlers = ImmutableList.copyOf(handlers);\n    this.handlerHooks = ImmutableList.copyOf(handlerHooks);\n\n    for (HttpHandler handler : handlers){\n      String basePath = \"\";\n      if (handler.getClass().isAnnotationPresent(Path.class)){\n        basePath =  handler.getClass().getAnnotation(Path.class).value();\n      }\n\n      for (Method method:  handler.getClass().getDeclaredMethods()){\n        if (method.getParameterTypes().length >= 2 &&\n          method.getParameterTypes()[0].isAssignableFrom(HttpRequest.class) &&\n          method.getParameterTypes()[1].isAssignableFrom(HttpResponder.class) &&\n          Modifier.isPublic(method.getModifiers())) {\n\n          String relativePath = \"\";\n          if (method.getAnnotation(Path.class) != null) {\n            relativePath = method.getAnnotation(Path.class).value();\n          }\n          String absolutePath = String.format(\"%s/%s\", basePath, relativePath);\n          Set<HttpMethod> httpMethods = getHttpMethods(method);\n          Preconditions.checkArgument(httpMethods.size() >= 1,\n                                      String.format(\"No HttpMethod found for method: %s\", method.getName()));\n          patternRouter.add(absolutePath, new HttpResourceModel(httpMethods, method, handler));\n        } else {\n          LOG.trace(\"Not adding method {}({}) to path routing like. HTTP calls will not be routed to this method\",\n                   method.getName(), method.getParameterTypes());\n        }\n      }\n    }\n  }","id":87446,"modified_method":"/**\n   * Construct HttpResourceHandler. Reads all annotations from all the handler classes and methods passed in, constructs\n   * patternPathRouter which is routable by path to {@code HttpResourceModel} as destination of the route.\n   *\n   * @param handlers Iterable of HttpHandler.\n   * @param handlerHooks Iterable of HandlerHook.\n   */\n  public HttpResourceHandler(Iterable<HttpHandler> handlers, Iterable<HandlerHook> handlerHooks,\n                             UrlRewriter urlRewriter) {\n    //Store the handlers to call init and destroy on all handlers.\n    this.handlers = ImmutableList.copyOf(handlers);\n    this.handlerHooks = ImmutableList.copyOf(handlerHooks);\n    this.urlRewriter = urlRewriter;\n\n    for (HttpHandler handler : handlers){\n      String basePath = \"\";\n      if (handler.getClass().isAnnotationPresent(Path.class)){\n        basePath =  handler.getClass().getAnnotation(Path.class).value();\n      }\n\n      for (Method method:  handler.getClass().getDeclaredMethods()){\n        if (method.getParameterTypes().length >= 2 &&\n          method.getParameterTypes()[0].isAssignableFrom(HttpRequest.class) &&\n          method.getParameterTypes()[1].isAssignableFrom(HttpResponder.class) &&\n          Modifier.isPublic(method.getModifiers())) {\n\n          String relativePath = \"\";\n          if (method.getAnnotation(Path.class) != null) {\n            relativePath = method.getAnnotation(Path.class).value();\n          }\n          String absolutePath = String.format(\"%s/%s\", basePath, relativePath);\n          Set<HttpMethod> httpMethods = getHttpMethods(method);\n          Preconditions.checkArgument(httpMethods.size() >= 1,\n                                      String.format(\"No HttpMethod found for method: %s\", method.getName()));\n          patternRouter.add(absolutePath, new HttpResourceModel(httpMethods, method, handler));\n        } else {\n          LOG.trace(\"Not adding method {}({}) to path routing like. HTTP calls will not be routed to this method\",\n                   method.getName(), method.getParameterTypes());\n        }\n      }\n    }\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Call the appropriate handler for handling the httprequest. 404 if path is not found. 405 if path is found but\n   * httpMethod does not match what's configured.\n   *\n   * @param request instance of {@code HttpRequest}\n   * @param responder instance of {@code HttpResponder} to handle the request.\n   */\n  public void handle(HttpRequest request, HttpResponder responder){\n\n    Map<String, String> groupValues = Maps.newHashMap();\n    String path = URI.create(request.getUri()).getPath();\n\n    List<HttpResourceModel> resourceModels = patternRouter.getDestinations(path, groupValues);\n\n    HttpResourceModel httpResourceModel = getMatchedResourceModel(resourceModels, request.getMethod());\n\n    try {\n      if (httpResourceModel != null) {\n        //Found a httpresource route to it.\n\n        // Call preCall method of handler hooks.\n        boolean terminated = false;\n        HandlerInfo info = new HandlerInfo(httpResourceModel.getMethod().getDeclaringClass().getName(),\n                                           httpResourceModel.getMethod().getName());\n        for (HandlerHook hook : handlerHooks) {\n          if (!hook.preCall(request, responder, info)) {\n            // Terminate further request processing if preCall returns false.\n            terminated = true;\n            break;\n          }\n        }\n\n        // Call httpresource method\n        if (!terminated) {\n          // Wrap responder to make post hook calls.\n          responder = new WrappedHttpResponder(responder, handlerHooks, request, info);\n          httpResourceModel.handle(request, responder, groupValues);\n        }\n      } else if (resourceModels.size() > 0)  {\n        //Found a matching resource but could not find the right HttpMethod so return 405\n        responder.sendError(HttpResponseStatus.METHOD_NOT_ALLOWED,\n                            String.format(\"Problem accessing: %s. Reason: Method Not Allowed\", request.getUri()));\n      } else {\n        responder.sendError(HttpResponseStatus.NOT_FOUND, String.format(\"Problem accessing: %s. Reason: Not Found\",\n                                                                        request.getUri()));\n      }\n    } catch (Throwable t){\n      responder.sendError(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                          String.format(\"Caught exception processing request. Reason: %s\",\n                                        t.getMessage()));\n    }\n  }","id":87447,"modified_method":"/**\n   * Call the appropriate handler for handling the httprequest. 404 if path is not found. 405 if path is found but\n   * httpMethod does not match what's configured.\n   *\n   * @param request instance of {@code HttpRequest}\n   * @param responder instance of {@code HttpResponder} to handle the request.\n   */\n  public void handle(HttpRequest request, HttpResponder responder) {\n\n    if (urlRewriter != null) {\n      try {\n        urlRewriter.rewrite(request);\n      } catch (Throwable t) {\n        responder.sendError(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                            String.format(\"Caught exception processing request. Reason: %s\",\n                                          t.getMessage()));\n        LOG.error(\"Exception thrown during rewriting of uri {}\", request.getUri(), t);\n        return;\n      }\n    }\n\n    Map<String, String> groupValues = Maps.newHashMap();\n    String path = URI.create(request.getUri()).getPath();\n\n    List<HttpResourceModel> resourceModels = patternRouter.getDestinations(path, groupValues);\n\n    HttpResourceModel httpResourceModel = getMatchedResourceModel(resourceModels, request.getMethod());\n\n    try {\n      if (httpResourceModel != null) {\n        //Found a httpresource route to it.\n\n        // Call preCall method of handler hooks.\n        boolean terminated = false;\n        HandlerInfo info = new HandlerInfo(httpResourceModel.getMethod().getDeclaringClass().getName(),\n                                           httpResourceModel.getMethod().getName());\n        for (HandlerHook hook : handlerHooks) {\n          if (!hook.preCall(request, responder, info)) {\n            // Terminate further request processing if preCall returns false.\n            terminated = true;\n            break;\n          }\n        }\n\n        // Call httpresource method\n        if (!terminated) {\n          // Wrap responder to make post hook calls.\n          responder = new WrappedHttpResponder(responder, handlerHooks, request, info);\n          httpResourceModel.handle(request, responder, groupValues);\n        }\n      } else if (resourceModels.size() > 0)  {\n        //Found a matching resource but could not find the right HttpMethod so return 405\n        responder.sendError(HttpResponseStatus.METHOD_NOT_ALLOWED,\n                            String.format(\"Problem accessing: %s. Reason: Method Not Allowed\", request.getUri()));\n      } else {\n        responder.sendError(HttpResponseStatus.NOT_FOUND, String.format(\"Problem accessing: %s. Reason: Not Found\",\n                                                                        request.getUri()));\n      }\n    } catch (Throwable t){\n      responder.sendError(HttpResponseStatus.INTERNAL_SERVER_ERROR,\n                          String.format(\"Caught exception processing request. Reason: %s\",\n                                        t.getMessage()));\n      LOG.error(\"Exception thrown during request processing for uri {}\", request.getUri(), t);\n    }\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures a {@link com.google.inject.Binder} via the exposed methods.\n   */\n  @Override\n  protected void configure() {\n\n    // Bind and expose LogWriter (a bit hacky, but needed by MapReduce for now)\n    bind(LogWriter.class).to(LocalLogWriter.class);\n    expose(LogWriter.class);\n\n    // Bind ServiceAnnouncer for procedure.\n    bind(ServiceAnnouncer.class).to(DiscoveryServiceAnnouncer.class);\n\n    // Bind ProgramRunner\n    MapBinder<ProgramRunnerFactory.Type, ProgramRunner> runnerFactoryBinder =\n      MapBinder.newMapBinder(binder(), ProgramRunnerFactory.Type.class, ProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOW).to(FlowProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOWLET).to(FlowletProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.PROCEDURE).to(ProcedureProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.MAPREDUCE).to(MapReduceProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.WORKFLOW).to(WorkflowProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.WEBAPP).to(WebappProgramRunner.class);\n\n    bind(ProgramRunnerFactory.class).to(InMemoryFlowProgramRunnerFactory.class).in(Scopes.SINGLETON);\n    // Note: Expose for test cases. Need to refactor test cases.\n    expose(ProgramRunnerFactory.class);\n\n    // Bind and expose runtime service\n    bind(ProgramRuntimeService.class).to(InMemoryProgramRuntimeService.class).in(Scopes.SINGLETON);\n    expose(ProgramRuntimeService.class);\n\n    // For binding DataSet transaction stuff\n    install(new DataFabricFacadeModule());\n\n    // For Binding queue stuff\n    install(new FactoryModuleBuilder()\n              .implement(QueueReader.class, SingleQueue2Reader.class)\n              .build(QueueReaderFactory.class));\n\n    // Create webapp http handler factory.\n    install(new FactoryModuleBuilder().implement(HttpHandler.class, IntactJarHttpHandler.class)\n              .build(WebappHttpHandlerFactory.class));\n  }","id":87448,"modified_method":"/**\n   * Configures a {@link com.google.inject.Binder} via the exposed methods.\n   */\n  @Override\n  protected void configure() {\n\n    // Bind and expose LogWriter (a bit hacky, but needed by MapReduce for now)\n    bind(LogWriter.class).to(LocalLogWriter.class);\n    expose(LogWriter.class);\n\n    // Bind ServiceAnnouncer for procedure.\n    bind(ServiceAnnouncer.class).to(DiscoveryServiceAnnouncer.class);\n\n    // Bind ProgramRunner\n    MapBinder<ProgramRunnerFactory.Type, ProgramRunner> runnerFactoryBinder =\n      MapBinder.newMapBinder(binder(), ProgramRunnerFactory.Type.class, ProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOW).to(FlowProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOWLET).to(FlowletProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.PROCEDURE).to(ProcedureProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.MAPREDUCE).to(MapReduceProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.WORKFLOW).to(WorkflowProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.WEBAPP).to(WebappProgramRunner.class);\n\n    bind(ProgramRunnerFactory.class).to(InMemoryFlowProgramRunnerFactory.class).in(Scopes.SINGLETON);\n    // Note: Expose for test cases. Need to refactor test cases.\n    expose(ProgramRunnerFactory.class);\n\n    // Bind and expose runtime service\n    bind(ProgramRuntimeService.class).to(InMemoryProgramRuntimeService.class).in(Scopes.SINGLETON);\n    expose(ProgramRuntimeService.class);\n\n    // For binding DataSet transaction stuff\n    install(new DataFabricFacadeModule());\n\n    // For Binding queue stuff\n    install(new FactoryModuleBuilder()\n              .implement(QueueReader.class, SingleQueue2Reader.class)\n              .build(QueueReaderFactory.class));\n\n    // Create webapp http handler factory.\n    install(new FactoryModuleBuilder().implement(JarHttpHandler.class, IntactJarHttpHandler.class)\n              .build(WebappHttpHandlerFactory.class));\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"@GET\n  @Path(\"/.*\")\n  public void serve(HttpRequest request, HttpResponder responder) {\n    try {\n\n      if (request.getUri().equals(\"/status\")) {\n        responder.sendString(HttpResponseStatus.OK, \"OK\\n\");\n        return;\n      }\n\n      String hostHeader = HttpHeaders.getHost(request);\n      if (hostHeader == null) {\n        responder.sendStatus(HttpResponseStatus.BAD_REQUEST);\n      }\n\n      String path = servePathGenerator.getServePath(hostHeader, request.getUri());\n      if (path == null) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      byte [] bytes = jarResources.getResource(path);\n\n      if (bytes == null) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      String contentType = URLConnection.guessContentTypeFromStream(new ByteArrayInputStream(bytes));\n\n      ImmutableMultimap<String, String> headers = ImmutableMultimap.of();\n      if (contentType != null) {\n        headers = ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE, contentType);\n      }\n      responder.sendByteArray(HttpResponseStatus.OK, bytes, headers);\n\n    } catch (Throwable t) {\n      LOG.error(\"Got exception: \", t);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","id":87449,"modified_method":"@GET\n  @Path(\"/.*\")\n  public void serve(HttpRequest request, HttpResponder responder) {\n    try {\n      String path = request.getUri();\n      if (path == null) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      if (path.startsWith(\"/\") && path.length() > 1) {\n        path = path.substring(1);\n      }\n\n      byte [] bytes = jarResources.getResource(path);\n\n      if (bytes == null) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n        return;\n      }\n\n      responder.sendByteArray(HttpResponseStatus.OK, bytes,\n                              ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE,\n                                                   mimeTypesMap.getContentType(path)));\n\n    } catch (Throwable t) {\n      LOG.error(\"Got exception: \", t);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Bootstrap the pipeline.\n   * <ul>\n   *   <li>Create Execution handler<\/li>\n   *   <li>Setup Http resource handler<\/li>\n   *   <li>Setup the netty pipeline<\/li>\n   * <\/ul>\n   *\n   * @param threadPoolSize Size of threadpool in threadpoolExecutor\n   * @param threadKeepAliveSecs  maximum time that excess idle threads will wait for new tasks before terminating.\n   * @param httpHandlers Handlers for httpRequests.\n   */\n  private void bootStrap(int threadPoolSize, long threadKeepAliveSecs, Iterable<HttpHandler> httpHandlers){\n\n    final ExecutionHandler executionHandler = createExecutionHandler(threadPoolSize, threadKeepAliveSecs);\n\n    Executor bossExecutor = Executors.newFixedThreadPool(bossThreadPoolSize,\n                                                         new ThreadFactoryBuilder()\n                                                           .setDaemon(true)\n                                                           .setNameFormat(\"boss-thread\")\n                                                           .build());\n\n    Executor workerExecutor = Executors.newFixedThreadPool(workerThreadPoolSize, new ThreadFactoryBuilder()\n                                                                                        .setDaemon(true)\n                                                                                        .setNameFormat(\"worker-thread\")\n                                                                                        .build());\n\n    //Server bootstrap with default worker threads (2 * number of cores)\n    bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(bossExecutor, bossThreadPoolSize,\n                                                                      workerExecutor, workerThreadPoolSize));\n    bootstrap.setOption(\"backlog\", connectionBacklog);\n\n    resourceHandler = new HttpResourceHandler(httpHandlers, handlerHooks);\n    resourceHandler.init(handlerContext);\n\n    final ChannelUpstreamHandler connectionTracker =  new SimpleChannelUpstreamHandler() {\n                                                  @Override\n                                                  public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)\n                                                    throws Exception {\n                                                    channelGroup.add(e.getChannel());\n                                                    super.handleUpstream(ctx, e);\n                                                  }\n                                                };\n\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n      @Override\n      public ChannelPipeline getPipeline() throws Exception {\n        ChannelPipeline pipeline = Channels.pipeline();\n\n        pipeline.addLast(\"tracker\", connectionTracker);\n        pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n        pipeline.addLast(\"aggregator\", new HttpChunkAggregator(MAX_INPUT_SIZE));\n        pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n        pipeline.addLast(\"compressor\", new HttpContentCompressor());\n        pipeline.addLast(\"executor\", executionHandler);\n        //TODO: Add chunker\n        pipeline.addLast(\"dispatcher\", new HttpDispatcher(resourceHandler));\n\n        return pipeline;\n      }\n    });\n  }","id":87450,"modified_method":"/**\n   * Bootstrap the pipeline.\n   * <ul>\n   *   <li>Create Execution handler<\/li>\n   *   <li>Setup Http resource handler<\/li>\n   *   <li>Setup the netty pipeline<\/li>\n   * <\/ul>\n   *\n   * @param threadPoolSize Size of threadpool in threadpoolExecutor\n   * @param threadKeepAliveSecs  maximum time that excess idle threads will wait for new tasks before terminating.\n   * @param httpHandlers Handlers for httpRequests.\n   */\n  private void bootStrap(int threadPoolSize, long threadKeepAliveSecs, Iterable<HttpHandler> httpHandlers){\n\n    final ExecutionHandler executionHandler = createExecutionHandler(threadPoolSize, threadKeepAliveSecs);\n\n    Executor bossExecutor = Executors.newFixedThreadPool(bossThreadPoolSize,\n                                                         new ThreadFactoryBuilder()\n                                                           .setDaemon(true)\n                                                           .setNameFormat(\"boss-thread\")\n                                                           .build());\n\n    Executor workerExecutor = Executors.newFixedThreadPool(workerThreadPoolSize, new ThreadFactoryBuilder()\n                                                                                        .setDaemon(true)\n                                                                                        .setNameFormat(\"worker-thread\")\n                                                                                        .build());\n\n    //Server bootstrap with default worker threads (2 * number of cores)\n    bootstrap = new ServerBootstrap(new NioServerSocketChannelFactory(bossExecutor, bossThreadPoolSize,\n                                                                      workerExecutor, workerThreadPoolSize));\n    bootstrap.setOption(\"backlog\", connectionBacklog);\n\n    resourceHandler = new HttpResourceHandler(httpHandlers, handlerHooks, urlRewriter);\n    resourceHandler.init(handlerContext);\n\n    final ChannelUpstreamHandler connectionTracker =  new SimpleChannelUpstreamHandler() {\n                                                  @Override\n                                                  public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)\n                                                    throws Exception {\n                                                    channelGroup.add(e.getChannel());\n                                                    super.handleUpstream(ctx, e);\n                                                  }\n                                                };\n\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() {\n      @Override\n      public ChannelPipeline getPipeline() throws Exception {\n        ChannelPipeline pipeline = Channels.pipeline();\n\n        pipeline.addLast(\"tracker\", connectionTracker);\n        pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n        pipeline.addLast(\"aggregator\", new HttpChunkAggregator(MAX_INPUT_SIZE));\n        pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n        pipeline.addLast(\"compressor\", new HttpContentCompressor());\n        pipeline.addLast(\"executor\", executionHandler);\n        //TODO: Add chunker\n        pipeline.addLast(\"dispatcher\", new HttpDispatcher(resourceHandler));\n\n        return pipeline;\n      }\n    });\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"public NettyHttpService build() {\n      InetSocketAddress bindAddress;\n      if (host == null) {\n        bindAddress = new InetSocketAddress(\"localhost\", port);\n      } else {\n        bindAddress = new InetSocketAddress(host, port);\n      }\n\n      return new NettyHttpService(bindAddress, bossThreadPoolSize, workerThreadPoolSize, connectionBacklog,\n                                  execThreadPoolSize, execThreadKeepAliveSecs, rejectedExecutionHandler,\n                                  handlers, handlerHooks);\n    }","id":87451,"modified_method":"public NettyHttpService build() {\n      InetSocketAddress bindAddress;\n      if (host == null) {\n        bindAddress = new InetSocketAddress(\"localhost\", port);\n      } else {\n        bindAddress = new InetSocketAddress(host, port);\n      }\n\n      return new NettyHttpService(bindAddress, bossThreadPoolSize, workerThreadPoolSize, connectionBacklog,\n                                  execThreadPoolSize, execThreadKeepAliveSecs, rejectedExecutionHandler,\n                                  urlRewriter, handlers, handlerHooks);\n    }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Initialize NettyHttpService.\n   *\n   * @param bindAddress Address for the service to bind to.\n   * @param bossThreadPoolSize Size of the boss thread pool.\n   * @param workerThreadPoolSize Size of the worker thread pool.\n   * @param connectionBacklog Max concurrent connections that can be queued.\n   * @param execThreadPoolSize Size of the thread pool for the executor.\n   * @param execThreadKeepAliveSecs  maximum time that excess idle threads will wait for new tasks before terminating.\n   * @param rejectedExecutionHandler rejection policy for executor.\n   * @param httpHandlers HttpHandlers to handle the calls.\n   */\n  public NettyHttpService(InetSocketAddress bindAddress, int bossThreadPoolSize, int workerThreadPoolSize,\n                          int connectionBacklog,\n                          int execThreadPoolSize, long execThreadKeepAliveSecs,\n                          RejectedExecutionHandler rejectedExecutionHandler,\n                          Iterable<? extends HttpHandler> httpHandlers,\n                          Iterable<? extends HandlerHook> handlerHooks){\n    this.bindAddress = bindAddress;\n    this.bossThreadPoolSize = bossThreadPoolSize;\n    this.workerThreadPoolSize = workerThreadPoolSize;\n    this.connectionBacklog = connectionBacklog;\n    this.execThreadPoolSize = execThreadPoolSize;\n    this.execThreadKeepAliveSecs = execThreadKeepAliveSecs;\n    this.rejectedExecutionHandler = rejectedExecutionHandler;\n    this.httpHandlers = ImmutableSet.copyOf(httpHandlers);\n    this.handlerContext = new DummyHandlerContext();\n    this.channelGroup = new DefaultChannelGroup();\n    this.handlerHooks = ImmutableList.copyOf(handlerHooks);\n  }","id":87452,"modified_method":"/**\n   * Initialize NettyHttpService.\n   *\n   * @param bindAddress Address for the service to bind to.\n   * @param bossThreadPoolSize Size of the boss thread pool.\n   * @param workerThreadPoolSize Size of the worker thread pool.\n   * @param connectionBacklog Max concurrent connections that can be queued.\n   * @param execThreadPoolSize Size of the thread pool for the executor.\n   * @param execThreadKeepAliveSecs  maximum time that excess idle threads will wait for new tasks before terminating.\n   * @param rejectedExecutionHandler rejection policy for executor.\n   * @param urlRewriter UrlRewriter to rewrite incoming URLs.\n   * @param httpHandlers HttpHandlers to handle the calls.\n   * @param handlerHooks Hooks to be called before/after request processing by httpHandlers.\n   */\n  public NettyHttpService(InetSocketAddress bindAddress, int bossThreadPoolSize, int workerThreadPoolSize,\n                          int connectionBacklog,\n                          int execThreadPoolSize, long execThreadKeepAliveSecs,\n                          RejectedExecutionHandler rejectedExecutionHandler, UrlRewriter urlRewriter,\n                          Iterable<? extends HttpHandler> httpHandlers,\n                          Iterable<? extends HandlerHook> handlerHooks){\n    this.bindAddress = bindAddress;\n    this.bossThreadPoolSize = bossThreadPoolSize;\n    this.workerThreadPoolSize = workerThreadPoolSize;\n    this.connectionBacklog = connectionBacklog;\n    this.execThreadPoolSize = execThreadPoolSize;\n    this.execThreadKeepAliveSecs = execThreadKeepAliveSecs;\n    this.rejectedExecutionHandler = rejectedExecutionHandler;\n    this.urlRewriter = urlRewriter;\n    this.httpHandlers = ImmutableSet.copyOf(httpHandlers);\n    this.handlerContext = new DummyHandlerContext();\n    this.channelGroup = new DefaultChannelGroup();\n    this.handlerHooks = ImmutableList.copyOf(handlerHooks);\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testPathRoutings(){\n\n    PatternPathRouterWithGroups<String> pathRouter = new PatternPathRouterWithGroups();\n    pathRouter.add(\"/foo/{baz}/b\", \"foobarb\");\n    pathRouter.add(\"/foo/bar/baz\", \"foobarbaz\");\n    pathRouter.add(\"/baz/bar\", \"bazbar\");\n    pathRouter.add(\"/bar\", \"bar\");\n    pathRouter.add(\"/foo/bar\", \"foobar\");\n    pathRouter.add(\"//multiple/slash//route\", \"multipleslashroute\");\n\n    Map<String, String> emptyGroupValues = Maps.newHashMap();\n    Map<String, String> groupValues = Maps.newHashMap();\n\n    List<String> routes = Lists.newArrayList();\n\n    routes = pathRouter.getDestinations(\"/foo/bar/baz\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"foobarbaz\", routes.get(0));\n    assertEquals(0, emptyGroupValues.size());\n\n    routes = pathRouter.getDestinations(\"/baz/bar\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"bazbar\", routes.get(0));\n\n    routes = pathRouter.getDestinations(\"/foo/bar/baz/moo\", emptyGroupValues);\n    assertEquals(0, routes.size());\n\n    routes = pathRouter.getDestinations(\"/bar/121\", emptyGroupValues);\n    assertEquals(0, routes.size());\n\n    routes = pathRouter.getDestinations(\"/foo/bar/b\", groupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"foobarb\", routes.get(0));\n    assertEquals(1, groupValues.size());\n    assertEquals(\"bar\", groupValues.get(\"baz\"));\n\n    routes = pathRouter.getDestinations(\"/foo/bar\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"foobar\", routes.get(0));\n\n    routes = pathRouter.getDestinations(\"/multiple/slash/route\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"multipleslashroute\", routes.get(0));\n\n\n    routes = pathRouter.getDestinations(\"/foo/bar/bazooka\", emptyGroupValues);\n    assertEquals(0, routes.size());\n  }","id":87453,"modified_method":"@Test\n  public void testPathRoutings(){\n\n    PatternPathRouterWithGroups<String> pathRouter = new PatternPathRouterWithGroups<String>();\n    pathRouter.add(\"/foo/{baz}/b\", \"foobarb\");\n    pathRouter.add(\"/foo/bar/baz\", \"foobarbaz\");\n    pathRouter.add(\"/baz/bar\", \"bazbar\");\n    pathRouter.add(\"/bar\", \"bar\");\n    pathRouter.add(\"/foo/bar\", \"foobar\");\n    pathRouter.add(\"//multiple/slash//route\", \"multipleslashroute\");\n\n    pathRouter.add(\"/multi/match/.*\", \"multi-match-*\");\n    pathRouter.add(\"/multi/match/def\", \"multi-match-def\");\n\n    pathRouter.add(\"/multi/maxmatch/.*\", \"multi-max-match-*\");\n    pathRouter.add(\"/multi/maxmatch/{id}\", \"multi-max-match-id\");\n    pathRouter.add(\"/multi/maxmatch/foo\", \"multi-max-match-foo\");\n\n    Map<String, String> emptyGroupValues = Maps.newHashMap();\n    Map<String, String> groupValues = Maps.newHashMap();\n\n    List<String> routes;\n\n    routes = pathRouter.getDestinations(\"/foo/bar/baz\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"foobarbaz\", routes.get(0));\n    assertEquals(0, emptyGroupValues.size());\n\n    routes = pathRouter.getDestinations(\"/baz/bar\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"bazbar\", routes.get(0));\n\n    routes = pathRouter.getDestinations(\"/foo/bar/baz/moo\", emptyGroupValues);\n    assertEquals(0, routes.size());\n\n    routes = pathRouter.getDestinations(\"/bar/121\", emptyGroupValues);\n    assertEquals(0, routes.size());\n\n    routes = pathRouter.getDestinations(\"/foo/bar/b\", groupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"foobarb\", routes.get(0));\n    assertEquals(1, groupValues.size());\n    assertEquals(\"bar\", groupValues.get(\"baz\"));\n\n    routes = pathRouter.getDestinations(\"/foo/bar\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"foobar\", routes.get(0));\n\n    routes = pathRouter.getDestinations(\"/multiple/slash/route\", emptyGroupValues);\n    assertEquals(1, routes.size());\n    assertEquals(\"multipleslashroute\", routes.get(0));\n\n    routes = pathRouter.getDestinations(\"/foo/bar/bazooka\", emptyGroupValues);\n    assertEquals(0, routes.size());\n\n    routes = pathRouter.getDestinations(\"/multi/match/def\", emptyGroupValues);\n    assertEquals(ImmutableSet.of(\"multi-match-def\"), ImmutableSet.copyOf(routes));\n\n    routes = pathRouter.getDestinations(\"/multi/match/ghi\", emptyGroupValues);\n    assertEquals(ImmutableSet.of(\"multi-match-*\"), ImmutableSet.copyOf(routes));\n\n    routes = pathRouter.getDestinations(\"/multi/maxmatch/id1\", groupValues);\n    assertEquals(ImmutableSet.of(\"multi-max-match-id\"), ImmutableSet.copyOf(routes));\n    assertEquals(ImmutableMap.of(\"id\", \"id1\"), groupValues);\n\n    routes = pathRouter.getDestinations(\"/multi/maxmatch/foo\", groupValues);\n    assertEquals(ImmutableSet.of(\"multi-max-match-id\"), ImmutableSet.copyOf(routes));\n    assertEquals(ImmutableMap.of(\"id\", \"foo\"), groupValues);\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Add a source and destination.\n   *\n   * @param source  Source path to be routed. Routed path can have named wild-card pattern with braces \"{}\".\n   * @param destination Destination of the path.\n   */\n  public void add(final String source, final T destination){\n\n    // replace multiple slashes with a single slash.\n    String cleanSource = source.replaceAll(\"(/)+\", \"/\");\n\n    String path = (source.endsWith(\"/\")) ? cleanSource.substring(0, cleanSource.length() - 1) :\n                                           cleanSource;\n\n    String [] parts = path.split(\"/\");\n    StringBuilder sb =  new StringBuilder();\n    List<String> groupNames = Lists.newArrayList();\n\n    for (String part : parts){\n      Matcher matcher = groupPattern.matcher(part);\n      if (matcher.matches()) {\n        groupNames.add(matcher.group(1));\n        sb.append(\"([^/]+?)\");\n      } else {\n        sb.append(part);\n      }\n      sb.append(\"/\");\n    }\n\n    //Ignore the last \"/\"\n    sb.setLength(sb.length() - 1);\n\n    Pattern pattern = Pattern.compile(sb.toString());\n    patternRouteList.add(new ImmutablePair<Pattern,\n      RouteDestinationWithGroups<T>>(pattern, new RouteDestinationWithGroups<T>(destination, groupNames)));\n  }","id":87454,"modified_method":"/**\n   * Add a source and destination.\n   *\n   * @param source  Source path to be routed. Routed path can have named wild-card pattern with braces \"{}\".\n   * @param destination Destination of the path.\n   */\n  public void add(final String source, final T destination){\n\n    // replace multiple slashes with a single slash.\n    String cleanSource = source.replaceAll(\"/+\", \"/\");\n\n    String path = (source.endsWith(\"/\") && source.length() > 1) ?\n      cleanSource.substring(0, cleanSource.length() - 1) :cleanSource;\n\n    String [] parts = path.split(\"/\");\n    StringBuilder sb =  new StringBuilder();\n    List<String> groupNames = Lists.newArrayList();\n\n    for (String part : parts){\n      Matcher matcher = groupPattern.matcher(part);\n      if (matcher.matches()) {\n        groupNames.add(matcher.group(1));\n        sb.append(\"([^/]+?)\");\n      } else {\n        sb.append(part);\n      }\n      sb.append(\"/\");\n    }\n\n    //Ignore the last \"/\"\n    sb.setLength(sb.length() - 1);\n\n    Pattern pattern = Pattern.compile(sb.toString());\n    patternRouteList.add(new ImmutablePair<Pattern,\n      RouteDestinationWithGroups<T>>(pattern, new RouteDestinationWithGroups<T>(destination, groupNames)));\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Get a list of destinations and the values matching templated parameter for the given path.\n   * Returns an empty list when there are no destinations that are matched.\n   *\n   * @param path path to be routed.\n   * @param groupNameValues Map of templated parameter and string representation group value matching the\n   *                        templated parameter as the value.\n   * @return List of Destinations matching the given route.\n   */\n  public List<T> getDestinations(final String path, final Map<String, String> groupNameValues){\n\n    // replace multiple slashes with a single slash.\n    String cleanPath = path.replaceAll(\"(/)+\", \"/\");\n\n    // TODO: Clean up the return type.\n    List<T> result = Lists.newArrayList();\n    for (ImmutablePair<Pattern, RouteDestinationWithGroups<T>> patternRoute : patternRouteList) {\n      Matcher matcher =  patternRoute.getFirst().matcher(cleanPath);\n      if (matcher.matches()){\n        int matchIndex = 1;\n        for (String name : patternRoute.getSecond().getGroupNames()){\n          String value = matcher.group(matchIndex);\n          groupNameValues.put(name, value);\n          matchIndex++;\n        }\n        result.add(patternRoute.getSecond().getDestination());\n      }\n    }\n    return result;\n  }","id":87455,"modified_method":"/**\n   * Get a list of destinations and the values matching templated parameter for the given path.\n   * Returns an empty list when there are no destinations that are matched.\n   *\n   * @param path path to be routed.\n   * @param groupNameValues Map of templated parameter and string representation group value matching the\n   *                        templated parameter as the value.\n   * @return List of Destinations matching the given route.\n   */\n  public List<T> getDestinations(final String path, final Map<String, String> groupNameValues){\n\n    // replace multiple slashes with a single slash.\n    String cleanPath = path.replaceAll(\"/+\", \"/\");\n\n    cleanPath = (cleanPath.endsWith(\"/\") && cleanPath.length() > 1)\n      ? cleanPath.substring(0, cleanPath.length() - 1) : cleanPath;\n\n    // TODO: Clean up the return type.\n    List<T> result = Lists.newArrayList();\n    int maxMatch = 0;\n    int maxPatternLength = 0;\n\n    for (ImmutablePair<Pattern, RouteDestinationWithGroups<T>> patternRoute : patternRouteList) {\n      Matcher matcher =  patternRoute.getFirst().matcher(cleanPath);\n\n      if (matcher.matches() && matcher.groupCount() >= maxMatch) {\n        if (matcher.groupCount() > maxMatch || matcher.pattern().pattern().length() > maxPatternLength) {\n          result.clear();\n          groupNameValues.clear();\n          maxMatch = matcher.groupCount();\n          maxPatternLength = matcher.pattern().pattern().length();\n        }\n\n        int matchIndex = 1;\n        for (String name : patternRoute.getSecond().getGroupNames()){\n          String value = matcher.group(matchIndex);\n          groupNameValues.put(name, value);\n          matchIndex++;\n        }\n\n        result.add(patternRoute.getSecond().getDestination());\n      }\n    }\n    return result;\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Returns the discoverable mapped to the given port.\n     *\n     * @param port port to lookup.\n     * @param hostHeaderSupplier supplies the header information for the lookup.\n     * @return discoverable based on port and host header.\n     */\n  public Discoverable getDiscoverable(int port, Supplier<HeaderDecoder.HeaderInfo> hostHeaderSupplier)\n    throws Exception {\n    final String service = serviceMapRef.get().get(port);\n    if (service == null) {\n      LOG.debug(\"No service found for port {}\", port);\n      return null;\n    }\n\n    Discoverable discoverable;\n    if (service.contains(\"$HOST\")) {\n      HeaderDecoder.HeaderInfo headerInfo = hostHeaderSupplier.get();\n      if (headerInfo == null) {\n        LOG.debug(\"Cannot find host header for service {} on port {}\", service, port);\n        return null;\n      }\n\n      // Route gateway URLs to gateway.\n      if (headerInfo.getPath().startsWith(GATEWAY_URL_PREFIX)) {\n        discoverable = discover(Constants.Service.GATEWAY);\n      } else {\n        // Route other URLs to host in the header.\n        discoverable = discoverService(service, headerInfo);\n\n        if (discoverable == null) {\n          // Now try default, this matches any host / any port in the host header.\n          discoverable = discoverDefaultService(service, headerInfo);\n        }\n\n        if (discoverable == null) {\n          LOG.error(\"No discoverable endpoints found for service {} {}\", service, headerInfo);\n        }\n      }\n    } else {\n      discoverable = discover(service);\n\n      if (discoverable == null) {\n        LOG.error(\"No discoverable endpoints found for service {}\", service);\n      }\n    }\n\n    return discoverable;\n  }","id":87456,"modified_method":"/**\n     * Returns the discoverable mapped to the given port.\n     *\n     * @param port port to lookup.\n     * @param hostHeaderSupplier supplies the header information for the lookup.\n     * @return discoverable based on port and host header.\n     */\n  public Discoverable getDiscoverable(int port, Supplier<HeaderDecoder.HeaderInfo> hostHeaderSupplier)\n    throws Exception {\n    final String service = serviceMapRef.get().get(port);\n    if (service == null) {\n      LOG.debug(\"No service found for port {}\", port);\n      return null;\n    }\n\n    Discoverable discoverable;\n    if (service.contains(\"$HOST\")) {\n      HeaderDecoder.HeaderInfo headerInfo = hostHeaderSupplier.get();\n      if (headerInfo == null) {\n        LOG.debug(\"Cannot find host header for service {} on port {}\", service, port);\n        return null;\n      }\n\n      // Route URLs to host in the header.\n      discoverable = discoverService(service, headerInfo);\n\n      if (discoverable == null) {\n        // Now try default, this matches any host / any port in the host header.\n        discoverable = discoverDefaultService(service, headerInfo);\n      }\n\n      if (discoverable == null) {\n        LOG.error(\"No discoverable endpoints found for service {} {}\", service, headerInfo);\n      }\n    } else {\n      discoverable = discover(service);\n\n      if (discoverable == null) {\n        LOG.error(\"No discoverable endpoints found for service {}\", service);\n      }\n    }\n\n    return discoverable;\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"public String getServePath(String hostHeader, String path) {\n    if (path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n\n    if (path.endsWith(\"/\")) {\n      path = path.substring(0, path.length() - 1);\n    }\n\n    // If exact match present, return it\n    String servePath = findPath(hostHeader, path);\n    if (servePath != null) {\n      return servePath;\n    }\n\n    boolean isDefaultPort = hostHeader.endsWith(DEFAULT_PORT_STR);\n    boolean hasNoPort = hostHeader.indexOf(':') == -1;\n\n    // Strip DEFAULT_PORT_STR and try again\n    if (isDefaultPort) {\n      servePath = findPath(hostHeader.substring(0, hostHeader.length() - DEFAULT_PORT_STR.length()), path);\n      if (servePath != null) {\n        return servePath;\n      }\n    }\n\n    // Add DEFAULT_PORT_STR and try\n    if (hasNoPort) {\n      servePath = findPath(hostHeader + DEFAULT_PORT_STR, path);\n      if (servePath != null) {\n        return servePath;\n      }\n    }\n\n    // Else if \"default\" is present, that is the serve dir\n    servePath = findPath(DEFAULT_DIR_NAME, path);\n    if (servePath != null) {\n      return servePath;\n    }\n\n    return null;\n  }","id":87457,"modified_method":"public String getServePath(String hostHeader, String path) {\n    if (path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n\n    if (path.endsWith(\"/\")) {\n      path = path.substring(0, path.length() - 1);\n    }\n\n    // If exact match present, return it\n    String servePath = findPath(hostHeader, path);\n    if (servePath != null) {\n      return \"/\" + servePath;\n    }\n\n    boolean isDefaultPort = hostHeader.endsWith(DEFAULT_PORT_STR);\n    boolean hasNoPort = hostHeader.indexOf(':') == -1;\n\n    // Strip DEFAULT_PORT_STR and try again\n    if (isDefaultPort) {\n      servePath = findPath(hostHeader.substring(0, hostHeader.length() - DEFAULT_PORT_STR.length()), path);\n      if (servePath != null) {\n        return \"/\" + servePath;\n      }\n    }\n\n    // Add DEFAULT_PORT_STR and try\n    if (hasNoPort) {\n      servePath = findPath(hostHeader + DEFAULT_PORT_STR, path);\n      if (servePath != null) {\n        return \"/\" + servePath;\n      }\n    }\n\n    // Else if \"default\" is present, that is the serve dir\n    servePath = findPath(DEFAULT_DIR_NAME, path);\n    if (servePath != null) {\n      return \"/\" + servePath;\n    }\n\n    return \"/\" + path;\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"private String findPath(String hostHeader, String path) {\n    // First try firstPathPart/src/restPath\n    Iterable<String> pathParts = Splitter.on('/').limit(2).split(path);\n    String servePath;\n    if (Iterables.size(pathParts) > 1) {\n      servePath = String.format(\"%s/%s/%s%s%s\", baseDir, hostHeader,\n                                       Iterables.get(pathParts, 0), SRC_PATH, Iterables.get(pathParts, 1));\n      if (fileExists.apply(servePath)) {\n        return servePath;\n      }\n\n    } else if (Iterables.size(pathParts) == 1) {\n      servePath = String.format(\"%s/%s/%s%s%s\", baseDir, hostHeader,\n                                Iterables.get(pathParts, 0), SRC_PATH, \"index.html\");\n      if (fileExists.apply(servePath)) {\n        return servePath;\n      }\n    }\n\n    // Next try src/path\n    path = path.isEmpty() ? \"index.html\" : path;\n    servePath = String.format(\"%s/%s%s%s\", baseDir, hostHeader, SRC_PATH, path);\n    if (fileExists.apply(servePath)) {\n      return servePath;\n    }\n\n    return null;\n  }","id":87458,"modified_method":"private String findPath(String hostHeader, String path) {\n    // First try firstPathPart/src/restPath\n    Iterable<String> pathParts = Splitter.on('/').limit(2).split(path);\n    String servePath;\n    if (Iterables.size(pathParts) > 1) {\n      String pathPart1 = Iterables.get(pathParts, 1);\n      if (pathPart1.startsWith(GATEWAY_PATH) || pathPart1.equals(\"status\")) {\n        return pathPart1;\n      }\n\n      servePath = String.format(\"%s/%s/%s%s%s\", baseDir, hostHeader,\n                                       Iterables.get(pathParts, 0), SRC_PATH, Iterables.get(pathParts, 1));\n      if (fileExists.apply(servePath)) {\n        return servePath;\n      }\n\n    } else if (Iterables.size(pathParts) == 1) {\n      servePath = String.format(\"%s/%s/%s%s%s\", baseDir, hostHeader,\n                                Iterables.get(pathParts, 0), SRC_PATH, \"index.html\");\n      if (fileExists.apply(servePath)) {\n        return servePath;\n      }\n    }\n\n    // Next try src/path\n    if (path.startsWith(GATEWAY_PATH) || path.equals(\"status\")) {\n      return path;\n    }\n\n    path = path.isEmpty() ? \"index.html\" : path;\n    servePath = String.format(\"%s/%s%s%s\", baseDir, hostHeader, SRC_PATH, path);\n    if (fileExists.apply(servePath)) {\n      return servePath;\n    }\n\n    return null;\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGetServePath() throws Exception {\n    URL jarUrl = getClass().getResource(\"/CountRandomWebapp-localhost.jar\");\n    Assert.assertNotNull(jarUrl);\n\n    final JarResources jarResources = new JarResources(new LocalLocationFactory().create(jarUrl.toURI()));\n    Predicate<String> fileExists = new Predicate<String>() {\n      @Override\n      public boolean apply(@Nullable String file) {\n        return file != null && jarResources.getResource(file) != null;\n      }\n    };\n\n    ServePathGenerator servePathGenerator = new ServePathGenerator(Constants.Webapp.WEBAPP_DIR, fileExists);\n\n    Assert.assertEquals(\"webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens\"));\n\n    Assert.assertEquals(\"webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens/index.html\"));\n\n    Assert.assertEquals(\"webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens/\"));\n\n    Assert.assertEquals(\"webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens/\"));\n\n    Assert.assertEquals(\"webapp/default/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:30000\", \"/\"));\n\n    Assert.assertEquals(\"webapp/default/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:30000\", \"/index.html\"));\n\n    Assert.assertEquals(\"webapp/127.0.0.1:20000/src/netlens/2.txt\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"netlens/2.txt\"));\n\n    Assert.assertEquals(\"webapp/default/netlens/src/1.txt\",\n                        servePathGenerator.getServePath(\"127.0.0.1:80\", \"/netlens/1.txt\"));\n\n    Assert.assertEquals(\"webapp/default/netlens/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"127.0.0.1:30000\", \"/netlens/data/data.txt\"));\n\n\n    servePathGenerator = new ServePathGenerator(Constants.Webapp.WEBAPP_DIR + \"/\", fileExists);\n    Assert.assertEquals(\"webapp/www.abc.com:80/geo/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"www.abc.com\", \"/geo/data/data.txt\"));\n\n    Assert.assertEquals(\"webapp/www.abc.com:80/geo/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"www.abc.com:80\", \"/geo/data/data.txt\"));\n\n    Assert.assertNull(servePathGenerator.getServePath(\"www.abc.com:30000\", \"/geo/data/data.txt\"));\n\n    Assert.assertEquals(\"webapp/default/netlens/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"www.abc.com:30000\", \"/netlens/data/data.txt\"));\n  }","id":87459,"modified_method":"@Test\n  public void testGetServePath() throws Exception {\n    URL jarUrl = getClass().getResource(\"/CountRandomWebapp-localhost.jar\");\n    Assert.assertNotNull(jarUrl);\n\n    final JarResources jarResources = new JarResources(new LocalLocationFactory().create(jarUrl.toURI()));\n    Predicate<String> fileExists = new Predicate<String>() {\n      @Override\n      public boolean apply(@Nullable String file) {\n        return file != null && jarResources.getResource(file) != null;\n      }\n    };\n\n    ServePathGenerator servePathGenerator = new ServePathGenerator(Constants.Webapp.WEBAPP_DIR, fileExists);\n\n    Assert.assertEquals(\"/webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens\"));\n\n    Assert.assertEquals(\"/webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens/index.html\"));\n\n    Assert.assertEquals(\"/webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens/\"));\n\n    Assert.assertEquals(\"/webapp/127.0.0.1:20000/netlens/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"/netlens/\"));\n\n    Assert.assertEquals(\"/webapp/default/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:30000\", \"/\"));\n\n    Assert.assertEquals(\"/webapp/default/src/index.html\",\n                        servePathGenerator.getServePath(\"127.0.0.1:30000\", \"/index.html\"));\n\n    Assert.assertEquals(\"/webapp/127.0.0.1:20000/src/netlens/2.txt\",\n                        servePathGenerator.getServePath(\"127.0.0.1:20000\", \"netlens/2.txt\"));\n\n    Assert.assertEquals(\"/webapp/default/netlens/src/1.txt\",\n                        servePathGenerator.getServePath(\"127.0.0.1:80\", \"/netlens/1.txt\"));\n\n    Assert.assertEquals(\"/webapp/default/netlens/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"127.0.0.1:30000\", \"/netlens/data/data.txt\"));\n\n\n    servePathGenerator = new ServePathGenerator(Constants.Webapp.WEBAPP_DIR + \"/\", fileExists);\n    Assert.assertEquals(\"/webapp/www.abc.com:80/geo/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"www.abc.com\", \"/geo/data/data.txt\"));\n\n    Assert.assertEquals(\"/webapp/www.abc.com:80/geo/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"www.abc.com:80\", \"/geo/data/data.txt\"));\n\n    Assert.assertNull(servePathGenerator.getServePath(\"www.abc.com:30000\", \"/geo/data/data.txt\"));\n\n    Assert.assertEquals(\"/webapp/default/netlens/src/data/data.txt\",\n                        servePathGenerator.getServePath(\"www.abc.com:30000\", \"/netlens/data/data.txt\"));\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public ProgramController run(Program program, ProgramOptions options) {\n    try {\n\n      Type processorType = program.getType();\n      Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n      Preconditions.checkArgument(processorType == Type.WEBAPP, \"Only WEBAPP process type is supported.\");\n\n      LOG.info(\"Initializing web app for app {} with jar {}\", program.getApplicationId(),\n               program.getJarLocation().getName());\n\n      String serviceName = getServiceName(Type.WEBAPP, program);\n      Preconditions.checkNotNull(serviceName, \"Cannot determine service name for program %s\", program.getName());\n      LOG.info(\"Got service name {}\", serviceName);\n\n      // Start netty server\n      // TODO: add metrics reporting\n      NettyHttpService.Builder builder = NettyHttpService.builder();\n      builder.addHttpHandlers(ImmutableList.of(handlerFactory.createHandler(program.getJarLocation())));\n      builder.setHost(hostname.getCanonicalHostName());\n      NettyHttpService httpService = builder.build();\n      httpService.startAndWait();\n      final InetSocketAddress address = httpService.getBindAddress();\n\n      RunId runId = RunIds.generate();\n\n      // Register service, and the serving host names.\n      final List<Cancellable> cancellables = Lists.newArrayList();\n      LOG.info(\"Webapp {} running on address {} registering as {}\", program.getApplicationId(), address, serviceName);\n      cancellables.add(serviceAnnouncer.announce(serviceName, address.getPort()));\n\n      for (String hname : getServingHostNames(program.getJarLocation().getInputStream())) {\n        final String sname = Type.WEBAPP.name().toLowerCase() + \"/\" + hname;\n\n        LOG.info(\"Webapp {} running on address {} registering as {}\", program.getApplicationId(), address, sname);\n        cancellables.add(discoveryService.register(new Discoverable() {\n          @Override\n          public String getName() {\n            return sname;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return address;\n          }\n        }));\n      }\n\n      return new WebappProgramController(program.getName(), runId, httpService, new Cancellable() {\n        @Override\n        public void cancel() {\n          for (Cancellable cancellable : cancellables) {\n            cancellable.cancel();\n          }\n        }\n      });\n\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","id":87460,"modified_method":"@Override\n  public ProgramController run(Program program, ProgramOptions options) {\n    try {\n\n      Type processorType = program.getType();\n      Preconditions.checkNotNull(processorType, \"Missing processor type.\");\n      Preconditions.checkArgument(processorType == Type.WEBAPP, \"Only WEBAPP process type is supported.\");\n\n      LOG.info(\"Initializing web app for app {} with jar {}\", program.getApplicationId(),\n               program.getJarLocation().getName());\n\n      String serviceName = getServiceName(Type.WEBAPP, program);\n      Preconditions.checkNotNull(serviceName, \"Cannot determine service name for program %s\", program.getName());\n      LOG.info(\"Got service name {}\", serviceName);\n\n      // Start netty server\n      // TODO: add metrics reporting\n      JarHttpHandler jarHttpHandler = webappHttpHandlerFactory.createHandler(program.getJarLocation());\n      NettyHttpService.Builder builder = NettyHttpService.builder();\n      builder.addHttpHandlers(\n        Iterables.concat(handlers, ImmutableSet.of(jarHttpHandler)));\n      builder.setUrlRewriter(new WebappUrlRewriter(jarHttpHandler));\n      builder.setHost(hostname.getCanonicalHostName());\n      NettyHttpService httpService = builder.build();\n      httpService.startAndWait();\n      final InetSocketAddress address = httpService.getBindAddress();\n\n      RunId runId = RunIds.generate();\n\n      // Register service, and the serving host names.\n      final List<Cancellable> cancellables = Lists.newArrayList();\n      LOG.info(\"Webapp {} running on address {} registering as {}\", program.getApplicationId(), address, serviceName);\n      cancellables.add(serviceAnnouncer.announce(serviceName, address.getPort()));\n\n      for (String hname : getServingHostNames(program.getJarLocation().getInputStream())) {\n        final String sname = Type.WEBAPP.name().toLowerCase() + \"/\" + hname;\n\n        LOG.info(\"Webapp {} running on address {} registering as {}\", program.getApplicationId(), address, sname);\n        cancellables.add(discoveryService.register(new Discoverable() {\n          @Override\n          public String getName() {\n            return sname;\n          }\n\n          @Override\n          public InetSocketAddress getSocketAddress() {\n            return address;\n          }\n        }));\n      }\n\n      return new WebappProgramController(program.getName(), runId, httpService, new Cancellable() {\n        @Override\n        public void cancel() {\n          for (Cancellable cancellable : cancellables) {\n            cancellable.cancel();\n          }\n        }\n      });\n\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected Module createModule(WeaveContext context, ZKClientService zkClientService,\n                                KafkaClientService kafkaClientService) {\n    return Modules.combine(super.createModule(context, zkClientService, kafkaClientService),\n                           new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n                           new GatewayAuthModule(),\n                           new AppFabricGatewayModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               // Create webapp http handler factory.\n                               install(new FactoryModuleBuilder()\n                                         .implement(HttpHandler.class, ExplodeJarHttpHandler.class)\n                                         .build(WebappHttpHandlerFactory.class));\n                             }\n                           });\n  }","id":87461,"modified_method":"@Override\n  protected Module createModule(WeaveContext context, ZKClientService zkClientService,\n                                KafkaClientService kafkaClientService) {\n    return Modules.combine(super.createModule(context, zkClientService, kafkaClientService),\n                           new DiscoveryRuntimeModule(zkClientService).getDistributedModules(),\n                           new GatewayAuthModule(),\n                           new AppFabricGatewayModule(),\n                           new AbstractModule() {\n                             @Override\n                             protected void configure() {\n                               // Create webapp http handler factory.\n                               install(new FactoryModuleBuilder()\n                                         .implement(JarHttpHandler.class, ExplodeJarHttpHandler.class)\n                                         .build(WebappHttpHandlerFactory.class));\n                             }\n                           });\n  }","commit_id":"d2963393a6ee2820200b40e80a08a2c61d03d427","url":"https://github.com/caskdata/cdap"},{"original_method":"private void processingSqlBySettingAutoCommit(Exchange exchange) throws Exception {\n        String sql = exchange.getIn().getBody(String.class);\n        Connection conn = null;\n        Statement stmt = null;\n        ResultSet rs = null;\n        Boolean autoCommit = null;\n        try {\n            conn = dataSource.getConnection();\n            autoCommit = conn.getAutoCommit();\n            if (autoCommit) {\n                conn.setAutoCommit(false);\n            }\n\n            stmt = conn.createStatement();\n\n            if (parameters != null && !parameters.isEmpty()) {\n                IntrospectionSupport.setProperties(stmt, parameters);\n            }\n\n            LOG.debug(\"Executing JDBC statement: {}\", sql);\n\n            if (stmt.execute(sql)) {\n                rs = stmt.getResultSet();\n                setResultSet(exchange, rs);\n            } else {\n                int updateCount = stmt.getUpdateCount();\n                exchange.getOut().setHeader(JdbcConstants.JDBC_UPDATE_COUNT, updateCount);\n            }\n            conn.commit();\n        } catch (Exception e) {\n            try {\n                conn.rollback();\n            } catch (SQLException sqle) {\n                LOG.warn(\"Error on jdbc component rollback: \" + sqle, sqle);\n            }\n            throw e;\n        } finally {\n            closeQuietly(rs);\n            closeQuietly(stmt);\n            resetAutoCommit(conn, autoCommit);\n            closeQuietly(conn);\n        }\n    }","id":87462,"modified_method":"private void processingSqlBySettingAutoCommit(Exchange exchange) throws Exception {\n        String sql = exchange.getIn().getBody(String.class);\n        Connection conn = null;\n        Statement stmt = null;\n        ResultSet rs = null;\n        Boolean autoCommit = null;\n        try {\n            conn = dataSource.getConnection();\n            autoCommit = conn.getAutoCommit();\n            if (autoCommit) {\n                conn.setAutoCommit(false);\n            }\n\n            stmt = conn.createStatement();\n\n            if (parameters != null && !parameters.isEmpty()) {\n                IntrospectionSupport.setProperties(stmt, parameters);\n            }\n\n            LOG.debug(\"Executing JDBC statement: {}\", sql);\n\n            if (stmt.execute(sql)) {\n                rs = stmt.getResultSet();\n                setResultSet(exchange, rs);\n            } else {\n                int updateCount = stmt.getUpdateCount();\n                exchange.getOut().setHeader(JdbcConstants.JDBC_UPDATE_COUNT, updateCount);\n            }\n            conn.commit();\n        } catch (Exception e) {\n            try {\n                if (conn != null)\n                    conn.rollback();\n            } catch (SQLException sqle) {\n                LOG.warn(\"Error on jdbc component rollback: \" + sqle, sqle);\n            }\n            throw e;\n        } finally {\n            closeQuietly(rs);\n            closeQuietly(stmt);\n            resetAutoCommit(conn, autoCommit);\n            closeQuietly(conn);\n        }\n    }","commit_id":"44fea66cd4abd2626b771f7154fbecee5c4dd016","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Signalizes that the publish thread finishes.<p>\n     * \n     * @param publishJob the finished publish job\n     */\n    protected void publishJobFinished(CmsPublishJobInfoBean publishJob) {\n\n        // in order to avoid not removable publish locks, unlock all assigned resources again\n        try {\n            unlockPublishList(publishJob);\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n\n        // trigger the old event mechanism\n        CmsDbContext dbc = m_dbContextFactory.getDbContext(publishJob.getCmsObject().getRequestContext());\n        try {\n            // fire an event that a project has been published\n            Map<String, Object> eventData = new HashMap<String, Object>();\n            eventData.put(I_CmsEventListener.KEY_REPORT, publishJob.getPublishReport());\n            eventData.put(\n                I_CmsEventListener.KEY_PUBLISHID,\n                publishJob.getPublishList().getPublishHistoryId().toString());\n            eventData.put(I_CmsEventListener.KEY_PROJECTID, dbc.currentProject().getUuid());\n            eventData.put(I_CmsEventListener.KEY_DBCONTEXT, dbc);\n            CmsEvent afterPublishEvent = new CmsEvent(I_CmsEventListener.EVENT_PUBLISH_PROJECT, eventData);\n            OpenCms.fireCmsEvent(afterPublishEvent);\n        } catch (Throwable t) {\n            dbc.rollback();\n            LOG.error(t);\n            // catch every thing including runtime exceptions\n            publishJob.getPublishReport().println(t);\n        } finally {\n            try {\n                dbc.clear();\n            } catch (Throwable t) {\n                // ignore\n            }\n            dbc = null;\n        }\n        try {\n            // fire the publish finish event\n            m_listeners.fireFinish(new CmsPublishJobRunning(publishJob));\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n        try {\n            // finish the job\n            publishJob.finish();\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n        try {\n            // put the publish job into the history list\n            m_publishHistory.add(publishJob);\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n        if (Thread.currentThread() == m_currentPublishThread) {\n            // wipe the dead thread, only if this thread has not been abandoned\n            m_currentPublishThread = null;\n        }\n        // clear the published resources cache\n        OpenCms.getMemoryMonitor().flushCache(CmsMemoryMonitor.CacheType.PUBLISHED_RESOURCES);\n        // try to start a new publish job\n        checkCurrentPublishJobThread();\n    }","id":87463,"modified_method":"/**\n     * Signalizes that the publish thread finishes.<p>\n     * \n     * @param publishJob the finished publish job\n     */\n    protected void publishJobFinished(CmsPublishJobInfoBean publishJob) {\n\n        // in order to avoid not removable publish locks, unlock all assigned resources again\n        try {\n            unlockPublishList(publishJob);\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n\n        // trigger the old event mechanism\n        CmsDbContext dbc = m_dbContextFactory.getDbContext(publishJob.getCmsObject().getRequestContext());\n        try {\n            // fire an event that a project has been published\n            Map<String, Object> eventData = new HashMap<String, Object>();\n            eventData.put(I_CmsEventListener.KEY_REPORT, publishJob.getPublishReport());\n            eventData.put(\n                I_CmsEventListener.KEY_PUBLISHID,\n                publishJob.getPublishList().getPublishHistoryId().toString());\n            eventData.put(I_CmsEventListener.KEY_PROJECTID, dbc.currentProject().getUuid());\n            eventData.put(I_CmsEventListener.KEY_DBCONTEXT, dbc);\n            CmsEvent afterPublishEvent = new CmsEvent(I_CmsEventListener.EVENT_PUBLISH_PROJECT, eventData);\n            OpenCms.fireCmsEvent(afterPublishEvent);\n        } catch (Throwable t) {\n            if (dbc != null) {\n                dbc.rollback();\n            }\n            LOG.error(t);\n            // catch every thing including runtime exceptions\n            publishJob.getPublishReport().println(t);\n        } finally {\n            if (dbc != null) {\n                try {\n                    dbc.clear();\n                } catch (Throwable t) {\n                    // ignore\n                }\n                dbc = null;\n            }\n        }\n        try {\n            // fire the publish finish event\n            m_listeners.fireFinish(new CmsPublishJobRunning(publishJob));\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n        try {\n            // finish the job\n            publishJob.finish();\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n        try {\n            // put the publish job into the history list\n            m_publishHistory.add(publishJob);\n        } catch (Throwable t) {\n            // log failure, most likely a database problem\n            LOG.error(t.getLocalizedMessage(), t);\n        }\n        if (Thread.currentThread() == m_currentPublishThread) {\n            // wipe the dead thread, only if this thread has not been abandoned\n            m_currentPublishThread = null;\n        }\n        // clear the published resources cache\n        OpenCms.getMemoryMonitor().flushCache(CmsMemoryMonitor.CacheType.PUBLISHED_RESOURCES);\n        // try to start a new publish job\n        checkCurrentPublishJobThread();\n    }","commit_id":"2f8c6b3911d3f7451944d4981ed9dcb6b84ebeaa","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Starts the configuration service\n     *\n     * @param bundleContext the <tt>BundleContext<\/tt> as provided by the OSGi\n     * framework.\n     * @throws Exception if anything goes wrong\n     */\n    public void start(BundleContext bundleContext)\n        throws Exception\n    {\n        if (logger.isDebugEnabled())\n            logger.debug(\"Service Impl: \" + getClass().getName() +\n                    \" [  STARTED ]\");\n\n        impl.start(bundleContext);\n\n        bundleContext.registerService(ConfigurationService.class.getName(),\n                                      impl,\n                                      null);\n\n        if (logger.isDebugEnabled())\n            logger.debug(\"Service Impl: \" + getClass().getName() +\n                    \" [REGISTERED]\");\n    }","id":87464,"modified_method":"/**\n     * Starts the configuration service\n     *\n     * @param bundleContext the <tt>BundleContext<\/tt> as provided by the OSGi\n     * framework.\n     * @throws Exception if anything goes wrong\n     */\n    public void start(BundleContext bundleContext)\n        throws Exception\n    {\n        boolean started = false;\n\n        ConfigurationActivator.bundleContext = bundleContext;\n        try\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\n                        \"Service Impl: \"\n                            + getClass().getName()\n                            + \" [  STARTED ]\");\n            }\n\n            impl.start(bundleContext);\n            bundleContext.registerService(\n                    ConfigurationService.class.getName(),\n                    impl,\n                    null);\n\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\n                        \"Service Impl: \"\n                            + getClass().getName()\n                            + \" [REGISTERED]\");\n            }\n\n            started = true;\n        }\n        finally\n        {\n            if (!started\n                    && (ConfigurationActivator.bundleContext == bundleContext))\n                ConfigurationActivator.bundleContext = null;\n        }\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Causes the configuration service to store the properties object and\n     * unregisters the configuration service.\n     *\n     * @param bundleContext <tt>BundleContext<\/tt>\n     * @throws Exception if anything goes wrong while storing the properties\n     * managed by the <tt>ConfigurationService<\/tt> implementation provided by\n     * this bundle and while unregistering the service in question\n     */\n    public void stop(BundleContext bundleContext)\n        throws Exception\n    {\n        logger.logEntry();\n        impl.stop();\n        if (logger.isInfoEnabled())\n            logger.info(\n                    \"The ConfigurationService stop method has been called.\");\n    }","id":87465,"modified_method":"/**\n     * Causes the configuration service to store the properties object and\n     * unregisters the configuration service.\n     *\n     * @param bundleContext <tt>BundleContext<\/tt>\n     * @throws Exception if anything goes wrong while storing the properties\n     * managed by the <tt>ConfigurationService<\/tt> implementation provided by\n     * this bundle and while unregistering the service in question\n     */\n    public void stop(BundleContext bundleContext)\n        throws Exception\n    {\n        try\n        {\n            logger.logEntry();\n            impl.stop();\n            if (logger.isInfoEnabled())\n                logger.info(\"ConfigurationService#stop() has been called.\");\n        }\n        finally\n        {\n            if (ConfigurationActivator.bundleContext == bundleContext)\n                ConfigurationActivator.bundleContext = null;\n        }\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Determines the name and the format of the configuration file to be used\n     * and initializes the {@link #configurationFile} and {@link #store} fields\n     * of this instance.\n     */\n    private void createConfigurationFile()\n        throws IOException\n    {\n\n        /*\n         * Choose the format of the configuration file so that the\n         * performance-savvy properties format is used whenever possible and\n         * only go with the slow and fat XML format when necessary.\n         */\n        File configurationFile = getConfigurationFile(\"xml\", false);\n\n        if (configurationFile == null)\n        {\n            /*\n             * It's strange that there's no configuration file name but let it\n             * play out as it did when the configuration file was in XML format.\n             */\n            this.configurationFile = getConfigurationFile(\"xml\", true);\n            if (!(this.store instanceof XMLConfigurationStore))\n                this.store = new XMLConfigurationStore();\n        }\n        else\n        {\n\n            /*\n             * Figure out the format of the configuration file by looking at its\n             * extension.\n             */\n            String name = configurationFile.getName();\n            int extensionBeginIndex = name.lastIndexOf('.');\n            String extension\n                = (extensionBeginIndex > -1)\n                        ? name.substring(extensionBeginIndex)\n                        : null;\n\n            /*\n             * Obviously, a file with the .properties extension is in the\n             * properties format. Since there's no file with the .xml extension,\n             * the case is simple.\n             */\n            if (\".properties\".equalsIgnoreCase(extension))\n            {\n                this.configurationFile = configurationFile;\n                if (!(this.store instanceof PropertyConfigurationStore))\n                    this.store = new PropertyConfigurationStore();\n            }\n            else\n            {\n\n                /*\n                 * But if we're told that the configuration file name is with\n                 * the .xml extension, we may also have a .properties file or\n                 * the .xml extension may be only the default and not forced on\n                 * us so it may be fine to create a .properties file and use the\n                 * properties format anyway.\n                 */\n                File newConfigurationFile\n                    = new File(\n                            configurationFile.getParentFile(),\n                            ((extensionBeginIndex > -1)\n                                    ? name.substring(0, extensionBeginIndex)\n                                    : name)\n                                + \".properties\");\n\n                /*\n                 * If there's an actual file with the .properties extension,\n                 * then we've previously migrated the configuration from the XML\n                 * format to the properties format. We may have failed to delete\n                 * the migrated .xml file but it's fine because the .properties\n                 * file is there to signal that we have to use it instead of the\n                 * .xml file.\n                 */\n                if (newConfigurationFile.exists())\n                {\n                    this.configurationFile = newConfigurationFile;\n                    if (!(this.store instanceof PropertyConfigurationStore))\n                        this.store = new PropertyConfigurationStore();\n                }\n                /*\n                 * Otherwise, the lack of an existing .properties file doesn't\n                 * help us much and we have the .xml extension for the file name\n                 * so we have to determine whether it's just the default or it's\n                 * been forced on us.\n                 */\n                else if (getSystemProperty(PNAME_CONFIGURATION_FILE_NAME)\n                            == null)\n                {\n\n                    /*\n                     * The .xml is not forced on us so we allow ourselves to not\n                     * obey the default and use the properties format. If a\n                     * configuration file in the XML foramt exists already, we\n                     * have to migrate it to the properties format.\n                     */\n                    if (configurationFile.exists())\n                    {\n                        ConfigurationStore xmlStore\n                            = new XMLConfigurationStore();\n                        try\n                        {\n                            xmlStore.reloadConfiguration(configurationFile);\n                        }\n                        catch (XMLException xmlex)\n                        {\n                            IOException ioex = new IOException();\n                            ioex.initCause(xmlex);\n                            throw ioex;\n                        }\n\n                        ConfigurationStore propertyStore\n                            = (this.store instanceof PropertyConfigurationStore)\n                                ? this.store\n                                : new PropertyConfigurationStore();\n                        copy(xmlStore, propertyStore);\n\n                        this.configurationFile\n                                = getConfigurationFile(\"properties\", true);\n                        this.store = propertyStore;\n\n                        Throwable exception = null;\n                        try\n                        {\n                            storeConfiguration(this.configurationFile);\n                        }\n                        catch (IllegalStateException isex)\n                        {\n                            exception = isex;\n                        }\n                        catch (IOException ioex)\n                        {\n                            exception = ioex;\n                        }\n                        if (exception == null)\n                            configurationFile.delete();\n                        else\n                        {\n                            this.configurationFile = configurationFile;\n                            this.store = xmlStore;\n                        }\n                    }\n                    else\n                    {\n                        this.configurationFile\n                                = getConfigurationFile(\"properties\", true);\n                        if (!(this.store instanceof PropertyConfigurationStore))\n                            this.store = new PropertyConfigurationStore();\n                    }\n                }\n                else\n                {\n\n                    /*\n                     * The .xml extension is forced on us so we have to assume\n                     * that whoever forced it knows what she wants to get so we\n                     * have to obey and use the XML foramt.\n                     */\n                    this.configurationFile =\n                            configurationFile.exists()\n                                ? configurationFile\n                                : getConfigurationFile(\"xml\", true);\n                    if (!(this.store instanceof XMLConfigurationStore))\n                        this.store = new XMLConfigurationStore();\n                }\n            }\n        }\n    }","id":87466,"modified_method":"/**\n     * Determines the name and the format of the configuration file to be used\n     * and initializes the {@link #configurationFile} and {@link #store} fields\n     * of this instance.\n     */\n    private void createConfigurationFile()\n        throws IOException\n    {\n\n        /*\n         * Choose the format of the configuration file so that the\n         * performance-savvy properties format is used whenever possible and\n         * only go with the slow and fat XML format when necessary.\n         */\n        File configurationFile = getConfigurationFile(\"xml\", false);\n\n        if (configurationFile == null)\n        {\n            /*\n             * It's strange that there's no configuration file name but let it\n             * play out as it did when the configuration file was in XML format.\n             */\n            setConfigurationStore(XMLConfigurationStore.class);\n        }\n        else\n        {\n\n            /*\n             * Figure out the format of the configuration file by looking at its\n             * extension.\n             */\n            String name = configurationFile.getName();\n            int extensionBeginIndex = name.lastIndexOf('.');\n            String extension\n                = (extensionBeginIndex > -1)\n                        ? name.substring(extensionBeginIndex)\n                        : null;\n\n            /*\n             * Obviously, a file with the .properties extension is in the\n             * properties format. Since there's no file with the .xml extension,\n             * the case is simple.\n             */\n            if (\".properties\".equalsIgnoreCase(extension))\n            {\n                this.configurationFile = configurationFile;\n                if (!(this.store instanceof PropertyConfigurationStore))\n                    this.store = new PropertyConfigurationStore();\n            }\n            else\n            {\n\n                /*\n                 * But if we're told that the configuration file name is with\n                 * the .xml extension, we may also have a .properties file or\n                 * the .xml extension may be only the default and not forced on\n                 * us so it may be fine to create a .properties file and use the\n                 * properties format anyway.\n                 */\n                File newConfigurationFile\n                    = new File(\n                            configurationFile.getParentFile(),\n                            ((extensionBeginIndex > -1)\n                                    ? name.substring(0, extensionBeginIndex)\n                                    : name)\n                                + \".properties\");\n\n                /*\n                 * If there's an actual file with the .properties extension,\n                 * then we've previously migrated the configuration from the XML\n                 * format to the properties format. We may have failed to delete\n                 * the migrated .xml file but it's fine because the .properties\n                 * file is there to signal that we have to use it instead of the\n                 * .xml file.\n                 */\n                if (newConfigurationFile.exists())\n                {\n                    this.configurationFile = newConfigurationFile;\n                    if (!(this.store instanceof PropertyConfigurationStore))\n                        this.store = new PropertyConfigurationStore();\n                }\n                /*\n                 * Otherwise, the lack of an existing .properties file doesn't\n                 * help us much and we have the .xml extension for the file name\n                 * so we have to determine whether it's just the default or it's\n                 * been forced on us.\n                 */\n                else if (getSystemProperty(PNAME_CONFIGURATION_FILE_NAME)\n                            == null)\n                {\n                    Class<? extends ConfigurationStore>\n                        defaultConfigurationStoreClass\n                            = getDefaultConfigurationStoreClass();\n\n                    /*\n                     * The .xml is not forced on us so we allow ourselves to not\n                     * obey the default and use the properties format. If a\n                     * configuration file in the XML format exists already, we\n                     * have to migrate it to the properties format.\n                     */\n                    if (configurationFile.exists())\n                    {\n                        ConfigurationStore xmlStore\n                            = new XMLConfigurationStore();\n                        try\n                        {\n                            xmlStore.reloadConfiguration(configurationFile);\n                        }\n                        catch (XMLException xmlex)\n                        {\n                            IOException ioex = new IOException();\n                            ioex.initCause(xmlex);\n                            throw ioex;\n                        }\n\n                        setConfigurationStore(defaultConfigurationStoreClass);\n                        if (this.store != null)\n                            copy(xmlStore, this.store);\n\n                        Throwable exception = null;\n                        try\n                        {\n                            storeConfiguration(this.configurationFile);\n                        }\n                        catch (IllegalStateException isex)\n                        {\n                            exception = isex;\n                        }\n                        catch (IOException ioex)\n                        {\n                            exception = ioex;\n                        }\n                        if (exception == null)\n                            configurationFile.delete();\n                        else\n                        {\n                            this.configurationFile = configurationFile;\n                            this.store = xmlStore;\n                        }\n                    }\n                    else\n                    {\n                        setConfigurationStore(defaultConfigurationStoreClass);\n                    }\n                }\n                else\n                {\n\n                    /*\n                     * The .xml extension is forced on us so we have to assume\n                     * that whoever forced it knows what she wants to get so we\n                     * have to obey and use the XML format.\n                     */\n                    this.configurationFile =\n                            configurationFile.exists()\n                                ? configurationFile\n                                : getConfigurationFile(\"xml\", true);\n                    if (!(this.store instanceof XMLConfigurationStore))\n                        this.store = new XMLConfigurationStore();\n                }\n            }\n        }\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the property with the specified name to the specified value. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * <p>\n     * @param propertyName String\n     * @param property Object\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property)\n        // throws PropertyVetoException\n    {\n        setProperty(propertyName, property, false);\n    }","id":87467,"modified_method":"/**\n     * Sets the property with the specified name to the specified value. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * <p>\n     * @param propertyName String\n     * @param property Object\n     */\n    public void setProperty(String propertyName, Object property)\n    {\n        setProperty(propertyName, property, false);\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the configuration service impl and makes it load an initial\n     * configuration from the conf file.\n     *\n     * @param bc the <tt>BundleContext<\/tt> provided by the OSGi framework\n     */\n    void start(BundleContext bc)\n    {\n        this.started = true;\n\n        // retrieve a reference to the FileAccessService\n        this.faService = ServiceUtils.getService(bc, FileAccessService.class);\n\n        try\n        {\n            debugPrintSystemProperties();\n            preloadSystemPropertyFiles();\n            reloadConfiguration();\n        }\n        catch (XMLException ex)\n        {\n            logger.error(\"Failed to parse the configuration file.\", ex);\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to load the configuration file\", ex);\n        }\n    }","id":87468,"modified_method":"/**\n     * Initializes the configuration service impl and makes it load an initial\n     * configuration from the conf file.\n     *\n     * @param bc the <tt>BundleContext<\/tt> provided by the OSGi framework\n     */\n    void start(BundleContext bc)\n    {\n        this.started = true;\n\n        // retrieve a reference to the FileAccessService\n        this.faService = ServiceUtils.getService(bc, FileAccessService.class);\n\n        try\n        {\n            debugPrintSystemProperties();\n            preloadSystemPropertyFiles();\n            reloadConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to load the configuration file\", ex);\n        }\n        catch (XMLException ex)\n        {\n            logger.error(\"Failed to parse the configuration file\", ex);\n        }\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stores local properties in the specified configuration file.\n     *\n     * @param file a reference to the configuration file where properties should\n     *            be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file)\n        throws IOException\n    {\n        if (!started)\n            throw new IllegalStateException(\n                \"Service is stopped or has not been started\");\n\n        // write the file.\n        FailSafeTransaction trans =\n            this.faService.createFailSafeTransaction(file);\n        Throwable exception = null;\n        try\n        {\n            trans.beginTransaction();\n            OutputStream stream = new FileOutputStream(file);\n\n            store.storeConfiguration(stream);\n\n            stream.close();\n            trans.commit();\n        }\n        catch (IllegalStateException isex)\n        {\n            exception = isex;\n        }\n        catch (IOException ioex)\n        {\n            exception = ioex;\n        }\n        if (exception != null)\n        {\n            logger\n                .error(\"can't write data in the configuration file\", exception);\n            trans.rollback();\n        }\n    }","id":87469,"modified_method":"/**\n     * Stores local properties in the specified configuration file.\n     *\n     * @param file a reference to the configuration file where properties should\n     *            be stored.\n     * @throws IOException if there was a problem writing to the specified file.\n     */\n    private void storeConfiguration(File file)\n        throws IOException\n    {\n        if (!started)\n            throw new IllegalStateException(\n                \"Service is stopped or has not been started\");\n\n        // write the file.\n        FailSafeTransaction trans\n            = (file == null)\n                ? null\n                : this.faService.createFailSafeTransaction(file);\n        Throwable exception = null;\n\n        try\n        {\n            if (trans != null)\n                trans.beginTransaction();\n\n            OutputStream stream\n                = (file == null) ? null : new FileOutputStream(file);\n\n            try\n            {\n                store.storeConfiguration(stream);\n            }\n            finally\n            {\n                if (stream != null)\n                    stream.close();\n            }\n\n            if (trans != null)\n                trans.commit();\n        }\n        catch (IllegalStateException isex)\n        {\n            exception = isex;\n        }\n        catch (IOException ioex)\n        {\n            exception = ioex;\n        }\n        if (exception != null)\n        {\n            logger.error(\n                    \"can't write data in the configuration file\",\n                    exception);\n            if (trans != null)\n                trans.rollback();\n        }\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void removeProperty(String propertyName)\n        // throws PropertyVetoException\n    {\n        List<String> childPropertyNames =\n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n\n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        store.removeProperty(propertyName);\n\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","id":87470,"modified_method":"/**\n     * Removes the property with the specified name. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched.\n     * All properties with prefix propertyName will also be removed.\n     * <p>\n     * @param propertyName the name of the property to change.\n     */\n    public void removeProperty(String propertyName)\n    {\n        List<String> childPropertyNames =\n            getPropertyNamesByPrefix(propertyName, false);\n\n        //remove all properties\n        for (String pName : childPropertyNames)\n        {\n            removeProperty(pName);\n        }\n\n        Object oldValue = getProperty(propertyName);\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, null);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Will remove prop: \" + propertyName + \".\");\n\n        store.removeProperty(propertyName);\n\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, null);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\"Failed to store configuration after \"\n                         + \"a property change\");\n        }\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void reloadConfiguration()\n        throws IOException, XMLException\n    {\n        this.configurationFile = null;\n\n        File file = getConfigurationFile();\n\n        // restore the file if needed\n        FailSafeTransaction trans = this.faService\n            .createFailSafeTransaction(file);\n        try {\n            trans.restoreFile();\n        } catch (Exception e) {\n            logger.error(\"can't restore the configuration file before loading\" +\n                    \" it\", e);\n        }\n\n        store.reloadConfiguration(file);\n    }","id":87471,"modified_method":"public void reloadConfiguration()\n        throws IOException,\n               XMLException\n    {\n        this.configurationFile = null;\n\n        File file = getConfigurationFile();\n\n        if (file != null)\n        {\n            // Restore the file if necessary.\n            FailSafeTransaction trans\n                = this.faService.createFailSafeTransaction(file);\n\n            try\n            {\n                trans.restoreFile();\n            }\n            catch (Exception e)\n            {\n                logger.error(\n                        \"Failed to restore configuration file \" + file,\n                        e);\n            }\n        }\n\n        store.reloadConfiguration(file);\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is internally forced\n     *                 to true.\n     * @throws PropertyVetoException in case the changed has been refused by\n     * at least one propertychange listener.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n        // throws PropertyVetoException\n    {\n        Object oldValue = getProperty(propertyName);\n\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        if (logger.isTraceEnabled())\n            logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        doSetProperty(propertyName, property, isSystem);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\n                \"Failed to store configuration after a property change\");\n        }\n\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n    }","id":87472,"modified_method":"/**\n     * Sets the property with the specified name to the specified. Calling\n     * this method would first trigger a PropertyChangeEvent that will\n     * be dispatched to all VetoableChangeListeners. In case no complaints\n     * (PropertyVetoException) have been received, the property will be actually\n     * changed and a PropertyChangeEvent will be dispatched. This method also\n     * allows the caller to specify whether or not the specified property is a\n     * system one.\n     * <p>\n     * @param propertyName the name of the property to change.\n     * @param property the new value of the specified property.\n     * @param isSystem specifies whether or not the property being is a System\n     *                 property and should be resolved against the system\n     *                 property set. If the property has previously been\n     *                 specified as system then this value is internally forced\n     *                 to true.\n     */\n    public void setProperty(String propertyName, Object property,\n                            boolean isSystem)\n    {\n        Object oldValue = getProperty(propertyName);\n\n        //first check whether the change is ok with everyone\n        if (changeEventDispatcher.hasVetoableChangeListeners(propertyName))\n            changeEventDispatcher.fireVetoableChange(\n                propertyName, oldValue, property);\n\n        //no exception was thrown - lets change the property and fire a\n        //change event\n\n        if (logger.isTraceEnabled())\n            logger.trace(propertyName + \"( oldValue=\" + oldValue\n                     + \", newValue=\" + property + \".\");\n\n        doSetProperty(propertyName, property, isSystem);\n\n        try\n        {\n            storeConfiguration();\n        }\n        catch (IOException ex)\n        {\n            logger.error(\n                \"Failed to store configuration after a property change\");\n        }\n\n        if (changeEventDispatcher.hasPropertyChangeListeners(propertyName))\n            changeEventDispatcher.firePropertyChange(\n                propertyName, oldValue, property);\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Implements\r\n     * {@link ConfigurationStore#setNonSystemProperty(String, Object)}. As the\r\n     * backend of this instance is a <tt>Properties<\/tt> instance, it can only\r\n     * store <tt>String<\/tt> values and the specified value to be associated\r\n     * with the specified property name is converted to a <tt>String<\/tt>.\r\n     *\r\n     * @param name the name of the non-system property to be set to the\r\n     * specified value in this <tt>ConfigurationStore<\/tt>\r\n     * @param value the value to be assigned to the non-system property with the\r\n     * specified name in this <tt>ConfigurationStore<\/tt>\r\n     * @see ConfigurationStore#setNonSystemProperty(String, Object)\r\n     */\r\n    public void setNonSystemProperty(String name, Object value)\r\n    {\r\n        properties.setProperty(name, value.toString());\r\n    }","id":87473,"modified_method":"/**\r\n     * Overrides\r\n     * {@link HashtableConfigurationStore#setNonSystemProperty(String, Object)}.\r\n     * As the backend of this instance is a <tt>Properties<\/tt> instance, it can\r\n     * only store <tt>String<\/tt> values and the specified value to be\r\n     * associated with the specified property name is converted to a\r\n     * <tt>String<\/tt>.\r\n     *\r\n     * @param name the name of the non-system property to be set to the\r\n     * specified value in this <tt>ConfigurationStore<\/tt>\r\n     * @param value the value to be assigned to the non-system property with the\r\n     * specified name in this <tt>ConfigurationStore<\/tt>\r\n     * @see ConfigurationStore#setNonSystemProperty(String, Object)\r\n     */\r\n    @Override\r\n    public void setNonSystemProperty(String name, Object value)\r\n    {\r\n        properties.setProperty(name, value.toString());\r\n    }","commit_id":"73e1aab26413c9ff586b3fa1c3b902eb35a08d70","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void removeCollection(Collection collection, DBBroker broker) {\r\n    \tboolean isCollectionGMLAware = false;\r\n    \tIndexSpec idxConf = collection.getIndexConfiguration(broker);\r\n    \tif (idxConf != null) {\r\n            Map collectionConfig = (Map) idxConf.getCustomIndexSpec(AbstractGMLJDBCIndex.ID);\r\n            if (collectionConfig != null) {\r\n            \tisCollectionGMLAware = (collectionConfig != null);\r\n            }\r\n    \t}\r\n    \tif (!isCollectionGMLAware)\r\n    \t\treturn;  \r\n    \t\r\n    \tConnection conn = null;\r\n    \ttry {\r\n    \t\tconn = acquireConnection();\r\n\t        if (LOG.isDebugEnabled())\r\n\t            LOG.debug(\"Dropping GML index for collection \" + collection.getURI());\t        \r\n\t        int nodeCount = removeCollection(collection, conn);\t\r\n\t        if (LOG.isDebugEnabled())\r\n\t            LOG.debug(\"Dropped \" + nodeCount + \" nodes from GML index\");\t         \r\n        } catch (SQLException e) {\r\n        \tLOG.error(e);\r\n        } finally {\r\n        \ttry {\r\n        \t\tif (conn != null)\r\n        \t\t\treleaseConnection(conn);\r\n            } catch (SQLException e) {\r\n            \tLOG.error(e);\r\n            }        \t\t\r\n        }\r\n    }","id":87474,"modified_method":"public void removeCollection(Collection collection, DBBroker broker) {\r\n        boolean isCollectionGMLAware = false;\r\n        IndexSpec idxConf = collection.getIndexConfiguration(broker);\r\n        if (idxConf != null) {\r\n            Map collectionConfig = (Map) idxConf.getCustomIndexSpec(AbstractGMLJDBCIndex.ID);\r\n            isCollectionGMLAware = (collectionConfig != null);\r\n        }\r\n        if (!isCollectionGMLAware)\r\n            return;\r\n\r\n        Connection conn = null;\r\n        try {\r\n            conn = acquireConnection();\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"Dropping GML index for collection \" + collection.getURI());\r\n            int nodeCount = removeCollection(collection, conn);\r\n            if (LOG.isDebugEnabled())\r\n                LOG.debug(\"Dropped \" + nodeCount + \" nodes from GML index\");\r\n        } catch (SQLException e) {\r\n            LOG.error(e);\r\n        } finally {\r\n            try {\r\n                if (conn != null)\r\n                    releaseConnection(conn);\r\n            } catch (SQLException e) {\r\n                LOG.error(e);\r\n            }\r\n        }\r\n    }","commit_id":"8ef9609ea904087a2f4cc30ea010de272011cfab","url":"https://github.com/eXist-db/exist"},{"original_method":"public void flush() {\r\n    \tif (!isDocumentGMLAware)\r\n    \t\t//Not concerned\r\n    \t\treturn;\r\n    \t//Is the job already done ?\r\n    \tif (currentMode == StreamListener.REMOVE_ALL_NODES && documentDeleted)\r\n    \t\treturn;\r\n    \tConnection conn = null;\r\n    \ttry {\r\n    \t\tconn = acquireConnection();\r\n            conn.setAutoCommit(false);\r\n\t        switch (currentMode) {\r\n\t            case StreamListener.STORE :\r\n\t                saveDocumentNodes(conn);\r\n\t                break;\r\n\t            case StreamListener.REMOVE_SOME_NODES :\r\n\t                dropDocumentNode(conn);\r\n\t                break;\r\n\t            case StreamListener.REMOVE_ALL_NODES:\r\n            \t\tremoveDocument(conn);\r\n            \t\tdocumentDeleted = true;\r\n            \t\tbreak;\r\n\t        }\r\n\t        conn.commit();\t  \r\n        } catch (SQLException e) {\r\n        \tLOG.error(\"Document: \" + currentDoc + \" NodeID: \" + currentNodeId, e);\r\n        \ttry {\r\n        \t\tconn.rollback();\r\n            } catch (SQLException ee) {\r\n            \tLOG.error(ee);\r\n            }    \t\r\n        } finally {\r\n        \ttry {\r\n        \t\tif (conn != null) {\r\n        \t\t\tconn.setAutoCommit(true);\r\n        \t\t\treleaseConnection(conn);\r\n        \t\t}\r\n            } catch (SQLException e) {\r\n            \tLOG.error(e);\r\n            }        \t\t\r\n        }\r\n    }","id":87475,"modified_method":"public void flush() {\r\n        if (!isDocumentGMLAware)\r\n            //Not concerned\r\n            return;\r\n        //Is the job already done ?\r\n        if (currentMode == StreamListener.REMOVE_ALL_NODES && documentDeleted)\r\n            return;\r\n        Connection conn = null;\r\n        try {\r\n            conn = acquireConnection();\r\n            conn.setAutoCommit(false);\r\n            switch (currentMode) {\r\n                case StreamListener.STORE :\r\n                    saveDocumentNodes(conn);\r\n                    break;\r\n                case StreamListener.REMOVE_SOME_NODES :\r\n                    dropDocumentNode(conn);\r\n                    break;\r\n                case StreamListener.REMOVE_ALL_NODES:\r\n                    removeDocument(conn);\r\n                    documentDeleted = true;\r\n                    break;\r\n            }\r\n            conn.commit();\r\n        } catch (SQLException e) {\r\n            LOG.error(\"Document: \" + currentDoc + \" NodeID: \" + currentNodeId, e);\r\n            try {\r\n                if (conn != null)\r\n                    conn.rollback();\r\n            } catch (SQLException ee) {\r\n                LOG.error(ee);\r\n            }\r\n        } finally {\r\n            try {\r\n                if (conn != null) {\r\n                    conn.setAutoCommit(true);\r\n                    releaseConnection(conn);\r\n                }\r\n            } catch (SQLException e) {\r\n                LOG.error(e);\r\n            }\r\n        }\r\n    }","commit_id":"8ef9609ea904087a2f4cc30ea010de272011cfab","url":"https://github.com/eXist-db/exist"},{"original_method":"public Occurrences[] scanIndex(XQueryContext context, DocumentSet docs, NodeSet contextSet, Map hints) {\r\n    \t//TODO : try to use contextSet\r\n    \tMap<Geometry, Occurrences> occurences = new TreeMap<Geometry, Occurrences>();\r\n    \tConnection conn = null;\r\n    \ttry { \r\n    \t\tconn = acquireConnection();\r\n    \t\t//Collect the (normalized) geometries for each document\r\n\t\t\tfor (Iterator<DocumentImpl> iDoc = docs.getDocumentIterator(); iDoc.hasNext();) {\r\n\t\t\t\tDocumentImpl doc = (DocumentImpl)iDoc.next();\r\n\t\t\t\t//TODO : check if document is GML-aware ?\r\n\t\t    \t//Aggregate the occurences between different documents\r\n\t\t    \tfor (Map.Entry<Geometry, String> entry : getGeometriesForDocument(doc, conn).entrySet()) {\r\n\t\t    \t\t///TODO : use the IndexWorker.VALUE_COUNT hint, if present, to limit the number of returned entries\r\n\t\t            Geometry key = entry.getKey();\r\n\t\t            //Do we already have an occurence for this geometry ?\r\n\t\t            Occurrences oc = occurences.get(key);\r\n\t\t            if (oc != null) {\r\n\t\t            \t//Yes : increment occurence count\r\n\t\t            \toc.addOccurrences(oc.getOccurrences() + 1);\r\n\t\t            \t//...and reference the document\r\n\t\t            \toc.addDocument(doc);\r\n\t\t            } else {\r\n\t\t            \t//No : create a new occurence with EPSG4326_WKT as \"term\"\r\n\t\t            \toc = new Occurrences(entry.getValue());\r\n\t\t            \t//... with a count set to 1\r\n\t\t            \toc.addOccurrences(1);\r\n\t\t            \t//... and reference the document\r\n\t\t            \toc.addDocument(doc);\r\n\t\t            \toccurences.put(key, oc);\r\n\t\t            }\r\n\t\t        }\r\n\t\t\t}\r\n    \t} catch (SQLException e) {\r\n    \t\tLOG.error(e);\r\n    \t\treturn null;\r\n    \t} finally {\r\n        \ttry {\r\n        \t\tif (conn != null)\r\n        \t\t\treleaseConnection(conn);\r\n            } catch (SQLException e) {\r\n            \tLOG.error(e);\r\n            \treturn null;\r\n            }            \r\n    \t}\r\n    \tOccurrences[] result = new Occurrences[occurences.size()];\r\n    \toccurences.values().toArray(result);\r\n    \treturn result;\r\n    }","id":87476,"modified_method":"public Occurrences[] scanIndex(XQueryContext context, DocumentSet docs, NodeSet contextSet, Map hints) {\r\n        //TODO : try to use contextSet\r\n        Map<Geometry, Occurrences> occurences = new TreeMap<Geometry, Occurrences>();\r\n        Connection conn = null;\r\n        try {\r\n            conn = acquireConnection();\r\n            //Collect the (normalized) geometries for each document\r\n            for (Iterator<DocumentImpl> iDoc = docs.getDocumentIterator(); iDoc.hasNext();) {\r\n                DocumentImpl doc = iDoc.next();\r\n                //TODO : check if document is GML-aware ?\r\n                //Aggregate the occurences between different documents\r\n                for (Map.Entry<Geometry, String> entry : getGeometriesForDocument(doc, conn).entrySet()) {\r\n                    ///TODO : use the IndexWorker.VALUE_COUNT hint, if present, to limit the number of returned entries\r\n                    Geometry key = entry.getKey();\r\n                    //Do we already have an occurence for this geometry ?\r\n                    Occurrences oc = occurences.get(key);\r\n                    if (oc != null) {\r\n                        //Yes : increment occurence count\r\n                        oc.addOccurrences(oc.getOccurrences() + 1);\r\n                        //...and reference the document\r\n                        oc.addDocument(doc);\r\n                    } else {\r\n                        //No : create a new occurence with EPSG4326_WKT as \"term\"\r\n                        oc = new Occurrences(entry.getValue());\r\n                        //... with a count set to 1\r\n                        oc.addOccurrences(1);\r\n                        //... and reference the document\r\n                        oc.addDocument(doc);\r\n                        occurences.put(key, oc);\r\n                    }\r\n                }\r\n            }\r\n        } catch (SQLException e) {\r\n            LOG.error(e);\r\n            return null;\r\n        } finally {\r\n            try {\r\n                if (conn != null)\r\n                    releaseConnection(conn);\r\n            } catch (SQLException e) {\r\n                LOG.error(e);\r\n                return null;\r\n            }\r\n        }\r\n        Occurrences[] result = new Occurrences[occurences.size()];\r\n        occurences.values().toArray(result);\r\n        return result;\r\n    }","commit_id":"8ef9609ea904087a2f4cc30ea010de272011cfab","url":"https://github.com/eXist-db/exist"},{"original_method":"private List<SearchBuilderItem> findPendingAndLock(int batchSize,\n\t\t\tConnection connection) throws SQLException\n\t{\n\t\t// Pending is the first 100 items\n\t\t// State == PENDING\n\t\t// Action != Unknown\n\t\tlong start = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tlog.debug(\"TXFind pending with \" + connection); //$NON-NLS-1$\n\n\t\t\tSearchBuilderItem masterItem = getMasterItem(connection);\n\t\t\ttry\n\t\t\t{\n\n\t\t\t\tInteger masterAction = getMasterAction(masterItem);\n\t\t\t\tlog.debug(\" Master Item is \" + masterItem.getName() + \":\" //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t+ masterItem.getSearchaction() + \":\" //$NON-NLS-1$\n\t\t\t\t\t\t+ masterItem.getSearchstate() + \"::\" //$NON-NLS-1$\n\t\t\t\t\t\t+ masterItem.getVersion());\n\t\t\t\tif (SearchBuilderItem.ACTION_REFRESH.equals(masterAction))\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\" Master Action is \" + masterAction); //$NON-NLS-1$\n\t\t\t\t\tlog.debug(\"  REFRESH = \" + SearchBuilderItem.ACTION_REFRESH); //$NON-NLS-1$\n\t\t\t\t\tlog.debug(\"  RELOAD = \" + SearchBuilderItem.ACTION_REBUILD); //$NON-NLS-1$\n\t\t\t\t\t// get a complete list of all items, before the master\n\t\t\t\t\t// action version\n\t\t\t\t\t// if there are none, update the master action action to\n\t\t\t\t\t// completed\n\t\t\t\t\t// and return a blank list\n\n\t\t\t\t\trefreshIndex(connection, masterItem);\n\n\t\t\t\t}\n\t\t\t\telse if (SearchBuilderItem.ACTION_REBUILD.equals(masterAction))\n\t\t\t\t{\n\t\t\t\t\trebuildIndex(connection, masterItem);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// get all site masters and perform the required action.\n\t\t\t\t\tList siteMasters = getSiteMasterItems(connection);\n\t\t\t\t\tfor (Iterator i = siteMasters.iterator(); i.hasNext();)\n\t\t\t\t\t{\n\t\t\t\t\t\tSearchBuilderItem siteMaster = (SearchBuilderItem) i.next();\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tInteger action = getSiteMasterAction(siteMaster);\n\t\t\t\t\t\t\tif (SearchBuilderItem.ACTION_REBUILD.equals(action))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trebuildIndex(connection, siteMaster);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (SearchBuilderItem.ACTION_REFRESH.equals(action))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trefreshIndex(connection, siteMaster);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// any value > 1000 is a lock\n\t\t\t\t\t\t\tif (siteMaster.getLock() == nodeLock )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tList<SearchBuilderItem> l = new ArrayList<SearchBuilderItem>();\n\t\t\t\t\t\t\t\tl.add(siteMaster);\n\t\t\t\t\t\t\t\tcommitPendingAndUnLock(l, connection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (masterItem.getLock() == nodeLock  )\n\t\t\t\t{\n\t\t\t\t\tList<SearchBuilderItem> l = new ArrayList<SearchBuilderItem>();\n\t\t\t\t\tl.add(masterItem);\n\t\t\t\t\tcommitPendingAndUnLock(l, connection);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPreparedStatement pst = null;\n\t\t\tPreparedStatement lockedPst = null;\n\t\t\tResultSet rst = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tpst = connection.prepareStatement(\"select \" //$NON-NLS-1$\n\t\t\t\t\t\t+ SEARCH_BUILDER_ITEM_FIELDS + \" from \" //$NON-NLS-1$\n\t\t\t\t\t\t+ SEARCH_BUILDER_ITEM_T + \" where searchstate = ? and     \" //$NON-NLS-1$\n\t\t\t\t\t\t+ \"        itemscope = ?  order by version \"); //$NON-NLS-1$\n\t\t\t\tlockedPst = connection.prepareStatement(\"update \" //$NON-NLS-1$\n\t\t\t\t\t\t+ SEARCH_BUILDER_ITEM_T + \" set searchstate = ? \" //$NON-NLS-1$\n\t\t\t\t\t\t+ \" where id = ?  and  searchstate = ? \"); //$NON-NLS-1$\n\t\t\t\tpst.clearParameters();\n\t\t\t\tpst.setInt(1, SearchBuilderItem.STATE_PENDING.intValue());\n\t\t\t\tpst.setInt(2, SearchBuilderItem.ITEM.intValue());\n\t\t\t\trst = pst.executeQuery();\n\t\t\t\tList<SearchBuilderItem> a = new ArrayList<SearchBuilderItem>();\n\t\t\t\twhile (rst.next() && a.size() < batchSize)\n\t\t\t\t{\n\n\t\t\t\t\tSearchBuilderItemImpl sbi = new SearchBuilderItemImpl();\n\t\t\t\t\tpopulateSearchBuilderItem(rst, sbi);\n\t\t\t\t\tif (!SearchBuilderItem.ACTION_UNKNOWN.equals(sbi.getSearchaction()))\n\t\t\t\t\t{\n\t\t\t\t\t\tlockedPst.clearParameters();\n\t\t\t\t\t\tlockedPst.setInt(1, nodeLock);\n\t\t\t\t\t\tlockedPst.setString(2, sbi.getId());\n\t\t\t\t\t\tlockedPst.setInt(3, SearchBuilderItem.STATE_PENDING.intValue());\n\t\t\t\t\t\tif (lockedPst.executeUpdate() == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsbi.setSearchstate(SearchBuilderItem.STATE_LOCKED);\n\t\t\t\t\t\t\tsbi.setLock(nodeLock);\n\t\t\t\t\t\t\ta.add(sbi);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconnection.commit();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\trst.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Error closing result set\", ex);\n\t\t\t\t}\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tpst.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Error closing statement\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tlong finish = System.currentTimeMillis();\n\t\t\tlog.debug(\" findPending took \" + (finish - start) + \" ms\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\t}","id":87477,"modified_method":"private List<SearchBuilderItem> findPendingAndLock(int batchSize,\n\t\t\tConnection connection) throws SQLException\n\t{\n\t\t// Pending is the first 100 items\n\t\t// State == PENDING\n\t\t// Action != Unknown\n\t\tlong start = System.currentTimeMillis();\n\t\ttry\n\t\t{\n\t\t\tlog.debug(\"TXFind pending with \" + connection); //$NON-NLS-1$\n\n\t\t\tSearchBuilderItem masterItem = getMasterItem(connection);\n\t\t\ttry\n\t\t\t{\n\n\t\t\t\tInteger masterAction = getMasterAction(masterItem);\n\t\t\t\tlog.debug(\" Master Item is \" + masterItem.getName() + \":\" //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\t\t+ masterItem.getSearchaction() + \":\" //$NON-NLS-1$\n\t\t\t\t\t\t+ masterItem.getSearchstate() + \"::\" //$NON-NLS-1$\n\t\t\t\t\t\t+ masterItem.getVersion());\n\t\t\t\tif (SearchBuilderItem.ACTION_REFRESH.equals(masterAction))\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\" Master Action is \" + masterAction); //$NON-NLS-1$\n\t\t\t\t\tlog.debug(\"  REFRESH = \" + SearchBuilderItem.ACTION_REFRESH); //$NON-NLS-1$\n\t\t\t\t\tlog.debug(\"  RELOAD = \" + SearchBuilderItem.ACTION_REBUILD); //$NON-NLS-1$\n\t\t\t\t\t// get a complete list of all items, before the master\n\t\t\t\t\t// action version\n\t\t\t\t\t// if there are none, update the master action action to\n\t\t\t\t\t// completed\n\t\t\t\t\t// and return a blank list\n\n\t\t\t\t\trefreshIndex(connection, masterItem);\n\n\t\t\t\t}\n\t\t\t\telse if (SearchBuilderItem.ACTION_REBUILD.equals(masterAction))\n\t\t\t\t{\n\t\t\t\t\trebuildIndex(connection, masterItem);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// get all site masters and perform the required action.\n\t\t\t\t\tList siteMasters = getSiteMasterItems(connection);\n\t\t\t\t\tfor (Iterator i = siteMasters.iterator(); i.hasNext();)\n\t\t\t\t\t{\n\t\t\t\t\t\tSearchBuilderItem siteMaster = (SearchBuilderItem) i.next();\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tInteger action = getSiteMasterAction(siteMaster);\n\t\t\t\t\t\t\tif (SearchBuilderItem.ACTION_REBUILD.equals(action))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trebuildIndex(connection, siteMaster);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (SearchBuilderItem.ACTION_REFRESH.equals(action))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trefreshIndex(connection, siteMaster);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// any value > 1000 is a lock\n\t\t\t\t\t\t\tif (siteMaster.getLock() == nodeLock )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tList<SearchBuilderItem> l = new ArrayList<SearchBuilderItem>();\n\t\t\t\t\t\t\t\tl.add(siteMaster);\n\t\t\t\t\t\t\t\tcommitPendingAndUnLock(l, connection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (masterItem.getLock() == nodeLock  )\n\t\t\t\t{\n\t\t\t\t\tList<SearchBuilderItem> l = new ArrayList<SearchBuilderItem>();\n\t\t\t\t\tl.add(masterItem);\n\t\t\t\t\tcommitPendingAndUnLock(l, connection);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPreparedStatement pst = null;\n\t\t\tPreparedStatement lockedPst = null;\n\t\t\tResultSet rst = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tpst = connection.prepareStatement(\"select \" //$NON-NLS-1$\n\t\t\t\t\t\t+ SEARCH_BUILDER_ITEM_FIELDS + \" from \" //$NON-NLS-1$\n\t\t\t\t\t\t+ SEARCH_BUILDER_ITEM_T + \" where searchstate = ? and     \" //$NON-NLS-1$\n\t\t\t\t\t\t+ \"        itemscope = ?  order by version \"); //$NON-NLS-1$\n\t\t\t\tlockedPst = connection.prepareStatement(\"update \" //$NON-NLS-1$\n\t\t\t\t\t\t+ SEARCH_BUILDER_ITEM_T + \" set searchstate = ? \" //$NON-NLS-1$\n\t\t\t\t\t\t+ \" where id = ?  and  searchstate = ? \"); //$NON-NLS-1$\n\t\t\t\tpst.clearParameters();\n\t\t\t\tpst.setInt(1, SearchBuilderItem.STATE_PENDING.intValue());\n\t\t\t\tpst.setInt(2, SearchBuilderItem.ITEM.intValue());\n\t\t\t\trst = pst.executeQuery();\n\t\t\t\tList<SearchBuilderItem> a = new ArrayList<SearchBuilderItem>();\n\t\t\t\twhile (rst.next() && a.size() < batchSize)\n\t\t\t\t{\n\n\t\t\t\t\tSearchBuilderItemImpl sbi = new SearchBuilderItemImpl();\n\t\t\t\t\tpopulateSearchBuilderItem(rst, sbi);\n\t\t\t\t\tif (!SearchBuilderItem.ACTION_UNKNOWN.equals(sbi.getSearchaction()))\n\t\t\t\t\t{\n\t\t\t\t\t\tlockedPst.clearParameters();\n\t\t\t\t\t\tlockedPst.setInt(1, nodeLock);\n\t\t\t\t\t\tlockedPst.setString(2, sbi.getId());\n\t\t\t\t\t\tlockedPst.setInt(3, SearchBuilderItem.STATE_PENDING.intValue());\n\t\t\t\t\t\tif (lockedPst.executeUpdate() == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsbi.setSearchstate(SearchBuilderItem.STATE_LOCKED);\n\t\t\t\t\t\t\tsbi.setLock(nodeLock);\n\t\t\t\t\t\t\ta.add(sbi);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconnection.commit();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (rst != null) rst.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Error closing result set\", ex);\n\t\t\t\t}\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (pst != null) pst.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Error closing statement\", ex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tlong finish = System.currentTimeMillis();\n\t\t\tlog.debug(\" findPending took \" + (finish - start) + \" ms\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t}\n\t}","commit_id":"75cd5de7e105a09311554d60960eddddce3ba3e3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void rollback(IndexTransaction transaction)\n\t{\n\t\tConnection connection = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\trollbackPendingAndUnLock(((IndexItemsTransaction) transaction).getItems(),\n\t\t\t\t\tconnection);\n\t\t\tconnection.commit();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.rollback();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"Exception during rollback\", ex2);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.close();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"Exception closing connection\", ex2);\n\t\t\t}\n\t\t}\n\t}","id":87478,"modified_method":"public void rollback(IndexTransaction transaction)\n\t{\n\t\tConnection connection = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\trollbackPendingAndUnLock(((IndexItemsTransaction) transaction).getItems(),\n\t\t\t\t\tconnection);\n\t\t\tconnection.commit();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (connection != null) connection.rollback();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.debug(\"Exception during rollback\", ex2);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (connection != null) connection.close();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.debug(\"Exception closing connection\", ex2);\n\t\t\t}\n\t\t}\n\t}","commit_id":"75cd5de7e105a09311554d60960eddddce3ba3e3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void commit(IndexTransaction transaction)\n\t{\n\t\tConnection connection = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\tcommitPendingAndUnLock(((IndexItemsTransaction) transaction).getItems(),\n\t\t\t\t\tconnection);\n\t\t\tconnection.commit();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.rollback();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"error during rollback in commit\", ex2);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.close();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"error closing connection in commit\", ex2);\n\t\t\t}\n\t\t}\n\t}","id":87479,"modified_method":"public void commit(IndexTransaction transaction)\n\t{\n\t\tConnection connection = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\tcommitPendingAndUnLock(((IndexItemsTransaction) transaction).getItems(),\n\t\t\t\t\tconnection);\n\t\t\tconnection.commit();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (connection != null) connection.rollback();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"error during rollback in commit\", ex2);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (connection != null) connection.close();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"error closing connection in commit\", ex2);\n\t\t\t}\n\t\t}\n\t}","commit_id":"75cd5de7e105a09311554d60960eddddce3ba3e3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void open(IndexTransaction transaction) throws IndexTransactionException\n\t{\n\t\tConnection connection = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\tInteger bs = (Integer) transaction.get(BATCH_SIZE);\n\t\t\tint batchSize = 100;\n\t\t\tif (bs != null)\n\t\t\t{\n\t\t\t\tbatchSize = bs.intValue();\n\t\t\t}\n\t\t\tList<SearchBuilderItem> items = findPendingAndLock(batchSize, connection);\n\t\t\tlog.debug(\"Adding \" + items.size()\n\t\t\t\t\t+ \" items to indexing queue: batch size was \" + batchSize);\n\t\t\t((IndexItemsTransaction) transaction).setItems(items);\n\t\t\tconnection.commit();\n\t\t}\n\t\tcatch (IndexTransactionException itex)\n\t\t{\n\t\t\tlog.info(\"Rethrowing \" + itex.getMessage());\n\t\t\tthrow itex;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tlog.info(\"Failed to Open Transaction \", ex);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.rollback();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"Exception during rollback\", ex2);\n\t\t\t}\n\t\t\tthrow new IndexTransactionException(\"Failed to open transaction \", ex);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.close();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.warn(\"Exception closing connection\", ex2);\n\t\t\t}\n\t\t}\n\n\t}","id":87480,"modified_method":"public void open(IndexTransaction transaction) throws IndexTransactionException\n\t{\n\t\tConnection connection = null;\n\t\ttry\n\t\t{\n\t\t\tconnection = datasource.getConnection();\n\t\t\tInteger bs = (Integer) transaction.get(BATCH_SIZE);\n\t\t\tint batchSize = 100;\n\t\t\tif (bs != null)\n\t\t\t{\n\t\t\t\tbatchSize = bs.intValue();\n\t\t\t}\n\t\t\tList<SearchBuilderItem> items = findPendingAndLock(batchSize, connection);\n\t\t\tlog.debug(\"Adding \" + items.size()\n\t\t\t\t\t+ \" items to indexing queue: batch size was \" + batchSize);\n\t\t\t((IndexItemsTransaction) transaction).setItems(items);\n\t\t\tconnection.commit();\n\t\t}\n\t\tcatch (IndexTransactionException itex)\n\t\t{\n\t\t\tlog.info(\"Rethrowing \" + itex.getMessage());\n\t\t\tthrow itex;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tlog.info(\"Failed to Open Transaction \", ex);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tconnection.rollback();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.debug(\"Exception during rollback\", ex2);\n\t\t\t}\n\t\t\tthrow new IndexTransactionException(\"Failed to open transaction \", ex);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (connection != null) connection.close();\n\t\t\t}\n\t\t\tcatch (Exception ex2)\n\t\t\t{\n\t\t\t\tlog.debug(\"Exception closing connection\", ex2);\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"75cd5de7e105a09311554d60960eddddce3ba3e3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Initializes the interface, socket binding group and socket binding part of the model\n     *\n     * @param rootResource the root model resource\n     * @param rootRegistration the root model registry\n     */\n    protected void initializeSocketBindingsModel(Resource rootResource, ManagementResourceRegistration rootRegistration) {\n        if (socketBindings.size() == 0) {\n            return;\n        }\n\n        rootResource.getModel().get(INTERFACE);\n        rootResource.getModel().get(SOCKET_BINDING_GROUP);\n        ManagementResourceRegistration interfaces = rootRegistration.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        interfaces.registerOperationHandler(SpecifiedInterfaceAddHandler.OPERATION_NAME, SpecifiedInterfaceAddHandler.INSTANCE, SpecifiedInterfaceAddHandler.INSTANCE, false);\n        interfaces.registerOperationHandler(SpecifiedInterfaceRemoveHandler.OPERATION_NAME, SpecifiedInterfaceRemoveHandler.INSTANCE, SpecifiedInterfaceRemoveHandler.INSTANCE, false);\n        InterfaceCriteriaWriteHandler.register(interfaces);\n\n        // Sockets\n        ManagementResourceRegistration socketGroup = rootRegistration.registerSubModel(new SocketBindingGroupResourceDefinition(BindingGroupAddHandler.INSTANCE, SocketBindingGroupRemoveHandler.INSTANCE, false));\n        socketGroup.registerSubModel(SocketBindingResourceDefinition.INSTANCE);\n    }","id":87481,"modified_method":"/**\n     * Initializes the interface, socket binding group and socket binding part of the model\n     *\n     * @param rootResource the root model resource\n     * @param rootRegistration the root model registry\n     */\n    protected void initializeSocketBindingsModel(Resource rootResource, ManagementResourceRegistration rootRegistration) {\n        if (socketBindings.size() == 0) {\n            return;\n        }\n\n        rootResource.getModel().get(INTERFACE);\n        rootResource.getModel().get(SOCKET_BINDING_GROUP);\n        ManagementResourceRegistration interfaces = rootRegistration.registerSubModel(PathElement.pathElement(INTERFACE), CommonProviders.SPECIFIED_INTERFACE_PROVIDER);\n        interfaces.registerOperationHandler(SpecifiedInterfaceAddHandler.OPERATION_NAME, SpecifiedInterfaceAddHandler.INSTANCE, SpecifiedInterfaceAddHandler.INSTANCE, false);\n        interfaces.registerOperationHandler(SpecifiedInterfaceRemoveHandler.OPERATION_NAME, SpecifiedInterfaceRemoveHandler.INSTANCE, SpecifiedInterfaceRemoveHandler.INSTANCE, false);\n        InterfaceCriteriaWriteHandler.register(interfaces);\n\n        // Sockets\n        ManagementResourceRegistration socketGroup = rootRegistration.registerSubModel(new SocketBindingGroupResourceDefinition(BindingGroupAddHandler.INSTANCE, SocketBindingGroupRemoveHandler.INSTANCE, false));\n        socketGroup.registerSubModel(SocketBindingResourceDefinition.INSTANCE);\n        // client-socket-binding (for remote destination)\n        socketGroup.registerSubModel(RemoteDestinationOutboundSocketBindingResourceDefinition.INSTANCE);\n        // client-socket-binding (for local destination)\n        socketGroup.registerSubModel(LocalDestinationOutboundSocketBindingResourceDefinition.INSTANCE);\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model,\n                                  final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final String outboundSocketName = model.get(ModelDescriptionConstants.NAME).asString();\n        final ServiceController<OutboundSocketBinding> outboundSocketBindingServiceController;\n        try {\n            outboundSocketBindingServiceController = this.installOutboundSocketBindingService(context, model, outboundSocketName);\n        } catch (UnknownHostException e) {\n            throw new RuntimeException(e);\n        }\n        serviceControllers.add(outboundSocketBindingServiceController);\n    }","id":87482,"modified_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model,\n                                  final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String outboundSocketName = address.getLastElement().getValue();\n        final ServiceController<OutboundSocketBinding> outboundSocketBindingServiceController;\n        try {\n            outboundSocketBindingServiceController = this.installOutboundSocketBindingService(context, model, outboundSocketName);\n        } catch (UnknownHostException e) {\n            throw new RuntimeException(e);\n        }\n        serviceControllers.add(outboundSocketBindingServiceController);\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(final ModelNode operation, final ModelNode model) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String outboundSocketBindingName = address.getLastElement().getValue();\n        model.get(ModelDescriptionConstants.NAME).set(outboundSocketBindingName);\n        model.get(ModelDescriptionConstants.SOCKET_BINDING_REF).set(operation.get(ModelDescriptionConstants.SOCKET_BINDING_REF));\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_INTERFACE)) {\n            model.get(ModelDescriptionConstants.SOURCE_INTERFACE).set(operation.get(ModelDescriptionConstants.SOURCE_INTERFACE));\n        }\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.SOURCE_PORT).set(operation.get(ModelDescriptionConstants.SOURCE_PORT));\n        }\n        if (operation.hasDefined(FIXED_SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.FIXED_SOURCE_PORT).set(operation.get(FIXED_SOURCE_PORT));\n        }\n\n    }","id":87483,"modified_method":"@Override\n    protected void populateModel(final ModelNode operation, final ModelNode model) throws OperationFailedException {\n\n        model.get(ModelDescriptionConstants.SOCKET_BINDING_REF).set(operation.get(ModelDescriptionConstants.SOCKET_BINDING_REF));\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_INTERFACE)) {\n            model.get(ModelDescriptionConstants.SOURCE_INTERFACE).set(operation.get(ModelDescriptionConstants.SOURCE_INTERFACE));\n        }\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.SOURCE_PORT).set(operation.get(ModelDescriptionConstants.SOURCE_PORT));\n        }\n        if (operation.hasDefined(FIXED_SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.FIXED_SOURCE_PORT).set(operation.get(FIXED_SOURCE_PORT));\n        }\n\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Make any runtime changes necessary to effect the changes indicated by the given {@code operation}. E\n     * <p>\n     * It constructs a MailSessionService that provides mail session and registers it to Naming service.\n     * <\/p>\n     *\n     * @param context             the operation context\n     * @param operation           the operation being executed\n     * @param model               persistent configuration model node that corresponds to the address of {@code operation}\n     * @param verificationHandler step handler that can be added as a listener to any new services installed in order to\n     *                            validate the services installed correctly during the\n     *                            {@link org.jboss.as.controller.OperationContext.Stage#VERIFY VERIFY stage}\n     * @param controllers         holder for the {@link org.jboss.msc.service.ServiceController} for any new services installed by the method. The\n     *                            method should add the {@code ServiceController} for any new services to this list. If the\n     *                            overall operation needs to be rolled back, the list will be used in\n     *                            {@link #rollbackRuntime(org.jboss.as.controller.OperationContext, org.jboss.dmr.ModelNode, org.jboss.dmr.ModelNode, java.util.List)}  to automatically removed\n     *                            the newly added services\n     * @throws org.jboss.as.controller.OperationFailedException\n     *          if {@code operation} is invalid or updating the runtime otherwise fails\n     */\n    @Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> controllers) throws OperationFailedException {\n        final String jndiName = Util.getJndiName(operation);\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        final MailSessionService service = createMailSessionService(context, operation);\n        final ServiceName serviceName = SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> mailSessionBuilder = serviceTarget.addService(serviceName, service);\n\n        final ManagedReferenceFactory valueManagedReferenceFactory = new ManagedReferenceFactory() {\n\n            @Override\n            public ManagedReference getReference() {\n                return new ValueManagedReference(new ImmediateValue<Object>(service.getValue()));\n            }\n        };\n        final ContextNames.BindInfo bindInfo =  ContextNames.bindInfoFor(jndiName);\n        final BinderService binderService = new BinderService(bindInfo.getBindName());\n        final ServiceBuilder<?> binderBuilder = serviceTarget\n                .addService(bindInfo.getBinderServiceName(), binderService)\n                .addInjection(binderService.getManagedObjectInjector(), valueManagedReferenceFactory)\n                .addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                    public void transition(final ServiceController<? extends Object> controller, final ServiceController.Transition transition) {\n                        switch (transition) {\n                            case STARTING_to_UP: {\n                                log.infof(\"Bound mail session [%s]\", jndiName);\n                                break;\n                            }\n                            case START_REQUESTED_to_DOWN: {\n                                log.infof(\"Unbound mail session [%s]\", jndiName);\n                                break;\n                            }\n                            case REMOVING_to_REMOVED: {\n                                log.debugf(\"Removed mail session [%s]\", jndiName);\n                                break;\n                            }\n                        }\n                    }\n                });\n\n        mailSessionBuilder.setInitialMode(ServiceController.Mode.ACTIVE)\n                .addListener(verificationHandler);\n        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE)\n                .addListener(verificationHandler);\n        controllers.add(mailSessionBuilder.install());\n        controllers.add(binderBuilder.install());\n\n\n    }","id":87484,"modified_method":"/**\n     * Make any runtime changes necessary to effect the changes indicated by the given {@code operation}. E\n     * <p>\n     * It constructs a MailSessionService that provides mail session and registers it to Naming service.\n     * <\/p>\n     *\n     * @param context             the operation context\n     * @param operation           the operation being executed\n     * @param model               persistent configuration model node that corresponds to the address of {@code operation}\n     * @param verificationHandler step handler that can be added as a listener to any new services installed in order to\n     *                            validate the services installed correctly during the\n     *                            {@link org.jboss.as.controller.OperationContext.Stage#VERIFY VERIFY stage}\n     * @param controllers         holder for the {@link org.jboss.msc.service.ServiceController} for any new services installed by the method. The\n     *                            method should add the {@code ServiceController} for any new services to this list. If the\n     *                            overall operation needs to be rolled back, the list will be used in\n     *                            {@link #rollbackRuntime(org.jboss.as.controller.OperationContext, org.jboss.dmr.ModelNode, org.jboss.dmr.ModelNode, java.util.List)}  to automatically removed\n     *                            the newly added services\n     * @throws org.jboss.as.controller.OperationFailedException\n     *          if {@code operation} is invalid or updating the runtime otherwise fails\n     */\n    @Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> controllers) throws OperationFailedException {\n        final String jndiName = Util.getJndiName(operation);\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        final MailSessionConfig config = Util.from(context, operation);\n        final MailSessionService service = new MailSessionService(config);\n        final ServiceName serviceName = SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> mailSessionBuilder = serviceTarget.addService(serviceName, service);\n        addOutboundSocketDependency(service, mailSessionBuilder, config.getImapServer());\n        addOutboundSocketDependency(service, mailSessionBuilder, config.getPop3Server());\n        addOutboundSocketDependency(service, mailSessionBuilder, config.getSmtpServer());\n\n        final ManagedReferenceFactory valueManagedReferenceFactory = new ManagedReferenceFactory() {\n\n            @Override\n            public ManagedReference getReference() {\n                return new ValueManagedReference(new ImmediateValue<Object>(service.getValue()));\n            }\n        };\n        final ContextNames.BindInfo bindInfo =  ContextNames.bindInfoFor(jndiName);\n        final BinderService binderService = new BinderService(bindInfo.getBindName());\n        final ServiceBuilder<?> binderBuilder = serviceTarget\n                .addService(bindInfo.getBinderServiceName(), binderService)\n                .addInjection(binderService.getManagedObjectInjector(), valueManagedReferenceFactory)\n                .addDependency(bindInfo.getParentContextServiceName(), ServiceBasedNamingStore.class, binderService.getNamingStoreInjector()).addListener(new AbstractServiceListener<Object>() {\n                    public void transition(final ServiceController<? extends Object> controller, final ServiceController.Transition transition) {\n                        switch (transition) {\n                            case STARTING_to_UP: {\n                                MailLogger.ROOT_LOGGER.boundMailSession(jndiName);\n                                break;\n                            }\n                            case START_REQUESTED_to_DOWN: {\n                                MailLogger.ROOT_LOGGER.unboundMailSession(jndiName);\n                                break;\n                            }\n                            case REMOVING_to_REMOVED: {\n                                MailLogger.ROOT_LOGGER.removedMailSession(jndiName);\n                                break;\n                            }\n                        }\n                    }\n                });\n\n        mailSessionBuilder.setInitialMode(ServiceController.Mode.ACTIVE)\n                .addListener(verificationHandler);\n        binderBuilder.setInitialMode(ServiceController.Mode.ACTIVE)\n                .addListener(verificationHandler);\n        controllers.add(mailSessionBuilder.install());\n        controllers.add(binderBuilder.install());\n\n\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"public MailSessionServer(String address, int port, String username, String password) {\n        this.address = address;\n        this.port = port;\n        if (username != null) {\n            this.credentials = new Credentials(username, password);\n        }else{\n            credentials = null;\n        }\n    }","id":87485,"modified_method":"public MailSessionServer(final String outgoingSocketBinding, String username, String password) {\n        this.outgoingSocketBinding = outgoingSocketBinding;\n        if (username != null) {\n            this.credentials = new Credentials(username, password);\n        }else{\n            credentials = null;\n        }\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"public MailSessionServer(String address, int port, Credentials credentials) {\n        this.address = address;\n        this.port = port;\n        this.credentials = credentials;\n    }","id":87486,"modified_method":"public MailSessionServer(final String outgoingSocketBinding, final Credentials credentials) {\n        this.outgoingSocketBinding = outgoingSocketBinding;\n        this.credentials = credentials;\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Properties getProperties() {\n        Properties props = new Properties();\n\n        if (config.getSmtpServer() != null) {\n            props.put(\"mail.transport.protocol\", \"smtp\");\n            props.put(\"mail.smtp.host\", config.getSmtpServer().getAddress());\n            props.put(\"mail.smtp.port\", config.getSmtpServer().getPort());\n        }\n        if (config.getImapServer() != null) {\n            props.put(\"mail.imap.host\", config.getImapServer().getAddress());\n            props.put(\"mail.imap.port\", config.getImapServer().getPort());\n        }\n        if (config.getPop3Server() != null) {\n            props.put(\"mail.pop3.host\", config.getPop3Server().getAddress());\n            props.put(\"mail.pop3.port\", config.getPop3Server().getPort());\n        }\n\n        props.put(\"mail.debug\", config.isDebug());\n        //todo maybe add mail.from\n\n        log.trace(\"props: \" + props);\n        return props;\n    }","id":87487,"modified_method":"private Properties getProperties() throws StartException  {\n        Properties props = new Properties();\n\n        if (config.getSmtpServer() != null) {\n            props.put(\"mail.transport.protocol\", \"smtp\");\n            InetSocketAddress socketAddress = getServerSocketAddress(config.getSmtpServer());\n            props.put(getHostKey(\"smtp\"), socketAddress.getAddress().getHostName());\n            props.put(getPortKey(\"smtp\"), socketAddress.getPort());\n        }\n        if (config.getImapServer() != null) {\n            InetSocketAddress socketAddress = getServerSocketAddress(config.getImapServer());\n            props.put(getHostKey(\"imap\"), socketAddress.getAddress().getHostName());\n            props.put(getPortKey(\"imap\"), socketAddress.getPort());\n        }\n        if (config.getPop3Server() != null) {\n            InetSocketAddress socketAddress = getServerSocketAddress(config.getPop3Server());\n            props.put(getHostKey(\"pop3\"), socketAddress.getAddress().getHostName());\n            props.put(getPortKey(\"pop3\"), socketAddress.getPort());\n        }\n\n        props.put(\"mail.debug\", config.isDebug());\n        //todo maybe add mail.from\n\n        log.tracef(\"props: %s\", props);\n\n        return props;\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"public MailSessionService(MailSessionConfig config) {\n        log.trace(\"service constructed with config: \" + config);\n        this.config = config;\n    }","id":87488,"modified_method":"public MailSessionService(MailSessionConfig config) {\n        log.tracef(\"service constructed with config: %s\", config);\n        this.config = config;\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void setAuthForServer(final Session session, final MailSessionServer server, final String protocol) {\n        if (server != null) {\n            Credentials c = server.getCredentials();\n            URLName urlName = new URLName(protocol, server.getAddress(), server.getPort(), \"\", c != null ? c.getUsername() : null, c != null ? c.getPassword() : null);\n            if (c != null) {\n                session.setPasswordAuthentication(urlName, new PasswordAuthentication(c.getUsername(), c.getPassword()));\n            }\n        }\n    }","id":87489,"modified_method":"private void setAuthForServer(final Session session, final MailSessionServer server, final String protocol) {\n        if (server != null) {\n            final String host = String.class.cast(props.get(getHostKey(protocol)));\n            final int port = Integer.class.cast(props.get(getPortKey(protocol)));\n            Credentials c = server.getCredentials();\n            URLName urlName = new URLName(protocol, host, port, \"\", c != null ? c.getUsername() : null, c != null ? c.getPassword() : null);\n            if (c != null) {\n                session.setPasswordAuthentication(urlName, new PasswordAuthentication(c.getUsername(), c.getPassword()));\n            }\n        }\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MailSessionServer parseServerConfig(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        String[] attributes = ParseUtils.requireAttributes(reader, Attribute.SERVER_ADDRESS.getLocalName(), Attribute.SERVER_PORT.getLocalName());\n        String username = null;\n        String password = null;\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case LOGIN: {\n                    for (int i = 0; i < reader.getAttributeCount(); i++) {\n                        String att = reader.getAttributeLocalName(i);\n                        if (att.equals(Attribute.USERNAME.getLocalName())) {\n                            username = reader.getAttributeValue(i);\n                        } else if (att.equals(Attribute.PASSWORD.getLocalName())) {\n                            password = reader.getAttributeValue(i);\n                        }\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n            }\n\n\n        }\n        return new MailSessionServer(attributes[0], Integer.parseInt(attributes[1]), username, password);\n    }","id":87490,"modified_method":"private MailSessionServer parseServerConfig(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        String[] attributes = ParseUtils.requireAttributes(reader, Attribute.OUTBOUND_SOCKET_BINDING_REF.getLocalName());\n        String username = null;\n        String password = null;\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch (element) {\n                case LOGIN: {\n                    for (int i = 0; i < reader.getAttributeCount(); i++) {\n                        String att = reader.getAttributeLocalName(i);\n                        if (att.equals(Attribute.USERNAME.getLocalName())) {\n                            username = reader.getAttributeValue(i);\n                        } else if (att.equals(Attribute.PASSWORD.getLocalName())) {\n                            password = reader.getAttributeValue(i);\n                        }\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n            }\n\n\n        }\n        return new MailSessionServer(attributes[0], username, password);\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n\n        final ModelNode address = new ModelNode();\n        address.add(ModelDescriptionConstants.SUBSYSTEM, MailExtension.SUBSYSTEM_NAME);\n        address.protect();\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).set(address);\n\n        list.add(subsystem);\n\n\n        List<MailSessionConfig> sessionConfigList = new LinkedList<MailSessionConfig>();\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case MAIL_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case MAIL_SESSION: {\n                            sessionConfigList.add(parseMailSession(reader, list));\n                            break;\n                        }\n                        default: {\n                            reader.handleAny(list);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n        for (MailSessionConfig c : sessionConfigList) {\n            final ModelNode dsAddress = address.clone();\n            dsAddress.add(ModelKeys.MAIL_SESSION, c.getJndiName());\n            dsAddress.protect();\n\n            final ModelNode operation = new ModelNode();\n            operation.get(OP_ADDR).set(dsAddress);\n            operation.get(OP).set(ADD);\n\n            Util.fillFrom(operation, c);\n            list.add(operation);\n\n\n        }\n\n        log.trace(\"parsing done, config is: \" + sessionConfigList);\n        log.trace(\"list is: \" + list);\n\n    }","id":87491,"modified_method":"/**\n     * {@inheritDoc}\n     */\n\n    public void readElement(XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n\n        final ModelNode address = new ModelNode();\n        address.add(ModelDescriptionConstants.SUBSYSTEM, MailExtension.SUBSYSTEM_NAME);\n        address.protect();\n\n        final ModelNode subsystem = new ModelNode();\n        subsystem.get(OP).set(ADD);\n        subsystem.get(OP_ADDR).set(address);\n\n        list.add(subsystem);\n\n\n        List<MailSessionConfig> sessionConfigList = new LinkedList<MailSessionConfig>();\n\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case MAIL_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case MAIL_SESSION: {\n                            sessionConfigList.add(parseMailSession(reader, list));\n                            break;\n                        }\n                        default: {\n                            reader.handleAny(list);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n\n        for (MailSessionConfig c : sessionConfigList) {\n            final ModelNode dsAddress = address.clone();\n            dsAddress.add(ModelKeys.MAIL_SESSION, c.getJndiName());\n            dsAddress.protect();\n\n            final ModelNode operation = new ModelNode();\n            operation.get(OP_ADDR).set(dsAddress);\n            operation.get(OP).set(ADD);\n\n            Util.fillFrom(operation, c);\n            list.add(operation);\n\n\n        }\n\n        log.tracef(\"parsing done, config is: %s\", sessionConfigList);\n        log.tracef(\"list is: %s\", list);\n\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MailSessionConfig parseMailSession(final XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        log.debug(\"parsing mail session\");\n        MailSessionConfig cfg = new MailSessionConfig();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            Attribute attr = Attribute.forName(reader.getAttributeLocalName(i));\n            String value = reader.getAttributeValue(i);\n            if (attr == Attribute.JNDI_NAME) {\n                String jndiName = value;\n                log.trace(\"jndi name: \" + jndiName);\n                cfg.setJndiName(jndiName);\n            }\n            if (attr == Attribute.DEBUG) {\n                boolean debug = Boolean.parseBoolean(value.trim());\n                cfg.setDebug(debug);\n            }\n\n        }\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case MAIL_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case SMTP_SERVER: {\n                            cfg.setSmtpServer(parseServerConfig(reader));\n                            break;\n                        }\n                        case POP3_SERVER: {\n                            cfg.setPop3Server(parseServerConfig(reader));\n\n                            break;\n                        }\n                        case IMAP_SERVER: {\n                            cfg.setImapServer(parseServerConfig(reader));\n                            break;\n                        }\n                        default: {\n                            reader.handleAny(list);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        return cfg;\n    }","id":87492,"modified_method":"private MailSessionConfig parseMailSession(final XMLExtendedStreamReader reader, List<ModelNode> list) throws XMLStreamException {\n        log.debug(\"parsing mail session\");\n        MailSessionConfig cfg = new MailSessionConfig();\n\n        for (int i = 0; i < reader.getAttributeCount(); i++) {\n            Attribute attr = Attribute.forName(reader.getAttributeLocalName(i));\n            String value = reader.getAttributeValue(i);\n            if (attr == Attribute.JNDI_NAME) {\n                String jndiName = value;\n                log.tracef(\"jndi name: %s\", jndiName);\n                cfg.setJndiName(jndiName);\n            }\n            if (attr == Attribute.DEBUG) {\n                boolean debug = Boolean.parseBoolean(value.trim());\n                cfg.setDebug(debug);\n            }\n\n        }\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case MAIL_1_0: {\n                    final Element element = Element.forName(reader.getLocalName());\n                    switch (element) {\n                        case SMTP_SERVER: {\n                            cfg.setSmtpServer(parseServerConfig(reader));\n                            break;\n                        }\n                        case POP3_SERVER: {\n                            cfg.setPop3Server(parseServerConfig(reader));\n\n                            break;\n                        }\n                        case IMAP_SERVER: {\n                            cfg.setImapServer(parseServerConfig(reader));\n                            break;\n                        }\n                        default: {\n                            reader.handleAny(list);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n        return cfg;\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        log.trace(\"model node: \" + context.getModelNode());\n        ModelNode model = context.getModelNode();\n        List<Property> sessions = model.get(ModelKeys.MAIL_SESSION).asPropertyList();\n\n        /*List<Property> props = mailSession.getValue().asPropertyList();\n        log.info(\"properties: \"+props);*/\n        for (Property mailSession : sessions) {\n            String jndi = mailSession.getName();\n            log.debug(\"jndi: \" + jndi);\n            ModelNode sessionData = mailSession.getValue();\n            writer.writeStartElement(Element.MAIL_SESSION.getLocalName());\n\n            writer.writeAttribute(Attribute.JNDI_NAME.getLocalName(), jndi);\n            if (sessionData.hasDefined(ModelKeys.DEBUG)) {\n                writer.writeAttribute(Attribute.DEBUG.getLocalName(), sessionData.get(ModelKeys.DEBUG).asString());\n            }\n\n\n            if (sessionData.hasDefined(ModelKeys.SMTP_SERVER)) {\n                writeServerModel(writer, sessionData, ModelKeys.SMTP_SERVER);\n\n            }\n            if (sessionData.hasDefined(ModelKeys.POP3_SERVER)) {\n                writeServerModel(writer, sessionData, ModelKeys.POP3_SERVER);\n            }\n\n            if (sessionData.hasDefined(ModelKeys.IMAP_SERVER)) {\n                writeServerModel(writer, sessionData, ModelKeys.IMAP_SERVER);\n            }\n\n\n            //writer.writeEndElement();\n\n            writer.writeEndElement();\n        }\n\n        writer.writeEndElement();\n\n    }","id":87493,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        log.tracef(\"model node: %s\", context.getModelNode());\n        ModelNode model = context.getModelNode();\n        List<Property> sessions = model.get(ModelKeys.MAIL_SESSION).asPropertyList();\n\n        /*List<Property> props = mailSession.getValue().asPropertyList();\n        log.info(\"properties: \"+props);*/\n        for (Property mailSession : sessions) {\n            String jndi = mailSession.getName();\n            log.tracef(\"jndi: %s\", jndi);\n            ModelNode sessionData = mailSession.getValue();\n            writer.writeStartElement(Element.MAIL_SESSION.getLocalName());\n\n            writer.writeAttribute(Attribute.JNDI_NAME.getLocalName(), jndi);\n            if (sessionData.hasDefined(ModelKeys.DEBUG)) {\n                writer.writeAttribute(Attribute.DEBUG.getLocalName(), sessionData.get(ModelKeys.DEBUG).asString());\n            }\n\n\n            if (sessionData.hasDefined(ModelKeys.SMTP_SERVER)) {\n                writeServerModel(writer, sessionData, ModelKeys.SMTP_SERVER);\n\n            }\n            if (sessionData.hasDefined(ModelKeys.POP3_SERVER)) {\n                writeServerModel(writer, sessionData, ModelKeys.POP3_SERVER);\n            }\n\n            if (sessionData.hasDefined(ModelKeys.IMAP_SERVER)) {\n                writeServerModel(writer, sessionData, ModelKeys.IMAP_SERVER);\n            }\n\n\n            //writer.writeEndElement();\n\n            writer.writeEndElement();\n        }\n\n        writer.writeEndElement();\n\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeServerModel(XMLExtendedStreamWriter writer, ModelNode sessionData, final String name) throws XMLStreamException {\n        ModelNode server = sessionData.get(name);\n        boolean credentials = server.hasDefined(ModelKeys.CREDENTIALS);\n        if (credentials) {\n            writer.writeStartElement(Element.forName(name).getLocalName());\n        } else {\n            writer.writeEmptyElement(Element.forName(name).getLocalName());\n        }\n        writer.writeAttribute(Attribute.SERVER_ADDRESS.getLocalName(), server.get(ModelKeys.SERVER_ADDRESS).asString());\n        writer.writeAttribute(Attribute.SERVER_PORT.getLocalName(), server.get(ModelKeys.SERVER_PORT).asString());\n        if (credentials) {\n            writer.writeEmptyElement(Element.LOGIN.getLocalName());\n            writer.writeAttribute(Attribute.USERNAME.getLocalName(), server.get(ModelKeys.CREDENTIALS).get(ModelKeys.USERNAME).asString());\n            writer.writeAttribute(Attribute.PASSWORD.getLocalName(), server.get(ModelKeys.CREDENTIALS).get(ModelKeys.PASSWORD).asString());\n            writer.writeEndElement();\n        }\n    }","id":87494,"modified_method":"private void writeServerModel(XMLExtendedStreamWriter writer, ModelNode sessionData, final String name) throws XMLStreamException {\n        ModelNode server = sessionData.get(name);\n        boolean credentials = server.hasDefined(ModelKeys.CREDENTIALS);\n        if (credentials) {\n            writer.writeStartElement(Element.forName(name).getLocalName());\n        } else {\n            writer.writeEmptyElement(Element.forName(name).getLocalName());\n        }\n        writer.writeAttribute(Attribute.OUTBOUND_SOCKET_BINDING_REF.getLocalName(), server.get(ModelKeys.OUTBOUND_SOCKET_BINDING_REF).asString());\n        if (credentials) {\n            writer.writeEmptyElement(Element.LOGIN.getLocalName());\n            writer.writeAttribute(Attribute.USERNAME.getLocalName(), server.get(ModelKeys.CREDENTIALS).get(ModelKeys.USERNAME).asString());\n            writer.writeAttribute(Attribute.PASSWORD.getLocalName(), server.get(ModelKeys.CREDENTIALS).get(ModelKeys.PASSWORD).asString());\n            writer.writeEndElement();\n        }\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n\n        resourceRegistration.registerReadOnlyAttribute(NAME, null);\n        resourceRegistration.registerReadWriteAttribute(SOURCE_PORT, null, new OutboundSocketBindingWriteHandler(SOURCE_PORT.getValidator(),\n                new IntRangeValidator(0, 65535, true, false), remoteDestination));\n        resourceRegistration.registerReadWriteAttribute(SOURCE_INTERFACE, null, new OutboundSocketBindingWriteHandler(SOURCE_INTERFACE.getValidator(),\n                new StringLengthValidator(1, Integer.MAX_VALUE, true, false), remoteDestination));\n        resourceRegistration.registerReadWriteAttribute(FIXED_SOURCE_PORT, null, new OutboundSocketBindingWriteHandler(new ModelTypeValidator(ModelType.BOOLEAN, true, true),\n                new ModelTypeValidator(ModelType.BOOLEAN, true, false), remoteDestination));\n    }","id":87495,"modified_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration resourceRegistration) {\n\n        resourceRegistration.registerReadWriteAttribute(SOURCE_PORT, null, new OutboundSocketBindingWriteHandler(SOURCE_PORT.getValidator(),\n                new IntRangeValidator(0, 65535, true, false), remoteDestination));\n        resourceRegistration.registerReadWriteAttribute(SOURCE_INTERFACE, null, new OutboundSocketBindingWriteHandler(SOURCE_INTERFACE.getValidator(),\n                new StringLengthValidator(1, Integer.MAX_VALUE, true, false), remoteDestination));\n        resourceRegistration.registerReadWriteAttribute(FIXED_SOURCE_PORT, null, new OutboundSocketBindingWriteHandler(new ModelTypeValidator(ModelType.BOOLEAN, true, true),\n                new ModelTypeValidator(ModelType.BOOLEAN, true, false), remoteDestination));\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(final ModelNode operation, final ModelNode model) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String outboundSocketBindingName = address.getLastElement().getValue();\n        model.get(ModelDescriptionConstants.NAME).set(outboundSocketBindingName);\n        model.get(ModelDescriptionConstants.HOST).set(operation.get(ModelDescriptionConstants.HOST));\n        model.get(ModelDescriptionConstants.PORT).set(operation.get(ModelDescriptionConstants.PORT));\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_INTERFACE)) {\n            model.get(ModelDescriptionConstants.SOURCE_INTERFACE).set(operation.get(ModelDescriptionConstants.SOURCE_INTERFACE));\n        }\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.SOURCE_PORT).set(operation.get(ModelDescriptionConstants.SOURCE_PORT));\n        }\n        if (operation.hasDefined(FIXED_SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.FIXED_SOURCE_PORT).set(operation.get(FIXED_SOURCE_PORT));\n        }\n    }","id":87496,"modified_method":"@Override\n    protected void populateModel(final ModelNode operation, final ModelNode model) throws OperationFailedException {\n\n        model.get(ModelDescriptionConstants.HOST).set(operation.get(ModelDescriptionConstants.HOST));\n        model.get(ModelDescriptionConstants.PORT).set(operation.get(ModelDescriptionConstants.PORT));\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_INTERFACE)) {\n            model.get(ModelDescriptionConstants.SOURCE_INTERFACE).set(operation.get(ModelDescriptionConstants.SOURCE_INTERFACE));\n        }\n        if (operation.hasDefined(ModelDescriptionConstants.SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.SOURCE_PORT).set(operation.get(ModelDescriptionConstants.SOURCE_PORT));\n        }\n        if (operation.hasDefined(FIXED_SOURCE_PORT)) {\n            model.get(ModelDescriptionConstants.FIXED_SOURCE_PORT).set(operation.get(FIXED_SOURCE_PORT));\n        }\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model,\n                                  final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final String outboundSocketName = model.get(ModelDescriptionConstants.NAME).asString();\n        final ServiceController<OutboundSocketBinding> outboundSocketBindingServiceController;\n        try {\n            outboundSocketBindingServiceController = this.installOutboundSocketBindingService(context, model, outboundSocketName);\n        } catch (UnknownHostException e) {\n            throw new RuntimeException(e);\n        }\n        serviceControllers.add(outboundSocketBindingServiceController);\n    }","id":87497,"modified_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model,\n                                  final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> serviceControllers) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String outboundSocketName = address.getLastElement().getValue();\n        final ServiceController<OutboundSocketBinding> outboundSocketBindingServiceController;\n        try {\n            outboundSocketBindingServiceController = this.installOutboundSocketBindingService(context, model, outboundSocketName);\n        } catch (UnknownHostException e) {\n            throw new RuntimeException(e);\n        }\n        serviceControllers.add(outboundSocketBindingServiceController);\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static MailSessionServer readServerConfig(final OperationContext operationContext, final ModelNode model) {\n        final String address = model.require(SERVER_ADDRESS).asString();\n        final int port = model.require(SERVER_PORT).asInt();\n        final Credentials credentials = readCredentials(operationContext, model);\n        return new MailSessionServer(address, port, credentials);\n    }","id":87498,"modified_method":"private static MailSessionServer readServerConfig(final OperationContext operationContext, final ModelNode model) {\n        final String socket = model.require(OUTBOUND_SOCKET_BINDING_REF).asString();\n        final Credentials credentials = readCredentials(operationContext, model);\n        return new MailSessionServer(socket, credentials);\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void addServerConfig(final ModelNode operation, final MailSessionServer server, final String name) {\n        operation.get(name).get(SERVER_ADDRESS).set(server.getAddress());\n        operation.get(name).get(SERVER_PORT).set(server.getPort());\n        addCredentials(operation.get(name), server.getCredentials());\n    }","id":87499,"modified_method":"private static void addServerConfig(final ModelNode operation, final MailSessionServer server, final String name) {\n        operation.get(name).get(OUTBOUND_SOCKET_BINDING_REF).set(server.getOutgoingSocketBinding());\n        addCredentials(operation.get(name), server.getCredentials());\n    }","commit_id":"5f7e95446970a974e56272ffea3e907140f28f3e","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected String fixAntXMLProjectName(String fileName, String content) {\n\t\tint x = 0;\n\n\t\tif (fileName.endsWith(\"-ext/build.xml\")) {\n\t\t\tx = fileName.indexOf(\"ext/\");\n\n\t\t\tif (x == -1) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x + 4;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-hook/build.xml\")) {\n\t\t\tx = fileName.indexOf(\"hooks/\");\n\n\t\t\tif (x == -1) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x + 6;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-layouttpl/build.xml\")) {\n\t\t\tx = fileName.indexOf(\"layouttpl/\");\n\n\t\t\tif (x == -1) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x + 10;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-portlet/build.xml\")) {\n\t\t\tx = fileName.indexOf(\"portlets/\");\n\n\t\t\tif (x == -1) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x + 9;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-theme/build.xml\")) {\n\t\t\tx = fileName.indexOf(\"themes/\");\n\n\t\t\tif (x == -1) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x + 7;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-web/build.xml\") &&\n\t\t\t\t !fileName.endsWith(\"/ext-web/build.xml\")) {\n\n\t\t\tx = fileName.indexOf(\"webs/\");\n\n\t\t\tif (x == -1) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x + 5;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn content;\n\t\t}\n\n\t\tint y = fileName.indexOf(\"/\", x);\n\n\t\tString correctProjectElementText =\n\t\t\t\"<project name=\\\"\" + fileName.substring(x, y) + \"\\\"\";\n\n\t\tif (!content.contains(correctProjectElementText)) {\n\t\t\tx = content.indexOf(\"<project name=\\\"\");\n\n\t\t\ty = content.indexOf(\"\\\"\", x) + 1;\n\t\t\ty = content.indexOf(\"\\\"\", y) + 1;\n\n\t\t\tcontent =\n\t\t\t\tcontent.substring(0, x) + correctProjectElementText +\n\t\t\t\t\tcontent.substring(y);\n\n\t\t\tprocessErrorMessage(\n\t\t\t\tfileName, fileName + \" has an incorrect project name\");\n\t\t}\n\n\t\treturn content;\n\t}","id":87500,"modified_method":"protected String fixAntXMLProjectName(String fileName, String content) {\n\t\tint x = 0;\n\n\t\tif (fileName.endsWith(\"-ext/build.xml\")) {\n\t\t\tif (fileName.startsWith(\"ext/\")) {\n\t\t\t\tx = 4;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-hook/build.xml\")) {\n\t\t\tif (fileName.startsWith(\"hooks/\")) {\n\t\t\t\tx = 6;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-layouttpl/build.xml\")) {\n\t\t\tif (fileName.startsWith(\"layouttpl/\")) {\n\t\t\t\tx = 10;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-portlet/build.xml\")) {\n\t\t\tif (fileName.startsWith(\"portlets/\")) {\n\t\t\t\tx = 9;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-theme/build.xml\")) {\n\t\t\tif (fileName.startsWith(\"themes/\")) {\n\t\t\t\tx = 7;\n\t\t\t}\n\t\t}\n\t\telse if (fileName.endsWith(\"-web/build.xml\") &&\n\t\t\t\t !fileName.endsWith(\"/ext-web/build.xml\")) {\n\n\t\t\tif (fileName.startsWith(\"webs/\")) {\n\t\t\t\tx = 5;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn content;\n\t\t}\n\n\t\tint y = fileName.indexOf(\"/\", x);\n\n\t\tString correctProjectElementText =\n\t\t\t\"<project name=\\\"\" + fileName.substring(x, y) + \"\\\"\";\n\n\t\tif (!content.contains(correctProjectElementText)) {\n\t\t\tx = content.indexOf(\"<project name=\\\"\");\n\n\t\t\ty = content.indexOf(\"\\\"\", x) + 1;\n\t\t\ty = content.indexOf(\"\\\"\", y) + 1;\n\n\t\t\tcontent =\n\t\t\t\tcontent.substring(0, x) + correctProjectElementText +\n\t\t\t\t\tcontent.substring(y);\n\n\t\t\tprocessErrorMessage(\n\t\t\t\tfileName, fileName + \" has an incorrect project name\");\n\t\t}\n\n\t\treturn content;\n\t}","commit_id":"95d8e0da052648d4c50c67bcaf4f3e0adc368e15","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      MigrationHelper.stageFixDependencies(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"FixModuleDependencies\", t);\n      }\n    }\n  }","id":87501,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      new DependenciesCorrectionStage().execute(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"FixModuleDependencies\", t);\n      }\n    }\n  }","commit_id":"c30d1388d469424f1a3d0fdeda48c41002cccff0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      MigrationHelper.stageStubsMigration(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"MigrateStubs\", t);\n      }\n    }\n  }","id":87502,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      new StubConversionStage().execute(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"MigrateStubs\", t);\n      }\n    }\n  }","commit_id":"c30d1388d469424f1a3d0fdeda48c41002cccff0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      MigrationState mComp = ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(MigrationState.class);\n      MState state = mComp.getMigrationState();\n\n      String title = \"Migration from MPS 1.5 to MPS 2.0\";\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Welcome to migration assistant.\").append(\"\\n\");\n      sb.append(\"This will help to migrate code written in MPS 1.5 to MPS 2.0.\").append(\"\\n\");\n      sb.append(\"The migration consists of \").append(MState.values().length).append(\" steps. \").append(\"On each step MPS will tell you what it intends to do, then perform a refactoring, restart and, after some of the steps, ask you to change some code by hand.\").append(\"\\n\");\n      sb.append(\"After each restart you will have 3 options - to continue, abort or schedule the migration. You can continue the migration at any time just by executing MainMenu->Tools->Continue Migration to MPS 2.0\").append(\"\\n\");\n      sb.append(\"You can read more about migration here: http://http://confluence.jetbrains.net/display/MPS/Migration20\").append(\"\\n\\n\");\n      sb.append(\"WARNING: your files will be changed by the assistant. Please ensure all work is saved and you have a backup copy of your code.\").append(\"\\n\\n\");\n      sb.append(NameUtil.capitalize(Migration20_Action.this.getContinuationWord(state, _params)) + \" migration?\");\n\n\n      String[] values = new String[]{NameUtil.capitalize(Migration20_Action.this.getContinuationWord(state, _params)), \"Abort Migration\", \"Cancel\"};\n\n      int res = Messages.showDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), sb.toString(), title, values, 0, Messages.getQuestionIcon());\n\n      if (res == 0) {\n        if (state == MState.DONE) {\n          mComp.setMigrationState(MState.INITIAL);\n        }\n        new MigrationHelper(((Project) MapSequence.fromMap(_params).get(\"project\"))).migrate();\n      } else if (res == 1) {\n        mComp.setMigrationState(MState.INITIAL);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"Migration20\", t);\n      }\n    }\n  }","id":87503,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      MigrationState mComp = ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(MigrationState.class);\n      MState state = mComp.getMigrationState();\n\n      String title = \"Migration from MPS 1.5 to MPS 2.0\";\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"Welcome to migration assistant.\").append(\"\\n\");\n      sb.append(\"This will help to migrate code written in MPS 1.5 to MPS 2.0.\").append(\"\\n\");\n      sb.append(\"The migration consists of \").append(MState.values().length - 2).append(\" steps. \").append(\"On each step MPS will tell you what it intends to do, then perform a refactoring, restart and, after some of the steps, ask you to change some code by hand.\").append(\"\\n\");\n      sb.append(\"After each restart you will have 3 options - to continue, abort or schedule the migration. You can continue the migration at any time just by executing MainMenu->Tools->Continue Migration to MPS 2.0\").append(\"\\n\");\n      sb.append(\"You can read more about migration here: http://http://confluence.jetbrains.net/display/MPS/Migration20\").append(\"\\n\\n\");\n      sb.append(\"WARNING: your files will be changed by the assistant. Please ensure all work is saved and you have a backup copy of your code.\").append(\"\\n\\n\");\n      sb.append(NameUtil.capitalize(Migration20_Action.this.getContinuationWord(state, _params)) + \" migration?\");\n\n      String[] values = new String[]{NameUtil.capitalize(Migration20_Action.this.getContinuationWord(state, _params)), \"Abort Migration\", \"Cancel\"};\n\n      int res = Messages.showDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), sb.toString(), title, values, 0, Messages.getQuestionIcon());\n\n      if (res == 0) {\n        if (state == MState.DONE) {\n          mComp.setMigrationState(MState.INITIAL);\n        }\n        new MigrationHelper(((Project) MapSequence.fromMap(_params).get(\"project\"))).migrate();\n      } else if (res == 1) {\n        mComp.setMigrationState(MState.INITIAL);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"Migration20\", t);\n      }\n    }\n  }","commit_id":"c30d1388d469424f1a3d0fdeda48c41002cccff0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void migrate() {\n    MigrationState msComponent = myProject.getComponent(MigrationState.class);\n    final MPSProject mpsProject = myProject.getComponent(MPSProject.class);\n\n    if (msComponent.getMigrationState() == MState.INITIAL) {\n      stageUpgradePersistence(mpsProject);\n      msComponent.setMigrationState(MState.PERSISTENCE_UPGRADED);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.PERSISTENCE_UPGRADED) {\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          stageFixDependencies(mpsProject);\n        }\n      });\n      msComponent.setMigrationState(MState.LANGUAGES_DEPS_CORRECTED);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.LANGUAGES_DEPS_CORRECTED) {\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          stageStubsMigration(mpsProject);\n        }\n      });\n      msComponent.setMigrationState(MState.STUBS_CONVERTED);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.STUBS_CONVERTED) {\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          stageLanguageMigrations(mpsProject);\n        }\n      });\n      msComponent.setMigrationState(MState.LANGUAGES_MIGRATION);\n      cleanRestart();\n    }\n\n    if (msComponent.getMigrationState() == MState.LANGUAGES_MIGRATION) {\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          stageRegeneration(mpsProject);\n        }\n      });\n      msComponent.setMigrationState(MState.REGENERATION);\n    }\n\n    if (msComponent.getMigrationState() == MState.REGENERATION) {\n      msComponent.setMigrationState(MState.DONE);\n    }\n  }","id":87504,"modified_method":"public void migrate() {\n    MigrationState msComponent = myProject.getComponent(MigrationState.class);\n    final MPSProject mpsProject = myProject.getComponent(MPSProject.class);\n\n    for (MState state : MState.values()) {\n      if (msComponent.getMigrationState() == state) {\n        MState next = MState.values()[state.ordinal() + 1];\n        final MigrationStage stage = next.getStage();\n\n        if (stage == null) continue;\n\n        String mb = stage.messageBefore();\n        if (mb != null) {\n          Messages.showMessageDialog(mb, stage.title(), Messages.getInformationIcon());\n        }\n\n        Runnable stageRunnable = new Runnable() {\n          public void run() {\n            stage.execute(mpsProject);\n          }\n        };\n\n        if (stage.needsCommand()) {\n          ModelAccess.instance().runWriteActionInCommand(stageRunnable);\n        } else {\n          stageRunnable.run();\n        }\n\n        String ma = stage.messageAfter();\n        if (ma != null) {\n          Messages.showMessageDialog(ma, stage.title(), Messages.getInformationIcon());\n        }\n\n        if (stage.needsRestart()) {\n          cleanRestart();\n        }\n      }\n    }\n  }","commit_id":"c30d1388d469424f1a3d0fdeda48c41002cccff0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MyState getState() {\n    MyState state = new MyState();\n    state.myState = myState.toInt();\n    return state;\n  }","id":87505,"modified_method":"public MyState getState() {\n    MyState state = new MyState();\n    state.myState = myState.name();\n    return state;\n  }","commit_id":"c30d1388d469424f1a3d0fdeda48c41002cccff0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void loadState(MyState state) {\n    myState = MState.fromInt(state.myState);\n  }","id":87506,"modified_method":"public void loadState(MyState state) {\n    myState = MState.valueOf(state.myState);\n  }","commit_id":"c30d1388d469424f1a3d0fdeda48c41002cccff0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      MigrationHelper.stageUpgradePersistence(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"UpgradePersistence\", t);\n      }\n    }\n  }","id":87507,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      new PersistenceUpgradeStage().execute(((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"UpgradePersistence\", t);\n      }\n    }\n  }","commit_id":"c30d1388d469424f1a3d0fdeda48c41002cccff0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<InlineVariableRefactoring> ref = new Wrappers._T<InlineVariableRefactoring>();\n      boolean isAvailable;\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ref.value = InlineVariableRefactoring.createRefactoring(((SNode) MapSequence.fromMap(_params).get(\"node\")));\n        }\n      });\n      isAvailable = ref.value.checkRefactoring(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      if (isAvailable) {\n        ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n          public void run() {\n            SNode result = ref.value.doRefactoring();\n            ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(result);\n          }\n        });\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"InlineLocalVariable\", t);\n      }\n    }\n  }","id":87508,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final Wrappers._T<InlineVariableRefactoring> ref = new Wrappers._T<InlineVariableRefactoring>();\n\n      final Wrappers._boolean isAvailable = new Wrappers._boolean(true);\n      String messageDialogTitle = \"Inline Variable\";\n      final Wrappers._T<String> infoMessage = new Wrappers._T<String>(null);\n      final Wrappers._T<String> yesNoMessage = new Wrappers._T<String>(null);\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          if (SNodeOperations.isInstanceOf(((SNode) MapSequence.fromMap(_params).get(\"node\")), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\")) {\n            SNode localVariableDeclaration = SNodeOperations.cast(((SNode) MapSequence.fromMap(_params).get(\"node\")), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n            InlineVariableAssignmentRefactoring inlineVARef = new InlineVariableAssignmentRefactoring(localVariableDeclaration);\n\n            if ((SLinkOperations.getTarget(localVariableDeclaration, \"initializer\", true) == null)) {\n              isAvailable.value = false;\n            }\n\n            String variableName = SPropertyOperations.getString(localVariableDeclaration, \"name\");\n            int nodesCount = ListSequence.fromList(inlineVARef.getNodesToRefactor()).count();\n            if (nodesCount == 0) {\n              infoMessage.value = \"Variable \" + variableName + \" is never used\";\n            } else {\n              yesNoMessage.value = \"Inline local variable '\" + variableName + \"'? (\" + NameUtil.formatNumericalString(nodesCount, \"occurence\") + \")\";\n            }\n\n            ref.value = inlineVARef;\n          } else {\n            SNode localVariableReference = SNodeOperations.cast(((SNode) MapSequence.fromMap(_params).get(\"node\")), \"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n            ref.value = new InlineVariableReferenceRefactoring(localVariableReference);\n          }\n        }\n      });\n      if (!(isAvailable.value)) {\n        return;\n      }\n\n      if (infoMessage.value != null) {\n        Messages.showInfoMessage(((Frame) MapSequence.fromMap(_params).get(\"frame\")), infoMessage.value, messageDialogTitle);\n        return;\n      }\n      if (yesNoMessage.value != null) {\n        int code = Messages.showYesNoDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), yesNoMessage.value, messageDialogTitle, null);\n        if (code != 0) {\n          return;\n        }\n      }\n\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          SNode result = ref.value.doRefactoring();\n          ((EditorContext) MapSequence.fromMap(_params).get(\"editorContext\")).select(result);\n        }\n      });\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"InlineLocalVariable\", t);\n      }\n    }\n  }","commit_id":"05b153168ecf04f15b3eb19ebef881fc93555dfc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    final Wrappers._boolean result = new Wrappers._boolean();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        result.value = InlineVariableRefactoring.isApplicable(((SNode) MapSequence.fromMap(_params).get(\"node\")));\n      }\n    });\n    return result.value && !(((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).isReadOnly());\n  }","id":87509,"modified_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    boolean result = SNodeOperations.isInstanceOf(((SNode) MapSequence.fromMap(_params).get(\"node\")), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\") || SNodeOperations.isInstanceOf(((SNode) MapSequence.fromMap(_params).get(\"node\")), \"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n    return result && !(((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).isReadOnly());\n  }","commit_id":"05b153168ecf04f15b3eb19ebef881fc93555dfc","url":"https://github.com/JetBrains/MPS"},{"original_method":"public final void actionPerformed(final AnActionEvent e) {\n    final THashMap<String, Object> params = new THashMap<String, Object>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        collectActionData(e, params);\n      }\n    });\n    final ModelAccess access = ModelAccess.instance();\n    if (myExecuteOutsideCommand) {\n      doExecute(e, params);\n    } else {\n      access.runWriteActionInCommand(new Runnable() {\n        public void run() {\n          doExecute(e, params);\n        }\n      });\n    }\n  }","id":87510,"modified_method":"public final void actionPerformed(final AnActionEvent event) {\n    final THashMap<String, Object> params = new THashMap<String, Object>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        collectActionData(event, params);\n      }\n    });\n    final ModelAccess access = ModelAccess.instance();\n    if (myExecuteOutsideCommand) {\n      doExecute(event, params);\n    } else {\n      Project project = getEventProject(event);\n      if (project != null) {\n        // modern API\n        access.runWriteActionInCommand(new Runnable() {\n          public void run() {\n            doExecute(event, params);\n          }\n        }, getTemplatePresentation().getText(), null, false, project.getComponent(MPSProject.class));\n      }else {\n        // deprecated API\n        access.runWriteActionInCommand(new Runnable() {\n          public void run() {\n            doExecute(event, params);\n          }\n        });\n      }\n    }\n  }","commit_id":"7d3f4d81a12196bab33217f0bc9222ed13511905","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void actionPerformed(@Nullable AnActionEvent e) {\n    ApplicationManager.getApplication().saveSettings();\n\n    ChooseComponentsToExportDialog dialog = new ChooseComponentsToExportDialog(getExportableComponentsMap(true, true), true,\n                                                                               IdeBundle.message(\"title.select.components.to.export\"),\n                                                                               IdeBundle.message(\n                                                                                 \"prompt.please.check.all.components.to.export\"));\n    if (!dialog.showAndGet()) {\n      return;\n    }\n\n    Set<ExportableComponent> markedComponents = dialog.getExportableComponents();\n    if (markedComponents.isEmpty()) {\n      return;\n    }\n\n    Set<File> exportFiles = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);\n    for (ExportableComponent markedComponent : markedComponents) {\n      ContainerUtil.addAll(exportFiles, markedComponent.getExportFiles());\n    }\n\n    final File saveFile = dialog.getExportFile();\n    try {\n      if (saveFile.exists()) {\n        final int ret = Messages.showOkCancelDialog(\n          IdeBundle.message(\"prompt.overwrite.settings.file\", FileUtil.toSystemDependentName(saveFile.getPath())),\n          IdeBundle.message(\"title.file.already.exists\"), Messages.getWarningIcon());\n        if (ret != Messages.OK) return;\n      }\n      final JarOutputStream output = new JarOutputStream(new BufferedOutputStream(new FileOutputStream(saveFile)));\n      try {\n        final File configPath = new File(PathManager.getConfigPath());\n        final HashSet<String> writtenItemRelativePaths = new HashSet<String>();\n        for (File file : exportFiles) {\n          final String rPath = FileUtil.getRelativePath(configPath, file);\n          assert rPath != null;\n          final String relativePath = FileUtil.toSystemIndependentName(rPath);\n          if (file.exists()) {\n            ZipUtil.addFileOrDirRecursively(output, saveFile, file, relativePath, null, writtenItemRelativePaths);\n          }\n        }\n\n        exportInstalledPlugins(saveFile, output, writtenItemRelativePaths);\n\n        final File magicFile = new File(FileUtil.getTempDirectory(), ImportSettingsFilenameFilter.SETTINGS_JAR_MARKER);\n        FileUtil.createIfDoesntExist(magicFile);\n        magicFile.deleteOnExit();\n        ZipUtil.addFileToZip(output, magicFile, ImportSettingsFilenameFilter.SETTINGS_JAR_MARKER, writtenItemRelativePaths, null);\n      }\n      finally {\n        output.close();\n      }\n      ShowFilePathAction.showDialog(getEventProject(e), IdeBundle.message(\"message.settings.exported.successfully\"),\n                                    IdeBundle.message(\"title.export.successful\"), saveFile, null);\n    }\n    catch (IOException e1) {\n      Messages.showErrorDialog(IdeBundle.message(\"error.writing.settings\", e1.toString()), IdeBundle.message(\"title.error.writing.file\"));\n    }\n  }","id":87511,"modified_method":"@Override\n  public void actionPerformed(@Nullable AnActionEvent e) {\n    ApplicationManager.getApplication().saveSettings();\n\n    ChooseComponentsToExportDialog dialog = new ChooseComponentsToExportDialog(getExportableComponentsMap(true, true), true,\n                                                                               IdeBundle.message(\"title.select.components.to.export\"),\n                                                                               IdeBundle.message(\n                                                                                 \"prompt.please.check.all.components.to.export\"));\n    if (!dialog.showAndGet()) {\n      return;\n    }\n\n    Set<ExportableComponent> markedComponents = dialog.getExportableComponents();\n    if (markedComponents.isEmpty()) {\n      return;\n    }\n\n    Set<File> exportFiles = new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);\n    for (ExportableComponent markedComponent : markedComponents) {\n      ContainerUtil.addAll(exportFiles, markedComponent.getExportFiles());\n    }\n\n    final File saveFile = dialog.getExportFile();\n    try {\n      if (saveFile.exists() && Messages.showOkCancelDialog(\n        IdeBundle.message(\"prompt.overwrite.settings.file\", FileUtil.toSystemDependentName(saveFile.getPath())),\n        IdeBundle.message(\"title.file.already.exists\"), Messages.getWarningIcon()) != Messages.OK) {\n        return;\n      }\n\n      MyZipOutputStream zipOut = new MyZipOutputStream(new BufferedOutputStream(new FileOutputStream(saveFile)));\n      try {\n        Set<String> writtenItemRelativePaths = new THashSet<String>();\n        String configRoot = PathManager.getConfigPath();\n        for (File file : exportFiles) {\n          if (file.exists()) {\n            String rPath = FileUtilRt.getRelativePath(configRoot, file.getAbsolutePath(), File.separatorChar);\n            assert rPath != null;\n            ZipUtil.addFileOrDirRecursively(zipOut, null, file, FileUtilRt.toSystemIndependentName(rPath), null, writtenItemRelativePaths);\n          }\n        }\n\n        exportInstalledPlugins(zipOut);\n\n        ZipEntry zipEntry = new ZipEntry(ImportSettingsFilenameFilter.SETTINGS_JAR_MARKER);\n        zipOut.putNextEntry(zipEntry);\n        zipOut.closeEntry();\n      }\n      finally {\n        zipOut.close();\n      }\n      ShowFilePathAction.showDialog(getEventProject(e), IdeBundle.message(\"message.settings.exported.successfully\"),\n                                    IdeBundle.message(\"title.export.successful\"), saveFile, null);\n    }\n    catch (IOException e1) {\n      Messages.showErrorDialog(IdeBundle.message(\"error.writing.settings\", e1.toString()), IdeBundle.message(\"title.error.writing.file\"));\n    }\n  }","commit_id":"7bee09ce72aacfedcf4efc2132baa30ed11fa528","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void exportInstalledPlugins(File saveFile, JarOutputStream output, HashSet<String> writtenItemRelativePaths) throws IOException {\n    final List<String> oldPlugins = new ArrayList<String>();\n    for (IdeaPluginDescriptor descriptor : PluginManagerCore.getPlugins()) {\n      if (!descriptor.isBundled() && descriptor.isEnabled()) {\n        oldPlugins.add(descriptor.getPluginId().getIdString());\n      }\n    }\n    if (!oldPlugins.isEmpty()) {\n      File tempFile = FileUtil.createTempFile(\"installed\", \"plugins\");\n      tempFile.deleteOnExit();\n      PluginManagerCore.savePluginsList(oldPlugins, false, tempFile);\n      ZipUtil.addDirToZipRecursively(output, saveFile, tempFile, \"/\" + PluginManager.INSTALLED_TXT, null, writtenItemRelativePaths);\n    }\n  }","id":87512,"modified_method":"private static void exportInstalledPlugins(@NotNull MyZipOutputStream zipOut) throws IOException {\n    List<String> plugins = new ArrayList<String>();\n    for (IdeaPluginDescriptor descriptor : PluginManagerCore.getPlugins()) {\n      if (!descriptor.isBundled() && descriptor.isEnabled()) {\n        plugins.add(descriptor.getPluginId().getIdString());\n      }\n    }\n    if (plugins.isEmpty()) {\n      return;\n    }\n\n    ZipEntry e = new ZipEntry(PluginManager.INSTALLED_TXT);\n    zipOut.putNextEntry(e);\n    zipOut.ignoreClose = true;\n    try {\n      PluginManagerCore.writePluginsList(plugins, new OutputStreamWriter(zipOut, CharsetToolkit.UTF8_CHARSET));\n    }\n    finally {\n      zipOut.ignoreClose = false;\n      zipOut.closeEntry();\n    }\n  }","commit_id":"7bee09ce72aacfedcf4efc2132baa30ed11fa528","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void savePluginsList(@NotNull Collection<String> ids, boolean append, @NotNull File plugins) throws IOException {\n    if (!plugins.isFile()) {\n      FileUtil.ensureCanCreateFile(plugins);\n    }\n    PrintWriter printWriter = new PrintWriter(new BufferedWriter(new FileWriter(plugins, append)));\n    try {\n      for (String id : ids) {\n        printWriter.println(id);\n      }\n      printWriter.flush();\n    }\n    finally {\n      printWriter.close();\n    }\n  }","id":87513,"modified_method":"public static void savePluginsList(@NotNull Collection<String> ids, boolean append, @NotNull File plugins) throws IOException {\n    if (!plugins.isFile()) {\n      FileUtil.ensureCanCreateFile(plugins);\n    }\n    writePluginsList(ids, new BufferedWriter(new FileWriter(plugins, append)));\n  }","commit_id":"7bee09ce72aacfedcf4efc2132baa30ed11fa528","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean checkVersion() {\n    final ApplicationNamesInfo appNamesInfo = ApplicationNamesInfo.getInstance();\n    if (originalVersion >= 0 && originalVersion < ProjectManagerImpl.CURRENT_FORMAT_VERSION) {\n      final VirtualFile projectFile = getProjectFile();\n      LOG.assertTrue(projectFile != null);\n      String name = projectFile.getNameWithoutExtension();\n\n      String message = ProjectBundle.message(\"project.convert.old.prompt\", projectFile.getName(),\n                                             appNamesInfo.getProductName(),\n                                             name + OLD_PROJECT_SUFFIX + projectFile.getExtension());\n      if (Messages.showYesNoDialog(message, CommonBundle.getWarningTitle(), Messages.getWarningIcon()) != Messages.YES) return false;\n\n      List<String> conversionProblems = getConversionProblemsStorage();\n      if (conversionProblems != null && !conversionProblems.isEmpty()) {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(ProjectBundle.message(\"project.convert.problems.detected\"));\n        for (String s : conversionProblems) {\n          buffer.append('\\n');\n          buffer.append(s);\n        }\n        buffer.append(ProjectBundle.message(\"project.convert.problems.help\"));\n        final int result = Messages.showOkCancelDialog(myProject, buffer.toString(), ProjectBundle.message(\"project.convert.problems.title\"),\n                                               ProjectBundle.message(\"project.convert.problems.help.button\"),\n                                                 CommonBundle.getCloseButtonText(), Messages.getWarningIcon());\n        if (result == Messages.OK) {\n          HelpManager.getInstance().invokeHelp(\"project.migrationProblems\");\n        }\n      }\n\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          try {\n            VirtualFile projectDir = projectFile.getParent();\n            assert projectDir != null;\n\n            backup(projectDir, projectFile);\n\n            VirtualFile workspaceFile = getWorkspaceFile();\n            if (workspaceFile != null) {\n              backup(projectDir, workspaceFile);\n            }\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n\n        private void backup(final VirtualFile projectDir, final VirtualFile vile) throws IOException {\n          final String oldName = vile.getNameWithoutExtension() + OLD_PROJECT_SUFFIX + vile.getExtension();\n          final VirtualFile oldFile = projectDir.findOrCreateChildData(this, oldName);\n          assert oldFile != null : projectDir + \", \" + oldName;\n          VfsUtil.saveText(oldFile, VfsUtilCore.loadText(vile));\n        }\n      });\n    }\n\n    if (originalVersion > ProjectManagerImpl.CURRENT_FORMAT_VERSION) {\n      String message =\n        ProjectBundle.message(\"project.load.new.version.warning\", myProject.getName(), appNamesInfo.getProductName());\n\n      if (Messages.showYesNoDialog(message, CommonBundle.getWarningTitle(), Messages.getWarningIcon()) != Messages.YES) return false;\n    }\n\n    return true;\n  }","id":87514,"modified_method":"@Override\n  public boolean checkVersion() {\n    if (originalVersion >= 0 && originalVersion < ProjectManagerImpl.CURRENT_FORMAT_VERSION) {\n      final VirtualFile projectFile = getProjectFile();\n      LOG.assertTrue(projectFile != null);\n      String message = ProjectBundle.message(\"project.convert.old.prompt\", projectFile.getName(),\n                                             ApplicationNamesInfo.getInstance().getProductName(),\n                                             projectFile.getNameWithoutExtension() + OLD_PROJECT_SUFFIX + projectFile.getExtension());\n      if (Messages.showYesNoDialog(message, CommonBundle.getWarningTitle(), Messages.getWarningIcon()) != Messages.YES) return false;\n\n      List<String> conversionProblems = getConversionProblemsStorage();\n      if (!ContainerUtil.isEmpty(conversionProblems)) {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(ProjectBundle.message(\"project.convert.problems.detected\"));\n        for (String s : conversionProblems) {\n          buffer.append('\\n');\n          buffer.append(s);\n        }\n        buffer.append(ProjectBundle.message(\"project.convert.problems.help\"));\n        if (Messages.showOkCancelDialog(myProject, buffer.toString(), ProjectBundle.message(\"project.convert.problems.title\"),\n                                               ProjectBundle.message(\"project.convert.problems.help.button\"),\n                                                 CommonBundle.getCloseButtonText(), Messages.getWarningIcon()) == Messages.OK) {\n          HelpManager.getInstance().invokeHelp(\"project.migrationProblems\");\n        }\n      }\n\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          try {\n            VirtualFile projectDir = projectFile.getParent();\n            assert projectDir != null;\n\n            backup(projectDir, projectFile);\n\n            VirtualFile workspaceFile = getWorkspaceFile();\n            if (workspaceFile != null) {\n              backup(projectDir, workspaceFile);\n            }\n          }\n          catch (IOException e) {\n            LOG.error(e);\n          }\n        }\n\n        private void backup(final VirtualFile projectDir, final VirtualFile vile) throws IOException {\n          final String oldName = vile.getNameWithoutExtension() + OLD_PROJECT_SUFFIX + vile.getExtension();\n          final VirtualFile oldFile = projectDir.findOrCreateChildData(this, oldName);\n          assert oldFile != null : projectDir + \", \" + oldName;\n          VfsUtil.saveText(oldFile, VfsUtilCore.loadText(vile));\n        }\n      });\n    }\n\n    if (originalVersion > ProjectManagerImpl.CURRENT_FORMAT_VERSION) {\n      String message =\n        ProjectBundle.message(\"project.load.new.version.warning\", myProject.getName(), ApplicationNamesInfo.getInstance().getProductName());\n\n      if (Messages.showYesNoDialog(message, CommonBundle.getWarningTitle(), Messages.getWarningIcon()) != Messages.YES) return false;\n    }\n\n    return true;\n  }","commit_id":"3a97b15da79a1c5c8d06c036c55b751ae88248e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Component component = PlatformDataKeys.CONTEXT_COMPONENT.getData(dataContext);\n    ChooseComponentsToExportDialog.chooseSettingsFile(PathManager.getConfigPath(), component, IdeBundle.message(\"title.import.file.location\"), IdeBundle.message(\"prompt.choose.import.file.path\")).doWhenDone(new Consumer<String>() {\n      @Override\n      public void consume(String path) {\n        doImport(path);\n      }\n    });\n  }","id":87515,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Component component = PlatformDataKeys.CONTEXT_COMPONENT.getData(dataContext);\n    ChooseComponentsToExportDialog.chooseSettingsFile(PathManager.getConfigPath(), component, IdeBundle.message(\"title.import.file.location\"), IdeBundle.message(\"prompt.choose.import.file.path\")).doWhenDone(new Consumer<String>() {\n      @Override\n      public void consume(String path) {\n        File saveFile = new File(path);\n        try {\n          doImport(saveFile);\n        }\n        catch (ZipException e1) {\n          Messages.showErrorDialog(\n            IdeBundle.message(\"error.reading.settings.file\", presentableFileName(saveFile), e1.getMessage(), promptLocationMessage()),\n            IdeBundle.message(\"title.invalid.file\"));\n        }\n        catch (IOException e1) {\n          Messages.showErrorDialog(IdeBundle.message(\"error.reading.settings.file.2\", presentableFileName(saveFile), e1.getMessage()),\n                                   IdeBundle.message(\"title.error.reading.file\"));\n        }\n      }\n    });\n  }","commit_id":"5d127b62c3caddb7f37713c23f571fa1abaa54e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean accept(File dir, String name) {\n    if (name.equals(SETTINGS_JAR_MARKER)) return false;\n    final File configPath = new File(PathManager.getConfigPath());\n    final String rPath = FileUtil.getRelativePath(configPath, new File(dir, name));\n    assert rPath != null;\n    final String relativePath = FileUtil.toSystemIndependentName(rPath);\n    for (final String allowedRelPath : myRelativeNamesToExtract) {\n      if (relativePath.startsWith(allowedRelPath)) return true;\n    }\n    return false;\n  }","id":87516,"modified_method":"public boolean accept(File dir, String name) {\n    if (name.equals(SETTINGS_JAR_MARKER)) {\n      return false;\n    }\n\n    File configPath = new File(PathManager.getConfigPath());\n    String rPath = FileUtil.getRelativePath(configPath, new File(dir, name));\n    assert rPath != null;\n    String relativePath = FileUtil.toSystemIndependentName(rPath);\n    for (String allowedRelPath : myRelativeNamesToExtract) {\n      if (relativePath.startsWith(allowedRelPath)) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"5d127b62c3caddb7f37713c23f571fa1abaa54e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public CandidateInfo resolveConflict(@NotNull List<CandidateInfo> conflicts){\n    if (conflicts.size() == 1) return conflicts.get(0);\n    final Map<Object, CandidateInfo> uniqueItems = new HashMap<Object, CandidateInfo>();\n    for (CandidateInfo info : conflicts) {\n      final PsiElement element = info.getElement();\n      Object key;\n      if (element instanceof PsiMethod) {\n        key = ((PsiMethod)element).getSignature(info.getSubstitutor());\n      }\n      else {\n        key = PsiUtilCore.getName(element);\n      }\n\n      if (!uniqueItems.containsKey(key)) {\n        uniqueItems.put(key, info);\n      }\n    }\n\n    if(uniqueItems.size() == 1) return uniqueItems.values().iterator().next();\n    return null;\n  }","id":87517,"modified_method":"@Override\n  public CandidateInfo resolveConflict(@NotNull List<CandidateInfo> conflicts){\n    if (conflicts.size() == 1) return conflicts.get(0);\n    final Map<Object, CandidateInfo> uniqueItems = new HashMap<Object, CandidateInfo>();\n    for (CandidateInfo info : conflicts) {\n      final PsiElement element = info.getElement();\n      Object key;\n      if (element instanceof PsiMethod) {\n        key = ((PsiMethod)element).getSignature(((MethodCandidateInfo)info).getSubstitutor(false));\n      }\n      else {\n        key = PsiUtilCore.getName(element);\n      }\n\n      if (!uniqueItems.containsKey(key)) {\n        uniqueItems.put(key, info);\n      }\n    }\n\n    if(uniqueItems.size() == 1) return uniqueItems.values().iterator().next();\n    return null;\n  }","commit_id":"c7eb8401493822892bb25af803ac98f47178c857","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (!PsiPolyExpressionUtil.isPolyExpression(myExpression)) {\n      if (session.isProperType(myT)) {\n        return TypeConversionUtil.areTypesAssignmentCompatible(myT, myExpression);\n      }\n    \n      final PsiType exprType = myExpression.getType();\n      if (exprType != null && exprType != PsiType.NULL) {\n        constraints.add(new TypeCompatibilityConstraint(myT, exprType));\n      }\n      return true;\n    }\n    if (myExpression instanceof PsiParenthesizedExpression) {\n      final PsiExpression expression = ((PsiParenthesizedExpression)myExpression).getExpression();\n      if (expression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(expression, myT));\n        return true;\n      }\n    }\n    \n    if (myExpression instanceof PsiConditionalExpression) {\n      final PsiExpression thenExpression = ((PsiConditionalExpression)myExpression).getThenExpression();\n      if (thenExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(thenExpression, myT));\n      }\n\n      final PsiExpression elseExpression = ((PsiConditionalExpression)myExpression).getElseExpression();\n      if (elseExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(elseExpression, myT));\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiCallExpression) {\n      final PsiExpressionList argumentList = ((PsiCallExpression)myExpression).getArgumentList();\n      if (argumentList != null) {\n        final JavaResolveResult resolveResult = ((PsiCallExpression)myExpression).resolveMethodGenerics();\n        final PsiMethod method = (PsiMethod)resolveResult.getElement();\n        PsiType returnType = null;\n        PsiTypeParameter[] typeParams = null;\n        if (method != null && !method.isConstructor()) {\n          returnType = method.getReturnType();\n          if (returnType != null) {\n            typeParams = method.getTypeParameters();\n          }\n        } else if (myExpression instanceof PsiNewExpression) {  //default constructor\n          final PsiJavaCodeReferenceElement classReference = ((PsiNewExpression)myExpression).getClassOrAnonymousClassReference();\n          if (classReference != null) {\n            final PsiElement psiClass = classReference.resolve();\n            if (psiClass instanceof PsiClass) {\n              returnType = JavaPsiFacade.getElementFactory(argumentList.getProject()).createType((PsiClass)psiClass, PsiSubstitutor.EMPTY);\n              typeParams = ((PsiClass)psiClass).getTypeParameters();\n            }\n          }\n        }\n\n        if (typeParams != null) {\n\n          final HashSet<PsiTypeParameter> oldBounds = new HashSet<PsiTypeParameter>(session.getTypeParams());\n          final boolean sameMethodCall = session.initBounds(typeParams);\n          PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n          final HashSet<InferenceVariable> variables = new HashSet<InferenceVariable>();\n          session.collectDependencies(returnType, variables);\n          final PsiTypeParameter[] params = new PsiTypeParameter[typeParams.length];\n          for (int i = 0; i < typeParams.length; i++) {\n            if (variables.contains(session.getInferenceVariable(typeParams[i]))) {\n              params[i] = JavaPsiFacade.getElementFactory(myExpression.getProject()).createTypeParameterFromText(\"copyOf\" + myExpression.hashCode() + typeParams[i].getName(), null);\n              substitutor = substitutor.put(typeParams[i], JavaPsiFacade.getElementFactory(myExpression.getProject()).createType(params[i]));\n            }\n            else {\n              params[i] = typeParams[i];\n            }\n          }\n          final PsiSubstitutor siteSubstitutor = resolveResult instanceof MethodCandidateInfo && method != null && !method.isConstructor() \n                                                 ? ((MethodCandidateInfo)resolveResult).getSiteSubstitutor() : PsiSubstitutor.EMPTY;\n          for (PsiTypeParameter typeParameter : siteSubstitutor.getSubstitutionMap().keySet()) {\n            substitutor = substitutor.put(typeParameter, substitutor.substitute(siteSubstitutor.substitute(typeParameter)));\n          }\n\n          final Collection<PsiTypeParameter> params1 = session.getTypeParams();\n          final InferenceSession callSession = new InferenceSession(params1.toArray(new PsiTypeParameter[params1.size()]), substitutor, myExpression.getManager(), myExpression);\n          callSession.initBounds(params);\n          if (method != null) {\n            final PsiExpression[] args = argumentList.getExpressions();\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            callSession.initExpressionConstraints(parameters, args, myExpression, method, resolveResult instanceof MethodCandidateInfo && ((MethodCandidateInfo)resolveResult).isVarargs());\n          }\n          final boolean accepted = callSession.repeatInferencePhases(true);\n          if (!accepted) {\n            return false;\n          }\n          callSession.registerConstraints(method != null && !PsiUtil.isRawSubstitutor(method, siteSubstitutor) ? siteSubstitutor.substitute(returnType) : returnType, substitutor.substitute(returnType));\n          if (callSession.repeatInferencePhases(true)) {\n            final Collection<InferenceVariable> inferenceVariables = callSession.getInferenceVariables();\n            if (sameMethodCall) {\n              for (Iterator<InferenceVariable> iterator = inferenceVariables.iterator(); iterator.hasNext(); ) {\n                InferenceVariable variable = iterator.next();\n                if (oldBounds.contains(variable.getParameter())) {\n                  iterator.remove();\n                }\n              }\n            }\n            session.liftBounds(inferenceVariables);\n          } else {\n            return false;\n          }\n          final PsiType capturedReturnType = myExpression instanceof PsiMethodCallExpression\n                                             ? PsiMethodCallExpressionImpl.captureReturnType((PsiMethodCallExpression)myExpression, method, returnType, substitutor)\n                                             : substitutor.substitute(returnType);\n          constraints.add(new TypeCompatibilityConstraint(myT, capturedReturnType));\n        }\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiMethodReferenceExpression) {\n      constraints.add(new PsiMethodReferenceCompatibilityConstraint(((PsiMethodReferenceExpression)myExpression), myT));\n      return true;\n    }\n    \n    if (myExpression instanceof PsiLambdaExpression) {\n      constraints.add(new LambdaExpressionCompatibilityConstraint((PsiLambdaExpression)myExpression, myT));\n      return true;\n    }\n    \n    \n    return true;\n  }","id":87518,"modified_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (!PsiPolyExpressionUtil.isPolyExpression(myExpression)) {\n      if (session.isProperType(myT)) {\n        return TypeConversionUtil.areTypesAssignmentCompatible(myT, myExpression);\n      }\n    \n      final PsiType exprType = myExpression.getType();\n      if (exprType != null && exprType != PsiType.NULL) {\n        constraints.add(new TypeCompatibilityConstraint(myT, exprType));\n      }\n      return true;\n    }\n    if (myExpression instanceof PsiParenthesizedExpression) {\n      final PsiExpression expression = ((PsiParenthesizedExpression)myExpression).getExpression();\n      if (expression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(expression, myT));\n        return true;\n      }\n    }\n    \n    if (myExpression instanceof PsiConditionalExpression) {\n      final PsiExpression thenExpression = ((PsiConditionalExpression)myExpression).getThenExpression();\n      if (thenExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(thenExpression, myT));\n      }\n\n      final PsiExpression elseExpression = ((PsiConditionalExpression)myExpression).getElseExpression();\n      if (elseExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(elseExpression, myT));\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiCallExpression) {\n      final PsiExpressionList argumentList = ((PsiCallExpression)myExpression).getArgumentList();\n      if (argumentList != null) {\n        final MethodCandidateInfo.CurrentCandidateProperties candidateProperties = MethodCandidateInfo.getCurrentMethod(((PsiCallExpression)myExpression).getArgumentList());\n        final JavaResolveResult resolveResult = candidateProperties != null ? null : ((PsiCallExpression)myExpression).resolveMethodGenerics();\n        final PsiMethod method = candidateProperties != null ? candidateProperties.getMethod() : (PsiMethod)resolveResult.getElement();\n        PsiType returnType = null;\n        PsiTypeParameter[] typeParams = null;\n        if (method != null && !method.isConstructor()) {\n          returnType = method.getReturnType();\n          if (returnType != null) {\n            typeParams = method.getTypeParameters();\n          }\n        } else if (myExpression instanceof PsiNewExpression) {  //default constructor\n          final PsiJavaCodeReferenceElement classReference = ((PsiNewExpression)myExpression).getClassOrAnonymousClassReference();\n          if (classReference != null) {\n            final PsiElement psiClass = classReference.resolve();\n            if (psiClass instanceof PsiClass) {\n              returnType = JavaPsiFacade.getElementFactory(argumentList.getProject()).createType((PsiClass)psiClass, PsiSubstitutor.EMPTY);\n              typeParams = ((PsiClass)psiClass).getTypeParameters();\n            }\n          }\n        }\n\n        if (typeParams != null) {\n\n          final HashSet<PsiTypeParameter> oldBounds = new HashSet<PsiTypeParameter>(session.getTypeParams());\n          final boolean sameMethodCall = session.initBounds(typeParams);\n          PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n          final HashSet<InferenceVariable> variables = new HashSet<InferenceVariable>();\n          session.collectDependencies(returnType, variables);\n          final PsiTypeParameter[] params = new PsiTypeParameter[typeParams.length];\n          for (int i = 0; i < typeParams.length; i++) {\n            if (variables.contains(session.getInferenceVariable(typeParams[i]))) {\n              params[i] = JavaPsiFacade.getElementFactory(myExpression.getProject()).createTypeParameterFromText(\"copyOf\" + myExpression.hashCode() + typeParams[i].getName(), null);\n              substitutor = substitutor.put(typeParams[i], JavaPsiFacade.getElementFactory(myExpression.getProject()).createType(params[i]));\n            }\n            else {\n              params[i] = typeParams[i];\n            }\n          }\n          PsiSubstitutor siteSubstitutor = PsiSubstitutor.EMPTY;\n          if (method != null && !method.isConstructor()) {\n            if (resolveResult instanceof MethodCandidateInfo) {\n              siteSubstitutor = ((MethodCandidateInfo)resolveResult).getSiteSubstitutor();\n            }\n            else if (candidateProperties != null) {\n              siteSubstitutor = candidateProperties.getSubstitutor();\n            }\n          }\n          for (PsiTypeParameter typeParameter : siteSubstitutor.getSubstitutionMap().keySet()) {\n            substitutor = substitutor.put(typeParameter, substitutor.substitute(siteSubstitutor.substitute(typeParameter)));\n          }\n\n          final Collection<PsiTypeParameter> params1 = session.getTypeParams();\n          final InferenceSession callSession = new InferenceSession(params1.toArray(new PsiTypeParameter[params1.size()]), substitutor, myExpression.getManager(), myExpression);\n          callSession.initBounds(params);\n          if (method != null) {\n            final PsiExpression[] args = argumentList.getExpressions();\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            callSession.initExpressionConstraints(parameters, args, myExpression, method, resolveResult instanceof MethodCandidateInfo && ((MethodCandidateInfo)resolveResult).isVarargs() || \n                                                                                          candidateProperties != null && candidateProperties.isVarargs());\n          }\n          final boolean accepted = callSession.repeatInferencePhases(true);\n          if (!accepted) {\n            return false;\n          }\n          callSession.registerConstraints(method != null && !PsiUtil.isRawSubstitutor(method, siteSubstitutor) ? siteSubstitutor.substitute(returnType) : returnType, substitutor.substitute(returnType));\n          if (callSession.repeatInferencePhases(true)) {\n            final Collection<InferenceVariable> inferenceVariables = callSession.getInferenceVariables();\n            if (sameMethodCall) {\n              for (Iterator<InferenceVariable> iterator = inferenceVariables.iterator(); iterator.hasNext(); ) {\n                InferenceVariable variable = iterator.next();\n                if (oldBounds.contains(variable.getParameter())) {\n                  iterator.remove();\n                }\n              }\n            }\n            session.liftBounds(inferenceVariables);\n          } else {\n            return false;\n          }\n          final PsiType capturedReturnType = myExpression instanceof PsiMethodCallExpression\n                                             ? PsiMethodCallExpressionImpl.captureReturnType((PsiMethodCallExpression)myExpression, method, returnType, substitutor)\n                                             : substitutor.substitute(returnType);\n          constraints.add(new TypeCompatibilityConstraint(myT, capturedReturnType));\n        }\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiMethodReferenceExpression) {\n      constraints.add(new PsiMethodReferenceCompatibilityConstraint(((PsiMethodReferenceExpression)myExpression), myT));\n      return true;\n    }\n    \n    if (myExpression instanceof PsiLambdaExpression) {\n      constraints.add(new LambdaExpressionCompatibilityConstraint((PsiLambdaExpression)myExpression, myT));\n      return true;\n    }\n    \n    \n    return true;\n  }","commit_id":"c7eb8401493822892bb25af803ac98f47178c857","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiSubstitutor getSubstitutor(boolean includeReturnConstraint) {\n    PsiSubstitutor substitutor = myCalcedSubstitutor;\n    if (substitutor == null || !includeReturnConstraint && myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_8)) {\n      PsiSubstitutor incompleteSubstitutor = super.getSubstitutor();\n      PsiMethod method = getElement();\n      if (myTypeArguments == null) {\n        final RecursionGuard.StackStamp stackStamp = PsiDiamondType.ourDiamondGuard.markStack();\n\n        final PsiSubstitutor inferredSubstitutor = inferTypeArguments(DefaultParameterTypeInferencePolicy.INSTANCE, includeReturnConstraint);\n\n         if (!stackStamp.mayCacheNow() || !ourOverloadGuard.currentStack().isEmpty() || !includeReturnConstraint && myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_8)) {\n          return inferredSubstitutor;\n        }\n\n        myCalcedSubstitutor = substitutor = inferredSubstitutor;\n      }\n      else {\n        PsiTypeParameter[] typeParams = method.getTypeParameters();\n        for (int i = 0; i < myTypeArguments.length && i < typeParams.length; i++) {\n          incompleteSubstitutor = incompleteSubstitutor.put(typeParams[i], myTypeArguments[i]);\n        }\n        myCalcedSubstitutor = substitutor = incompleteSubstitutor;\n      }\n    }\n\n    return substitutor;\n  }","id":87519,"modified_method":"@NotNull\n  public PsiSubstitutor getSubstitutor(boolean includeReturnConstraint) {\n    PsiSubstitutor substitutor = myCalcedSubstitutor;\n    if (substitutor == null || !includeReturnConstraint && myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_8)) {\n      PsiSubstitutor incompleteSubstitutor = super.getSubstitutor();\n      PsiMethod method = getElement();\n      if (myTypeArguments == null) {\n        final RecursionGuard.StackStamp stackStamp = PsiDiamondType.ourDiamondGuard.markStack();\n\n        final PsiSubstitutor inferredSubstitutor = inferTypeArguments(DefaultParameterTypeInferencePolicy.INSTANCE, includeReturnConstraint);\n\n         if (!stackStamp.mayCacheNow() ||\n             !ourOverloadGuard.currentStack().isEmpty() ||\n             !includeReturnConstraint && myLanguageLevel.isAtLeast(LanguageLevel.JDK_1_8) ||\n             getMarkerList() != null && PsiResolveHelper.ourGraphGuard.currentStack().contains(getMarkerList().getParent())) {\n          return inferredSubstitutor;\n        }\n\n        myCalcedSubstitutor = substitutor = inferredSubstitutor;\n      }\n      else {\n        PsiTypeParameter[] typeParams = method.getTypeParameters();\n        for (int i = 0; i < myTypeArguments.length && i < typeParams.length; i++) {\n          incompleteSubstitutor = incompleteSubstitutor.put(typeParams[i], myTypeArguments[i]);\n        }\n        myCalcedSubstitutor = substitutor = incompleteSubstitutor;\n      }\n    }\n\n    return substitutor;\n  }","commit_id":"c7eb8401493822892bb25af803ac98f47178c857","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isPolyExpression(final PsiExpression expression) {\n    if (expression instanceof PsiLambdaExpression || expression instanceof PsiMethodReferenceExpression) {\n      return true;\n    } \n    else if (expression instanceof PsiParenthesizedExpression) {\n      return isPolyExpression(((PsiParenthesizedExpression)expression).getExpression());\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiJavaCodeReferenceElement classReference = ((PsiNewExpression)expression).getClassReference();\n      if (classReference != null) {\n        final PsiReferenceParameterList parameterList = classReference.getParameterList();\n        if (parameterList != null) {\n          final PsiTypeElement[] typeElements = parameterList.getTypeParameterElements();\n          if (typeElements.length == 1 && typeElements[0].getType() instanceof PsiDiamondType) {\n            return isInAssignmentOrInvocationContext(expression);\n          }\n        }\n      }\n    } else if (expression instanceof PsiMethodCallExpression) {\n      return isMethodCallPolyExpression(expression, ((PsiMethodCallExpression)expression).resolveMethod());\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final ConditionalKind conditionalKind = isBooleanOrNumeric(expression);\n      if (conditionalKind == null) {\n        return isInAssignmentOrInvocationContext(expression);\n      }\n    }\n    return false;\n  }","id":87520,"modified_method":"public static boolean isPolyExpression(final PsiExpression expression) {\n    if (expression instanceof PsiLambdaExpression || expression instanceof PsiMethodReferenceExpression) {\n      return true;\n    } \n    else if (expression instanceof PsiParenthesizedExpression) {\n      return isPolyExpression(((PsiParenthesizedExpression)expression).getExpression());\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiJavaCodeReferenceElement classReference = ((PsiNewExpression)expression).getClassReference();\n      if (classReference != null) {\n        final PsiReferenceParameterList parameterList = classReference.getParameterList();\n        if (parameterList != null) {\n          final PsiTypeElement[] typeElements = parameterList.getTypeParameterElements();\n          if (typeElements.length == 1 && typeElements[0].getType() instanceof PsiDiamondType) {\n            return isInAssignmentOrInvocationContext(expression);\n          }\n        }\n      }\n    } else if (expression instanceof PsiMethodCallExpression) {\n      final MethodCandidateInfo.CurrentCandidateProperties candidateProperties = MethodCandidateInfo.getCurrentMethod(((PsiMethodCallExpression)expression).getArgumentList());\n      return isMethodCallPolyExpression(expression, candidateProperties != null ? candidateProperties.getMethod() : ((PsiMethodCallExpression)expression).resolveMethod());\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final ConditionalKind conditionalKind = isBooleanOrNumeric(expression);\n      if (conditionalKind == null) {\n        return isInAssignmentOrInvocationContext(expression);\n      }\n    }\n    return false;\n  }","commit_id":"c7eb8401493822892bb25af803ac98f47178c857","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initReturnTypeConstraint(PsiMethod method, PsiCallExpression context) {\n    if (PsiPolyExpressionUtil.isMethodCallPolyExpression(context, method) || \n        context instanceof PsiNewExpression && PsiDiamondType.ourDiamondGuard.currentStack().contains(context)) {\n      final PsiType returnType = method.getReturnType();\n      if (!PsiType.VOID.equals(returnType) && returnType != null) {\n        PsiType targetType = PsiTypesUtil.getExpectedTypeByParent(context);\n        if (targetType == null) {\n          final PsiElement parent = PsiUtil.skipParenthesizedExprUp(context.getParent());\n          if (parent instanceof PsiExpressionList) {\n            final PsiElement gParent = parent.getParent();\n            if (gParent instanceof PsiCallExpression) {\n              final PsiExpressionList argumentList = ((PsiCallExpression)gParent).getArgumentList();\n              if (argumentList != null) {\n                final JavaResolveResult resolveResult = ((PsiCallExpression)gParent).resolveMethodGenerics();\n                final PsiElement parentMethod = resolveResult.getElement();\n                if (parentMethod instanceof PsiMethod) {\n                  final PsiParameter[] parameters = ((PsiMethod)parentMethod).getParameterList().getParameters();\n                  PsiElement arg = context;\n                  while (arg.getParent() instanceof PsiParenthesizedExpression) {\n                    arg = parent.getParent();\n                  }\n                  final PsiExpression[] args = argumentList.getExpressions();\n                  targetType = getParameterType(parameters, args, ArrayUtilRt.find(args, arg), resolveResult.getSubstitutor());\n                }\n              }\n            }\n          } else if (parent instanceof PsiConditionalExpression) {\n            targetType = PsiTypesUtil.getExpectedTypeByParent((PsiExpression)parent);\n          }\n        }\n        if (targetType != null) {\n          myConstraints.add(new TypeCompatibilityConstraint(targetType, PsiImplUtil.normalizeWildcardTypeByPosition(returnType, context)));\n        }\n      }\n    }\n  }","id":87521,"modified_method":"private void initReturnTypeConstraint(PsiMethod method, PsiCallExpression context) {\n    if (PsiPolyExpressionUtil.isMethodCallPolyExpression(context, method) || \n        context instanceof PsiNewExpression && PsiDiamondType.ourDiamondGuard.currentStack().contains(context)) {\n      final PsiType returnType = method.getReturnType();\n      if (!PsiType.VOID.equals(returnType) && returnType != null) {\n        PsiType targetType = PsiTypesUtil.getExpectedTypeByParent(context);\n        if (targetType == null) {\n          final PsiElement parent = PsiUtil.skipParenthesizedExprUp(context.getParent());\n          if (parent instanceof PsiExpressionList) {\n            final PsiElement gParent = parent.getParent();\n            if (gParent instanceof PsiCallExpression) {\n              final PsiExpressionList argumentList = ((PsiCallExpression)gParent).getArgumentList();\n              if (argumentList != null) {\n                final Pair<PsiMethod, PsiSubstitutor> pair = MethodCandidateInfo.getCurrentMethod(argumentList);\n                final JavaResolveResult resolveResult = pair == null ? ((PsiCallExpression)gParent).resolveMethodGenerics() : null;\n                final PsiElement parentMethod = pair != null ? pair.first : resolveResult.getElement();\n                if (parentMethod instanceof PsiMethod) {\n                  final PsiParameter[] parameters = ((PsiMethod)parentMethod).getParameterList().getParameters();\n                  PsiElement arg = context;\n                  while (arg.getParent() instanceof PsiParenthesizedExpression) {\n                    arg = parent.getParent();\n                  }\n                  final PsiExpression[] args = argumentList.getExpressions();\n                  targetType = getParameterType(parameters, args, ArrayUtilRt.find(args, arg), pair != null ? pair.second : resolveResult.getSubstitutor());\n                }\n              }\n            }\n          } else if (parent instanceof PsiConditionalExpression) {\n            targetType = PsiTypesUtil.getExpectedTypeByParent((PsiExpression)parent);\n          }\n          else if (parent instanceof PsiLambdaExpression) {\n            targetType = LambdaUtil.getFunctionalInterfaceReturnType(((PsiLambdaExpression)parent).getFunctionalInterfaceType());\n          }\n        }\n        if (targetType != null) {\n          myConstraints.add(new TypeCompatibilityConstraint(targetType, PsiImplUtil.normalizeWildcardTypeByPosition(returnType, context)));\n        }\n      }\n    }\n  }","commit_id":"52fea51bc40102458580dd3b514c7ed9ff36caae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (!PsiPolyExpressionUtil.isPolyExpression(myExpression)) {\n      if (session.isProperType(myT)) {\n        return TypeConversionUtil.areTypesAssignmentCompatible(myT, myExpression);\n      }\n    \n      final PsiType exprType = myExpression.getType();\n      if (exprType != null && !exprType.equals(PsiType.NULL)) {\n        constraints.add(new TypeCompatibilityConstraint(myT, exprType));\n      }\n      return true;\n    }\n    if (myExpression instanceof PsiParenthesizedExpression) {\n      final PsiExpression expression = ((PsiParenthesizedExpression)myExpression).getExpression();\n      if (expression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(expression, myT));\n        return true;\n      }\n    }\n    \n    if (myExpression instanceof PsiConditionalExpression) {\n      final PsiExpression thenExpression = ((PsiConditionalExpression)myExpression).getThenExpression();\n      if (thenExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(thenExpression, myT));\n      }\n\n      final PsiExpression elseExpression = ((PsiConditionalExpression)myExpression).getElseExpression();\n      if (elseExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(elseExpression, myT));\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiCallExpression) {\n      final PsiExpressionList argumentList = ((PsiCallExpression)myExpression).getArgumentList();\n      if (argumentList != null) {\n        final Pair<PsiMethod,PsiSubstitutor> pair = MethodCandidateInfo.getCurrentMethod(argumentList);\n        if (pair != null) return true;\n        final JavaResolveResult resolveResult = ((PsiCallExpression)myExpression).resolveMethodGenerics();\n        final PsiMethod method = (PsiMethod)resolveResult.getElement();\n        PsiType returnType = null;\n        PsiTypeParameter[] typeParams = null;\n        if (method != null && !method.isConstructor()) {\n          returnType = method.getReturnType();\n          if (returnType != null) {\n            typeParams = method.getTypeParameters();\n          }\n        } else if (myExpression instanceof PsiNewExpression) {  //default constructor\n          final PsiJavaCodeReferenceElement classReference = ((PsiNewExpression)myExpression).getClassOrAnonymousClassReference();\n          if (classReference != null) {\n            final PsiElement psiClass = classReference.resolve();\n            if (psiClass instanceof PsiClass) {\n              returnType = JavaPsiFacade.getElementFactory(argumentList.getProject()).createType((PsiClass)psiClass, PsiSubstitutor.EMPTY);\n              typeParams = ((PsiClass)psiClass).getTypeParameters();\n            }\n          }\n        }\n\n        if (typeParams != null) {\n\n          for (PsiTypeParameter typeParam : typeParams) {\n            session.addCapturedVariable(typeParam);\n          }\n          PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n          if (method != null) {\n            InferenceSession callSession = new InferenceSession(typeParams, ((MethodCandidateInfo)resolveResult).getSiteSubstitutor(), myExpression.getManager());\n            final PsiExpression[] args = argumentList.getExpressions();\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            callSession.initExpressionConstraints(parameters, args, myExpression);\n            substitutor = callSession.infer(parameters, args, myExpression, LiftParameterTypeInferencePolicy.INSTANCE);\n          }\n          final PsiType capturedReturnType = myExpression instanceof PsiMethodCallExpression\n                                             ? PsiMethodCallExpressionImpl.captureReturnType((PsiMethodCallExpression)myExpression, method, returnType, substitutor)\n                                             : substitutor.substitute(returnType);\n          constraints.add(new TypeCompatibilityConstraint(GenericsUtil.eliminateWildcards(myT, false), capturedReturnType));\n        }\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiMethodReferenceExpression) {\n      constraints.add(new PsiMethodReferenceCompatibilityConstraint(((PsiMethodReferenceExpression)myExpression), myT));\n      return true;\n    }\n    \n    if (myExpression instanceof PsiLambdaExpression) {\n      constraints.add(new LambdaExpressionCompatibilityConstraint((PsiLambdaExpression)myExpression, myT));\n      return true;\n    }\n    \n    \n    return true;\n  }","id":87522,"modified_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (!PsiPolyExpressionUtil.isPolyExpression(myExpression)) {\n      if (session.isProperType(myT)) {\n        return TypeConversionUtil.areTypesAssignmentCompatible(myT, myExpression);\n      }\n    \n      final PsiType exprType = myExpression.getType();\n      if (exprType != null && !exprType.equals(PsiType.NULL)) {\n        constraints.add(new TypeCompatibilityConstraint(myT, exprType));\n      }\n      return true;\n    }\n    if (myExpression instanceof PsiParenthesizedExpression) {\n      final PsiExpression expression = ((PsiParenthesizedExpression)myExpression).getExpression();\n      if (expression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(expression, myT));\n        return true;\n      }\n    }\n    \n    if (myExpression instanceof PsiConditionalExpression) {\n      final PsiExpression thenExpression = ((PsiConditionalExpression)myExpression).getThenExpression();\n      if (thenExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(thenExpression, myT));\n      }\n\n      final PsiExpression elseExpression = ((PsiConditionalExpression)myExpression).getElseExpression();\n      if (elseExpression != null) {\n        constraints.add(new ExpressionCompatibilityConstraint(elseExpression, myT));\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiCallExpression) {\n      final PsiExpressionList argumentList = ((PsiCallExpression)myExpression).getArgumentList();\n      if (argumentList != null) {\n        final Pair<PsiMethod,PsiSubstitutor> pair = MethodCandidateInfo.getCurrentMethod(argumentList);\n        final JavaResolveResult resolveResult = pair == null ? ((PsiCallExpression)myExpression).resolveMethodGenerics() : null;\n        final PsiMethod method = pair != null ? pair.first : (PsiMethod)resolveResult.getElement();\n        PsiType returnType = null;\n        PsiTypeParameter[] typeParams = null;\n        if (method != null && !method.isConstructor()) {\n          returnType = method.getReturnType();\n          if (returnType != null) {\n            typeParams = method.getTypeParameters();\n          }\n        } else if (myExpression instanceof PsiNewExpression) {  //default constructor\n          final PsiJavaCodeReferenceElement classReference = ((PsiNewExpression)myExpression).getClassOrAnonymousClassReference();\n          if (classReference != null) {\n            final PsiElement psiClass = classReference.resolve();\n            if (psiClass instanceof PsiClass) {\n              returnType = JavaPsiFacade.getElementFactory(argumentList.getProject()).createType((PsiClass)psiClass, PsiSubstitutor.EMPTY);\n              typeParams = ((PsiClass)psiClass).getTypeParameters();\n            }\n          }\n        }\n\n        if (typeParams != null) {\n\n          for (PsiTypeParameter typeParam : typeParams) {\n            session.addCapturedVariable(typeParam);\n          }\n          PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n          if (pair == null) {\n            if (method != null) {\n              InferenceSession callSession = new InferenceSession(typeParams, ((MethodCandidateInfo)resolveResult).getSiteSubstitutor(), myExpression.getManager());\n              final PsiExpression[] args = argumentList.getExpressions();\n              final PsiParameter[] parameters = method.getParameterList().getParameters();\n              callSession.initExpressionConstraints(parameters, args, myExpression);\n              substitutor = callSession.infer(parameters, args, myExpression, LiftParameterTypeInferencePolicy.INSTANCE);\n            }\n          } else {\n            substitutor = pair.second;\n          }\n          final PsiType capturedReturnType = myExpression instanceof PsiMethodCallExpression\n                                             ? PsiMethodCallExpressionImpl.captureReturnType((PsiMethodCallExpression)myExpression, method, returnType, substitutor)\n                                             : substitutor.substitute(returnType);\n          constraints.add(new TypeCompatibilityConstraint(GenericsUtil.eliminateWildcards(myT, false), capturedReturnType));\n        }\n      }\n      return true;\n    }\n    \n    if (myExpression instanceof PsiMethodReferenceExpression) {\n      constraints.add(new PsiMethodReferenceCompatibilityConstraint(((PsiMethodReferenceExpression)myExpression), myT));\n      return true;\n    }\n    \n    if (myExpression instanceof PsiLambdaExpression) {\n      constraints.add(new LambdaExpressionCompatibilityConstraint((PsiLambdaExpression)myExpression, myT));\n      return true;\n    }\n    \n    \n    return true;\n  }","commit_id":"fc58e5e0af5d9cc5de2425c683b0bdf2c9e3d371","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ExpectedTypeInfo[] findClassesWithDeclaredMethod(final PsiMethodCallExpression methodCallExpr, final boolean forCompletion) {\n      final PsiReferenceExpression reference = methodCallExpr.getMethodExpression();\n      final PsiManager manager = methodCallExpr.getManager();\n      final JavaPsiFacade facade = JavaPsiFacade.getInstance(manager.getProject());\n      final PsiMethod[] methods = myClassProvider.findDeclaredMethods(reference.getManager(), reference.getReferenceName());\n      Set<ExpectedTypeInfo> types = new THashSet<ExpectedTypeInfo>();\n      for (PsiMethod method : methods) {\n        final PsiClass aClass = method.getContainingClass();\n        if (!facade.getResolveHelper().isAccessible(method, reference, aClass)) continue;\n\n        final PsiSubstitutor substitutor = ExpectedTypeUtil.inferSubstitutor(method, methodCallExpr, forCompletion);\n        final PsiClassType type;\n        if (substitutor != null) {\n          type = facade.getElementFactory().createType(aClass, substitutor);\n        }\n        else {\n          type = facade.getElementFactory().createType(aClass);\n        }\n\n        if (method.hasModifierProperty(PsiModifier.STATIC) ||\n            method.hasModifierProperty(PsiModifier.FINAL) ||\n            method.hasModifierProperty(PsiModifier.PRIVATE)) {\n          types.add(createInfoImpl(type, ExpectedTypeInfo.TYPE_STRICTLY, type, TailType.DOT));\n        }\n        else {\n          addBaseType(types, type, method);\n        }\n      }\n\n      return types.toArray(new ExpectedTypeInfo[types.size()]);\n    }","id":87523,"modified_method":"private ExpectedTypeInfo[] findClassesWithDeclaredMethod(final PsiMethodCallExpression methodCallExpr, final boolean forCompletion) {\n      final PsiReferenceExpression reference = methodCallExpr.getMethodExpression();\n      final PsiManager manager = methodCallExpr.getManager();\n      final JavaPsiFacade facade = JavaPsiFacade.getInstance(manager.getProject());\n      final PsiMethod[] methods = myClassProvider.findDeclaredMethods(reference.getManager(), reference.getReferenceName());\n      Set<ExpectedTypeInfo> types = new THashSet<ExpectedTypeInfo>();\n      for (PsiMethod method : methods) {\n        final PsiClass aClass = method.getContainingClass();\n        if (aClass == null || !facade.getResolveHelper().isAccessible(method, reference, aClass)) continue;\n\n        final PsiSubstitutor substitutor = ExpectedTypeUtil.inferSubstitutor(method, methodCallExpr, forCompletion);\n        final PsiClassType type =\n          substitutor == null ? facade.getElementFactory().createType(aClass) : facade.getElementFactory().createType(aClass, substitutor);\n\n        if (method.hasModifierProperty(PsiModifier.STATIC) ||\n            method.hasModifierProperty(PsiModifier.FINAL) ||\n            method.hasModifierProperty(PsiModifier.PRIVATE)) {\n          types.add(createInfoImpl(type, ExpectedTypeInfo.TYPE_STRICTLY, type, TailType.DOT));\n        }\n        else {\n          addBaseType(types, type, method);\n        }\n      }\n\n      return types.toArray(new ExpectedTypeInfo[types.size()]);\n    }","commit_id":"36a5334f35d9b937f82a027aab8c8567ba3a0445","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ExpectedTypeInfo[] findClassesWithDeclaredField(PsiReferenceExpression expression) {\n      final JavaPsiFacade facade = JavaPsiFacade.getInstance(expression.getProject());\n      PsiField[] fields = myClassProvider.findDeclaredFields(expression.getManager(), expression.getReferenceName());\n      List<ExpectedTypeInfo> types = new ArrayList<ExpectedTypeInfo>();\n      for (PsiField field : fields) {\n        final PsiClass aClass = field.getContainingClass();\n        if (!facade.getResolveHelper().isAccessible(field, expression, aClass)) continue;\n\n        final PsiType type = facade.getElementFactory().createType(aClass);\n\n        int kind = field.hasModifierProperty(PsiModifier.STATIC) ||\n                   field.hasModifierProperty(PsiModifier.FINAL) ||\n                   field.hasModifierProperty(PsiModifier.PRIVATE)\n                   ? ExpectedTypeInfo.TYPE_STRICTLY\n                   : ExpectedTypeInfo.TYPE_OR_SUBTYPE;\n        ExpectedTypeInfo info = createInfoImpl(type, kind, type, TailType.DOT);\n        //Do not filter inheritors!\n        types.add(info);\n      }\n      return types.toArray(new ExpectedTypeInfo[types.size()]);\n    }","id":87524,"modified_method":"private ExpectedTypeInfo[] findClassesWithDeclaredField(PsiReferenceExpression expression) {\n      final JavaPsiFacade facade = JavaPsiFacade.getInstance(expression.getProject());\n      PsiField[] fields = myClassProvider.findDeclaredFields(expression.getManager(), expression.getReferenceName());\n      List<ExpectedTypeInfo> types = new ArrayList<ExpectedTypeInfo>();\n      for (PsiField field : fields) {\n        final PsiClass aClass = field.getContainingClass();\n        if (aClass == null || !facade.getResolveHelper().isAccessible(field, expression, aClass)) continue;\n\n        final PsiType type = facade.getElementFactory().createType(aClass);\n\n        int kind = field.hasModifierProperty(PsiModifier.STATIC) ||\n                   field.hasModifierProperty(PsiModifier.FINAL) ||\n                   field.hasModifierProperty(PsiModifier.PRIVATE)\n                   ? ExpectedTypeInfo.TYPE_STRICTLY\n                   : ExpectedTypeInfo.TYPE_OR_SUBTYPE;\n        ExpectedTypeInfo info = createInfoImpl(type, kind, type, TailType.DOT);\n        //Do not filter inheritors!\n        types.add(info);\n      }\n      return types.toArray(new ExpectedTypeInfo[types.size()]);\n    }","commit_id":"36a5334f35d9b937f82a027aab8c8567ba3a0445","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MyParentVisitor(PsiExpression expr, boolean forCompletion, ExpectedClassProvider classProvider) {\n      myExpr = expr;\n      myForCompletion = forCompletion;\n      myClassProvider = classProvider;\n    }","id":87525,"modified_method":"private MyParentVisitor(PsiExpression expr, boolean forCompletion, ExpectedClassProvider classProvider) {\n      myExpr = expr;\n      myForCompletion = forCompletion;\n      myClassProvider = classProvider;\n    }","commit_id":"36a5334f35d9b937f82a027aab8c8567ba3a0445","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addMemberInfo(PsiMember[] members,\n                                    PsiElement place,\n                                    List<ExpectedTypeInfo[]> types,\n                                    PsiElementFactory factory) {\n    if (members.length > MAX_GUESSED_MEMBERS_COUNT) return;\n\n    List<ExpectedTypeInfo> l = new ArrayList<ExpectedTypeInfo>();\n    PsiManager manager = place.getManager();\n    ExpectedTypesProvider provider = ExpectedTypesProvider.getInstance(manager.getProject());\n    for (PsiMember member : members) {\n      PsiClass aClass = member.getContainingClass();\n      if (manager.getResolveHelper().isAccessible(aClass, place, null)) {\n        if (!(aClass instanceof PsiAnonymousClass)) {\n          PsiClassType type = factory.createType(aClass);\n          l.add(provider.createInfo(type, ExpectedTypeInfo.TYPE_OR_SUBTYPE, type, TailType.NONE));\n        }\n      }\n    }\n\n    if (l.size() > 0) {\n      types.add(l.toArray(new ExpectedTypeInfo[l.size()]));\n    }\n  }","id":87526,"modified_method":"private static void addMemberInfo(PsiMember[] members,\n                                    PsiExpression expression,\n                                    List<ExpectedTypeInfo[]> types,\n                                    PsiElementFactory factory) {\n    final StatisticsManager statisticsManager = StatisticsManager.getInstance();\n    Arrays.sort(members, new Comparator<PsiMember>() {\n      public int compare(final PsiMember m1, final PsiMember m2) {\n        int result = statisticsManager.getMemberUseCount(null, m2, null) - statisticsManager.getMemberUseCount(null, m1, null);\n        if (result != 0) return result;\n        final PsiClass aClass = m1.getContainingClass();\n        final PsiClass bClass = m2.getContainingClass();\n        if (aClass == null || bClass == null) return 0;\n        return statisticsManager.getMemberUseCount(null, bClass, null) - statisticsManager.getMemberUseCount(null, aClass, null);\n      }\n    });\n\n    List<ExpectedTypeInfo> l = new ArrayList<ExpectedTypeInfo>();\n    PsiManager manager = expression.getManager();\n    ExpectedTypesProvider provider = ExpectedTypesProvider.getInstance(manager.getProject());\n    for (int i = 0; i < Math.min(MAX_GUESSED_MEMBERS_COUNT, members.length); i++) {\n      PsiMember member = members[i];\n      PsiClass aClass = member.getContainingClass();\n      if (aClass instanceof PsiAnonymousClass) continue;\n\n      if (manager.getResolveHelper().isAccessible(aClass, expression, null)) {\n        PsiClassType type;\n        final PsiElement pparent = expression.getParent().getParent();\n        if (pparent instanceof PsiMethodCallExpression) {\n\n          PsiSubstitutor substitutor = ExpectedTypeUtil.inferSubstitutor(((PsiMethod)member), (PsiMethodCallExpression)pparent, false);\n          if (substitutor == null) {\n            type = factory.createType(aClass);\n          } else {\n            type = factory.createType(aClass, substitutor);\n          }\n        }\n        else {\n          type = factory.createType(aClass);\n        }\n        l.add(provider.createInfo(type, ExpectedTypeInfo.TYPE_OR_SUBTYPE, type, TailType.NONE));\n      }\n    }\n\n    if (l.size() > 0) {\n      types.add(l.toArray(new ExpectedTypeInfo[l.size()]));\n    }\n  }","commit_id":"0d5f8b87507d95d967c1e6827d057b6e0819f555","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiMethod[] findDeclaredMethods(final PsiManager manager, String name) {\n      List<PsiMethod> methods = new ArrayList<PsiMethod>();\n      for (Iterator<PsiClass> iterator = myOccurrenceClasses.iterator(); iterator.hasNext();) {\n        PsiClass aClass = iterator.next();\n        final PsiMethod[] occMethod = aClass.findMethodsByName(name, true);\n        methods.addAll(Arrays.asList(occMethod));\n      }\n      return methods.toArray(new PsiMethod[methods.size()]);\n    }","id":87527,"modified_method":"public PsiMethod[] findDeclaredMethods(final PsiManager manager, String name) {\n      List<PsiMethod> methods = new ArrayList<PsiMethod>();\n      for (PsiClass aClass : myOccurrenceClasses) {\n        final PsiMethod[] occMethod = aClass.findMethodsByName(name, true);\n        methods.addAll(Arrays.asList(occMethod));\n      }\n      return methods.toArray(new PsiMethod[methods.size()]);\n    }","commit_id":"0d5f8b87507d95d967c1e6827d057b6e0819f555","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ExpectedTypeInfo[] intersect(List<ExpectedTypeInfo[]> typeInfos) {\n    if (typeInfos.isEmpty()) return ExpectedTypeInfo.EMPTY;\n\n    ExpectedTypeInfos result = new ExpectedTypeInfos(typeInfos.get(0));\n    ExpectedTypeInfos acc = new ExpectedTypeInfos();\n\n    for (int i = 1; i < typeInfos.size(); i++) {\n      ExpectedTypeInfo[] next = typeInfos.get(i);\n      acc.clear();\n      for (int j = 0; j < next.length; j++) {\n        ExpectedTypeInfo info = next[j];\n        for (Iterator<ExpectedTypeInfo> iterator = result.iterator(); iterator.hasNext();) {\n          ExpectedTypeInfo[] intersection = iterator.next().intersect(info);\n          for (int k = 0; k < intersection.length; k++) {\n            acc.addInfo(intersection[k]);\n          }\n        }\n      }\n      if (acc.isEmpty()) {\n        return ExpectedTypeInfo.EMPTY;\n      }\n      result = acc;\n    }\n\n    return result.toArray();\n  }","id":87528,"modified_method":"public static ExpectedTypeInfo[] intersect(List<ExpectedTypeInfo[]> typeInfos) {\n    if (typeInfos.isEmpty()) return ExpectedTypeInfo.EMPTY;\n\n    ExpectedTypeInfos result = new ExpectedTypeInfos(typeInfos.get(0));\n    ExpectedTypeInfos acc = new ExpectedTypeInfos();\n\n    for (int i = 1; i < typeInfos.size(); i++) {\n      ExpectedTypeInfo[] next = typeInfos.get(i);\n      acc.clear();\n      for (ExpectedTypeInfo info : next) {\n        for (Iterator<ExpectedTypeInfo> iterator = result.iterator(); iterator.hasNext();) {\n          ExpectedTypeInfo[] intersection = iterator.next().intersect(info);\n          for (ExpectedTypeInfo aIntersection : intersection) {\n            acc.addInfo(aIntersection);\n          }\n        }\n      }\n      if (acc.isEmpty()) {\n        return ExpectedTypeInfo.EMPTY;\n      }\n      result = acc;\n    }\n\n    return result.toArray();\n  }","commit_id":"0d5f8b87507d95d967c1e6827d057b6e0819f555","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiField[] findDeclaredFields(final PsiManager manager, String name) {\n      List<PsiField> fields = new ArrayList<PsiField>();\n      for (Iterator<PsiClass> iterator = myOccurrenceClasses.iterator(); iterator.hasNext();) {\n        PsiClass aClass = iterator.next();\n        final PsiField field = aClass.findFieldByName(name, true);\n        if (field != null) fields.add(field);\n      }\n      return fields.toArray(new PsiField[fields.size()]);\n    }","id":87529,"modified_method":"public PsiField[] findDeclaredFields(final PsiManager manager, String name) {\n      List<PsiField> fields = new ArrayList<PsiField>();\n      for (PsiClass aClass : myOccurrenceClasses) {\n        final PsiField field = aClass.findFieldByName(name, true);\n        if (field != null) fields.add(field);\n      }\n      return fields.toArray(new PsiField[fields.size()]);\n    }","commit_id":"0d5f8b87507d95d967c1e6827d057b6e0819f555","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void activate(final ServiceActivatorContext context) {final BatchBuilder batchBuilder = context.getBatchBuilder();\n        final ScaledCount coreThreads = this.coreThreads;\n        int coreThreadsValue = coreThreads != null ? coreThreads.getScaledCount() : 0;\n        final ScaledCount maxThreads = getMaxThreads();\n        int maxThreadsValue = maxThreads != null ? maxThreads.getScaledCount() : Integer.MAX_VALUE;\n        final ScaledCount queueLength = this.queueLength;\n        int queueLengthValue = queueLength != null ? queueLength.getScaledCount() : Integer.MAX_VALUE;\n\n        TimeSpec keepAlive = getKeepaliveTime();\n        if(keepAlive == null)\n            keepAlive = TimeSpec.DEFAULT_KEEPALIVE;\n        final BoundedQueueThreadPoolService service = new BoundedQueueThreadPoolService(coreThreadsValue, maxThreadsValue, queueLengthValue, blocking, keepAlive, allowCoreTimeout);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n        final String handoffExecutor = this.handoffExecutor;\n        if (handoffExecutor != null) {\n            final ServiceName handoffExecutorName = JBOSS_THREAD_EXECUTOR.append(handoffExecutor);\n            serviceBuilder.addDependency(handoffExecutorName, Executor.class, service.getHandoffExecutorInjector());\n        }\n    }","id":87530,"modified_method":"public void activate(final ServiceActivatorContext context) {final BatchBuilder batchBuilder = context.getBatchBuilder();\n        final ScaledCount maxThreads = getMaxThreads();\n        int maxThreadsValue = maxThreads.getScaledCount();\n        final ScaledCount queueLength = this.queueLength;\n        int queueLengthValue = queueLength.getScaledCount();\n\n        final ScaledCount coreThreads = this.coreThreads;\n        int coreThreadsValue = coreThreads != null ? coreThreads.getScaledCount() : maxThreadsValue;\n\n        TimeSpec keepAlive = getKeepaliveTime();\n        if(keepAlive == null)\n            keepAlive = TimeSpec.DEFAULT_KEEPALIVE;\n        final BoundedQueueThreadPoolService service = new BoundedQueueThreadPoolService(coreThreadsValue, maxThreadsValue, queueLengthValue, blocking, keepAlive, allowCoreTimeout);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n        final String handoffExecutor = this.handoffExecutor;\n        if (handoffExecutor != null) {\n            final ServiceName handoffExecutorName = JBOSS_THREAD_EXECUTOR.append(handoffExecutor);\n            serviceBuilder.addDependency(handoffExecutorName, Executor.class, service.getHandoffExecutorInjector());\n        }\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder batchBuilder = context.getBatchBuilder();\n        long keepAlive = -1L;\n        final TimeSpec keepaliveTime = getKeepaliveTime();\n        if(keepaliveTime != null)\n            keepAlive = keepaliveTime.getUnit().toNanos(keepaliveTime.getDuration());\n\n        final ScaledCount maxThreads = getMaxThreads();\n        final QueuelessThreadPoolService service = new QueuelessThreadPoolService(maxThreads != null ? maxThreads.getScaledCount() : Integer.MAX_VALUE, blocking, keepAlive);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n\n        final String handoffExecutor = getHandoffExecutor();\n        if (handoffExecutor != null) {\n            final ServiceName handoffExecutorName = JBOSS_THREAD_EXECUTOR.append(handoffExecutor);\n            serviceBuilder.addDependency(handoffExecutorName, Executor.class, service.getHandoffExecutorInjector());\n        }\n    }","id":87531,"modified_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder batchBuilder = context.getBatchBuilder();\n        long keepAlive = -1L;\n        final TimeSpec keepaliveTime = getKeepaliveTime();\n        if(keepaliveTime != null)\n            keepAlive = keepaliveTime.getUnit().toNanos(keepaliveTime.getDuration());\n\n        final ScaledCount maxThreads = getMaxThreads();\n        final QueuelessThreadPoolService service = new QueuelessThreadPoolService(maxThreads.getScaledCount(), blocking, keepAlive);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n\n        final String handoffExecutor = getHandoffExecutor();\n        if (handoffExecutor != null) {\n            final ServiceName handoffExecutorName = JBOSS_THREAD_EXECUTOR.append(handoffExecutor);\n            serviceBuilder.addDependency(handoffExecutorName, Executor.class, service.getHandoffExecutorInjector());\n        }\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ThreadFactoryExecutorElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        // Attributes\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            if (reader.getAttributeNamespace(i) != null) {\n                throw unexpectedAttribute(reader, i);\n            }\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME: break;\n                default: throw unexpectedAttribute(reader, i);\n            }\n        }\n        // Elements\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case THREADS_1_0: {\n                    switch (Element.forName(reader.getLocalName())) {\n                        case MAX_THREADS: {\n                            setMaxThreads(readScaledCountElement(reader));\n                            break;\n                        }\n                        case THREAD_FACTORY: {\n                            setThreadFactory(readStringAttributeElement(reader, \"name\"));\n                            break;\n                        }\n                        case PROPERTIES: {\n                            setProperties(new PropertiesElement(reader));\n                            break;\n                        }\n                        default: throw unexpectedElement(reader);\n                    }\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","id":87532,"modified_method":"public ThreadFactoryExecutorElement(final XMLExtendedStreamReader reader) throws XMLStreamException {\n        super(reader);\n        // Attributes\n        final int count = reader.getAttributeCount();\n        for (int i = 0; i < count; i ++) {\n            if (reader.getAttributeNamespace(i) != null) {\n                throw unexpectedAttribute(reader, i);\n            }\n            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));\n            switch (attribute) {\n                case NAME: break;\n                case BLOCKING: {\n                    blocking = Boolean.parseBoolean(reader.getAttributeValue(i));\n                    break;\n                }\n                default: throw unexpectedAttribute(reader, i);\n            }\n        }\n        // Elements\n        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            switch (Namespace.forUri(reader.getNamespaceURI())) {\n                case THREADS_1_0: {\n                    switch (Element.forName(reader.getLocalName())) {\n                        case MAX_THREADS: {\n                            setMaxThreads(readScaledCountElement(reader));\n                            break;\n                        }\n                        case THREAD_FACTORY: {\n                            setThreadFactory(readStringAttributeElement(reader, \"name\"));\n                            break;\n                        }\n                        case PROPERTIES: {\n                            setProperties(new PropertiesElement(reader));\n                            break;\n                        }\n                        default: throw unexpectedElement(reader);\n                    }\n                }\n                default: {\n                    throw unexpectedElement(reader);\n                }\n            }\n        }\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder batchBuilder = context.getBatchBuilder();\n\n        final ScaledCount maxThreads = getMaxThreads();\n        final ThreadFactoryExecutorService service = new ThreadFactoryExecutorService(maxThreads != null ? maxThreads.getScaledCount() : Integer.MAX_VALUE);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n    }","id":87533,"modified_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder batchBuilder = context.getBatchBuilder();\n\n        final ScaledCount maxThreads = getMaxThreads();\n        final ThreadFactoryExecutorService service = new ThreadFactoryExecutorService(maxThreads != null ? maxThreads.getScaledCount() : Integer.MAX_VALUE, blocking);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void writeContent(final XMLExtendedStreamWriter streamWriter) throws XMLStreamException {\n        streamWriter.writeAttribute(\"name\", getName());\n        final ScaledCount maxThreads = getMaxThreads();\n        if (maxThreads != null) writeScaledCountElement(streamWriter, maxThreads, \"max-threads\");\n        final String threadFactory = getThreadFactory();\n        if (threadFactory != null) {\n            streamWriter.writeEmptyElement(\"thread-factory\");\n            streamWriter.writeAttribute(\"name\", threadFactory);\n        }\n        final PropertiesElement properties = getProperties();\n        if (properties != null) {\n            streamWriter.writeStartElement(\"properties\");\n            properties.writeContent(streamWriter);\n        }\n        streamWriter.writeEndElement();\n    }","id":87534,"modified_method":"public void writeContent(final XMLExtendedStreamWriter streamWriter) throws XMLStreamException {\n        streamWriter.writeAttribute(\"name\", getName());\n        if (blocking) { streamWriter.writeAttribute(\"blocking\", \"true\"); }\n        final ScaledCount maxThreads = getMaxThreads();\n        if (maxThreads != null) writeScaledCountElement(streamWriter, maxThreads, \"max-threads\");\n        final String threadFactory = getThreadFactory();\n        if (threadFactory != null) {\n            streamWriter.writeEmptyElement(\"thread-factory\");\n            streamWriter.writeAttribute(\"name\", threadFactory);\n        }\n        final PropertiesElement properties = getProperties();\n        if (properties != null) {\n            streamWriter.writeStartElement(\"properties\");\n            properties.writeContent(streamWriter);\n        }\n        streamWriter.writeEndElement();\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ThreadFactoryExecutorService(int maxThreads) {\n        this.maxThreads = maxThreads;\n    }","id":87535,"modified_method":"public ThreadFactoryExecutorService(final int maxThreads, final boolean blocking) {\n        this.maxThreads = maxThreads;\n        this.blocking = blocking;\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void start(final StartContext context) throws StartException {\n        executor = JBossExecutors.threadFactoryExecutor(threadFactoryValue.getValue(), maxThreads);\n        value = JBossExecutors.protectedExecutorService(executor);\n    }","id":87536,"modified_method":"public synchronized void start(final StartContext context) throws StartException {\n        // TODO: Use org.jboss.threads.ThreadFactoryExecutor when public\n        executor = JBossExecutors.threadFactoryExecutor(threadFactoryValue.getValue(), maxThreads, blocking);\n        value = JBossExecutors.protectedExecutorService(executor);\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder batchBuilder = context.getBatchBuilder();\n        final ScaledCount maxThreads = getMaxThreads();\n        int maxThreadsValue = maxThreads != null ? maxThreads.getScaledCount() : Integer.MAX_VALUE;\n        TimeSpec keepAlive = getKeepaliveTime();\n        if(keepAlive == null)\n            keepAlive = TimeSpec.DEFAULT_KEEPALIVE;\n        final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService(maxThreadsValue, keepAlive);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n    }","id":87537,"modified_method":"public void activate(final ServiceActivatorContext context) {\n        final BatchBuilder batchBuilder = context.getBatchBuilder();\n        TimeSpec keepAlive = getKeepaliveTime();\n        if(keepAlive == null)\n            keepAlive = TimeSpec.DEFAULT_KEEPALIVE;\n        final UnboundedQueueThreadPoolService service = new UnboundedQueueThreadPoolService(getMaxThreads().getScaledCount(), keepAlive);\n        final ServiceName serviceName = JBOSS_THREAD_EXECUTOR.append(getName());\n        final BatchServiceBuilder<ExecutorService> serviceBuilder = batchBuilder.addService(serviceName, service);\n        final String threadFactory = getThreadFactory();\n        final ServiceName threadFactoryName;\n        if (threadFactory == null) {\n            threadFactoryName = serviceName.append(\"thread-factory\");\n            batchBuilder.addService(threadFactoryName, new ThreadFactoryService());\n        } else {\n            threadFactoryName = JBOSS_THREAD_FACTORY.append(threadFactory);\n        }\n        serviceBuilder.addDependency(threadFactoryName, ThreadFactory.class, service.getThreadFactoryInjector());\n    }","commit_id":"64805c0c43282ad978e1fc0f311a01283fc40d10","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void tryToExecAllList() {\n    ApplierCompleter right = this;\n    while (right != null) {\n      if (right.tryUnfork()) {\n        right.execAndForkSubTasks();\n      }\n      right = right.next;\n    }\n  }","id":87538,"modified_method":"private Throwable tryToExecAllList() {\n    ApplierCompleter right = this;\n    Throwable result = throwable;\n    while (right != null) {\n      if (right.tryUnfork()) {\n        right.execAndForkSubTasks();\n        result = moreImportant(result, right.throwable);\n      }\n      right = right.next;\n    }\n    return result;\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"boolean completeTaskWhichFailToAcquireReadAction() {\n    if (failedSubTasks == null) {\n      return true;\n    }\n    final boolean[] result = {true};\n    // these tasks could not be executed in the other thread; do them here\n    for (final ApplierCompleter task : failedSubTasks) {\n      task.failedSubTasks = null;\n      task.compute(new Runnable() {\n        @Override\n        public void run() {\n          for (int i = task.lo; i < task.hi; ++i) {\n            if (!task.processor.process(task.array.get(i))) {\n              result[0] = false;\n              break;\n            }\n          }\n        }\n      });\n      assert task.failedSubTasks == null : task.failedSubTasks;\n    }\n    return result[0];\n  }","id":87539,"modified_method":"boolean completeTaskWhichFailToAcquireReadAction() {\n    if (failedSubTasks == null) {\n      return true;\n    }\n    final boolean[] result = {true};\n    // these tasks could not be executed in the other thread; do them here\n    for (final ApplierCompleter task : failedSubTasks) {\n      task.failedSubTasks = null;\n      task.wrapInReadActionAndIndicator(new Runnable() {\n        @Override\n        public void run() {\n          for (int i = task.lo; i < task.hi; ++i) {\n            if (!task.processor.process(task.array.get(i))) {\n              result[0] = false;\n              break;\n            }\n          }\n        }\n      });\n      assert task.failedSubTasks == null : task.failedSubTasks;\n    }\n    return result[0];\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void compute() {\n    compute(new Runnable() {\n      @Override\n      public void run() {\n        execAndForkSubTasks();\n      }\n    });\n  }","id":87540,"modified_method":"@Override\n  public void compute() {\n    wrapInReadActionAndIndicator(new Runnable() {\n      @Override\n      public void run() {\n        execAndForkSubTasks();\n      }\n    });\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private ApplierCompleter execAndForkSubTasks() {\n    int hi = this.hi;\n    long start = System.currentTimeMillis();\n    ApplierCompleter right = null;\n    Throwable throwable = null;\n    try {\n      for (int i = lo; i < hi; ++i) {\n        progressIndicator.checkCanceled();\n        if (!processor.process(array.get(i))) throw new ComputationAbortedException();\n        long finish = System.currentTimeMillis();\n        long elapsed = finish - start;\n        if (elapsed > 10 && hi - i >= 2 && getSurplusQueuedTaskCount() <= JobSchedulerImpl.CORES_COUNT) {\n          int mid = i + hi >>> 1;\n          right = new ApplierCompleter(this, runInReadAction, progressIndicator, array, processor, mid, hi, right);\n          //children.add(right);\n          addToPendingCount(1);\n          right.fork();\n          hi = mid;\n          start = finish;\n        }\n      }\n\n      // traverse the list looking for a task available for stealing\n      if (right != null) {\n        right.tryToExecAllList();\n      }\n    }\n    catch (Throwable e) {\n      cancelProgress();\n      throwable = e;\n    }\n    finally {\n      doComplete(throwable == null ? this.throwable : throwable);\n    }\n    return right;\n  }","id":87541,"modified_method":"@Nullable\n  private ApplierCompleter execAndForkSubTasks() {\n    int hi = this.hi;\n    long start = System.currentTimeMillis();\n    ApplierCompleter right = null;\n    Throwable throwable = null;\n    try {\n      for (int i = lo; i < hi; ++i) {\n        progressIndicator.checkCanceled();\n        if (!processor.process(array.get(i))) {\n          throw new ComputationAbortedException();\n        }\n        long finish = System.currentTimeMillis();\n        long elapsed = finish - start;\n        if (elapsed > 5 && hi - i >= 2 && getSurplusQueuedTaskCount() <= JobSchedulerImpl.CORES_COUNT) {\n          int mid = i + hi >>> 1;\n          right = new ApplierCompleter(this, runInReadAction, progressIndicator, array, processor, mid, hi, right);\n          //children.add(right);\n          addToPendingCount(1);\n          right.fork();\n          hi = mid;\n          start = finish;\n        }\n      }\n\n      // traverse the list looking for a task available for stealing\n      if (right != null) {\n        throwable = right.tryToExecAllList();\n      }\n    }\n    catch (Throwable e) {\n      cancelProgress();\n      throwable = e;\n    }\n    finally {\n      doComplete(moreImportant(throwable, this.throwable));\n    }\n    return right;\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doComplete(Throwable throwable) {\n    ApplierCompleter a = this;\n    ApplierCompleter child = a;\n    while (true) {\n      if (throwable != null) {\n        a.throwable = throwable;\n      }\n      if (a.getPendingCount() == 0) {\n        if (throwable == null) {\n          a.onCompletion(child);\n        }\n        else {\n          a.throwable = throwable;\n          // currently avoid using onExceptionalCompletion since it leaks exceptions via jsr166e.ForkJoinTask.exceptionTable\n          a.onCompletion(child);\n          //a.onExceptionalCompletion(throwable, child);\n        }\n        child = a;\n        a = (ApplierCompleter)a.getCompleter();\n        if (a == null) {\n          if (throwable == null) {\n            child.quietlyComplete();\n          }\n          else {\n            child.throwable = throwable;\n            // currently avoid using completeExceptionally since it leaks exceptions via jsr166e.ForkJoinTask.exceptionTable\n            child.quietlyComplete();\n            //child.completeExceptionally(throwable);\n          }\n          break;\n        }\n      }\n      else if (a.decrementPendingCountUnlessZero() != 0) {\n        break;\n      }\n    }\n  }","id":87542,"modified_method":"private void doComplete(Throwable throwable) {\n    ApplierCompleter a = this;\n    ApplierCompleter child = a;\n    while (true) {\n      // update parent.throwable in a thread safe way\n      Throwable oldThrowable;\n      Throwable newThrowable;\n      do {\n        oldThrowable = a.throwable;\n        newThrowable = moreImportant(oldThrowable, throwable);\n      } while (oldThrowable != newThrowable && !throwableUpdater.compareAndSet(a, oldThrowable, newThrowable));\n      throwable = newThrowable;\n      if (a.getPendingCount() == 0) {\n        // currently avoid using onExceptionalCompletion since it leaks exceptions via jsr166e.ForkJoinTask.exceptionTable\n        a.onCompletion(child);\n        //a.onExceptionalCompletion(throwable, child);\n        child = a;\n        a = (ApplierCompleter)a.getCompleter();\n        if (a == null) {\n          // currently avoid using completeExceptionally since it leaks exceptions via jsr166e.ForkJoinTask.exceptionTable\n          child.quietlyComplete();\n          break;\n        }\n      }\n      else if (a.decrementPendingCountUnlessZero() != 0) {\n        break;\n      }\n    }\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EntryPointsManagerBase(Project project) {\n    myProject = project;\n    myTemporaryEntryPoints = new HashSet<RefElement>();\n    myPersistentEntryPoints =\n        new LinkedHashMap<String, SmartRefElementPointer>(); // To keep the order between readExternal to writeExternal\n    Disposer.register(project, this);\n    final ExtensionPoint<EntryPoint> point = Extensions.getRootArea().getExtensionPoint(ToolExtensionPoints.DEAD_CODE_TOOL);\n    point.addExtensionPointListener(new ExtensionPointListener<EntryPoint>() {\n      @Override\n      public void extensionAdded(@NotNull EntryPoint extension, @Nullable PluginDescriptor pluginDescriptor) {\n        extensionRemoved(extension, pluginDescriptor);\n      }\n\n      @Override\n      public void extensionRemoved(@NotNull EntryPoint extension, @Nullable PluginDescriptor pluginDescriptor) {\n        if (ADDITIONAL_ANNOS != null) {\n          ADDITIONAL_ANNOS = null;\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              if (ApplicationManager.getApplication().isDisposed()) return;\n              InspectionProfileManager.getInstance().fireProfileChanged(null);\n            }\n          });\n        }\n      }\n    }, this);\n  }","id":87543,"modified_method":"public EntryPointsManagerBase(Project project) {\n    myProject = project;\n    myTemporaryEntryPoints = new HashSet<RefElement>();\n    myPersistentEntryPoints = new LinkedHashMap<String, SmartRefElementPointer>(); // To keep the order between readExternal to writeExternal\n    Disposer.register(project, this);\n    final ExtensionPoint<EntryPoint> point = Extensions.getRootArea().getExtensionPoint(ToolExtensionPoints.DEAD_CODE_TOOL);\n    ((ExtensionPointImpl)point).addExtensionPointListener(new ExtensionPointListener<EntryPoint>() {\n      @Override\n      public void extensionAdded(@NotNull EntryPoint extension, @Nullable PluginDescriptor pluginDescriptor) {\n        extensionRemoved(extension, pluginDescriptor);\n      }\n\n      @Override\n      public void extensionRemoved(@NotNull EntryPoint extension, @Nullable PluginDescriptor pluginDescriptor) {\n        if (ADDITIONAL_ANNOS != null) {\n          ADDITIONAL_ANNOS = null;\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              if (ApplicationManager.getApplication().isDisposed()) return;\n              InspectionProfileManager.getInstance().fireProfileChanged(null);\n            }\n          });\n        }\n      }\n    }, false, this);\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static <T> boolean invokeConcurrentlyForAll(@NotNull final List<T> things,\n                                                      boolean runInReadAction,\n                                                      @NotNull final Processor<? super T> thingProcessor,\n                                                      @NotNull ProgressIndicator wrapper) throws ProcessCanceledException {\n    ApplierCompleter applier = new ApplierCompleter(null, runInReadAction, wrapper, things, thingProcessor, 0, things.size(), null);\n    try {\n      pool.invoke(applier);\n      if (applier.throwable != null) throw applier.throwable;\n    }\n    catch (ApplierCompleter.ComputationAbortedException e) {\n      return false;\n    }\n    catch (RuntimeException e) {\n      throw e;\n    }\n    catch (Error e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      throw new RuntimeException(e);\n    }\n    assert applier.isDone();\n    return applier.completeTaskWhichFailToAcquireReadAction();\n  }","id":87544,"modified_method":"private static <T> boolean invokeConcurrentlyForAll(@NotNull final List<T> things,\n                                                      boolean runInReadAction,\n                                                      @NotNull final Processor<? super T> thingProcessor,\n                                                      @NotNull ProgressIndicator wrapper) throws ProcessCanceledException {\n    ApplierCompleter applier = new ApplierCompleter(null, runInReadAction, wrapper, things, thingProcessor, 0, things.size(), null);\n    try {\n      pool.invoke(applier);\n      if (applier.throwable != null) throw applier.throwable;\n    }\n    catch (ApplierCompleter.ComputationAbortedException e) {\n      return false;\n    }\n    catch (ProcessCanceledException e) {\n      // task1.processor returns false and the task cancels the indicator\n      // then task2 calls checkCancel() and get here\n      return false;\n    }\n    catch (RuntimeException e) {\n      throw e;\n    }\n    catch (Error e) {\n      throw e;\n    }\n    catch (Throwable e) {\n      throw new RuntimeException(e);\n    }\n    assert applier.isDone();\n    return applier.completeTaskWhichFailToAcquireReadAction();\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testExceptionalCompletion() throws Throwable {\n    final List<Object> objects = Collections.nCopies(100000000, null);\n    COUNT.set(0);\n    try {\n      JobLauncher.getInstance().invokeConcurrentlyUnderProgress(objects, null, true, new Processor<Object>() {\n        @Override\n        public boolean process(Object o) {\n          if (COUNT.incrementAndGet() == 100000) {\n            System.out.println(\"PCE\");\n            throw new ProcessCanceledException();\n          }\n          return true;\n        }\n      });\n      fail(\"PCE must have been thrown\");\n    }\n    catch (ProcessCanceledException e) {\n      // caught OK\n    }\n  }","id":87545,"modified_method":"public void testExceptionalCompletion() throws Throwable {\n    final List<Object> objects = Collections.nCopies(100000000, null);\n    COUNT.set(0);\n    try {\n      JobLauncher.getInstance().invokeConcurrentlyUnderProgress(objects, null, true, new Processor<Object>() {\n        @Override\n        public boolean process(Object o) {\n          if (COUNT.incrementAndGet() == 100000) {\n            System.out.println(\"PCE\");\n            throw new MyException();\n          }\n          return true;\n        }\n      });\n      fail(\"exception must have been thrown\");\n    }\n    catch (MyException e) {\n      // caught OK\n    }\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testJobUtilRecursiveCancel() throws Exception {\n    final List<String> list = Collections.nCopies(100, \"\");\n    final List<Integer> ilist = Collections.nCopies(100, 0);\n    for (int i=0; i<10; i++) {\n      COUNT.set(0);\n      long start = System.currentTimeMillis();\n      boolean success = false;\n      try {\n        success = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(list, null, false, new Processor<String>() {\n          @Override\n          public boolean process(String name) {\n            boolean nestedSuccess = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(ilist, null, false, new Processor<Integer>() {\n              @Override\n              public boolean process(Integer integer) {\n                if (busySleep(1) == 1000) {\n                  System.out.println(\"PCE\");\n                  throw new RuntimeException(\"xxx\");\n                }\n                return true;\n              }\n            });\n            //System.out.println(\"nestedSuccess = \" + nestedSuccess);\n            return true;\n          }\n        });\n      }\n      catch (ProcessCanceledException e) {\n        // OK\n      }\n      catch (RuntimeException e) {\n        assertEquals(\"xxx\", e.getMessage());\n      }\n      long finish = System.currentTimeMillis();\n      System.out.println(\"Elapsed: \"+(finish-start)+\"ms\");\n      //assertEquals(list.size()*list.size(), COUNT.get());\n      assertFalse(success);\n    }\n  }","id":87546,"modified_method":"public void testJobUtilRecursiveCancel() throws Exception {\n    final List<String> list = Collections.nCopies(100, \"\");\n    final List<Integer> ilist = Collections.nCopies(100, 0);\n    for (int i=0; i<10; i++) {\n      COUNT.set(0);\n      long start = System.currentTimeMillis();\n      boolean success = false;\n      try {\n        success = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(list, null, false, new Processor<String>() {\n          @Override\n          public boolean process(String name) {\n            boolean nestedSuccess = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(ilist, null, false, new Processor<Integer>() {\n              @Override\n              public boolean process(Integer integer) {\n                if (busySleep(1) == 1000) {\n                  System.out.println(\"PCE\");\n                  throw new MyException();\n                }\n                return true;\n              }\n            });\n            //System.out.println(\"nestedSuccess = \" + nestedSuccess);\n            return true;\n          }\n        });\n        fail(\"exception must have been thrown\");\n      }\n      catch (MyException ignored) {\n      }\n      long finish = System.currentTimeMillis();\n      System.out.println(\"Elapsed: \"+(finish-start)+\"ms\");\n      //assertEquals(list.size()*list.size(), COUNT.get());\n      assertFalse(success);\n    }\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testNotNormalCompletion() throws Throwable {\n    final List<Object> objects = Collections.nCopies(100000000, null);\n    COUNT.set(0);\n    try {\n      boolean success = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(objects, null, true, new Processor<Object>() {\n        @Override\n        public boolean process(Object o) {\n          if (COUNT.incrementAndGet() == 100000) {\n            System.out.println(\"PCE\");\n            return false;\n          }\n          return true;\n        }\n      });\n      assertFalse(success);\n    }\n    catch (ProcessCanceledException e) {\n    }\n  }","id":87547,"modified_method":"public void testNotNormalCompletion() throws Throwable {\n    final List<Object> objects = Collections.nCopies(100000000, null);\n    COUNT.set(0);\n    boolean success = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(objects, null, true, new Processor<Object>() {\n      @Override\n      public boolean process(Object o) {\n        if (COUNT.incrementAndGet() == 100000) {\n          System.out.println(\"PCE\");\n          return false;\n        }\n        return true;\n      }\n    });\n    assertFalse(success);\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public EntryPointsManager getEntryPointsManager() {\n    if (myEntryPointsManager == null) {\n      final Project project = myRefManager.getProject();\n      myEntryPointsManager = EntryPointsManager.getInstance(project);\n      ((EntryPointsManagerBase)myEntryPointsManager).addAllPersistentEntries(EntryPointsManagerBase.getInstance(project));\n    }\n    return myEntryPointsManager;\n  }","id":87548,"modified_method":"@Override\n  public EntryPointsManager getEntryPointsManager() {\n    if (myEntryPointsManager == null) {\n      final Project project = myRefManager.getProject();\n      myEntryPointsManager = new EntryPointsManagerBase(project) {\n        @Override\n        public void configureAnnotations() {\n\n        }\n\n        @Override\n        public JButton createConfigureAnnotationsBtn() {\n          return null;\n        }\n      };\n      ((EntryPointsManagerBase)myEntryPointsManager).addAllPersistentEntries(EntryPointsManagerBase.getInstance(project));\n    }\n    return myEntryPointsManager;\n  }","commit_id":"e9c1a15ee74d6cebac5e218b2d22d28e905c8a27","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ListenableFuture<AdHocPlannedStmtBatch> compileAdHocPlanFuture(final AdHocPlannerWork apw) {\n        return m_es.submit(new Callable<AdHocPlannedStmtBatch>() {\n            @Override\n            public AdHocPlannedStmtBatch call() throws Exception {\n                return compileAdHocPlan(apw);\n            }\n        });\n    }","id":87549,"modified_method":"public void compileAdHocPlanForProcedure(final AdHocPlannerWork apw) {\n        m_es.submit(new Runnable() {\n            @Override\n            public void run(){\n                apw.completionHandler.onCompletion(compileAdHocPlan(apw));\n            }\n        });\n    }","commit_id":"c0b80eccda24392277eee25e61b8355fe94167e0","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void handleMailboxMessage(final VoltMessage message) {\n        final LocalObjectMessage wrapper = (LocalObjectMessage)message;\n        if (wrapper.payload instanceof AdHocPlannerWork) {\n            final AdHocPlannerWork w = (AdHocPlannerWork)(wrapper.payload);\n            final AsyncCompilerResult result = compileAdHocPlan(w);\n            if (w.completionHandler != null) {\n                w.completionHandler.onCompletion(result);\n            } else {\n                /*\n                 * I believe this may be dead code? I don't know of anything receiving a response\n                 * via the mailbox system\n                 */\n                // XXX: need client interface mailbox id.\n                m_mailbox.send(message.m_sourceHSId, new LocalObjectMessage(result));\n            }\n        }\n        else if (wrapper.payload instanceof CatalogChangeWork) {\n            final CatalogChangeWork w = (CatalogChangeWork)(wrapper.payload);\n            final AsyncCompilerResult result = prepareApplicationCatalogDiff(w);\n            if (w.completionHandler != null) {\n                w.completionHandler.onCompletion(result);\n            } else {\n                /*\n                 * I believe this may be dead code? I don't know of anything receiving a response\n                 * via the mailbox system\n                 */\n                // XXX: need client interface mailbox id.\n                m_mailbox.send(message.m_sourceHSId, new LocalObjectMessage(result));\n            }\n        }\n    }","id":87550,"modified_method":"void handleMailboxMessage(final VoltMessage message) {\n        final LocalObjectMessage wrapper = (LocalObjectMessage)message;\n        if (wrapper.payload instanceof AdHocPlannerWork) {\n            final AdHocPlannerWork w = (AdHocPlannerWork)(wrapper.payload);\n            final AsyncCompilerResult result = compileAdHocPlan(w);\n            w.completionHandler.onCompletion(result);\n        }\n        else if (wrapper.payload instanceof CatalogChangeWork) {\n            final CatalogChangeWork w = (CatalogChangeWork)(wrapper.payload);\n            final AsyncCompilerResult result = prepareApplicationCatalogDiff(w);\n            w.completionHandler.onCompletion(result);\n        }\n    }","commit_id":"c0b80eccda24392277eee25e61b8355fe94167e0","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void createMailbox(final HostMessenger hostMessenger, final long hsId) {\n        m_mailbox = new LocalMailbox(hostMessenger) {\n\n            @Override\n            public void send(long destinationHSId, VoltMessage message) {\n                message.m_sourceHSId = hsId;\n                hostMessenger.send(destinationHSId, message);\n            }\n\n            @Override\n            public void deliver(final VoltMessage message) {\n                try {\n                    m_es.submit(new Runnable() {\n                        @Override\n                        public void run() {\n                            handleMailboxMessage(message);\n                        }\n                    });\n                } catch (RejectedExecutionException rejected) {\n                    final LocalObjectMessage wrapper = (LocalObjectMessage)message;\n                    AsyncCompilerWork work = (AsyncCompilerWork)(wrapper.payload);\n                    AsyncCompilerResult retval = new AsyncCompilerResult();\n                    retval.clientHandle = work.clientHandle;\n                    retval.errorMsg = \"Ad Hoc Planner is not available. Try again.\";\n                    retval.connectionId = work.connectionId;\n                    retval.hostname = work.hostname;\n                    retval.adminConnection = work.adminConnection;\n                    retval.clientData = work.clientData;\n                    // XXX: need client interface mailbox id.\n                    m_mailbox.send(message.m_sourceHSId, new LocalObjectMessage(retval));\n                }\n            }\n        };\n        hostMessenger.createMailbox(hsId, m_mailbox);\n    }","id":87551,"modified_method":"public void createMailbox(final HostMessenger hostMessenger, final long hsId) {\n        m_mailbox = new LocalMailbox(hostMessenger) {\n\n            @Override\n            public void send(long destinationHSId, VoltMessage message) {\n                message.m_sourceHSId = hsId;\n                hostMessenger.send(destinationHSId, message);\n            }\n\n            @Override\n            public void deliver(final VoltMessage message) {\n                try {\n                    m_es.submit(new Runnable() {\n                        @Override\n                        public void run() {\n                            handleMailboxMessage(message);\n                        }\n                    });\n                } catch (RejectedExecutionException rejected) {\n                    final LocalObjectMessage wrapper = (LocalObjectMessage)message;\n                    AsyncCompilerWork work = (AsyncCompilerWork)(wrapper.payload);\n                    AsyncCompilerResult retval = new AsyncCompilerResult();\n                    retval.clientHandle = work.clientHandle;\n                    retval.errorMsg = \"Ad Hoc Planner is not available. Try again.\";\n                    retval.connectionId = work.connectionId;\n                    retval.hostname = work.hostname;\n                    retval.adminConnection = work.adminConnection;\n                    retval.clientData = work.clientData;\n                    work.completionHandler.onCompletion(retval);\n                }\n            }\n        };\n        hostMessenger.createMailbox(hsId, m_mailbox);\n    }","commit_id":"c0b80eccda24392277eee25e61b8355fe94167e0","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public AsyncCompilerWork(long replySiteId, boolean shouldShutdown, long clientHandle,\n            long connectionId, String hostname, boolean adminConnection,\n            Object clientData,\n            AsyncCompilerWorkCompletionHandler completionHandler)\n    {\n        this.replySiteId = replySiteId;\n        this.shouldShutdown = shouldShutdown;\n        this.clientHandle = clientHandle;\n        this.connectionId = connectionId;\n        this.hostname = hostname;\n        this.adminConnection = adminConnection;\n        this.clientData = clientData;\n        this.completionHandler = completionHandler;\n    }","id":87552,"modified_method":"public AsyncCompilerWork(long replySiteId, boolean shouldShutdown, long clientHandle,\n            long connectionId, String hostname, boolean adminConnection,\n            Object clientData,\n            AsyncCompilerWorkCompletionHandler completionHandler)\n    {\n        this.replySiteId = replySiteId;\n        this.shouldShutdown = shouldShutdown;\n        this.clientHandle = clientHandle;\n        this.connectionId = connectionId;\n        this.hostname = hostname;\n        this.adminConnection = adminConnection;\n        this.clientData = clientData;\n        this.completionHandler = completionHandler;\n        if (completionHandler == null) {\n            throw new IllegalArgumentException(\"Completion handler can't be null\");\n        }\n    }","commit_id":"c0b80eccda24392277eee25e61b8355fe94167e0","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public ListenableFuture<AdHocPlannedStmtBatch> plan(String sql, boolean multipart) {\n        /*\n         * If this is multi-part, don't give the planner a partition param AND\n         * tell it not to infer whether the plan is single part. Those optimizations\n         * are fine for adhoc SQL planned outside a stored proc, but not when those\n         * factors have already been determined by the proc.\n         */\n        AdHocPlannerWork work =\n            new AdHocPlannerWork(\n                    -1, false, 0, 0, \"\", false, null, //none of the params on this line are used\n                    sql, Arrays.asList(new String[] { sql }), multipart ? null : 0, m_catalogContext, true, !multipart,\n                    null);\n        return m_agent.compileAdHocPlanFuture(work);\n    }","id":87553,"modified_method":"public ListenableFuture<AdHocPlannedStmtBatch> plan(String sql, boolean multipart) {\n        /*\n         * If this is multi-part, don't give the planner a partition param AND\n         * tell it not to infer whether the plan is single part. Those optimizations\n         * are fine for adhoc SQL planned outside a stored proc, but not when those\n         * factors have already been determined by the proc.\n         */\n        final SettableFuture<AdHocPlannedStmtBatch> retval = SettableFuture.create();\n        AdHocPlannerWork work =\n            new AdHocPlannerWork(\n                    -1, false, 0, 0, \"\", false, null, //none of the params on this line are used\n                    sql, Arrays.asList(new String[] { sql }), multipart ? null : 0, m_catalogContext, true, !multipart,\n                    new AsyncCompilerWorkCompletionHandler() {\n\n                        @Override\n                        public void onCompletion(AsyncCompilerResult result) {\n                            retval.set((AdHocPlannedStmtBatch)result);\n                        }\n\n                    });\n        m_agent.compileAdHocPlanForProcedure(work);\n        return retval;\n    }","commit_id":"c0b80eccda24392277eee25e61b8355fe94167e0","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Checks if a proper response is sent back when the max queue depth is\n     * reached.\n     * @throws MessagingException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testMaxQueueDepth() throws InterruptedException {\n        /*\n         * mock the compileAdHocPlan method so that we can control how many\n         * things will be waiting in the queue\n         */\n        BlockingAnswer blockingAnswer = new BlockingAnswer();\n        doAnswer(blockingAnswer).when(m_agent).compileAdHocPlan(any(AdHocPlannerWork.class));\n\n        m_agent.createMailbox(mock(HostMessenger.class), 100);\n        m_agent.m_mailbox = spy(m_agent.m_mailbox);\n\n        /*\n         * send max + 2 messages to the agent. The first one will be executed\n         * immediately so it doesn't consume queue capacity, the next max number\n         * of messages will use up all the capacity, the last one will be\n         * rejected.\n         */\n        for (int i = 0; i < AsyncCompilerAgent.MAX_QUEUE_DEPTH + 2; ++i) {\n            AdHocPlannerWork work =\n                    new AdHocPlannerWork(100l, false, 0, 0, \"localhost\", false, null,\n                            \"select * from a\", Arrays.asList(new String[] {\"select * from a\"}), 0, null, false, true, null);\n            LocalObjectMessage msg = new LocalObjectMessage(work);\n            msg.m_sourceHSId = 100;\n            m_agent.m_mailbox.deliver(msg);\n        }\n\n        // check for one rejected request\n        ArgumentCaptor<LocalObjectMessage> captor = ArgumentCaptor.forClass(LocalObjectMessage.class);\n        verify(m_agent.m_mailbox).send(eq(100L), captor.capture());\n        assertNotNull(((AsyncCompilerResult) captor.getValue().payload).errorMsg);\n        // let all requests return\n        blockingAnswer.flag.release(AsyncCompilerAgent.MAX_QUEUE_DEPTH + 1);\n\n        // check if all previous requests finish\n        m_agent.shutdown();\n        VerificationMode expected = times(AsyncCompilerAgent.MAX_QUEUE_DEPTH + 2);\n        verify(m_agent.m_mailbox, expected).send(eq(100L), any(LocalObjectMessage.class));\n    }","id":87554,"modified_method":"/**\n     * Checks if a proper response is sent back when the max queue depth is\n     * reached.\n     * @throws MessagingException\n     * @throws InterruptedException\n     */\n    @Test\n    public void testMaxQueueDepth() throws InterruptedException {\n        /*\n         * mock the compileAdHocPlan method so that we can control how many\n         * things will be waiting in the queue\n         */\n        BlockingAnswer blockingAnswer = new BlockingAnswer();\n        doAnswer(blockingAnswer).when(m_agent).compileAdHocPlan(any(AdHocPlannerWork.class));\n\n        m_agent.createMailbox(mock(HostMessenger.class), 100);\n        m_agent.m_mailbox = spy(m_agent.m_mailbox);\n\n        /*\n         * send max + 2 messages to the agent. The first one will be executed\n         * immediately so it doesn't consume queue capacity, the next max number\n         * of messages will use up all the capacity, the last one will be\n         * rejected.\n         */\n        final AtomicInteger completedRequests = new AtomicInteger();\n        final AtomicReference<AsyncCompilerResult> result = new AtomicReference<AsyncCompilerResult>();\n        final long threadId = Thread.currentThread().getId();\n        for (int i = 0; i < AsyncCompilerAgent.MAX_QUEUE_DEPTH + 2; ++i) {\n            AdHocPlannerWork work =\n                    new AdHocPlannerWork(100l, false, 0, 0, \"localhost\", false, null,\n                            \"select * from a\", Arrays.asList(new String[] {\"select * from a\"}), 0, null, false, true,\n                            new AsyncCompilerWorkCompletionHandler() {\n\n                                @Override\n                                public void onCompletion(\n                                        AsyncCompilerResult compilerResult) {\n                                    completedRequests.incrementAndGet();\n                                    /*\n                                     * A rejected request will be handled in the current thread invoking deliver\n                                     * so use that to record the error response\n                                     */\n                                    if (Thread.currentThread().getId() == threadId) {\n                                        result.set(compilerResult);\n                                    }\n                                }\n\n                    });\n            LocalObjectMessage msg = new LocalObjectMessage(work);\n            msg.m_sourceHSId = 100;\n            m_agent.m_mailbox.deliver(msg);\n        }\n\n        // check for one rejected request\n        assertNotNull(result.get().errorMsg);\n\n        // let all requests return\n        blockingAnswer.flag.release(AsyncCompilerAgent.MAX_QUEUE_DEPTH + 5);\n\n        // check if all previous requests finish\n        m_agent.shutdown();\n        assertEquals(AsyncCompilerAgent.MAX_QUEUE_DEPTH + 2, completedRequests.get());\n    }","commit_id":"c0b80eccda24392277eee25e61b8355fe94167e0","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\r\n  public void serialize(final Serializer ser) throws IOException {\r\n    final byte[] tag = name.atom();\r\n    final byte[] uri = name.uri.atom();\r\n    ser.openElement(tag);\r\n\r\n    // remember top level namespace\r\n    final byte[] dn = ser.dn;\r\n    // xmlns? namespace with prefix?\r\n    boolean xmlns = false;\r\n\r\n    // serialize all namespaces at top level...\r\n    if(ser.level() == 1) {\r\n      final Atts nns = nsScope();\r\n      for(int a = 0; a < nns.size; ++a) {\r\n        if(nns.key[a].length == 0) {\r\n          xmlns = true;\r\n          if(Token.eq(ser.dn, nns.val[a])) continue;\r\n          // reset default namespace\r\n          ser.dn = nns.val[a];\r\n        }\r\n        ser.namespace(nns.key[a], nns.val[a]);\r\n      }\r\n\r\n      // serialize default namespace if not done yet\r\n      for(int p = ser.ns.size - 1; p >= 0 && !xmlns; p--) {\r\n        if(ser.ns.key[p].length != 0) continue;\r\n        xmlns = true;\r\n        ser.dn = ser.ns.val[p];\r\n        ser.namespace(EMPTY, ser.ns.val[p]);\r\n      }\r\n    } else {\r\n      if(ns != null) {\r\n        for(int p = ns.size - 1; p >= 0; p--) {\r\n          final byte[] key = ns.key[p];\r\n          final int i = ser.ns.get(key);\r\n          if(i == -1 || !Token.eq(ser.ns.val[i], uri)) {\r\n            ser.namespace(key, ns.val[p]);\r\n            xmlns |= key.length == 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    ser.dn = uri;\r\n\r\n    // serialize attributes\r\n    for(int n = 0; n < atts.size(); ++n) {\r\n      final Nod nod = atts.get(n);\r\n      final QNm atn = nod.qname();\r\n      if(atn.ns()) {\r\n        if(!NSGlobal.standard(atn.uri.atom())) {\r\n          final byte[] pre = atn.pref();\r\n          final int i = ser.ns.get(pre);\r\n          if(i == -1) ser.namespace(pre, atn.uri.atom());\r\n        }\r\n      }\r\n      ser.attribute(atn.atom(), nod.atom());\r\n    }\r\n\r\n    // serialize children\r\n    for(int n = 0; n < children.size(); ++n) children.get(n).serialize(ser);\r\n    ser.closeElement();\r\n\r\n    // reset top level namespace\r\n    ser.dn = dn;\r\n  }","id":87555,"modified_method":"@Override\r\n  public void serialize(final Serializer ser) throws IOException {\r\n    final byte[] tag = name.atom();\r\n    final byte[] uri = name.uri.atom();\r\n    ser.openElement(tag);\r\n\r\n    // remember top level namespace\r\n    final byte[] dn = ser.dn;\r\n    // xmlns? namespace with prefix?\r\n\r\n    // serialize all namespaces at top level...\r\n    if(ser.level() == 1) {\r\n      final Atts nns = nsScope();\r\n      for(int a = 0; a < nns.size; ++a) {\r\n        if(nns.key[a].length == 0) {\r\n          if(Token.eq(ser.dn, nns.val[a])) continue;\r\n          // reset default namespace\r\n          ser.dn = nns.val[a];\r\n        }\r\n        ser.namespace(nns.key[a], nns.val[a]);\r\n      }\r\n\r\n      // serialize default namespace if not done yet\r\n      final byte[] def = ser.ns(EMPTY);\r\n      if(def != null) {\r\n        ser.dn = def;\r\n        ser.namespace(EMPTY, def);\r\n      }\r\n    } else if(ns != null) {\r\n      for(int p = ns.size - 1; p >= 0; p--) ser.namespace(ns.key[p], ns.val[p]);\r\n    }\r\n\r\n    ser.dn = uri;\r\n\r\n    // serialize attributes\r\n    for(int n = 0; n < atts.size(); ++n) {\r\n      final Nod nod = atts.get(n);\r\n      final QNm atn = nod.qname();\r\n      if(atn.ns() && !NSGlobal.standard(atn.uri.atom())) {\r\n        ser.namespace(atn.pref(), atn.uri.atom());\r\n      }\r\n      ser.attribute(atn.atom(), nod.atom());\r\n    }\r\n\r\n    // serialize children\r\n    for(int n = 0; n < children.size(); ++n) children.get(n).serialize(ser);\r\n    ser.closeElement();\r\n\r\n    // reset top level namespace\r\n    ser.dn = dn;\r\n  }","commit_id":"72ba859c91004f1f6b13d024db1e2baf8e53083e","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Serializes a namespace.\r\n   * @param n name\r\n   * @param v value\r\n   * @throws IOException I/O exception\r\n   */\r\n  public final void namespace(final byte[] n, final byte[] v)\r\n      throws IOException {\r\n\r\n    if(!undecl && n.length != 0 && v.length == 0) return;\r\n    attribute(n.length == 0 ? XMLNS : concat(XMLNSC, n), v);\r\n    ns.add(n, v);\r\n  }","id":87556,"modified_method":"/**\r\n   * Serializes a namespace.\r\n   * @param n name\r\n   * @param v value\r\n   * @throws IOException I/O exception\r\n   */\r\n  public final void namespace(final byte[] n, final byte[] v)\r\n      throws IOException {\r\n    \r\n    if(!undecl && n.length != 0 && v.length == 0) return;\r\n    final byte[] uri = ns(n);\r\n    if(uri == null || !eq(uri, v)) {\r\n      attribute(n.length == 0 ? XMLNS : concat(XMLNSC, n), v);\r\n      ns.add(n, v);\r\n    }\r\n  }","commit_id":"72ba859c91004f1f6b13d024db1e2baf8e53083e","url":"https://github.com/BaseXdb/basex"},{"original_method":"public void characters(CharSequence seq) throws SAXException {\n\t\treceiver.characters(seq);\n\t}","id":87557,"modified_method":"public void characters(CharSequence seq) throws SAXException {\n        if (!inFallback || error != null)\n            receiver.characters(seq);\n\t}","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"public void attribute(QName qname, String value) throws SAXException {\n\t\treceiver.attribute(qname, value);\n\t}","id":87558,"modified_method":"public void attribute(QName qname, String value) throws SAXException {\n        if (!inFallback || error != null)\n            receiver.attribute(qname, value);\n\t}","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"public void comment(char[] ch, int start, int length) throws SAXException {\n\t\treceiver.comment(ch, start, length);\n\t}","id":87559,"modified_method":"public void comment(char[] ch, int start, int length) throws SAXException {\n        if (!inFallback || error != null)\n            receiver.comment(ch, start, length);\n\t}","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @see org.exist.util.serializer.Receiver#endElement(org.exist.dom.QName)\n\t */\n\tpublic void endElement(QName qname) throws SAXException {\n\t\tif( !XINCLUDE_NS.equals( qname.getNamespaceURI() ) )\n\t\t\treceiver.endElement(qname);\n\t}","id":87560,"modified_method":"/**\n\t * @see org.exist.util.serializer.Receiver#endElement(org.exist.dom.QName)\n\t */\n    public void endElement(QName qname) throws SAXException {\n        if (XINCLUDE_NS.equals(qname.getNamespaceURI())) {\n            if (XI_FALLBACK.equals(qname.getLocalName())) {\n                inFallback = false;\n                // clear error\n                error = null;\n            } else if (XI_INCLUDE.equals(qname.getLocalName()) && error != null) {\n                // found an error, but there was no fallback element.\n                // throw the exception now\n                Exception e = error;\n                error = null;\n                throw new SAXException(e.getMessage(), e);\n            }\n        } else if (!inFallback || error != null)\n            receiver.endElement(qname);\n    }","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void processXInclude(String href, String xpointer) throws SAXException {\n        if(href == null)\n            throw new SAXException(\"No href attribute found in XInclude include element\");\n        // save some settings\n        DocumentImpl prevDoc = document;\n        boolean createContainerElements = serializer.createContainerElements;\n        serializer.createContainerElements = false;\n\n        //The following comments are the basis for possible external documents\n        XmldbURI docUri = null;\n        //URI externalUri = null;\n        try {\n            docUri = XmldbURI.xmldbUriFor(href);\n            /*\n               if(!stylesheetUri.toCollectionPathURI().equals(stylesheetUri)) {\n                   externalUri = stylesheetUri.getXmldbURI();\n               }\n               */\n        } catch (URISyntaxException e) {\n            //could be an external URI!\n            /*\n               try {\n                   externalUri = new URI(href);\n               } catch (URISyntaxException ee) {\n               */\n            throw new IllegalArgumentException(\"Stylesheet URI could not be parsed: \"+e.getMessage());\n            //}\n        }\n\n        // parse the href attribute\n        LOG.debug(\"found href=\\\"\" + href + \"\\\"\");\n        //String xpointer = null;\n        //String docName = href;\n        String fragment = docUri.getFragment();\n        if (!(fragment == null || fragment.length() == 0))\n            throw new SAXException(\"Fragment identifiers must not be used in an xinclude href attribute. To specify an \" +\n                    \"xpointer, use the xpointer attribute.\");\n\n//        if(xpointer!=null) {\n//            try {\n//                xpointer = XMLUtil.decodeAttrMarkup(URLDecoder.decode(xpointer, \"UTF-8\"));\n//            } catch (UnsupportedEncodingException e) {\n//            \tLOG.warn(e);\n//            }\n//            // remove the fragment part from the URI for further processing\n//            URI u = docUri.getURI();\n//            try {\n//                u = new URI(u.getScheme(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), null);\n//                docUri = XmldbURI.xmldbUriFor(u);\n//            } catch (URISyntaxException e) {\n//                throw new IllegalArgumentException(\"Stylesheet URI could not be parsed: \" + e.getMessage());\n//            }\n//        }\n\n        // extract possible parameters in the URI\n        Map params = null;\n        String paramStr = docUri.getQuery();\n        if (paramStr != null) {\n            params = processParameters(paramStr);\n            // strip query part\n            docUri = XmldbURI.create(docUri.getRawCollectionPath());\n        }\n\n        // if docName has no collection specified, assume\n        // current collection\n\n        // Patch 1520454 start\n        if (!docUri.isAbsolute()) {\n            String base = document.getCollection().getURI() + \"/\";\n            String child = \"./\" + docUri.toString();\n\n            URI baseUri = URI.create(base);\n            URI childUri = URI.create(child);\n\n            URI uri = baseUri.resolve(childUri);\n            docUri = XmldbURI.create(uri);\n        }\n        // Patch 1520454 end\n\n        // retrieve the document\n        DocumentImpl doc = null;\n        try {\n            doc = (DocumentImpl) serializer.broker.getXMLResource(docUri);\n            if(doc != null && !doc.getPermissions().validate(serializer.broker.getUser(), Permission.READ))\n                throw new PermissionDeniedException(\"Permission denied to read xincluded resource\");\n        } catch (PermissionDeniedException e) {\n            LOG.warn(\"permission denied\", e);\n            throw new SAXException(e);\n        }\n        /* if document has not been found and xpointer is\n               * null, throw an exception. If xpointer != null\n               * we retry below and interpret docName as\n               * a collection.\n               */\n        if (doc == null && xpointer == null)\n            throw new SAXException(\"document \" + docUri + \" not found\");\n\n        /* Check if the document is a stored XQuery */\n        boolean xqueryDoc = false;\n        if (doc != null && doc.getResourceType() == DocumentImpl.BINARY_FILE) {\n            xqueryDoc = \"application/xquery\".equals(doc.getMetadata().getMimeType());\n        }\n\n        if (xpointer == null && !xqueryDoc)\n            // no xpointer found - just serialize the doc\n            serializer.serializeToReceiver(doc, false);\n        else {\n            // process the xpointer or the stored XQuery\n            try {\n                Source source;\n                if (xpointer == null)\n                    source = new DBSource(serializer.broker, (BinaryDocument) doc, true);\n                else {\n                    xpointer = checkNamespaces(xpointer);\n                    source = new StringSource(xpointer);\n                }\n                XQuery xquery = serializer.broker.getXQueryService();\n                XQueryPool pool = xquery.getXQueryPool();\n                XQueryContext context;\n                CompiledXQuery compiled = pool.borrowCompiledXQuery(serializer.broker, source);\n                if (compiled != null)\n                    context = compiled.getContext();\n                else\n                    context = xquery.newContext(AccessContext.XINCLUDE);\n                context.declareNamespaces(namespaces);\n                context.declareNamespace(\"xinclude\", XINCLUDE_NS);\n                //TODO: change these to putting the XmldbURI in, but we need to warn users!\n                context.declareVariable(\"xinclude:current-doc\", document.getFileURI().toString());\n                context.declareVariable(\"xinclude:current-collection\", document.getCollection().getURI().toString());\n                if (xpointer != null) {\n                    if(doc != null)\n                        context.setStaticallyKnownDocuments(new XmldbURI[] { doc.getURI() } );\n                    else\n                        context.setStaticallyKnownDocuments(new XmldbURI[] { docUri });\n                }\n\n                // pass parameters as variables\n                if (params != null) {\n                    for (Iterator i = params.entrySet().iterator(); i.hasNext(); ) {\n                        Map.Entry entry = (Map.Entry) i.next();\n                        context.declareVariable(entry.getKey().toString(), entry.getValue());\n                    }\n                }\n\n                if(compiled == null) {\n                    try {\n                        compiled = xquery.compile(context, source, xpointer != null);\n                    } catch (IOException e) {\n                        throw new SAXException(\"I/O error while reading query for xinclude: \" + e.getMessage(), e);\n                    }\n                }\n                LOG.info(\"xpointer query: \" + ExpressionDumper.dump((Expression) compiled));\n                Sequence seq = xquery.execute(compiled, null);\n\n                if(Type.subTypeOf(seq.getItemType(), Type.NODE)) {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"xpointer found: \" + seq.getItemCount());\n\n                    NodeValue node;\n                    for (SequenceIterator i = seq.iterate(); i.hasNext();) {\n                        node = (NodeValue) i.nextItem();\n                        serializer.serializeToReceiver(node, false);\n                    }\n                } else {\n                    String val;\n                    for (int i = 0; i < seq.getItemCount(); i++) {\n                        val = seq.itemAt(i).getStringValue();\n                        characters(val);\n                    }\n                }\n\n            } catch (XPathException e) {\n                LOG.warn(\"xpointer error\", e);\n                throw new SAXException(\"Error while processing XInclude expression: \" + e.getMessage(), e);\n            }\n        }\n        // restore settings\n        document = prevDoc;\n        serializer.createContainerElements = createContainerElements;\n    }","id":87561,"modified_method":"protected void processXInclude(String href, String xpointer) throws SAXException, ResourceError {\n        if(href == null)\n            throw new SAXException(\"No href attribute found in XInclude include element\");\n        // save some settings\n        DocumentImpl prevDoc = document;\n        boolean createContainerElements = serializer.createContainerElements;\n        serializer.createContainerElements = false;\n\n        //The following comments are the basis for possible external documents\n        XmldbURI docUri = null;\n        //URI externalUri = null;\n        try {\n            docUri = XmldbURI.xmldbUriFor(href);\n            /*\n               if(!stylesheetUri.toCollectionPathURI().equals(stylesheetUri)) {\n                   externalUri = stylesheetUri.getXmldbURI();\n               }\n               */\n        } catch (URISyntaxException e) {\n            //could be an external URI!\n            /*\n               try {\n                   externalUri = new URI(href);\n               } catch (URISyntaxException ee) {\n               */\n            throw new IllegalArgumentException(\"Stylesheet URI could not be parsed: \"+e.getMessage());\n            //}\n        }\n\n        // parse the href attribute\n        LOG.debug(\"found href=\\\"\" + href + \"\\\"\");\n        //String xpointer = null;\n        //String docName = href;\n        String fragment = docUri.getFragment();\n        if (!(fragment == null || fragment.length() == 0))\n            throw new SAXException(\"Fragment identifiers must not be used in an xinclude href attribute. To specify an \" +\n                    \"xpointer, use the xpointer attribute.\");\n\n//        if(xpointer!=null) {\n//            try {\n//                xpointer = XMLUtil.decodeAttrMarkup(URLDecoder.decode(xpointer, \"UTF-8\"));\n//            } catch (UnsupportedEncodingException e) {\n//            \tLOG.warn(e);\n//            }\n//            // remove the fragment part from the URI for further processing\n//            URI u = docUri.getURI();\n//            try {\n//                u = new URI(u.getScheme(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), null);\n//                docUri = XmldbURI.xmldbUriFor(u);\n//            } catch (URISyntaxException e) {\n//                throw new IllegalArgumentException(\"Stylesheet URI could not be parsed: \" + e.getMessage());\n//            }\n//        }\n\n        // extract possible parameters in the URI\n        Map params = null;\n        String paramStr = docUri.getQuery();\n        if (paramStr != null) {\n            params = processParameters(paramStr);\n            // strip query part\n            docUri = XmldbURI.create(docUri.getRawCollectionPath());\n        }\n\n        // if docName has no collection specified, assume\n        // current collection\n\n        // Patch 1520454 start\n        if (!docUri.isAbsolute()) {\n            String base = document.getCollection().getURI() + \"/\";\n            String child = \"./\" + docUri.toString();\n\n            URI baseUri = URI.create(base);\n            URI childUri = URI.create(child);\n\n            URI uri = baseUri.resolve(childUri);\n            docUri = XmldbURI.create(uri);\n        }\n        // Patch 1520454 end\n\n        // retrieve the document\n        DocumentImpl doc = null;\n        try {\n            doc = (DocumentImpl) serializer.broker.getXMLResource(docUri);\n            if(doc != null && !doc.getPermissions().validate(serializer.broker.getUser(), Permission.READ))\n                throw new ResourceError(\"Permission denied to read xincluded resource\");\n        } catch (PermissionDeniedException e) {\n            LOG.warn(\"permission denied\", e);\n            throw new ResourceError(\"Permission denied to read xincluded resource\", e);\n        }\n        /* if document has not been found and xpointer is\n               * null, throw an exception. If xpointer != null\n               * we retry below and interpret docName as\n               * a collection.\n               */\n        if (doc == null && xpointer == null)\n            throw new ResourceError(\"document \" + docUri + \" not found\");\n\n        /* Check if the document is a stored XQuery */\n        boolean xqueryDoc = false;\n        if (doc != null && doc.getResourceType() == DocumentImpl.BINARY_FILE) {\n            xqueryDoc = \"application/xquery\".equals(doc.getMetadata().getMimeType());\n        }\n\n        if (xpointer == null && !xqueryDoc)\n            // no xpointer found - just serialize the doc\n            serializer.serializeToReceiver(doc, false);\n        else {\n            // process the xpointer or the stored XQuery\n            try {\n                Source source;\n                if (xpointer == null)\n                    source = new DBSource(serializer.broker, (BinaryDocument) doc, true);\n                else {\n                    xpointer = checkNamespaces(xpointer);\n                    source = new StringSource(xpointer);\n                }\n                XQuery xquery = serializer.broker.getXQueryService();\n                XQueryPool pool = xquery.getXQueryPool();\n                XQueryContext context;\n                CompiledXQuery compiled = pool.borrowCompiledXQuery(serializer.broker, source);\n                if (compiled != null)\n                    context = compiled.getContext();\n                else\n                    context = xquery.newContext(AccessContext.XINCLUDE);\n                context.declareNamespaces(namespaces);\n                context.declareNamespace(\"xinclude\", XINCLUDE_NS);\n                //TODO: change these to putting the XmldbURI in, but we need to warn users!\n                context.declareVariable(\"xinclude:current-doc\", document.getFileURI().toString());\n                context.declareVariable(\"xinclude:current-collection\", document.getCollection().getURI().toString());\n                if (xpointer != null) {\n                    if(doc != null)\n                        context.setStaticallyKnownDocuments(new XmldbURI[] { doc.getURI() } );\n                    else\n                        context.setStaticallyKnownDocuments(new XmldbURI[] { docUri });\n                }\n\n                // pass parameters as variables\n                if (params != null) {\n                    for (Iterator i = params.entrySet().iterator(); i.hasNext(); ) {\n                        Map.Entry entry = (Map.Entry) i.next();\n                        context.declareVariable(entry.getKey().toString(), entry.getValue());\n                    }\n                }\n\n                if(compiled == null) {\n                    try {\n                        compiled = xquery.compile(context, source, xpointer != null);\n                    } catch (IOException e) {\n                        throw new SAXException(\"I/O error while reading query for xinclude: \" + e.getMessage(), e);\n                    }\n                }\n                LOG.info(\"xpointer query: \" + ExpressionDumper.dump((Expression) compiled));\n                Sequence seq = xquery.execute(compiled, null);\n\n                if(Type.subTypeOf(seq.getItemType(), Type.NODE)) {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"xpointer found: \" + seq.getItemCount());\n\n                    NodeValue node;\n                    for (SequenceIterator i = seq.iterate(); i.hasNext();) {\n                        node = (NodeValue) i.nextItem();\n                        serializer.serializeToReceiver(node, false);\n                    }\n                } else {\n                    String val;\n                    for (int i = 0; i < seq.getItemCount(); i++) {\n                        val = seq.itemAt(i).getStringValue();\n                        characters(val);\n                    }\n                }\n\n            } catch (XPathException e) {\n                LOG.warn(\"xpointer error\", e);\n                throw new SAXException(\"Error while processing XInclude expression: \" + e.getMessage(), e);\n            }\n        }\n        // restore settings\n        document = prevDoc;\n        serializer.createContainerElements = createContainerElements;\n    }","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"public void startElement(QName qname, AttrList attribs) throws SAXException {\n\t\tif (qname.getNamespaceURI() != null && qname.getNamespaceURI().equals(XINCLUDE_NS)) {\n\t\t\tif (qname.getLocalName().equals(\"include\")) {\n\t\t\t\tLOG.debug(\"processing include ...\");\n\t\t\t\tprocessXInclude(attribs.getValue(HREF_ATTRIB), attribs.getValue(XPOINTER_ATTRIB));\n\t\t\t}\n\t\t} else {\n\t\t\t//LOG.debug(\"start: \" + qName);\n\t\t\treceiver.startElement(qname, attribs);\n\t\t}\n\t}","id":87562,"modified_method":"public void startElement(QName qname, AttrList attribs) throws SAXException {\n\t\tif (qname.getNamespaceURI() != null && qname.getNamespaceURI().equals(XINCLUDE_NS)) {\n\t\t\tif (qname.getLocalName().equals(XI_INCLUDE)) {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"processing include ...\");\n                try {\n                    processXInclude(attribs.getValue(HREF_ATTRIB), attribs.getValue(XPOINTER_ATTRIB));\n                } catch (ResourceError resourceError) {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(resourceError.getMessage(), resourceError);\n                    error = resourceError;\n                }\n            } else if (qname.getLocalName().equals(XI_FALLBACK)) {\n                inFallback = true;\n            }\n        } else if (!inFallback || error != null) {\n\t\t\t//LOG.debug(\"start: \" + qName);\n\t\t\treceiver.startElement(qname, attribs);\n\t\t}\n\t}","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * @see org.exist.util.serializer.Receiver#cdataSection(char[], int, int)\n     */\n    public void cdataSection(char[] ch, int start, int len) throws SAXException {\n        receiver.cdataSection(ch, start, len);\n    }","id":87563,"modified_method":"/**\n     * @see org.exist.util.serializer.Receiver#cdataSection(char[], int, int)\n     */\n    public void cdataSection(char[] ch, int start, int len) throws SAXException {\n        if (!inFallback || error != null)\n            receiver.cdataSection(ch, start, len);\n    }","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"public void setDocument(DocumentImpl doc) {\n\t\tdocument = doc;\n\t}","id":87564,"modified_method":"public void setDocument(DocumentImpl doc) {\n\t\tdocument = doc;\n        inFallback = false;\n        error = null;\n    }","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * @see org.xml.sax.ContentHandler#processingInstruction(java.lang.String, java.lang.String)\n\t */\n\tpublic void processingInstruction(String target, String data) throws SAXException {\n\t\treceiver.processingInstruction(target, data);\n\t}","id":87565,"modified_method":"/**\n\t * @see org.xml.sax.ContentHandler#processingInstruction(java.lang.String, java.lang.String)\n\t */\n\tpublic void processingInstruction(String target, String data) throws SAXException {\n        if (!inFallback || error != null)\n            receiver.processingInstruction(target, data);\n\t}","commit_id":"168e6a129432ced444918ad7635add05f48c3315","url":"https://github.com/eXist-db/exist"},{"original_method":"public long openChangeSet(String comment) {\n\t\tlong id = -1;\n\t\tStringWriter writer = new StringWriter(256);\n\t\tXmlSerializer ser = Xml.newSerializer();\n\t\ttry {\n\t\t\tser.setOutput(writer);\n\t\t\tser.startDocument(\"UTF-8\", true); //$NON-NLS-1$\n\t\t\tser.startTag(null, \"osm\"); //$NON-NLS-1$\n\t\t\tser.startTag(null, \"changeset\"); //$NON-NLS-1$\n\n\t\t\tser.startTag(null, \"tag\"); //$NON-NLS-1$\n\t\t\tser.attribute(null, \"k\", \"comment\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tser.attribute(null, \"v\", comment); //$NON-NLS-1$\n\t\t\tser.endTag(null, \"tag\"); //$NON-NLS-1$\n\n\t\t\tser.startTag(null, \"tag\"); //$NON-NLS-1$\n\t\t\tser.attribute(null, \"k\", \"created_by\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tser.attribute(null, \"v\", Version.getFullVersion(ctx)); //$NON-NLS-1$\n\t\t\tser.endTag(null, \"tag\"); //$NON-NLS-1$\n\t\t\tser.endTag(null, \"changeset\"); //$NON-NLS-1$\n\t\t\tser.endTag(null, \"osm\"); //$NON-NLS-1$\n\t\t\tser.endDocument();\n\t\t\twriter.close();\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Unhandled exception\", e); //$NON-NLS-1$\n\t\t}\n\t\tString response = sendRequest(\n\t\t\t\tgetSiteApi() + \"api/0.6/changeset/create/\", \"PUT\", writer.getBuffer().toString(), ctx.getString(R.string.opening_changeset), true); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tif (response != null && response.length() > 0) {\n\t\t\tid = Long.parseLong(response);\n\t\t}\n\n\t\treturn id;\n\t}","id":87566,"modified_method":"public long openChangeSet(String comment) {\n\t\tlong id = -1;\n\t\tStringWriter writer = new StringWriter(256);\n\t\tXmlSerializer ser = Xml.newSerializer();\n\t\ttry {\n\t\t\tser.setOutput(writer);\n\t\t\tser.startDocument(\"UTF-8\", true); //$NON-NLS-1$\n\t\t\tser.startTag(null, \"osm\"); //$NON-NLS-1$\n\t\t\tser.startTag(null, \"changeset\"); //$NON-NLS-1$\n\n\t\t\tif(comment != null) {\n\t\t\t\tser.startTag(null, \"tag\"); //$NON-NLS-1$\n\t\t\t\tser.attribute(null, \"k\", \"comment\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\tser.attribute(null, \"v\", comment); //$NON-NLS-1$\n\t\t\t\tser.endTag(null, \"tag\"); //$NON-NLS-1$\n\t\t\t}\n\n\t\t\tser.startTag(null, \"tag\"); //$NON-NLS-1$\n\t\t\tser.attribute(null, \"k\", \"created_by\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tser.attribute(null, \"v\", Version.getFullVersion(ctx)); //$NON-NLS-1$\n\t\t\tser.endTag(null, \"tag\"); //$NON-NLS-1$\n\t\t\tser.endTag(null, \"changeset\"); //$NON-NLS-1$\n\t\t\tser.endTag(null, \"osm\"); //$NON-NLS-1$\n\t\t\tser.endDocument();\n\t\t\twriter.close();\n\t\t} catch (IOException e) {\n\t\t\tlog.error(\"Unhandled exception\", e); //$NON-NLS-1$\n\t\t}\n\t\tString response = sendRequest(\n\t\t\t\tgetSiteApi() + \"api/0.6/changeset/create/\", \"PUT\", writer.getBuffer().toString(), ctx.getString(R.string.opening_changeset), true); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tif (response != null && response.length() > 0) {\n\t\t\tid = Long.parseLong(response);\n\t\t}\n\n\t\treturn id;\n\t}","commit_id":"9816a5daf008094d54391d827bfd978ce33c3d9c","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n     * Should we enable the next button of the wizard?\n     * @return true if a proper image has been selected, false otherwise\n     */\n    public boolean validatePanel() {\n        String path = getContentPaths();\n        if (path == null || path.isEmpty()) {\n            return false;\n        }\n        \n        boolean isExist = Case.pathExists(path);\n        boolean isPhysicalDrive = Case.isPhysicalDrive(path);\n        boolean isPartition = Case.isPartition(path);\n               \n        if (!isImagePathValid(path)) {\n            return false;\n        }\n        \n        return (isExist || isPhysicalDrive || isPartition);\n    }","id":87567,"modified_method":"/**\n     * Should we enable the next button of the wizard?\n     * @return true if a proper image has been selected, false otherwise\n     */\n    public boolean validatePanel() {\n        errorLabel.setVisible(false);\n        String path = getContentPaths();\n        if (path == null || path.isEmpty()) {\n            return false;\n        }\n        \n        // display warning if there is one (but don't disable \"next\" button)\n        isImagePathValid(path);\n        \n        boolean isExist = Case.pathExists(path);\n        boolean isPhysicalDrive = Case.isPhysicalDrive(path);\n        boolean isPartition = Case.isPartition(path);\n        \n        return (isExist || isPhysicalDrive || isPartition);\n    }","commit_id":"3d99f685c1bd5b6fe45b88a77268a4bbd983fee8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Validates path to selected data source. \n     * @param path Absolute path to the selected data source\n     * @return true if path is valid, false otherwise.\n     */\n    private boolean isImagePathValid(String path){        \n        errorLabel.setVisible(false);                \n        if (!MultiUserPathValidator.isValid(path, Case.getCurrentCase().getCaseType())) {\n            errorLabel.setVisible(true);\n            errorLabel.setText(NbBundle.getMessage(this.getClass(), \"DataSourceOnCDriveError.text\"));\n            return false;\n        }\n        return true;\n    }","id":87568,"modified_method":"/**\n     * Validates path to selected data source. \n     * @param path Absolute path to the selected data source\n     * @return true if path is valid, false otherwise.\n     */\n    private boolean isImagePathValid(String path){                      \n        if (!MultiUserPathValidator.isValid(path, Case.getCurrentCase().getCaseType())) {\n            errorLabel.setVisible(true);\n            errorLabel.setText(NbBundle.getMessage(this.getClass(), \"DataSourceOnCDriveError.text\"));\n            return false;\n        }\n        return true;\n    }","commit_id":"3d99f685c1bd5b6fe45b88a77268a4bbd983fee8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Should we enable the wizard's next button?\n     * Always return true because we control the possible selections.\n     *\n     * @return true\n     */\n    //@Override\n    public boolean validatePanel() {\n        \n        if (!isImagePathValid(getContentPaths())) {\n            return false;\n        }\n        \n        return enableNext;\n    }","id":87569,"modified_method":"/**\n     * Should we enable the wizard's next button?\n     * Always return true because we control the possible selections.\n     *\n     * @return true\n     */\n    //@Override\n    public boolean validatePanel() {\n        \n        // display warning if there is one (but don't disable \"next\" button)\n        isImagePathValid(getContentPaths());        \n        \n        return enableNext;\n    }","commit_id":"3d99f685c1bd5b6fe45b88a77268a4bbd983fee8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public boolean validatePanel() {\n        \n        if (!isImagePathValid(getContentPaths())) {\n            return false;\n        }\n        \n        return enableNext;\n    }","id":87570,"modified_method":"public boolean validatePanel() {\n        \n        // display warning if there is one (but don't disable \"next\" button)\n        isImagePathValid(getContentPaths());        \n        \n        return enableNext;\n    }","commit_id":"3d99f685c1bd5b6fe45b88a77268a4bbd983fee8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * The \"listener\" that listens when the fields in this form are updated.\n     * This method is used to determine when to enable / disable the \"Finish\"\n     * button.\n     *\n     * @param e the document event\n     */\n    public void updateUI(DocumentEvent e) {\n        \n        // Note: DocumentEvent e can be null when called from rbSingleUserCaseActionPerformed()\n        // and rbMultiUserCaseActionPerformed().\n\n        String caseName = getCaseName();\n        String parentDir = getCaseParentDir();\n        \n        if (!caseName.equals(\"\") && !parentDir.equals(\"\")) {\n            caseDirTextField.setText(parentDir + caseName);\n            wizPanel.setIsFinish(true);\n        } else {\n            caseDirTextField.setText(\"\");\n            wizPanel.setIsFinish(false);\n        }\n        \n        if (!isImagePathValid(parentDir)) {\n            wizPanel.setIsFinish(false);\n        }                \n    }","id":87571,"modified_method":"/**\n     * The \"listener\" that listens when the fields in this form are updated.\n     * This method is used to determine when to enable / disable the \"Finish\"\n     * button.\n     *\n     * @param e the document event\n     */\n    public void updateUI(DocumentEvent e) {\n        \n        // Note: DocumentEvent e can be null when called from rbSingleUserCaseActionPerformed()\n        // and rbMultiUserCaseActionPerformed().\n\n        String caseName = getCaseName();\n        String parentDir = getCaseParentDir();\n        \n        if (!caseName.equals(\"\") && !parentDir.equals(\"\")) {\n            caseDirTextField.setText(parentDir + caseName);\n            wizPanel.setIsFinish(true);\n        } else {\n            caseDirTextField.setText(\"\");\n            wizPanel.setIsFinish(false);\n        }\n        \n        // display warning if there is one (but don't disable \"next\" button)\n        isImagePathValid(parentDir);              \n    }","commit_id":"3d99f685c1bd5b6fe45b88a77268a4bbd983fee8","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static void mappingScript_CodeBlock_1238589718396(final IOperationContext operationContext, final MappingScriptContext _context) {\n    Language language = Language.getLanguageFor(_context.getOriginalInputModel().getModelDescriptor());\n    if (language == null) {\n      return;\n    }\n    SModel structureModel = language.getStructureModelDescriptor().getSModel();\n    Map<SNode, SNode> conceptsToTargets = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    Map<SNode, SNode> additionalConceptsToTargets = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    Map<SNode, SNode> partsToLinkDeclarations = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    SNode conceptContainer = ListSequence.fromList(SModelOperations.getRoots(_context.getModel(), \"jetbrains.mpslite.structure.ConceptContainer\")).first();\n    List<SNode> allConcepts = ConceptContainer_Behavior.call_getAllConcepts_1239801518275(conceptContainer);\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode concept = SConceptOperations.createNewNode(\"jetbrains.mps.lang.structure.structure.ConceptDeclaration\", null);\n      SPropertyOperations.set(concept, \"name\", SPropertyOperations.getString(conceptDeclaration, \"name\"));\n      SPropertyOperations.set(concept, \"rootable\", \"\" + IMPSLiteConcept_Behavior.call_isRootable_1239714833738(conceptDeclaration));\n      if (IMPSLiteConcept_Behavior.call_isAbstract_1239715026284(conceptDeclaration)) {\n        SNode booleanConceptProperty = SLinkOperations.addNewChild(concept, \"conceptProperty\", \"jetbrains.mps.lang.structure.structure.BooleanConceptProperty\");\n        SNode conceptProperty_Abstract = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.BaseConcept\"), \"conceptPropertyDeclaration\", true)).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return \"abstract\".equals(SPropertyOperations.getString(it, \"name\"));\n          }\n        }).first(), \"jetbrains.mps.lang.structure.structure.BooleanConceptPropertyDeclaration\");\n        SLinkOperations.setTarget(booleanConceptProperty, \"conceptPropertyDeclaration\", conceptProperty_Abstract, false);\n      }\n      MapSequence.fromMap(conceptsToTargets).put(conceptDeclaration, concept);\n    }\n    // additional concepts \n    for (SNode conceptDeclaration : allConcepts) {\n      SNode concept = IMPSLiteConcept_Behavior.call_createAdditionalConcept_1239817368042(conceptDeclaration, conceptsToTargets, partsToLinkDeclarations);\n      if (concept != null) {\n        MapSequence.fromMap(additionalConceptsToTargets).put(conceptDeclaration, concept);\n      }\n    }\n    // extends \n    for (SNode conceptDeclaration : allConcepts) {\n      SLinkOperations.setTarget(((SNode) MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration)), \"extends\", ((SNode) AbstractConceptReference_Behavior.call_getConcept_1238594571574(SLinkOperations.getTarget(conceptDeclaration, \"extends\", true), conceptsToTargets)), false);\n    }\n    // inner concept structure \n    for (SNode conceptDeclaration : allConcepts) {\n      IMPSLiteConcept_Behavior.call_fillConcept_1239891562930(conceptDeclaration, ((SNode) MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration)), conceptsToTargets, partsToLinkDeclarations);\n    }\n    // editor \n    SModel editorModel = language.getEditorModelDescriptor().getSModel();\n    SModel actionsModel = language.getActionsModelDescriptor().getSModel();\n    Map<SNode, SNode> conceptsToEditors = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode editor = IMPSLiteConcept_Behavior.call_createEditor_1239890004879(conceptDeclaration, conceptsToTargets, partsToLinkDeclarations);\n      if (editor == null) {\n        continue;\n      }\n      SNode mpsConcept = MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration);\n      SLinkOperations.setTarget(editor, \"conceptDeclaration\", mpsConcept, false);\n      MapSequence.fromMap(conceptsToEditors).put(mpsConcept, editor);\n    }\n    for (SNode additionalConcept : MapSequence.fromMap(additionalConceptsToTargets).keySet()) {\n      SNode editor = IMPSLiteConcept_Behavior.call_createAdditionalEditor_1239891670850(additionalConcept, conceptsToTargets, partsToLinkDeclarations);\n      if (editor == null) {\n        continue;\n      }\n      SNode mpsConcept = MapSequence.fromMap(additionalConceptsToTargets).get(additionalConcept);\n      SLinkOperations.setTarget(editor, \"conceptDeclaration\", mpsConcept, false);\n      MapSequence.fromMap(conceptsToEditors).put(mpsConcept, editor);\n    }\n    SNode actions = SConceptOperations.createNewNode(\"jetbrains.mps.lang.actions.structure.SideTransformHintSubstituteActions\", null);\n    SPropertyOperations.set(actions, \"name\", \"_BinaryOperations_SideTransform\");\n    for (SNode binaryOperationConcept : ConceptContainer_Behavior.call_getBinaryOperationConcepts_1239806149720(conceptContainer)) {\n      GenerationUtils.fillBinarySideTransformActions(binaryOperationConcept, actions, conceptsToTargets, partsToLinkDeclarations);\n    }\n    // constraints(scopes) \n    Map<SNode, SNode> conceptsToConstraints = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    for (SNode variableConcept : ConceptContainer_Behavior.call_getVariableConcepts_1239806150736(conceptContainer)) {\n      SNode conceptConstraint = SConceptOperations.createNewNode(\"jetbrains.mps.lang.constraints.structure.ConceptConstraints\", null);\n      SLinkOperations.setTarget(conceptConstraint, \"concept\", MapSequence.fromMap(additionalConceptsToTargets).get(variableConcept), false);\n      SNode varScope = VariableConcept_Behavior.call_createVariableScope_1239942296621(variableConcept, conceptsToTargets, partsToLinkDeclarations);\n      SLinkOperations.addChild(conceptConstraint, \"referent\", varScope);\n      MapSequence.fromMap(conceptsToConstraints).put(variableConcept, conceptConstraint);\n    }\n    SModel constraintsModel = language.getConstraintsModelDescriptor().getSModel();\n    // \n    // setting roots and deleting input roots \n    structureModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(structureModel, null))) {\n      structureModel.removeRoot(root);\n    }\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode concept = MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration);\n      SModelOperations.addRootNode(structureModel, concept);\n    }\n    for (SNode conceptDeclaration : MapSequence.fromMap(additionalConceptsToTargets).keySet()) {\n      SNode concept = MapSequence.fromMap(additionalConceptsToTargets).get(conceptDeclaration);\n      SModelOperations.addRootNode(structureModel, concept);\n    }\n    structureModel.setLoading(false);\n    editorModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(editorModel, null))) {\n      editorModel.removeRoot(root);\n    }\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode editorDeclaration = MapSequence.fromMap(conceptsToEditors).get(MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration));\n      SModelOperations.addRootNode(editorModel, editorDeclaration);\n    }\n    for (SNode conceptDeclaration : MapSequence.fromMap(additionalConceptsToTargets).keySet()) {\n      SNode editorDeclaration = MapSequence.fromMap(conceptsToEditors).get(MapSequence.fromMap(additionalConceptsToTargets).get(conceptDeclaration));\n      SModelOperations.addRootNode(editorModel, editorDeclaration);\n    }\n    editorModel.setLoading(false);\n    actionsModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(actionsModel, null))) {\n      actionsModel.removeRoot(root);\n    }\n    SModelOperations.addRootNode(actionsModel, actions);\n    actionsModel.setLoading(false);\n    constraintsModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(constraintsModel, null))) {\n      constraintsModel.removeRoot(root);\n    }\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode conceptConstraints = MapSequence.fromMap(conceptsToConstraints).get(conceptDeclaration);\n      SModelOperations.addRootNode(constraintsModel, conceptConstraints);\n    }\n    constraintsModel.setLoading(false);\n    SModelRepository.getInstance().markChanged(structureModel);\n    SModelRepository.getInstance().markChanged(editorModel);\n    SModelRepository.getInstance().markChanged(actionsModel);\n    SModelRepository.getInstance().markChanged(constraintsModel);\n    SNodeOperations.deleteNode(conceptContainer);\n  }","id":87572,"modified_method":"public static void mappingScript_CodeBlock_1238589718396(final IOperationContext operationContext, final MappingScriptContext _context) {\n    Language language = Language.getLanguageFor(_context.getOriginalInputModel().getModelDescriptor());\n    if (language == null) {\n      return;\n    }\n    SModel structureModel = language.getStructureModelDescriptor().getSModel();\n    Map<SNode, SNode> conceptsToTargets = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    Map<SNode, SNode> additionalConceptsToTargets = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    Map<SNode, SNode> partsToLinkDeclarations = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    SNode conceptContainer = ListSequence.fromList(SModelOperations.getRoots(_context.getModel(), \"jetbrains.mpslite.structure.ConceptContainer\")).first();\n    List<SNode> allConcepts = ConceptContainer_Behavior.call_getAllConcepts_1239801518275(conceptContainer);\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode concept = SConceptOperations.createNewNode(\"jetbrains.mps.lang.structure.structure.ConceptDeclaration\", null);\n      SPropertyOperations.set(concept, \"name\", SPropertyOperations.getString(conceptDeclaration, \"name\"));\n      SPropertyOperations.set(concept, \"rootable\", \"\" + IMPSLiteConcept_Behavior.call_isRootable_1239714833738(conceptDeclaration));\n      if (IMPSLiteConcept_Behavior.call_isAbstract_1239715026284(conceptDeclaration)) {\n        SNode booleanConceptProperty = SLinkOperations.addNewChild(concept, \"conceptProperty\", \"jetbrains.mps.lang.structure.structure.BooleanConceptProperty\");\n        SNode conceptProperty_Abstract = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getTargets(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.lang.core.structure.BaseConcept\"), \"conceptPropertyDeclaration\", true)).where(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return \"abstract\".equals(SPropertyOperations.getString(it, \"name\"));\n          }\n        }).first(), \"jetbrains.mps.lang.structure.structure.BooleanConceptPropertyDeclaration\");\n        SLinkOperations.setTarget(booleanConceptProperty, \"conceptPropertyDeclaration\", conceptProperty_Abstract, false);\n      }\n      MapSequence.fromMap(conceptsToTargets).put(conceptDeclaration, concept);\n    }\n    // additional concepts \n    for (SNode conceptDeclaration : allConcepts) {\n      SNode concept = IMPSLiteConcept_Behavior.call_createAdditionalConcept_1239817368042(conceptDeclaration, conceptsToTargets, partsToLinkDeclarations);\n      if (concept != null) {\n        MapSequence.fromMap(additionalConceptsToTargets).put(conceptDeclaration, concept);\n      }\n    }\n    // extends \n    for (SNode conceptDeclaration : allConcepts) {\n      SLinkOperations.setTarget(((SNode) MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration)), \"extends\", ((SNode) AbstractConceptReference_Behavior.call_getConcept_1238594571574(SLinkOperations.getTarget(conceptDeclaration, \"extends\", true), conceptsToTargets)), false);\n    }\n    // inner concept structure \n    for (SNode conceptDeclaration : allConcepts) {\n      IMPSLiteConcept_Behavior.call_fillConcept_1239891562930(conceptDeclaration, ((SNode) MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration)), conceptsToTargets, partsToLinkDeclarations);\n    }\n    // editor \n    SModel editorModel = language.getEditorModelDescriptor().getSModel();\n    SModel actionsModel = language.getActionsModelDescriptor().getSModel();\n    Map<SNode, SNode> conceptsToEditors = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode editor = IMPSLiteConcept_Behavior.call_createEditor_1239890004879(conceptDeclaration, conceptsToTargets, partsToLinkDeclarations);\n      if (editor == null) {\n        continue;\n      }\n      SNode mpsConcept = MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration);\n      SLinkOperations.setTarget(editor, \"conceptDeclaration\", mpsConcept, false);\n      MapSequence.fromMap(conceptsToEditors).put(mpsConcept, editor);\n    }\n    for (SNode additionalConcept : MapSequence.fromMap(additionalConceptsToTargets).keySet()) {\n      SNode editor = IMPSLiteConcept_Behavior.call_createAdditionalEditor_1239891670850(additionalConcept, conceptsToTargets, partsToLinkDeclarations);\n      if (editor == null) {\n        continue;\n      }\n      SNode mpsConcept = MapSequence.fromMap(additionalConceptsToTargets).get(additionalConcept);\n      SLinkOperations.setTarget(editor, \"conceptDeclaration\", mpsConcept, false);\n      MapSequence.fromMap(conceptsToEditors).put(mpsConcept, editor);\n    }\n    SNode actions = SConceptOperations.createNewNode(\"jetbrains.mps.lang.actions.structure.SideTransformHintSubstituteActions\", null);\n    SPropertyOperations.set(actions, \"name\", \"_BinaryOperations_SideTransform\");\n    for (SNode binaryOperationConcept : ConceptContainer_Behavior.call_getBinaryOperationConcepts_1239806149720(conceptContainer)) {\n      GenerationUtils.fillBinarySideTransformActions(binaryOperationConcept, actions, conceptsToTargets, partsToLinkDeclarations);\n    }\n    // constraints(scopes) \n    Map<SNode, SNode> conceptsToConstraints = MapSequence.fromMap(new HashMap<SNode, SNode>());\n    for (SNode variableConcept : ConceptContainer_Behavior.call_getVariableConcepts_1239806150736(conceptContainer)) {\n      SNode conceptConstraint = SConceptOperations.createNewNode(\"jetbrains.mps.lang.constraints.structure.ConceptConstraints\", null);\n      SLinkOperations.setTarget(conceptConstraint, \"concept\", MapSequence.fromMap(additionalConceptsToTargets).get(variableConcept), false);\n      SNode varScope = VariableConcept_Behavior.call_createVariableScope_1239942296621(variableConcept, conceptsToTargets, partsToLinkDeclarations);\n      ListSequence.fromList(SLinkOperations.getTargets(conceptConstraint, \"referent\", true)).addElement(varScope);\n      MapSequence.fromMap(conceptsToConstraints).put(variableConcept, conceptConstraint);\n    }\n    SModel constraintsModel = language.getConstraintsModelDescriptor().getSModel();\n    // \n    // setting roots and deleting input roots \n    structureModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(structureModel, null))) {\n      structureModel.removeRoot(root);\n    }\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode concept = MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration);\n      SModelOperations.addRootNode(structureModel, concept);\n    }\n    for (SNode conceptDeclaration : MapSequence.fromMap(additionalConceptsToTargets).keySet()) {\n      SNode concept = MapSequence.fromMap(additionalConceptsToTargets).get(conceptDeclaration);\n      SModelOperations.addRootNode(structureModel, concept);\n    }\n    structureModel.setLoading(false);\n    editorModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(editorModel, null))) {\n      editorModel.removeRoot(root);\n    }\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode editorDeclaration = MapSequence.fromMap(conceptsToEditors).get(MapSequence.fromMap(conceptsToTargets).get(conceptDeclaration));\n      SModelOperations.addRootNode(editorModel, editorDeclaration);\n    }\n    for (SNode conceptDeclaration : MapSequence.fromMap(additionalConceptsToTargets).keySet()) {\n      SNode editorDeclaration = MapSequence.fromMap(conceptsToEditors).get(MapSequence.fromMap(additionalConceptsToTargets).get(conceptDeclaration));\n      SModelOperations.addRootNode(editorModel, editorDeclaration);\n    }\n    editorModel.setLoading(false);\n    actionsModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(actionsModel, null))) {\n      actionsModel.removeRoot(root);\n    }\n    SModelOperations.addRootNode(actionsModel, actions);\n    actionsModel.setLoading(false);\n    constraintsModel.setLoading(true);\n    for (SNode root : ListSequence.fromListWithValues(new ArrayList<SNode>(), SModelOperations.getRoots(constraintsModel, null))) {\n      constraintsModel.removeRoot(root);\n    }\n    for (SNode conceptDeclaration : allConcepts) {\n      SNode conceptConstraints = MapSequence.fromMap(conceptsToConstraints).get(conceptDeclaration);\n      SModelOperations.addRootNode(constraintsModel, conceptConstraints);\n    }\n    constraintsModel.setLoading(false);\n    SModelRepository.getInstance().markChanged(structureModel);\n    SModelRepository.getInstance().markChanged(editorModel);\n    SModelRepository.getInstance().markChanged(actionsModel);\n    SModelRepository.getInstance().markChanged(constraintsModel);\n    SNodeOperations.deleteNode(conceptContainer);\n  }","commit_id":"2fef5697bcb6de31fe04371f50dbd823314c82ec","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void nodeFactory_NodeSetup_ContentList_1178622500723(final IOperationContext operationContext, final NodeSetupContext _context) {\n    if (SNodeOperations.isInstanceOf(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\")) {\n      SLinkOperations.addChild(_context.getNewNode(), \"content\", SNodeOperations.cast(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\"));\n    }\n  }","id":87573,"modified_method":"public static void nodeFactory_NodeSetup_ContentList_1178622500723(final IOperationContext operationContext, final NodeSetupContext _context) {\n    if (SNodeOperations.isInstanceOf(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(_context.getNewNode(), \"content\", true)).addElement(SNodeOperations.cast(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\"));\n    }\n  }","commit_id":"2fef5697bcb6de31fe04371f50dbd823314c82ec","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void nodeFactory_NodeSetup_Element_1188911043247(final IOperationContext operationContext, final NodeSetupContext _context) {\n    if (SNodeOperations.isInstanceOf(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\")) {\n      SLinkOperations.addChild(SLinkOperations.getTarget(_context.getNewNode(), \"contentList\", true), \"content\", SNodeOperations.cast(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\"));\n    }\n  }","id":87574,"modified_method":"public static void nodeFactory_NodeSetup_Element_1188911043247(final IOperationContext operationContext, final NodeSetupContext _context) {\n    if (SNodeOperations.isInstanceOf(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(_context.getNewNode(), \"contentList\", true), \"content\", true)).addElement(SNodeOperations.cast(_context.getSampleNode(), \"jetbrains.mps.xml.structure.Content\"));\n    }\n  }","commit_id":"2fef5697bcb6de31fe04371f50dbd823314c82ec","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void nodeFactory_NodeSetup_ComplexText_1178622222481(final IOperationContext operationContext, final NodeSetupContext _context) {\n    if (SNodeOperations.isInstanceOf(_context.getSampleNode(), \"jetbrains.mps.xml.structure.BaseText\")) {\n      SLinkOperations.addChild(_context.getNewNode(), \"text\", SNodeOperations.cast(_context.getSampleNode(), \"jetbrains.mps.xml.structure.BaseText\"));\n    }\n  }","id":87575,"modified_method":"public static void nodeFactory_NodeSetup_ComplexText_1178622222481(final IOperationContext operationContext, final NodeSetupContext _context) {\n    if (SNodeOperations.isInstanceOf(_context.getSampleNode(), \"jetbrains.mps.xml.structure.BaseText\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(_context.getNewNode(), \"text\", true)).addElement(SNodeOperations.cast(_context.getSampleNode(), \"jetbrains.mps.xml.structure.BaseText\"));\n    }\n  }","commit_id":"2fef5697bcb6de31fe04371f50dbd823314c82ec","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode contentList = SConceptOperations.createNewNode(\"jetbrains.mps.xml.structure.ContentList\", null);\n    List<SNode> selectedNodes = editorContext.getNodeEditorComponent().getNodeRangeSelection().getNodes();\n    if (ListSequence.fromList(selectedNodes).isEmpty()) {\n      ListSequence.fromList(selectedNodes).addElement(editorContext.getSelectedNode());\n    }\n    SNode first = ListSequence.fromList(selectedNodes).getElement(0);\n    SNodeOperations.insertPrevSiblingChild(first, contentList);\n    for (SNode selectedNode : ListSequence.fromList(selectedNodes)) {\n      SLinkOperations.addChild(contentList, \"content\", SNodeOperations.cast(selectedNode, \"jetbrains.mps.xml.structure.Content\"));\n    }\n    SLinkOperations.addNewChild(contentList, \"content\", \"jetbrains.mps.xml.structure.Content\");\n  }","id":87576,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode contentList = SConceptOperations.createNewNode(\"jetbrains.mps.xml.structure.ContentList\", null);\n    List<SNode> selectedNodes = editorContext.getNodeEditorComponent().getNodeRangeSelection().getNodes();\n    if (ListSequence.fromList(selectedNodes).isEmpty()) {\n      ListSequence.fromList(selectedNodes).addElement(editorContext.getSelectedNode());\n    }\n    SNode first = ListSequence.fromList(selectedNodes).getElement(0);\n    SNodeOperations.insertPrevSiblingChild(first, contentList);\n    for (SNode selectedNode : ListSequence.fromList(selectedNodes)) {\n      ListSequence.fromList(SLinkOperations.getTargets(contentList, \"content\", true)).addElement(SNodeOperations.cast(selectedNode, \"jetbrains.mps.xml.structure.Content\"));\n    }\n    SLinkOperations.addNewChild(contentList, \"content\", \"jetbrains.mps.xml.structure.Content\");\n  }","commit_id":"2fef5697bcb6de31fe04371f50dbd823314c82ec","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition9190_0(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(SLinkOperations.getTarget(VisitChildrenExpression_Behavior.call_getEnclosingVisitNodesStatement_1213877259423(node), \"visitParameterDeclarationList\", true), \"visitParameterDeclaration\") > 0;\n  }","id":87577,"modified_method":"private static boolean renderingCondition9190_0(SNode node, EditorContext editorContext, IScope scope) {\n    return ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(VisitChildrenExpression_Behavior.call_getEnclosingVisitNodesStatement_1213877259423(node), \"visitParameterDeclarationList\", true), \"visitParameterDeclaration\", true)).count() > 0;\n  }","commit_id":"2fef5697bcb6de31fe04371f50dbd823314c82ec","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode visitChildrenExpression, final TypeCheckingContext typeCheckingContext) {\n    int actualCount = SLinkOperations.getCount(visitChildrenExpression, \"actualArgument\");\n    SNode visitBlock = VisitChildrenExpression_Behavior.call_getEnclosingVisitNodesStatement_1213877259423(visitChildrenExpression);\n    if (!((visitBlock != null))) {\n      BaseIntentionProvider intentionProvider = null;\n      IErrorTarget errorTarget = new NodeErrorTarget();\n      IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(visitChildrenExpression, \"visit children is unexpected here\", \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014856089\", intentionProvider, errorTarget);\n    }\n    List<SNode> parameters = SLinkOperations.getTargets(SLinkOperations.getTarget(visitBlock, \"visitParameterDeclarationList\", true), \"visitParameterDeclaration\", true);\n    int expectedCount = ListSequence.fromList(parameters).count();\n    if (!(actualCount == expectedCount)) {\n      BaseIntentionProvider intentionProvider = null;\n      IErrorTarget errorTarget = new NodeErrorTarget();\n      IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(visitChildrenExpression, \"wrong parameters number: expected \" + expectedCount + \" , actual \" + actualCount, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014444793\", intentionProvider, errorTarget);\n    }\n    {\n      SNode arg;\n      SNode param;\n      Iterator<SNode> arg_iterator = ListSequence.fromList(SLinkOperations.getTargets(visitChildrenExpression, \"actualArgument\", true)).iterator();\n      Iterator<SNode> param_iterator = ListSequence.fromList(parameters).iterator();\n      while (true) {\n        if (!(arg_iterator.hasNext())) {\n          break;\n        }\n        if (!(param_iterator.hasNext())) {\n          break;\n        }\n        arg = arg_iterator.next();\n        param = param_iterator.next();\n        {\n          SNode _nodeToCheck_1029348928467 = arg;\n          BaseIntentionProvider intentionProvider = null;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014737422\", 0, intentionProvider);\n          _info_12389875345.setInequationGroup(\"default\");\n          typeCheckingContext.createLessThanInequation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014730654\", true), (SNode) typeCheckingContext.typeOf(param, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014739452\", true), false, _info_12389875345);\n        }\n      }\n    }\n  }","id":87578,"modified_method":"public void applyRule(final SNode visitChildrenExpression, final TypeCheckingContext typeCheckingContext) {\n    int actualCount = ListSequence.fromList(SLinkOperations.getTargets(visitChildrenExpression, \"actualArgument\", true)).count();\n    SNode visitBlock = VisitChildrenExpression_Behavior.call_getEnclosingVisitNodesStatement_1213877259423(visitChildrenExpression);\n    if (!((visitBlock != null))) {\n      BaseIntentionProvider intentionProvider = null;\n      IErrorTarget errorTarget = new NodeErrorTarget();\n      IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(visitChildrenExpression, \"visit children is unexpected here\", \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014856089\", intentionProvider, errorTarget);\n    }\n    List<SNode> parameters = SLinkOperations.getTargets(SLinkOperations.getTarget(visitBlock, \"visitParameterDeclarationList\", true), \"visitParameterDeclaration\", true);\n    int expectedCount = ListSequence.fromList(parameters).count();\n    if (!(actualCount == expectedCount)) {\n      BaseIntentionProvider intentionProvider = null;\n      IErrorTarget errorTarget = new NodeErrorTarget();\n      IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(visitChildrenExpression, \"wrong parameters number: expected \" + expectedCount + \" , actual \" + actualCount, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014444793\", intentionProvider, errorTarget);\n    }\n    {\n      SNode arg;\n      SNode param;\n      Iterator<SNode> arg_iterator = ListSequence.fromList(SLinkOperations.getTargets(visitChildrenExpression, \"actualArgument\", true)).iterator();\n      Iterator<SNode> param_iterator = ListSequence.fromList(parameters).iterator();\n      while (true) {\n        if (!(arg_iterator.hasNext())) {\n          break;\n        }\n        if (!(param_iterator.hasNext())) {\n          break;\n        }\n        arg = arg_iterator.next();\n        param = param_iterator.next();\n        {\n          SNode _nodeToCheck_1029348928467 = arg;\n          BaseIntentionProvider intentionProvider = null;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014737422\", 0, intentionProvider);\n          _info_12389875345.setInequationGroup(\"default\");\n          typeCheckingContext.createLessThanInequation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014730654\", true), (SNode) typeCheckingContext.typeOf(param, \"r:00000000-0000-4000-0000-011c895905aa(jetbrains.mps.ypath.typesystem)\", \"1180014739452\", true), false, _info_12389875345);\n        }\n      }\n    }\n  }","commit_id":"2fef5697bcb6de31fe04371f50dbd823314c82ec","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method5(SNode node) {\n    // single attribute access\n    SNode expression = SLinkOperations.getTarget(node, \"expression\", true);\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.Expression\");\n    SNode ex = SLinkOperations.removeChild(node, \"expression\");\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.lang.generator.structure.PropertyMacro\");\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.lang.generator.structure.PropertyMacro\");\n    SNode macro = SLinkOperations.removeChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"));\n  }","id":87579,"modified_method":"public void method5(SNode node) {\n    // single attribute access \n    SNode expression = SLinkOperations.getTarget(node, \"expression\", true);\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.Expression\");\n    SNode ex = SNodeOperations.detachNode(SLinkOperations.getTarget(node, \"expression\", true));\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.lang.generator.structure.PropertyMacro\");\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.lang.generator.structure.PropertyMacro\");\n    SNode macro = SNodeOperations.detachNode(SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), true));\n  }","commit_id":"b7874a9bf9eab9343f2f293899b6d66f31faf6d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method7(SNode node) {\n    Iterable<SNode> seq = ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\");\n      }\n\n    });\n    for(SNode statement : SLinkOperations.getTargets(node, \"statement\", true)) {\n      String string = SPropertyOperations.getString(statement, \"alias\");\n    }\n  }","id":87580,"modified_method":"public void method7(SNode node) {\n    Iterable<SNode> seq = ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(it, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\");\n      }\n    });\n    for (SNode statement : ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true))) {\n      String string = SPropertyOperations.getString(statement, \"alias\");\n    }\n  }","commit_id":"b7874a9bf9eab9343f2f293899b6d66f31faf6d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method6(SNode node) {\n    // attribute list access\n    List<SNode> nodes = SLinkOperations.getTargets(node, \"statement\", true);\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addChild(node, \"statement\", null);\n    SLinkOperations.addAll(node, \"statement\", null);\n    SLinkOperations.insertChildFirst(node, \"statement\", null);\n    int c1 = SLinkOperations.getCount(node, \"statement\");\n    List<SNode> macros = SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.lang.generator.structure.NodeMacro\");\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.lang.generator.structure.NodeMacro\");\n    SLinkOperations.addChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    SLinkOperations.addAll(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    SLinkOperations.insertChildFirst(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    int c2 = SLinkOperations.getCount(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"));\n    int c3 = ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).count();\n    // not a link\n    int all = ListSequence.fromList(SNodeOperations.getAllAttributes(node)).count();\n    SNodeOperations.copyNode(SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), true));\n  }","id":87581,"modified_method":"public void method6(SNode node) {\n    // attribute list access \n    List<SNode> nodes = SLinkOperations.getTargets(node, \"statement\", true);\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true)).addElement(null);\n    ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true)).addSequence(null);\n    ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true)).insertElement(0, SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.ReturnStatement\", null));\n    int c1 = ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true)).count();\n    List<SNode> macros = SLinkOperations.getTargets(SNodeOperations.cast(node, \"\"), AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.lang.generator.structure.NodeMacro\");\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.lang.generator.structure.NodeMacro\");\n    ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).addElement(null);\n    ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).addSequence(null);\n    ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).insertElement(0, null);\n    int c2 = ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).count();\n    int c3 = ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).count();\n    // not a link \n    int all = ListSequence.fromList(SNodeOperations.getAllAttributes(node)).count();\n    SNodeOperations.copyNode(SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), true));\n  }","commit_id":"b7874a9bf9eab9343f2f293899b6d66f31faf6d3","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition7205_1(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(node, \"typeVariableDeclaration\") > 0;\n  }","id":87582,"modified_method":"private static boolean renderingCondition7205_1(SNode node, EditorContext editorContext, IScope scope) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"typeVariableDeclaration\", true)).count() > 0;\n  }","commit_id":"e76819d80ce8d96538dc915716c6ccf711a46ebb","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition7205_0(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(node, \"annotation\") > 0;\n  }","id":87583,"modified_method":"private static boolean renderingCondition7205_0(SNode node, EditorContext editorContext, IScope scope) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"annotation\", true)).count() > 0;\n  }","commit_id":"e76819d80ce8d96538dc915716c6ccf711a46ebb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static AbstractExtractMethodRefactoringProcessor virtual_getExtractMethodRefactoringProcessor_1221393367929(SNode thisNode, List<SNode> nodesToRefactor) {\n    return new AbstractExtractMethodRefactoringProcessor(thisNode, nodesToRefactor) {\n      public SNode createNewMethod() {\n        return SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodDeclaration\", null);\n      }\n\n      public SNode createMethodCall(SNode methodDeclaration, List<SNode> parameteres) {\n        SNode call = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodCallOperation\", null);\n        SLinkOperations.setTarget(call, \"member\", SNodeOperations.cast(methodDeclaration, \"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodDeclaration\"), false);\n        SLinkOperations.addAll(call, \"actualArgument\", parameteres);\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.DotExpression\", null);\n        SLinkOperations.setTarget(result, \"operand\", SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.classifiers.structure.ThisClassifierExpression\", null), true);\n        SLinkOperations.setTarget(result, \"operation\", call, true);\n        return result;\n      }\n    };\n  }","id":87584,"modified_method":"public static AbstractExtractMethodRefactoringProcessor virtual_getExtractMethodRefactoringProcessor_1221393367929(SNode thisNode, List<SNode> nodesToRefactor) {\n    return new AbstractExtractMethodRefactoringProcessor(thisNode, nodesToRefactor) {\n      public SNode createNewMethod() {\n        return SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodDeclaration\", null);\n      }\n\n      public SNode createMethodCall(SNode methodDeclaration, List<SNode> parameteres) {\n        SNode call = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodCallOperation\", null);\n        SLinkOperations.setTarget(call, \"member\", SNodeOperations.cast(methodDeclaration, \"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodDeclaration\"), false);\n        ListSequence.fromList(SLinkOperations.getTargets(call, \"actualArgument\", true)).addSequence(ListSequence.fromList(parameteres));\n        SNode result = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.DotExpression\", null);\n        SLinkOperations.setTarget(result, \"operand\", SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.classifiers.structure.ThisClassifierExpression\", null), true);\n        SLinkOperations.setTarget(result, \"operation\", call, true);\n        return result;\n      }\n    };\n  }","commit_id":"e76819d80ce8d96538dc915716c6ccf711a46ebb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205769679712\", 0, intentionProvider);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205769685435\", true), (SNode) SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"returnType\", true), _info_12389875345);\n    }\n    {\n      SNode parameter;\n      SNode argument;\n      Iterator<SNode> parameter_iterator = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true)).iterator();\n      Iterator<SNode> argument_iterator = ListSequence.fromList(SLinkOperations.getTargets(nodeToCheck, \"actualArgument\", true)).iterator();\n      while (true) {\n        if (!(parameter_iterator.hasNext())) {\n          break;\n        }\n        if (!(argument_iterator.hasNext())) {\n          break;\n        }\n        parameter = parameter_iterator.next();\n        argument = argument_iterator.next();\n        {\n          SNode _nodeToCheck_1029348928467 = argument;\n          BaseIntentionProvider intentionProvider = null;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205854571586\", 0, intentionProvider);\n          _info_12389875345.setInequationGroup(\"default\");\n          typeCheckingContext.createLessThanInequation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205854575356\", true), (SNode) SLinkOperations.getTarget(parameter, \"type\", true), false, _info_12389875345);\n        }\n      }\n    }\n    if (SLinkOperations.getCount(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\") != SLinkOperations.getCount(nodeToCheck, \"actualArgument\")) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(nodeToCheck, \"Number of parameters doesn't match\", \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205854659855\", intentionProvider, errorTarget);\n      }\n    }\n  }","id":87585,"modified_method":"public void applyRule(final SNode nodeToCheck, final TypeCheckingContext typeCheckingContext) {\n    {\n      SNode _nodeToCheck_1029348928467 = nodeToCheck;\n      BaseIntentionProvider intentionProvider = null;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205769679712\", 0, intentionProvider);\n      typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205769685435\", true), (SNode) SLinkOperations.getTarget(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"returnType\", true), _info_12389875345);\n    }\n    {\n      SNode parameter;\n      SNode argument;\n      Iterator<SNode> parameter_iterator = ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true)).iterator();\n      Iterator<SNode> argument_iterator = ListSequence.fromList(SLinkOperations.getTargets(nodeToCheck, \"actualArgument\", true)).iterator();\n      while (true) {\n        if (!(parameter_iterator.hasNext())) {\n          break;\n        }\n        if (!(argument_iterator.hasNext())) {\n          break;\n        }\n        parameter = parameter_iterator.next();\n        argument = argument_iterator.next();\n        {\n          SNode _nodeToCheck_1029348928467 = argument;\n          BaseIntentionProvider intentionProvider = null;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205854571586\", 0, intentionProvider);\n          _info_12389875345.setInequationGroup(\"default\");\n          typeCheckingContext.createLessThanInequation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205854575356\", true), (SNode) SLinkOperations.getTarget(parameter, \"type\", true), false, _info_12389875345);\n        }\n      }\n    }\n    if (ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(nodeToCheck, \"member\", false), \"parameter\", true)).count() != ListSequence.fromList(SLinkOperations.getTargets(nodeToCheck, \"actualArgument\", true)).count()) {\n      {\n        BaseIntentionProvider intentionProvider = null;\n        IErrorTarget errorTarget = new NodeErrorTarget();\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(nodeToCheck, \"Number of parameters doesn't match\", \"r:00000000-0000-4000-0000-011c89590371(jetbrains.mps.baseLanguage.classifiers.typesystem)\", \"1205854659855\", intentionProvider, errorTarget);\n      }\n    }\n  }","commit_id":"e76819d80ce8d96538dc915716c6ccf711a46ebb","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode sourceNodeQuery_1197045463934(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    if (SLinkOperations.getCount(_context.getNode(), \"depends\") == 0) {\n      return null;\n    }\n    SNode attribute = SConceptOperations.createNewNode(\"jetbrains.mps.xml.deprecated.structure.Attribute\", null);\n    SPropertyOperations.set(attribute, \"name\", \"depends\");\n    SPropertyOperations.set(attribute, \"value\", TargetDeclaration_Behavior.call_getDependanceString_1213877231974(_context.getNode()));\n    return attribute;\n  }","id":87586,"modified_method":"public static SNode sourceNodeQuery_1197045463934(final IOperationContext operationContext, final SourceSubstituteMacroNodeContext _context) {\n    if (ListSequence.fromList(SLinkOperations.getTargets(_context.getNode(), \"depends\", true)).count() == 0) {\n      return null;\n    }\n    SNode attribute = SConceptOperations.createNewNode(\"jetbrains.mps.xml.deprecated.structure.Attribute\", null);\n    SPropertyOperations.set(attribute, \"name\", \"depends\");\n    SPropertyOperations.set(attribute, \"value\", TargetDeclaration_Behavior.call_getDependanceString_1213877231974(_context.getNode()));\n    return attribute;\n  }","commit_id":"b5de29f2b767de248a4fc2ee0965711143993fd7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ActivityFeedTable(String name) {\n      super(name);\n      table = new Table(\"activity_feed_\" + this.getName());\n  }","id":87587,"modified_method":"public ActivityFeedTable(String name) {\n    super(name);\n    this.table = new Table(\"activity_feed_\" + name);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public DataSetSpecification configure() {\n        return null;\n    }","id":87588,"modified_method":"@Override\n  public DataSetSpecification configure() {\n    return new DataSetSpecification.Builder(this)\n        .dataset(this.table.configure())\n        .create();\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Writes the specified activity feed entry to the activity feed of the\n   * specified country and category.\n   * @param country\n   * @param category\n   * @param feedEntry\n   */\n  public void writeEntry(String country, String category,\n      ActivityFeedEntry feedEntry) {\n\n      Write feedEntryWrite = new Write(makeActivityFeedRow(country, category), feedEntry.getColumn(), feedEntry.getValue());\n\n      try {\n          table.write(feedEntryWrite);\n      } catch (OperationException e) {\n          throw Throwables.propagate(e);\n      }\n\n// Old logic\n//    Write feedEntryWrite = new Write(ACTIVITY_FEED_TABLE,\n//        makeActivityFeedRow(country, category), feedEntry.getColumn(),\n//        feedEntry.getValue());\n//    getCollector().add(feedEntryWrite);\n  }","id":87589,"modified_method":"/**\n   * Writes the specified activity feed entry to the activity feed of the\n   * specified country and category.\n   * @param country\n   * @param category\n   * @param feedEntry\n   */\n  public void writeEntry(String country, String category,\n      ActivityFeedEntry feedEntry) throws OperationException {\n    Write feedEntryWrite =\n        new Write(makeActivityFeedRow(country, category),\n            feedEntry.getColumn(), feedEntry.getValue());\n\n    this.table.write(feedEntryWrite);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Reads the activity feed for the specified category, from times between the\n   * maximum and minimum stamps, and up to the specified limit.\n   * @param country\n   * @param category\n   * @param limit maximum number of entries to return\n   * @param maxStamp maximum stamp, exclusive\n   * @param minStamp minimum stamp, exclusive\n   * @return list of feed entries\n   * @throws OperationException \n   * @throws IllegalStateException \n   */\n  public List<ActivityFeedEntry> readEntries(String country, String category,\n      int limit, long maxStamp, long minStamp)\n          throws OperationException {\n\n    // ReadColumnRange start is inclusive but we want exclusive, so if the start\n    // is non-zero, subtract one\n    long exclusiveStamp = Helpers.reverse(maxStamp);\n\n    if (exclusiveStamp != 0) exclusiveStamp--;\n    byte [] startColumn = Bytes.toBytes(exclusiveStamp);\n    byte [] stopColumn = Bytes.toBytes(Helpers.reverse(minStamp));\n\n   // Old logic\n    // Perform read from startColumn to stopColumn\n    //ReadColumnRange read = new ReadColumnRange(ACTIVITY_FEED_TABLE,\n    //    makeActivityFeedRow(country, category), startColumn, stopColumn, limit);\n    //OperationResult<Map<byte[],byte[]>> result = getDataFabric().read(read);\n\n   Read read = new Read(makeActivityFeedRow(country, category), startColumn, stopColumn, limit);\n   OperationResult<Map<byte[],byte[]>> result = table.read(read);\n\n\n    List<ActivityFeedEntry> entries = new ArrayList<ActivityFeedEntry>();\n    if (!result.isEmpty()) {\n      for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n        entries.add(new ActivityFeedEntry(entry.getKey(), entry.getValue()));\n      }\n    }\n    return entries;\n  }","id":87590,"modified_method":"/**\n   * Reads the activity feed for the specified category, from times between the\n   * maximum and minimum stamps, and up to the specified limit.\n   * @param country\n   * @param category\n   * @param limit maximum number of entries to return\n   * @param maxStamp maximum stamp, exclusive\n   * @param minStamp minimum stamp, exclusive\n   * @return list of feed entries\n   * @throws OperationException\n   * @throws IllegalStateException\n   */\n  public List<ActivityFeedEntry> readEntries(String country, String category,\n      int limit, long maxStamp, long minStamp)\n          throws OperationException {\n\n    // ReadColumnRange start is inclusive but we want exclusive, so if the start\n    // is non-zero, subtract one\n    long exclusiveStamp = Helpers.reverse(maxStamp);\n\n    if (exclusiveStamp != 0) exclusiveStamp--;\n    byte [] startColumn = Bytes.toBytes(exclusiveStamp);\n    byte [] stopColumn = Bytes.toBytes(Helpers.reverse(minStamp));\n\n    Read read = new Read(makeActivityFeedRow(country, category), startColumn,\n        stopColumn, limit);\n    OperationResult<Map<byte[],byte[]>> result = this.table.read(read);\n\n    List<ActivityFeedEntry> entries = new ArrayList<ActivityFeedEntry>();\n    if (!result.isEmpty()) {\n      for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n        entries.add(new ActivityFeedEntry(entry.getKey(), entry.getValue()));\n      }\n    }\n    return entries;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Performs the query once the URL has been validated and the inputs have been\n   * parsed.  Further validation of arguments required per-method is performed\n   * within this method.\n   * <p>\n   * This currently supports two methods, <i>readactivity<\/i> and\n   * <i>readpopular<\/i>.\n   * <p>\n   * <b><i>readactivity<\/i><\/b> performs an ActivityFeed read and has required\n   * arguments of <i>clusterid<\/i> and <i>limit<\/i>.  Optionally, can also\n   * specify a <i>maxts<\/i> and <i>mints<\/i> for maximum and minimum timestamps.\n   * <p>\n   * <b><i>readpopular<\/i><\/b> performs a PopularFeed read and has required\n   * arguments of <i>clusterid<\/i>, <i>numhours<\/i>, and <i>limit<\/i>.\n   * Optionally, can also specify an <i>offset<\/i> and <i>starttime<\/i>, which\n   * is treated as the start time for doing popular queries.\n   * @param request method being performed\n   * @param responder arguments of method\n   * @return string result\n   */\n  @Handle(\"readactivity\")\n  public void readActivity(ProcedureRequest request, ProcedureResponder responder) throws Exception {\n\n\n\n      String country =  request.getArgument(\"country\"); // args.get(\"country\");\n      String clusteridStr = request.getArgument(\"clusterid\"); // args.get(\"clusterid\");\n      String limitStr =  request.getArgument(\"limit\");  //  args.get(\"limit\");\n      Integer clusterid = null;\n      Integer limit = null;\n      Long maxts = Long.MAX_VALUE;\n      Long mints = 0L;\n\n      try {\n          clusterid = Integer.valueOf(clusteridStr);\n          limit = Integer.valueOf(limitStr);\n\n          if (request.getArgument(\"maxts\") != null)\n            maxts = Long.getLong(request.getArgument(\"maxts\"));\n\n          if (request.getArgument(\"mints\") != null)\n            mints = Long.getLong(request.getArgument(\"mints\"));\n\n      } catch (NumberFormatException nfe) {\n          Throwables.propagate(nfe);\n      }\n\n      try {\n          ActivityFeed feed =\n                  reader.getActivityFeed(country, clusterid, limit, maxts, mints);\n\n          responder.sendJson(new ProcedureResponse(ProcedureResponse.Code.SUCCESS), feed);\n\n      } catch (OperationException e) {\n          Throwables.propagate(e);\n      }\n  }","id":87591,"modified_method":"/**\n   * Performs the query once the URL has been validated and the inputs have been\n   * parsed.  Further validation of arguments required per-method is performed\n   * within this method.\n   * <p>\n   * This currently supports two methods, <i>readactivity<\/i> and\n   * <i>readpopular<\/i>.\n   * <p>\n   * <b><i>readactivity<\/i><\/b> performs an ActivityFeed read and has required\n   * arguments of <i>clusterid<\/i> and <i>limit<\/i>.  Optionally, can also\n   * specify a <i>maxts<\/i> and <i>mints<\/i> for maximum and minimum timestamps.\n   * <p>\n   * <b><i>readpopular<\/i><\/b> performs a PopularFeed read and has required\n   * arguments of <i>clusterid<\/i>, <i>numhours<\/i>, and <i>limit<\/i>.\n   * Optionally, can also specify an <i>offset<\/i> and <i>starttime<\/i>, which\n   * is treated as the start time for doing popular queries.\n   * @param request method being performed\n   * @param responder arguments of method\n   * @return string result\n   */\n  @Handle(\"readactivity\")\n  public void readActivity(ProcedureRequest request, ProcedureResponder responder) throws Exception {\n\n    initReader();\n\n\n    String country =  request.getArgument(\"country\"); // args.get(\"country\");\n    String clusteridStr = request.getArgument(\"clusterid\"); // args.get(\"clusterid\");\n    String limitStr =  request.getArgument(\"limit\");  //  args.get(\"limit\");\n    Integer clusterid = null;\n    Integer limit = null;\n    Long maxts = Long.MAX_VALUE;\n    Long mints = 0L;\n\n    try {\n      clusterid = Integer.valueOf(clusteridStr);\n      limit = Integer.valueOf(limitStr);\n\n      if (request.getArgument(\"maxts\") != null)\n        maxts = Long.getLong(request.getArgument(\"maxts\"));\n\n      if (request.getArgument(\"mints\") != null)\n        mints = Long.getLong(request.getArgument(\"mints\"));\n\n    } catch (NumberFormatException nfe) {\n      throw nfe;\n    }\n\n    try {\n      ActivityFeed feed =\n          this.reader.getActivityFeed(country, clusterid, limit, maxts, mints);\n\n      responder.sendJson(new ProcedureResponse(ProcedureResponse.Code.SUCCESS), feed);\n\n    } catch (OperationException e) {\n      throw e;\n    }\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Handle(\"readpopular\")\n  public void readPopular(ProcedureRequest request, ProcedureResponder responder) throws Exception {\n\n      String country =  request.getArgument(\"country\");//  args.get(\"country\");\n      String clusteridStr = request.getArgument(\"clusterid\"); // args.get(\"clusterid\");\n      String numhoursStr = request.getArgument(\"numhours\") ; // args.get(\"numhours\");\n      String limitStr = request.getArgument(\"limit\");    //   args.get(\"limit\");\n      Integer clusterid = null;\n      Integer numhours = null;\n      Integer limit = null;\n\n      // Check for additional arguments (first setting default values)\n      Integer offset = 0;\n      Long starttime = System.currentTimeMillis();\n\n\n      try {\n          clusterid = Integer.valueOf(clusteridStr);\n          numhours = Integer.valueOf(numhoursStr);\n          limit = Integer.valueOf(limitStr);\n\n          if (request.getArgument(\"offset\") != null)\n            offset = Integer.valueOf(request.getArgument(\"offset\"));\n\n          if (request.getArgument(\"starttime\") != null)\n            starttime = Long.valueOf(request.getArgument(\"starttime\"));\n\n      } catch (NumberFormatException nfe) {\n          Throwables.propagate(nfe);\n      }\n\n      PopularFeed feed = reader.getPopularFeed(country, clusterid,\n      Helpers.hour(starttime), numhours, limit, offset);\n      List<PopularFeedEntry> entries = feed.getFeed(limit + offset);\n\n      responder.sendJson(new ProcedureResponse(ProcedureResponse.Code.SUCCESS), entries);\n  }","id":87592,"modified_method":"@Handle(\"readpopular\")\n  public void readPopular(ProcedureRequest request, ProcedureResponder responder) throws Exception {\n\n    initReader();\n\n    String country =  request.getArgument(\"country\");//  args.get(\"country\");\n    String clusteridStr = request.getArgument(\"clusterid\"); // args.get(\"clusterid\");\n    String numhoursStr = request.getArgument(\"numhours\") ; // args.get(\"numhours\");\n    String limitStr = request.getArgument(\"limit\");    //   args.get(\"limit\");\n    Integer clusterid = null;\n    Integer numhours = null;\n    Integer limit = null;\n\n    // Check for additional arguments (first setting default values)\n    Integer offset = 0;\n    Long starttime = System.currentTimeMillis();\n\n\n    try {\n      clusterid = Integer.valueOf(clusteridStr);\n      numhours = Integer.valueOf(numhoursStr);\n      limit = Integer.valueOf(limitStr);\n\n      if (request.getArgument(\"offset\") != null)\n        offset = Integer.valueOf(request.getArgument(\"offset\"));\n\n      if (request.getArgument(\"starttime\") != null)\n        starttime = Long.valueOf(request.getArgument(\"starttime\"));\n\n    } catch (NumberFormatException nfe) {\n      throw nfe;\n    }\n\n    PopularFeed feed = this.reader.getPopularFeed(country, clusterid,\n        Helpers.hour(starttime), numhours, limit, offset);\n    List<PopularFeedEntry> entries = feed.getFeed(limit + offset);\n\n    responder.sendJson(new ProcedureResponse(ProcedureResponse.Code.SUCCESS), entries);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public DataSetSpecification configure() {\n        return null;\n    }","id":87593,"modified_method":"@Override\n  public DataSetSpecification configure() {\n    return new DataSetSpecification.Builder(this)\n        .dataset(this.table.configure())\n        .create();\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Reads the cluster information for the specified cluster id.  Returns null\n   * if no cluster information found.\n   * <p>\n   * This operation is synchronous.\n   * @param clusterId\n   * @return cluster info containing map from classification/category to weight\n   * @throws OperationException\n   */\n  public Map<String,Double> readCluster(int clusterId)\n      throws OperationException {\n\n\n\n\n    // Old logic\n//   OperationResult<Map<byte[],byte[]>> result =\n//      getDataFabric().read(new ReadColumnRange(getDataSetId(), makeRow(clusterId), null));\n\n   Read read = new Read(makeRow(clusterId));\n   OperationResult<Map<byte[],byte[]>> result  = table.read( new Read(makeRow(clusterId)) );\n\n\n    if (result.isEmpty()) return null;\n    Map<byte[],byte[]> map = result.getValue();\n    Map<String,Double> ret = new TreeMap<String,Double>();\n    for (Map.Entry<byte[],byte[]> entry : map.entrySet()) {\n      ret.put(Bytes.toString(entry.getKey()), Bytes.toDouble(entry.getValue()));\n    }\n    return ret;\n  }","id":87594,"modified_method":"/**\n   * Reads the cluster information for the specified cluster id.  Returns null\n   * if no cluster information found.\n   * <p>\n   * This operation is synchronous.\n   * @param clusterId\n   * @return cluster info containing map from classification/category to weight\n   * @throws OperationException\n   */\n  public Map<String,Double> readCluster(int clusterId)\n      throws OperationException {\n    OperationResult<Map<byte[],byte[]>> result =\n        this.table.read(new Read(makeRow(clusterId)));\n    if (result.isEmpty()) return null;\n    Map<byte[],byte[]> map = result.getValue();\n    Map<String,Double> ret = new TreeMap<String,Double>();\n    for (Map.Entry<byte[],byte[]> entry : map.entrySet()) {\n      ret.put(Bytes.toString(entry.getKey()), Bytes.toDouble(entry.getValue()));\n    }\n    return ret;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public ClusterTable(String name) {\n      super(name);\n      table = new Table(\"cluster_\" + this.getName());\n  }","id":87595,"modified_method":"public ClusterTable(String name) {\n    super(name);\n    this.table = new Table(\"cluster_\" + name);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public static byte [] makeRow(int clusterid) {\n    return Bytes.add(Bytes.toBytes(CLUSTER_TABLE), Bytes.toBytes(clusterid));\n  }","id":87596,"modified_method":"public static byte [] makeRow(int clusterid) {\n    return Bytes.toBytes(clusterid);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public FlowSpecification configure() {\n        return FlowSpecification.Builder.with()\n                .setName(flowName)\n                .setDescription(\"Continuuity+Payvment:ClusterWriter\")\n                .withFlowlets()\n                .add(cluster_source_parser, new ClusterSourceParser())\n                .add(writer_output, new ClusterWriter())\n                .add(reset_output, new ClusterReset())\n                .connect()\n\n                .fromStream(LishApp.inputStream).to(cluster_source_parser)\n                .from(cluster_source_parser).to(writer_output)\n                .from(cluster_source_parser).to(reset_output)\n                .build();\n    }","id":87597,"modified_method":"@Override\n  public FlowSpecification configure() {\n    return FlowSpecification.Builder.with()\n        .setName(FLOW_NAME)\n        .setDescription(FLOW_NAME)\n        .withFlowlets()\n          .add(PARSER_FLOWLET_NAME, new ClusterSourceParser())\n          .add(WRITER_FLOWLET_NAME, new ClusterWriter())\n          .add(RESET_FLOWLET_NAME, new ClusterReseter())\n        .connect()\n          .fromStream(LishApp.CLUSTER_STREAM).to(PARSER_FLOWLET_NAME)\n          .from(PARSER_FLOWLET_NAME).to(WRITER_FLOWLET_NAME)\n          .from(PARSER_FLOWLET_NAME).to(RESET_FLOWLET_NAME)\n        .build();\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public CounterTable(DataSetSpecification spec) {\n        super(spec);\n        this.counters = new Table(spec.getSpecificationFor(\"ct_\" + this.getName()));\n    }","id":87598,"modified_method":"public CounterTable(DataSetSpecification spec) {\n    super(spec);\n    this.counters = new Table(spec.getSpecificationFor(\"ct_\" + getName()));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs a synchronous read of the specified counters in the specified\n     * counter set.  Returns a map of counter name to counter long values for\n     * all counters found.  Counters with no found value will not be in map.\n     * @param counterSet counter set name\n     * @param counterNames counter names\n     * @return map of counter names to counter long values\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public Map<String,Long> readCounterSet(String counterSet,\n                                           String [] counterNames) throws OperationException {\n        byte [][] columns = Helpers.saToBa(counterNames);\n        Read read = new Read(Bytes.toBytes(counterSet), columns);\n        OperationResult<Map<byte[],byte[]>> result = counters.read(read);\n        Map<String,Long> ret = new TreeMap<String,Long>();\n        if (result.isEmpty()) return ret;\n        for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n            ret.put(Bytes.toString(entry.getKey()), Bytes.toLong(entry.getValue()));\n        }\n        return ret;\n    }","id":87599,"modified_method":"/**\n   * Performs a synchronous read of the specified counters in the specified\n   * counter set.  Returns a map of counter name to counter long values for\n   * all counters found.  Counters with no found value will not be in map.\n   * @param counterSet counter set name\n   * @param counterNames counter names\n   * @return map of counter names to counter long values\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public Map<String,Long> readCounterSet(String counterSet,\n      String [] counterNames) throws OperationException {\n    byte [][] columns = Helpers.saToBa(counterNames);\n    Read read = new Read(Bytes.toBytes(counterSet), columns);\n    OperationResult<Map<byte[],byte[]>> result = this.counters.read(read);\n    Map<String,Long> ret = new TreeMap<String,Long>();\n    if (result.isEmpty()) return ret;\n    for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n      ret.put(Bytes.toString(entry.getKey()), Bytes.toLong(entry.getValue()));\n    }\n    return ret;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs a synchronous read of the specified counter set, finding counters\n     * with names less than or equal to the specified minimum and greater than the\n     * specified maximum, returning a map of counter names to long values.\n     * @param counterSet counter set name\n     * @param minCounter minimum counter, inclusive\n     * @param maxCounter maximum counter, exclusive\n     * @return map of counter names to counter long values\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public Map<String,Long> readCounterSet(String counterSet, String minCounter,\n                                           String maxCounter) throws OperationException {\n        Read read = new Read(Bytes.toBytes(counterSet), Bytes.toBytes(minCounter), Bytes.toBytes(maxCounter));\n        OperationResult<Map<byte[],byte[]>> result = counters.read(read);\n        Map<String,Long> ret = new TreeMap<String,Long>();\n        if (result.isEmpty()) return ret;\n        for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n            ret.put(Bytes.toString(entry.getKey()), Bytes.toLong(entry.getValue()));\n        }\n        return ret;\n    }","id":87600,"modified_method":"/**\n   * Performs a synchronous read of the specified counter set, finding counters\n   * with names less than or equal to the specified minimum and greater than the\n   * specified maximum, returning a map of counter names to long values.\n   * @param counterSet counter set name\n   * @param minCounter minimum counter, inclusive\n   * @param maxCounter maximum counter, exclusive\n   * @return map of counter names to counter long values\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public Map<String,Long> readCounterSet(String counterSet, String minCounter,\n      String maxCounter) throws OperationException {\n    Read read = new Read(Bytes.toBytes(counterSet), Bytes.toBytes(minCounter), Bytes.toBytes(maxCounter));\n    OperationResult<Map<byte[],byte[]>> result = this.counters.read(read);\n    Map<String,Long> ret = new TreeMap<String,Long>();\n    if (result.isEmpty()) return ret;\n    for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n      ret.put(Bytes.toString(entry.getKey()), Bytes.toLong(entry.getValue()));\n    }\n    return ret;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Generates an increment operation that should be used to increment the\n     * specified counters in the specified counter set by the specified amounts.\n     * <p>\n     * See ... for more information.\n     * @param counterSet counter set name\n     * @param counters counter names\n     * @param amounts amounts to increment counters by\n     * @return prepared increment operation\n     */\n    public Increment generateCounterSetIncrement(String counterSet,\n                                                 String [] counters, long [] amounts) {\n        return new Increment(Bytes.toBytes(counterSet),\n                Helpers.saToBa(counters), amounts);\n    }","id":87601,"modified_method":"/**\n   * Generates an increment operation that should be used to increment the\n   * specified counters in the specified counter set by the specified amounts.\n   * <p>\n   * See ... for more information.\n   * @param counterSet counter set name\n   * @param counters counter names\n   * @param amounts amounts to increment counters by\n   * @return prepared increment operation\n   */\n  private Increment generateCounterSetIncrement(String counterSet,\n      String [] counters, long [] amounts) {\n    return new Increment(Bytes.toBytes(counterSet),\n        Helpers.saToBa(counters), amounts);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs a synchronous read of the specified counter set, finding counters\n     * with names less than or equal to the specified minimum and greater than the\n     * specified maximum, returning a map of counter names to long values.\n     * @param counterSet counter set name\n     * @param minCounter minimum counter, inclusive\n     * @param maxCounter maximum counter, exclusive\n     * @return map of counter names to counter long values\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public Map<byte[],Long> readCounterSet(byte [] counterSet, byte [] minCounter,\n                                           byte [] maxCounter) throws OperationException {\n        Read read = new Read(counterSet, minCounter, maxCounter);\n        OperationResult<Map<byte[],byte[]>> result = counters.read(read);\n        Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n        if (result.isEmpty()) return ret;\n        for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n            ret.put(entry.getKey(), Bytes.toLong(entry.getValue()));\n        }\n        return ret;\n    }","id":87602,"modified_method":"/**\n   * Performs a synchronous read of the specified counter set, finding counters\n   * with names less than or equal to the specified minimum and greater than the\n   * specified maximum, returning a map of counter names to long values.\n   * @param counterSet counter set name\n   * @param minCounter minimum counter, inclusive\n   * @param maxCounter maximum counter, exclusive\n   * @return map of counter names to counter long values\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public Map<byte[],Long> readCounterSet(byte [] counterSet, byte [] minCounter,\n      byte [] maxCounter) throws OperationException {\n    Read read = new Read(counterSet, minCounter, maxCounter);\n    OperationResult<Map<byte[],byte[]>> result = this.counters.read(read);\n    Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n    if (result.isEmpty()) return ret;\n    for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n      ret.put(entry.getKey(), Bytes.toLong(entry.getValue()));\n    }\n    return ret;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs a synchronous read of the specified counter set, returning a map\n     * of counter names to long values.\n     * @param counterSet counter set name\n     * @return map of counter names to counter long values\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public Map<String,Long> readCounterSet(String counterSet)\n            throws OperationException {\n        Read read = new Read(Bytes.toBytes(counterSet), null, null);\n        OperationResult<Map<byte[],byte[]>> result = counters.read(read);\n        Map<String,Long> ret = new TreeMap<String,Long>();\n        if (result.isEmpty()) return ret;\n        for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n            ret.put(Bytes.toString(entry.getKey()), Bytes.toLong(entry.getValue()));\n        }\n        return ret;\n    }","id":87603,"modified_method":"/**\n   * Performs a synchronous read of the specified counter set, returning a map\n   * of counter names to long values.\n   * @param counterSet counter set name\n   * @return map of counter names to counter long values\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public Map<String,Long> readCounterSet(String counterSet)\n      throws OperationException {\n    Read read = new Read(Bytes.toBytes(counterSet));\n    OperationResult<Map<byte[],byte[]>> result = this.counters.read(read);\n    Map<String,Long> ret = new TreeMap<String,Long>();\n    if (result.isEmpty()) return ret;\n    for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n      ret.put(Bytes.toString(entry.getKey()), Bytes.toLong(entry.getValue()));\n    }\n    return ret;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Generates an increment operation that should be used to increment the\n     * specified counter by the specified amount.\n     * <p>\n     * See ... for more information.\n     * @param counter counter name\n     * @param amount amount to increment counter by\n     * @return prepared increment operation\n     */\n    public Increment generateSingleKeyIncrement(byte [] counter, long amount) {\n        return new Increment(counter, COLUMN, amount);\n    }","id":87604,"modified_method":"/**\n   * Generates an increment operation that should be used to increment the\n   * specified counter by the specified amount.\n   * <p>\n   * See ... for more information.\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   * @return prepared increment operation\n   */\n  private Increment generateSingleKeyIncrement(byte [] counter, long amount) {\n    return new Increment(counter, COLUMN, amount);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs an asynchronous increment of the specified counter by the\n     * specified amount.  Value of counter after increment is not available.\n     * @param counter counter name\n     * @param amount amount to increment counter by\n     */\n    public void incrementSingleKey(String counter, long amount) {\n        incrementSingleKey(Bytes.toBytes(counter), amount);\n    }","id":87605,"modified_method":"/**\n   * Performs an asynchronous increment of the specified counter by the\n   * specified amount.  Value of counter after increment is not available.\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   */\n  public Long incrementSingleKey(String counter, long amount)\n  throws OperationException {\n    return incrementSingleKey(Bytes.toBytes(counter), amount);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Generates an increment operation that should be used to increment the\n     * specified counter in the specified counter set by the specified amount.\n     * <p>\n     * See ... for more information.\n     * @param counterSet counter set name\n     * @param counter counter name\n     * @param amount amount to increment counter by\n     * @return prepared increment operation\n     */\n    public Increment generateCounterSetIncrement(String counterSet,\n                                                 String counter, long amount) {\n        return new Increment(Bytes.toBytes(counterSet), Bytes.toBytes(counter), amount);\n    }","id":87606,"modified_method":"/**\n   * Generates an increment operation that should be used to increment the\n   * specified counter in the specified counter set by the specified amount.\n   * <p>\n   * See ... for more information.\n   * @param counterSet counter set name\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   * @return prepared increment operation\n   */\n  private Increment generateCounterSetIncrement(String counterSet,\n      String counter, long amount) {\n    return new Increment(Bytes.toBytes(counterSet), Bytes.toBytes(counter), amount);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs an asynchronous increment of the specified counter by the\n     * specified amount.  Value of counter after increment is not available.\n     * @param counter counter name\n     * @param amount amount to increment counter by\n     */\n    public void incrementSingleKey(byte [] counter, long amount) {\n        try {\n            this.counters.write(generateSingleKeyIncrement(counter, amount));\n        } catch (OperationException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":87607,"modified_method":"/**\n   * Performs an asynchronous increment of the specified counter by the\n   * specified amount.  Value of counter after increment is not available.\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   */\n  public Long incrementSingleKey(byte [] counter, long amount)\n      throws OperationException {\n    return this.counters.incrementAndGet(\n        generateSingleKeyIncrement(counter, amount)).get(COLUMN);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Generates an increment operation that should be used to increment the\n     * specified counters in the specified counter set by the specified amounts.\n     * <p>\n     * See ... for more information.\n     * @param counterSet counter set name\n     * @param counters counter names\n     * @param amounts amounts to increment counters by\n     * @return prepared increment operation\n     */\n    public Increment generateCounterSetIncrement(byte [] counterSet,\n                                                 byte [][] counters, long [] amounts) {\n        return new Increment(counterSet, counters, amounts);\n    }","id":87608,"modified_method":"/**\n   * Generates an increment operation that should be used to increment the\n   * specified counters in the specified counter set by the specified amounts.\n   * <p>\n   * See ... for more information.\n   * @param counterSet counter set name\n   * @param counters counter names\n   * @param amounts amounts to increment counters by\n   * @return prepared increment operation\n   */\n  private Increment generateCounterSetIncrement(byte [] counterSet,\n      byte [][] counters, long [] amounts) {\n    return new Increment(counterSet, counters, amounts);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs an asynchronous increment of the specified counters in the\n     * specified counter set by the specified amounts.\n     * <p>\n     * Values of counters after increments are not available.\n     * @param counterSet counter set name\n     * @param counterNames counter names\n     * @param amounts amounts to increment counters by\n     */\n    public void incrementCounterSet(byte [] counterSet,\n                                    byte [][] counterNames, long [] amounts) {\n        try {\n            counters.write(generateCounterSetIncrement(counterSet, counterNames, amounts));\n        } catch (OperationException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":87609,"modified_method":"/**\n   * Performs an asynchronous increment of the specified counters in the\n   * specified counter set by the specified amounts.\n   * <p>\n   * Values of counters after increments are not available.\n   * @param counterSet counter set name\n   * @param counterNames counter names\n   * @param amounts amounts to increment counters by\n   */\n  public Map<byte[],Long> incrementCounterSet(byte [] counterSet,\n      byte [][] counterNames, long [] amounts)\n      throws OperationException {\n    return this.counters.incrementAndGet(\n        generateCounterSetIncrement(counterSet, counterNames, amounts));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Constructs a reference to a counter table by the specified name under the\n     * specified flowlet context.\n     */\n    public CounterTable(String name) {\n        super(name);\n        counters = new Table(\"ct_\" + this.getName());\n    }","id":87610,"modified_method":"/**\n   * Constructs a reference to a counter table by the specified name under the\n   * specified flowlet context.\n   */\n  public CounterTable(String name) {\n    super(name);\n    this.counters = new Table(\"ct_\" + getName());\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs an asynchronous increment of the specified counters in the\n     * specified counter set by the specified amounts.\n     * <p>\n     * Values of counters after increments are not available.\n     * @param counterSet counter set name\n     * @param counterNames counter names\n     * @param amounts amounts to increment counters by\n     */\n    public void incrementCounterSet(String counterSet,\n                                    String [] counterNames, long [] amounts) {\n        try {\n            counters.write(generateCounterSetIncrement(counterSet, counterNames, amounts));\n        } catch (OperationException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":87611,"modified_method":"/**\n   * Performs an asynchronous increment of the specified counters in the\n   * specified counter set by the specified amounts.\n   * <p>\n   * Values of counters after increments are not available.\n   * @param counterSet counter set name\n   * @param counterNames counter names\n   * @param amounts amounts to increment counters by\n   */\n  public Map<byte[],Long> incrementCounterSet(String counterSet,\n      String [] counterNames, long [] amounts) throws OperationException {\n    return this.counters.incrementAndGet(\n        generateCounterSetIncrement(counterSet, counterNames, amounts));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs a synchronous read of the specified counters in the specified\n     * counter set.  Returns a map of counter name to counter long values for\n     * all counters found.  Counters with no found value will not be in map.\n     * @param counterSet counter set name\n     * @param counterNames counter names\n     * @return map of counter names to counter long values\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public Map<byte[],Long> readCounterSet(byte [] counterSet,\n                                           byte [][] counterNames) throws OperationException {\n        Read read = new Read(counterSet, counterNames);\n        OperationResult<Map<byte[],byte[]>> result = counters.read(read);\n        Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n        if (result.isEmpty()) return ret;\n        for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n            ret.put(entry.getKey(), Bytes.toLong(entry.getValue()));\n        }\n        return ret;\n    }","id":87612,"modified_method":"/**\n   * Performs a synchronous read of the specified counters in the specified\n   * counter set.  Returns a map of counter name to counter long values for\n   * all counters found.  Counters with no found value will not be in map.\n   * @param counterSet counter set name\n   * @param counterNames counter names\n   * @return map of counter names to counter long values\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public Map<byte[],Long> readCounterSet(byte [] counterSet,\n      byte [][] counterNames) throws OperationException {\n    Read read = new Read(counterSet, counterNames);\n    OperationResult<Map<byte[],byte[]>> result = this.counters.read(read);\n    Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n    if (result.isEmpty()) return ret;\n    for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n      ret.put(entry.getKey(), Bytes.toLong(entry.getValue()));\n    }\n    return ret;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs an asynchronous increment of the specified counter in the\n     * specified counter set by the specified amount.\n     * <p>\n     * Value of counter after increment is not available.\n     * @param counterSet counter set name\n     * @param counter counter name\n     * @param amount amount to increment counter by\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public void incrementCounterSet(String counterSet, String counter, long amount)\n            throws OperationException {\n        counters.write(generateCounterSetIncrement(counterSet, counter, amount));\n    }","id":87613,"modified_method":"/**\n   * Performs an asynchronous increment of the specified counter in the\n   * specified counter set by the specified amount.\n   * <p>\n   * Value of counter after increment is not available.\n   * @param counterSet counter set name\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public void incrementCounterSet(String counterSet, String counter, long amount)\n      throws OperationException {\n    this.counters.write(generateCounterSetIncrement(counterSet, counter, amount));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs a synchronous read of the specified counter set, returning a map\n     * of counter names to long values.\n     * @param counterSet counter set name\n     * @return map of counter names to counter long values\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public Map<byte[],Long> readCounterSet(byte [] counterSet)\n            throws OperationException {\n        Read read = new Read(counterSet, null, null);\n        OperationResult<Map<byte[],byte[]>> result = counters.read(read);\n        Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n        if (result.isEmpty()) return ret;\n        for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n            ret.put(entry.getKey(), Bytes.toLong(entry.getValue()));\n        }\n        return ret;\n    }","id":87614,"modified_method":"/**\n   * Performs a synchronous read of the specified counter set, returning a map\n   * of counter names to long values.\n   * @param counterSet counter set name\n   * @return map of counter names to counter long values\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public Map<byte[],Long> readCounterSet(byte [] counterSet)\n      throws OperationException {\n    Read read = new Read(counterSet);\n    OperationResult<Map<byte[],byte[]>> result = this.counters.read(read);\n    Map<byte[],Long> ret = new TreeMap<byte[],Long>(Bytes.BYTES_COMPARATOR);\n    if (result.isEmpty()) return ret;\n    for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n      ret.put(entry.getKey(), Bytes.toLong(entry.getValue()));\n    }\n    return ret;\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs an asynchronous increment of the specified counter in the\n     * specified counter set by the specified amount.\n     * <p>\n     * Value of counter after increment is not available.\n     * @param counterSet counter set name\n     * @param counter counter name\n     * @param amount amount to increment counter by\n     */\n    public void incrementCounterSet(byte [] counterSet, byte [] counter, long amount) {\n        try {\n            counters.write(generateCounterSetIncrement(counterSet, counter, amount));\n        } catch (OperationException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":87615,"modified_method":"/**\n   * Performs an asynchronous increment of the specified counter in the\n   * specified counter set by the specified amount.\n   * <p>\n   * Value of counter after increment is not available.\n   * @param counterSet counter set name\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   */\n  public Map<byte[],Long> incrementCounterSet(byte [] counterSet,\n    byte [] counter, long amount) throws OperationException {\n    return this.counters.incrementAndGet(\n        generateCounterSetIncrement(counterSet, counter, amount));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Performs a synchronous read of the specified counter in the specified\n     * counter set.  Returns the long value of the counter, or 0 if not found.\n     * @param counterSet counter set name\n     * @param counter counter name\n     * @return counter long value\n     * @throws com.continuuity.api.data.OperationException\n     */\n    public Long readCounterSet(byte [] counterSet, byte [] counter)\n            throws OperationException {\n        Read read = new Read(counterSet, counter);\n        OperationResult<Map<byte[],byte[]>> result = counters.read(read);\n        if (result.isEmpty()) return 0L;\n        return Bytes.toLong(result.getValue().get(counter));\n    }","id":87616,"modified_method":"/**\n   * Performs a synchronous read of the specified counter in the specified\n   * counter set.  Returns the long value of the counter, or 0 if not found.\n   * @param counterSet counter set name\n   * @param counter counter name\n   * @return counter long value\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public Long readCounterSet(byte [] counterSet, byte [] counter)\n      throws OperationException {\n    Read read = new Read(counterSet, counter);\n    OperationResult<Map<byte[],byte[]>> result = this.counters.read(read);\n    if (result.isEmpty()) return 0L;\n    return Bytes.toLong(result.getValue().get(counter));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Generates an increment operation that should be used to increment the\n     * specified counter in the specified counter set by the specified amount.\n     * <p>\n     * See ... for more information.\n     * @param counterSet counter set name\n     * @param counter counter name\n     * @param amount amount to increment counter by\n     * @return prepared increment operation\n     */\n    public Increment generateCounterSetIncrement(byte [] counterSet,\n                                                 byte [] counter, long amount) {\n        return new Increment(counterSet, counter, amount);\n    }","id":87617,"modified_method":"/**\n   * Generates an increment operation that should be used to increment the\n   * specified counter in the specified counter set by the specified amount.\n   * <p>\n   * See ... for more information.\n   * @param counterSet counter set name\n   * @param counter counter name\n   * @param amount amount to increment counter by\n   * @return prepared increment operation\n   */\n  private Increment generateCounterSetIncrement(byte [] counterSet,\n      byte [] counter, long amount) {\n    return new Increment(counterSet, counter, amount);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public ApplicationSpecification configure() {\n        return ApplicationSpecification.Builder.with()\n                .setName(APP_NAME)\n                .setDescription(APP_DESC)\n                .withStreams()\n                .add(new Stream(inputStream))\n                .withDataSets()\n                .add(new ActivityFeedTable(ACTIVITY_FEED_TABLE))\n                .add(new ClusterTable(CLUSTER_TABLE))\n                .add(new CounterTable(COUNTER_TABLE))\n                .add(new ProductTable(PRODUCT_TABLE))\n                .add(new SortedCounterTable(SORTED_COUNTER_TABLE))\n                .add(new CounterTable(PRODUCT_ACTION_TABLE))\n                .add(new CounterTable(ALL_TIME_SCORE_TABLE))\n                .add(new SortedCounterTable(TOP_SCORE_TABLE))\n                .withFlows()\n                .add(new ClusterWriterFlow())\n                .withProcedures()\n                .add(new ClusterFeedQueryProvider())\n                .build();\n    }","id":87618,"modified_method":"@Override\n  public ApplicationSpecification configure() {\n    return ApplicationSpecification.Builder.with()\n        .setName(APP_NAME)\n        .setDescription(APP_DESC)\n        .withStreams()\n          .add(new Stream(SOCIAL_ACTION_STREAM))\n          .add(new Stream(CLUSTER_STREAM))\n        .withDataSets()\n          .add(new ActivityFeedTable(ACTIVITY_FEED_TABLE))\n          .add(new ClusterTable(CLUSTER_TABLE))\n          .add(new CounterTable(COUNTER_TABLE))\n          .add(new SortedCounterTable(SORTED_COUNTER_TABLE))\n          .add(new CounterTable(PRODUCT_ACTION_TABLE))\n          .add(new CounterTable(ALL_TIME_SCORE_TABLE))\n          .add(new SortedCounterTable(TOP_SCORE_TABLE))\n        .withFlows()\n          .add(new SocialActionFlow())\n          .add(new ClusterWriterFlow())\n        .withProcedures()\n          .add(new ClusterFeedQueryProvider())\n        .build();\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public <T> void put(String key, T o) {\n     String s = gson.get().toJson(o);\n     try {\n         this.table.write(new Write(key.getBytes(Charset.forName(\"UTF-8\")),\n        \"default\".getBytes(Charset.forName(\"UTF-8\")),\n          s.getBytes(Charset.forName(\"UTF-8\"))));\n           } catch (OperationException e) {\n            throw Throwables.propagate(e);\n            }\n       }","id":87619,"modified_method":"public <T> void put(String key, T o) throws OperationException {\n    String s = this.gson.get().toJson(o);\n    this.table.write(new Write(Bytes.toBytes(key), COLUMN,\n        Bytes.toBytes(s)));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public DataSetSpecification configure() {\n     return null;\n     }","id":87620,"modified_method":"@Override\n  public DataSetSpecification configure() {\n    return new DataSetSpecification.Builder(this)\n      .dataset(this.table.configure())\n      .create();\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Nullable\n    public <T> T get(String key, Class<T> keyClass) {\n        try {\n            OperationResult<Map<byte[], byte[]>> result\n                    = this.table.read(new Read(key.getBytes(Charset.forName(\"UTF-8\")),\n                    \"default\".getBytes(Charset.forName(\"UTF-8\"))));\n            if (result == null) {\n                return null;\n            }\n            byte[] value = result.getValue().get(key);\n            return (T) (gson.get().fromJson(new String(value), keyClass));\n        } catch (OperationException e) {\n            throw Throwables.propagate(e);\n        }\n    }","id":87621,"modified_method":"public <T> T get(String key, Class<T> keyClass) throws OperationException {\n    OperationResult<Map<byte[], byte[]>> result\n    = this.table.read(new Read(Bytes.toBytes(key), COLUMN));\n    if (result == null || result.isEmpty()) {\n      return null;\n    }\n    byte[] value = result.getValue().get(key);\n    return (this.gson.get().fromJson(new String(value), keyClass));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public ObjectTable(String name) {\n     super(name);\n     table = new Table(\"o_\" + name);\n     }","id":87622,"modified_method":"public ObjectTable(String name) {\n    super(name);\n    this.table = new Table(\"o_\" + name);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@ProcessInput\n      public void process(SocialAction action) {\n\n          // Determine score increase\n          Long scoreIncrease = 0L;\n          try {\n              scoreIncrease = action.getSocialActionType().getScore();\n          } catch (IllegalArgumentException iae) {\n              Throwables.propagate(iae);\n              return;\n          }\n\n          // Update product action count table async\n          this.productActionCountTable.incrementCounterSet(\n                  Bytes.toBytes(action.product_id), Bytes.toBytes(action.type), 1L);\n\n          // Update all-time score, but put increment into tuple for pass-thru\n          Increment allTimeScore = allTimeScoreTable.generateSingleKeyIncrement(\n                  Bytes.toBytes(action.product_id), scoreIncrease);\n\n          // Outputs\n          ProcessedActionActivity actionActivity = new ProcessedActionActivity();\n          ProcessedActionPopular actionPopular = new ProcessedActionPopular();\n\n\n          actionActivity.socialAction = action;\n          actionActivity.scoreIncrease = scoreIncrease;\n\n          // TODO: check if snapping first value valid\n          actionActivity.allTimeScore = allTimeScore.getValues()[0];\n\n          processedActionActivityOutputEmitter.emit(actionActivity);\n\n\n          try {\n              // For each country, update time bucketed top-score table, put increment\n              // into tuple and emit a tuple for each country\n              for (String country : action.country) {\n\n                  topScoreTable.increment(\n                          PopularFeed.makeRow(Helpers.hour(action.date),\n                                  country, action.category),\n                          Bytes.toBytes(action.product_id), scoreIncrease);\n\n                  actionPopular.socialAction = action;\n                  actionPopular.scoreIncrease = scoreIncrease;\n                  actionPopular.country = country;\n\n                  // TODO: Read top Score hourly from table?\n                  actionPopular.hourlyScore++; // = topScoreHourly.getValues()[0];\n\n                  processedActionPopularOutputEmitter.emit(actionPopular);\n              }\n          } catch (OperationException e) {\n              Throwables.propagate(e);\n          }\n      }","id":87623,"modified_method":"@ProcessInput\n    public void process(SocialAction action) throws OperationException {\n\n      // Determine score increase\n      Long scoreIncrease = action.getSocialActionType().getScore();\n\n      // Update product action count table\n      this.productActionCountTable.incrementCounterSet(\n          Bytes.toBytes(action.product_id), Bytes.toBytes(action.type), 1L);\n\n      // Update all-time score\n      Long allTimeScore = this.allTimeScoreTable.incrementSingleKey(\n          Bytes.toBytes(action.product_id), scoreIncrease);\n\n      ProcessedSocialAction processedAction = new ProcessedSocialAction(\n          action, scoreIncrease, allTimeScore);\n      \n      this.activityUpdater.emit(processedAction);\n\n      // Emit a tuple for each country\n      for (String country : action.country) {\n        this.popularUpdater.emit(\n            new ProcessedSocialActionAndCountry(processedAction, country));\n      }\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@ProcessInput\n    public void process(ProcessedActionActivity processedAction) {\n\n        // Doesn't do anything for now\n        if (!shouldInsertFeedEntry(processedAction.scoreIncrease, processedAction.allTimeScore)) {\n            return;\n        }\n\n        ActivityFeedEntry feedEntry = new ActivityFeedEntry(processedAction.socialAction.date,\n                processedAction.socialAction.store_id, processedAction.socialAction.product_id, processedAction.allTimeScore);\n        for (String country : processedAction.socialAction.country) {\n            activityFeedTable.writeEntry(country, processedAction.socialAction.category, feedEntry);\n        }\n\n        numProcessed++;\n    }","id":87624,"modified_method":"@ProcessInput(\"activity\")\n    public void process(ProcessedSocialAction processedAction)\n        throws OperationException {\n\n      // Doesn't do anything for now\n      if (!shouldInsertFeedEntry(processedAction.scoreIncrease,\n          processedAction.allTimeScore)) {\n        return;\n      }\n\n      ActivityFeedEntry feedEntry = new ActivityFeedEntry(\n          processedAction.socialAction.date,\n          processedAction.socialAction.store_id,\n          processedAction.socialAction.product_id,\n          processedAction.allTimeScore);\n\n      for (String country : processedAction.socialAction.country) {\n        this.activityFeedTable.writeEntry(country,\n            processedAction.socialAction.category, feedEntry);\n      }\n\n      numProcessed++;\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public  FlowSpecification configure() {\n      return FlowSpecification.Builder.with()\n              .setName(flowName)\n              .setDescription(\"\")\n              .withFlowlets()\n              .add(\"action_parser\", new SocialActionParserFlowlet())\n              .add(\"action_processor\", new SocialActionProcessorFlowlet())\n              .add(\"activity_feed_updater\", new ActivityFeedUpdaterFlowlet())\n              .add(\"popular_feed_updater\", new PopularFeedUpdaterFlowlet())\n              .connect()\n              .fromStream(inputStream).to(\"product_parser\")\n              .from(\"product_parser\").to(\"product_processor\")\n              .from(\"product_processor\").to(\"activity_feed_updater\")\n              .build();\n  }","id":87625,"modified_method":"@Override\n  public FlowSpecification configure() {\n    return FlowSpecification.Builder.with()\n        .setName(FLOW_NAME)\n        .setDescription(FLOW_NAME)\n        .withFlowlets()\n          .add(\"action_parser\", new SocialActionParserFlowlet())\n          .add(\"action_processor\", new SocialActionProcessorFlowlet())\n          .add(\"activity_feed_updater\", new ActivityFeedUpdaterFlowlet())\n          .add(\"popular_feed_updater\", new PopularFeedUpdaterFlowlet())\n        .connect()\n          .fromStream(LishApp.SOCIAL_ACTION_STREAM).to(\"action_parser\")\n          .from(\"action_parser\").to(\"action_processor\")\n          .from(\"action_processor\").to(\"activity_feed_updater\")\n          .from(\"action_processor\").to(\"popular_feed_updater\")\n        .build();\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@ProcessInput(SocialActionFlow.inputStream)\n    public void process(StreamEvent event) {\n        String jsonEventString = new String(Bytes.toBytes(event.getBody()));\n\n        // Perform any necessary pre-processing\n        jsonEventString = preProcessSocialActionJSON(jsonEventString);\n\n        // Parse social action JSON using GSON\n        SocialAction action = null;\n        try {\n            action =\n                    this.gson.fromJson(jsonEventString, SocialAction.class);\n        } catch (JsonParseException jpe) {\n            Throwables.propagate(jpe);\n        } finally {\n\n            // Emit tuple\n            socialActionOutputEmitter.emit(action);\n            numProcessed++;\n        }\n    }","id":87626,"modified_method":"@ProcessInput\n  public void process(StreamEvent event) {\n    String jsonEventString = new String(Bytes.toBytes(event.getBody()));\n\n    // Perform any necessary pre-processing\n    jsonEventString = preProcessSocialActionJSON(jsonEventString);\n\n    // Parse social action JSON using GSON\n    SocialAction action = null;\n    try {\n      action =\n          this.gson.fromJson(jsonEventString, SocialAction.class);\n      // Emit tuple\n      this.socialActionOutputEmitter.emit(action);\n    } catch (JsonParseException jpe) {\n      throw jpe;\n    } finally {\n      numProcessed++;\n    }\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Performs a synchronous read operation for the top counters in the specified\n   * counter set, up to the limit.\n   * <p>\n   * Top counter list returned is in descending count order.\n   * @param counterSet counter set name\n   * @param limit maximum number of counters to return\n   * @return list of top counters, in descending count order\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public List<Counter> readTopCounters(byte [] counterSet, int limit)\n    throws OperationException {\n    CounterBucket counterBucket = new CounterBucket();\n    // Build a list of buckets in descending order to be processed\n    List<Long> bucketList = new ArrayList<Long>(this.config.buckets.length);\n    for (int i = this.config.buckets.length - 1 ; i >= 0 ; i--) {\n      bucketList.add(this.config.buckets[i]);\n    }\n    bucketList.add(0L);\n    // Iterate through buckets (descending / reverse order)\n    for (Long bucket : bucketList) {\n      byte [] row = makeRow(counterSet, bucket);\n      // Read all counters in bucket\n\n\n\n      // TODO: This uses Read of all columns not key-value!\n      Read bucketRead = new Read(row, null, null);\n      OperationResult< Map<byte[],byte[]> > result = this.counters.read(bucketRead);\n      // If nothing in this bucket, go to next bucket\n      if (result.isEmpty()) continue;\n      // Iterate through all entries in this bucket (these are ordered by name\n      // not by count, so need to look at all of them, cannot early-out)\n      for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n        byte [] counterName = entry.getKey();\n        long counterValue = Bytes.toLong(entry.getValue()) + bucket;\n        Counter counter = new Counter(counterName, counterValue);\n        counterBucket.add(counter);\n      }\n      // If we have enough counters, we are done\n      if (counterBucket.size() >= limit) break;\n      // Otherwise, keep going to next bucket\n    }\n    // Found enough counters or ran out, get the top results, up to limit\n    return counterBucket.getTop(limit);\n  }","id":87627,"modified_method":"/**\n   * Performs a synchronous read operation for the top counters in the specified\n   * counter set, up to the limit.\n   * <p>\n   * Top counter list returned is in descending count order.\n   * @param counterSet counter set name\n   * @param limit maximum number of counters to return\n   * @return list of top counters, in descending count order\n   * @throws com.continuuity.api.data.OperationException\n   */\n  public List<Counter> readTopCounters(byte [] counterSet, int limit)\n      throws OperationException {\n    CounterBucket counterBucket = new CounterBucket();\n    // Build a list of buckets in descending order to be processed\n    List<Long> bucketList = new ArrayList<Long>(this.config.buckets.length);\n    for (int i = this.config.buckets.length - 1 ; i >= 0 ; i--) {\n      bucketList.add(this.config.buckets[i]);\n    }\n    bucketList.add(0L);\n    // Iterate through buckets (descending / reverse order)\n    for (Long bucket : bucketList) {\n      byte [] row = makeRow(counterSet, bucket);\n      // Read all counters in bucket\n      Read bucketRead = new Read(row);\n      OperationResult< Map<byte[],byte[]> > result =\n          this.counters.read(bucketRead);\n      // If nothing in this bucket, go to next bucket\n      if (result.isEmpty()) continue;\n      // Iterate through all entries in this bucket (these are ordered by name\n      // not by count, so need to look at all of them, cannot early-out)\n      for (Map.Entry<byte[], byte[]> entry : result.getValue().entrySet()) {\n        byte [] counterName = entry.getKey();\n        long counterValue = Bytes.toLong(entry.getValue()) + bucket;\n        Counter counter = new Counter(counterName, counterValue);\n        counterBucket.add(counter);\n      }\n      // If we have enough counters, we are done\n      if (counterBucket.size() >= limit) break;\n      // Otherwise, keep going to next bucket\n    }\n    // Found enough counters or ran out, get the top results, up to limit\n    return counterBucket.getTop(limit);\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public long[] getBuckets() {\n      return buckets;\n    }","id":87628,"modified_method":"public long[] getBuckets() {\n      return this.buckets;\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public SortedCounterConfig() {\n      buckets = new long [] { 10, 100, 1000 };\n\n    }","id":87629,"modified_method":"public SortedCounterConfig() {\n      this.buckets = new long [] { 10, 100, 1000 };\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public SortedCounterTable(String name) {\n        super(name);\n        this.counters = new Table(this.getName());\n        this.config = new SortedCounterConfig();\n    }","id":87630,"modified_method":"public SortedCounterTable(String name) {\n    super(name);\n    this.counters = new Table(\"sct_\" + name);\n    this.config = new SortedCounterConfig();\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public String toString() {\n      StringBuilder builder = new StringBuilder();\n      for (long i : buckets) {\n        builder.append(i);\n        builder.append(\" \");\n      }\n      return builder.toString();\n    }","id":87631,"modified_method":"@Override\n    public String toString() {\n      StringBuilder builder = new StringBuilder();\n      for (long i : this.buckets) {\n        builder.append(i);\n        builder.append(\" \");\n      }\n      return builder.toString().trim();\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public SortedCounterConfig(String serialized) {\n      String[] strings = serialized.split(\" \");\n      buckets = new long[strings.length];\n      for (int i = 0; i < strings.length; ++i) {\n        buckets[i] = Long.parseLong(strings[i]);\n      }\n    }","id":87632,"modified_method":"public SortedCounterConfig(String serialized) {\n      String[] strings = serialized.split(\" \");\n      this.buckets = new long[strings.length];\n      for (int i = 0; i < strings.length; ++i) {\n        this.buckets[i] = Long.parseLong(strings[i]);\n      }\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"void add(Counter counter) {\n      counterSet.add(counter);\n    }","id":87633,"modified_method":"void add(Counter counter) {\n      this.counterSet.add(counter);\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"public SortedCounterTable(DataSetSpecification spec) {\n    super(spec);\n    this.config = new SortedCounterConfig(spec.getProperty(\"config\"));\n    this.counters = new Table(spec.getSpecificationFor(this.getName()));\n  }","id":87634,"modified_method":"public SortedCounterTable(DataSetSpecification spec) {\n    super(spec);\n    this.counters = new Table(\"sct_\" + getName());\n    this.config = new SortedCounterConfig(spec.getProperty(\"config\"));\n  }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * Returns the counters with the highest counts, up to the specified limit.\n     * <p>\n     * This is an expensive operation and does not cache the result!\n     * @param limit maximum counters to return\n     * @return list of counters with highest counts, in descending count order\n     */\n    List<Counter> getTop(int limit) {\n      /*\n       * Ordered map of top counters.  Comparator will sort map in descending\n       * count order, and then ascending counter order for tied count.\n       */\n      NavigableMap<Counter,Counter> topMap = new TreeMap<Counter,Counter>(\n        new Comparator<Counter>() {\n          @Override\n          public int compare(Counter left, Counter right) {\n            if (left.count > right.count) return -1;\n            if (left.count < right.count) return 1;\n            return Bytes.compareTo(left.name, right.name);\n          }\n        });\n      // Add everything to the map\n      for (Counter counter : counterSet) topMap.put(counter, counter);\n      // Grab up to n (min of limit/total found)\n      int n = Math.min(limit, topMap.size());\n      List<Counter> top = new ArrayList<Counter>(n);\n      Iterator<Counter> topIterator = topMap.keySet().iterator();\n      for (int i=0; i<n; i++) {\n        top.add(topIterator.next());\n      }\n      return top;\n    }","id":87635,"modified_method":"/**\n     * Returns the counters with the highest counts, up to the specified limit.\n     * <p>\n     * This is an expensive operation and does not cache the result!\n     * @param limit maximum counters to return\n     * @return list of counters with highest counts, in descending count order\n     */\n    List<Counter> getTop(int limit) {\n      /*\n       * Ordered map of top counters.  Comparator will sort map in descending\n       * count order, and then ascending counter order for tied count.\n       */\n      NavigableMap<Counter,Counter> topMap = new TreeMap<Counter,Counter>(\n          new Comparator<Counter>() {\n            @Override\n            public int compare(Counter left, Counter right) {\n              if (left.count > right.count) return -1;\n              if (left.count < right.count) return 1;\n              return Bytes.compareTo(left.name, right.name);\n            }\n          });\n      // Add everything to the map\n      for (Counter counter : this.counterSet) topMap.put(counter, counter);\n      // Grab up to n (min of limit/total found)\n      int n = Math.min(limit, topMap.size());\n      List<Counter> top = new ArrayList<Counter>(n);\n      Iterator<Counter> topIterator = topMap.keySet().iterator();\n      for (int i=0; i<n; i++) {\n        top.add(topIterator.next());\n      }\n      return top;\n    }","commit_id":"04f26bb809a33241aecf2c23d6ceabc527e8bb35","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public ImagePlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);\n        init(context);\n    }","id":87636,"modified_method":"/**\n     * Creates a new instance of this plugin.\n     * \n     * @param name the name of the plugin\n     * @param className the class name\n     * @param context the XWiki context\n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public ImagePlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);\n        init(context);\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void init(XWikiContext context)\n    {\n        super.init(context);\n        initCache(context);\n    }","id":87637,"modified_method":"@Override\n    public void init(XWikiContext context)\n    {\n        super.init(context);\n        initCache(context);\n\n        String defaultQualityParam = context.getWiki().Param(\"xwiki.plugin.image.defaultQuality\");\n        if (!StringUtils.isBlank(defaultQualityParam) && StringUtils.isNumeric(defaultQualityParam.trim())) {\n            try {\n                defaultQuality = Math.max(0, Math.min(1, Float.parseFloat(defaultQualityParam.trim())));\n            } catch (NumberFormatException e) {\n                LOG.warn(String.format(\"Failed to parse xwiki.plugin.image.defaultQuality configuration parameter. \"\n                    + \"Using %s as the default image quality.\", defaultQuality), e);\n            }\n        }\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getHeight(XWikiAttachment attachment, XWikiContext context) throws InterruptedException, XWikiException\n    {\n        Image imgOri = getImage(attachment, context);\n        return imgOri.getHeight(null);\n    }","id":87638,"modified_method":"/**\n     * @param attachment an image attachment\n     * @param context the XWiki context\n     * @return the height of the specified image\n     * @throws IOException if reading the image from the attachment content fails\n     * @throws XWikiException if reading the attachment content fails\n     */\n    public int getHeight(XWikiAttachment attachment, XWikiContext context) throws IOException, XWikiException\n    {\n        return imageProcessor.readImage(attachment.getContentInputStream(context)).getHeight(null);\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public XWikiAttachment getImage(XWikiAttachment attachment, int thumbnailWidth, int thumbnailHeight,\n        XWikiContext context) throws Exception\n    {\n\n        if (getType(attachment.getMimeType(context)) == 0) {\n            throw new PluginException(PLUGIN_NAME, XWikiException.ERROR_XWIKI_NOT_IMPLEMENTED,\n                \"Only JPG, GIF, PNG or BMP images are supported.\");\n        }\n\n        Image imgOri = getImage(attachment, context);\n\n        int imgOriWidth = imgOri.getWidth(null);\n        int imgOriHeight = imgOri.getHeight(null);\n\n        if (thumbnailHeight >= imgOriHeight) {\n            throw new PluginException(PLUGIN_NAME, XWikiException.ERROR_XWIKI_DIFF_METADATA_ERROR,\n                \"Thumbnail image not created: the height is higher than the original one.\");\n        }\n\n        if (thumbnailWidth >= imgOriWidth) {\n            throw new PluginException(PLUGIN_NAME, XWikiException.ERROR_XWIKI_DIFF_METADATA_ERROR,\n                \"Thumbnail image not created: the width is higher than the original one.\");\n        }\n\n        createThumbnail(thumbnailWidth, thumbnailHeight, imgOri, attachment);\n        return attachment;\n    }","id":87639,"modified_method":"/**\n     * Reduces the size (i.e. the number of bytes) of an image by scaling its width and height and by reducing its\n     * compression quality. This helps decreasing the time needed to download the image attachment.\n     * \n     * @param attachment the image to be shrunk\n     * @param requestedWidth the requested width; use a value less than or equal to 0 to preserve image aspect ratio; if\n     *            this is greater than the current width then the image is not resized\n     * @param requestedHeight the requested height; use a value less than or equal to 0 to preserve image aspect ratio;\n     *            if this is greater than the current height then the image is not resized\n     * @param requestedQuality the desired compression quality\n     * @param context the XWiki context\n     * @return the modified image attachment\n     * @throws Exception if shrinking the image fails\n     */\n    private XWikiAttachment shrinkImage(XWikiAttachment attachment, int requestedWidth, int requestedHeight,\n        float requestedQuality, XWikiContext context) throws Exception\n    {\n        Image image = imageProcessor.readImage(attachment.getContentInputStream(context));\n\n        // Compute the new image dimension.\n        int currentWidth = image.getWidth(null);\n        int currentHeight = image.getHeight(null);\n        int[] dimensions = reduceImageDimensions(currentWidth, currentHeight, requestedWidth, requestedHeight);\n\n        float quality = requestedQuality;\n        if (quality < 0) {\n            // If no scaling is needed and the quality parameter is not specified, return the original image.\n            if (dimensions[0] == currentWidth && dimensions[1] == currentHeight) {\n                return attachment;\n            }\n            quality = defaultQuality;\n        }\n\n        // Scale the image to the new dimensions.\n        RenderedImage shrunkImage = imageProcessor.scaleImage(image, dimensions[0], dimensions[1]);\n\n        // Write the shrunk image to a byte array output stream.\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        imageProcessor.writeImage(shrunkImage, attachment.getMimeType(context), quality, bout);\n\n        // Create an image attachment for the shrunk image.\n        XWikiAttachment thumbnail = (XWikiAttachment) attachment.clone();\n        thumbnail.setContent(new ByteArrayInputStream(bout.toByteArray()), bout.size());\n\n        return thumbnail;\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Image getImage(XWikiAttachment attachment, XWikiContext context) throws XWikiException,\n        InterruptedException\n    {\n        Toolkit tk = Toolkit.getDefaultToolkit();\n        Image imgOri = tk.createImage(attachment.getContent(context));\n\n        MediaTracker mediaTracker = new MediaTracker(new Container());\n        mediaTracker.addImage(imgOri, 0);\n        mediaTracker.waitForID(0);\n        return imgOri;\n    }","id":87640,"modified_method":"/**\n     * Transforms the given image (i.e. shrinks the image and changes its quality) before it is downloaded.\n     * \n     * @param image the image to be downloaded\n     * @param width the desired image width; use a value less than or equal to 0 to preserve image aspect ratio; if this\n     *            is greater than the current width then the image is not resized\n     * @param height the desired image height; use a value less than or equal to 0 to preserve image aspect ratio; if\n     *            this is greater than the current height then the image is not resized\n     * @param quality the desired compression quality\n     * @param context the XWiki context\n     * @return the transformed image\n     * @throws Exception if transforming the image fails\n     */\n    private XWikiAttachment downloadImage(XWikiAttachment image, int width, int height, float quality,\n        XWikiContext context) throws Exception\n    {\n        if (imageCache == null) {\n            initCache(context);\n            if (imageCache == null) {\n                return shrinkImage(image, width, height, quality, context);\n            }\n        }\n        String key = String.format(\"%s-%s-%s-%s-%s\", image.getId(), image.getVersion(), width, height, quality);\n        byte[] data = imageCache.get(key);\n        XWikiAttachment thumbnail;\n        if (data != null) {\n            thumbnail = (XWikiAttachment) image.clone();\n            thumbnail.setContent(new ByteArrayInputStream(data), data.length);\n        } else {\n            thumbnail = shrinkImage(image, width, height, quality, context);\n            imageCache.set(key, thumbnail.getContent(context));\n        }\n        return thumbnail;\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void initCache(XWikiContext context)\n    {\n        CacheConfiguration configuration = new CacheConfiguration();\n\n        configuration.setConfigurationId(\"xwiki.plugin.image\");\n\n        // Set folder to store cache\n        File tempDir = context.getWiki().getTempDirectory(context);\n        File imgTempDir = new File(tempDir, configuration.getConfigurationId());\n        try {\n            imgTempDir.mkdirs();\n        } catch (Exception ex) {\n            LOG.warn(\"Cannot create temporary files\", ex);\n        }\n        configuration.put(\"cache.path\", imgTempDir.getAbsolutePath());\n\n        // Set cache constraints\n        LRUEvictionConfiguration lru = new LRUEvictionConfiguration();\n        configuration.put(LRUEvictionConfiguration.CONFIGURATIONID, lru);\n\n        String capacityParam = \"\";\n        try {\n            capacityParam = context.getWiki().Param(\"xwiki.plugin.image.cache.capacity\");\n            if (!StringUtils.isBlank(capacityParam) && StringUtils.isNumeric(capacityParam.trim())) {\n                this.capacity = Integer.parseInt(capacityParam.trim());\n            }\n        } catch (NumberFormatException ex) {\n            LOG.error(\"Error in ImagePlugin reading capacity: \" + capacityParam, ex);\n        }\n        lru.setMaxEntries(this.capacity);\n\n        try {\n            this.imageCache = context.getWiki().getLocalCacheFactory().newCache(configuration);\n        } catch (CacheException e) {\n            LOG.error(\"Error initializing the image cache\", e);\n        }\n    }","id":87641,"modified_method":"/**\n     * Tries to initializes the image cache. If the initialization fails the image cache remains {@code null}.\n     * \n     * @param context the XWiki context\n     */\n    private void initCache(XWikiContext context)\n    {\n        CacheConfiguration configuration = new CacheConfiguration();\n\n        configuration.setConfigurationId(\"xwiki.plugin.image\");\n\n        // Set folder to store cache.\n        File tempDir = context.getWiki().getTempDirectory(context);\n        File imgTempDir = new File(tempDir, configuration.getConfigurationId());\n        try {\n            imgTempDir.mkdirs();\n        } catch (Exception ex) {\n            LOG.warn(\"Cannot create temporary files.\", ex);\n        }\n        configuration.put(\"cache.path\", imgTempDir.getAbsolutePath());\n        // Set cache constraints.\n        LRUEvictionConfiguration lru = new LRUEvictionConfiguration();\n        configuration.put(LRUEvictionConfiguration.CONFIGURATIONID, lru);\n\n        String capacityParam = context.getWiki().Param(\"xwiki.plugin.image.cache.capacity\");\n        if (!StringUtils.isBlank(capacityParam) && StringUtils.isNumeric(capacityParam.trim())) {\n            try {\n                capacity = Integer.parseInt(capacityParam.trim());\n            } catch (NumberFormatException e) {\n                LOG.warn(String.format(\"Failed to parse xwiki.plugin.image.cache.capacity configuration parameter. \"\n                    + \"Using %s as the cache capacity.\", capacity), e);\n            }\n        }\n        lru.setMaxEntries(capacity);\n\n        try {\n            imageCache = context.getWiki().getLocalCacheFactory().newCache(configuration);\n        } catch (CacheException e) {\n            LOG.error(\"Error initializing the image cache.\", e);\n        }\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getWidth(XWikiAttachment attachment, XWikiContext context) throws InterruptedException, XWikiException\n    {\n        Image imgOri = getImage(attachment, context);\n        return imgOri.getWidth(null);\n    }","id":87642,"modified_method":"/**\n     * @param attachment an image attachment\n     * @param context the XWiki context\n     * @return the width of the specified image\n     * @throws IOException if reading the image from the attachment content fails\n     * @throws XWikiException if reading the attachment content fails\n     */\n    public int getWidth(XWikiAttachment attachment, XWikiContext context) throws IOException, XWikiException\n    {\n        return imageProcessor.readImage(attachment.getContentInputStream(context)).getWidth(null);\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Allows to scale images server-side, in order to have real thumbnails for reduced traffic. The new image\n     * dimensions are passed in the request as the {@code width} and {@code height} parameters. If only one of the\n     * dimensions is specified, then the other one is comupted to preserve the original aspect ratio of the image.\n     */\n    @Override\n    public XWikiAttachment downloadAttachment(XWikiAttachment attachment, XWikiContext context)\n    {\n        int height = 0;\n        int width = 0;\n        XWikiAttachment attachmentClone = null;\n\n        if (!this.isSupportedImageFormat(attachment.getMimeType(context))) {\n            return attachment;\n        }\n\n        String sheight = context.getRequest().getParameter(\"height\");\n        String swidth = context.getRequest().getParameter(\"width\");\n\n        // If no scaling is needed, return the original image.\n        if ((StringUtils.isBlank(sheight) || !StringUtils.isNumeric(sheight))\n            && (StringUtils.isBlank(swidth) || !StringUtils.isNumeric(swidth))) {\n            return attachment;\n        }\n\n        if (this.imageCache == null) {\n            initCache(context);\n        }\n\n        try {\n            if (sheight != null) {\n                height = Integer.parseInt(sheight);\n            }\n            if (swidth != null) {\n                width = Integer.parseInt(swidth);\n            }\n\n            attachmentClone = (XWikiAttachment) attachment.clone();\n            String key =\n                attachmentClone.getId() + \"-\" + attachmentClone.getVersion() + \"-\" + SupportedFormat.PNG.getCode()\n                    + \"-\" + width + \"-\" + height;\n\n            if (this.imageCache != null) {\n                byte[] data = this.imageCache.get(key);\n\n                if (data != null) {\n                    attachmentClone.setContent(data);\n                } else {\n                    if (width == 0) {\n                        attachmentClone = this.getImageByHeight(attachmentClone, height, context);\n                    } else if (height == 0) {\n                        attachmentClone = this.getImageByWidth(attachmentClone, width, context);\n                    } else {\n                        attachmentClone = this.getImage(attachmentClone, width, height, context);\n                    }\n\n                    this.imageCache.set(key, attachmentClone.getContent(context));\n                }\n            } else {\n                attachmentClone = this.getImageByHeight(attachmentClone, height, context);\n            }\n        } catch (Exception e) {\n            attachmentClone = attachment;\n        }\n        return attachmentClone;\n    }","id":87643,"modified_method":"/**\n     * {@inheritDoc}\n     * <p>\n     * Allows to scale images server-side, in order to have real thumbnails for reduced traffic. The new image\n     * dimensions are passed in the request as the {@code width} and {@code height} parameters. If only one of the\n     * dimensions is specified, then the other one is computed to preserve the original aspect ratio of the image.\n     * \n     * @see XWikiDefaultPlugin#downloadAttachment(XWikiAttachment, XWikiContext)\n     */\n    @Override\n    public XWikiAttachment downloadAttachment(XWikiAttachment attachment, XWikiContext context)\n    {\n        if (!imageProcessor.isMimeTypeSupported(attachment.getMimeType(context))) {\n            return attachment;\n        }\n\n        int height = -1;\n        try {\n            height = Integer.parseInt(context.getRequest().getParameter(\"height\"));\n        } catch (NumberFormatException e) {\n            // Ignore.\n        }\n\n        int width = -1;\n        try {\n            width = Integer.parseInt(context.getRequest().getParameter(\"width\"));\n        } catch (NumberFormatException e) {\n            // Ignore.\n        }\n\n        float quality = -1;\n        try {\n            quality = Float.parseFloat(context.getRequest().getParameter(\"quality\"));\n        } catch (NumberFormatException e) {\n            // Ignore.\n        } catch (NullPointerException e) {\n            // Ignore.\n        }\n\n        // If no scaling is needed, return the original image.\n        if (height <= 0 && width <= 0 && quality < 0) {\n            return attachment;\n        }\n\n        try {\n            // Transform the image attachment before is it downloaded.\n            return downloadImage(attachment, width, height, quality, context);\n        } catch (Exception e) {\n            LOG.warn(\"Failed to transform image attachment.\", e);\n            return attachment;\n        }\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public ImagePluginAPI(ImagePlugin imagePlugin, XWikiContext context)\n    {\n        super(imagePlugin, context);\n    }","id":87644,"modified_method":"/**\n     * Creates a new instance of this plugin API.\n     * \n     * @param imagePlugin the underlying image plugin that is exposed by this API\n     * @param context the XWiki context\n     */\n    public ImagePluginAPI(ImagePlugin imagePlugin, XWikiContext context)\n    {\n        super(imagePlugin, context);\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getHeight(String pageName, String attachmentName)\n    {\n        try {\n            XWikiAttachment attachment =\n                getXWikiContext().getWiki().getDocument(pageName, getXWikiContext()).getAttachment(attachmentName);\n            return getProtectedPlugin().getHeight(attachment, getXWikiContext());\n        } catch (Exception e) {\n            return -1;\n        }\n    }","id":87645,"modified_method":"/**\n     * Detects the height of an image attached to a wiki page.\n     * \n     * @param pageName the name of a wiki page\n     * @param attachmentName the name of an image attached to the specified page\n     * @return the height of the specified image\n     */\n    public int getHeight(String pageName, String attachmentName)\n    {\n        try {\n            return getProtectedPlugin().getHeight(getAttachment(pageName, attachmentName), getXWikiContext());\n        } catch (Exception e) {\n            LOG.error(String.format(\"Failed to detect the height of %s attached to %s.\", attachmentName, pageName), e);\n            return -1;\n        }\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getWidth(String pageName, String attachmentName)\n    {\n        try {\n            XWikiAttachment attachment =\n                getXWikiContext().getWiki().getDocument(pageName, getXWikiContext()).getAttachment(attachmentName);\n            return getProtectedPlugin().getWidth(attachment, getXWikiContext());\n        } catch (Exception e) {\n            return -1;\n        }\n    }","id":87646,"modified_method":"/**\n     * Detects the width of an image attached to a wiki page.\n     * \n     * @param pageName the name of a wiki page\n     * @param attachmentName the name of an image attached to the specified page\n     * @return the width of the specified image\n     */\n    public int getWidth(String pageName, String attachmentName)\n    {\n        try {\n            return getProtectedPlugin().getWidth(getAttachment(pageName, attachmentName), getXWikiContext());\n        } catch (Exception e) {\n            LOG.error(String.format(\"Failed to detect the width of %s attached to %s.\", attachmentName, pageName), e);\n            return -1;\n        }\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrive the content of this attachment as a byte array.\n     * \n     * @param context current XWikiContext\n     * @return a byte array containing the binary data content of the attachment\n     * @throws XWikiException when an error occurs during wiki operation\n     * @deprecated use {@link #setContent(java.io.InputStream, int)} instead\n     */\n    @Deprecated\n    public byte[] getContent(XWikiContext context) throws XWikiException\n    {\n        if (this.attachment_content == null) {\n            this.doc.loadAttachmentContent(this, context);\n        }\n\n        return this.attachment_content.getContent();\n    }","id":87647,"modified_method":"/**\n     * Retrive the content of this attachment as a byte array.\n     * \n     * @param context current XWikiContext\n     * @return a byte array containing the binary data content of the attachment\n     * @throws XWikiException when an error occurs during wiki operation\n     * @deprecated use {@link #getContentInputStream(XWikiContext)} instead\n     */\n    @Deprecated\n    public byte[] getContent(XWikiContext context) throws XWikiException\n    {\n        if (this.attachment_content == null) {\n            this.doc.loadAttachmentContent(this, context);\n        }\n\n        return this.attachment_content.getContent();\n    }","commit_id":"e50d5c26c96aecb073e8a238b32102b29caa1b58","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static String runU(UStatistic context) {\n        // note: u statistic (U) is relatively useless for recalibrating outside of the context of m and n\n        // thus we report V = (U - (m*n+1)/2)/(n*m*(n+m+1)/12)\n        Pair<Double,Double> results = mannWhitneyUTest(context);\n        return String.format(\"V: %.2f\\tP: %.2e\\tQ: %d\",results.first,results.second,(int)Math.floor(QualityUtils.phredScaleErrorRate(results.second)));\n    }","id":87648,"modified_method":"public static String runU(UStatistic context) {\n        // note: u statistic (U) is relatively useless for recalibrating outside of the context of m and n\n        // thus we report V = (U - (m*n+1)/2)/(n*m*(n+m+1)/12)\n        Pair<Double,Double> results = mannWhitneyUTest(context);\n        return String.format(\"V: %.2f\\tP: %.2e\\tQ: %d\",results.first,results.second,pToQ(results.second));\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static String runZ(ZStatistic context) {\n        Pair<Double,Double> stats = testZ(context);\n        double z = stats.first;\n        double p = stats.second;\n        return String.format(\"Z: %.2f\\tP: %.2e\\tQ: %d\",z,p,(int)Math.floor(QualityUtils.phredScaleErrorRate(p)));\n    }","id":87649,"modified_method":"public static String runZ(ZStatistic context) {\n        Pair<Double,Double> stats = testZ(context);\n        double z = stats.first;\n        double p = stats.second;\n        return String.format(\"Z: %.2f\\tP: %.2e\\tQ: %d\",z,p,pToQ(p));\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static String runStudentT(TStatistic context) {\n        Pair<Double,Double> stats = testStudentT(context);\n        double t = stats.first;\n        double p = stats.second;\n        return String.format(\"T: %.2f\\tP: %.2e\\tQ: %d\",t,p,(int)Math.floor(QualityUtils.phredScaleErrorRate(p)));\n    }","id":87650,"modified_method":"public static String runStudentT(TStatistic context) {\n        Pair<Double,Double> stats = testStudentT(context);\n        double t = stats.first;\n        double p = stats.second;\n        return String.format(\"T: %.2f\\tP: %.2e\\tQ: %d\",t,p,pToQ(p));\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Just gets the Q value associated with a particular association context.\n     * @param context\n     * @return\n     */\n    public static int getQValue(AssociationContext context) {\n        if ( context instanceof TStatistic ) {\n            return pToQ(testStudentT((TStatistic) context).second);\n        }\n\n        if ( context instanceof ZStatistic ) {\n            return pToQ(testZ((ZStatistic) context).second);\n        }\n\n        if ( context instanceof UStatistic ) {\n            return pToQ(mannWhitneyUTest((UStatistic) context).second);\n        }\n\n        return -1;\n    }","id":87651,"modified_method":"public static Pair<Double,Pair<Double,Integer>> getTestValues(AssociationContext context) {\n        if ( context instanceof TStatistic) {\n            Pair<Double,Double> t = testStudentT((TStatistic) context);\n            return new Pair<Double,Pair<Double,Integer>> (t.first,new Pair<Double,Integer>(t.second,pToQ(t.second)));\n        }\n\n        if ( context instanceof ZStatistic) {\n            Pair<Double,Double> z = testZ((ZStatistic) context);\n            return new Pair<Double,Pair<Double,Integer>> (z.first,new Pair<Double,Integer>(z.second,pToQ(z.second)));\n        }\n\n        if ( context instanceof UStatistic ) {\n            Pair<Double,Double> u = mannWhitneyUTest((UStatistic) context);\n            return new Pair<Double,Pair<Double,Integer>> ( u.first, new Pair<Double,Integer>(u.second,pToQ(u.second)));\n        }\n\n        return null;\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Switches what formatting to use based on wiggle or standard\n     * @param wiggleFormat - use wiggle format (just Q) or standard (S: P: Q:)\n     * @return - test results in proper format\n     */\n    public Map<AssociationContext,String> runTests(boolean wiggleFormat) {\n        if ( wiggleFormat ) {\n            return runWiggleTests();\n        } else {\n            return runTests();\n        }\n    }","id":87652,"modified_method":"/**\n     * Switches what formatting to use based on wiggle or standard\n     * @param bedGraphFormat - use bedgraph format (s p q) or standard (S: s P: p Q: q)\n     * @return - test results in proper format\n     */\n    public Map<AssociationContext,String> runTests(boolean bedGraphFormat) {\n        // todo -- maybe the tdf should be the whole window rather than just the most recent loc?\n        Map<AssociationContext,String> testResults = new HashMap<AssociationContext,String>(associations.size());\n        for ( AssociationContext w : associations ) {\n            if ( w.isFull() ) {\n                String outVal;\n                if ( bedGraphFormat ) {\n                    Pair<Double,Pair<Double,Integer>> vals = AssociationTestRunner.getTestValues(w);\n                    outVal = String.format(\"%.2f\\t%.2e\\t%d\",vals.first,vals.second.first,vals.second.second);\n                } else {\n                    outVal = AssociationTestRunner.runTests(w);\n                }\n                testResults.put(w,String.format(\"%s\\t%d\\t%d\\t%s\",maps.getReferenceContext().getLocus().getContig(),\n                        maps.getReferenceContext().getLocus().getStart()-w.getWindowSize()-1,maps.getReferenceContext().getLocus().getStart()+1, outVal));\n                w.slide();\n            }\n        }\n        return testResults;\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String transformArgument(final Class<? extends AssociationContext> context, String arg) {\n        if ( wigOut ) {\n            return String.format(\"%s.%s.wig\",arg,context.getSimpleName());\n        }\n        return String.format(\"%s.%s.tdf\", arg, context.getSimpleName());\n    }","id":87653,"modified_method":"public String transformArgument(final Class<? extends AssociationContext> context, String arg) {\n        if ( bedGraphOut ) {\n            return String.format(\"%s.%s.bedgraph\",arg,context.getSimpleName());\n        }\n        return String.format(\"%s.%s.tdf\", arg, context.getSimpleName());\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public RegionalAssociationMultiplexer(String[] toUse, boolean wiggleOutput) {\n        super();\n        contexts = getAssociations(toUse);\n        wigOut = wiggleOutput;\n    }","id":87654,"modified_method":"public RegionalAssociationMultiplexer(String[] toUse, boolean wiggleOutput) {\n        super();\n        contexts = getAssociations(toUse);\n        bedGraphOut = wiggleOutput;\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void initialize() {\n        if ( wiggleFormat && getToolkit().getIntervals().size() > 1 ) {\n            throw new UserException(\"Wiggle format (fixedStep) is only consistent with a contiguous region (one interval) on one contig. Otherwise use the default output.\");\n        }\n\n        Set<AssociationContext> validAssociations = getAssociations();\n\n        if ( wiggleFormat ) {\n            writeWiggleHeaders(validAssociations);\n        }\n    }","id":87655,"modified_method":"public void initialize() {\n\n        Set<AssociationContext> validAssociations = getAssociations();\n\n        if ( bedGraph ) {\n            writeBedGraphHeaders(validAssociations);\n        }\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public RegionalAssociationHandler reduce(MapHolder map, RegionalAssociationHandler rac) {\n        rac.updateExtender(map);\n        try {\n            rac.runMapReduce();\n        } catch (Exception e) {\n            throw new StingException(\"Error in map reduce\",e);\n        }\n        Map<AssociationContext,String> testsHere = rac.runTests(wiggleFormat);\n        // todo -- really awful shitty formatting\n        if ( testsHere.size() > 0 ) {\n            for ( Map.Entry<AssociationContext,String> result : testsHere.entrySet() ) {\n                out.get(result.getKey().getClass()).printf(\"%s%n\",result.getValue());\n            }\n        }\n        return rac;\n    }","id":87656,"modified_method":"public RegionalAssociationHandler reduce(MapHolder map, RegionalAssociationHandler rac) {\n        rac.updateExtender(map);\n        try {\n            rac.runMapReduce();\n        } catch (Exception e) {\n            throw new StingException(\"Error in map reduce\",e);\n        }\n        Map<AssociationContext,String> testsHere = rac.runTests(bedGraph);\n        // todo -- really awful shitty formatting\n        if ( testsHere.size() > 0 ) {\n            for ( Map.Entry<AssociationContext,String> result : testsHere.entrySet() ) {\n                out.get(result.getKey().getClass()).printf(\"%s%n\",result.getValue());\n            }\n        }\n        return rac;\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void writeWiggleHeaders(Set<AssociationContext> cons) {\n        for ( AssociationContext con : cons ) {\n            GenomeLoc first = getToolkit().getIntervals().iterator().next();\n            String header = String.format(\"fixedStep chrom=%s start=%d step=%d span=%d\",first.getContig(),first.getStart(),con.slideByValue(),con.getWindowSize());\n            out.get(con.getClass()).printf(\"%s%n\",header);\n        }\n    }","id":87657,"modified_method":"public void writeBedGraphHeaders(Set<AssociationContext> cons) {\n        for ( AssociationContext con : cons ) {\n            GenomeLoc first = getToolkit().getIntervals().iterator().next();\n            String header = String.format(\"track type=bedGraph name=%s\",con.getClass().getSimpleName());\n            out.get(con.getClass()).printf(\"%s%n\",header);\n        }\n    }","commit_id":"687b2e51b4ea38dbc953e9fa671d580f8f02d80c","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Just gets the Q value associated with a particular association context.\n     * @param context\n     * @return\n     */\n    public static int getQValue(AssociationContext context) {\n        if ( context instanceof TStatistic ) {\n            return (int) Math.floor(QualityUtils.phredScaleErrorRate(testStudentT((TStatistic) context).second));\n        }\n\n        if ( context instanceof ZStatistic ) {\n            return (int) Math.floor(QualityUtils.phredScaleErrorRate(testZ((ZStatistic) context).second));\n        }\n\n        if ( context instanceof UStatistic ) {\n            return (int) Math.floor(QualityUtils.phredScaleErrorRate(mannWhitneyUTest((UStatistic) context).second));\n        }\n\n        return -1;\n    }","id":87658,"modified_method":"/**\n     * Just gets the Q value associated with a particular association context.\n     * @param context\n     * @return\n     */\n    public static int getQValue(AssociationContext context) {\n        if ( context instanceof TStatistic ) {\n            return pToQ(testStudentT((TStatistic) context).second);\n        }\n\n        if ( context instanceof ZStatistic ) {\n            return pToQ(testZ((ZStatistic) context).second);\n        }\n\n        if ( context instanceof UStatistic ) {\n            return pToQ(mannWhitneyUTest((UStatistic) context).second);\n        }\n\n        return -1;\n    }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87659,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87660,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87661,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87662,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87663,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87664,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87665,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87666,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87667,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87668,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87669,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87670,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87671,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87672,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87673,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87674,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87675,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87676,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87677,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87678,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87679,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87680,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void writeWiggleHeaders(Set<AssociationContext> cons) {\n        for ( AssociationContext con : cons ) {\n            GenomeLoc first = getToolkit().getIntervals().iterator().next();\n            String header = String.format(\"fixedStep\\tchrom=%s,start=%d,step=%d,span=%d\",first.getContig(),first.getStart(),con.slideByValue(),con.getWindowSize());\n            out.get(con.getClass()).printf(\"%s%n\",header);\n        }\n    }","id":87681,"modified_method":"public void writeWiggleHeaders(Set<AssociationContext> cons) {\n        for ( AssociationContext con : cons ) {\n            GenomeLoc first = getToolkit().getIntervals().iterator().next();\n            String header = String.format(\"fixedStep chrom=%s start=%d step=%d span=%d\",first.getContig(),first.getStart(),con.slideByValue(),con.getWindowSize());\n            out.get(con.getClass()).printf(\"%s%n\",header);\n        }\n    }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int slideByValue() { return 25; }","id":87682,"modified_method":"public int slideByValue() { return 10; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getWindowSize() { return 200; }","id":87683,"modified_method":"public int getWindowSize() { return 100; }","commit_id":"31a2575c7bc1485d18ccaa0bc07d608be4d54865","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void start(Properties c, boolean verbose, boolean jmx) throws Exception {\n        String          config_file=\"config.txt\";\n        BufferedReader  fileReader;\n        String          line;\n        String          key, val;\n        StringTokenizer st;\n        Properties      tmp=new Properties();\n\n        config_file=c.getProperty(\"config\");\n        fileReader=new BufferedReader(new FileReader(config_file));\n        while((line=fileReader.readLine()) != null) {\n            if(line.startsWith(\"#\"))\n                continue;\n            line=line.trim();\n            if(line.length() == 0)\n                continue;\n            st=new StringTokenizer(line, \"=\", false);\n            key=st.nextToken().toLowerCase();\n            val=st.nextToken();\n            tmp.put(key, val);\n        }\n        fileReader.close();\n\n        // 'tmp' now contains all properties from the file, now we need to override the ones\n        // passed to us by 'c'\n        tmp.putAll(c);\n        this.config=tmp;\n\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n\\n----------------------- TEST -----------------------\\n\");\n        sb.append(\"Date: \").append(new Date()).append('\\n');\n        sb.append(\"Run by: \").append(System.getProperty(\"user.name\")).append(\"\\n\\n\");\n        if(verbose)\n            sb.append(\"Properties: \").append(printProperties()).append(\"\\n-------------------------\\n\\n\");\n\n        for(Iterator it=this.config.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry=(Map.Entry)it.next();\n            sb.append(entry.getKey()).append(\":\\t\").append(entry.getValue()).append('\\n');\n        }\n        sb.append(\"JGroups version: \").append(Version.printVersion()).append('\\n');\n        System.out.println(\"Configuration is: \" + sb);\n\n        log.info(sb.toString());\n\n        props=this.config.getProperty(\"props\");\n        num_members=Integer.parseInt(this.config.getProperty(\"num_members\"));\n        num_senders=Integer.parseInt(this.config.getProperty(\"num_senders\"));\n        long num_msgs=Long.parseLong(this.config.getProperty(\"num_msgs\"));\n        this.num_msgs_expected=num_senders * num_msgs;\n        sender=Boolean.valueOf(this.config.getProperty(\"sender\")).booleanValue();\n        msg_size=Long.parseLong(this.config.getProperty(\"msg_size\"));\n        String tmp2=this.config.getProperty(\"dump_transport_stats\", \"false\");\n        if(Boolean.valueOf(tmp2).booleanValue())\n            this.dump_transport_stats=true;\n        tmp2=this.config.getProperty(\"log_interval\");\n        if(tmp2 != null)\n            log_interval=Long.parseLong(tmp2);\n\n        sb=new StringBuffer();\n        sb.append(\"\\n##### msgs_received\");\n        sb.append(\", current time (in ms)\");\n        sb.append(\", msgs/sec\");\n        sb.append(\", throughput/sec [KB]\");\n        sb.append(\", free_mem [KB] \");\n        sb.append(\", total_mem [KB] \");\n        if(log.isInfoEnabled()) log.info(sb.toString());\n\n        if(jmx) {\n            this.config.setProperty(\"jmx\", \"true\");\n        }\n        this.jmx=new Boolean(this.config.getProperty(\"jmx\")).booleanValue();\n        String transport_name=this.config.getProperty(\"transport\");\n        transport=(Transport)Util.loadClass(transport_name, this.getClass()).newInstance();\n        transport.create(this.config);\n        transport.setReceiver(this);\n        transport.start();\n        local_addr=transport.getLocalAddress();\n    }","id":87684,"modified_method":"public void start(Properties c, boolean verbose, boolean jmx, String output) throws Exception {\n        String          config_file=\"config.txt\";\n        BufferedReader  fileReader;\n        String          line;\n        String          key, val;\n        StringTokenizer st;\n        Properties      tmp=new Properties();\n\n        if(output != null)\n            this.output=new FileWriter(output, false);\n\n        config_file=c.getProperty(\"config\");\n        fileReader=new BufferedReader(new FileReader(config_file));\n        while((line=fileReader.readLine()) != null) {\n            if(line.startsWith(\"#\"))\n                continue;\n            line=line.trim();\n            if(line.length() == 0)\n                continue;\n            st=new StringTokenizer(line, \"=\", false);\n            key=st.nextToken().toLowerCase();\n            val=st.nextToken();\n            tmp.put(key, val);\n        }\n        fileReader.close();\n\n        // 'tmp' now contains all properties from the file, now we need to override the ones\n        // passed to us by 'c'\n        tmp.putAll(c);\n        this.config=tmp;\n\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n\\n----------------------- TEST -----------------------\\n\");\n        sb.append(\"Date: \").append(new Date()).append('\\n');\n        sb.append(\"Run by: \").append(System.getProperty(\"user.name\")).append(\"\\n\\n\");\n        if(verbose)\n            sb.append(\"Properties: \").append(printProperties()).append(\"\\n-------------------------\\n\\n\");\n\n        for(Iterator it=this.config.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry=(Map.Entry)it.next();\n            sb.append(entry.getKey()).append(\":\\t\").append(entry.getValue()).append('\\n');\n        }\n        sb.append(\"JGroups version: \").append(Version.printVersion()).append('\\n');\n        System.out.println(\"Configuration is: \" + sb);\n\n        output(sb.toString());\n\n        props=this.config.getProperty(\"props\");\n        num_members=Integer.parseInt(this.config.getProperty(\"num_members\"));\n        num_senders=Integer.parseInt(this.config.getProperty(\"num_senders\"));\n        long num_msgs=Long.parseLong(this.config.getProperty(\"num_msgs\"));\n        this.num_msgs_expected=num_senders * num_msgs;\n        sender=Boolean.valueOf(this.config.getProperty(\"sender\")).booleanValue();\n        msg_size=Long.parseLong(this.config.getProperty(\"msg_size\"));\n        String tmp2=this.config.getProperty(\"dump_transport_stats\", \"false\");\n        if(Boolean.valueOf(tmp2).booleanValue())\n            this.dump_transport_stats=true;\n        tmp2=this.config.getProperty(\"log_interval\");\n        if(tmp2 != null)\n            log_interval=Long.parseLong(tmp2);\n\n        sb=new StringBuffer();\n        sb.append(\"\\n##### msgs_received\");\n        sb.append(\", current time (in ms)\");\n        sb.append(\", msgs/sec\");\n        sb.append(\", throughput/sec [KB]\");\n        sb.append(\", free_mem [KB] \");\n        sb.append(\", total_mem [KB] \");\n        output(sb.toString());\n\n        if(jmx) {\n            this.config.setProperty(\"jmx\", \"true\");\n        }\n        this.jmx=new Boolean(this.config.getProperty(\"jmx\")).booleanValue();\n        String transport_name=this.config.getProperty(\"transport\");\n        transport=(Transport)Util.loadClass(transport_name, this.getClass()).newInstance();\n        transport.create(this.config);\n        transport.setReceiver(this);\n        transport.start();\n        local_addr=transport.getLocalAddress();\n    }","commit_id":"74cea800fef5a41d42e012c8465773c4c06fbecb","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void main(String[] args) {\n        Properties config=new Properties();\n        boolean sender=false, verbose=false, jmx=false, dump_stats=false; // dumps at end of run\n        Test t=null;\n\n        for(int i=0; i < args.length; i++) {\n            if(\"-sender\".equals(args[i])) {\n                config.put(\"sender\", \"true\");\n                sender=true;\n                continue;\n            }\n            if(\"-receiver\".equals(args[i])) {\n                config.put(\"sender\", \"false\");\n                sender=false;\n                continue;\n            }\n            if(\"-config\".equals(args[i])) {\n                String config_file=args[++i];\n                config.put(\"config\", config_file);\n                continue;\n            }\n            if(\"-props\".equals(args[i])) {\n                String props=args[++i];\n                config.put(\"props\", props);\n                continue;\n            }\n            if(\"-verbose\".equals(args[i])) {\n                verbose=true;\n                continue;\n            }\n            if(\"-jmx\".equals(args[i])) {\n                jmx=true;\n                continue;\n            }\n            if(\"-dump_stats\".equals(args[i])) {\n                dump_stats=true;\n                continue;\n            }\n            help();\n            return;\n        }\n\n        try {\n            t=new Test();\n            t.start(config, verbose, jmx);\n            t.runDiscoveryPhase();\n            if(sender) {\n                t.sendMessages();\n            }\n            synchronized(t) {\n                while(t.receivedFinalResults() == false) {\n                    t.wait(2000);\n                }\n            }\n            if(dump_stats) {\n                String stats=t.dumpTransportStats();\n                System.out.println(\"\\nTransport statistics:\\n\" + stats);\n            }\n            if(t.jmx) {\n                System.out.println(\"jmx=true: not terminating\");\n                if(t != null) {\n                    t.stop();\n                    t=null;\n                }\n                while(true) {\n                    Util.sleep(60000);\n                }\n            }\n        }\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n            if(t != null) {\n                t.stop();\n            }\n        }\n    }","id":87685,"modified_method":"public static void main(String[] args) {\n        Properties config=new Properties();\n        boolean sender=false, verbose=false, jmx=false, dump_stats=false; // dumps at end of run\n        Test t=null;\n        String output=null;\n\n        for(int i=0; i < args.length; i++) {\n            if(\"-sender\".equals(args[i])) {\n                config.put(\"sender\", \"true\");\n                sender=true;\n                continue;\n            }\n            if(\"-receiver\".equals(args[i])) {\n                config.put(\"sender\", \"false\");\n                sender=false;\n                continue;\n            }\n            if(\"-config\".equals(args[i])) {\n                String config_file=args[++i];\n                config.put(\"config\", config_file);\n                continue;\n            }\n            if(\"-props\".equals(args[i])) {\n                String props=args[++i];\n                config.put(\"props\", props);\n                continue;\n            }\n            if(\"-verbose\".equals(args[i])) {\n                verbose=true;\n                continue;\n            }\n            if(\"-jmx\".equals(args[i])) {\n                jmx=true;\n                continue;\n            }\n            if(\"-dump_stats\".equals(args[i])) {\n                dump_stats=true;\n                continue;\n            }\n            if(\"-f\".equals(args[i])) {\n                output=args[++i];\n                continue;\n            }\n            help();\n            return;\n        }\n\n        try {\n            t=new Test();\n            t.start(config, verbose, jmx, output);\n            t.runDiscoveryPhase();\n            if(sender) {\n                t.sendMessages();\n            }\n            synchronized(t) {\n                while(t.receivedFinalResults() == false) {\n                    t.wait(2000);\n                }\n            }\n            if(dump_stats) {\n                String stats=t.dumpTransportStats();\n                System.out.println(\"\\nTransport statistics:\\n\" + stats);\n            }\n            if(t.jmx) {\n                System.out.println(\"jmx=true: not terminating\");\n                if(t != null) {\n                    t.stop();\n                    t=null;\n                }\n                while(true) {\n                    Util.sleep(60000);\n                }\n            }\n        }\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n            if(t != null) {\n                t.stop();\n            }\n        }\n    }","commit_id":"74cea800fef5a41d42e012c8465773c4c06fbecb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        if(transport != null) {\n            transport.stop();\n            transport.destroy();\n        }\n        if(response_sender != null) {\n            response_sender.shutdownNow();\n        }\n    }","id":87686,"modified_method":"public void stop() {\n        if(transport != null) {\n            transport.stop();\n            transport.destroy();\n        }\n        if(response_sender != null) {\n            response_sender.shutdownNow();\n        }\n        if(this.output != null) {\n            try {\n                this.output.close();\n            }\n            catch(IOException e) {\n            }\n        }\n    }","commit_id":"74cea800fef5a41d42e012c8465773c4c06fbecb","url":"https://github.com/belaban/JGroups"},{"original_method":"private void dumpResults(Map final_results) {\n        Object      member;\n        Map.Entry   entry;\n        MemberInfo  val;\n        double      combined_msgs_sec, tmp=0;\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n-- results:\\n\");\n\n        for(Iterator it=final_results.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            member=entry.getKey();\n            val=(MemberInfo)entry.getValue();\n            tmp+=val.getMessageSec();\n            sb.append(\"\\n\").append(member);\n            if(member.equals(local_addr))\n                sb.append(\" (myself)\");\n            sb.append(\":\\n\");\n            sb.append(val);\n            sb.append('\\n');\n        }\n        combined_msgs_sec=tmp / final_results.size();\n        sb.append(\"\\ncombined: \").append(f.format(combined_msgs_sec)).\n                append(\" msgs/sec averaged over all receivers\\n\");\n        System.out.println(sb.toString());\n        if(log.isInfoEnabled()) log.info(sb.toString());\n    }","id":87687,"modified_method":"private void dumpResults(Map final_results) {\n        Object      member;\n        Map.Entry   entry;\n        MemberInfo  val;\n        double      combined_msgs_sec, tmp=0;\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n-- results:\\n\");\n\n        for(Iterator it=final_results.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            member=entry.getKey();\n            val=(MemberInfo)entry.getValue();\n            tmp+=val.getMessageSec();\n            sb.append(\"\\n\").append(member);\n            if(member.equals(local_addr))\n                sb.append(\" (myself)\");\n            sb.append(\":\\n\");\n            sb.append(val);\n            sb.append('\\n');\n        }\n        combined_msgs_sec=tmp / final_results.size();\n        sb.append(\"\\ncombined: \").append(f.format(combined_msgs_sec)).\n                append(\" msgs/sec averaged over all receivers\\n\");\n        System.out.println(sb.toString());\n        output(sb.toString());\n    }","commit_id":"74cea800fef5a41d42e012c8465773c4c06fbecb","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleData(Object sender, int num_bytes) {\n        if(all_received)\n            return;\n        if(start == 0) {\n            start=System.currentTimeMillis();\n        }\n\n        num_msgs_received++;\n        num_bytes_received+=num_bytes;\n\n        if(num_msgs_received >= num_msgs_expected) {\n            if(stop == 0)\n                stop=System.currentTimeMillis();\n            all_received=true;\n        }\n\n        if(num_msgs_received % log_interval == 0)\n            System.out.println(new StringBuffer(\"-- received \").append(num_msgs_received).append(\" messages\"));\n\n        if(counter % log_interval == 0) {\n            if(log.isInfoEnabled()) log.info(dumpStats(counter));\n        }\n\n        MemberInfo info=(MemberInfo)this.senders.get(sender);\n        if(info != null) {\n            if(info.start == 0)\n                info.start=System.currentTimeMillis();\n            info.num_msgs_received++;\n            counter++;\n            info.total_bytes_received+=num_bytes;\n            if(info.num_msgs_received >= info.num_msgs_expected) {\n                info.done=true;\n                if(info.stop == 0)\n                    info.stop=System.currentTimeMillis();\n            }\n        }\n        else {\n            log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n        }\n\n        if(all_received) {\n            if(!this.sender)\n                dumpSenders();\n            publisher.start();\n        }\n    }","id":87688,"modified_method":"private void handleData(Object sender, int num_bytes) {\n        if(all_received)\n            return;\n        if(start == 0) {\n            start=System.currentTimeMillis();\n        }\n\n        num_msgs_received++;\n        num_bytes_received+=num_bytes;\n\n        if(num_msgs_received >= num_msgs_expected) {\n            if(stop == 0)\n                stop=System.currentTimeMillis();\n            all_received=true;\n        }\n\n        if(num_msgs_received % log_interval == 0)\n            System.out.println(new StringBuffer(\"-- received \").append(num_msgs_received).append(\" messages\"));\n\n        if(counter % log_interval == 0) {\n            output(dumpStats(counter));\n        }\n\n        MemberInfo info=(MemberInfo)this.senders.get(sender);\n        if(info != null) {\n            if(info.start == 0)\n                info.start=System.currentTimeMillis();\n            info.num_msgs_received++;\n            counter++;\n            info.total_bytes_received+=num_bytes;\n            if(info.num_msgs_received >= info.num_msgs_expected) {\n                info.done=true;\n                if(info.stop == 0)\n                    info.stop=System.currentTimeMillis();\n            }\n        }\n        else {\n            log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n        }\n\n        if(all_received) {\n            if(!this.sender)\n                dumpSenders();\n            publisher.start();\n        }\n    }","commit_id":"74cea800fef5a41d42e012c8465773c4c06fbecb","url":"https://github.com/belaban/JGroups"},{"original_method":"static void help() {\n        System.out.println(\"Test [-help] ([-sender] | [-receiver]) \" +\n                           \"[-config <config file>] [-props <stack config>] [-verbose] [-jmx] [-dump_stats]\");\n    }","id":87689,"modified_method":"static void help() {\n        System.out.println(\"Test [-help] ([-sender] | [-receiver]) \" +\n                \"[-config <config file>] \" +\n                \"[-props <stack config>] [-verbose] [-jmx] \" +\n                \"[-dump_stats] [-f <filename>]\");\n    }","commit_id":"74cea800fef5a41d42e012c8465773c4c06fbecb","url":"https://github.com/belaban/JGroups"},{"original_method":"public void stop() {\n        if(transport != null) {\n            transport.stop();\n            transport.destroy();\n        }\n        if(response_sender != null) {\n            response_sender.shutdownNow();\n        }\n    }","id":87690,"modified_method":"public void stop() {\n        if(transport != null) {\n            transport.stop();\n            transport.destroy();\n        }\n        if(response_sender != null) {\n            response_sender.shutdownNow();\n        }\n        if(this.output != null) {\n            try {\n                this.output.close();\n            }\n            catch(IOException e) {\n            }\n        }\n    }","commit_id":"711961ca25826c9ba35309a64104d9fb1c650ffe","url":"https://github.com/belaban/JGroups"},{"original_method":"private void handleData(Object sender, int num_bytes) {\n        if(all_received)\n            return;\n        if(start == 0) {\n            start=System.currentTimeMillis();\n        }\n\n        num_msgs_received++;\n        num_bytes_received+=num_bytes;\n\n        if(num_msgs_received >= num_msgs_expected) {\n            if(stop == 0)\n                stop=System.currentTimeMillis();\n            all_received=true;\n        }\n\n        if(num_msgs_received % log_interval == 0)\n            System.out.println(new StringBuffer(\"-- received \").append(num_msgs_received).append(\" messages\"));\n\n        if(counter % log_interval == 0) {\n            if(log.isInfoEnabled()) log.info(dumpStats(counter));\n        }\n\n        MemberInfo info=(MemberInfo)this.senders.get(sender);\n        if(info != null) {\n            if(info.start == 0)\n                info.start=System.currentTimeMillis();\n            info.num_msgs_received++;\n            counter++;\n            info.total_bytes_received+=num_bytes;\n            if(info.num_msgs_received >= info.num_msgs_expected) {\n                info.done=true;\n                if(info.stop == 0)\n                    info.stop=System.currentTimeMillis();\n            }\n        }\n        else {\n            log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n        }\n\n        if(all_received) {\n            if(!this.sender)\n                dumpSenders();\n            publisher.start();\n        }\n    }","id":87691,"modified_method":"private void handleData(Object sender, int num_bytes) {\n        if(all_received)\n            return;\n        if(start == 0) {\n            start=System.currentTimeMillis();\n        }\n\n        num_msgs_received++;\n        num_bytes_received+=num_bytes;\n\n        if(num_msgs_received >= num_msgs_expected) {\n            if(stop == 0)\n                stop=System.currentTimeMillis();\n            all_received=true;\n        }\n\n        if(num_msgs_received % log_interval == 0)\n            System.out.println(new StringBuffer(\"-- received \").append(num_msgs_received).append(\" messages\"));\n\n        if(counter % log_interval == 0) {\n            output(dumpStats(counter));\n        }\n\n        MemberInfo info=(MemberInfo)this.senders.get(sender);\n        if(info != null) {\n            if(info.start == 0)\n                info.start=System.currentTimeMillis();\n            info.num_msgs_received++;\n            counter++;\n            info.total_bytes_received+=num_bytes;\n            if(info.num_msgs_received >= info.num_msgs_expected) {\n                info.done=true;\n                if(info.stop == 0)\n                    info.stop=System.currentTimeMillis();\n            }\n        }\n        else {\n            log.error(\"-- sender \" + sender + \" not found in senders hashmap\");\n        }\n\n        if(all_received) {\n            if(!this.sender)\n                dumpSenders();\n            publisher.start();\n        }\n    }","commit_id":"711961ca25826c9ba35309a64104d9fb1c650ffe","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void main(String[] args) {\n        Properties config=new Properties();\n        boolean sender=false, verbose=false, jmx=false, dump_stats=false; // dumps at end of run\n        Test t=null;\n\n        for(int i=0; i < args.length; i++) {\n            if(\"-sender\".equals(args[i])) {\n                config.put(\"sender\", \"true\");\n                sender=true;\n                continue;\n            }\n            if(\"-receiver\".equals(args[i])) {\n                config.put(\"sender\", \"false\");\n                sender=false;\n                continue;\n            }\n            if(\"-config\".equals(args[i])) {\n                String config_file=args[++i];\n                config.put(\"config\", config_file);\n                continue;\n            }\n            if(\"-props\".equals(args[i])) {\n                String props=args[++i];\n                config.put(\"props\", props);\n                continue;\n            }\n            if(\"-verbose\".equals(args[i])) {\n                verbose=true;\n                continue;\n            }\n            if(\"-jmx\".equals(args[i])) {\n                jmx=true;\n                continue;\n            }\n            if(\"-dump_stats\".equals(args[i])) {\n                dump_stats=true;\n                continue;\n            }\n            help();\n            return;\n        }\n\n        try {\n            t=new Test();\n            t.start(config, verbose, jmx);\n            t.runDiscoveryPhase();\n            if(sender) {\n                t.sendMessages();\n            }\n            synchronized(t) {\n                while(t.receivedFinalResults() == false) {\n                    t.wait(2000);\n                }\n            }\n            if(dump_stats) {\n                String stats=t.dumpTransportStats();\n                System.out.println(\"\\nTransport statistics:\\n\" + stats);\n            }\n            if(t.jmx) {\n                System.out.println(\"jmx=true: not terminating\");\n                if(t != null) {\n                    t.stop();\n                    t=null;\n                }\n                while(true) {\n                    Util.sleep(60000);\n                }\n            }\n        }\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n            if(t != null) {\n                t.stop();\n            }\n        }\n    }","id":87692,"modified_method":"public static void main(String[] args) {\n        Properties config=new Properties();\n        boolean sender=false, verbose=false, jmx=false, dump_stats=false; // dumps at end of run\n        Test t=null;\n        String output=null;\n\n        for(int i=0; i < args.length; i++) {\n            if(\"-sender\".equals(args[i])) {\n                config.put(\"sender\", \"true\");\n                sender=true;\n                continue;\n            }\n            if(\"-receiver\".equals(args[i])) {\n                config.put(\"sender\", \"false\");\n                sender=false;\n                continue;\n            }\n            if(\"-config\".equals(args[i])) {\n                String config_file=args[++i];\n                config.put(\"config\", config_file);\n                continue;\n            }\n            if(\"-props\".equals(args[i])) {\n                String props=args[++i];\n                config.put(\"props\", props);\n                continue;\n            }\n            if(\"-verbose\".equals(args[i])) {\n                verbose=true;\n                continue;\n            }\n            if(\"-jmx\".equals(args[i])) {\n                jmx=true;\n                continue;\n            }\n            if(\"-dump_stats\".equals(args[i])) {\n                dump_stats=true;\n                continue;\n            }\n            if(\"-f\".equals(args[i])) {\n                output=args[++i];\n                continue;\n            }\n            help();\n            return;\n        }\n\n        try {\n            t=new Test();\n            t.start(config, verbose, jmx, output);\n            t.runDiscoveryPhase();\n            if(sender) {\n                t.sendMessages();\n            }\n            synchronized(t) {\n                while(t.receivedFinalResults() == false) {\n                    t.wait(2000);\n                }\n            }\n            if(dump_stats) {\n                String stats=t.dumpTransportStats();\n                System.out.println(\"\\nTransport statistics:\\n\" + stats);\n            }\n            if(t.jmx) {\n                System.out.println(\"jmx=true: not terminating\");\n                if(t != null) {\n                    t.stop();\n                    t=null;\n                }\n                while(true) {\n                    Util.sleep(60000);\n                }\n            }\n        }\n        catch(Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n            if(t != null) {\n                t.stop();\n            }\n        }\n    }","commit_id":"711961ca25826c9ba35309a64104d9fb1c650ffe","url":"https://github.com/belaban/JGroups"},{"original_method":"private void dumpResults(Map final_results) {\n        Object      member;\n        Map.Entry   entry;\n        MemberInfo  val;\n        double      combined_msgs_sec, tmp=0;\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n-- results:\\n\");\n\n        for(Iterator it=final_results.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            member=entry.getKey();\n            val=(MemberInfo)entry.getValue();\n            tmp+=val.getMessageSec();\n            sb.append(\"\\n\").append(member);\n            if(member.equals(local_addr))\n                sb.append(\" (myself)\");\n            sb.append(\":\\n\");\n            sb.append(val);\n            sb.append('\\n');\n        }\n        combined_msgs_sec=tmp / final_results.size();\n        sb.append(\"\\ncombined: \").append(f.format(combined_msgs_sec)).\n                append(\" msgs/sec averaged over all receivers\\n\");\n        System.out.println(sb.toString());\n        if(log.isInfoEnabled()) log.info(sb.toString());\n    }","id":87693,"modified_method":"private void dumpResults(Map final_results) {\n        Object      member;\n        Map.Entry   entry;\n        MemberInfo  val;\n        double      combined_msgs_sec, tmp=0;\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n-- results:\\n\");\n\n        for(Iterator it=final_results.entrySet().iterator(); it.hasNext();) {\n            entry=(Map.Entry)it.next();\n            member=entry.getKey();\n            val=(MemberInfo)entry.getValue();\n            tmp+=val.getMessageSec();\n            sb.append(\"\\n\").append(member);\n            if(member.equals(local_addr))\n                sb.append(\" (myself)\");\n            sb.append(\":\\n\");\n            sb.append(val);\n            sb.append('\\n');\n        }\n        combined_msgs_sec=tmp / final_results.size();\n        sb.append(\"\\ncombined: \").append(f.format(combined_msgs_sec)).\n                append(\" msgs/sec averaged over all receivers\\n\");\n        System.out.println(sb.toString());\n        output(sb.toString());\n    }","commit_id":"711961ca25826c9ba35309a64104d9fb1c650ffe","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start(Properties c, boolean verbose, boolean jmx) throws Exception {\n        String          config_file=\"config.txt\";\n        BufferedReader  fileReader;\n        String          line;\n        String          key, val;\n        StringTokenizer st;\n        Properties      tmp=new Properties();\n\n        config_file=c.getProperty(\"config\");\n        fileReader=new BufferedReader(new FileReader(config_file));\n        while((line=fileReader.readLine()) != null) {\n            if(line.startsWith(\"#\"))\n                continue;\n            line=line.trim();\n            if(line.length() == 0)\n                continue;\n            st=new StringTokenizer(line, \"=\", false);\n            key=st.nextToken().toLowerCase();\n            val=st.nextToken();\n            tmp.put(key, val);\n        }\n        fileReader.close();\n\n        // 'tmp' now contains all properties from the file, now we need to override the ones\n        // passed to us by 'c'\n        tmp.putAll(c);\n        this.config=tmp;\n\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n\\n----------------------- TEST -----------------------\\n\");\n        sb.append(\"Date: \").append(new Date()).append('\\n');\n        sb.append(\"Run by: \").append(System.getProperty(\"user.name\")).append(\"\\n\\n\");\n        if(verbose)\n            sb.append(\"Properties: \").append(printProperties()).append(\"\\n-------------------------\\n\\n\");\n\n        for(Iterator it=this.config.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry=(Map.Entry)it.next();\n            sb.append(entry.getKey()).append(\":\\t\").append(entry.getValue()).append('\\n');\n        }\n        sb.append(\"JGroups version: \").append(Version.printVersion()).append('\\n');\n        System.out.println(\"Configuration is: \" + sb);\n\n        log.info(sb.toString());\n\n        props=this.config.getProperty(\"props\");\n        num_members=Integer.parseInt(this.config.getProperty(\"num_members\"));\n        num_senders=Integer.parseInt(this.config.getProperty(\"num_senders\"));\n        long num_msgs=Long.parseLong(this.config.getProperty(\"num_msgs\"));\n        this.num_msgs_expected=num_senders * num_msgs;\n        sender=Boolean.valueOf(this.config.getProperty(\"sender\")).booleanValue();\n        msg_size=Long.parseLong(this.config.getProperty(\"msg_size\"));\n        String tmp2=this.config.getProperty(\"dump_transport_stats\", \"false\");\n        if(Boolean.valueOf(tmp2).booleanValue())\n            this.dump_transport_stats=true;\n        tmp2=this.config.getProperty(\"log_interval\");\n        if(tmp2 != null)\n            log_interval=Long.parseLong(tmp2);\n\n        sb=new StringBuffer();\n        sb.append(\"\\n##### msgs_received\");\n        sb.append(\", current time (in ms)\");\n        sb.append(\", msgs/sec\");\n        sb.append(\", throughput/sec [KB]\");\n        sb.append(\", free_mem [KB] \");\n        sb.append(\", total_mem [KB] \");\n        if(log.isInfoEnabled()) log.info(sb.toString());\n\n        if(jmx) {\n            this.config.setProperty(\"jmx\", \"true\");\n        }\n        this.jmx=new Boolean(this.config.getProperty(\"jmx\")).booleanValue();\n        String transport_name=this.config.getProperty(\"transport\");\n        transport=(Transport)Util.loadClass(transport_name, this.getClass()).newInstance();\n        transport.create(this.config);\n        transport.setReceiver(this);\n        transport.start();\n        local_addr=transport.getLocalAddress();\n    }","id":87694,"modified_method":"public void start(Properties c, boolean verbose, boolean jmx, String output) throws Exception {\n        String          config_file=\"config.txt\";\n        BufferedReader  fileReader;\n        String          line;\n        String          key, val;\n        StringTokenizer st;\n        Properties      tmp=new Properties();\n\n        if(output != null)\n            this.output=new FileWriter(output, false);\n\n        config_file=c.getProperty(\"config\");\n        fileReader=new BufferedReader(new FileReader(config_file));\n        while((line=fileReader.readLine()) != null) {\n            if(line.startsWith(\"#\"))\n                continue;\n            line=line.trim();\n            if(line.length() == 0)\n                continue;\n            st=new StringTokenizer(line, \"=\", false);\n            key=st.nextToken().toLowerCase();\n            val=st.nextToken();\n            tmp.put(key, val);\n        }\n        fileReader.close();\n\n        // 'tmp' now contains all properties from the file, now we need to override the ones\n        // passed to us by 'c'\n        tmp.putAll(c);\n        this.config=tmp;\n\n        StringBuffer sb=new StringBuffer();\n        sb.append(\"\\n\\n----------------------- TEST -----------------------\\n\");\n        sb.append(\"Date: \").append(new Date()).append('\\n');\n        sb.append(\"Run by: \").append(System.getProperty(\"user.name\")).append(\"\\n\\n\");\n        if(verbose)\n            sb.append(\"Properties: \").append(printProperties()).append(\"\\n-------------------------\\n\\n\");\n\n        for(Iterator it=this.config.entrySet().iterator(); it.hasNext();) {\n            Map.Entry entry=(Map.Entry)it.next();\n            sb.append(entry.getKey()).append(\":\\t\").append(entry.getValue()).append('\\n');\n        }\n        sb.append(\"JGroups version: \").append(Version.printVersion()).append('\\n');\n        System.out.println(\"Configuration is: \" + sb);\n\n        output(sb.toString());\n\n        props=this.config.getProperty(\"props\");\n        num_members=Integer.parseInt(this.config.getProperty(\"num_members\"));\n        num_senders=Integer.parseInt(this.config.getProperty(\"num_senders\"));\n        long num_msgs=Long.parseLong(this.config.getProperty(\"num_msgs\"));\n        this.num_msgs_expected=num_senders * num_msgs;\n        sender=Boolean.valueOf(this.config.getProperty(\"sender\")).booleanValue();\n        msg_size=Long.parseLong(this.config.getProperty(\"msg_size\"));\n        String tmp2=this.config.getProperty(\"dump_transport_stats\", \"false\");\n        if(Boolean.valueOf(tmp2).booleanValue())\n            this.dump_transport_stats=true;\n        tmp2=this.config.getProperty(\"log_interval\");\n        if(tmp2 != null)\n            log_interval=Long.parseLong(tmp2);\n\n        sb=new StringBuffer();\n        sb.append(\"\\n##### msgs_received\");\n        sb.append(\", current time (in ms)\");\n        sb.append(\", msgs/sec\");\n        sb.append(\", throughput/sec [KB]\");\n        sb.append(\", free_mem [KB] \");\n        sb.append(\", total_mem [KB] \");\n        output(sb.toString());\n\n        if(jmx) {\n            this.config.setProperty(\"jmx\", \"true\");\n        }\n        this.jmx=new Boolean(this.config.getProperty(\"jmx\")).booleanValue();\n        String transport_name=this.config.getProperty(\"transport\");\n        transport=(Transport)Util.loadClass(transport_name, this.getClass()).newInstance();\n        transport.create(this.config);\n        transport.setReceiver(this);\n        transport.start();\n        local_addr=transport.getLocalAddress();\n    }","commit_id":"711961ca25826c9ba35309a64104d9fb1c650ffe","url":"https://github.com/belaban/JGroups"},{"original_method":"static void help() {\n        System.out.println(\"Test [-help] ([-sender] | [-receiver]) \" +\n                           \"[-config <config file>] [-props <stack config>] [-verbose] [-jmx] [-dump_stats]\");\n    }","id":87695,"modified_method":"static void help() {\n        System.out.println(\"Test [-help] ([-sender] | [-receiver]) \" +\n                \"[-config <config file>] \" +\n                \"[-props <stack config>] [-verbose] [-jmx] \" +\n                \"[-dump_stats] [-f <filename>]\");\n    }","commit_id":"711961ca25826c9ba35309a64104d9fb1c650ffe","url":"https://github.com/belaban/JGroups"},{"original_method":"public static boolean static_canBeAChild(SNode node, SNode parentNode, SNode link, SNode childConcept, final IOperationContext operationContext) {\n    return (SNodeOperations.getAncestor(parentNode, \"jetbrains.mps.lang.editor.structure.CellModel_RefCell\", true, false) != null);\n  }","id":87696,"modified_method":"public static boolean static_canBeAChild(SNode node, SNode parentNode, SNode link, SNode childConcept, final IOperationContext operationContext) {\n    SNode ancestorRef = SNodeOperations.getAncestor(parentNode, \"jetbrains.mps.lang.editor.structure.CellModel_RefCell\", true, false);\n    SNode ancestorList = SNodeOperations.getAncestor(parentNode, \"jetbrains.mps.lang.editor.structure.CellModel_ListWithRole\", true, false);\n    if ((ancestorRef == null)) {\n      return false;\n    }\n    if ((ancestorList == null)) {\n      return true;\n    }\n    return jetbrains.mps.util.SNodeOperations.isAncestor(ancestorList, ancestorRef);\n  }","commit_id":"5231130dab68c2f56e33cf7f87550a6b614b9fce","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode variableReference, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (SNodeOperations.getAncestor(variableReference, \"org.jetbrains.mps.samples.ParallelFor.structure.ParallelFor\", false, false) != null) {\n      if (!(SPropertyOperations.getBoolean(SLinkOperations.getTarget(variableReference, \"variableDeclaration\", false), \"isFinal\"))) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(variableReference, \"Cannot refer non-final variables and parameters from within concurrent code\", \"r:4c36f4b4-7816-4067-aa6e-a49c547265ed(org.jetbrains.mps.samples.ParallelFor.typesystem)\", \"7793246093816027855\", null, errorTarget);\n          {\n            BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"org.jetbrains.mps.samples.ParallelFor.typesystem.MakeDeclarationFinal_QuickFix\", false);\n            _reporter_2309309498.addIntentionProvider(intentionProvider);\n          }\n        }\n      }\n      SNode dotOperation = SNodeOperations.getAncestor(variableReference, \"jetbrains.mps.baseLanguage.structure.DotExpression\", false, false);\n      if (dotOperation != null) {\n        if (SLinkOperations.getTarget(dotOperation, \"operand\", true) == variableReference) {\n          List<SNode> allowedClasses = ListSequence.fromListAndArray(new ArrayList<SNode>(), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a1a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a2a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a3a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a4a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a5a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a6a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a7a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a8a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a9a0a0a0c0a0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a01a0a0a0c0a0a().createNode(typeCheckingContext));\n\n          if (!(ListSequence.fromList(allowedClasses).any(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SLinkOperations.getTarget(it, \"classifier\", false) == check_hquoeu_a0a0a0a0c0a0c0a0a(SNodeOperations.as(SLinkOperations.getTarget(SLinkOperations.getTarget(variableReference, \"variableDeclaration\", false), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\"));\n            }\n          }))) {\n            {\n              MessageTarget errorTarget = new NodeMessageTarget();\n              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(SLinkOperations.getTarget(dotOperation, \"operation\", true), \"Calling a method on a potentially non-thread-safe shared object\", \"r:4c36f4b4-7816-4067-aa6e-a49c547265ed(org.jetbrains.mps.samples.ParallelFor.typesystem)\", \"7793246093816048948\", null, errorTarget);\n            }\n          }\n        }\n      }\n    }\n  }","id":87697,"modified_method":"public void applyRule(final SNode variableReference, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    SNode directAncestor = SNodeOperations.getAncestor(variableReference, \"org.jetbrains.mps.samples.ParallelFor.structure.ParallelFor\", false, false);\n    if (directAncestor != null) {\n      SNode declarationsAncestor = SNodeOperations.getAncestor(SLinkOperations.getTarget(variableReference, \"variableDeclaration\", false), \"org.jetbrains.mps.samples.ParallelFor.structure.ParallelFor\", false, false);\n      if (directAncestor != declarationsAncestor) {\n        if (!(SPropertyOperations.getBoolean(SLinkOperations.getTarget(variableReference, \"variableDeclaration\", false), \"isFinal\"))) {\n          {\n            MessageTarget errorTarget = new NodeMessageTarget();\n            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(variableReference, \"Cannot refer non-final variables and parameters from within concurrent code\", \"r:4c36f4b4-7816-4067-aa6e-a49c547265ed(org.jetbrains.mps.samples.ParallelFor.typesystem)\", \"7793246093816027855\", null, errorTarget);\n            {\n              BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"org.jetbrains.mps.samples.ParallelFor.typesystem.MakeDeclarationFinal_QuickFix\", false);\n              _reporter_2309309498.addIntentionProvider(intentionProvider);\n            }\n          }\n        }\n        SNode dotOperation = SNodeOperations.getAncestor(variableReference, \"jetbrains.mps.baseLanguage.structure.DotExpression\", false, false);\n        if (dotOperation != null) {\n          if (SLinkOperations.getTarget(dotOperation, \"operand\", true) == variableReference) {\n            List<SNode> allowedClasses = ListSequence.fromListAndArray(new ArrayList<SNode>(), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a1a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a2a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a3a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a4a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a5a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a6a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a7a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a8a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a9a0a0a0c0b0b0a().createNode(typeCheckingContext), new NoAssignmentsToNonFinalVariablesOutsideTheScope_NonTypesystemRule.QuotationClass_hquoeu_a01a0a0a0c0b0b0a().createNode(typeCheckingContext));\n\n            if (!(ListSequence.fromList(allowedClasses).any(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return SLinkOperations.getTarget(it, \"classifier\", false) == check_hquoeu_a0a0a0a0c0a0c0b0b0a(SNodeOperations.as(SLinkOperations.getTarget(SLinkOperations.getTarget(variableReference, \"variableDeclaration\", false), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\"));\n              }\n            }))) {\n              {\n                MessageTarget errorTarget = new NodeMessageTarget();\n                IErrorReporter _reporter_2309309498 = typeCheckingContext.reportWarning(SLinkOperations.getTarget(dotOperation, \"operation\", true), \"Calling a method on a potentially non-thread-safe shared object\", \"r:4c36f4b4-7816-4067-aa6e-a49c547265ed(org.jetbrains.mps.samples.ParallelFor.typesystem)\", \"7793246093816048948\", null, errorTarget);\n              }\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"dc03a76556979bb5b7d07ea223f3203b8436ee50","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SNode check_hquoeu_a0a0a0a0c0a0c0a0a(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return SLinkOperations.getTarget(checkedDotOperand, \"classifier\", false);\n    }\n    return null;\n  }","id":87698,"modified_method":"private static SNode check_hquoeu_a0a0a0a0c0a0c0b0b0a(SNode checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return SLinkOperations.getTarget(checkedDotOperand, \"classifier\", false);\n    }\n    return null;\n  }","commit_id":"dc03a76556979bb5b7d07ea223f3203b8436ee50","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void main(String[] args) {\n    // Some thread pools to use \n    final ExecutorService myPool = Executors.newFixedThreadPool(3);\n    final ExecutorService youPool = Executors.newFixedThreadPool(10);\n\n    // A collection of numbers to play with \n    final Iterable<Integer> numbers = Sequence.fromClosure(new ISequenceClosure<Integer>() {\n      public Iterable<Integer> iterable() {\n        return new Iterable<Integer>() {\n          public Iterator<Integer> iterator() {\n            return new YieldingIterator<Integer>() {\n              private int __CP__ = 0;\n\n              protected boolean moveToNext() {\n__loop__:\n                do {\n__switch__:\n                  switch (this.__CP__) {\n                    case -1:\n                      assert false : \"Internal error\";\n                      return false;\n                    case 2:\n                      this.__CP__ = 3;\n                      this.yield(1);\n                      return true;\n                    case 3:\n                      this.__CP__ = 4;\n                      this.yield(2);\n                      return true;\n                    case 4:\n                      this.__CP__ = 5;\n                      this.yield(3);\n                      return true;\n                    case 5:\n                      this.__CP__ = 6;\n                      this.yield(4);\n                      return true;\n                    case 6:\n                      this.__CP__ = 1;\n                      this.yield(5);\n                      return true;\n                    case 0:\n                      this.__CP__ = 2;\n                      break;\n                    default:\n                      break __loop__;\n                  }\n                } while (true);\n                return false;\n              }\n            };\n          }\n        };\n      }\n    });\n\n    // The optional reference to a thread pool is set in the Inspector (Alt|Command + 2) \n    {\n      final CountDownLatch latch = new CountDownLatch(Sequence.fromIterable(numbers).count());\n      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();\n\n      for (final int a : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {\n\n        final int localA = a;\n\n        Runnable runnable = new Runnable() {\n          public void run() {\n            try {\n              log(\"Starting calculation for number \" + localA + \" in thread \" + Thread.currentThread());\n              ParallelForSample.sleep(localA * 1000);\n              log(\"Finished calculation for number \" + localA + \" in thread \" + Thread.currentThread());\n            } catch (RuntimeException e) {\n              ListSequence.fromList(exceptions).addElement(e);\n            } finally {\n              latch.countDown();\n            }\n          }\n        };\n\n        myPool.execute(runnable);\n\n      }\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        ListSequence.fromList(exceptions).addElement(e);\n      }\n      if (ListSequence.fromList(exceptions).isNotEmpty()) {\n        throw new ParallelLoopException(\"Some parallel calculations failed\", exceptions);\n      }\n\n    }\n    log(\"Done\");\n\n\n    // References to non-final variables and parameters from within parallel loops are reported as errors \n    // Try making the following variable non-final (Alt + Enter) \n    final String doNotMessupWith = \"The Shared State\";\n\n    // Accessing non-thread-safe classes, such as lists, is reported as warnings \n    final List<String> names = ListSequence.fromListAndArray(new ArrayList<String>(), \"Joe\", \"Dave\", \"Alice\");\n\n    // Accessing thread-safe classes is considered ok \n    final AtomicInteger counter = new AtomicInteger(0);\n\n    {\n      final CountDownLatch latch = new CountDownLatch(Sequence.fromIterable(numbers).count());\n      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();\n\n      for (final int b : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {\n\n        final int localA = b;\n\n        Runnable runnable = new Runnable() {\n          public void run() {\n            try {\n              log(\"Touching \" + doNotMessupWith);\n              log(\"Counter: \" + counter.incrementAndGet());\n              ListSequence.fromList(names).removeElement(\"Joe\");\n              ParallelForSample.sleep(1000);\n            } catch (RuntimeException e) {\n              ListSequence.fromList(exceptions).addElement(e);\n            } finally {\n              latch.countDown();\n            }\n          }\n        };\n\n        youPool.execute(runnable);\n\n      }\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        ListSequence.fromList(exceptions).addElement(e);\n      }\n      if (ListSequence.fromList(exceptions).isNotEmpty()) {\n        throw new ParallelLoopException(\"Some parallel calculations failed\", exceptions);\n      }\n\n    }\n\n    // Iterating over a collection of strings \n    // No thread pool is set (Alt|Command + 2) so using threads directly \n    {\n      final CountDownLatch latch = new CountDownLatch(ListSequence.fromList(names).count());\n      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();\n\n      for (final String c : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<String>(), names))) {\n\n        final String localA = c;\n\n        Runnable runnable = new Runnable() {\n          public void run() {\n            try {\n              log(\"Name: \" + localA);\n              if (localA == \"Joe\") {\n                throw new RuntimeException(\"test\");\n              }\n            } catch (RuntimeException e) {\n              ListSequence.fromList(exceptions).addElement(e);\n            } finally {\n              latch.countDown();\n            }\n          }\n        };\n\n        new Thread(runnable).start();\n\n      }\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        ListSequence.fromList(exceptions).addElement(e);\n      }\n      if (ListSequence.fromList(exceptions).isNotEmpty()) {\n        throw new ParallelLoopException(\"Some parallel calculations failed\", exceptions);\n      }\n\n    }\n\n    // Shutdown the thread pools \n    myPool.shutdown();\n    youPool.shutdown();\n  }","id":87699,"modified_method":"public static void main(String[] args) {\n    // Some thread pools to use \n    final ExecutorService myPool = Executors.newFixedThreadPool(3);\n    final ExecutorService youPool = Executors.newFixedThreadPool(10);\n\n    // A collection of numbers to play with \n    final Iterable<Integer> numbers = Sequence.fromClosure(new ISequenceClosure<Integer>() {\n      public Iterable<Integer> iterable() {\n        return new Iterable<Integer>() {\n          public Iterator<Integer> iterator() {\n            return new YieldingIterator<Integer>() {\n              private int __CP__ = 0;\n\n              protected boolean moveToNext() {\n__loop__:\n                do {\n__switch__:\n                  switch (this.__CP__) {\n                    case -1:\n                      assert false : \"Internal error\";\n                      return false;\n                    case 2:\n                      this.__CP__ = 3;\n                      this.yield(1);\n                      return true;\n                    case 3:\n                      this.__CP__ = 4;\n                      this.yield(2);\n                      return true;\n                    case 4:\n                      this.__CP__ = 5;\n                      this.yield(3);\n                      return true;\n                    case 5:\n                      this.__CP__ = 6;\n                      this.yield(4);\n                      return true;\n                    case 6:\n                      this.__CP__ = 1;\n                      this.yield(5);\n                      return true;\n                    case 0:\n                      this.__CP__ = 2;\n                      break;\n                    default:\n                      break __loop__;\n                  }\n                } while (true);\n                return false;\n              }\n            };\n          }\n        };\n      }\n    });\n\n    // The optional reference to a thread pool is set in the Inspector (Alt|Command + 2) \n    {\n      final CountDownLatch latch = new CountDownLatch(Sequence.fromIterable(numbers).count());\n      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();\n\n      for (final int a : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {\n\n        final int localA = a;\n\n        Runnable runnable = new Runnable() {\n          public void run() {\n            try {\n              log(\"Starting calculation for number \" + localA + \" in thread \" + Thread.currentThread());\n              ParallelForSample.sleep(localA * 1000);\n              log(\"Finished calculation for number \" + localA + \" in thread \" + Thread.currentThread());\n            } catch (RuntimeException e) {\n              ListSequence.fromList(exceptions).addElement(e);\n            } finally {\n              latch.countDown();\n            }\n          }\n        };\n\n        myPool.execute(runnable);\n\n      }\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        ListSequence.fromList(exceptions).addElement(e);\n      }\n      if (ListSequence.fromList(exceptions).isNotEmpty()) {\n        throw new ParallelLoopException(\"Some parallel calculations failed\", exceptions);\n      }\n\n    }\n    log(\"Done\");\n\n\n    // References to non-final variables and parameters from within parallel loops are reported as errors \n    // Try making the following variable non-final (Alt + Enter) \n    final String doNotMessupWith = \"The Shared State\";\n\n    // Accessing non-thread-safe classes, such as lists, is reported as warnings \n    final List<String> names = ListSequence.fromListAndArray(new ArrayList<String>(), \"Joe\", \"Dave\", \"Alice\");\n\n    // Accessing thread-safe classes is considered ok \n    final AtomicInteger counter = new AtomicInteger(0);\n\n    {\n      final CountDownLatch latch = new CountDownLatch(Sequence.fromIterable(numbers).count());\n      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();\n\n      for (final int b : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<Integer>(), numbers))) {\n\n        final int localA = b;\n\n        Runnable runnable = new Runnable() {\n          public void run() {\n            try {\n              log(\"Touching \" + doNotMessupWith);\n\n              int messupWithMeSinceImlocal = 1;\n              messupWithMeSinceImlocal += 10;\n              log(\"Local variables can be used without restrictions \" + messupWithMeSinceImlocal);\n\n              // Warning since we are accessing a non-local object \n              ListSequence.fromList(names).removeElement(\"Joe\");\n\n              List<String> localNames = ListSequence.fromList(new ArrayList<String>());\n              // Local references can be called without restrictions \n              ListSequence.fromList(localNames).addElement(\"Susan\");\n\n              // Thread-safe objects are safe to use as well \n              log(\"Counter: \" + counter.incrementAndGet());\n\n              ParallelForSample.sleep(1000);\n            } catch (RuntimeException e) {\n              ListSequence.fromList(exceptions).addElement(e);\n            } finally {\n              latch.countDown();\n            }\n          }\n        };\n\n        youPool.execute(runnable);\n\n      }\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        ListSequence.fromList(exceptions).addElement(e);\n      }\n      if (ListSequence.fromList(exceptions).isNotEmpty()) {\n        throw new ParallelLoopException(\"Some parallel calculations failed\", exceptions);\n      }\n\n    }\n\n    // Iterating over a collection of strings \n    // No thread pool is set (Alt|Command + 2) so using threads directly \n    {\n      final CountDownLatch latch = new CountDownLatch(ListSequence.fromList(names).count());\n      final List<Exception> exceptions = new CopyOnWriteArrayList<Exception>();\n\n      for (final String c : Collections.unmodifiableList(ListSequence.fromListWithValues(new ArrayList<String>(), names))) {\n\n        final String localA = c;\n\n        Runnable runnable = new Runnable() {\n          public void run() {\n            try {\n              log(\"Name: \" + localA);\n              if (localA == \"Joe\") {\n                throw new RuntimeException(\"test\");\n              }\n            } catch (RuntimeException e) {\n              ListSequence.fromList(exceptions).addElement(e);\n            } finally {\n              latch.countDown();\n            }\n          }\n        };\n\n        new Thread(runnable).start();\n\n      }\n      try {\n        latch.await();\n      } catch (InterruptedException e) {\n        ListSequence.fromList(exceptions).addElement(e);\n      }\n      if (ListSequence.fromList(exceptions).isNotEmpty()) {\n        throw new ParallelLoopException(\"Some parallel calculations failed\", exceptions);\n      }\n\n    }\n\n    // Shutdown the thread pools \n    myPool.shutdown();\n    youPool.shutdown();\n  }","commit_id":"dc03a76556979bb5b7d07ea223f3203b8436ee50","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope virtual_getScope_3734116213129936182(SNode thisNode, SNode kind, final SNode child) {\n    if (kind == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.buildScript.structure.BuildMacro\")) {\n      return BuildProject_Behavior.call_getBuildMacroScope_3767587139141108514(thisNode, child);\n    }\n    return null;\n  }","id":87700,"modified_method":"public static Scope virtual_getScope_3734116213129936182(SNode thisNode, SNode kind, final SNode child) {\n    if (SConceptOperations.isSubConceptOf(kind, \"jetbrains.mps.buildScript.structure.BuildMacro\")) {\n      return BuildProject_Behavior.call_getBuildMacroScope_3767587139141108514(thisNode, child);\n    }\n    return null;\n  }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_save77_a0a0a0a0a1a0b0c0d(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":87701,"modified_method":"private static boolean eq_save77_a0a0a0a0a1a0b0c0d0d(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean neq_save77_a0b0d(Object a, Object b) {\n    return !((a != null ?\n      a.equals(b) :\n      a == b\n    ));\n  }","id":87702,"modified_method":"private static boolean neq_save77_a0c0d(Object a, Object b) {\n    return !((a != null ?\n      a.equals(b) :\n      a == b\n    ));\n  }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Scope call_getBuildMacroScope_3767587139141108514(SNode thisNode, final SNode child) {\n    Scope rootScope = ScopeUtil.simpleRoleScope(thisNode, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.buildScript.structure.BuildProject\", \"macros\"));\n    if (neq_save77_a0b0d(SNodeOperations.getAncestor(child, \"jetbrains.mps.buildScript.structure.BuildProject\", false, false), thisNode)) {\n      // we are imported => give away only public macro \n      rootScope = ScopeUtil.where(rootScope, new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode node) {\n          return SConceptPropertyOperations.getBoolean(SNodeOperations.cast(node, \"jetbrains.mps.buildScript.structure.BuildMacro\"), \"public\");\n        }\n      });\n    }\n    if (\"macros\".equals(SNodeOperations.getContainingLinkRole(child))) {\n      // we can only see what was strictly before us \n      rootScope = ScopeUtil.where(rootScope, new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode it) {\n          return !(ListSequence.fromList(SNodeOperations.getNextSiblings(child, false)).contains(it)) && !(eq_save77_a0a0a0a0a1a0b0c0d(child, it));\n        }\n      });\n    }\n\n    List<Scope> scopes = ListSequence.fromList(new ArrayList<Scope>());\n    ListSequence.fromList(scopes).addElement(rootScope);\n    ListSequence.fromList(scopes).addSequence(Sequence.fromIterable(ScopeUtil.imported(SLinkOperations.getTargets(thisNode, \"dependencies\", true), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.buildScript.structure.BuildMacro\"), child)));\n\n    return new CompositeScope(ListSequence.fromList(scopes).toGenericArray(Scope.class));\n  }","id":87703,"modified_method":"public static Scope call_getBuildMacroScope_3767587139141108514(SNode thisNode, final SNode child) {\n    Scope rootScope = ScopeUtil.simpleRoleScope(thisNode, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.buildScript.structure.BuildProject\", \"macros\"));\n    SNode containingProject = SNodeOperations.getAncestor(child, \"jetbrains.mps.buildScript.structure.BuildProject\", false, false);\n    if (neq_save77_a0c0d(containingProject, thisNode)) {\n      // we are imported => give away only public macro \n      rootScope = ScopeUtil.where(rootScope, new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n        public Boolean invoke(SNode node) {\n          return SConceptPropertyOperations.getBoolean(SNodeOperations.cast(node, \"jetbrains.mps.buildScript.structure.BuildMacro\"), \"public\");\n        }\n      });\n    }\n    if ((containingProject != null)) {\n      final Wrappers._T<SNode> definedMacro = new Wrappers._T<SNode>();\n      if (ListSequence.fromList(SLinkOperations.getTargets(containingProject, \"macros\", true)).contains(child)) {\n        definedMacro.value = SNodeOperations.cast(child, \"jetbrains.mps.buildScript.structure.BuildMacro\");\n      } else {\n        definedMacro.value = ListSequence.fromList(SLinkOperations.getTargets(containingProject, \"macros\", true)).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode it) {\n            return ListSequence.fromList(SNodeOperations.getDescendants(it, null, false, new String[]{})).contains(child);\n          }\n        });\n      }\n      if ((definedMacro.value != null)) {\n        // we can only see what was strictly before us \n        rootScope = ScopeUtil.where(rootScope, new _FunctionTypes._return_P1_E0<Boolean, SNode>() {\n          public Boolean invoke(SNode visibleNode) {\n            return !(ListSequence.fromList(SNodeOperations.getNextSiblings(definedMacro.value, false)).contains(visibleNode)) && !(eq_save77_a0a0a0a0a1a0b0c0d0d(definedMacro.value, visibleNode));\n          }\n        });\n      }\n    }\n\n    List<Scope> scopes = ListSequence.fromList(new ArrayList<Scope>());\n    ListSequence.fromList(scopes).addElement(rootScope);\n    ListSequence.fromList(scopes).addSequence(Sequence.fromIterable(ScopeUtil.imported(SLinkOperations.getTargets(thisNode, \"dependencies\", true), SConceptOperations.findConceptDeclaration(\"jetbrains.mps.buildScript.structure.BuildMacro\"), child)));\n\n    return new CompositeScope(ListSequence.fromList(scopes).toGenericArray(Scope.class));\n  }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void test_seeForwardVariableInScope() throws Throwable {\n    this.initTest(\"${mps_home}/MPS.ipr\", \"r:361d93bd-9223-4768-9e37-bcd7b8db1f40(jetbrains.mps.buildScript.tests@tests)\");\n    this.runTest(\"jetbrains.mps.buildScript.tests.MacroTest_Test$TestBody\", \"test_seeForwardVariableInScope\", true);\n  }","id":87704,"modified_method":"@Test\n  public void test_doNotSeeForwardVariabletInScope() throws Throwable {\n    this.initTest(\"${mps_home}/MPS.ipr\", \"r:361d93bd-9223-4768-9e37-bcd7b8db1f40(jetbrains.mps.buildScript.tests@tests)\");\n    this.runTest(\"jetbrains.mps.buildScript.tests.MacroTest_Test$TestBody\", \"test_doNotSeeForwardVariabletInScope\", true);\n  }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void test_exportedMacro() throws Exception {\n      this.addNodeById(\"193602448594327347\");\n      this.addNodeById(\"763409143595572699\");\n      this.addNodeById(\"384280137912153748\");\n      Context context = new Context() {\n        @Override\n        public String getBasePath_Local(SNode node) {\n          return PathManager.getHomePath();\n        }\n      };\n      List<SNode> exportedMacro = context.getExportedMacro(SNodeOperations.cast(this.getNodeById(\"193602448594327348\"), \"jetbrains.mps.buildScript.structure.BuildProject\"));\n\n      List<SNode> expected = new ArrayList<SNode>();\n      ListSequence.fromList(expected).addElement(new MacroTest_Test.TestBody.QuotationClass_oxxkhl_a0a0h0a0().createNode(\"${build.dir}/tmp/project.tmp\"));\n      ListSequence.fromList(expected).addElement(new MacroTest_Test.TestBody.QuotationClass_oxxkhl_a0a0i0a0().createNode(\"${build.dir}/artifacts/project.artifacts\"));\n\n      for (int i = 0; i < ListSequence.fromList(expected).count(); i++) {\n        Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), expected.get(i)), ListSequence.fromListAndArray(new ArrayList<SNode>(), exportedMacro.get(i))));\n      }\n    }","id":87705,"modified_method":"public void test_exportedMacro() throws Exception {\n      this.addNodeById(\"193602448594327347\");\n      this.addNodeById(\"763409143595572699\");\n      this.addNodeById(\"384280137912153748\");\n      Context context = new Context();\n      List<SNode> exportedMacro = context.getExportedMacro(SNodeOperations.cast(this.getNodeById(\"193602448594327348\"), \"jetbrains.mps.buildScript.structure.BuildProject\"));\n\n      List<SNode> expected = new ArrayList<SNode>();\n      ListSequence.fromList(expected).addElement(new MacroTest_Test.TestBody.QuotationClass_oxxkhl_a0a0h0a0().createNode(\"${build.dir}/tmp/project.tmp\"));\n      ListSequence.fromList(expected).addElement(new MacroTest_Test.TestBody.QuotationClass_oxxkhl_a0a0i0a0().createNode(\"${build.dir}/artifacts/project.artifacts\"));\n\n      for (int i = 0; i < ListSequence.fromList(expected).count(); i++) {\n        Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), expected.get(i)), ListSequence.fromListAndArray(new ArrayList<SNode>(), exportedMacro.get(i))));\n      }\n    }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void test_doNotSeeBackwardVariableInScope() throws Exception {\n      this.addNodeById(\"193602448594327347\");\n      this.addNodeById(\"763409143595572699\");\n      this.addNodeById(\"384280137912153748\");\n      Assert.assertFalse(ListSequence.fromList(ScopeProvider_Behavior.call_getScope_3734116213129936182(SNodeOperations.cast(this.getNodeById(\"384280137912153749\"), \"jetbrains.mps.buildScript.structure.BuildProject\"), ModelAccess.instance().runReadAction(new Computable<SNode>() {\n        public SNode compute() {\n          return SConceptOperations.findConceptDeclaration(\"jetbrains.mps.buildScript.structure.BuildMacro\");\n        }\n      }), SNodeOperations.cast(this.getNodeById(\"384280137912153762\"), \"jetbrains.mps.buildScript.structure.BuildVariableReference\")).getAvailableElements(\"\")).contains(SNodeOperations.cast(this.getNodeById(\"384280137912153753\"), \"jetbrains.mps.buildScript.structure.BuildVariableMacro\")));\n    }","id":87706,"modified_method":"public void test_seeBackwardVariableInScope() throws Exception {\n      this.addNodeById(\"193602448594327347\");\n      this.addNodeById(\"763409143595572699\");\n      this.addNodeById(\"384280137912153748\");\n      Assert.assertTrue(ListSequence.fromList(ScopeProvider_Behavior.call_getScope_3734116213129936182(SNodeOperations.cast(this.getNodeById(\"384280137912153749\"), \"jetbrains.mps.buildScript.structure.BuildProject\"), ModelAccess.instance().runReadAction(new Computable<SNode>() {\n        public SNode compute() {\n          return SConceptOperations.findConceptDeclaration(\"jetbrains.mps.buildScript.structure.BuildMacro\");\n        }\n      }), SNodeOperations.cast(this.getNodeById(\"384280137912153762\"), \"jetbrains.mps.buildScript.structure.BuildVariableReference\")).getAvailableElements(\"\")).contains(SNodeOperations.cast(this.getNodeById(\"384280137912153753\"), \"jetbrains.mps.buildScript.structure.BuildVariableMacro\")));\n    }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void test_seeForwardVariableInScope() throws Exception {\n      this.addNodeById(\"193602448594327347\");\n      this.addNodeById(\"763409143595572699\");\n      this.addNodeById(\"384280137912153748\");\n      Assert.assertTrue(ListSequence.fromList(ScopeProvider_Behavior.call_getScope_3734116213129936182(SNodeOperations.cast(this.getNodeById(\"384280137912153749\"), \"jetbrains.mps.buildScript.structure.BuildProject\"), ModelAccess.instance().runReadAction(new Computable<SNode>() {\n        public SNode compute() {\n          return SConceptOperations.findConceptDeclaration(\"jetbrains.mps.buildScript.structure.BuildMacro\");\n        }\n      }), SNodeOperations.cast(this.getNodeById(\"384280137912153758\"), \"jetbrains.mps.buildScript.structure.BuildVariableReference\")).getAvailableElements(\"\")).contains(SNodeOperations.cast(this.getNodeById(\"384280137912153753\"), \"jetbrains.mps.buildScript.structure.BuildVariableMacro\")));\n    }","id":87707,"modified_method":"public void test_doNotSeeForwardVariabletInScope() throws Exception {\n      this.addNodeById(\"193602448594327347\");\n      this.addNodeById(\"763409143595572699\");\n      this.addNodeById(\"384280137912153748\");\n      Assert.assertFalse(ListSequence.fromList(ScopeProvider_Behavior.call_getScope_3734116213129936182(SNodeOperations.cast(this.getNodeById(\"384280137912153749\"), \"jetbrains.mps.buildScript.structure.BuildProject\"), ModelAccess.instance().runReadAction(new Computable<SNode>() {\n        public SNode compute() {\n          return SConceptOperations.findConceptDeclaration(\"jetbrains.mps.buildScript.structure.BuildMacro\");\n        }\n      }), SNodeOperations.cast(this.getNodeById(\"384280137912153758\"), \"jetbrains.mps.buildScript.structure.BuildVariableReference\")).getAvailableElements(\"\")).contains(SNodeOperations.cast(this.getNodeById(\"384280137912153753\"), \"jetbrains.mps.buildScript.structure.BuildVariableMacro\")));\n    }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void test_doNotSeeBackwardVariableInScope() throws Throwable {\n    this.initTest(\"${mps_home}/MPS.ipr\", \"r:361d93bd-9223-4768-9e37-bcd7b8db1f40(jetbrains.mps.buildScript.tests@tests)\");\n    this.runTest(\"jetbrains.mps.buildScript.tests.MacroTest_Test$TestBody\", \"test_doNotSeeBackwardVariableInScope\", true);\n  }","id":87708,"modified_method":"@Test\n  public void test_seeBackwardVariableInScope() throws Throwable {\n    this.initTest(\"${mps_home}/MPS.ipr\", \"r:361d93bd-9223-4768-9e37-bcd7b8db1f40(jetbrains.mps.buildScript.tests@tests)\");\n    this.runTest(\"jetbrains.mps.buildScript.tests.MacroTest_Test$TestBody\", \"test_seeBackwardVariableInScope\", true);\n  }","commit_id":"78f551ce07b09e45fb65e962f047a4b4ef1fb68d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void call_checkReturns_1213877327397(SNode thisNode) {\n    Set<SNode> expectedReturns = DataFlow.getExpectedReturns(thisNode);\n    for(SNode n : expectedReturns) {\n      SNode nodeToSelect;\n      if (((StatementList)SNodeOperations.getAdapter(SNodeOperations.getAncestor(n, \"jetbrains.mps.baseLanguage.structure.StatementList\", false, false))).getStatementsCount() > 0) {\n        SNodeOperations.getAncestor(nodeToSelect = n, \"jetbrains.mps.baseLanguage.structure.Statement\", true, false);\n      } else\n      {\n        nodeToSelect = SNodeOperations.getAncestor(n, \"jetbrains.mps.baseLanguage.structure.StatementList\", false, false);\n      }\n      if (nodeToSelect != null) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(nodeToSelect, \"Return expected\", \"jetbrains.mps.baseLanguage.behavior\", \"1213877327419\", intentionProvider);\n        }\n      } else\n      {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(n, \"Return expected\", \"jetbrains.mps.baseLanguage.behavior\", \"1213877327427\", intentionProvider);\n        }\n      }\n    }\n  }","id":87709,"modified_method":"public static void call_checkReturns_1213877327397(SNode thisNode) {\n    Set<SNode> expectedReturns = DataFlow.getExpectedReturns(thisNode);\n    for(SNode n : expectedReturns) {\n      SNode nodeToSelect;\n      SNode sl = SNodeOperations.getAncestor(n, \"jetbrains.mps.baseLanguage.structure.StatementList\", false, false);\n      if ((sl != null) && ((StatementList)SNodeOperations.getAdapter(sl)).getStatementsCount() > 0) {\n        SNodeOperations.getAncestor(nodeToSelect = n, \"jetbrains.mps.baseLanguage.structure.Statement\", true, false);\n      } else\n      {\n        nodeToSelect = SNodeOperations.getAncestor(n, \"jetbrains.mps.baseLanguage.structure.StatementList\", false, false);\n      }\n      if (nodeToSelect != null) {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(nodeToSelect, \"Return expected\", \"jetbrains.mps.baseLanguage.behavior\", \"1213877327419\", intentionProvider);\n        }\n      } else\n      {\n        {\n          BaseIntentionProvider intentionProvider = null;\n          TypeChecker.getInstance().reportTypeError(n, \"Return expected\", \"jetbrains.mps.baseLanguage.behavior\", \"1213877327427\", intentionProvider);\n        }\n      }\n    }\n  }","commit_id":"09f2245a6d4dd5b18e8f96de7453018b81b8a418","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {\n    return (SNodeOperations.getAncestor(SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false) != null);\n  }","id":87710,"modified_method":"public boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {\n    SNode outerConcept = SNodeOperations.getAncestor(SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    while ((outerConcept != null)) {\n      if (SNodeOperations.isInstanceOf(outerConcept, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        outerConcept = SNodeOperations.getAncestor(outerConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n      } else {\n        break;\n      }\n    }\n    return (outerConcept != null);\n  }","commit_id":"81da3f8d8d441727c5f71dcd38c7afef5365cfd0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode outerConcept = SNodeOperations.getAncestor(SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    SLinkOperations.setTarget(node, \"classConcept\", outerConcept, false);\n  }","id":87711,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n    SNode outerConcept = SNodeOperations.getAncestor(SNodeOperations.getAncestor(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false), \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n    while ((outerConcept != null)) {\n      if (SNodeOperations.isInstanceOf(outerConcept, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        outerConcept = SNodeOperations.getAncestor(outerConcept, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", false, false);\n      } else {\n        break;\n      }\n    }\n    SLinkOperations.setTarget(node, \"classConcept\", outerConcept, false);\n  }","commit_id":"81da3f8d8d441727c5f71dcd38c7afef5365cfd0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<String> getClasspath(final List<ITestNodeWrapper> tests) {\n    final Set<SModule> uniqueModules = SetSequence.fromSet(new HashSet<SModule>());\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        for (ITestNodeWrapper testable : tests) {\n          SModule module = SNodeOperations.getModelFromNodeReference(((SNodePointer) testable.getNodePointer())).getModule();\n          SetSequence.fromSet(uniqueModules).addElement(module);\n        }\n      }\n    });\n    return SetSequence.fromSet(uniqueModules).translate(new ITranslator2<SModule, String>() {\n      public Iterable<String> translate(SModule it) {\n        return Java_Command.getClasspath(it);\n      }\n    }).distinct().toListSequence();\n  }","id":87712,"modified_method":"private static List<String> getClasspath(final List<ITestNodeWrapper> tests) {\n    final Set<SModule> uniqueModules = SetSequence.fromSet(new HashSet<SModule>());\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        for (ITestNodeWrapper testable : tests) {\n          SModule module = SNodeOperations.getModelFromNodeReference(((SNodePointer) testable.getNodePointer())).getModule();\n          SetSequence.fromSet(uniqueModules).addElement(module);\n        }\n      }\n    });\n    List<String> classpath = SetSequence.fromSet(uniqueModules).translate(new ITranslator2<SModule, String>() {\n      public Iterable<String> translate(SModule it) {\n        return Java_Command.getClasspath(it);\n      }\n    }).toListSequence();\n    ListSequence.fromList(classpath).addSequence(ListSequence.fromList(JUnit_Command.collectFromLibFolder())).distinct();\n    return classpath;\n  }","commit_id":"df9a05e9d9910f2df5ec1fabcc59c38de801774a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public UIQueryRelayStrategy(UIQueryRelayStrategy.DialogListener dialogListener) {\n    this.dialogListener = dialogListener;\n  }","id":87713,"modified_method":"public UIQueryRelayStrategy() {\n  }","commit_id":"4fe3f2c15d4e65f52b66fb53709e165d563c8619","url":"https://github.com/JetBrains/MPS"},{"original_method":"public <T extends IOption> T relayQuery(IQuery<T> query, IOperationContext context) {\n    if (dialogListener != null) {\n      try {\n        SwingUtilities.invokeAndWait(new Runnable() {\n          public void run() {\n            dialogListener.beforeDialogShown();\n          }\n        });\n      } catch (InterruptedException ignore) {\n      } catch (InvocationTargetException ignore) {\n      }\n    }\n    String[] options = Sequence.fromIterable(query.options()).<String>select(new ISelector<T, String>() {\n      public String select(T o) {\n        return o.getText();\n      }\n    }).toGenericArray(String.class);\n    int res = JOptionPane.showOptionDialog(context.getMainFrame(), query.getText(), query.getName().toString(), JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, null);\n    if (res == JOptionPane.CLOSED_OPTION) {\n      return query.voidOption();\n    }\n    return ListSequence.fromList(Sequence.fromIterable(query.options()).toListSequence()).getElement(res);\n  }","id":87714,"modified_method":"public <T extends IOption> T relayQuery(final IQuery<T> query, final IOperationContext context) {\n    List<T> optList = Sequence.fromIterable(query.options()).toListSequence();\n    final String[] options = ListSequence.fromList(optList).<String>select(new ISelector<T, String>() {\n      public String select(T o) {\n        return o.getText();\n      }\n    }).toGenericArray(String.class);\n    final int defopt = ListSequence.fromList(optList).indexOf(query.defaultOption());\n    final Wrappers._int res = new Wrappers._int(-1);\n    ThreadUtils.runInUIThreadAndWait(new Runnable() {\n      public void run() {\n        res.value = Messages.showDialog(context.getProject(), query.getText(), query.getName().toString(), options, defopt, defopt, Messages.getQuestionIcon());\n      }\n    });\n    if (res.value < 0) {\n      return query.voidOption();\n    }\n    return ListSequence.fromList(optList).getElement(res.value);\n  }","commit_id":"4fe3f2c15d4e65f52b66fb53709e165d563c8619","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void init() {\n      this.confMon = new IConfigMonitor.Stub() {\n        @Override\n        public <T extends IOption> T relayQuery(IQuery<T> query) {\n          T opt = null;\n          if (delegateConfMon != null) {\n            opt = delegateConfMon.relayQuery(query);\n          }\n          return (opt != null ?\n            opt :\n            new UIQueryRelayStrategy(new UIQueryRelayStrategy.DialogListener() {\n              public void beforeDialogShown() {\n                progInd.background();\n              }\n            }).relayQuery(query, getSession().getContext())\n          );\n        }\n      };\n      this.jobMon = new IJobMonitor.Stub() {\n        @Override\n        public boolean stopRequested() {\n          return (progStrat.getProgressIndicator() != null ?\n            progStrat.getProgressIndicator().isCanceled() :\n            false\n          );\n        }\n\n        @Override\n        public void reportFeedback(IFeedback fdbk) {\n          new UIFeedbackStrategy(mh).reportFeedback(fdbk);\n        }\n\n        @Override\n        public IProgress currentProgress() {\n          return progStrat.currentProgress();\n        }\n      };\n    }","id":87715,"modified_method":"private void init() {\n      this.confMon = new IConfigMonitor.Stub() {\n        @Override\n        public <T extends IOption> T relayQuery(IQuery<T> query) {\n          T opt = null;\n          if (delegateConfMon != null) {\n            opt = delegateConfMon.relayQuery(query);\n          }\n          return (opt != null ?\n            opt :\n            new UIQueryRelayStrategy().relayQuery(query, getSession().getContext())\n          );\n        }\n      };\n      this.jobMon = new IJobMonitor.Stub() {\n        @Override\n        public boolean stopRequested() {\n          return (progStrat.getProgressIndicator() != null ?\n            progStrat.getProgressIndicator().isCanceled() :\n            false\n          );\n        }\n\n        @Override\n        public void reportFeedback(IFeedback fdbk) {\n          new UIFeedbackStrategy(mh).reportFeedback(fdbk);\n        }\n\n        @Override\n        public IProgress currentProgress() {\n          return progStrat.currentProgress();\n        }\n      };\n    }","commit_id":"4fe3f2c15d4e65f52b66fb53709e165d563c8619","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void testAPIVisible() throws ClassNotFoundException {\n    FilterClassLoader classLoader = FilterClassLoader.create(this.getClass().getClassLoader());\n    Assert.assertSame(Application.class, classLoader.loadClass(Application.class.getName()));\n  }","id":87716,"modified_method":"@Test\n  public void testAPIVisible() throws ClassNotFoundException {\n    FilterClassLoader classLoader = FilterClassLoader.create(this.getClass().getClassLoader());\n    Assert.assertSame(Application.class, classLoader.loadClass(Application.class.getName()));\n\n    // Dependencies of API classes should also be visible\n    Assert.assertSame(Logger.class, classLoader.loadClass(Logger.class.getName()));\n\n    // JAX-RS classes should also be visible\n    Assert.assertSame(PUT.class, classLoader.loadClass(PUT.class.getName()));\n  }","commit_id":"ac2abe487202b170738f2e032b11111fcc51ada5","url":"https://github.com/caskdata/cdap"},{"original_method":"private static Set<String> createVisibleResources(ClassLoader classLoader, ProgramType type) throws IOException {\n    Set<String> resources = getBaseResources();\n\n    // Base on the type, add extra resources\n    // Current only Spark and Workflow type has extra visible resources\n    if (type == ProgramType.SPARK || type == ProgramType.WORKFLOW) {\n      resources = getResources(ClassPath.from(classLoader, JAR_ONLY_URI),\n                               SPARK_PACKAGES, CLASS_INFO_TO_RESOURCE_NAME, Sets.newHashSet(resources));\n    }\n    return ImmutableSet.copyOf(resources);\n  }","id":87717,"modified_method":"private static Set<String> createVisibleResources(ClassLoader classLoader, ProgramType type) throws IOException {\n    Set<String> resources = getBaseResources();\n\n    // Base on the type, add extra resources\n    // Current only Spark and Workflow type has extra visible resources\n    if (type == ProgramType.SPARK || type == ProgramType.WORKFLOW) {\n      resources = getResources(ClassPath.from(classLoader, JAR_ONLY_URI),\n                               SPARK_PACKAGES, ImmutableList.<String>of(),\n                               RESOURCE_INFO_TO_RESOURCE_NAME, Sets.newHashSet(resources));\n    }\n    return ImmutableSet.copyOf(resources);\n  }","commit_id":"ac2abe487202b170738f2e032b11111fcc51ada5","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Finds all resources that are accessible in a given {@link ClassPath} that starts with certain package prefixes.\n   * Resources information presented in the result collection is transformed by the given result transformation\n   * function.\n   */\n  private static <V, T extends Collection<V>> T getResources(ClassPath classPath,\n                                                             Iterable<String> packages,\n                                                             Function<ClassPath.ClassInfo, V> resultTransform,\n                                                             final T result) throws IOException {\n    for (String pkg : packages) {\n      Set<ClassPath.ClassInfo> packageClasses = classPath.getAllClassesRecursive(pkg);\n      for (ClassPath.ClassInfo cls : packageClasses) {\n        result.add(resultTransform.apply(cls));\n      }\n    }\n    return result;\n  }","id":87718,"modified_method":"/**\n   * Finds all resources that are accessible in a given {@link ClassPath} that starts with certain package prefixes.\n   * Also includes all non .class file resources in the same base URLs of those classes that are accepted through\n   * the package prefixes filtering.\n   *\n   * Resources information presented in the result collection is transformed by the given result transformation\n   * function.\n   */\n  private static <V, T extends Collection<V>> T getResources(ClassPath classPath,\n                                                             Iterable<String> includePackagePrefixes,\n                                                             Iterable<String> excludePackagePrefixes,\n                                                             Function<ClassPath.ResourceInfo, V> resultTransform,\n                                                             final T result) throws IOException {\n    Set<URL> resourcesBaseURLs = new HashSet<>();\n    // Adds all .class resources that should be included\n    // Also record the base URL of those resources\n    for (ClassPath.ClassInfo classInfo : classPath.getAllClasses()) {\n      boolean include = false;\n      for (String prefix : includePackagePrefixes) {\n        if (classInfo.getName().startsWith(prefix)) {\n          include = true;\n          break;\n        }\n      }\n      for (String prefix : excludePackagePrefixes) {\n        if (classInfo.getName().startsWith(prefix)) {\n          include = false;\n          break;\n        }\n      }\n\n      if (include) {\n        result.add(resultTransform.apply(classInfo));\n        resourcesBaseURLs.add(getClassPathURL(classInfo.getResourceName(), classInfo.url()));\n      }\n    }\n\n    // Adds non .class resources that are in the resourceBaseURLs\n    for (ClassPath.ResourceInfo resourceInfo : classPath.getResources()) {\n      if (resourceInfo instanceof ClassPath.ClassInfo) {\n        // We already processed all classes in the loop above\n        continue;\n      }\n      // See if the resource base URL is already accepted through class filtering.\n      // If it does, adds the resource name to the collection as well.\n      if (resourcesBaseURLs.contains(getClassPathURL(resourceInfo.getResourceName(), resourceInfo.url()))) {\n        result.add(resultTransform.apply(resourceInfo));\n      }\n    }\n\n    return result;\n  }","commit_id":"ac2abe487202b170738f2e032b11111fcc51ada5","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns a Set of resources name that are visible through the cdap-api module as well as Hadoop classes.\n   * This includes all classes+resources in cdap-api plus all classes+resources that cdap-api\n   * depends on (for example, sl4j, guava, gson, etc).\n   */\n  private static Set<String> createBaseResources() throws IOException {\n    // Everything should be traceable in the same ClassLoader of this class, which is the CDAP system ClassLoader\n    ClassLoader classLoader = ProgramResources.class.getClassLoader();\n\n    // Gather resources information for cdap-api classes\n    Set<ClassPath.ClassInfo> apiResources = getResources(getClassPath(classLoader, Application.class),\n                                                         CDAP_API_PACKAGES, Sets.<ClassPath.ClassInfo>newHashSet());\n    // Trace dependencies for cdap-api classes\n    Set<String> result = findClassDependencies(classLoader,\n                                               Iterables.transform(apiResources, CLASS_INFO_TO_CLASS_NAME),\n                                               Sets.<String>newHashSet());\n\n    // Gather resources for javax.ws.rs classes. They are not traceable from the api classes.\n    getResources(getClassPath(classLoader, Path.class), JAVAX_WS_RS_PACKAGES, CLASS_INFO_TO_RESOURCE_NAME, result);\n\n    // Gather Hadoop classes.\n    getResources(ClassPath.from(classLoader, JAR_ONLY_URI), HADOOP_PACKAGES, CLASS_INFO_TO_RESOURCE_NAME, result);\n\n    // Excludes HBase classes\n    return ImmutableSet.copyOf(Sets.filter(result, new Predicate<String>() {\n      @Override\n      public boolean apply(String input) {\n        return !input.startsWith(HBASE_PACKAGE_PREFIX);\n      }\n    }));\n  }","id":87719,"modified_method":"/**\n   * Returns a Set of resources name that are visible through the cdap-api module as well as Hadoop classes.\n   * This includes all classes+resources in cdap-api plus all classes+resources that cdap-api\n   * depends on (for example, sl4j, guava, gson, etc).\n   */\n  private static Set<String> createBaseResources() throws IOException {\n    // Everything should be traceable in the same ClassLoader of this class, which is the CDAP system ClassLoader\n    ClassLoader classLoader = ProgramResources.class.getClassLoader();\n\n    // Gather resources information for cdap-api classes\n    ClassPath apiClassPath = getClassPath(classLoader, Application.class);\n    // Add everything in cdap-api as visible resources\n    Set<String> result = Sets.newHashSet(Iterables.transform(apiClassPath.getResources(),\n                                                             RESOURCE_INFO_TO_RESOURCE_NAME));\n    // Trace dependencies for cdap-api classes\n    findClassDependencies(classLoader, Iterables.transform(apiClassPath.getAllClasses(), CLASS_INFO_TO_CLASS_NAME),\n                          result);\n\n    // Gather resources for javax.ws.rs classes. They are not traceable from the api classes.\n    Iterables.addAll(result, Iterables.transform(getClassPath(classLoader, Path.class).getResources(),\n                                                 RESOURCE_INFO_TO_RESOURCE_NAME));\n\n    // Gather Hadoop classes and resources\n    getResources(ClassPath.from(classLoader, JAR_ONLY_URI),\n                 HADOOP_PACKAGES, HBASE_PACKAGES, RESOURCE_INFO_TO_RESOURCE_NAME, result);\n\n    return ImmutableSet.copyOf(result);\n  }","commit_id":"ac2abe487202b170738f2e032b11111fcc51ada5","url":"https://github.com/caskdata/cdap"},{"original_method":"public Callable<?> create() {\n        List<URL> applicationClassPath = GFileUtils.toURLs(processBuilder.getApplicationClasspath());\n        ActionExecutionWorker injectedWorker = new ActionExecutionWorker(processBuilder.getWorker(), workerId,\n                displayName, serverAddress);\n        ImplementationClassLoaderWorker worker = new ImplementationClassLoaderWorker(processBuilder.getLogLevel(),\n                processBuilder.getSharedPackages(), implementationClassPath, injectedWorker);\n        return new IsolatedApplicationClassLoaderWorker(applicationClassPath, worker);\n    }","id":87720,"modified_method":"public Callable<?> create() {\n        List<URI> applicationClassPath = GFileUtils.toURIs(processBuilder.getApplicationClasspath());\n        ActionExecutionWorker injectedWorker = new ActionExecutionWorker(processBuilder.getWorker(), workerId,\n                displayName, serverAddress);\n        ImplementationClassLoaderWorker worker = new ImplementationClassLoaderWorker(processBuilder.getLogLevel(),\n                processBuilder.getSharedPackages(), implementationClassPath, injectedWorker);\n        return new IsolatedApplicationClassLoaderWorker(applicationClassPath, worker);\n    }","commit_id":"dbc305c0612bf17c22290b1dec32cef26b7cba32","url":"https://github.com/gradle/gradle"},{"original_method":"public ClassLoader createIsolatedClassLoader(Iterable<URL> urls) {\n        List<URL> classpath = GUtil.addLists(urls);\n\n        // This piece of ugliness copies the JAXP (ie XML API) provider, if any, from the system ClassLoader. Here's why:\n        //\n        // 1. When looking for a provider, JAXP looks for a service resource in the context ClassLoader, which is our isolated ClassLoader. If our classpath above does not contain a\n        //    provider, this returns null. If it does contain a provider, JAXP extracts the classname from the service resource.\n        // 2. If not found, JAXP looks for a service resource in the system ClassLoader. This happens to include all the application classes specified on the classpath. If the application\n        //    classpath does not contain a provider, this returns null. If it does contain a provider, JAXP extracts the implementation classname from the service resource.\n        // 3. If not found, JAXP uses a default classname\n        // 4. JAXP attempts to load the provider using the context ClassLoader. which is our isolated ClassLoader. This is fine if the classname came from step 1 or 3. It blows up if the\n        //    classname came from step 2.\n        //\n        // So, as a workaround, locate and include the JAXP provider jar in the classpath for our isolated ClassLoader.\n        //\n        // Note that in practise, this is only triggered when running in our tests\n\n        if (needJaxpImpl()) {\n            try {\n                classpath.add(ClasspathUtil.getClasspathForResource(ClassLoader.getSystemClassLoader(), \"META-INF/services/javax.xml.parsers.SAXParserFactory\").toURI().toURL());\n            } catch (MalformedURLException e) {\n                throw UncheckedException.throwAsUncheckedException(e);\n            }\n        }\n\n        return new URLClassLoader(classpath.toArray(new URL[classpath.size()]), ClassLoader.getSystemClassLoader().getParent());\n    }","id":87721,"modified_method":"public ClassLoader createIsolatedClassLoader(Iterable<URI> uris) {\n        List<URL> classpath = GFileUtils.urisToUrls(uris);\n\n        // This piece of ugliness copies the JAXP (ie XML API) provider, if any, from the system ClassLoader. Here's why:\n        //\n        // 1. When looking for a provider, JAXP looks for a service resource in the context ClassLoader, which is our isolated ClassLoader. If our classpath above does not contain a\n        //    provider, this returns null. If it does contain a provider, JAXP extracts the classname from the service resource.\n        // 2. If not found, JAXP looks for a service resource in the system ClassLoader. This happens to include all the application classes specified on the classpath. If the application\n        //    classpath does not contain a provider, this returns null. If it does contain a provider, JAXP extracts the implementation classname from the service resource.\n        // 3. If not found, JAXP uses a default classname\n        // 4. JAXP attempts to load the provider using the context ClassLoader. which is our isolated ClassLoader. This is fine if the classname came from step 1 or 3. It blows up if the\n        //    classname came from step 2.\n        //\n        // So, as a workaround, locate and include the JAXP provider jar in the classpath for our isolated ClassLoader.\n        //\n        // Note that in practise, this is only triggered when running in our tests\n\n        if (needJaxpImpl()) {\n            try {\n                classpath.add(ClasspathUtil.getClasspathForResource(ClassLoader.getSystemClassLoader(), \"META-INF/services/javax.xml.parsers.SAXParserFactory\").toURI().toURL());\n            } catch (MalformedURLException e) {\n                throw UncheckedException.throwAsUncheckedException(e);\n            }\n        }\n\n        return new URLClassLoader(classpath.toArray(new URL[classpath.size()]), ClassLoader.getSystemClassLoader().getParent());\n    }","commit_id":"dbc305c0612bf17c22290b1dec32cef26b7cba32","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultClassLoaderRegistry(ClassPathRegistry classPathRegistry, ClassLoaderFactory classLoaderFactory) {\n        // Add in tools.jar to the Ant classloader\n        ClassLoader antClassLoader = Project.class.getClassLoader();\n        File toolsJar = Jvm.current().getToolsJar();\n        if (toolsJar != null) {\n            ClasspathUtil.addUrl((URLClassLoader) antClassLoader, GFileUtils.toURLs(Collections.singleton(toolsJar)));\n        }\n\n        ClassLoader runtimeClassLoader = getClass().getClassLoader();\n\n        // Core impl\n        URL[] coreImplClassPath = classPathRegistry.getClassPath(\"GRADLE_CORE_IMPL\").getAsURLArray();\n        coreImplClassLoader = new URLClassLoader(coreImplClassPath, runtimeClassLoader);\n\n        // Add in libs for plugins\n        URL[] pluginsClassPath = classPathRegistry.getClassPath(\"GRADLE_PLUGINS\").getAsURLArray();\n        MultiParentClassLoader pluginsImports = new MultiParentClassLoader(runtimeClassLoader, coreImplClassLoader);\n        pluginsClassLoader = new URLClassLoader(pluginsClassPath, pluginsImports);\n\n        rootClassLoader = classLoaderFactory.createFilteringClassLoader(pluginsClassLoader);\n        rootClassLoader.allowPackage(\"org.gradle\");\n        rootClassLoader.allowResources(\"META-INF/gradle-plugins\");\n        rootClassLoader.allowPackage(\"org.apache.tools.ant\");\n        rootClassLoader.allowPackage(\"groovy\");\n        rootClassLoader.allowPackage(\"org.codehaus.groovy\");\n        rootClassLoader.allowPackage(\"groovyjarjarantlr\");\n        rootClassLoader.allowPackage(\"org.apache.ivy\");\n        rootClassLoader.allowPackage(\"org.slf4j\");\n        rootClassLoader.allowPackage(\"org.apache.commons.logging\");\n        rootClassLoader.allowPackage(\"org.apache.log4j\");\n    }","id":87722,"modified_method":"public DefaultClassLoaderRegistry(ClassPathRegistry classPathRegistry, ClassLoaderFactory classLoaderFactory) {\n        // Add in tools.jar to the Ant classloader\n        ClassLoader antClassLoader = Project.class.getClassLoader();\n        File toolsJar = Jvm.current().getToolsJar();\n        if (toolsJar != null) {\n            ClasspathUtil.addUrl((URLClassLoader) antClassLoader, GFileUtils.toURLs(Collections.singleton(toolsJar)));\n        }\n\n        ClassLoader runtimeClassLoader = getClass().getClassLoader();\n\n        // Core impl\n        ClassPath coreImplClassPath = classPathRegistry.getClassPath(\"GRADLE_CORE_IMPL\");\n        coreImplClassLoader = new MutableURLClassLoader(runtimeClassLoader, coreImplClassPath);\n\n        // Add in libs for plugins\n        ClassPath pluginsClassPath = classPathRegistry.getClassPath(\"GRADLE_PLUGINS\");\n        MultiParentClassLoader pluginsImports = new MultiParentClassLoader(runtimeClassLoader, coreImplClassLoader);\n        pluginsClassLoader = new MutableURLClassLoader(pluginsImports, pluginsClassPath);\n\n        rootClassLoader = classLoaderFactory.createFilteringClassLoader(pluginsClassLoader);\n        rootClassLoader.allowPackage(\"org.gradle\");\n        rootClassLoader.allowResources(\"META-INF/gradle-plugins\");\n        rootClassLoader.allowPackage(\"org.apache.tools.ant\");\n        rootClassLoader.allowPackage(\"groovy\");\n        rootClassLoader.allowPackage(\"org.codehaus.groovy\");\n        rootClassLoader.allowPackage(\"groovyjarjarantlr\");\n        rootClassLoader.allowPackage(\"org.apache.ivy\");\n        rootClassLoader.allowPackage(\"org.slf4j\");\n        rootClassLoader.allowPackage(\"org.apache.commons.logging\");\n        rootClassLoader.allowPackage(\"org.apache.log4j\");\n    }","commit_id":"dbc305c0612bf17c22290b1dec32cef26b7cba32","url":"https://github.com/gradle/gradle"},{"original_method":"public IsolatedApplicationClassLoaderWorker(Collection<URL> applicationClassPath, Action<WorkerContext> worker) {\n        this.applicationClassPath = applicationClassPath;\n        this.worker = worker;\n    }","id":87723,"modified_method":"public IsolatedApplicationClassLoaderWorker(Collection<URI> applicationClassPath, Action<WorkerContext> worker) {\n        this.applicationClassPath = applicationClassPath;\n        this.worker = worker;\n    }","commit_id":"dbc305c0612bf17c22290b1dec32cef26b7cba32","url":"https://github.com/gradle/gradle"},{"original_method":"private void runNoExit(String mainClassName, String[] args) throws Exception {\n        ClassPathRegistry classPathRegistry = new DefaultClassPathRegistry(new DefaultClassPathProvider(new DefaultModuleRegistry()));\n        ClassLoaderFactory classLoaderFactory = new DefaultClassLoaderFactory();\n        Collection<URL> antClasspath = classPathRegistry.getClassPath(\"ANT\").getAsURLs();\n        URL[] runtimeClasspath = classPathRegistry.getClassPath(\"GRADLE_RUNTIME\").getAsURLArray();\n        ClassLoader antClassLoader = classLoaderFactory.createIsolatedClassLoader(antClasspath);\n        ClassLoader runtimeClassLoader = new URLClassLoader(runtimeClasspath, antClassLoader);\n        Thread.currentThread().setContextClassLoader(runtimeClassLoader);\n        Class<?> mainClass = runtimeClassLoader.loadClass(mainClassName);\n        Method mainMethod = mainClass.getMethod(\"main\", String[].class);\n        mainMethod.invoke(null, new Object[]{args});\n    }","id":87724,"modified_method":"private void runNoExit(String mainClassName, String[] args) throws Exception {\n        ClassPathRegistry classPathRegistry = new DefaultClassPathRegistry(new DefaultClassPathProvider(new DefaultModuleRegistry()));\n        ClassLoaderFactory classLoaderFactory = new DefaultClassLoaderFactory();\n        ClassPath antClasspath = classPathRegistry.getClassPath(\"ANT\");\n        ClassPath runtimeClasspath = classPathRegistry.getClassPath(\"GRADLE_RUNTIME\");\n        ClassLoader antClassLoader = classLoaderFactory.createIsolatedClassLoader(antClasspath);\n        ClassLoader runtimeClassLoader = new MutableURLClassLoader(antClassLoader, runtimeClasspath);\n        Thread.currentThread().setContextClassLoader(runtimeClassLoader);\n        Class<?> mainClass = runtimeClassLoader.loadClass(mainClassName);\n        Method mainMethod = mainClass.getMethod(\"main\", String[].class);\n        mainMethod.invoke(null, new Object[]{args});\n    }","commit_id":"dbc305c0612bf17c22290b1dec32cef26b7cba32","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n\t * Run the algorithm.\n\t * Afterwards, caller can use the getStartFact() and getResultFact() methods to\n\t * to get dataflow facts at start and result points of each block.\n\t */\n\tpublic void execute() throws DataflowAnalysisException {\n\t\tboolean change;\n\n\t\tif (DEBUG) {\n\t\t\tString shortAnalysisName = analysis.getClass().getName();\n\t\t\tint pkgEnd = shortAnalysisName.lastIndexOf('.');\n\t\t\tif (pkgEnd >= 0) {\n\t\t\t\tshortAnalysisName = shortAnalysisName.substring(pkgEnd + 1);\n\t\t\t}\n\t\t\tSystem.out.println(\"Executing \" + shortAnalysisName + \" on \" + cfg.getMethodName());\n\t\t}\n\n\t\tint timestamp = 0;\n\t\tdo {\n\t\t\tchange = false;\n\t\t\t++numIterations;\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t\tSystem.out.println(this.getClass().getName() + \" iteration: \" + numIterations + \", timestamp: \" + timestamp);\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t}\n\n\t\t\tif (numIterations >= MAX_ITERS)\n\t\t\t\tthrow new DataflowAnalysisException(\"Too many iterations (\" + numIterations + \") in dataflow!\");\n\t\n\t\t\tanalysis.startIteration();\n\t\t\t\n\t\t\tif (DEBUG) {\n\t\t\t\tif (blockOrder instanceof ReverseDFSOrder) {\n\t\t\t\t\tReverseDFSOrder rBlockOrder = (ReverseDFSOrder) blockOrder;\n\t\t\t\t\tSystem.out.println(\"Entry point is: \" + logicalEntryBlock());\n\t\t\t\t\tSystem.out.println(\"Basic block order: \");\n\t\t\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\t\t\twhile (i.hasNext()) {\n\n\t\t\t\t\t\tBasicBlock block = i.next();\n\t\t\t\t\t\tif (DEBUG) debug(block, \"rBlockOrder \" + rBlockOrder.rdfs.getDiscoveryTime(block) + \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// For each block in CFG...\n\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\twhile (i.hasNext()) {\n\n\t\t\t\tBasicBlock block = i.next();\n\t\t\t\tif (DEBUG) debug(block, \"start\\n\");\n\t\n\t\t\t\t// Get start fact for block.\n\t\t\t\tFact start = analysis.getStartFact(block);\n\t\t\t\tboolean needToRecompute = false;\n\t\n\t\t\t\t// Meet all of the logical predecessor results into this block's start.\n\t\t\t\t// Special case: if the block is the logical entry, then it gets\n\t\t\t\t// the special \"entry fact\".\n\t\t\t\tif (block == logicalEntryBlock()) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tanalysis.initEntryFact(start);\n\t\t\t\t\tif (DEBUG) debug(block, \"Init entry fact ==> \" + start + \"\\n\");\n\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t} else {\n\t\t\t\t\tint lastUpdated = analysis.getLastUpdateTimestamp(start);\n\t\t\t\t\tIterator<Edge> predEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\tint predCount = 0;\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\tpredCount++;\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\tif (predLastUpdated >= lastUpdated) {\n\t\t\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (predCount == 0) needToRecompute = true;\n\t\t\t\t\tif (!needToRecompute) {\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tdebug(block, \"Skipping: predecessors haven't changed\");\n\t\t\t\t\t\t\tSystem.out.println(\" curr timestamp: \" + timestamp);\n\t\t\t\t\t\t\tSystem.out.println(\" last timestamp: \" + lastUpdated);\n\t\t\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\t\t\tSystem.out.println(\" pred timestamp: \" + predLastUpdated);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.println(\"Fact: \" + start);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (true) continue;\n\t\t\t\t\t}\n\t\t\t\t\tif (needToRecompute) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply the edge transfer function.\n\t\t\t\t\t\tFact edgeFact = analysis.createFact(); \n\t\t\t\t\t\tanalysis.copy(predFact, edgeFact);\n\t\t\t\t\t\tanalysis.edgeTransfer(edge, edgeFact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (DEBUG && !analysis.same(edgeFact, predFact)) {\n\t\t\t\t\t\t\tdebug(block, logicalPred, edge,\n\t\t\t\t\t\t\t\t\t\"Edge transfer \" + predFact + \" ==> \" + edgeFact);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Merge the predecessor fact (possibly transformed by the edge transfer function)\n\t\t\t\t\t\t// into the block's start fact.\n\t\t\t\t\t\tif (DEBUG) debug(block, logicalPred, edge, \"Meet \" + start + \" with \" + edgeFact);\n\t\t\t\t\t\tanalysis.meetInto(edgeFact, edge, start);\n\t\t\t\t\t\tif (DEBUG) System.out.println(\" ==> \" + start);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (DEBUG) debug(block, \"start fact is \" + start + \"\\n\");\n\t\n\t\t\t\n\t\t\t\t// Get result facts for block,\n\t\t\t\t// making a copy of it (so we can detect if it changed).\n\t\t\t\tFact result = analysis.getResultFact(block);\n\t\t\t\tFact origResult = analysis.createFact();\n\t\t\t\tanalysis.copy(result, origResult);\n\t\n\t\t\t\t// Apply the transfer function.\n\t\t\t\tanalysis.transfer(block, null, start, result);\n\n\t\t\t\tif (DEBUG && SystemProperties.getBoolean(\"dataflow.blockdebug\")) {\n\t\t\t\t\tdebug(block, \"Dumping flow values for block:\\n\");\n\t\t\t\t\tIterator<org.apache.bcel.generic.InstructionHandle> ii = block.instructionIterator();\n\t\t\t\t\twhile (ii.hasNext()) {\n\t\t\t\t\t\torg.apache.bcel.generic.InstructionHandle handle = ii.next();\n\t\t\t\t\t\tFact tmpResult = analysis.createFact();\n\t\t\t\t\t\tanalysis.transfer(block, handle, start, tmpResult);\n\t\t\t\t\t\tSystem.out.println(\"\\t\" + handle + \" \" + tmpResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// See if the result changed.\n\t\t\t\tif (DEBUG) debug(block, \"orig result is \" + origResult + \"\\n\");\n\t\t\t\tif (!analysis.same(result, origResult)) {\n\t\t\t\t\tif (DEBUG) debug(block, \"result changed!\\n\");\n\t\t\t\t\tif (DEBUG && !needToRecompute) {\n\t\t\t\t\t\tSystem.out.println(\"I thought I didn't need to recompute\");\n\t\t\t\t\t}\n\t\t\t\t\tchange = true;\n\t\t\t\t\ttimestamp++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tanalysis.setLastUpdateTimestamp(result, timestamp);\n\t\t\t\tif (DEBUG) debug(block, \"result is \" + result + \"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tanalysis.finishIteration();\n\t\t} while (change);\n\t}","id":87725,"modified_method":"/**\n\t * Run the algorithm.\n\t * Afterwards, caller can use the getStartFact() and getResultFact() methods to\n\t * to get dataflow facts at start and result points of each block.\n\t */\n\tpublic void execute() throws DataflowAnalysisException {\n\t\tboolean change;\n\n\t\tif (DEBUG) {\n\t\t\tString shortAnalysisName = analysis.getClass().getName();\n\t\t\tint pkgEnd = shortAnalysisName.lastIndexOf('.');\n\t\t\tif (pkgEnd >= 0) {\n\t\t\t\tshortAnalysisName = shortAnalysisName.substring(pkgEnd + 1);\n\t\t\t}\n\t\t\tSystem.out.println(\"Executing \" + shortAnalysisName + \" on \" + cfg.getMethodName());\n\t\t}\n\n\t\tint timestamp = 0;\n\t\tdo {\n\t\t\tchange = false;\n\t\t\t++numIterations;\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t\tSystem.out.println(this.getClass().getName() + \" iteration: \" + numIterations + \", timestamp: \" + timestamp);\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t}\n\n\t\t\tif (numIterations >= MAX_ITERS)\n\t\t\t\tthrow new DataflowAnalysisException(\"Too many iterations (\" + numIterations + \") in dataflow!\");\n\t\n\t\t\tanalysis.startIteration();\n\t\t\t\n\t\t\tif (DEBUG) {\n\t\t\t\tif (blockOrder instanceof ReverseDFSOrder) {\n\t\t\t\t\tReverseDFSOrder rBlockOrder = (ReverseDFSOrder) blockOrder;\n\t\t\t\t\tSystem.out.println(\"Entry point is: \" + logicalEntryBlock());\n\t\t\t\t\tSystem.out.println(\"Basic block order: \");\n\t\t\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\t\t\twhile (i.hasNext()) {\n\n\t\t\t\t\t\tBasicBlock block = i.next();\n\t\t\t\t\t\tif (DEBUG) debug(block, \"rBlockOrder \" + rBlockOrder.rdfs.getDiscoveryTime(block) + \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// For each block in CFG...\n\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\twhile (i.hasNext()) {\n\n\t\t\t\tBasicBlock block = i.next();\n\t\t\t\tif (DEBUG) debug(block, \"start\\n\");\n\t\n\t\t\t\t// Get start fact for block.\n\t\t\t\tFact start = analysis.getStartFact(block);\n\t\t\t\tboolean needToRecompute = false;\n\t\t\t\t//\t\t\t\t Get result facts for block,\n\t\t\t\tFact originalResult = analysis.getResultFact(block);\n\t\t\t\t\n\t\t\t\t// Meet all of the logical predecessor results into this block's start.\n\t\t\t\t// Special case: if the block is the logical entry, then it gets\n\t\t\t\t// the special \"entry fact\".\n\t\t\t\tif (block == logicalEntryBlock()) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tanalysis.initEntryFact(start);\n\t\t\t\t\tif (DEBUG) debug(block, \"Init entry fact ==> \" + start + \"\\n\");\n\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t} else {\n\t\t\t\t\tint lastUpdated = analysis.getLastUpdateTimestamp(originalResult);\n\t\t\t\t\tIterator<Edge> predEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\tint predCount = 0;\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\tif (!analysis.isTop(predFact)) {\n\t\t\t\t\t\t\tpredCount++;\n\t\t\t\t\t\t\tif (predLastUpdated >= lastUpdated) {\n\n\t\t\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Need to recompute. My timestamp = \" + lastUpdated + \", pred timestamp = \" + predLastUpdated + \", pred fact = \" + predFact);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (predCount == 0) needToRecompute = true;\n\t\t\t\t\tif (!needToRecompute) {\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tdebug(block, \"Skipping: predecessors haven't changed\");\n\t\t\t\t\t\t\tSystem.out.println(\" curr timestamp: \" + timestamp);\n\t\t\t\t\t\t\tSystem.out.println(\" last timestamp: \" + lastUpdated);\n\t\t\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\t\t\tSystem.out.println(\" pred timestamp: \" + predLastUpdated);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.println(\"Fact: \" + start);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (true) continue;\n\t\t\t\t\t}\n\t\t\t\t\tif (needToRecompute) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply the edge transfer function.\n\t\t\t\t\t\tFact edgeFact = analysis.createFact(); \n\t\t\t\t\t\tanalysis.copy(predFact, edgeFact);\n\t\t\t\t\t\tanalysis.edgeTransfer(edge, edgeFact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (DEBUG && !analysis.same(edgeFact, predFact)) {\n\t\t\t\t\t\t\tdebug(block, logicalPred, edge,\n\t\t\t\t\t\t\t\t\t\"Edge transfer \" + predFact + \" ==> \" + edgeFact);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Merge the predecessor fact (possibly transformed by the edge transfer function)\n\t\t\t\t\t\t// into the block's start fact.\n\t\t\t\t\t\tif (DEBUG) debug(block, logicalPred, edge, \"Meet \" + start + \" with \" + edgeFact);\n\t\t\t\t\t\tanalysis.meetInto(edgeFact, edge, start);\n\t\t\t\t\t\tif (DEBUG) System.out.println(\" ==> \" + start);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (DEBUG) debug(block, \"start fact is \" + start + \"\\n\");\n\t\n\t\t\t\t// compute result in temporary location\n\t\t\t\tFact result = analysis.createFact();\n\t\n\t\t\t\tif (true || analysis.isTop(start)) {\n\t\t\t\t\t// Apply the transfer function.\n\t\t\t\t\tanalysis.transfer(block, null, start, result);\n\t\t\t\t} else {\n\t\t\t\t\tanalysis.makeFactTop(result);\n\t\t\t\t}\n\n\t\t\t\tif (DEBUG && SystemProperties.getBoolean(\"dataflow.blockdebug\")) {\n\t\t\t\t\tdebug(block, \"Dumping flow values for block:\\n\");\n\t\t\t\t\tIterator<org.apache.bcel.generic.InstructionHandle> ii = block.instructionIterator();\n\t\t\t\t\twhile (ii.hasNext()) {\n\t\t\t\t\t\torg.apache.bcel.generic.InstructionHandle handle = ii.next();\n\t\t\t\t\t\tFact tmpResult = analysis.createFact();\n\t\t\t\t\t\tanalysis.transfer(block, handle, start, tmpResult);\n\t\t\t\t\t\tSystem.out.println(\"\\t\" + handle + \" \" + tmpResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// See if the result changed.\n\t\t\t\tif (DEBUG) debug(block, \"orig result is \" + originalResult + \"\\n\");\n\t\t\t\tif (!analysis.same(result, originalResult)) {\n\t\t\t\t\ttimestamp++;\n\t\t\t\t\tif (DEBUG) debug(block, \"result changed at timestamp \" + timestamp + \"\\n\");\n\t\t\t\t\tif (DEBUG && !needToRecompute) {\n\t\t\t\t\t\tSystem.out.println(\"I thought I didn't need to recompute\");\n\t\t\t\t\t}\n\t\t\t\t\tchange = true;\n\t\t\t\t\tanalysis.copy(result, originalResult);\n\t\t\t\t\tanalysis.setLastUpdateTimestamp(originalResult, timestamp);\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (DEBUG) debug(block, \"result is \" + result + \" @ timestamp \" \n\t\t\t\t\t\t+ analysis.getLastUpdateTimestamp(result) + \"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tanalysis.finishIteration();\n\t\t} while (change);\n\t}","commit_id":"629f640ecf2738e43b8ec162f8add2a7fad905ad","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Make this Frame exactly the same as the one given as a parameter.\n\t * \n\t * @param other\n\t *            the Frame to make this object the same as\n\t */\n\tpublic void copyFrom(Frame<ValueType> other) {\n\t\tint size = slotList.size();\n\t\tif (size == other.slotList.size()) {\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tslotList.set(i, other.slotList.get(i));\n\t\t} else {\n\t\t\tslotList.clear();\n\t\t\tfor (ValueType v : other.slotList)\n\t\t\t\tslotList.add(v);\n\t\t}\n\t\tisTop = other.isTop;\n\t\tisBottom = other.isBottom;\n\t}","id":87726,"modified_method":"/**\n\t * Make this Frame exactly the same as the one given as a parameter.\n\t * \n\t * @param other\n\t *            the Frame to make this object the same as\n\t */\n\tpublic void copyFrom(Frame<ValueType> other) {\n\t\tlastUpdateTimestamp = other.lastUpdateTimestamp;\n\t\tint size = slotList.size();\n\t\tif (size == other.slotList.size()) {\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tslotList.set(i, other.slotList.get(i));\n\t\t} else {\n\t\t\tslotList.clear();\n\t\t\tfor (ValueType v : other.slotList)\n\t\t\t\tslotList.add(v);\n\t\t}\n\t\tisTop = other.isTop;\n\t\tisBottom = other.isBottom;\n\t}","commit_id":"629f640ecf2738e43b8ec162f8add2a7fad905ad","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Make this frame the special \"TOP\" value. Such Frames are the identity\n\t * element of the meet operation.\n\t */\n\tpublic void setTop() {\n\t\tisTop = true;\n\t\tisBottom = false;\n\t}","id":87727,"modified_method":"/**\n\t * Make this frame the special \"TOP\" value. Such Frames are the identity\n\t * element of the meet operation.\n\t */\n\tpublic void setTop() {\n\t\tisTop = true;\n\t\tisBottom = false;\n\t\tlastUpdateTimestamp = 0;\n\t}","commit_id":"629f640ecf2738e43b8ec162f8add2a7fad905ad","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Make this dataflow fact the top value.\n\t */\n\tpublic void setIsTop() {\n\t\tclear();\n\t\tvalueNumberSet.set(numValueNumbersInMethod + 1);\n\t}","id":87728,"modified_method":"/**\n\t * Make this dataflow fact the top value.\n\t */\n\tpublic void setIsTop() {\n\t\tclear();\n\t\tvalueNumberSet.set(numValueNumbersInMethod + 1);\n\t\tlastUpdateTimestamp = 0;\n\t}","commit_id":"629f640ecf2738e43b8ec162f8add2a7fad905ad","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Make this dataflow fact the same as the given one.\n\t * \n\t * @param source another dataflow fact\n\t */\n\tpublic void makeSameAs(UnconditionalValueDerefSet source) {\n\t\t// Copy value numbers\n\t\tvalueNumberSet.clear();\n\t\tvalueNumberSet.or(source.valueNumberSet);\n\n\t\t// Copy dereference locations for each value number\n\t\tderefLocationSetMap.clear();\n\t\tfor (Map.Entry<ValueNumber, Set<Location>> sourceEntry : source.derefLocationSetMap.entrySet()) {\n\t\t\tSet<Location> derefLocationSet = new HashSet<Location>();\n\t\t\tderefLocationSet.addAll(sourceEntry.getValue());\n\t\t\tderefLocationSetMap.put(sourceEntry.getKey(), derefLocationSet);\n\t\t}\n\t}","id":87729,"modified_method":"/**\n\t * Make this dataflow fact the same as the given one.\n\t * \n\t * @param source another dataflow fact\n\t */\n\tpublic void makeSameAs(UnconditionalValueDerefSet source) {\n\t\t// Copy value numbers\n\t\tvalueNumberSet.clear();\n\t\tvalueNumberSet.or(source.valueNumberSet);\n\t\tlastUpdateTimestamp = source.lastUpdateTimestamp;\n\t\t// Copy dereference locations for each value number\n\t\tderefLocationSetMap.clear();\n\t\tfor (Map.Entry<ValueNumber, Set<Location>> sourceEntry : source.derefLocationSetMap.entrySet()) {\n\t\t\tSet<Location> derefLocationSet = new HashSet<Location>();\n\t\t\tderefLocationSet.addAll(sourceEntry.getValue());\n\t\t\tderefLocationSetMap.put(sourceEntry.getKey(), derefLocationSet);\n\t\t}\n\t}","commit_id":"629f640ecf2738e43b8ec162f8add2a7fad905ad","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n\t * Run the algorithm.\n\t * Afterwards, caller can use the getStartFact() and getResultFact() methods to\n\t * to get dataflow facts at start and result points of each block.\n\t */\n\tpublic void execute() throws DataflowAnalysisException {\n\t\tboolean change;\n\n\t\tif (DEBUG) {\n\t\t\tString shortAnalysisName = analysis.getClass().getName();\n\t\t\tint pkgEnd = shortAnalysisName.lastIndexOf('.');\n\t\t\tif (pkgEnd >= 0) {\n\t\t\t\tshortAnalysisName = shortAnalysisName.substring(pkgEnd + 1);\n\t\t\t}\n\t\t\tSystem.out.println(\"Executing \" + shortAnalysisName + \" on \" + cfg.getMethodName());\n\t\t}\n\n\t\tint timestamp = 0;\n\t\tdo {\n\t\t\tchange = false;\n\t\t\t++numIterations;\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t\tSystem.out.println(this.getClass().getName() + \" iteration: \" + numIterations + \", timestamp: \" + timestamp);\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t}\n\n\t\t\tif (numIterations >= MAX_ITERS)\n\t\t\t\tthrow new DataflowAnalysisException(\"Too many iterations (\" + numIterations + \") in dataflow!\");\n\t\n\t\t\tanalysis.startIteration();\n\t\t\t\n\t\t\tif (DEBUG) {\n\t\t\t\tif (blockOrder instanceof ReverseDFSOrder) {\n\t\t\t\t\tReverseDFSOrder rBlockOrder = (ReverseDFSOrder) blockOrder;\n\t\t\t\t\tSystem.out.println(\"Entry point is: \" + logicalEntryBlock());\n\t\t\t\t\tSystem.out.println(\"Basic block order: \");\n\t\t\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\t\t\twhile (i.hasNext()) {\n\n\t\t\t\t\t\tBasicBlock block = i.next();\n\t\t\t\t\t\tif (DEBUG) debug(block, \"rBlockOrder \" + rBlockOrder.rdfs.getDiscoveryTime(block) + \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// For each block in CFG...\n\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\twhile (i.hasNext()) {\n\n\t\t\t\tBasicBlock block = i.next();\n\t\t\t\tif (DEBUG) debug(block, \"start\\n\");\n\t\n\t\t\t\t// Get start fact for block.\n\t\t\t\tFact start = analysis.getStartFact(block);\n\t\t\t\tboolean needToRecompute = false;\n\t\t\t\t//\t\t\t\t Get result facts for block,\n\t\t\t\tFact originalResult = analysis.getResultFact(block);\n\t\t\t\t\n\t\t\t\t// Meet all of the logical predecessor results into this block's start.\n\t\t\t\t// Special case: if the block is the logical entry, then it gets\n\t\t\t\t// the special \"entry fact\".\n\t\t\t\tif (block == logicalEntryBlock()) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tanalysis.initEntryFact(start);\n\t\t\t\t\tif (DEBUG) debug(block, \"Init entry fact ==> \" + start + \"\\n\");\n\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t} else {\n\t\t\t\t\tint lastUpdated = analysis.getLastUpdateTimestamp(originalResult);\n\t\t\t\t\tIterator<Edge> predEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\tint predCount = 0;\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\tif (!analysis.isTop(predFact)) {\n\t\t\t\t\t\t\tpredCount++;\n\t\t\t\t\t\t\tif (predLastUpdated >= lastUpdated) {\n\n\t\t\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Need to recompute. My timestamp = \" + lastUpdated + \", pred timestamp = \" + predLastUpdated + \", pred fact = \" + predFact);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (predCount == 0) needToRecompute = true;\n\t\t\t\t\tif (!needToRecompute) {\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tdebug(block, \"Skipping: predecessors haven't changed\");\n\t\t\t\t\t\t\tSystem.out.println(\" curr timestamp: \" + timestamp);\n\t\t\t\t\t\t\tSystem.out.println(\" last timestamp: \" + lastUpdated);\n\t\t\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\t\t\tSystem.out.println(\" pred timestamp: \" + predLastUpdated);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.println(\"Fact: \" + start);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (true) continue;\n\t\t\t\t\t}\n\t\t\t\t\tif (needToRecompute) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply the edge transfer function.\n\t\t\t\t\t\tFact edgeFact = analysis.createFact(); \n\t\t\t\t\t\tanalysis.copy(predFact, edgeFact);\n\t\t\t\t\t\tanalysis.edgeTransfer(edge, edgeFact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (DEBUG && !analysis.same(edgeFact, predFact)) {\n\t\t\t\t\t\t\tdebug(block, logicalPred, edge,\n\t\t\t\t\t\t\t\t\t\"Edge transfer \" + predFact + \" ==> \" + edgeFact);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Merge the predecessor fact (possibly transformed by the edge transfer function)\n\t\t\t\t\t\t// into the block's start fact.\n\t\t\t\t\t\tif (DEBUG) debug(block, logicalPred, edge, \"Meet \" + start + \" with \" + edgeFact);\n\t\t\t\t\t\tanalysis.meetInto(edgeFact, edge, start);\n\t\t\t\t\t\tif (DEBUG) System.out.println(\" ==> \" + start);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (DEBUG) debug(block, \"start fact is \" + start + \"\\n\");\n\t\n\t\t\t\t// compute result in temporary location\n\t\t\t\tFact result = analysis.createFact();\n\t\n\t\t\t\tif (true || analysis.isTop(start)) {\n\t\t\t\t\t// Apply the transfer function.\n\t\t\t\t\tanalysis.transfer(block, null, start, result);\n\t\t\t\t} else {\n\t\t\t\t\tanalysis.makeFactTop(result);\n\t\t\t\t}\n\n\t\t\t\tif (DEBUG && SystemProperties.getBoolean(\"dataflow.blockdebug\")) {\n\t\t\t\t\tdebug(block, \"Dumping flow values for block:\\n\");\n\t\t\t\t\tIterator<org.apache.bcel.generic.InstructionHandle> ii = block.instructionIterator();\n\t\t\t\t\twhile (ii.hasNext()) {\n\t\t\t\t\t\torg.apache.bcel.generic.InstructionHandle handle = ii.next();\n\t\t\t\t\t\tFact tmpResult = analysis.createFact();\n\t\t\t\t\t\tanalysis.transfer(block, handle, start, tmpResult);\n\t\t\t\t\t\tSystem.out.println(\"\\t\" + handle + \" \" + tmpResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// See if the result changed.\n\t\t\t\tif (DEBUG) debug(block, \"orig result is \" + originalResult + \"\\n\");\n\t\t\t\tif (!analysis.same(result, originalResult)) {\n\t\t\t\t\ttimestamp++;\n\t\t\t\t\tif (DEBUG) debug(block, \"result changed at timestamp \" + timestamp + \"\\n\");\n\t\t\t\t\tif (DEBUG && !needToRecompute) {\n\t\t\t\t\t\tSystem.out.println(\"I thought I didn't need to recompute\");\n\t\t\t\t\t}\n\t\t\t\t\tchange = true;\n\t\t\t\t\tanalysis.copy(result, originalResult);\n\t\t\t\t\tanalysis.setLastUpdateTimestamp(originalResult, timestamp);\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (DEBUG) debug(block, \"result is \" + result + \" @ timestamp \" \n\t\t\t\t\t\t+ analysis.getLastUpdateTimestamp(result) + \"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tanalysis.finishIteration();\n\t\t} while (change);\n\t}","id":87730,"modified_method":"/**\n\t * Run the algorithm.\n\t * Afterwards, caller can use the getStartFact() and getResultFact() methods to\n\t * to get dataflow facts at start and result points of each block.\n\t */\n\tpublic void execute() throws DataflowAnalysisException {\n\t\tboolean change;\n\n\t\tif (DEBUG) {\n\t\t\tString shortAnalysisName = analysis.getClass().getName();\n\t\t\tint pkgEnd = shortAnalysisName.lastIndexOf('.');\n\t\t\tif (pkgEnd >= 0) {\n\t\t\t\tshortAnalysisName = shortAnalysisName.substring(pkgEnd + 1);\n\t\t\t}\n\t\t\tSystem.out.println(\"Executing \" + shortAnalysisName + \" on \" + cfg.getMethodName());\n\t\t}\n\n\t\tint timestamp = 0;\n\t\tdo {\n\t\t\tchange = false;\n\t\t\t++numIterations;\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t\tSystem.out.println(this.getClass().getName() + \" iteration: \" + numIterations + \", timestamp: \" + timestamp);\n\t\t\t\tSystem.out.println(\"----------------------------------------------------------------------\");\n\t\t\t}\n\n\t\t\tif (numIterations >= MAX_ITERS)\n\t\t\t\tthrow new DataflowAnalysisException(\"Too many iterations (\" + numIterations + \") in dataflow!\");\n\t\n\t\t\tanalysis.startIteration();\n\t\t\t\n\t\t\tif (DEBUG) {\n\t\t\t\tif (blockOrder instanceof ReverseDFSOrder) {\n\t\t\t\t\tReverseDFSOrder rBlockOrder = (ReverseDFSOrder) blockOrder;\n\t\t\t\t\tSystem.out.println(\"Entry point is: \" + logicalEntryBlock());\n\t\t\t\t\tSystem.out.println(\"Basic block order: \");\n\t\t\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\t\t\twhile (i.hasNext()) {\n\n\t\t\t\t\t\tBasicBlock block = i.next();\n\t\t\t\t\t\tif (DEBUG) debug(block, \"rBlockOrder \" + rBlockOrder.rdfs.getDiscoveryTime(block) + \"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// For each block in CFG...\n\t\t\tIterator<BasicBlock> i = blockOrder.blockIterator();\n\t\t\twhile (i.hasNext()) {\n\n\t\t\t\tBasicBlock block = i.next();\n\t\t\t\tif (DEBUG) debug(block, \"start\\n\");\n\t\n\t\t\t\t// Get start fact for block.\n\t\t\t\tFact start = analysis.getStartFact(block);\n\t\t\t\tboolean needToRecompute = false;\n\t\t\t\t//\t\t\t\t Get result facts for block,\n\t\t\t\tFact result = analysis.getResultFact(block);\n\t\t\t\t\n\t\t\t\t// Meet all of the logical predecessor results into this block's start.\n\t\t\t\t// Special case: if the block is the logical entry, then it gets\n\t\t\t\t// the special \"entry fact\".\n\t\t\t\tif (block == logicalEntryBlock()) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tanalysis.initEntryFact(start);\n\t\t\t\t\tif (DEBUG) debug(block, \"Init entry fact ==> \" + start + \"\\n\");\n\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t} else {\n\t\t\t\t\tint lastUpdated = analysis.getLastUpdateTimestamp(result);\n\t\t\t\t\tIterator<Edge> predEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\tint predCount = 0;\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\tif (!analysis.isTop(predFact)) {\n\t\t\t\t\t\t\tpredCount++;\n\t\t\t\t\t\t\tif (predLastUpdated >= lastUpdated) {\n\n\t\t\t\t\t\t\tneedToRecompute = true;\n\t\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tSystem.out.println(\"Need to recompute. My timestamp = \" + lastUpdated + \", pred timestamp = \" + predLastUpdated + \", pred fact = \" + predFact);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (predCount == 0) needToRecompute = true;\n\t\t\t\t\tif (!needToRecompute) {\n\t\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\t\tdebug(block, \"Skipping: predecessors haven't changed\");\n\t\t\t\t\t\t\tSystem.out.println(\" curr timestamp: \" + timestamp);\n\t\t\t\t\t\t\tSystem.out.println(\" last timestamp: \" + lastUpdated);\n\t\t\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\n\t\t\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\t\tint predLastUpdated = analysis.getLastUpdateTimestamp(predFact);\n\t\t\t\t\t\t\t\tSystem.out.println(\" pred timestamp: \" + predLastUpdated);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.println(\"Fact: \" + start);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (false) continue;\n\t\t\t\t\t}\n\t\t\t\t\tif (needToRecompute) {\n\t\t\t\t\tanalysis.makeFactTop(start);\n\t\t\t\t\tpredEdgeIter = logicalPredecessorEdgeIterator(block);\n\t\t\t\t\twhile (predEdgeIter.hasNext()) {\n\t\t\t\t\t\tEdge edge = predEdgeIter.next();\n\t\t\t\t\t\tBasicBlock logicalPred = isForwards ? edge.getSource() : edge.getTarget();\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Get the predecessor result fact\n\t\t\t\t\t\tFact predFact = analysis.getResultFact(logicalPred);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Apply the edge transfer function.\n\t\t\t\t\t\tFact edgeFact = analysis.createFact(); \n\t\t\t\t\t\tanalysis.copy(predFact, edgeFact);\n\t\t\t\t\t\tanalysis.edgeTransfer(edge, edgeFact);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (DEBUG && !analysis.same(edgeFact, predFact)) {\n\t\t\t\t\t\t\tdebug(block, logicalPred, edge,\n\t\t\t\t\t\t\t\t\t\"Edge transfer \" + predFact + \" ==> \" + edgeFact);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Merge the predecessor fact (possibly transformed by the edge transfer function)\n\t\t\t\t\t\t// into the block's start fact.\n\t\t\t\t\t\tif (DEBUG) debug(block, logicalPred, edge, \"Meet \" + start + \" with \" + edgeFact);\n\t\t\t\t\t\tanalysis.meetInto(edgeFact, edge, start);\n\t\t\t\t\t\tif (DEBUG) System.out.println(\" ==> \" + start);\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (DEBUG) debug(block, \"start fact is \" + start + \"\\n\");\n\t\n\t\t\t\t// making a copy of result facts (so we can detect if it changed).\n\t\t\t\tFact origResult = analysis.createFact();\n\t\t\t\tanalysis.copy(result, origResult);\n\t\n\t\t\t\tif (true || analysis.isTop(start)) {\n\t\t\t\t\t// Apply the transfer function.\n\n\t\t\t\t\tanalysis.transfer(block, null, start, result);\n\t\t\t\t} else {\n\t\t\t\t\tanalysis.copy(start, result);\n\t\t\t\t}\n\n\t\t\t\tif (DEBUG && SystemProperties.getBoolean(\"dataflow.blockdebug\")) {\n\t\t\t\t\tdebug(block, \"Dumping flow values for block:\\n\");\n\t\t\t\t\tIterator<org.apache.bcel.generic.InstructionHandle> ii = block.instructionIterator();\n\t\t\t\t\twhile (ii.hasNext()) {\n\t\t\t\t\t\torg.apache.bcel.generic.InstructionHandle handle = ii.next();\n\t\t\t\t\t\tFact tmpResult = analysis.createFact();\n\t\t\t\t\t\tanalysis.transfer(block, handle, start, tmpResult);\n\t\t\t\t\t\tSystem.out.println(\"\\t\" + handle + \" \" + tmpResult);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// See if the result changed.\n\t\t\t\tif (DEBUG) debug(block, \"orig result is \" + origResult + \"\\n\");\n\t\t\t\tif (!analysis.same(result, origResult)) {\n\t\t\t\t\ttimestamp++;\n\t\t\t\t\tif (DEBUG) debug(block, \"result changed at timestamp \" + timestamp + \"\\n\");\n\t\t\t\t\tif (DEBUG && !needToRecompute) {\n\t\t\t\t\t\tSystem.out.println(\"I thought I didn't need to recompute\");\n\t\t\t\t\t}\n\t\t\t\t\tchange = true;\n\t\t\t\t\tanalysis.setLastUpdateTimestamp(result, timestamp);\n\t\t\t\t} else\n\t\t\t\t\tanalysis.setLastUpdateTimestamp(result, analysis.getLastUpdateTimestamp(origResult));\n\t\t\t\t\n\t\t\t\tif (DEBUG) debug(block, \"result is \" + result + \" @ timestamp \" \n\t\t\t\t\t\t+ analysis.getLastUpdateTimestamp(result) + \"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tanalysis.finishIteration();\n\t\t} while (change);\n\t}","commit_id":"f6c53965d7fc15d27503064350fbde0d7c150904","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Serve the specified resource, optionally including the data content.\n     *\n     * @param request  The servlet request we are processing\n     * @param response The servlet response we are creating\n     * @param content  Should the content be included?\n     * @param encoding The encoding to use if it is necessary to access the\n     *                 source as characters rather than as bytes\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet-specified error occurs\n     */\n    protected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        // Identify the requested resource path\n        String path = getRelativePath(request);\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // SRV.9.3 says we must throw a FNFE\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // Spec doesn't say what to do in this case but a FNFE seems\n                // reasonable\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        // If the resource is not a collection, and the resource path\n        // ends with \"/\" or \"\\\", return NOT FOUND\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST;\n\n        boolean included = false;\n        // Check if the conditions specified in the optional If headers are\n        // satisfied.\n        if (resource.isFile()) {\n            // Checking If headers\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        // Find content type.\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        // These need to reflect the original resource, not the potentially\n        // gzip'd version of the resource so get them now if they are going to\n        // be needed later\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        // Serve a gzipped version of the file if present\n        boolean usingGzippedVersion = false;\n        if (gzip &&\n                resource.isFile() &&\n                !included &&\n                !path.endsWith(\".gz\") &&\n                checkIfGzip(request)) {\n            WebResource gzipResource = resources.getResource(path + \".gz\");\n            if (gzipResource.exists() && gzipResource.isFile()) {\n                response.addHeader(\"Content-Encoding\", \"gzip\");\n                resource = gzipResource;\n                usingGzippedVersion = true;\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            // Skip directory listings if we have been configured to\n            // suppress them\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    // Accept ranges header\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                // Parse range specifier\n                ranges = parseRange(request, response, resource);\n\n                // ETag header\n                response.setHeader(\"ETag\", eTag);\n\n                // Last-Modified header\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            // Get content length\n            contentLength = resource.getContentLength();\n            // Special case for zero length files, which would cause a\n            // (silent) ISE when setting the output buffer size\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            // Trying to retrieve the servlet output stream\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                // If it fails, we try to get a Writer instead if we're\n                // trying to serve a text file\n                if (!usingGzippedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    // Cannot reliably serve partial content with a Writer\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Check to see if a Filter, Valve of wrapper has written some content.\n        // If it has, disable range requests and setting of a content length\n        // since neither can be done reliably.\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            // Set the appropriate output headers\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                // Don't set a content length if something else has already\n                // written to the response.\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            InputStream renderResult = null;\n            if (serveContent) {\n                if (resource.isDirectory()) {\n                    // Serve the directory browser\n                    renderResult = render(getPathPrefix(request), resource);\n                } else {\n                    renderResult = resource.getInputStream();\n                }\n\n                // Copy the input stream to our output stream\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                    // Silent catch\n                }\n                if (ostream != null) {\n                    if (checkSendfile(request, response, resource,\n                            contentLength, null)) {\n                        try {\n                            renderResult.close();\n                        } catch (IOException ioe) {\n                            // Ignore\n                        }\n                    } else {\n                        copy(resource, renderResult, ostream);\n                    }\n                } else {\n                    copy(resource, renderResult, writer, encoding);\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n            // Partial content response.\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n    }","id":87731,"modified_method":"/**\n     * Serve the specified resource, optionally including the data content.\n     *\n     * @param request  The servlet request we are processing\n     * @param response The servlet response we are creating\n     * @param content  Should the content be included?\n     * @param encoding The encoding to use if it is necessary to access the\n     *                 source as characters rather than as bytes\n     *\n     * @exception IOException if an input/output error occurs\n     * @exception ServletException if a servlet-specified error occurs\n     */\n    protected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        // Identify the requested resource path\n        String path = getRelativePath(request);\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // SRV.9.3 says we must throw a FNFE\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                // We're included\n                // Spec doesn't say what to do in this case but a FNFE seems\n                // reasonable\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        // If the resource is not a collection, and the resource path\n        // ends with \"/\" or \"\\\", return NOT FOUND\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            // Check if we're included so we can return the appropriate\n            // missing resource name in the error\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST;\n\n        boolean included = false;\n        // Check if the conditions specified in the optional If headers are\n        // satisfied.\n        if (resource.isFile()) {\n            // Checking If headers\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        // Find content type.\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        // These need to reflect the original resource, not the potentially\n        // gzip'd version of the resource so get them now if they are going to\n        // be needed later\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        // Serve a gzipped version of the file if present\n        boolean usingGzippedVersion = false;\n        if (gzip &&\n                resource.isFile() &&\n                !included &&\n                !path.endsWith(\".gz\") &&\n                checkIfGzip(request)) {\n            WebResource gzipResource = resources.getResource(path + \".gz\");\n            if (gzipResource.exists() && gzipResource.isFile()) {\n                response.addHeader(\"Content-Encoding\", \"gzip\");\n                resource = gzipResource;\n                usingGzippedVersion = true;\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            // Skip directory listings if we have been configured to\n            // suppress them\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    // Accept ranges header\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                // Parse range specifier\n                ranges = parseRange(request, response, resource);\n\n                // ETag header\n                response.setHeader(\"ETag\", eTag);\n\n                // Last-Modified header\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            // Get content length\n            contentLength = resource.getContentLength();\n            // Special case for zero length files, which would cause a\n            // (silent) ISE when setting the output buffer size\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            // Trying to retrieve the servlet output stream\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                // If it fails, we try to get a Writer instead if we're\n                // trying to serve a text file\n                if (!usingGzippedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    // Cannot reliably serve partial content with a Writer\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Check to see if a Filter, Valve of wrapper has written some content.\n        // If it has, disable range requests and setting of a content length\n        // since neither can be done reliably.\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            // Set the appropriate output headers\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                // Don't set a content length if something else has already\n                // written to the response.\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            if (serveContent) {\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                    // Silent catch\n                }\n                InputStream renderResult = null;\n                if (ostream == null) {\n                    // Output via a writer so can't use sendfile or write\n                    // content directly.\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource);\n                    } else {\n                        renderResult = resource.getInputStream();\n                    }\n                    copy(resource, renderResult, writer, encoding);\n                } else {\n                    // Output is via an InputStream\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource);\n                    } else {\n                        // Output is content of resource\n                        if (!checkSendfile(request, response, resource,\n                                contentLength, null)) {\n                            // sendfile not possible so check if resource\n                            // content is available directly\n                            byte[] resourceBody = resource.getContent();\n                            if (resourceBody == null) {\n                                // Resource content not available, use\n                                // inputstream\n                                renderResult = resource.getInputStream();\n                            } else {\n                                // Use the resource content directly\n                                ostream.write(resourceBody);\n                            }\n                        }\n                        // If a stream was configured, it needs to be copied to\n                        // the output (this method closes the stream)\n                        if (renderResult != null) {\n                            copy(resource, renderResult, ostream);\n                        }\n                    }\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n            // Partial content response.\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                        // Silent catch\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        // we should not get here\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n    }","commit_id":"f5fe6209110a9344196daa462dfe30878e4e3fb6","url":"https://github.com/apache/tomcat"},{"original_method":"public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            Repository targetRepository = new Repository( repositoryId, target );\n            getLog().debug( \"username: \" + username );\n            if ( StringUtils.isEmpty( username ) )\n            {\n                copier.copy( source, targetRepository, version );\n            }\n            else\n            {\n                copier.copy( source, targetRepository, version, username );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException(\n                \"Error copying repository from \" + source + \" to \" + target, e );\n        }\n        catch ( WagonException e )\n        {\n            throw new MojoExecutionException(\n                \"Error copying repository from \" + source + \" to \" + target, e );\n        }\n    }","id":87732,"modified_method":"public void execute()\n        throws MojoExecutionException\n    {\n        try\n        {\n            Repository sourceRepository = new Repository( sourceRepositoryId, source );\n            Repository targetRepository = new Repository( targetRepositoryId, target );\n            copier.copy( sourceRepository, targetRepository, version );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException(\n                \"Error copying repository from \" + source + \" to \" + target, e );\n        }\n        catch ( WagonException e )\n        {\n            throw new MojoExecutionException(\n                \"Error copying repository from \" + source + \" to \" + target, e );\n        }\n    }","commit_id":"767a2b09441222b1014beae9872ba57fc849325f","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void copy( String sourceRepositoryUrl, Repository targetRepository, String version )\n        throws WagonException, IOException\n    {\n        copy( sourceRepositoryUrl, targetRepository, version, null );\n    }","id":87733,"modified_method":"public void copy( Repository sourceRepository, Repository targetRepository, String version )\n        throws WagonException, IOException\n    {\n        String prefix = \"staging-plugin\";\n\n        String fileName = prefix + \"-\" + version + \".zip\";\n\n        String tempdir = System.getProperty( \"java.io.tmpdir\" );\n\n        logger.debug( \"Writing all output to \" + tempdir );\n\n        // Create the renameScript script\n\n        String renameScriptName = prefix + \"-\" + version + \"-rename.sh\";\n\n        File renameScript = new File( tempdir, renameScriptName );\n\n        // Work directory\n\n        File basedir = new File( tempdir, prefix + \"-\" + version );\n\n        FileUtils.deleteDirectory( basedir );\n\n        basedir.mkdirs();\n\n        logger.info( \"Downloading files from source repository.\" );\n\n        String protocol = sourceRepository.getProtocol();\n\n        Wagon sourceWagon = wagonManager.getWagon( sourceRepository );\n        AuthenticationInfo sourceAuth = wagonManager.getAuthenticationInfo( sourceRepository.getId() );\n\n        sourceWagon.connect( sourceRepository, sourceAuth );\n\n        List files = new ArrayList();\n\n        scan( sourceWagon, \"\", files );\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            String s = (String) i.next();\n\n            if ( s.indexOf( \".svn\" ) >= 0 )\n            {\n                continue;\n            }\n\n            File f = new File( basedir, s );\n\n            FileUtils.mkdir( f.getParentFile().getAbsolutePath() );\n\n            sourceWagon.get( s, f );\n        }\n\n        // ----------------------------------------------------------------------------\n        // Now all the files are present locally and now we are going to grab the\n        // metadata files from the targetRepositoryUrl and pull those down locally\n        // so that we can merge the metadata.\n        // ----------------------------------------------------------------------------\n\n        logger.info( \"Downloading metadata from the target repository.\" );\n\n        Wagon targetWagon = wagonManager.getWagon( targetRepository );\n        AuthenticationInfo targetAuth = wagonManager.getAuthenticationInfo( targetRepository.getId() );\n\n        targetWagon.connect( targetRepository, targetAuth );\n\n        PrintWriter rw = new PrintWriter( new FileWriter( renameScript ) );\n\n        File archive = new File( tempdir, fileName );\n\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            String s = (String) i.next();\n\n            if ( s.startsWith( \"/\" ) )\n            {\n                s = s.substring( 1 );\n            }\n\n            if ( s.endsWith( MAVEN_METADATA ) )\n            {\n                File emf = new File( basedir, s + IN_PROCESS_MARKER );\n\n                try\n                {\n                    targetWagon.get( s, emf );\n                }\n                catch ( ResourceDoesNotExistException e )\n                {\n                    // We don't have an equivalent on the targetRepositoryUrl side because we have something\n                    // new on the sourceRepositoryUrl side so just skip the metadata merging.\n\n                    continue;\n                }\n\n                try\n                {\n                    mergeMetadata( emf );\n                }\n                catch ( XmlPullParserException e )\n                {\n                    throw new IOException( \"Metadata file is corrupt \" + s + \" Reason: \" + e.getMessage() );\n                }\n            }\n        }\n\n        Set moveCommands = new TreeSet();\n\n        // ----------------------------------------------------------------------------\n        // Create the Zip file that we will deploy to the targetRepositoryUrl stage\n        // ----------------------------------------------------------------------------\n\n        logger.info( \"Creating zip file.\" );\n\n        OutputStream os = new FileOutputStream( archive );\n\n        ZipOutputStream zos = new ZipOutputStream( os );\n\n        scanDirectory( basedir, basedir, zos, version, moveCommands );\n\n        // ----------------------------------------------------------------------------\n        // Create the renameScript script. This is as atomic as we can\n        // ----------------------------------------------------------------------------\n\n        logger.info( \"Creating rename script.\" );\n\n        for ( Iterator i = moveCommands.iterator(); i.hasNext(); )\n        {\n            String s = (String) i.next();\n\n            // We use an explicit unix '\\n' line-ending here instead of using the println() method.\n            // Using println() will cause files and folders to have a '\\r' at the end if the plugin is run on Windows.\n            rw.print( s + \"\\n\" );\n        }\n\n        IOUtil.close( rw );\n\n        ZipEntry e = new ZipEntry( renameScript.getName() );\n\n        zos.putNextEntry( e );\n\n        InputStream is = new FileInputStream( renameScript );\n\n        IOUtil.copy( is, zos );\n\n        IOUtil.close( is );\n\n        IOUtil.close( zos );\n\n        sourceWagon.disconnect();\n\n        // Push the Zip to the target system\n\n        logger.info( \"Uploading zip file to the target repository.\" );\n\n        targetWagon.put( archive, fileName );\n\n        logger.info( \"Unpacking zip file on the target machine.\" );\n\n        String targetRepoBaseDirectory = targetRepository.getBasedir();\n\n        // We use the super quiet option here as all the noise seems to kill/stall the connection\n\n        String command = \"unzip -o -qq -d \" + targetRepoBaseDirectory + \" \" + targetRepoBaseDirectory + \"/\" + fileName;\n\n        ( (ScpWagon) targetWagon ).executeCommand( command );\n\n        logger.info( \"Deleting zip file from the target repository.\" );\n\n        command = \"rm -f \" + targetRepoBaseDirectory + \"/\" + fileName;\n\n        ( (ScpWagon) targetWagon ).executeCommand( command );\n\n        logger.info( \"Running rename script on the target machine.\" );\n\n        command = \"cd \" + targetRepoBaseDirectory + \"; sh \" + renameScriptName;\n\n        ( (ScpWagon) targetWagon ).executeCommand( command );\n\n        logger.info( \"Deleting rename script from the target repository.\" );\n\n        command = \"rm -f \" + targetRepoBaseDirectory + \"/\" + renameScriptName;\n\n        ( (ScpWagon) targetWagon ).executeCommand( command );\n\n        targetWagon.disconnect();\n    }","commit_id":"767a2b09441222b1014beae9872ba57fc849325f","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testCopy()\n        throws Exception\n    {\n        RepositoryCopier copier = (RepositoryCopier) lookup( RepositoryCopier.ROLE );\n\n        File targetRepoSource = new File( getBasedir(), \"src/test/target-repository\" );\n\n        File targetRepo = new File( getBasedir(), \"target/target-repository\" );\n\n        System.out.println( \"Copying target stage for tests ...\" );\n\n        FileUtils.copyDirectoryStructure( targetRepoSource, targetRepo );\n\n        File stagingRepo = new File( getBasedir(), \"src/test/staging-repository\" );\n\n        copier.copy( \"file://\" + stagingRepo, \"scp://localhost/\" + targetRepo, version );\n\n        String s[] = {\n            \"maven\",\n            \"maven-artifact\",\n            \"maven-artifact-manager\",\n            \"maven-artifact-test\",\n            \"maven-core\",\n            \"maven-error-diagnostics\",\n            \"maven-model\",\n            \"maven-monitor\",\n            \"maven-plugin-api\",\n            \"maven-plugin-descriptor\",\n            \"maven-plugin-parameter-documenter\",\n            \"maven-plugin-registry\",\n            \"maven-profile\",\n            \"maven-project\",\n            \"maven-repository-metadata\",\n            \"maven-script\",\n            \"maven-script-ant\",\n            \"maven-script-beanshell\",\n            \"maven-settings\" };\n\n        for ( int i = 0; i < s.length; i++ )\n        {\n            testMavenArtifact( targetRepo, s[i] );\n        }\n\n        // leave something behind to clean it up.\n\n        // Test merging\n\n        // Test MD5\n\n        // Test SHA1\n\n        // Test new artifacts are present\n    }","id":87734,"modified_method":"public void testCopy()\n        throws Exception\n    {\n        RepositoryCopier copier = (RepositoryCopier) lookup( RepositoryCopier.ROLE );\n\n        File targetRepoSource = new File( getBasedir(), \"src/test/target-repository\" );\n\n        File targetRepo = new File( getBasedir(), \"target/target-repository\" );\n\n        System.out.println( \"Copying target stage for tests ...\" );\n\n        FileUtils.copyDirectoryStructure( targetRepoSource, targetRepo );\n\n        File stagingRepo = new File( getBasedir(), \"src/test/staging-repository\" );\n\n        Repository sourceRepository = new Repository( \"source\", \"file://\" + stagingRepo );\n        Repository targetRepository = new Repository( \"target\", \"scp://localhost/\" + targetRepo );\n\n        copier.copy( sourceRepository, targetRepository, version );\n\n        String s[] = {\n            \"maven\",\n            \"maven-artifact\",\n            \"maven-artifact-manager\",\n            \"maven-artifact-test\",\n            \"maven-core\",\n            \"maven-error-diagnostics\",\n            \"maven-model\",\n            \"maven-monitor\",\n            \"maven-plugin-api\",\n            \"maven-plugin-descriptor\",\n            \"maven-plugin-parameter-documenter\",\n            \"maven-plugin-registry\",\n            \"maven-profile\",\n            \"maven-project\",\n            \"maven-repository-metadata\",\n            \"maven-script\",\n            \"maven-script-ant\",\n            \"maven-script-beanshell\",\n            \"maven-settings\" };\n\n        for ( int i = 0; i < s.length; i++ )\n        {\n            testMavenArtifact( targetRepo, s[i] );\n        }\n\n        // leave something behind to clean it up.\n\n        // Test merging\n\n        // Test MD5\n\n        // Test SHA1\n\n        // Test new artifacts are present\n    }","commit_id":"767a2b09441222b1014beae9872ba57fc849325f","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected synchronized Maybe<ManagementContext> mgmtMaybe() {\n        if (managementContext!=null) return Maybe.of(managementContext);\n        managementContext = (ManagementContext) servletContext.getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n        if (managementContext!=null) return Maybe.of(managementContext);\n        \n        return Maybe.absent(\"ManagementContext not available for Brooklyn Jersey Resource \"+this);\n    }","id":87735,"modified_method":"protected synchronized Maybe<ManagementContext> mgmtMaybe() {\n        if (managementContext!=null) return Maybe.of(managementContext);\n        managementContext = OsgiCompat.getManagementContext(servletContext);\n        if (managementContext!=null) return Maybe.of(managementContext);\n        \n        return Maybe.absent(\"ManagementContext not available for Brooklyn Jersey Resource \"+this);\n    }","commit_id":"94de46427eb84b97449456c02863fcd9ff164b7c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static ManagementContext getManagementContext(ServletContext servletContext) {\n        if (servletContext == null)\n            return null;\n\n        return (ManagementContext) servletContext.getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n    }","id":87736,"modified_method":"public static ManagementContext getManagementContext(ServletContext servletContext) {\n        return OsgiCompat.getManagementContext(servletContext);\n    }","commit_id":"94de46427eb84b97449456c02863fcd9ff164b7c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private ManagementContext getManagementContextFromJettyServerAttributes(Server server) {\n        return (ManagementContext) ((ContextHandler)server.getHandler()).getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n    }","id":87737,"modified_method":"private ManagementContext getManagementContextFromJettyServerAttributes(Server server) {\n        return OsgiCompat.getManagementContext((ContextHandler) server.getHandler());\n    }","commit_id":"94de46427eb84b97449456c02863fcd9ff164b7c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void init(FilterConfig config) throws ServletException {\n        ManagementContext mgmt = (ManagementContext) config.getServletContext().getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n        provider = new DelegatingSecurityProvider(mgmt);\n    }","id":87738,"modified_method":"@Override\n    public void init(FilterConfig config) throws ServletException {\n        ManagementContext mgmt = OsgiCompat.getManagementContext(config.getServletContext());\n        provider = new DelegatingSecurityProvider(mgmt);\n    }","commit_id":"94de46427eb84b97449456c02863fcd9ff164b7c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void installAsServletFilter(ServletContextHandler context, List<Class<? extends Filter>> filters) {\n        installBrooklynFilters(context, filters);\n\n        // now set up the REST servlet resources\n        ResourceConfig config = new DefaultResourceConfig();\n        // load all our REST API modules, JSON, and Swagger\n        for (Object r: BrooklynRestApi.getAllResources())\n            config.getSingletons().add(r);\n\n        // disable caching for dynamic content\n        config.getProperties().put(ResourceConfig.PROPERTY_CONTAINER_RESPONSE_FILTERS, NoCacheFilter.class.getName());\n        // Checks if appropriate request given HA status\n        config.getProperties().put(ResourceConfig.PROPERTY_RESOURCE_FILTER_FACTORIES, org.apache.brooklyn.rest.filter.HaHotCheckResourceFilter.class.getName());\n        // configure to match empty path, or any thing which looks like a file path with /assets/ and extension html, css, js, or png\n        // and treat that as static content\n        config.getProperties().put(ServletContainer.PROPERTY_WEB_PAGE_CONTENT_REGEX, \"(/?|[^?]*/assets/[^?]+\\\\.[A-Za-z0-9_]+)\");\n        // and anything which is not matched as a servlet also falls through (but more expensive than a regex check?)\n        config.getFeatures().put(ServletContainer.FEATURE_FILTER_FORWARD_ON_404, true);\n        // finally create this as a _filter_ which falls through to a web app or something (optionally)\n        FilterHolder filterHolder = new FilterHolder(new ServletContainer(config));\n        context.addFilter(filterHolder, \"/*\", EnumSet.allOf(DispatcherType.class));\n\n        ManagementContext mgmt = (ManagementContext) context.getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n        config.getSingletons().add(new ManagementContextProvider(mgmt));\n        config.getSingletons().add(new ShutdownHandlerProvider(shutdownListener));\n    }","id":87739,"modified_method":"private void installAsServletFilter(ServletContextHandler context, List<Class<? extends Filter>> filters) {\n        installBrooklynFilters(context, filters);\n\n        // now set up the REST servlet resources\n        ResourceConfig config = new DefaultResourceConfig();\n        // load all our REST API modules, JSON, and Swagger\n        for (Object r: BrooklynRestApi.getAllResources())\n            config.getSingletons().add(r);\n\n        // disable caching for dynamic content\n        config.getProperties().put(ResourceConfig.PROPERTY_CONTAINER_RESPONSE_FILTERS, NoCacheFilter.class.getName());\n        // Checks if appropriate request given HA status\n        config.getProperties().put(ResourceConfig.PROPERTY_RESOURCE_FILTER_FACTORIES, org.apache.brooklyn.rest.filter.HaHotCheckResourceFilter.class.getName());\n        // configure to match empty path, or any thing which looks like a file path with /assets/ and extension html, css, js, or png\n        // and treat that as static content\n        config.getProperties().put(ServletContainer.PROPERTY_WEB_PAGE_CONTENT_REGEX, \"(/?|[^?]*/assets/[^?]+\\\\.[A-Za-z0-9_]+)\");\n        // and anything which is not matched as a servlet also falls through (but more expensive than a regex check?)\n        config.getFeatures().put(ServletContainer.FEATURE_FILTER_FORWARD_ON_404, true);\n        // finally create this as a _filter_ which falls through to a web app or something (optionally)\n        FilterHolder filterHolder = new FilterHolder(new ServletContainer(config));\n        context.addFilter(filterHolder, \"/*\", EnumSet.allOf(DispatcherType.class));\n\n        ManagementContext mgmt = OsgiCompat.getManagementContext(context);\n        config.getSingletons().add(new ManagementContextProvider(mgmt));\n        config.getSingletons().add(new ShutdownHandlerProvider(shutdownListener));\n    }","commit_id":"94de46427eb84b97449456c02863fcd9ff164b7c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static ManagementContext getManagementContextFromJettyServerAttributes(Server server) {\n        return (ManagementContext) ((ContextHandler) server.getHandler()).getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n    }","id":87740,"modified_method":"public static ManagementContext getManagementContextFromJettyServerAttributes(Server server) {\n        return OsgiCompat.getManagementContext((ContextHandler) server.getHandler());\n    }","commit_id":"94de46427eb84b97449456c02863fcd9ff164b7c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void init(FilterConfig config) throws ServletException {\n        servletContext = config.getServletContext();\n        mgmt = (ManagementContext) servletContext.getAttribute(BrooklynServiceAttributes.BROOKLYN_MANAGEMENT_CONTEXT);\n    }","id":87741,"modified_method":"@Override\n    public void init(FilterConfig config) throws ServletException {\n        servletContext = config.getServletContext();\n        mgmt = OsgiCompat.getManagementContext(servletContext);\n    }","commit_id":"94de46427eb84b97449456c02863fcd9ff164b7c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public ProcessInstance getProcessInstance(long id) {\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        ProcessInstanceInfo processInstanceInfo = em.find( ProcessInstanceInfo.class,\r\n                                                           id );\r\n        if ( processInstanceInfo == null ) {\r\n            return null;\r\n        }\r\n        processInstanceInfo.updateLastReadDate();\r\n        ProcessInstance processInstance = (ProcessInstance)\r\n        \tprocessInstanceInfo.getProcessInstance(workingMemory);\r\n        Process process = ((InternalRuleBase) workingMemory.getRuleBase()).getProcess( processInstance.getProcessId() );\r\n        if ( process == null ) {\r\n            throw new IllegalArgumentException( \"Could not find process \" + processInstance.getProcessId() );\r\n        }\r\n        processInstance.setProcess( process );\r\n        if ( processInstance.getWorkingMemory() == null ) {\r\n            processInstance.setWorkingMemory( (InternalWorkingMemory) workingMemory );\r\n            ((ProcessInstanceImpl) processInstance).reconnect();\r\n        }\r\n        return processInstance;\r\n    }","id":87742,"modified_method":"public ProcessInstance getProcessInstance(long id) {\r\n    \tProcessInstance processInstance = null;\r\n    \tif (this.processInstances != null) {\r\n\t    \tprocessInstance = this.processInstances.get(id);\r\n\t    \tif (processInstance != null) {\r\n\t    \t\treturn processInstance;\r\n\t    \t}\r\n    \t}\r\n    \t\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        ProcessInstanceInfo processInstanceInfo = em.find( ProcessInstanceInfo.class,\r\n                                                           id );\r\n        if ( processInstanceInfo == null ) {\r\n            return null;\r\n        }\r\n        processInstanceInfo.updateLastReadDate();\r\n        processInstance = (ProcessInstance)\r\n        \tprocessInstanceInfo.getProcessInstance(workingMemory);\r\n        Process process = ((InternalRuleBase) workingMemory.getRuleBase()).getProcess( processInstance.getProcessId() );\r\n        if ( process == null ) {\r\n            throw new IllegalArgumentException( \"Could not find process \" + processInstance.getProcessId() );\r\n        }\r\n        processInstance.setProcess( process );\r\n        if ( processInstance.getWorkingMemory() == null ) {\r\n            processInstance.setWorkingMemory( (InternalWorkingMemory) workingMemory );\r\n            ((ProcessInstanceImpl) processInstance).reconnect();\r\n        }\r\n        return processInstance;\r\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void internalAddProcessInstance(ProcessInstance processInstance) {\r\n    }","id":87743,"modified_method":"public void internalAddProcessInstance(ProcessInstance processInstance) {\r\n    \tif (this.processInstances == null) {\r\n        \tthis.processInstances = new HashMap<Long, ProcessInstance>();\r\n        }\r\n        processInstances.put(processInstance.getId(), processInstance);\r\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void internalRemoveProcessInstance(ProcessInstance processInstance) {\r\n    }","id":87744,"modified_method":"public void internalRemoveProcessInstance(ProcessInstance processInstance) {\r\n    \tif (this.processInstances != null) {\r\n            processInstances.remove( processInstance.getId() );\r\n        }\r\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void addProcessInstance(ProcessInstance processInstance) {\r\n        ProcessInstanceInfo processInstanceInfo = new ProcessInstanceInfo( processInstance );\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        em.persist( processInstanceInfo );\r\n        ((ProcessInstance) processInstance).setId( processInstanceInfo.getId() );\r\n        processInstanceInfo.updateLastReadDate();\r\n    }","id":87745,"modified_method":"public void addProcessInstance(ProcessInstance processInstance) {\r\n        ProcessInstanceInfo processInstanceInfo = new ProcessInstanceInfo( processInstance );\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        em.persist( processInstanceInfo );\r\n        ((ProcessInstance) processInstance).setId( processInstanceInfo.getId() );\r\n        processInstanceInfo.updateLastReadDate();\r\n        internalAddProcessInstance(processInstance);\r\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void removeProcessInstance(ProcessInstance processInstance) {\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        ProcessInstanceInfo processInstanceInfo = em.find( ProcessInstanceInfo.class,\r\n                                                           processInstance.getId() );\r\n        if ( processInstanceInfo != null ) {\r\n            em.remove( processInstanceInfo );\r\n        }\r\n    }","id":87746,"modified_method":"public void removeProcessInstance(ProcessInstance processInstance) {\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        ProcessInstanceInfo processInstanceInfo = em.find( ProcessInstanceInfo.class,\r\n                                                           processInstance.getId() );\r\n        if ( processInstanceInfo != null ) {\r\n            em.remove( processInstanceInfo );\r\n        }\r\n        internalRemoveProcessInstance(processInstance);\r\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void internalExecuteWorkItem(WorkItem workItem) {\r\n\t    EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n\t    \r\n\t\tWorkItemInfo workItemInfo = new WorkItemInfo(workItem);\r\n        em.persist(workItemInfo);\r\n        ((WorkItemImpl) workItem).setId(workItemInfo.getId());\r\n        workItemInfo.update();\r\n        WorkItemHandler handler = (WorkItemHandler) this.workItemHandlers.get(workItem.getName());\r\n\t    if (handler != null) {\r\n\t        handler.executeWorkItem(workItem, this);\r\n\t    } else {\r\n\t        System.err.println(\"Could not find work item handler for \" + workItem.getName());\r\n\t    }\r\n\t}","id":87747,"modified_method":"public void internalExecuteWorkItem(WorkItem workItem) {\r\n\t    EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n\t    \r\n\t\tWorkItemInfo workItemInfo = new WorkItemInfo(workItem);\r\n        em.persist(workItemInfo);\r\n        ((WorkItemImpl) workItem).setId(workItemInfo.getId());\r\n        workItemInfo.update();\r\n        \r\n\t\tif (this.workItems == null) {\r\n        \tthis.workItems = new HashMap<Long, WorkItemInfo>();\r\n        }\r\n\t\tworkItems.put(workItem.getId(), workItemInfo);\r\n        \r\n        WorkItemHandler handler = (WorkItemHandler) this.workItemHandlers.get(workItem.getName());\r\n\t    if (handler != null) {\r\n\t        handler.executeWorkItem(workItem, this);\r\n\t    } else {\r\n\t        System.err.println(\"Could not find work item handler for \" + workItem.getName());\r\n\t    }\r\n\t}","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void completeWorkItem(long id, Map<String, Object> results) {\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        \r\n        WorkItemInfo workItemInfo = em.find(WorkItemInfo.class, id);\r\n        // work item may have been aborted\r\n        if (workItemInfo != null) {\r\n        \tWorkItemImpl workItem = (WorkItemImpl) workItemInfo.getWorkItem();\r\n            workItem.setResults(results);\r\n            ProcessInstance processInstance = workingMemory.getProcessInstance(workItem.getProcessInstanceId());\r\n            workItem.setState(WorkItem.COMPLETED);\r\n            // process instance may have finished already\r\n            if (processInstance != null) {\r\n                processInstance.signalEvent(\"workItemCompleted\", workItem);\r\n            }\r\n            em.remove(workItemInfo);\r\n            workingMemory.fireAllRules();\r\n    \t}\r\n    }","id":87748,"modified_method":"public void completeWorkItem(long id, Map<String, Object> results) {\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        \r\n        WorkItemInfo workItemInfo = null;\r\n        if (this.workItems != null) {\r\n\t    \tworkItemInfo = this.workItems.get(id);\r\n\t    \tif (workItemInfo != null) {\r\n\t    \t\tworkItemInfo = em.merge(workItemInfo);\r\n\t    \t}\r\n    \t}\r\n        \r\n        if (workItemInfo == null) {\r\n        \tworkItemInfo = em.find(WorkItemInfo.class, id);\r\n        }\r\n        \r\n    \t// work item may have been aborted\r\n        if (workItemInfo != null) {\r\n    \t\tWorkItem workItem = (WorkItemImpl) workItemInfo.getWorkItem();\r\n            workItem.setResults(results);\r\n            ProcessInstance processInstance = workingMemory.getProcessInstance(workItem.getProcessInstanceId());\r\n            workItem.setState(WorkItem.COMPLETED);\r\n            // process instance may have finished already\r\n            if (processInstance != null) {\r\n                processInstance.signalEvent(\"workItemCompleted\", workItem);\r\n            }\r\n            em.remove(workItemInfo);\r\n            if (workItems != null) {\r\n            \tthis.workItems.remove(workItem.getId());\r\n            }\r\n            workingMemory.fireAllRules();\r\n    \t}\r\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void abortWorkItem(long id) {\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        \r\n        WorkItemInfo workItemInfo = em.find(WorkItemInfo.class, id);\r\n        // work item may have been aborted\r\n        if (workItemInfo != null) {\r\n        \tWorkItemImpl workItem = (WorkItemImpl) workItemInfo.getWorkItem();\r\n            ProcessInstance processInstance = workingMemory.getProcessInstance(workItem.getProcessInstanceId());\r\n            workItem.setState(WorkItem.ABORTED);\r\n            // process instance may have finished already\r\n            if (processInstance != null) {\r\n                processInstance.signalEvent(\"workItemAborted\", workItem);\r\n            }\r\n            em.remove(workItemInfo);\r\n            workingMemory.fireAllRules();\r\n        }\r\n    }","id":87749,"modified_method":"public void abortWorkItem(long id) {\r\n        EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        \r\n        WorkItemInfo workItemInfo = null;\r\n        if (this.workItems != null) {\r\n\t    \tworkItemInfo = this.workItems.get(id);\r\n\t    \tem.merge(workItemInfo);\r\n    \t}\r\n        \r\n        if (workItemInfo == null) {\r\n        \tworkItemInfo = em.find(WorkItemInfo.class, id);\r\n        }\r\n        \r\n    \t// work item may have been aborted\r\n        if (workItemInfo != null) {\r\n    \t\tWorkItem workItem = (WorkItemImpl) workItemInfo.getWorkItem();\r\n            ProcessInstance processInstance = workingMemory.getProcessInstance(workItem.getProcessInstanceId());\r\n            workItem.setState(WorkItem.ABORTED);\r\n            // process instance may have finished already\r\n            if (processInstance != null) {\r\n                processInstance.signalEvent(\"workItemAborted\", workItem);\r\n            }\r\n            em.remove(workItemInfo);\r\n            if (workItems != null) {\r\n            \tworkItems.remove(workItem.getId());\r\n            }\r\n            workingMemory.fireAllRules();\r\n        }\r\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public WorkItem getWorkItem(long id) {\r\n\t    EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n\t    \r\n\t\tWorkItemInfo workItemInfo = em.find(WorkItemInfo.class, id);\r\n        if (workItemInfo == null) {\r\n            return null;\r\n        }\r\n        return workItemInfo.getWorkItem();\r\n\t}","id":87750,"modified_method":"public WorkItem getWorkItem(long id) {\r\n        WorkItemInfo workItemInfo = null;\r\n        if (this.workItems != null) {\r\n\t    \tworkItemInfo = this.workItems.get(id);\r\n    \t}\r\n        \r\n        if (workItemInfo == null) {\r\n            EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n        \tworkItemInfo = em.find(WorkItemInfo.class, id);\r\n        }\r\n\r\n        if (workItemInfo == null) {\r\n            return null;\r\n        }\r\n        return workItemInfo.getWorkItem();\r\n\t}","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void internalAbortWorkItem(long id) {\r\n\t    EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n\t    \r\n        WorkItemInfo workItemInfo = em.find(WorkItemInfo.class, id);\r\n        // work item may have been aborted\r\n        if (workItemInfo != null) {\r\n        \tWorkItemImpl workItem = (WorkItemImpl) workItemInfo.getWorkItem();\r\n            WorkItemHandler handler = (WorkItemHandler) this.workItemHandlers.get(workItem.getName());\r\n            if (handler != null) {\r\n                handler.abortWorkItem(workItem, this);\r\n            } else {\r\n                System.err.println(\"Could not find work item handler for \" + workItem.getName());\r\n            }\r\n            em.remove(workItemInfo);\r\n        }\r\n\t}","id":87751,"modified_method":"public void internalAbortWorkItem(long id) {\r\n\t    EntityManager em = (EntityManager) this.workingMemory.getEnvironment().get( EnvironmentName.ENTITY_MANAGER );\r\n\t    \r\n        WorkItemInfo workItemInfo = em.find(WorkItemInfo.class, id);\r\n        // work item may have been aborted\r\n        if (workItemInfo != null) {\r\n        \tWorkItemImpl workItem = (WorkItemImpl) workItemInfo.getWorkItem();\r\n            WorkItemHandler handler = (WorkItemHandler) this.workItemHandlers.get(workItem.getName());\r\n            if (handler != null) {\r\n                handler.abortWorkItem(workItem, this);\r\n            } else {\r\n                System.err.println(\"Could not find work item handler for \" + workItem.getName());\r\n            }\r\n            workItems.remove(id);\r\n            em.remove(workItemInfo);\r\n        }\r\n\t}","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public synchronized <T> T execute(Command<T> command) {\n        session.halt();\n\n        boolean localTransaction = false;\n        UserTransaction ut = null;\n        try {\n            ut = (UserTransaction) new InitialContext().lookup( \"java:comp/UserTransaction\" );\n\n            if ( ut.getStatus() == Status.STATUS_NO_TRANSACTION ) {\n                // If there is no transaction then start one, we will commit within the same Command\n                ut.begin();\n                localTransaction = true;\n            }\n\n            EntityManager localEm = this.emf.createEntityManager(); // no need to call joinTransaction as it will do so if one already exists\n            this.env.set( EnvironmentName.ENTITY_MANAGER,\n                          localEm );\n            \n            if ( this.em == null ) {\n                // there must have been a rollback to lazily re-initialise the state\n                this.em = this.emf.createEntityManager();\n                this.sessionInfo = this.em.find( SessionInfo.class, this.sessionInfo.getId() );\n                this.sessionInfo.setJPASessionMashallingHelper( this.marshallingHelper );\n                // have to create a new localEM as an EM part of a transaction cannot do a find.\n                // this.sessionInfo.rollback();\n                this.marshallingHelper.loadSnapshot( this.sessionInfo.getData(),\n                                                     this.ksession );\n                this.session = (StatefulSession) ((StatefulKnowledgeSessionImpl) this.ksession).session;                \n            }\n\n            this.em.joinTransaction();\n            //System.out.println( \"1) exec ver : \" + this.sessionInfo.getVersion() );\n            this.sessionInfo.setDirty();\n            //System.out.println( \"2) exec ver : \" + this.sessionInfo.getVersion() );\n\n            registerRollbackSync();\n\n            T result = command.execute( ( ReteooWorkingMemory ) session );\n            //System.out.println( \"3) exec ver : \" + this.sessionInfo.getVersion() );\n\n            if ( localTransaction ) {\n                // it's a locally created transaction so commit\n                ut.commit();\n            }\n\n            return result;\n\n        } catch ( Throwable t1 ) {\n            t1.printStackTrace();\n            if ( localTransaction ) {\n                try {\n                    if ( ut != null ) {\n                        ut.rollback();\n                    }\n                    throw new RuntimeException( \"Could not execute command\",\n                                                t1 );\n                } catch ( Throwable t2 ) {\n                    throw new RuntimeException( \"Could not rollback transaction\",\n                                                t2 );\n                }\n            } else {\n                throw new RuntimeException( \"Could not execute command\",\n                                            t1 );\n            }\n        } finally {\n            new Thread( new Runnable() {\n                public void run() {\n                    session.fireUntilHalt();\n                }\n            } );\n        }\n    }","id":87752,"modified_method":"public synchronized <T> T execute(Command<T> command) {\n        session.halt();\n\n        boolean localTransaction = false;\n        UserTransaction ut = null;\n        try {\n            ut = (UserTransaction) new InitialContext().lookup( \"java:comp/UserTransaction\" );\n\n            if ( ut.getStatus() == Status.STATUS_NO_TRANSACTION ) {\n                // If there is no transaction then start one, we will commit within the same Command\n                ut.begin();\n                localTransaction = true;\n            }\n\n            EntityManager localEm = (EntityManager) env.get( EnvironmentName.ENTITY_MANAGER );\n            if (localEm == null ||  !localEm.isOpen()) {\n            \tlocalEm = this.emf.createEntityManager(); // no need to call joinTransaction as it will do so if one already exists\n            \tthis.env.set( EnvironmentName.ENTITY_MANAGER, localEm );\n            }\n            \n            if ( this.em == null ) {\n                // there must have been a rollback to lazily re-initialise the state\n                this.em = this.emf.createEntityManager();\n                this.sessionInfo = this.em.find( SessionInfo.class, this.sessionInfo.getId() );\n                this.sessionInfo.setJPASessionMashallingHelper( this.marshallingHelper );\n                // have to create a new localEM as an EM part of a transaction cannot do a find.\n                // this.sessionInfo.rollback();\n                this.marshallingHelper.loadSnapshot( this.sessionInfo.getData(),\n                                                     this.ksession );\n                this.session = (StatefulSession) ((StatefulKnowledgeSessionImpl) this.ksession).session;                \n            }\n\n            this.em.joinTransaction();\n            this.sessionInfo.setDirty();\n\n            registerRollbackSync();\n\n            T result = command.execute( ( ReteooWorkingMemory ) session );\n\n            if ( localTransaction ) {\n                // it's a locally created transaction so commit\n                ut.commit();\n\n                // cleanup local entity manager\n                if ( localEm.isOpen() ) {\n                    localEm.close();\n                }\n                this.env.set( EnvironmentName.ENTITY_MANAGER, null );\n                \n                // clean up cached process and work item instances\n                ((JPAProcessInstanceManager) ((ReteooWorkingMemory) session).getProcessInstanceManager()).clearProcessInstances();\n                ((JPAWorkItemManager) ((ReteooWorkingMemory) session).getWorkItemManager()).clearWorkItems();\n            }\n            \n            return result;\n\n        } catch ( Throwable t1 ) {\n            t1.printStackTrace();\n            if ( localTransaction ) {\n                try {\n                    if ( ut != null ) {\n                        ut.rollback();\n                    }\n                    throw new RuntimeException( \"Could not execute command\",\n                                                t1 );\n                } catch ( Throwable t2 ) {\n                    throw new RuntimeException( \"Could not rollback transaction\",\n                                                t2 );\n                }\n            } else {\n                throw new RuntimeException( \"Could not execute command\",\n                                            t1 );\n            }\n        } finally {\n            new Thread( new Runnable() {\n                public void run() {\n                    session.fireUntilHalt();\n                }\n            } );\n        }\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void afterCompletion(int status) {\n            if ( status != Status.STATUS_COMMITTED ) {\n                cmdService.rollback();\n                System.out.println( \"after with local rollback: \" + status );\n            }\n\n            // always cleanup thread local whatever the result\n            //rollbackRegistered.remove();\n            System.out.println( \"cleanedup rollback sychronisation\" );\n            Map map = (Map) env.get( \"synchronizations\" );\n            map.remove( cmdService );\n\n            // cleanup local resource entity manager, normally an EntityManager should be closed with the transaction it was bound to,\n            // if it was created inside the scope of the transaction, but adding this anyway just in case.\n            EntityManager localEm = (EntityManager) this.env.get( EnvironmentName.ENTITY_MANAGER );\n            if ( localEm != null && localEm.isOpen() ) {\n                localEm.close();\n            }\n\n        }","id":87753,"modified_method":"public void afterCompletion(int status) {\n            if ( status != Status.STATUS_COMMITTED ) {\n                rollback();\n            }\n\n            // always cleanup thread local whatever the result\n            //rollbackRegistered.remove();\n            Map map = (Map) env.get( \"synchronizations\" );\n            map.remove( SingleSessionCommandService.this );\n\n            // cleanup local entity manager\n            EntityManager localEm = (EntityManager) env.get( EnvironmentName.ENTITY_MANAGER );\n            if ( localEm != null && localEm.isOpen() ) {\n                localEm.close();\n            }\n            env.set( EnvironmentName.ENTITY_MANAGER, null );\n            \n            // clean up cached process and work item instances\n            ((JPAProcessInstanceManager) ((ReteooWorkingMemory) session).getProcessInstanceManager()).clearProcessInstances();\n            ((JPAWorkItemManager) ((ReteooWorkingMemory) session).getWorkItemManager()).clearWorkItems();\n\n        }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public SingleSessionCommandService(int sessionId,\n                                       KnowledgeBase kbase,\n                                       KnowledgeSessionConfiguration conf,\n                                       Environment env) {\n        if ( conf == null ) {\n            conf = new SessionConfiguration();\n        }\n\n        this.env = env;\n\n        this.emf = (EntityManagerFactory) env.get( EnvironmentName.ENTITY_MANAGER_FACTORY );\n        this.em = emf.createEntityManager(); // how can I ensure this is an extended entity?\n        //System.out.println(((EntityManagerImpl) this.em).getFlushMode());\n        UserTransaction ut = null;\n        try {\n            InitialContext ctx = new InitialContext();\n            ut = (UserTransaction) ctx.lookup( \"java:comp/UserTransaction\" );\n            ut.begin();\n            registerRollbackSync();\n            this.em.joinTransaction();\n\n            sessionInfo = this.em.find( SessionInfo.class,\n                                        sessionId );\n\n            //\tSystem.out.println(\"committing\");\n            ut.commit();\n            //\tSystem.out.println(\"commit complete\");\n        } catch ( Throwable t1 ) {\n            try {\n                if ( ut != null ) {\n                    ut.rollback();\n                }\n                throw new RuntimeException( \"Could not find session data for id \" + sessionId,\n                                            t1 );\n            } catch ( Throwable t2 ) {\n                throw new RuntimeException( \"Could not rollback transaction\",\n                                            t2 );\n            }\n        }\n\n        this.session = ((KnowledgeBaseImpl) kbase).ruleBase.newStatefulSession( (SessionConfiguration) conf,\n                                                                                this.env );\n        \n        // update the session id to be the same as the session info id\n        ((ReteooStatefulSession) this.session).setId( sessionId );\n        \n        this.ksession = new StatefulKnowledgeSessionImpl( (ReteooWorkingMemory) session );\n        ((JPASignalManager) this.session.getSignalManager()).setCommandService( this );\n        \n        this.marshallingHelper = new JPASessionMarshallingHelper( this.sessionInfo,\n                                                                  kbase,\n                                                                  conf,\n                                                                  env );\n\n\n        this.sessionInfo.setJPASessionMashallingHelper( this.marshallingHelper );        \n\t\tthis.ksession = this.marshallingHelper.getObject();\n\t\tthis.session = (StatefulSession) ((StatefulKnowledgeSessionImpl) ksession).session;\n        ((JPASignalManager) this.session.getSignalManager()).setCommandService( this );\n\n        new Thread( new Runnable() {\n            public void run() {\n                session.fireUntilHalt();\n            }\n        } );\n    }","id":87754,"modified_method":"public SingleSessionCommandService(int sessionId,\n                                       KnowledgeBase kbase,\n                                       KnowledgeSessionConfiguration conf,\n                                       Environment env) {\n        if ( conf == null ) {\n            conf = new SessionConfiguration();\n        }\n\n        this.env = env;\n\n        this.emf = (EntityManagerFactory) env.get( EnvironmentName.ENTITY_MANAGER_FACTORY );\n        this.em = emf.createEntityManager(); // how can I ensure this is an extended entity?\n        //System.out.println(((EntityManagerImpl) this.em).getFlushMode());\n        UserTransaction ut = null;\n        try {\n            InitialContext ctx = new InitialContext();\n            ut = (UserTransaction) ctx.lookup( \"java:comp/UserTransaction\" );\n            ut.begin();\n            registerRollbackSync();\n            this.em.joinTransaction();\n            sessionInfo = this.em.find( SessionInfo.class, sessionId );\n            ut.commit();\n        } catch ( Throwable t1 ) {\n            try {\n                if ( ut != null ) {\n                    ut.rollback();\n                }\n                throw new RuntimeException( \"Could not find session data for id \" + sessionId,\n                                            t1 );\n            } catch ( Throwable t2 ) {\n                throw new RuntimeException( \"Could not rollback transaction\",\n                                            t2 );\n            }\n        }\n\n        this.marshallingHelper = new JPASessionMarshallingHelper( this.sessionInfo,\n                                                                  kbase,\n                                                                  conf,\n                                                                  env );\n\n        this.sessionInfo.setJPASessionMashallingHelper( this.marshallingHelper );        \n\t\tthis.ksession = this.marshallingHelper.getObject();\n\t\tthis.session = (StatefulSession) ((StatefulKnowledgeSessionImpl) ksession).session;\n        ((JPASignalManager) this.session.getSignalManager()).setCommandService( this );\n\n        new Thread( new Runnable() {\n            public void run() {\n                session.fireUntilHalt();\n            }\n        } );\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void registerRollbackSync() throws IllegalStateException,\n                                      RollbackException,\n                                      SystemException {\n        TransactionManager txm = (TransactionManager) env.get( EnvironmentName.TRANSACTION_MANAGER );\n        if ( txm == null ) {\n            return;\n        }\n\n        Map map = (Map) env.get( \"synchronizations\" );\n        if ( map == null ) {\n            map = new IdentityMap();\n            env.set( \"synchronizations\",\n                     map );\n        }\n\n        if ( map.get( this ) == null ) {\n            txm.getTransaction().registerSynchronization( new SynchronizationImpl( env,\n                                                                                   this ) );\n            map.put( this,\n                     this );\n        }\n\n        //        // lazy registration that ensures we registration the rollback just once\n        //        if ( !rollbackRegistered.get() ) {\n        //            TransactionManagerServices.getTransactionManager().getTransaction().registerSynchronization( new SynchronizationImpl( rollbackRegistered,\n        //                                                                                                                                  ks ) );  \n        //            rollbackRegistered.set( true );\n        //            System.out.println( \"registered rollback sychronisation\" );\n        //        }\n    }","id":87755,"modified_method":"private void registerRollbackSync() throws IllegalStateException,\n                                      RollbackException,\n                                      SystemException {\n        TransactionManager txm = (TransactionManager) env.get( EnvironmentName.TRANSACTION_MANAGER );\n        if ( txm == null ) {\n            return;\n        }\n\n        Map map = (Map) env.get( \"synchronizations\" );\n        if ( map == null ) {\n            map = new IdentityMap();\n            env.set( \"synchronizations\",\n                     map );\n        }\n\n        if ( map.get( this ) == null ) {\n            txm.getTransaction().registerSynchronization( new SynchronizationImpl() );\n            map.put( this,\n                     this );\n        }\n\n        //        // lazy registration that ensures we registration the rollback just once\n        //        if ( !rollbackRegistered.get() ) {\n        //            TransactionManagerServices.getTransactionManager().getTransaction().registerSynchronization( new SynchronizationImpl( rollbackRegistered,\n        //                                                                                                                                  ks ) );  \n        //            rollbackRegistered.set( true );\n        //            System.out.println( \"registered rollback sychronisation\" );\n        //        }\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void rollback() {\n        // with em null, if someone tries to use this session it'll first restore it's state\n        this.em.close();\n        this.em = null;\n    }","id":87756,"modified_method":"private void rollback() {\n        // with em null, if someone tries to use this session it'll first restore it's state\n        this.em.close();\n        this.em = null;\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testPersistenceTimer() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( \"drools.TransactionManager\",\n                 TransactionManagerServices.getTransactionManager() );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessTimer();\n        kbase.addKnowledgePackages( kpkgs );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        Thread.sleep( 3000 );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n    }","id":87757,"modified_method":"public void testPersistenceTimer() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( EnvironmentName.TRANSACTION_MANAGER,\n                 TransactionManagerServices.getTransactionManager() );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessTimer();\n        kbase.addKnowledgePackages( kpkgs );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        Thread.sleep( 3000 );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testPersistenceWorkItemsUserTransaction() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( \"drools.TransactionManager\",\n                 TransactionManagerServices.getTransactionManager() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessWorkItems();\n        kbase.addKnowledgePackages( kpkgs );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n\n        UserTransaction ut = (UserTransaction) new InitialContext().lookup( \"java:comp/UserTransaction\" );\n        ut.begin();\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n        ut.commit();\n\n        TestWorkItemHandler handler = TestWorkItemHandler.getInstance();\n        WorkItem workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        ut.commit();\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        CompleteWorkItemCommand completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        ut.commit();\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        ut.commit();\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        ut.commit();\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        ut.commit();\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        ut.commit();\n\n        workItem = handler.getWorkItem();\n        assertNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        ut.commit();\n        assertNull( processInstance );\n        service.dispose();\n    }","id":87758,"modified_method":"public void testPersistenceWorkItemsUserTransaction() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( EnvironmentName.TRANSACTION_MANAGER,\n                 TransactionManagerServices.getTransactionManager() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessWorkItems();\n        kbase.addKnowledgePackages( kpkgs );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n\n        UserTransaction ut = (UserTransaction) new InitialContext().lookup( \"java:comp/UserTransaction\" );\n        ut.begin();\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n        ut.commit();\n\n        TestWorkItemHandler handler = TestWorkItemHandler.getInstance();\n        WorkItem workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        ut.commit();\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        CompleteWorkItemCommand completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        ut.commit();\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        ut.commit();\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        ut.commit();\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        ut.commit();\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        ut.commit();\n\n        workItem = handler.getWorkItem();\n        assertNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        ut.begin();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        ut.commit();\n        assertNull( processInstance );\n        service.dispose();\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testPersistenceSubProcess() {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( \"drools.TransactionManager\",\n                 TransactionManagerServices.getTransactionManager() );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        RuleBase ruleBase = RuleBaseFactory.newRuleBase();\n        Package pkg = getProcessSubProcess();\n        ruleBase.addPackage( pkg );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( ruleBase,\n                                                                               config,\n                                                                               env );\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        RuleFlowProcessInstance processInstance = (RuleFlowProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n        long processInstanceId = processInstance.getId();\n\n        TestWorkItemHandler handler = TestWorkItemHandler.getInstance();\n        WorkItem workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( ruleBase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstanceId );\n        processInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n\n        Collection<NodeInstance> nodeInstances = processInstance.getNodeInstances();\n        assertEquals( 1,\n                      nodeInstances.size() );\n        SubProcessNodeInstance subProcessNodeInstance = (SubProcessNodeInstance) nodeInstances.iterator().next();\n        long subProcessInstanceId = subProcessNodeInstance.getProcessInstanceId();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( subProcessInstanceId );\n        RuleFlowProcessInstance subProcessInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( subProcessInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( ruleBase,\n                                                   config,\n                                                   env );\n        CompleteWorkItemCommand completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        service.dispose();\n\n        service = new SingleSessionCommandService( ruleBase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( subProcessInstanceId );\n        subProcessInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( subProcessInstance );\n\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstanceId );\n        processInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n        service.dispose();\n    }","id":87759,"modified_method":"public void testPersistenceSubProcess() {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( EnvironmentName.TRANSACTION_MANAGER,\n                 TransactionManagerServices.getTransactionManager() );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        RuleBase ruleBase = RuleBaseFactory.newRuleBase();\n        Package pkg = getProcessSubProcess();\n        ruleBase.addPackage( pkg );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( ruleBase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        RuleFlowProcessInstance processInstance = (RuleFlowProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n        long processInstanceId = processInstance.getId();\n\n        TestWorkItemHandler handler = TestWorkItemHandler.getInstance();\n        WorkItem workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n        \t\t                                   ruleBase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstanceId );\n        processInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n\n        Collection<NodeInstance> nodeInstances = processInstance.getNodeInstances();\n        assertEquals( 1,\n                      nodeInstances.size() );\n        SubProcessNodeInstance subProcessNodeInstance = (SubProcessNodeInstance) nodeInstances.iterator().next();\n        long subProcessInstanceId = subProcessNodeInstance.getProcessInstanceId();\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( subProcessInstanceId );\n        RuleFlowProcessInstance subProcessInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( subProcessInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   ruleBase,\n                                                   config,\n                                                   env );\n        CompleteWorkItemCommand completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   ruleBase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( subProcessInstanceId );\n        subProcessInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( subProcessInstance );\n\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstanceId );\n        processInstance = (RuleFlowProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n        service.dispose();\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testPersistenceWorkItems() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( \"drools.TransactionManager\",\n                 TransactionManagerServices.getTransactionManager() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessWorkItems();\n        kbase.addKnowledgePackages( kpkgs );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n\n        TestWorkItemHandler handler = TestWorkItemHandler.getInstance();\n        WorkItem workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        CompleteWorkItemCommand completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n\n        workItem = handler.getWorkItem();\n        assertNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n        service.dispose();\n    }","id":87760,"modified_method":"public void testPersistenceWorkItems() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( EnvironmentName.TRANSACTION_MANAGER,\n                 TransactionManagerServices.getTransactionManager() );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessWorkItems();\n        kbase.addKnowledgePackages( kpkgs );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n\n        TestWorkItemHandler handler = TestWorkItemHandler.getInstance();\n        WorkItem workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        CompleteWorkItemCommand completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n\n        workItem = handler.getWorkItem();\n        assertNotNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNotNull( processInstance );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        completeWorkItemCommand = new CompleteWorkItemCommand();\n        completeWorkItemCommand.setWorkItemId( workItem.getId() );\n        service.execute( completeWorkItemCommand );\n\n        workItem = handler.getWorkItem();\n        assertNull( workItem );\n        service.dispose();\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n        service.dispose();\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testPersistenceTimer2() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( \"drools.TransactionManager\",\n                 TransactionManagerServices.getTransactionManager() );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessTimer2();\n        kbase.addKnowledgePackages( kpkgs );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n\n        Thread.sleep( 2000 );\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n    }","id":87761,"modified_method":"public void testPersistenceTimer2() throws Exception {\n        Environment env = KnowledgeBaseFactory.newEnvironment();\n        env.set( EnvironmentName.ENTITY_MANAGER_FACTORY,\n                 emf );\n        env.set( EnvironmentName.TRANSACTION_MANAGER,\n                 TransactionManagerServices.getTransactionManager() );\n\n        Properties properties = new Properties();\n        properties.setProperty( \"drools.commandService\",\n                                \"org.drools.persistence.session.SingleSessionCommandService\" );\n        properties.setProperty( \"drools.processInstanceManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAProcessInstanceManagerFactory\" );\n        properties.setProperty( \"drools.workItemManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPAWorkItemManagerFactory\" );\n        properties.setProperty( \"drools.processSignalManagerFactory\",\n                                \"org.drools.persistence.processinstance.JPASignalManagerFactory\" );\n        SessionConfiguration config = new SessionConfiguration( properties );\n\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\n        Collection<KnowledgePackage> kpkgs = getProcessTimer2();\n        kbase.addKnowledgePackages( kpkgs );\n\n        SingleSessionCommandService service = new SingleSessionCommandService( kbase,\n                                                                               config,\n                                                                               env );\n        int sessionId = service.getSessionId();\n        StartProcessCommand startProcessCommand = new StartProcessCommand();\n        startProcessCommand.setProcessId( \"org.drools.test.TestProcess\" );\n        ProcessInstance processInstance = (ProcessInstance) service.execute( startProcessCommand );\n        System.out.println( \"Started process instance \" + processInstance.getId() );\n\n        Thread.sleep( 2000 );\n\n        service = new SingleSessionCommandService( sessionId,\n                                                   kbase,\n                                                   config,\n                                                   env );\n        GetProcessInstanceCommand getProcessInstanceCommand = new GetProcessInstanceCommand();\n        getProcessInstanceCommand.setProcessInstanceId( processInstance.getId() );\n        processInstance = (ProcessInstance) service.execute( getProcessInstanceCommand );\n        assertNull( processInstance );\n    }","commit_id":"cd912408e72e1474e001b1fbbee0e6e5f49cc9ee","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void afterPropertiesSet() {\r\n\t\tConfiguration config = new Configuration();\r\n\t\tconfig.getProperties().put(Environment.CURRENT_SESSION_CONTEXT_CLASS, SpringSessionContext.class.getName());\r\n\t\tconfig.getProperties().put(Environment.DATASOURCE, this.dataSource);\r\n\t\tconfig.getProperties().put(\"hibernate.classLoader.application\", this.resourcePatternResolver.getClassLoader());\r\n\t\tconfig.addProperties(this.hibernateProperties);\r\n\t\tscanPackages(config);\r\n\t\tfor (Class<?> annotatedClass : this.annotatedClasses) {\r\n\t\t\tReflectionUtils.invokeMethod(addAnnotatedClassMethod, config, annotatedClass);\r\n\t\t}\r\n\t\tthis.sessionFactory = config.buildSessionFactory();\r\n\t}","id":87762,"modified_method":"public void afterPropertiesSet() {\r\n\t\tConfiguration config = new Configuration();\r\n\t\tconfig.getProperties().put(Environment.CURRENT_SESSION_CONTEXT_CLASS, SpringSessionContext.class.getName());\r\n\t\tconfig.getProperties().put(Environment.DATASOURCE, this.dataSource);\r\n\t\tconfig.getProperties().put(\"hibernate.classLoader.application\", this.resourcePatternResolver.getClassLoader());\r\n\t\tif (this.hibernateProperties != null) {\r\n\t\t\tconfig.addProperties(this.hibernateProperties);\r\n\t\t}\r\n\t\tscanPackages(config);\r\n\t\tfor (Class<?> annotatedClass : this.annotatedClasses) {\r\n\t\t\tReflectionUtils.invokeMethod(addAnnotatedClassMethod, config, annotatedClass);\r\n\t\t}\r\n\t\tthis.sessionFactory = config.buildSessionFactory();\r\n\t}","commit_id":"4c49cc73b28e89599ae95c0dbd5b099b164bba01","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected void importFromLDAPByGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tcookie = PortalLDAPUtil.getGroups(\n\t\t\t\tldapServerId, companyId, ldapContext, cookie, 0, searchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\ttry {\n\t\t\t\t\tAttributes attributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\t\tldapServerId, companyId, searchResult),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\t\t\tcompanyId, attributes, groupMappings);\n\n\t\t\t\t\tAttribute usersAttribute = getUsers(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, attributes,\n\t\t\t\t\t\tuserGroup, groupMappings);\n\n\t\t\t\t\tif (usersAttribute == null) {\n\t\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\t\t\"No users found in \" + userGroup.getName());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\timportUsers(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, userMappings,\n\t\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\t\tcontactExpandoMappings, userGroup.getUserGroupId(),\n\t\t\t\t\t\tusersAttribute);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(\"Unable to import group \" + searchResult, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":87763,"modified_method":"protected void importFromLDAPByGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.getGroups(\n\t\t\tldapServerId, companyId, ldapContext, 0);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\ttry {\n\t\t\t\tAttributes attributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult),\n\t\t\t\t\ttrue);\n\n\t\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\t\tcompanyId, attributes, groupMappings);\n\n\t\t\t\tAttribute usersAttribute = getUsers(\n\t\t\t\t\tldapServerId, companyId, ldapContext, attributes, userGroup,\n\t\t\t\t\tgroupMappings);\n\n\t\t\t\tif (usersAttribute == null) {\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"No users found in \" + userGroup.getName());\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\timportUsers(\n\t\t\t\t\tldapServerId, companyId, ldapContext, userMappings,\n\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\tcontactExpandoMappings, userGroup.getUserGroupId(),\n\t\t\t\t\tusersAttribute);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to import group \" + searchResult, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAttribute attribute = attributes.get(userMappingsGroup);\n\n\t\tif (attribute == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tattribute.clear();\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\tldapServerId, companyId, user.getScreenName());\n\n\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\tldapServerId, companyId, binding);\n\n\t\tStringBundler sb = new StringBundler(9);\n\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(StringPool.AMPERSAND);\n\t\tsb.append(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(fullUserDN);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tPortalLDAPUtil.searchLDAP(\n\t\t\t\tcompanyId, ldapContext, cookie, 0, baseDN, sb.toString(), null,\n\t\t\t\tsearchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\t\tattribute.add(fullGroupDN);\n\t\t\t}\n\t\t}\n\n\t\tList<Long> newUserGroupIds = new ArrayList<Long>(attribute.size());\n\n\t\tfor (int i = 0; i < attribute.size(); i++) {\n\t\t\tString fullGroupDN = (String)attribute.get(i);\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with fullGroupDN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Adding \" + user.getUserId() + \" to group \" +\n\t\t\t\t\t\t\tuserGroup.getUserGroupId());\n\t\t\t\t}\n\n\t\t\t\tnewUserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t}\n\t\t}\n\n\t\tUserGroupLocalServiceUtil.setUserUserGroups(\n\t\t\tuser.getUserId(),\n\t\t\tArrayUtil.toArray(\n\t\t\t\tnewUserGroupIds.toArray(new Long[newUserGroupIds.size()])));\n\t}","id":87764,"modified_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAttribute attribute = attributes.get(userMappingsGroup);\n\n\t\tif (attribute == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tattribute.clear();\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\tldapServerId, companyId, user.getScreenName());\n\n\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\tldapServerId, companyId, binding);\n\n\t\tStringBundler sb = new StringBundler(9);\n\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(StringPool.AMPERSAND);\n\t\tsb.append(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(fullUserDN);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.searchLDAP(\n\t\t\tcompanyId, ldapContext, 0, baseDN, sb.toString(), null);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\tattribute.add(fullGroupDN);\n\t\t}\n\n\t\tList<Long> newUserGroupIds = new ArrayList<Long>(attribute.size());\n\n\t\tfor (int i = 0; i < attribute.size(); i++) {\n\t\t\tString fullGroupDN = (String) attribute.get(i);\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with fullGroupDN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Adding \" + user.getUserId() + \" to group \" +\n\t\t\t\t\t\t\tuserGroup.getUserGroupId());\n\t\t\t\t}\n\n\t\t\t\tnewUserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t}\n\t\t}\n\n\t\tUserGroupLocalServiceUtil.setUserUserGroups(\n\t\t\tuser.getUserId(),\n\t\t\tArrayUtil.toArray(\n\t\t\t\tnewUserGroupIds.toArray(new Long[newUserGroupIds.size()])));\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importFromLDAPByUser(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tcookie = PortalLDAPUtil.getUsers(\n\t\t\t\tldapServerId, companyId, ldapContext, cookie, 0, searchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\ttry {\n\t\t\t\t\tAttributes userAttributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\t\tldapServerId, companyId, searchResult));\n\n\t\t\t\t\tUser user = importUser(\n\t\t\t\t\t\tcompanyId, userAttributes, userMappings,\n\t\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\t\tcontactExpandoMappings, StringPool.BLANK);\n\n\t\t\t\t\timportGroups(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, userAttributes, user,\n\t\t\t\t\t\tuserMappings, groupMappings);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(\"Unable to import user \" + searchResult, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":87765,"modified_method":"protected void importFromLDAPByUser(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.getUsers(\n\t\t\tldapServerId, companyId, ldapContext, 0);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\ttry {\n\t\t\t\tAttributes userAttributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult));\n\n\t\t\t\tUser user = importUser(\n\t\t\t\t\tcompanyId, userAttributes, userMappings,\n\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\tcontactExpandoMappings, StringPool.BLANK);\n\n\t\t\t\timportGroups(\n\t\t\t\t\tldapServerId, companyId, ldapContext, userAttributes, user,\n\t\t\t\t\tuserMappings, groupMappings);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to import user \" + searchResult, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] getGroups(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String groupFilter,\n\t\t\tList<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, groupFilter,\n\t\t\tnull, searchResults);\n\t}","id":87766,"modified_method":"public static List<SearchResult> getGroups(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String groupFilter)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, groupFilter, null);\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] getUsers(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tbyte[] cookie, int maxResults, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString userFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix);\n\n\t\treturn getUsers(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, userFilter,\n\t\t\tsearchResults);\n\t}","id":87767,"modified_method":"public static List<SearchResult> getUsers(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tint maxResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString userFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix);\n\n\t\treturn getUsers(companyId, ldapContext, maxResults, baseDN, userFilter);\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] searchLDAP(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String filter,\n\t\t\tString[] attributeIds, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tSearchControls searchControls = new SearchControls(\n\t\t\tSearchControls.SUBTREE_SCOPE, maxResults, 0, attributeIds, false,\n\t\t\tfalse);\n\n\t\ttry {\n\t\t\tif (cookie != null) {\n\t\t\t\tif (cookie.length == 0) {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, Control.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, cookie,\n\t\t\t\t\t\t\t\tControl.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t\t}\n\n\t\t\t\tenu.close();\n\n\t\t\t\treturn _getCookie(ldapContext.getResponseControls());\n\t\t\t}\n\t\t}\n\t\tcatch (OperationNotSupportedException onse) {\n\t\t\tldapContext.setRequestControls(null);\n\n\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t}\n\n\t\t\tenu.close();\n\t\t}\n\t\tfinally {\n\t\t\tldapContext.setRequestControls(null);\n\t\t}\n\n\t\treturn null;\n\t}","id":87768,"modified_method":"public static List<SearchResult> searchLDAP(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String filter, String[] attributeIds)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\tSearchControls searchControls = new SearchControls(\n\t\t\tSearchControls.SUBTREE_SCOPE, maxResults, 0, attributeIds, false,\n\t\t\tfalse);\n\n\t\ttry {\n\t\t\tbyte[] cookie = new byte[0];\n\n\t\t\twhile (cookie != null) {\n\t\t\t\tif (cookie.length == 0) {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, Control.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, cookie,\n\t\t\t\t\t\t\t\tControl.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t\t}\n\n\t\t\t\tenu.close();\n\n\t\t\t\tcookie = _getCookie(ldapContext.getResponseControls());\n\t\t\t}\n\t\t}\n\t\tcatch (OperationNotSupportedException onse) {\n\t\t\tldapContext.setRequestControls(null);\n\n\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t}\n\n\t\t\tenu.close();\n\t\t}\n\t\tfinally {\n\t\t\tldapContext.setRequestControls(null);\n\t\t}\n\n\t\treturn searchResults;\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] getUsers(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String userFilter,\n\t\t\tList<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, userFilter,\n\t\t\tnull, searchResults);\n\t}","id":87769,"modified_method":"public static List<SearchResult> getUsers(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String userFilter)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, userFilter, null);\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] getGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tbyte[] cookie, int maxResults, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString groupFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix);\n\n\t\treturn getGroups(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, groupFilter,\n\t\t\tsearchResults);\n\t}","id":87770,"modified_method":"public static List<SearchResult> getGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tint maxResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString groupFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix);\n\n\t\treturn getGroups(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, groupFilter);\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Attribute getMultivaluedAttribute(\n\t\t\tlong companyId, LdapContext ldapContext, String baseDN,\n\t\t\tString filter, Attribute attribute)\n\t\tthrows Exception {\n\n\t\tif (attribute.size() > 0) {\n\t\t\treturn attribute;\n\t\t}\n\n\t\tString[] attributeIds = {_getNextRange(attribute.getID())};\n\n\t\twhile (true) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tsearchLDAP(\n\t\t\t\tcompanyId, ldapContext, new byte[0], 0, baseDN, filter,\n\t\t\t\tattributeIds, searchResults);\n\n\t\t\tif (searchResults.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSearchResult searchResult = searchResults.get(0);\n\n\t\t\tAttributes attributes = searchResult.getAttributes();\n\n\t\t\tif (attributes.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNamingEnumeration<? extends Attribute> enu = attributes.getAll();\n\n\t\t\tif (!enu.hasMoreElements()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tAttribute curAttribute = enu.nextElement();\n\n\t\t\tfor (int i = 0; i < curAttribute.size(); i++) {\n\t\t\t\tattribute.add(curAttribute.get(i));\n\t\t\t}\n\n\t\t\tif (StringUtil.endsWith(curAttribute.getID(), StringPool.STAR) ||\n\t\t\t\t(curAttribute.size() < PropsValues.LDAP_RANGE_SIZE)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tattributeIds[0] = _getNextRange(attributeIds[0]);\n\t\t}\n\n\t\treturn attribute;\n\t}","id":87771,"modified_method":"public static Attribute getMultivaluedAttribute(\n\t\t\tlong companyId, LdapContext ldapContext, String baseDN,\n\t\t\tString filter, Attribute attribute)\n\t\tthrows Exception {\n\n\t\tif (attribute.size() > 0) {\n\t\t\treturn attribute;\n\t\t}\n\n\t\tString[] attributeIds = {_getNextRange(attribute.getID())};\n\n\t\twhile (true) {\n\t\t\tList<SearchResult> searchResults = searchLDAP(\n\t\t\t\tcompanyId, ldapContext, 0, baseDN, filter, attributeIds);\n\n\t\t\tif (searchResults.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSearchResult searchResult = searchResults.get(0);\n\n\t\t\tAttributes attributes = searchResult.getAttributes();\n\n\t\t\tif (attributes.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNamingEnumeration<? extends Attribute> enu = attributes.getAll();\n\n\t\t\tif (!enu.hasMoreElements()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tAttribute curAttribute = enu.nextElement();\n\n\t\t\tfor (int i = 0; i < curAttribute.size(); i++) {\n\t\t\t\tattribute.add(curAttribute.get(i));\n\t\t\t}\n\n\t\t\tif (StringUtil.endsWith(curAttribute.getID(), StringPool.STAR) ||\n\t\t\t\t(curAttribute.size() < PropsValues.LDAP_RANGE_SIZE)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tattributeIds[0] = _getNextRange(attributeIds[0]);\n\t\t}\n\n\t\treturn attribute;\n\t}","commit_id":"17669bb6fd19219f61de3a784c54ea7cff98fa8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\r\n     * Checks if crawl queue has elements and new crawl will not exceed thread-limit\r\n     * @param stackType\r\n     * @return\r\n     */\r\n    private String loadIsPossible(final StackType stackType) {\r\n        //System.out.println(\"stacksize = \" + noticeURL.stackSize(stackType));\r\n        if (this.noticeURL.stackSize(stackType) == 0) {\r\n            //log.logDebug(\"GlobalCrawl: queue is empty\");\r\n            return \"stack is empty\";\r\n        }\r\n\r\n        // check again\r\n        if (this.workerQueue.remainingCapacity() == 0) {\r\n            return \"too many workers active: \" + this.workerQueue.size();\r\n        }\r\n\r\n        final String cautionCause = this.sb.onlineCaution();\r\n        if (cautionCause != null) {\r\n            return \"online caution: \" + cautionCause;\r\n        }\r\n        return null;\r\n    }","id":87772,"modified_method":"/**\r\n     * Checks if crawl queue has elements and new crawl will not exceed thread-limit\r\n     * @param stackType\r\n     * @return\r\n     */\r\n    private String loadIsPossible(final StackType stackType) {\r\n        //System.out.println(\"stacksize = \" + noticeURL.stackSize(stackType));\r\n        if (this.noticeURL.isEmpty(stackType)) {\r\n            //log.logDebug(\"GlobalCrawl: queue is empty\");\r\n            return \"stack is empty\";\r\n        }\r\n\r\n        // check again\r\n        if (this.workerQueue.remainingCapacity() == 0) {\r\n            return \"too many workers active: \" + this.workerQueue.size();\r\n        }\r\n\r\n        final String cautionCause = this.sb.onlineCaution();\r\n        if (cautionCause != null) {\r\n            return \"online caution: \" + cautionCause;\r\n        }\r\n        return null;\r\n    }","commit_id":"9c6228d948b7f8c1cead821030cabe67390f8ec0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * push a request to one of the host queues. If the queue does not exist, it is created\n     * @param entry\n     * @param profile\n     * @param robots\n     * @return null if everything is ok or a string with an error message if the push is not allowed according to the crawl profile or robots\n     * @throws IOException\n     * @throws SpaceExceededException\n     */\n    @Override\n    public synchronized String push(final Request entry, CrawlProfile profile, final RobotsTxt robots) throws IOException, SpaceExceededException {\n        if (this.has(entry.url().hash())) return \"double occurrence\";\n        depthCache.put(entry.url().hash(), entry.depth());\n        String hosthash = ASCII.String(entry.url().hash(), 6, 6);\n        HostQueue queue = this.queues.get(hosthash);\n        if (queue == null) {\n            queue = new HostQueue(this.hostsPath, entry.url().getHost(), entry.url().getPort(), this.queues.size() > 100, this.exceed134217727);\n            this.queues.put(hosthash, queue);\n            robots.ensureExist(entry.url(), profile.getAgent(), true); // concurrently load all robots.txt\n        }\n        return queue.push(entry, profile, robots);\n    }","id":87773,"modified_method":"/**\n     * push a request to one of the host queues. If the queue does not exist, it is created\n     * @param entry\n     * @param profile\n     * @param robots\n     * @return null if everything is ok or a string with an error message if the push is not allowed according to the crawl profile or robots\n     * @throws IOException\n     * @throws SpaceExceededException\n     */\n    @Override\n    public String push(final Request entry, CrawlProfile profile, final RobotsTxt robots) throws IOException, SpaceExceededException {\n        if (this.has(entry.url().hash())) return \"double occurrence\";\n        depthCache.put(entry.url().hash(), entry.depth());\n        String hosthash = ASCII.String(entry.url().hash(), 6, 6);\n        synchronized (this) {\n            HostQueue queue = this.queues.get(hosthash);\n            if (queue == null) {\n                queue = new HostQueue(this.hostsPath, entry.url().getHost(), entry.url().getPort(), this.queues.size() > 100, this.exceed134217727);\n                this.queues.put(hosthash, queue);\n                robots.ensureExist(entry.url(), profile.getAgent(), true); // concurrently load all robots.txt\n            }\n            return queue.push(entry, profile, robots);\n        }\n    }","commit_id":"9c6228d948b7f8c1cead821030cabe67390f8ec0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * get the next entry in this crawl queue in such a way that the domain access time delta is maximized\n     * and always above the given minimum delay time. An additional delay time is computed using the robots.txt\n     * crawl-delay time which is always respected. In case the minimum time cannot ensured, this method pauses\n     * the necessary time until the url is released and returned as CrawlEntry object. In case that a profile\n     * for the computed Entry does not exist, null is returned\n     * @param delay true if the requester demands forced delays using explicit thread sleep\n     * @param profile\n     * @return a url in a CrawlEntry object\n     * @throws IOException\n     * @throws SpaceExceededException\n     */\n    @Override\n    public synchronized Request pop(boolean delay, CrawlSwitchboard cs, RobotsTxt robots) throws IOException {\n        tryagain: while (true) try {\n            if (this.roundRobinHostHashes.size() == 0) {\n                // refresh the round-robin cache\n                this.roundRobinHostHashes.addAll(this.queues.keySet());\n                // quickly get rid of small stacks to reduce number of files:\n                if (this.roundRobinHostHashes.size() > 100) {\n                    // if there are stacks with less than 10 entries, remove all stacks with more than 10 entries\n                    // this shall kick out small stacks to prevent that too many files are opened for very wide crawls\n                    boolean smallStacksExist = false;\n                    boolean singletonStacksExist = false;\n                    smallsearch: for (String s: this.roundRobinHostHashes) {\n                        HostQueue hq = this.queues.get(s);\n                        if (hq != null) {\n                            int size = hq.size();\n                            if (size ==  1) {singletonStacksExist = true; break smallsearch;}\n                            if (size <= 10) {smallStacksExist = true; break smallsearch;}\n                        }\n                    }\n                    if (singletonStacksExist) {\n                        Iterator<String> i = this.roundRobinHostHashes.iterator();\n                        while (i.hasNext()) {\n                            String s = i.next();\n                            HostQueue hq = this.queues.get(s);\n                            if (hq == null || hq.size() != 1) {i.remove();}\n                        }\n                    } else if (smallStacksExist) {\n                        Iterator<String> i = this.roundRobinHostHashes.iterator();\n                        while (i.hasNext()) {\n                            String s = i.next();\n                            HostQueue hq = this.queues.get(s);\n                            if (hq == null || hq.size() > 10) {i.remove();}\n                        }\n                    }\n                }\n            }\n            if (this.roundRobinHostHashes.size() == 0) return null;\n    \n            // first strategy: get one entry which does not need sleep time\n            for (String nextHH: this.roundRobinHostHashes) {\n                HostQueue hq = this.queues.get(nextHH);\n                int delta = Latency.waitingRemainingGuessed(hq.getHost(), DigestURL.hosthash(hq.getHost(), hq.getPort()), robots, ClientIdentification.yacyInternetCrawlerAgent);\n                if (delta <= 10 || this.roundRobinHostHashes.size() == 1) {\n                    this.roundRobinHostHashes.remove(nextHH);\n                    Request request = hq == null ? null : hq.pop(delay, cs, robots);\n                    int size = hq == null ? 0 : hq.size();\n                    if (size == 0) {\n                        hq.close();\n                        this.queues.remove(nextHH);\n                    }\n                    if (request != null) return request;\n                }\n            }\n            \n            // second strategy: take from the largest stack and clean round robin cache\n            int largest = Integer.MIN_VALUE;\n            String nextHH = null;\n            for (String h: this.roundRobinHostHashes) {\n                HostQueue hq = this.queues.get(h);\n                if (hq != null) {\n                    int s = hq.size();\n                    if (s > largest) {\n                        largest = s;\n                        nextHH = h;\n                    }\n                }\n            }\n            this.roundRobinHostHashes.clear(); // start from the beginning next time\n            HostQueue hq = this.queues.get(nextHH);\n            Request request = hq == null ? null : hq.pop(delay, cs, robots);\n            if (hq != null && hq.size() == 0) {\n                hq.close();\n                this.queues.remove(nextHH);\n            }\n            return request;\n        } catch (ConcurrentModificationException e) {\n            continue tryagain;\n        } catch (Throwable e) {\n            throw new IOException(e.getMessage());\n        }\n    }","id":87774,"modified_method":"/**\n     * get the next entry in this crawl queue in such a way that the domain access time delta is maximized\n     * and always above the given minimum delay time. An additional delay time is computed using the robots.txt\n     * crawl-delay time which is always respected. In case the minimum time cannot ensured, this method pauses\n     * the necessary time until the url is released and returned as CrawlEntry object. In case that a profile\n     * for the computed Entry does not exist, null is returned\n     * @param delay true if the requester demands forced delays using explicit thread sleep\n     * @param profile\n     * @return a url in a CrawlEntry object\n     * @throws IOException\n     * @throws SpaceExceededException\n     */\n    @Override\n    public Request pop(boolean delay, CrawlSwitchboard cs, RobotsTxt robots) throws IOException {\n        tryagain: while (true) try {\n            HostQueue rhq = null;\n            String rhh = null;\n        \n            synchronized (this) {\n                if (this.roundRobinHostHashes.size() == 0) {\n                    // refresh the round-robin cache\n                    this.roundRobinHostHashes.addAll(this.queues.keySet());\n                    // quickly get rid of small stacks to reduce number of files:\n                    if (this.roundRobinHostHashes.size() > 100) {\n                        // if there are stacks with less than 10 entries, remove all stacks with more than 10 entries\n                        // this shall kick out small stacks to prevent that too many files are opened for very wide crawls\n                        boolean smallStacksExist = false;\n                        boolean singletonStacksExist = false;\n                        smallsearch: for (String s: this.roundRobinHostHashes) {\n                            HostQueue hq = this.queues.get(s);\n                            if (hq != null) {\n                                int size = hq.size();\n                                if (size ==  1) {singletonStacksExist = true; break smallsearch;}\n                                if (size <= 10) {smallStacksExist = true; break smallsearch;}\n                            }\n                        }\n                        if (singletonStacksExist) {\n                            Iterator<String> i = this.roundRobinHostHashes.iterator();\n                            while (i.hasNext()) {\n                                String s = i.next();\n                                HostQueue hq = this.queues.get(s);\n                                if (hq == null || hq.size() != 1) {i.remove();}\n                            }\n                        } else if (smallStacksExist) {\n                            Iterator<String> i = this.roundRobinHostHashes.iterator();\n                            while (i.hasNext()) {\n                                String s = i.next();\n                                HostQueue hq = this.queues.get(s);\n                                if (hq == null || hq.size() > 10) {i.remove();}\n                            }\n                        }\n                    }\n                }\n                if (this.roundRobinHostHashes.size() == 0) return null;\n                \n                // first strategy: get one entry which does not need sleep time\n                Iterator<String> nhhi = this.roundRobinHostHashes.iterator();\n                nosleep: while (nhhi.hasNext()) {\n                    rhh = nhhi.next();\n                    rhq = this.queues.get(rhh);\n                    if (rhq == null) {\n                        nhhi.remove();\n                        continue nosleep;\n                    }\n                    int delta = Latency.waitingRemainingGuessed(rhq.getHost(), DigestURL.hosthash(rhq.getHost(), rhq.getPort()), robots, ClientIdentification.yacyInternetCrawlerAgent);\n                    if (delta <= 10 || this.roundRobinHostHashes.size() == 1) {\n                        nhhi.remove();\n                        break nosleep;\n                    }\n                }\n                \n                if (rhq == null) {\n                    // second strategy: take from the largest stack and clean round robin cache\n                    int largest = Integer.MIN_VALUE;\n                    for (String h: this.roundRobinHostHashes) {\n                        HostQueue hq = this.queues.get(h);\n                        if (hq != null) {\n                            int s = hq.size();\n                            if (s > largest) {\n                                largest = s;\n                                rhh = h;\n                            }\n                        }\n                    }\n                    this.roundRobinHostHashes.clear(); // start from the beginning next time\n                    rhq = this.queues.get(rhh);\n                }\n            }\n            \n            if (rhq == null) continue tryagain;\n            Request request = rhq.pop(delay, cs, robots); // this pop is outside of synchronization to prevent blocking of pushes\n\n            int size = rhq.size();\n            if (size == 0) {\n                synchronized (this) {\n                    this.queues.remove(rhh);\n                }\n                rhq.close();\n            }\n            if (request == null) continue tryagain;\n            return request;\n        } catch (ConcurrentModificationException e) {\n            continue tryagain;\n        } catch (Throwable e) {\n            throw new IOException(e.getMessage());\n        }\n    }","commit_id":"9c6228d948b7f8c1cead821030cabe67390f8ec0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n    public synchronized void clear() {\n        for (Map.Entry<Integer, Index> entry: this.depthStacks.entrySet()) {\n            entry.getValue().close();\n            getFile(entry.getKey()).delete();\n        }\n        this.depthStacks.clear();\n        String[] l = this.hostPath.list();\n        for (String s: l) {\n            new File(this.hostPath, s).delete();\n        }\n        this.hostPath.delete();\n    }","id":87775,"modified_method":"@Override\n    public synchronized void clear() {\n        for (Map.Entry<Integer, Index> entry: this.depthStacks.entrySet()) {\n            entry.getValue().close();\n            getFile(entry.getKey()).delete();\n        }\n        this.depthStacks.clear();\n        String[] l = this.hostPath.list();\n        if (l != null) for (String s: l) {\n            new File(this.hostPath, s).delete();\n        }\n        this.hostPath.delete();\n    }","commit_id":"9c6228d948b7f8c1cead821030cabe67390f8ec0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** {@inheritDoc */\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final Resource resource = context.createResource(PathAddress.EMPTY_ADDRESS);\n\n        final ModelNode model = resource.getModel();\n        PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        model.get(NAME).set(name);\n        pathAttribute.validateAndSet(operation, model);\n        RELATIVE_TO.validateAndSet(operation, model);\n\n\n\n        if (services) {\n            final String path = getPathValue(context, PATH_SPECIFIED, model);\n            final String relativeTo = getPathValue(context, RELATIVE_TO, model);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                    final PathEventContextImpl pathEventContext = pathManager.checkRestartRequired(context, name, Event.ADDED);\n                    final ServiceController<?> legacyService;\n                    if (pathEventContext.isInstallServices()) {\n                        //Add service to the path manager\n                        pathManager.addPathEntry(name, path, relativeTo, false);\n\n                        //Add the legacy services\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        final ServiceTarget target = context.getServiceTarget();\n                        if (relativeTo == null) {\n                            legacyService = pathManager.addAbsolutePathService(target, name, path, verificationHandler);\n                        } else {\n                            legacyService = pathManager.addRelativePathService(target, name, path, false, relativeTo, verificationHandler);\n                        }\n                        //This is a change from the original version\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n                    } else {\n                        legacyService = null;\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            pathManager.removePathService(context, name);\n                            if (pathEventContext.isInstallServices()) {\n                                if (legacyService != null) {\n                                    context.removeService(legacyService.getName());\n                                }\n                                pathManager.removePathEntry(name);\n                            } else {\n                                pathEventContext.revert();\n                            }\n                        }\n                    });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","id":87776,"modified_method":"/** {@inheritDoc */\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final Resource resource = context.createResource(PathAddress.EMPTY_ADDRESS);\n\n        final ModelNode model = resource.getModel();\n        PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        model.get(NAME).set(name);\n        pathAttribute.validateAndSet(operation, model);\n        RELATIVE_TO.validateAndSet(operation, model);\n\n\n\n        if (services) {\n            final String path = getPathValue(context, PATH_SPECIFIED, model);\n            final String relativeTo = getPathValue(context, RELATIVE_TO, model);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n                    final PathEventContextImpl pathEventContext = pathManager.checkRestartRequired(context, name, Event.ADDED);\n                    final ServiceController<?> legacyService;\n                    if (pathEventContext.isInstallServices()) {\n                        //Add service to the path manager\n                        pathManager.addPathEntry(name, path, relativeTo, false);\n\n                        //Add the legacy services\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        final ServiceTarget target = context.getServiceTarget();\n                        if (relativeTo == null) {\n                            legacyService = pathManager.addAbsolutePathService(target, name, path, verificationHandler);\n                        } else {\n                            legacyService = pathManager.addRelativePathService(target, name, path, false, relativeTo, verificationHandler);\n                        }\n                        //This is a change from the original version\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n                    } else {\n                        legacyService = null;\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            pathManager.removePathService(context, name);\n                            if (pathEventContext.isInstallServices()) {\n                                if (legacyService != null) {\n                                    context.removeService(legacyService.getName());\n                                }\n                                try {\n                                    pathManager.removePathEntry(name, false);\n                                } catch (OperationFailedException e) {\n                                    //Should not happen since 'false' passed in for the check parameter\n                                    throw new RuntimeException(e);\n                                }\n                            } else {\n                                pathEventContext.revert();\n                            }\n                        }\n                    });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","commit_id":"148a96447ec95d55c1ac5deed4db9d55ef412183","url":"https://github.com/wildfly/wildfly"},{"original_method":"final void changeRelativePath(String pathName, String relativePath) {\n        PathEntry pathEntry = findPathEntry(pathName);\n        synchronized (pathEntries) {\n            if (pathEntry.getRelativeTo() != null) {\n                Set<String> dependents = dependenctRelativePaths.get(pathEntry.getRelativeTo());\n                dependents.remove(pathEntry.getName());\n            }\n            pathEntry.setRelativeTo(relativePath);\n            pathEntry.setPathResolver(relativePath == null ? absoluteResolver : relativeResolver);\n            addDependent(pathEntry.getName(), pathEntry.getRelativeTo());\n        }\n        triggerCallbacksForEvent(pathEntry, Event.UPDATED);\n    }","id":87777,"modified_method":"final void changeRelativePath(String pathName, String relativePath, boolean check) throws OperationFailedException {\n        PathEntry pathEntry = findPathEntry(pathName);\n        synchronized (pathEntries) {\n            if (pathEntry.getRelativeTo() != null) {\n                Set<String> dependents = dependenctRelativePaths.get(pathEntry.getRelativeTo());\n                dependents.remove(pathEntry.getName());\n            }\n            if (check && relativePath != null && pathEntries.get(relativePath) == null) {\n                throw MESSAGES.pathEntryNotFound(pathName);\n            }\n            pathEntry.setRelativeTo(relativePath);\n            pathEntry.setPathResolver(relativePath == null ? absoluteResolver : relativeResolver);\n            addDependent(pathEntry.getName(), pathEntry.getRelativeTo());\n        }\n        triggerCallbacksForEvent(pathEntry, Event.UPDATED);\n    }","commit_id":"148a96447ec95d55c1ac5deed4db9d55ef412183","url":"https://github.com/wildfly/wildfly"},{"original_method":"final void removePathEntry(final String pathName) {\n        synchronized (pathEntries) {\n            PathEntry pathEntry = pathEntries.get(pathName);\n            if (pathEntry.isReadOnly()) {\n                throw MESSAGES.pathEntryIsReadOnly(pathName);\n            }\n            pathEntries.remove(pathName);\n            triggerCallbacksForEvent(pathEntry, Event.REMOVED);\n            dependenctRelativePaths.remove(pathName);\n        }\n    }","id":87778,"modified_method":"final void removePathEntry(final String pathName, boolean check) throws OperationFailedException{\n        synchronized (pathEntries) {\n            PathEntry pathEntry = pathEntries.get(pathName);\n            if (pathEntry.isReadOnly()) {\n                throw MESSAGES.pathEntryIsReadOnly(pathName);\n            }\n\n            Set<String> dependents = dependenctRelativePaths.get(pathName);\n            if (dependents != null) {\n                throw MESSAGES.cannotRemovePathWithDependencies(pathName, dependents);\n            }\n            pathEntries.remove(pathName);\n            triggerCallbacksForEvent(pathEntry, Event.REMOVED);\n            if (pathEntry.getRelativeTo() != null) {\n                dependents = dependenctRelativePaths.get(pathEntry.getRelativeTo());\n                if (dependents != null) {\n                    dependents.remove(pathEntry.getName());\n                    if (dependents.size() == 0) {\n                        dependenctRelativePaths.remove(pathEntry.getRelativeTo());\n                    }\n                }\n            }\n        }\n    }","commit_id":"148a96447ec95d55c1ac5deed4db9d55ef412183","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode model = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n\n        if (model.get(READ_ONLY.getName()).asBoolean(false)) {\n            throw ControllerMessages.MESSAGES.cannotRemoveReadOnlyPath(name);\n        }\n\n        context.removeResource(PathAddress.EMPTY_ADDRESS);\n\n        if (services) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final PathEventContextImpl pathEventContext = pathManager.checkRestartRequired(context, name, Event.REMOVED);\n                    if (pathEventContext.isInstallServices()) {\n                        pathManager.removePathService(context, name);\n                        pathManager.removePathEntry(name);\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        @Override\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            try {\n                                final String path = PathAddHandler.getPathValue(context, PATH_SPECIFIED, model);\n                                final String relativeTo = PathAddHandler.getPathValue(context, RELATIVE_TO, model);\n                                if (pathEventContext.isInstallServices()) {\n                                    pathManager.addPathEntry(name, path, relativeTo, false);\n                                    final ServiceTarget target = context.getServiceTarget();\n                                    if (relativeTo == null) {\n                                        pathManager.addAbsolutePathService(target, name, path, null);\n                                    } else {\n                                        pathManager.addRelativePathService(target, name, path, false, relativeTo, null);\n                                    }\n                                } else {\n                                    context.revertRestartRequired();\n                                }\n\n\n                            } catch (Exception e) {\n                                MGMT_OP_LOGGER.errorRevertingOperation(e, getClass().getSimpleName(),\n                                    operation.require(ModelDescriptionConstants.OP).asString(),\n                                    PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n                            }\n                        }\n                    });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","id":87779,"modified_method":"public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n\n        final PathAddress address = PathAddress.pathAddress(operation.require(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode model = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n\n        if (model.get(READ_ONLY.getName()).asBoolean(false)) {\n            throw ControllerMessages.MESSAGES.cannotRemoveReadOnlyPath(name);\n        }\n\n        context.removeResource(PathAddress.EMPTY_ADDRESS);\n\n        if (services) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final PathEventContextImpl pathEventContext = pathManager.checkRestartRequired(context, name, Event.REMOVED);\n                    if (pathEventContext.isInstallServices()) {\n                        pathManager.removePathEntry(name, true);\n                        pathManager.removePathService(context, name);\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        @Override\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            try {\n                                final String path = PathAddHandler.getPathValue(context, PATH_SPECIFIED, model);\n                                final String relativeTo = PathAddHandler.getPathValue(context, RELATIVE_TO, model);\n                                if (pathEventContext.isInstallServices()) {\n                                    pathManager.addPathEntry(name, path, relativeTo, false);\n                                    final ServiceTarget target = context.getServiceTarget();\n                                    if (relativeTo == null) {\n                                        pathManager.addAbsolutePathService(target, name, path, null);\n                                    } else {\n                                        pathManager.addRelativePathService(target, name, path, false, relativeTo, null);\n                                    }\n                                } else {\n                                    context.revertRestartRequired();\n                                }\n\n\n                            } catch (Exception e) {\n                                MGMT_OP_LOGGER.errorRevertingOperation(e, getClass().getSimpleName(),\n                                    operation.require(ModelDescriptionConstants.OP).asString(),\n                                    PathAddress.pathAddress(operation.get(ModelDescriptionConstants.OP_ADDR)));\n                            }\n                        }\n                    });\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","commit_id":"148a96447ec95d55c1ac5deed4db9d55ef412183","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void modelChanged(final OperationContext context, final ModelNode operation, final String attributeName, final ModelNode newValue,\n            final ModelNode currentValue) throws OperationFailedException {\n\n        final String pathName = PathAddress.pathAddress(operation.get(OP_ADDR)).getLastElement().getValue();\n        final ModelNode model = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        if (model.get(READ_ONLY.getName()).asBoolean(false)) {\n            throw ControllerMessages.MESSAGES.cannotModifyReadOnlyPath(pathName);\n        }\n\n        if (services) {\n            final PathEntry pathEntry = pathManager.getPathEntry(pathName);\n            if (pathEntry.isReadOnly()) {\n                throw MESSAGES.pathEntryIsReadOnly(operation.require(OP_ADDR).asString());\n            }\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final PathEntry backup = new PathEntry(pathEntry);\n\n                    final PathEventContextImpl pathEventContext = pathManager.checkRestartRequired(context, pathName, Event.UPDATED);\n                    if (pathEventContext.isInstallServices()) {\n                        if (attributeName.equals(PATH)) {\n                            pathManager.changePath(pathName, newValue.asString());\n                            pathManager.changePathServices(context, pathName, newValue.asString());\n                        } else if (attributeName.equals(RELATIVE_TO)) {\n                            pathManager.changeRelativePath( pathName, newValue.isDefined() ?  newValue.asString() : null);\n                            pathManager.changeRelativePathServices(context, pathName, newValue.isDefined() ?  newValue.asString() : null);\n                        }\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            if (pathEventContext.isInstallServices()) {\n                                if (attributeName.equals(PATH)) {\n                                    pathManager.changePath(pathName, backup.getPath());\n                                    pathManager.changePathServices(context, pathName, currentValue.asString());\n                                } else if (attributeName.equals(RELATIVE_TO)) {\n                                    pathManager.changeRelativePath( pathName, backup.getRelativeTo());\n                                    pathManager.changeRelativePathServices(context, pathName, currentValue.isDefined() ?  currentValue.asString() : null);\n                                }\n                            } else {\n                                pathEventContext.revert();\n                            }\n                        }\n                    });\n                }\n            }, Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","id":87780,"modified_method":"@Override\n    protected void modelChanged(final OperationContext context, final ModelNode operation, final String attributeName, final ModelNode newValue,\n            final ModelNode currentValue) throws OperationFailedException {\n\n        final String pathName = PathAddress.pathAddress(operation.get(OP_ADDR)).getLastElement().getValue();\n        final ModelNode model = Resource.Tools.readModel(context.readResource(PathAddress.EMPTY_ADDRESS));\n        if (model.get(READ_ONLY.getName()).asBoolean(false)) {\n            throw ControllerMessages.MESSAGES.cannotModifyReadOnlyPath(pathName);\n        }\n\n        if (services) {\n            final PathEntry pathEntry = pathManager.getPathEntry(pathName);\n            if (pathEntry.isReadOnly()) {\n                throw MESSAGES.pathEntryIsReadOnly(operation.require(OP_ADDR).asString());\n            }\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final PathEntry backup = new PathEntry(pathEntry);\n\n                    final PathEventContextImpl pathEventContext = pathManager.checkRestartRequired(context, pathName, Event.UPDATED);\n                    if (pathEventContext.isInstallServices()) {\n                        if (attributeName.equals(PATH)) {\n                            pathManager.changePath(pathName, newValue.asString());\n                            pathManager.changePathServices(context, pathName, newValue.asString());\n                        } else if (attributeName.equals(RELATIVE_TO)) {\n                            pathManager.changeRelativePath( pathName, newValue.isDefined() ?  newValue.asString() : null, true);\n                            pathManager.changeRelativePathServices(context, pathName, newValue.isDefined() ?  newValue.asString() : null);\n                        }\n                    }\n\n                    context.completeStep(new OperationContext.RollbackHandler() {\n                        public void handleRollback(OperationContext context, ModelNode operation) {\n                            if (pathEventContext.isInstallServices()) {\n                                if (attributeName.equals(PATH)) {\n                                    pathManager.changePath(pathName, backup.getPath());\n                                    pathManager.changePathServices(context, pathName, currentValue.asString());\n                                } else if (attributeName.equals(RELATIVE_TO)) {\n                                    try {\n                                        pathManager.changeRelativePath(pathName, backup.getRelativeTo(), false);\n                                    } catch (OperationFailedException e) {\n                                        //Should not happen since false passed in for the 'check' parameter\n                                        throw new RuntimeException(e);\n                                    }\n                                    pathManager.changeRelativePathServices(context, pathName, currentValue.isDefined() ?  currentValue.asString() : null);\n                                }\n                            } else {\n                                pathEventContext.revert();\n                            }\n                        }\n                    });\n                }\n            }, Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","commit_id":"148a96447ec95d55c1ac5deed4db9d55ef412183","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testBadChangeNoNotification() throws Exception {\n        ServiceController<?> pathManagerService = getContainer().getRequiredService(PathManagerService.SERVICE_NAME);\n        PathManager pathManager = (PathManager)pathManagerService.getValue();\n\n        PerformChangeCallback allCallback1 = new PerformChangeCallback(pathManager, \"add1\", Event.ADDED, Event.REMOVED, Event.UPDATED);\n\n\n        ModelNode operation = createOperation(ADD);\n        operation.get(OP_ADDR).add(PATH, \"add1\");\n        operation.get(PATH).set(\"123\");\n        executeForResult(operation);\n        allCallback1.checkEvent(Event.ADDED, \"add1\", \"123\", null);\n        allCallback1.checkDone();\n\n\n        operation = createOperation(ADD);\n        operation.get(OP_ADDR).add(PATH, \"add1\");\n        operation.get(PATH).set(\"123\");\n        operation.get(RELATIVE_TO).set(\"bad\");\n\n        //TODO I changed this to fail, not 100% sure that is correct\n        executeForFailure(operation);\n\n        ServiceController<?> svc = getContainer().getRequiredService(AbstractPathService.pathNameOf(\"add1\"));\n        allCallback1.checkDone();\n        checkServiceAndPathEntry(\"add1\", \"123\", null);\n    }","id":87781,"modified_method":"@Test\n    public void testBadChangeNoNotification() throws Exception {\n        ServiceController<?> pathManagerService = getContainer().getRequiredService(PathManagerService.SERVICE_NAME);\n        PathManager pathManager = (PathManager)pathManagerService.getValue();\n\n        PerformChangeCallback allCallback1 = new PerformChangeCallback(pathManager, \"add1\", Event.ADDED, Event.REMOVED, Event.UPDATED);\n\n\n        ModelNode operation = createOperation(ADD);\n        operation.get(OP_ADDR).add(PATH, \"add1\");\n        operation.get(PATH).set(\"123\");\n        executeForResult(operation);\n        allCallback1.checkEvent(Event.ADDED, \"add1\", \"123\", null);\n        allCallback1.checkDone();\n\n\n        operation = createOperation(WRITE_ATTRIBUTE_OPERATION);\n        operation.get(OP_ADDR).add(PATH, \"add1\");\n        operation.get(NAME).set(RELATIVE_TO);\n        operation.get(VALUE).set(\"bad\");\n\n        //TODO I changed this to fail, not 100% sure that is correct\n        executeForFailure(operation);\n\n        ServiceController<?> svc = getContainer().getRequiredService(AbstractPathService.pathNameOf(\"add1\"));\n        allCallback1.checkDone();\n        checkServiceAndPathEntry(\"add1\", \"123\", null);\n    }","commit_id":"148a96447ec95d55c1ac5deed4db9d55ef412183","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n\tpublic void testGetDDMXSD() throws Exception {\n\t\tDDMStructure expectedDDMStructure = new DDMStructureImpl();\n\n\t\texpectedDDMStructure.setXsd(\n\t\t\treadText(\"test-ddm-structure-all-fields.xml\"));\n\n\t\tDDMStructure actualDDMStructure = new DDMStructureImpl();\n\n\t\tactualDDMStructure.setXsd(\n\t\t\tJournalConverterUtil.getDDMXSD(\n\t\t\t\treadText(\"test-journal-structure-all-fields.xml\")));\n\n\t\tAssert.assertEquals(\n\t\t\texpectedDDMStructure.getFieldsMap(),\n\t\t\tactualDDMStructure.getFieldsMap());\n\t}","id":87782,"modified_method":"@Test\n\tpublic void testGetDDMXSD() throws Exception {\n\t\tDDMStructure expectedDDMStructure = new DDMStructureImpl();\n\n\t\texpectedDDMStructure.setXsd(\n\t\t\treadText(\"test-ddm-structure-all-fields.xml\"));\n\n\t\tString actualXSD = JournalConverterUtil.getDDMXSD(\n\t\t\treadText(\"test-journal-structure-all-fields.xml\"));\n\n\t\tvalidateDDMXSD(actualXSD);\n\n\t\tDDMStructure actualDDMStructure = new DDMStructureImpl();\n\n\t\tactualDDMStructure.setXsd(actualXSD);\n\n\t\tAssert.assertEquals(\n\t\t\texpectedDDMStructure.getFieldsMap(),\n\t\t\tactualDDMStructure.getFieldsMap());\n\t}","commit_id":"5cc9e6ae07ed70bef4112986cc7b5dc56dd2a3cf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetDDMXSD() throws Exception {\n\t\tDDMStructure expectedDDMStructure = new DDMStructureImpl();\n\n\t\texpectedDDMStructure.setXsd(\n\t\t\treadText(\"test-ddm-structure-all-fields.xml\"));\n\n\t\tString actualXSD = JournalConverterUtil.getDDMXSD(\n\t\t\treadText(\"test-journal-structure-all-fields.xml\"));\n\n\t\tvalidateDDMXSD(actualXSD);\n\n\t\tDDMStructure actualDDMStructure = new DDMStructureImpl();\n\n\t\tactualDDMStructure.setXsd(actualXSD);\n\n\t\tAssert.assertEquals(\n\t\t\texpectedDDMStructure.getFieldsMap(),\n\t\t\tactualDDMStructure.getFieldsMap());\n\t}","id":87783,"modified_method":"@Test\n\tpublic void testGetDDMXSD() throws Exception {\n\t\tDDMStructure expectedDDMStructure = new DDMStructureImpl();\n\n\t\texpectedDDMStructure.setXsd(\n\t\t\treadText(\"test-ddm-structure-all-fields.xml\"));\n\n\t\tDDMStructure actualDDMStructure = new DDMStructureImpl();\n\n\t\tactualDDMStructure.setXsd(\n\t\t\tJournalConverterUtil.getDDMXSD(\n\t\t\t\treadText(\"test-journal-structure-all-fields.xml\")));\n\n\t\tAssert.assertEquals(\n\t\t\texpectedDDMStructure.getFieldsMap(),\n\t\t\tactualDDMStructure.getFieldsMap());\n\t}","commit_id":"64a5a2d3e22b3479dbee43846b25d8deba48c4de","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetDDMXSD() throws Exception {\n\t\tDDMStructure expectedDDMStructure = new DDMStructureImpl();\n\n\t\texpectedDDMStructure.setXsd(\n\t\t\treadText(\"test-ddm-structure-all-fields.xml\"));\n\n\t\tDDMStructure actualDDMStructure = new DDMStructureImpl();\n\n\t\tactualDDMStructure.setXsd(\n\t\t\tJournalConverterUtil.getDDMXSD(\n\t\t\t\treadText(\"test-journal-structure-all-fields.xml\")));\n\n\t\tAssert.assertEquals(\n\t\t\texpectedDDMStructure.getFieldsMap(),\n\t\t\tactualDDMStructure.getFieldsMap());\n\t}","id":87784,"modified_method":"@Test\n\tpublic void testGetDDMXSD() throws Exception {\n\t\tDDMStructure expectedDDMStructure = new DDMStructureImpl();\n\n\t\texpectedDDMStructure.setXsd(\n\t\t\treadText(\"test-ddm-structure-all-fields.xml\"));\n\n\t\tString actualXSD = JournalConverterUtil.getDDMXSD(\n\t\t\treadText(\"test-journal-structure-all-fields.xml\"));\n\n\t\tvalidateDDMXSD(actualXSD);\n\n\t\tDDMStructure actualDDMStructure = new DDMStructureImpl();\n\n\t\tactualDDMStructure.setXsd(actualXSD);\n\n\t\tAssert.assertEquals(\n\t\t\texpectedDDMStructure.getFieldsMap(),\n\t\t\tactualDDMStructure.getFieldsMap());\n\t}","commit_id":"7e0f4b7632b1b7b8818d4aae0553ec5bca6db67c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Performs the copy action, will be called by the JSP page.<p>\n     * \n     * @throws JspException if problems including sub-elements occur\n     */\n    public void actionCopy() throws JspException {\n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        try {\n            if (performCopyOperation())  {\n                // if no exception is caused and \"true\" is returned copy operation was successful\n                getJsp().include(C_FILE_EXPLORER_FILELIST);\n            } else  {\n                // \"false\" returned, display \"please wait\" screen\n                getJsp().include(C_FILE_DIALOG_SCREEN_WAIT);\n            }    \n        } catch (CmsException e) {\n            // prepare common message part\n            String message = \"<p>\\n\" \n                + key(\"source\") + \": \" + getParamFile() + \"<br>\\n\" \n                + key(\"target\") + \": \" + getParamTarget() + \"\\n<\/p>\\n\";\n            // check if this exception requires a confirmation or error screen\n            if ((e.getType() == CmsException.C_FILE_EXISTS) \n            && !(CmsResource.isFolder(getParamFile()))) {\n                // file copy but file already exists, show confirmation dialog\n                setParamMessage(message + key(\"confirm.message.\" + getParamDialogtype()));\n                getJsp().include(C_FILE_DIALOG_SCREEN_CONFIRM);        \n            } else {                \n                // error during copy, show error dialog\n                setParamErrorstack(e.getStackTraceAsString());\n                setParamMessage(message + key(\"error.message.\" + getParamDialogtype()));\n                getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n            }\n        }\n    }","id":87785,"modified_method":"/**\n     * Performs the copy action, will be called by the JSP page.<p>\n     * \n     * @throws JspException if problems including sub-elements occur\n     */\n    public void actionCopy() throws JspException {\n        // save initialized instance of this class in request attribute for included sub-elements\n        getJsp().getRequest().setAttribute(C_SESSION_WORKPLACE_CLASS, this);\n        CmsResource res = null;\n        try {\n            res = getCms().readFileHeader(getParamFile());\n            if (performCopyOperation())  {\n                // if no exception is caused and \"true\" is returned copy operation was successful\n                getJsp().include(C_FILE_EXPLORER_FILELIST);\n            } else  {\n                // \"false\" returned, display \"please wait\" screen\n                getJsp().include(C_FILE_DIALOG_SCREEN_WAIT);\n            }    \n        } catch (CmsException e) {\n            // prepare common message part\n            String message = \"<p>\\n\" \n                + key(\"source\") + \": \" + getParamFile() + \"<br>\\n\" \n                + key(\"target\") + \": \" + getParamTarget() + \"\\n<\/p>\\n\";\n            // check if this exception requires a confirmation or error screen\n            if ((e.getType() == CmsException.C_FILE_EXISTS) \n            && !(res.isFolder())) {\n                // file copy but file already exists, show confirmation dialog\n                setParamMessage(message + key(\"confirm.message.\" + getParamDialogtype()));\n                getJsp().include(C_FILE_DIALOG_SCREEN_CONFIRM);        \n            } else {                \n                // error during copy, show error dialog\n                setParamErrorstack(e.getStackTraceAsString());\n                setParamMessage(message + key(\"error.message.\" + getParamDialogtype()));\n                getJsp().include(C_FILE_DIALOG_SCREEN_ERROR);\n            }\n        }\n    }","commit_id":"1b705e96968c03cb39af490892cd07106e549a81","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the resource copying.<p>\n     * \n     * @return true, if the resource was copied, otherwise false\n     * @throws CmsException if copying is not successful\n     */\n    private boolean performCopyOperation() throws CmsException {\n\n        // on folder copy display \"please wait\" screen, not for simple file copy\n        if (CmsResource.isFolder(getParamFile()) && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // calculate the target name\n        String target = getParamTarget();\n        if (target == null) target = \"\";\n\n        if (! target.startsWith(\"/\")) {\n            // target is not an absolute path, add the current parent folder\n            target = CmsResource.getParent(getParamFile()) + target; \n        }\n        try {\n            CmsResource res = getCms().readFileHeader(target);\n            if (res.isFolder()) {\n                // target folder already exists, so we add the current folder name\n                if (! target.endsWith(\"/\")) target += \"/\";\n                target = target + CmsResource.getName(getParamFile());\n            }\n        } catch (CmsException e) {\n            // target folder does not already exist, so target name is o.k.\n        }\n        \n        // set the target parameter value\n        setParamTarget(target);        \n        \n        // delete existing target resource if confirmed by the user\n        if (DIALOG_CONFIRMED.equals(getParamAction())) {\n            getCms().deleteResource(target);\n        }            \n        \n        // copy the resource       \n        getCms().copyResource(getParamFile(), target, \"true\".equals(getParamKeeprights()));\n        return true;\n    }","id":87786,"modified_method":"/**\n     * Performs the resource copying.<p>\n     * \n     * @return true, if the resource was copied, otherwise false\n     * @throws CmsException if copying is not successful\n     */\n    private boolean performCopyOperation() throws CmsException {\n\n        // on folder copy display \"please wait\" screen, not for simple file copy\n        CmsResource sourceRes = getCms().readFileHeader(getParamFile());\n        if (sourceRes.isFolder() && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // calculate the target name\n        String target = getParamTarget();\n        if (target == null) target = \"\";\n\n        if (! target.startsWith(\"/\")) {\n            // target is not an absolute path, add the current parent folder\n            target = CmsResource.getParent(getParamFile()) + target; \n        }\n        try {\n            CmsResource res = getCms().readFileHeader(target);\n            if (res.isFolder()) {\n                // target folder already exists, so we add the current folder name\n                if (! target.endsWith(\"/\")) target += \"/\";\n                target = target + CmsResource.getName(getParamFile());\n            }\n        } catch (CmsException e) {\n            // target folder does not already exist, so target name is o.k.\n        }\n        \n        // set the target parameter value\n        setParamTarget(target);        \n        \n        // delete existing target resource if confirmed by the user\n        if (DIALOG_CONFIRMED.equals(getParamAction())) {\n            getCms().deleteResource(target);\n        }            \n        \n        // copy the resource       \n        getCms().copyResource(getParamFile(), target, \"true\".equals(getParamKeeprights()));\n        return true;\n    }","commit_id":"1b705e96968c03cb39af490892cd07106e549a81","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the resource deletion.<p>\n     * \n     * @return true, if the resource was deleted, otherwise false\n     * @throws CmsException if deletion is not successful\n     */\n    private boolean performDeleteOperation() throws CmsException {     \n        \n        // on folder deletion display \"please wait\" screen, not for simple file touching\n        if (CmsResource.isFolder(getParamFile()) && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n         \n        // delete the resource\n        getCms().deleteResource(getParamFile());\n        return true;\n    }","id":87787,"modified_method":"/**\n     * Performs the resource deletion.<p>\n     * \n     * @return true, if the resource was deleted, otherwise false\n     * @throws CmsException if deletion is not successful\n     */\n    private boolean performDeleteOperation() throws CmsException {     \n        \n        // on folder copy display \"please wait\" screen, not for simple file copy\n        CmsResource sourceRes = getCms().readFileHeader(getParamFile());\n        if (sourceRes.isFolder() && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n         \n        // delete the resource\n        getCms().deleteResource(getParamFile());\n        return true;\n    }","commit_id":"1b705e96968c03cb39af490892cd07106e549a81","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the resource moving.<p>\n     * \n     * @return true, if the resource was copied, otherwise false\n     * @throws CmsException if copying is not successful\n     */\n    private boolean performMoveOperation() throws CmsException {\n\n        // on folder move display \"please wait\" screen, not for simple file copy\n        if (CmsResource.isFolder(getParamFile()) && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // get the target name\n        String target = getParamTarget();\n        if (target == null) target = \"\";\n        \n        if (target.equals(getParamFile())) {\n            throw new CmsException(\"Can't move resource onto itself.\", CmsException.C_FILESYSTEM_ERROR);\n        }\n        \n        // calculate the target name\n        if (! target.startsWith(\"/\")) {\n            // target is not an absolute path, add the current parent folder\n            target = CmsResource.getParent(getParamFile()) + target; \n        }\n        try {\n            CmsResource res = getCms().readFileHeader(target);\n            if (res.isFolder()) {\n                // target folder already exists, so we add the current folder name\n                if (! target.endsWith(\"/\")) target += \"/\";\n                target = target + CmsResource.getName(getParamFile());\n                if (target.endsWith(\"/\")) target = target.substring(0,target.length()-1);\n            }\n        } catch (CmsException e) {\n            // target folder does not already exist, so target name is o.k.\n        }\n        \n        // set the target parameter value\n        setParamTarget(target);        \n        \n        // check if target already exists, if so, throw exception to show confirmation dialog\n        CmsResource targetRes = null;\n        try {\n            targetRes = getCms().readFileHeader(target);\n        } catch (CmsException e) {}\n\n        if (targetRes != null) {\n            if (DIALOG_CONFIRMED.equals(getParamAction())) {\n                // delete existing target resource if confirmed by the user\n                getCms().deleteResource(target);\n            } else {\n                // throw exception to indicate that the target exists\n                throw new CmsException(\"The target already exists\", CmsException.C_FILE_EXISTS);\n            }\n        } \n                \n        // move the resource\n        getCms().moveResource(getParamFile(), target);\n        return true;\n    }","id":87788,"modified_method":"/**\n     * Performs the resource moving.<p>\n     * \n     * @return true, if the resource was copied, otherwise false\n     * @throws CmsException if copying is not successful\n     */\n    private boolean performMoveOperation() throws CmsException {\n\n        // on folder copy display \"please wait\" screen, not for simple file copy\n        CmsResource sourceRes = getCms().readFileHeader(getParamFile());\n        if (sourceRes.isFolder() && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // get the target name\n        String target = getParamTarget();\n        if (target == null) target = \"\";\n        \n        if (target.equals(getParamFile())) {\n            throw new CmsException(\"Can't move resource onto itself.\", CmsException.C_FILESYSTEM_ERROR);\n        }\n        \n        // calculate the target name\n        if (! target.startsWith(\"/\")) {\n            // target is not an absolute path, add the current parent folder\n            target = CmsResource.getParent(getParamFile()) + target; \n        }\n        try {\n            CmsResource res = getCms().readFileHeader(target);\n            if (res.isFolder()) {\n                // target folder already exists, so we add the current folder name\n                if (! target.endsWith(\"/\")) target += \"/\";\n                target = target + CmsResource.getName(getParamFile());\n                if (target.endsWith(\"/\")) target = target.substring(0,target.length()-1);\n            }\n        } catch (CmsException e) {\n            // target folder does not already exist, so target name is o.k.\n        }\n        \n        // set the target parameter value\n        setParamTarget(target);        \n        \n        // check if target already exists, if so, throw exception to show confirmation dialog\n        CmsResource targetRes = null;\n        try {\n            targetRes = getCms().readFileHeader(target);\n        } catch (CmsException e) {}\n\n        if (targetRes != null) {\n            if (DIALOG_CONFIRMED.equals(getParamAction())) {\n                // delete existing target resource if confirmed by the user\n                getCms().deleteResource(target);\n            } else {\n                // throw exception to indicate that the target exists\n                throw new CmsException(\"The target already exists\", CmsException.C_FILE_EXISTS);\n            }\n        } \n                \n        // move the resource\n        getCms().moveResource(getParamFile(), target);\n        return true;\n    }","commit_id":"1b705e96968c03cb39af490892cd07106e549a81","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Performs the resource touching.<p>\n     * \n     * @return true, if the resource was touched, otherwise false\n     * @throws CmsException if touching is not successful\n     */\n    private boolean performTouchOperation() throws CmsException {\n\n        // on recursive folder touch display \"please wait\" screen, not for simple file touching\n        if (CmsResource.isFolder(getParamFile()) && \"true\".equals(getParamRecursive()) && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // get the current resource name\n        String filename = getParamFile();\n\n        // get the new timestamp for the resource(s) from request parameter\n        long timeStamp;\n        try {\n            timeStamp = Long.parseLong(getParamNewtimestampmillis());\n        } catch (Exception e) {\n            timeStamp = -1;\n        }\n\n        // get the flag if the touch is recursive from request parameter\n        boolean touchRecursive = \"true\".equalsIgnoreCase(getParamRecursive());     \n  \n        // now touch the resource(s)\n        if (timeStamp != -1) {\n            getCms().touch(filename, timeStamp, touchRecursive);      \n        }\n        return true;\n    }","id":87789,"modified_method":"/**\n     * Performs the resource touching.<p>\n     * \n     * @return true, if the resource was touched, otherwise false\n     * @throws CmsException if touching is not successful\n     */\n    private boolean performTouchOperation() throws CmsException {\n\n        // on folder copy display \"please wait\" screen, not for simple file copy\n        CmsResource sourceRes = getCms().readFileHeader(getParamFile());\n        if (sourceRes.isFolder() && ! DIALOG_WAIT.equals(getParamAction())) {\n            // return false, this will trigger the \"please wait\" screen\n            return false;\n        }\n\n        // get the current resource name\n        String filename = getParamFile();\n\n        // get the new timestamp for the resource(s) from request parameter\n        long timeStamp;\n        try {\n            timeStamp = Long.parseLong(getParamNewtimestampmillis());\n        } catch (Exception e) {\n            timeStamp = -1;\n        }\n\n        // get the flag if the touch is recursive from request parameter\n        boolean touchRecursive = \"true\".equalsIgnoreCase(getParamRecursive());     \n  \n        // now touch the resource(s)\n        if (timeStamp != -1) {\n            getCms().touch(filename, timeStamp, touchRecursive);      \n        }\n        return true;\n    }","commit_id":"1b705e96968c03cb39af490892cd07106e549a81","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates the \"recursive\" checkbox for touching subresources of folders.<p>\n     *  \n     * @return the String with the checkbox input field or an empty String for folders.\n     */\n    public String buildCheckRecursive() {\n        StringBuffer retValue = new StringBuffer(256);\n        \n        // show the checkbox only for folders\n        if (CmsResource.isFolder(getParamFile())) {\n            retValue.append(\"<tr>\\n\\t<td colspan=\\\"2\\\" style=\\\"white-space: nowrap;\\\" unselectable=\\\"on\\\">\");\n            retValue.append(\"<input type=\\\"checkbox\\\" name=\\\"\"+PARAM_RECURSIVE+\"\\\" value=\\\"true\\\">&nbsp;\"+key(\"input.changesubresources\"));\n            retValue.append(\"<\/td>\\n<\/tr>\\n\");\n        }\n        return retValue.toString();\n    }","id":87790,"modified_method":"/**\n     * Creates the \"recursive\" checkbox for touching subresources of folders.<p>\n     *  \n     * @return the String with the checkbox input field or an empty String for folders.\n     */\n    public String buildCheckRecursive() {\n        StringBuffer retValue = new StringBuffer(256);\n        \n        CmsResource res = null;\n        try {\n            res = getCms().readFileHeader(getParamFile());\n        } catch (CmsException e) {\n            return \"\";\n        }    \n        \n        // show the checkbox only for folders\n        if (res.isFolder()) {\n            retValue.append(\"<tr>\\n\\t<td colspan=\\\"2\\\" style=\\\"white-space: nowrap;\\\" unselectable=\\\"on\\\">\");\n            retValue.append(\"<input type=\\\"checkbox\\\" name=\\\"\"+PARAM_RECURSIVE+\"\\\" value=\\\"true\\\">&nbsp;\"+key(\"input.changesubresources\"));\n            retValue.append(\"<\/td>\\n<\/tr>\\n\");\n        }\n        return retValue.toString();\n    }","commit_id":"1b705e96968c03cb39af490892cd07106e549a81","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n  public PyDecorator findDecorator(String name) {\n    final PyDecorator[] decorators = getDecorators();\n    for (PyDecorator decorator : decorators) {\n      if (name.equals(decorator.getCallee().getText())) {\n        return decorator;\n      }\n    }\n    return null;\n  }","id":87791,"modified_method":"@Override\n  public PyDecorator findDecorator(String name) {\n    final PyDecorator[] decorators = getDecorators();\n    for (PyDecorator decorator : decorators) {\n      final PyExpression callee = decorator.getCallee();\n      if (callee != null && name.equals(callee.getText())) {\n        return decorator;\n      }\n    }\n    return null;\n  }","commit_id":"50ce261ed142fbd32b32b65b7e07e5e42d9cf865","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addAddSelfFix(PyElement node, PyReferenceExpression refex, List<LocalQuickFix> actions) {\n      final PyClass containedClass = PsiTreeUtil.getParentOfType(node, PyClass.class);\n      final PyFunction function = PsiTreeUtil.getParentOfType(node, PyFunction.class);\n      if (containedClass != null && function != null) {\n        final PyParameter[] parameters = function.getParameterList().getParameters();\n        if (parameters.length == 0) return;\n        final String qualifier = parameters[0].getText();\n        final PyDecoratorList decoratorList = function.getDecoratorList();\n        boolean isClassmethod = false;\n        if (decoratorList != null) {\n          for (PyDecorator decorator : decoratorList.getDecorators()) {\n            if (PyNames.CLASSMETHOD.equals(decorator.getCallee().getText()))\n              isClassmethod = true;\n          }\n        }\n        for (PyTargetExpression target : containedClass.getInstanceAttributes()) {\n          if (!isClassmethod && Comparing.strEqual(node.getName(), target.getName())) {\n            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex, qualifier));\n          }\n        }\n        for (PyStatement statement : containedClass.getStatementList().getStatements()) {\n          if (statement instanceof PyAssignmentStatement) {\n            PyExpression lhsExpression = ((PyAssignmentStatement)statement).getLeftHandSideExpression();\n            if (lhsExpression != null && lhsExpression.getText().equals(refex.getText())) {\n              PyExpression callexpr = ((PyAssignmentStatement)statement).getAssignedValue();\n              if (callexpr instanceof PyCallExpression) {\n                PyType type = myTypeEvalContext.getType(callexpr);\n                if (type != null && type instanceof PyClassTypeImpl) {\n                  if (((PyCallExpression)callexpr).isCalleeText(PyNames.PROPERTY)) {\n                    actions.add(new UnresolvedReferenceAddSelfQuickFix(refex, qualifier));\n                  }\n                }\n              }\n            }\n          }\n        }\n        for (PyFunction method : containedClass.getMethods()) {\n          if (refex.getText().equals(method.getName())) {\n            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex, qualifier));\n          }\n        }\n      }\n    }","id":87792,"modified_method":"private void addAddSelfFix(PyElement node, PyReferenceExpression refex, List<LocalQuickFix> actions) {\n      final PyClass containedClass = PsiTreeUtil.getParentOfType(node, PyClass.class);\n      final PyFunction function = PsiTreeUtil.getParentOfType(node, PyFunction.class);\n      if (containedClass != null && function != null) {\n        final PyParameter[] parameters = function.getParameterList().getParameters();\n        if (parameters.length == 0) return;\n        final String qualifier = parameters[0].getText();\n        final PyDecoratorList decoratorList = function.getDecoratorList();\n        boolean isClassmethod = false;\n        if (decoratorList != null) {\n          for (PyDecorator decorator : decoratorList.getDecorators()) {\n            final PyExpression callee = decorator.getCallee();\n            if (callee != null && PyNames.CLASSMETHOD.equals(callee.getText()))\n              isClassmethod = true;\n          }\n        }\n        for (PyTargetExpression target : containedClass.getInstanceAttributes()) {\n          if (!isClassmethod && Comparing.strEqual(node.getName(), target.getName())) {\n            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex, qualifier));\n          }\n        }\n        for (PyStatement statement : containedClass.getStatementList().getStatements()) {\n          if (statement instanceof PyAssignmentStatement) {\n            PyExpression lhsExpression = ((PyAssignmentStatement)statement).getLeftHandSideExpression();\n            if (lhsExpression != null && lhsExpression.getText().equals(refex.getText())) {\n              PyExpression callexpr = ((PyAssignmentStatement)statement).getAssignedValue();\n              if (callexpr instanceof PyCallExpression) {\n                PyType type = myTypeEvalContext.getType(callexpr);\n                if (type != null && type instanceof PyClassTypeImpl) {\n                  if (((PyCallExpression)callexpr).isCalleeText(PyNames.PROPERTY)) {\n                    actions.add(new UnresolvedReferenceAddSelfQuickFix(refex, qualifier));\n                  }\n                }\n              }\n            }\n          }\n        }\n        for (PyFunction method : containedClass.getMethods()) {\n          if (refex.getText().equals(method.getName())) {\n            actions.add(new UnresolvedReferenceAddSelfQuickFix(refex, qualifier));\n          }\n        }\n      }\n    }","commit_id":"e4e5d6af01198a12704566a3c2c70749fe70888e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyCallExpression(PyCallExpression node) {\n      if (isDict(node)) {\n        Map<String, PsiElement> map = new HashMap<String, PsiElement>();\n        PyExpression[] argumentList = node.getArgumentList().getArguments();\n        for (PyExpression argument : argumentList) {\n          if (argument instanceof PyParenthesizedExpression)\n            argument = ((PyParenthesizedExpression)argument).getContainedExpression();\n          if (argument instanceof PySequenceExpression) {\n            for (PyElement el : ((PySequenceExpression)argument).getElements()) {\n              PsiElement key = getKey(el);\n              checkKey(map, key);\n            }\n          }\n          else {\n            PsiElement key = getKey(argument);\n            checkKey(map, key);\n          }\n        }\n      }\n    }","id":87793,"modified_method":"@Override\n    public void visitPyCallExpression(final PyCallExpression node) {\n      if (isDict(node)) {\n        final Map<String, PsiElement> map = new HashMap<String, PsiElement>();\n        final PyArgumentList pyArgumentList = node.getArgumentList();\n        if (pyArgumentList == null) return;\n        final PyExpression[] arguments = pyArgumentList.getArguments();\n        for (PyExpression argument : arguments) {\n          if (argument instanceof PyParenthesizedExpression)\n            argument = ((PyParenthesizedExpression)argument).getContainedExpression();\n          if (argument instanceof PySequenceExpression) {\n            for (PyElement el : ((PySequenceExpression)argument).getElements()) {\n              final PsiElement key = getKey(el);\n              checkKey(map, key);\n            }\n          }\n          else {\n            final PsiElement key = getKey(argument);\n            checkKey(map, key);\n          }\n        }\n      }\n    }","commit_id":"e2022325dc7136aa3eef8f9168bb6d313b90d57c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isDict(PyCallExpression expression) {\n      String name = expression.getCallee().getText();\n      if (\"dict\".equals(name)) {\n        return true;\n      }\n      return false;\n    }","id":87794,"modified_method":"private static boolean isDict(final PyCallExpression expression) {\n      final PyExpression callee = expression.getCallee();\n      if (callee == null) return false;\n      final String name = callee.getText();\n      if (\"dict\".equals(name)) {\n        return true;\n      }\n      return false;\n    }","commit_id":"e2022325dc7136aa3eef8f9168bb6d313b90d57c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyDictLiteralExpression(PyDictLiteralExpression node) {\n      if (node.getElements().length != 0){\n        Map<String, PyElement> map = new HashMap<String, PyElement>();\n        for (PyExpression exp : node.getElements()) {\n          PyExpression key = ((PyKeyValueExpression)exp).getKey();\n          if (key instanceof PyNumericLiteralExpression\n                  || key instanceof PyStringLiteralExpression || key instanceof PyReferenceExpression) {\n            if (map.keySet().contains(key.getText())) {\n              registerProblem(key, \"Dictionary contains duplicate keys \" + key.getText());\n              registerProblem(map.get(key.getText()), \"Dictionary contains duplicate keys \" + key.getText());\n            }\n            map.put(key.getText(), key);\n          }\n        }\n      }\n    }","id":87795,"modified_method":"@Override\n    public void visitPyDictLiteralExpression(PyDictLiteralExpression node) {\n      if (node.getElements().length != 0){\n        final Map<String, PyElement> map = new HashMap<String, PyElement>();\n        for (PyExpression exp : node.getElements()) {\n          final PyExpression key = ((PyKeyValueExpression)exp).getKey();\n          if (key instanceof PyNumericLiteralExpression\n                  || key instanceof PyStringLiteralExpression || key instanceof PyReferenceExpression) {\n            if (map.keySet().contains(key.getText())) {\n              registerProblem(key, \"Dictionary contains duplicate keys \" + key.getText());\n              registerProblem(map.get(key.getText()), \"Dictionary contains duplicate keys \" + key.getText());\n            }\n            map.put(key.getText(), key);\n          }\n        }\n      }\n    }","commit_id":"e2022325dc7136aa3eef8f9168bb6d313b90d57c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private PsiElement getKey(PyElement argument) {\n      if (argument instanceof PyParenthesizedExpression) {\n        PyExpression expr = ((PyParenthesizedExpression)argument).getContainedExpression();\n        if (expr instanceof PyTupleExpression) {\n          PyElement key = ((PyTupleExpression)expr).getElements()[0];\n          return key;\n        }\n      }\n      if (argument instanceof PyKeywordArgument) {\n        ASTNode keyWord = ((PyKeywordArgument)argument).getKeywordNode();\n        if (keyWord != null) return keyWord.getPsi();\n      }\n      return null;\n    }","id":87796,"modified_method":"@Nullable\n    private static PsiElement getKey(final PyElement argument) {\n      if (argument instanceof PyParenthesizedExpression) {\n        final PyExpression expr = ((PyParenthesizedExpression)argument).getContainedExpression();\n        if (expr instanceof PyTupleExpression) {\n          return ((PyTupleExpression)expr).getElements()[0];\n        }\n      }\n      if (argument instanceof PyKeywordArgument) {\n        ASTNode keyWord = ((PyKeywordArgument)argument).getKeywordNode();\n        if (keyWord != null) return keyWord.getPsi();\n      }\n      return null;\n    }","commit_id":"e2022325dc7136aa3eef8f9168bb6d313b90d57c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateSnmpDataForInterface(OnmsIpInterface ipIf) {\n    \tif (m_collector == null || !m_collector.hasIpAddrTable() || !m_collector.hasIfTable()) return;\n\n    \tString ipAddr = ipIf.getIpAddress();\n    \tlog().debug(\"Creating SNMP info for interface \"+ipAddr);\n\n    \tInetAddress inetAddr = ipIf.getInetAddress();\n\n    \tint ifIndex = m_collector.getIfIndex(inetAddr);\n    \tif (ifIndex == -1) return;\n\n    \tOnmsSnmpInterface snmpIf = new OnmsSnmpInterface(ipAddr, new Integer(ifIndex), m_node);\n    \tsnmpIf.setIfAlias(m_collector.getIfAlias(ifIndex));\n    \tsnmpIf.setIfName(m_collector.getIfName(ifIndex));\n    \tsnmpIf.setIfType(getIfType(ifIndex));\n    \tsnmpIf.setNetMask(getNetMask(ifIndex));\n    \tsnmpIf.setIfAdminStatus(getAdminStatus(ifIndex));\n    \tsnmpIf.setIfDescr(m_collector.getIfDescr(ifIndex));\n    \tsnmpIf.setIfSpeed(m_collector.getIfSpeed(ifIndex));\n    \tsnmpIf.setPhysAddr(m_collector.getPhysAddr(ifIndex));\n    \t\n    \tipIf.setSnmpInterface(snmpIf);\n\n    \t//FIXME: Improve OpenNMS to provide these values\n    \t// ifOperStatus\n\n\t}","id":87797,"modified_method":"private void updateSnmpDataForInterface(OnmsIpInterface ipIf) {\n    \tif (m_collector == null || !m_collector.hasIpAddrTable() || !m_collector.hasIfTable()) return;\n\n    \tString ipAddr = ipIf.getIpAddress();\n    \tlog().debug(\"Creating SNMP info for interface \"+ipAddr);\n\n    \tInetAddress inetAddr = ipIf.getInetAddress();\n\n    \tint ifIndex = m_collector.getIfIndex(inetAddr);\n    \tif (ifIndex == -1) return;\n\n        // first look to see if an snmpIf was created already\n        OnmsSnmpInterface snmpIf = m_node.getSnmpInterfaceWithIfIndex(ifIndex);\n        \n        if (snmpIf == null) {\n            // if not then create one\n            snmpIf = new OnmsSnmpInterface(ipAddr, new Integer(ifIndex), m_node);\n            snmpIf.setIfAlias(m_collector.getIfAlias(ifIndex));\n            snmpIf.setIfName(m_collector.getIfName(ifIndex));\n            snmpIf.setIfType(getIfType(ifIndex));\n            snmpIf.setNetMask(getNetMask(ifIndex));\n            snmpIf.setIfAdminStatus(getAdminStatus(ifIndex));\n            snmpIf.setIfDescr(m_collector.getIfDescr(ifIndex));\n            snmpIf.setIfSpeed(m_collector.getIfSpeed(ifIndex));\n            snmpIf.setPhysAddr(m_collector.getPhysAddr(ifIndex));\n        }\n        \n        if (ipIf.getIsSnmpPrimary() == CollectionType.PRIMARY) {\n            // make sure the snmpIf has the ipAddr of the primary interface\n            snmpIf.setIpAddress(ipAddr);\n        }\n    \t\n    \tipIf.setSnmpInterface(snmpIf);\n\n    \t//FIXME: Improve OpenNMS to provide these values\n    \t// ifOperStatus\n\n\t}","commit_id":"6d6d7720c52d16528c7e902132c0eeab5bcc5ac1","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void updateSnmpDataForInterface(OnmsIpInterface ipIf) {\n    \tif (m_collector == null || !m_collector.hasIpAddrTable() || !m_collector.hasIfTable()) return;\n\n    \tString ipAddr = ipIf.getIpAddress();\n    \tlog().debug(\"Creating SNMP info for interface \"+ipAddr);\n\n    \tInetAddress inetAddr = ipIf.getInetAddress();\n\n    \tint ifIndex = m_collector.getIfIndex(inetAddr);\n    \tif (ifIndex == -1) return;\n\n    \tOnmsSnmpInterface snmpIf = new OnmsSnmpInterface(ipAddr, new Integer(ifIndex), m_node);\n    \tsnmpIf.setIfAlias(m_collector.getIfAlias(ifIndex));\n    \tsnmpIf.setIfName(m_collector.getIfName(ifIndex));\n    \tsnmpIf.setIfType(getIfType(ifIndex));\n    \tsnmpIf.setNetMask(getNetMask(ifIndex));\n    \tsnmpIf.setIfAdminStatus(getAdminStatus(ifIndex));\n    \tsnmpIf.setIfDescr(m_collector.getIfDescr(ifIndex));\n    \tsnmpIf.setIfSpeed(m_collector.getIfSpeed(ifIndex));\n    \tsnmpIf.setPhysAddr(m_collector.getPhysAddr(ifIndex));\n    \t\n    \tipIf.setSnmpInterface(snmpIf);\n\n    \t//FIXME: Improve OpenNMS to provide these values\n    \t// ifOperStatus\n\n\t}","id":87798,"modified_method":"private void updateSnmpDataForInterface(OnmsIpInterface ipIf) {\n    \tif (m_collector == null || !m_collector.hasIpAddrTable() || !m_collector.hasIfTable()) return;\n\n    \tString ipAddr = ipIf.getIpAddress();\n    \tlog().debug(\"Creating SNMP info for interface \"+ipAddr);\n\n    \tInetAddress inetAddr = ipIf.getInetAddress();\n\n    \tint ifIndex = m_collector.getIfIndex(inetAddr);\n    \tif (ifIndex == -1) return;\n\n        // first look to see if an snmpIf was created already\n        OnmsSnmpInterface snmpIf = m_node.getSnmpInterfaceWithIfIndex(ifIndex);\n        \n        if (snmpIf == null) {\n            // if not then create one\n            snmpIf = new OnmsSnmpInterface(ipAddr, new Integer(ifIndex), m_node);\n            snmpIf.setIfAlias(m_collector.getIfAlias(ifIndex));\n            snmpIf.setIfName(m_collector.getIfName(ifIndex));\n            snmpIf.setIfType(getIfType(ifIndex));\n            snmpIf.setNetMask(getNetMask(ifIndex));\n            snmpIf.setIfAdminStatus(getAdminStatus(ifIndex));\n            snmpIf.setIfDescr(m_collector.getIfDescr(ifIndex));\n            snmpIf.setIfSpeed(m_collector.getIfSpeed(ifIndex));\n            snmpIf.setPhysAddr(m_collector.getPhysAddr(ifIndex));\n        }\n        \n        if (ipIf.getIsSnmpPrimary() == CollectionType.PRIMARY) {\n            // make sure the snmpIf has the ipAddr of the primary interface\n            snmpIf.setIpAddress(ipAddr);\n        }\n    \t\n    \tipIf.setSnmpInterface(snmpIf);\n\n    \t//FIXME: Improve OpenNMS to provide these values\n    \t// ifOperStatus\n\n\t}","commit_id":"d1622ee7dad2ef980bb5983344a4138d28ef0703","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsIpInterface createInterfaceFromRow() {\n\n            final Integer ifIndex = getIfIndex();\n            final String ipAddr = getIpAddress();\n            final Integer type = getType();\n            final InetAddress netMask = getNetMask();\n\n            LogUtils.debugf(this, \"createInterfaceFromRow: ifIndex = %s, ipAddress = %s, type = %s, netmask = %s\", ifIndex, ipAddr, type, netMask);\n\n            if (type != IP_ADDRESS_TYPE_UNICAST || ipAddr == null) {\n                return null;\n            }\n\n            final OnmsSnmpInterface snmpIface = new OnmsSnmpInterface(null, ifIndex);\n            snmpIface.setNetMask(netMask);\n            snmpIface.setCollectionEnabled(true);\n\n            final OnmsIpInterface iface = new OnmsIpInterface(ipAddr, null);\n            iface.setSnmpInterface(snmpIface);\n\n            iface.setIfIndex(ifIndex);\n            final String hostName = normalize(ipAddr);\n            LogUtils.debugf(this, \"setIpHostName: %s\", hostName);\n            iface.setIpHostName(hostName == null? ipAddr : hostName);\n\n            return iface;\n        }","id":87799,"modified_method":"public OnmsIpInterface createInterfaceFromRow() {\n\n            final Integer ifIndex = getIfIndex();\n            final String ipAddr = getIpAddress();\n            final Integer type = getType();\n            final InetAddress netMask = getNetMask();\n\n            LogUtils.debugf(this, \"createInterfaceFromRow: ifIndex = %s, ipAddress = %s, type = %s, netmask = %s\", ifIndex, ipAddr, type, netMask);\n\n            if (type != IP_ADDRESS_TYPE_UNICAST || ipAddr == null) {\n                return null;\n            }\n\n            final InetAddress inetAddress = InetAddressUtils.addr(ipAddr);\n            final OnmsIpInterface iface = new OnmsIpInterface(inetAddress, null);\n\n            if (ifIndex != null) {\n                final OnmsSnmpInterface snmpIface = new OnmsSnmpInterface(null, ifIndex);\n                snmpIface.setNetMask(netMask);\n                snmpIface.setCollectionEnabled(true);\n                iface.setSnmpInterface(snmpIface);\n                iface.setIfIndex(ifIndex);\n            }\n\n            String hostName = null;\n            if (inetAddress != null) hostName = inetAddress.getHostName();\n            if (hostName == null) hostName = InetAddressUtils.normalize(ipAddr);\n            iface.setIpHostName(hostName == null? ipAddr : hostName);\n\n            return iface;\n        }","commit_id":"3ffb3c522e1355f549f7cfb6bcb9c438def574fb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public OnmsIpInterface createInterfaceFromRow() {\n            \n            String ipAddr = getIpAddress();\n            InetAddress netMask = getNetMask();\n            Integer ifIndex = getIfIndex();\n\n            OnmsSnmpInterface snmpIface = new OnmsSnmpInterface(null, ifIndex);\n            snmpIface.setNetMask(netMask);\n            snmpIface.setCollectionEnabled(true);\n\n            final InetAddress inetAddress = InetAddressUtils.addr(ipAddr);\n            OnmsIpInterface iface = new OnmsIpInterface(inetAddress, null);\n            iface.setSnmpInterface(snmpIface);\n            \n            iface.setIfIndex(ifIndex);\n            String hostName = null;\n            if (inetAddress != null) hostName = inetAddress.getHostName();\n            if (hostName == null) hostName = InetAddressUtils.normalize(ipAddr);\n            iface.setIpHostName(hostName == null? ipAddr : hostName);\n            \n            return iface;\n        }","id":87800,"modified_method":"public OnmsIpInterface createInterfaceFromRow() {\n            \n            final Integer ifIndex = getIfIndex();\n            final String ipAddr = getIpAddress();\n            final InetAddress netMask = getNetMask();\n\n            LogUtils.debugf(this, \"createInterfaceFromRow: ifIndex = %s, ipAddress = %s, netmask = %s\", ifIndex, ipAddr, netMask);\n\n            if (ipAddr == null) {\n                return null;\n            }\n\n            final InetAddress inetAddress = InetAddressUtils.addr(ipAddr);\n            final OnmsIpInterface iface = new OnmsIpInterface(inetAddress, null);\n\n            if (ifIndex != null) {\n                final OnmsSnmpInterface snmpIface = new OnmsSnmpInterface(null, ifIndex);\n                snmpIface.setNetMask(netMask);\n                snmpIface.setCollectionEnabled(true);\n                iface.setSnmpInterface(snmpIface);\n                iface.setIfIndex(ifIndex);\n            }\n\n            String hostName = null;\n            if (inetAddress != null) hostName = inetAddress.getHostName();\n            if (hostName == null) hostName = InetAddressUtils.normalize(ipAddr);\n            iface.setIpHostName(hostName == null? ipAddr : hostName);\n            \n            return iface;\n        }","commit_id":"3ffb3c522e1355f549f7cfb6bcb9c438def574fb","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static void addPathToActionsTree(JTree tree, ActionUrl url) {\n    final TreePath treePath = CustomizationUtil.getTreePath(tree, url);\n    if (treePath == null) return;\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n    if (url.getComponent() instanceof Group){\n      node.insert(ActionsTreeUtil.createNode((Group)url.getComponent()), url.getAbsolutePosition());\n    } else {\n      node.insert(new DefaultMutableTreeNode(url.getComponent()), url.getAbsolutePosition());\n    }\n  }","id":87801,"modified_method":"private static void addPathToActionsTree(JTree tree, ActionUrl url) {\n    final TreePath treePath = CustomizationUtil.getTreePath(tree, url);\n    if (treePath == null) return;\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n    final int absolutePosition = url.getAbsolutePosition();\n    if (node.getChildCount() > absolutePosition && absolutePosition >= 0) {\n      if (url.getComponent() instanceof Group){\n        node.insert(ActionsTreeUtil.createNode((Group)url.getComponent()), absolutePosition);\n      } else {\n        node.insert(new DefaultMutableTreeNode(url.getComponent()), absolutePosition);\n      }\n    }\n  }","commit_id":"fcf9e3b28b13ee2b9abe890c9c270adc541e4b16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void removePathFromActionsTree(JTree tree, ActionUrl url) {\n    if (url.myComponent == null) return;\n    final TreePath treePath = CustomizationUtil.getTreePath(tree, url);\n    if (treePath == null) return;\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n    if (node.getChildCount() > url.getAbsolutePosition()) {\n      DefaultMutableTreeNode child = (DefaultMutableTreeNode)node.getChildAt(url.getAbsolutePosition());\n      if (child.getUserObject().equals(url.getComponent())) {\n        node.remove(child);\n      }\n    }\n  }","id":87802,"modified_method":"private static void removePathFromActionsTree(JTree tree, ActionUrl url) {\n    if (url.myComponent == null) return;\n    final TreePath treePath = CustomizationUtil.getTreePath(tree, url);\n    if (treePath == null) return;\n    DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n    final int absolutePosition = url.getAbsolutePosition();\n    if (node.getChildCount() > absolutePosition && absolutePosition >= 0) {\n      DefaultMutableTreeNode child = (DefaultMutableTreeNode)node.getChildAt(absolutePosition);\n      if (child.getUserObject().equals(url.getComponent())) {\n        node.remove(child);\n      }\n    }\n  }","commit_id":"fcf9e3b28b13ee2b9abe890c9c270adc541e4b16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CustomizableActionsPanel() {\n    myList.setModel(myCustomizationSchemas);\n    myList.setPrototypeCellValue(new CustomActionsSchema(\"xxxxxxxxxxxxx\", \"\"));\n    fillSchemaList();\n    myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myList.setCellRenderer(new ColoredListCellRenderer() {\n      protected void customizeCellRenderer(\n        JList list,\n        Object value,\n        int index,\n        boolean selected,\n        boolean hasFocus\n      ) {\n        if (value instanceof CustomActionsSchema) {\n          final CustomActionsSchema schema = ((CustomActionsSchema)value);\n          append(schema.getName(),\n                 schema.getName().equals(CustomizableActionsSchemas.DEFAULT_NAME)\n                 ? SimpleTextAttributes.GRAYED_ATTRIBUTES\n                 : SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n      }\n    });\n    Group rootGroup = new Group(\"root\", null, null);\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode(rootGroup);\n    DefaultTreeModel model = new DefaultTreeModel(root);\n    myActionsTree.setModel(model);\n\n    myActionsTree.setRootVisible(false);\n    myActionsTree.setShowsRootHandles(true);\n    myActionsTree.putClientProperty(\"JTree.lineStyle\", \"Angled\");\n    myActionsTree.setCellRenderer(new MyTreeCellRenderer());\n\n    setButtonsDisabled();\n    final ActionManager actionManager = ActionManager.getInstance();\n    myActionsTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        final TreePath[] selectionPaths = myActionsTree.getSelectionPaths();\n        final boolean isSingleSelection = selectionPaths != null && selectionPaths.length == 1;\n        myAddActionButton.setEnabled(isSingleSelection);\n        if (isSingleSelection) {\n          final DefaultMutableTreeNode node = ((DefaultMutableTreeNode)selectionPaths[0].getLastPathComponent());\n          String actionId = getActionId(node);\n          if (actionId != null) {\n            final AnAction action = actionManager.getAction(actionId);\n            myEditIconButton.setEnabled(action != null &&\n                                        (!action.isDefaultIcon() ||\n                                         (action.getTemplatePresentation() != null && action.getTemplatePresentation().getIcon() == null)));\n          }\n          else {\n            myEditIconButton.setEnabled(false);\n          }\n        }\n        else {\n          myEditIconButton.setEnabled(false);\n        }\n        myAddSeparatorButton.setEnabled(isSingleSelection);\n        myRemoveActionButton.setEnabled(selectionPaths != null);\n        if (selectionPaths != null) {\n          for (int i = 0; i < selectionPaths.length; i++) {\n            TreePath selectionPath = selectionPaths[i];\n            if ((selectionPath.getPath() != null && selectionPath.getPath().length <= 2) ||\n                (mySelectedSchema == null || mySelectedSchema.getName().equals(CustomizableActionsSchemas.DEFAULT_NAME))) {\n              setButtonsDisabled();\n              return;\n            }\n          }\n        }\n        myMoveActionUpButton.setEnabled(isMoveSupported(myActionsTree, -1));\n        myMoveActionDownButton.setEnabled(isMoveSupported(myActionsTree, 1));\n      }\n    });\n    final CustomizableActionsSchemas schemas = CustomizableActionsSchemas.getInstance();\n    myAddActionButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath selectionPath = myActionsTree.getLeadSelectionPath();\n        if (selectionPath != null) {\n          DefaultMutableTreeNode node = (DefaultMutableTreeNode)selectionPath.getLastPathComponent();\n          final FindAvailableActionsDialog dlg = new FindAvailableActionsDialog();\n          dlg.show();\n          if (dlg.isOK()) {\n            final Set<Object> toAdd = dlg.getTreeSelectedActionIds();\n            for (Iterator<Object> iterator = toAdd.iterator(); iterator.hasNext();) {\n              final Object o = iterator.next();\n              final ActionUrl url = new ActionUrl(ActionUrl.getGroupPath(new TreePath(node.getPath())), o, ActionUrl.ADDED,\n                                                  node.getParent().getIndex(node) + 1);\n              mySelectedSchema.addAction(url);\n              ActionUrl.changePathInActionsTree(myActionsTree, url);\n              if (o instanceof String) {\n                DefaultMutableTreeNode current = new DefaultMutableTreeNode(url.getComponent());\n                current.setParent((DefaultMutableTreeNode)node.getParent());\n                editToolbarIcon((String)o, current, schemas);\n              }\n            }\n            ((DefaultTreeModel)myActionsTree.getModel()).reload();\n          }\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n    myEditIconButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath selectionPath = myActionsTree.getLeadSelectionPath();\n        if (selectionPath != null) {\n          EditIconDialog dlg = new EditIconDialog((DefaultMutableTreeNode)selectionPath.getLastPathComponent());\n          dlg.show();\n          if (dlg.isOK()) {\n            myActionsTree.repaint();\n          }\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n    myAddSeparatorButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath selectionPath = myActionsTree.getLeadSelectionPath();\n        if (selectionPath != null) {\n          DefaultMutableTreeNode node = (DefaultMutableTreeNode)selectionPath.getLastPathComponent();\n          final ActionUrl url = new ActionUrl(ActionUrl.getGroupPath(selectionPath), Separator.getInstance(), ActionUrl.ADDED,\n                                              node.getParent().getIndex(node) + 1);\n          ActionUrl.changePathInActionsTree(myActionsTree, url);\n          mySelectedSchema.addAction(url);\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n\n    myRemoveActionButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath[] selectionPath = myActionsTree.getSelectionPaths();\n        if (selectionPath != null) {\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath treePath = selectionPath[i];\n            final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.DELETED);\n            ActionUrl.changePathInActionsTree(myActionsTree, url);\n            mySelectedSchema.addAction(url);\n          }\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n    myMoveActionUpButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath[] selectionPath = myActionsTree.getSelectionPaths();\n        if (selectionPath != null) {\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath treePath = selectionPath[i];\n            final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.MOVE);\n            final int absolutePosition = url.getAbsolutePosition();\n            url.setInitialPosition(absolutePosition);\n            url.setAbsolutePosition(absolutePosition - 1);\n            ActionUrl.changePathInActionsTree(myActionsTree, url);\n            mySelectedSchema.addAction(url);\n          }\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n          TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath path = selectionPath[i];\n            myActionsTree.addSelectionPath(path);\n          }\n        }\n      }\n    });\n\n    myMoveActionDownButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath[] selectionPath = myActionsTree.getSelectionPaths();\n        if (selectionPath != null) {\n          for (int i = selectionPath.length - 1; i >= 0; i--) {\n            TreePath treePath = selectionPath[i];\n            final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.MOVE);\n            final int absolutePosition = url.getAbsolutePosition();\n            url.setInitialPosition(absolutePosition);\n            url.setAbsolutePosition(absolutePosition + 1);\n            ActionUrl.changePathInActionsTree(myActionsTree, url);\n            mySelectedSchema.addAction(url);\n          }\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n          TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath path = selectionPath[i];\n            myActionsTree.addSelectionPath(path);\n          }\n        }\n      }\n    });\n\n    myDescription.setText(mySelectedSchema != null ? mySelectedSchema.getDescription() : \"\");\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n    ReorderableListController<CustomActionsSchema> controller = ReorderableListController.create(myList, group);\n    controller.addAddAction(\"Add customization schema\", new Factory<CustomActionsSchema>() {\n      public CustomActionsSchema create() {\n        return new CustomActionsSchema(createUniqueName(), \"\");\n      }\n    }, true);\n\n    final ReorderableListController<CustomActionsSchema>.RemoveActionDescription removeActionDescription = controller.addRemoveAction(\"Remove customization schema\");\n    removeActionDescription.setEnableCondition(new Condition<CustomActionsSchema>() {\n      public boolean value(final CustomActionsSchema schema) {\n        if (schema.getName().equals(\"default\")) {\n          return false;\n        }\n        return true;\n      }\n    });\n    controller.addCopyAction(\"Copy schema\", new Convertor<CustomActionsSchema, CustomActionsSchema>() {\n      public CustomActionsSchema convert(final CustomActionsSchema o) {\n        final CustomActionsSchema customActionsSchema = o.copyFrom();\n        customActionsSchema.setName(createUniqueName());\n        return customActionsSchema;\n      }\n    }, new Condition<CustomActionsSchema>() {\n      public boolean value(final CustomActionsSchema object) {\n        return true;\n      }\n    });\n    myListPane.setLayout(new BorderLayout());\n    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    myListPane.add(toolbar.getComponent(), BorderLayout.NORTH);\n    myListPane.add(ScrollPaneFactory.createScrollPane(myList), BorderLayout.CENTER);\n    myList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        final CustomActionsSchema selectedValue = (CustomActionsSchema)myList.getSelectedValue();\n        if (selectedValue != null) {\n          mySelectedSchema = selectedValue;\n          setNameAndDescription(mySelectedSchema != null && !mySelectedSchema.getName().equals(CustomizableActionsSchemas.DEFAULT_NAME),\n                                mySelectedSchema.getName(), mySelectedSchema.getDescription());\n          patchActionsTreeCorrespondingToSchema((DefaultMutableTreeNode)myActionsTree.getModel().getRoot());\n        }\n        else {\n          mySelectedSchema = null;\n          ((DefaultMutableTreeNode)myActionsTree.getModel().getRoot()).removeAllChildren();\n        }\n      }\n    });\n    myList.getModel().addListDataListener(new ListDataListener() {\n      public void contentsChanged(ListDataEvent e) {\n      }\n\n      public void intervalAdded(ListDataEvent e) {\n      }\n\n      public void intervalRemoved(ListDataEvent e) {\n        if (myList.getModel().getSize() == 0) {\n          mySelectedSchema = null;\n          setNameAndDescription(false, \"\", \"\");\n          ((DefaultMutableTreeNode)myActionsTree.getModel().getRoot()).removeAllChildren();\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n        }\n      }\n    });\n\n    myDescription.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        if (mySelectedSchema != null) {\n          mySelectedSchema.setDescription(myDescription.getText());\n        }\n      }\n    });\n\n    myName.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        if (mySelectedSchema != null) {\n          mySelectedSchema.setName(myName.getText());\n          myList.repaint();\n        }\n      }\n    });\n\n\n    patchActionsTreeCorrespondingToSchema(root);\n  }","id":87803,"modified_method":"public CustomizableActionsPanel() {\n    myList.setModel(myCustomizationSchemas);\n    myList.setPrototypeCellValue(new CustomActionsSchema(\"xxxxxxxxxxxxx\", \"\"));\n    fillSchemaList();\n    myList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myList.setCellRenderer(new ColoredListCellRenderer() {\n      protected void customizeCellRenderer(\n        JList list,\n        Object value,\n        int index,\n        boolean selected,\n        boolean hasFocus\n      ) {\n        if (value instanceof CustomActionsSchema) {\n          final CustomActionsSchema schema = ((CustomActionsSchema)value);\n          append(schema.getName(),\n                 schema.getName().equals(CustomizableActionsSchemas.DEFAULT_NAME)\n                 ? SimpleTextAttributes.GRAYED_ATTRIBUTES\n                 : SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n      }\n    });\n    Group rootGroup = new Group(\"root\", null, null);\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode(rootGroup);\n    DefaultTreeModel model = new DefaultTreeModel(root);\n    myActionsTree.setModel(model);\n\n    myActionsTree.setRootVisible(false);\n    myActionsTree.setShowsRootHandles(true);\n    myActionsTree.putClientProperty(\"JTree.lineStyle\", \"Angled\");\n    myActionsTree.setCellRenderer(new MyTreeCellRenderer());\n\n    setButtonsDisabled();\n    final ActionManager actionManager = ActionManager.getInstance();\n    myActionsTree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {\n      public void valueChanged(TreeSelectionEvent e) {\n        final TreePath[] selectionPaths = myActionsTree.getSelectionPaths();\n        final boolean isSingleSelection = selectionPaths != null && selectionPaths.length == 1;\n        myAddActionButton.setEnabled(isSingleSelection);\n        if (isSingleSelection) {\n          final DefaultMutableTreeNode node = ((DefaultMutableTreeNode)selectionPaths[0].getLastPathComponent());\n          String actionId = getActionId(node);\n          if (actionId != null) {\n            final AnAction action = actionManager.getAction(actionId);\n            myEditIconButton.setEnabled(action != null &&\n                                        (!action.isDefaultIcon() ||\n                                         (action.getTemplatePresentation() != null && action.getTemplatePresentation().getIcon() == null)));\n          }\n          else {\n            myEditIconButton.setEnabled(false);\n          }\n        }\n        else {\n          myEditIconButton.setEnabled(false);\n        }\n        myAddSeparatorButton.setEnabled(isSingleSelection);\n        myRemoveActionButton.setEnabled(selectionPaths != null);\n        if (selectionPaths != null) {\n          for (int i = 0; i < selectionPaths.length; i++) {\n            TreePath selectionPath = selectionPaths[i];\n            if ((selectionPath.getPath() != null && selectionPath.getPath().length <= 2) ||\n                (mySelectedSchema == null || mySelectedSchema.getName().equals(CustomizableActionsSchemas.DEFAULT_NAME))) {\n              setButtonsDisabled();\n              return;\n            }\n          }\n        }\n        myMoveActionUpButton.setEnabled(isMoveSupported(myActionsTree, -1));\n        myMoveActionDownButton.setEnabled(isMoveSupported(myActionsTree, 1));\n      }\n    });\n    final CustomizableActionsSchemas schemas = CustomizableActionsSchemas.getInstance();\n    myAddActionButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath selectionPath = myActionsTree.getLeadSelectionPath();\n        if (selectionPath != null) {\n          DefaultMutableTreeNode node = (DefaultMutableTreeNode)selectionPath.getLastPathComponent();\n          final FindAvailableActionsDialog dlg = new FindAvailableActionsDialog();\n          dlg.show();\n          if (dlg.isOK()) {\n            final Set<Object> toAdd = dlg.getTreeSelectedActionIds();\n            for (Iterator<Object> iterator = toAdd.iterator(); iterator.hasNext();) {\n              final Object o = iterator.next();\n              final ActionUrl url = new ActionUrl(ActionUrl.getGroupPath(new TreePath(node.getPath())), o, ActionUrl.ADDED,\n                                                  node.getParent().getIndex(node) + 1);\n              mySelectedSchema.addAction(url);\n              ActionUrl.changePathInActionsTree(myActionsTree, url);\n              if (o instanceof String) {\n                DefaultMutableTreeNode current = new DefaultMutableTreeNode(url.getComponent());\n                current.setParent((DefaultMutableTreeNode)node.getParent());\n                editToolbarIcon((String)o, current, schemas);\n              }\n            }\n            ((DefaultTreeModel)myActionsTree.getModel()).reload();\n          }\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n    myEditIconButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath selectionPath = myActionsTree.getLeadSelectionPath();\n        if (selectionPath != null) {\n          EditIconDialog dlg = new EditIconDialog((DefaultMutableTreeNode)selectionPath.getLastPathComponent());\n          dlg.show();\n          if (dlg.isOK()) {\n            myActionsTree.repaint();\n          }\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n    myAddSeparatorButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath selectionPath = myActionsTree.getLeadSelectionPath();\n        if (selectionPath != null) {\n          DefaultMutableTreeNode node = (DefaultMutableTreeNode)selectionPath.getLastPathComponent();\n          final ActionUrl url = new ActionUrl(ActionUrl.getGroupPath(selectionPath), Separator.getInstance(), ActionUrl.ADDED,\n                                              node.getParent().getIndex(node) + 1);\n          ActionUrl.changePathInActionsTree(myActionsTree, url);\n          mySelectedSchema.addAction(url);\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n\n    myRemoveActionButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath[] selectionPath = myActionsTree.getSelectionPaths();\n        if (selectionPath != null) {\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath treePath = selectionPath[i];\n            final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.DELETED);\n            ActionUrl.changePathInActionsTree(myActionsTree, url);\n            mySelectedSchema.addAction(url);\n          }\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n        }\n        TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n      }\n    });\n\n    myMoveActionUpButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath[] selectionPath = myActionsTree.getSelectionPaths();\n        if (selectionPath != null) {\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath treePath = selectionPath[i];\n            final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.MOVE);\n            final int absolutePosition = url.getAbsolutePosition();\n            url.setInitialPosition(absolutePosition);\n            url.setAbsolutePosition(absolutePosition - 1);\n            ActionUrl.changePathInActionsTree(myActionsTree, url);\n            mySelectedSchema.addAction(url);\n          }\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n          TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath path = selectionPath[i];\n            myActionsTree.addSelectionPath(path);\n          }\n        }\n      }\n    });\n\n    myMoveActionDownButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        final java.util.List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(myActionsTree);\n        final TreePath[] selectionPath = myActionsTree.getSelectionPaths();\n        if (selectionPath != null) {\n          for (int i = selectionPath.length - 1; i >= 0; i--) {\n            TreePath treePath = selectionPath[i];\n            final ActionUrl url = CustomizationUtil.getActionUrl(treePath, ActionUrl.MOVE);\n            final int absolutePosition = url.getAbsolutePosition();\n            url.setInitialPosition(absolutePosition);\n            url.setAbsolutePosition(absolutePosition + 1);\n            ActionUrl.changePathInActionsTree(myActionsTree, url);\n            mySelectedSchema.addAction(url);\n          }\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n          TreeUtil.restoreExpandedPaths(myActionsTree, expandedPaths);\n          for (int i = 0; i < selectionPath.length; i++) {\n            TreePath path = selectionPath[i];\n            myActionsTree.addSelectionPath(path);\n          }\n        }\n      }\n    });\n\n    myDescription.setText(mySelectedSchema != null ? mySelectedSchema.getDescription() : \"\");\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n    ReorderableListController<CustomActionsSchema> controller = ReorderableListController.create(myList, group);\n    controller.addAddAction(\"Add customization schema\", new Factory<CustomActionsSchema>() {\n      public CustomActionsSchema create() {\n        return new CustomActionsSchema(createUniqueName(), \"\");\n      }\n    }, true);\n\n    final ReorderableListController<CustomActionsSchema>.RemoveActionDescription removeActionDescription = controller.addRemoveAction(\"Remove customization schema\");\n    removeActionDescription.setEnableCondition(new Condition<CustomActionsSchema>() {\n      public boolean value(final CustomActionsSchema schema) {\n        if (schema.getName().equals(\"default\")) {\n          return false;\n        }\n        return true;\n      }\n    });\n    controller.addCopyAction(\"Copy schema\", new Convertor<CustomActionsSchema, CustomActionsSchema>() {\n      public CustomActionsSchema convert(final CustomActionsSchema o) {\n        final CustomActionsSchema customActionsSchema = o.copyFrom();\n        customActionsSchema.setName(createUniqueName());\n        return customActionsSchema;\n      }\n    }, new Condition<CustomActionsSchema>() {\n      public boolean value(final CustomActionsSchema object) {\n        return true;\n      }\n    });\n    myListPane.setLayout(new BorderLayout());\n    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    myListPane.add(toolbar.getComponent(), BorderLayout.NORTH);\n    myListPane.add(ScrollPaneFactory.createScrollPane(myList), BorderLayout.CENTER);\n    myList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        final CustomActionsSchema selectedValue = (CustomActionsSchema)myList.getSelectedValue();\n        if (selectedValue != null) {\n          mySelectedSchema = selectedValue;\n          setNameAndDescription(!mySelectedSchema.getName().equals(CustomizableActionsSchemas.DEFAULT_NAME),\n                                mySelectedSchema.getName(), mySelectedSchema.getDescription());\n          patchActionsTreeCorrespondingToSchema((DefaultMutableTreeNode)myActionsTree.getModel().getRoot());\n        }\n        else {\n          mySelectedSchema = null;\n          ((DefaultMutableTreeNode)myActionsTree.getModel().getRoot()).removeAllChildren();\n        }\n      }\n    });\n    myList.getModel().addListDataListener(new ListDataListener() {\n      public void contentsChanged(ListDataEvent e) {\n      }\n\n      public void intervalAdded(ListDataEvent e) {\n      }\n\n      public void intervalRemoved(ListDataEvent e) {\n        if (myList.getModel().getSize() == 0) {\n          mySelectedSchema = null;\n          setNameAndDescription(false, \"\", \"\");\n          ((DefaultMutableTreeNode)myActionsTree.getModel().getRoot()).removeAllChildren();\n          ((DefaultTreeModel)myActionsTree.getModel()).reload();\n        }\n      }\n    });\n\n    myDescription.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        if (mySelectedSchema != null) {\n          mySelectedSchema.setDescription(myDescription.getText());\n        }\n      }\n    });\n\n    myName.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        if (mySelectedSchema != null) {\n          mySelectedSchema.setName(myName.getText());\n          myList.repaint();\n        }\n      }\n    });\n\n\n    patchActionsTreeCorrespondingToSchema(root);\n  }","commit_id":"fcf9e3b28b13ee2b9abe890c9c270adc541e4b16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\r\n        Set<UUID> possibleTargets = new HashSet<UUID>();\r\n        for (StackObject stackObject :  game.getStack()) {\r\n            if (stackObject.getStackAbility() != null && (stackObject.getStackAbility() instanceof ActivatedAbility || stackObject.getStackAbility() instanceof TriggeredAbility) && game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getStackAbility().getControllerId())) {\r\n                possibleTargets.add(stackObject.getStackAbility().getId());\r\n            }\r\n        }\r\n        return possibleTargets;\r\n    }","id":87804,"modified_method":"@Override\r\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\r\n        Set<UUID> possibleTargets = new HashSet<>();\r\n        for (StackObject stackObject :  game.getStack()) {\r\n            if (stackObject.getStackAbility() != null && (stackObject.getStackAbility() instanceof ActivatedAbility || stackObject.getStackAbility() instanceof TriggeredAbility) && game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getStackAbility().getControllerId())) {\r\n                possibleTargets.add(stackObject.getStackAbility().getId());\r\n            }\r\n        }\r\n        return possibleTargets;\r\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"public Set<UUID> possibleTargets(UUID sourceControllerId, Cards cards, Game game) {\n        Set<UUID> possibleTargets = new HashSet<UUID>();\n        for (Card card: cards.getCards(filter, game)) {\n            possibleTargets.add(card.getId());\n        }\n        return possibleTargets;\n    }","id":87805,"modified_method":"public Set<UUID> possibleTargets(UUID sourceControllerId, Cards cards, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (Card card: cards.getCards(filter, game)) {\n            possibleTargets.add(card.getId());\n        }\n        return possibleTargets;\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"/**\n     * Checks if there are enough {@link Card} that can be chosen.\n     *\n     * @param sourceId - the target event source\n     * @param sourceControllerId - controller of the target event source\n     * @param game\n     * @return - true if enough valid {@link Card} exist\n     */\n    @Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null) {\n                switch (zone) {\n                    case HAND:\n                        if (player.getHand().count(filter, sourceId, sourceControllerId, game) >= this.minNumberOfTargets) {\n                            return true;\n                        }\n                        break;\n                    case GRAVEYARD:\n                        if (player.getGraveyard().count(filter, sourceId, sourceControllerId, game) >= this.minNumberOfTargets) {\n                            return true;\n                        }\n                        break;\n                    case LIBRARY:\n                        if (player.getLibrary().count(filter, game) >= this.minNumberOfTargets) {\n                            return true;\n                        }\n                        break;\n                    case EXILED:\n                        if (game.getExile().getPermanentExile().count(filter, sourceId, sourceControllerId, game) >= this.minNumberOfTargets) {\n                            return true;\n                        }\n                        break;\n                }\n            }\n        }\n        return false;\n    }","id":87806,"modified_method":"/**\n     * Checks if there are enough {@link Card} that can be chosen.\n     *\n     * @param sourceId - the target event source\n     * @param sourceControllerId - controller of the target event source\n     * @param game\n     * @return - true if enough valid {@link Card} exist\n     */\n    @Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        int possibleTargets = 0;\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null) {\n                switch (zone) {\n                    case HAND:\n                        for (Card card : player.getHand().getCards(filter, game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                possibleTargets++;\n                                if (possibleTargets >= this.minNumberOfTargets) {\n                                    return true;\n                                }\n                            }\n                        }\n                        break;\n                    case GRAVEYARD:\n                        for (Card card : player.getGraveyard().getCards(filter, game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                possibleTargets++;\n                                if (possibleTargets >= this.minNumberOfTargets) {\n                                    return true;\n                                }\n                            }\n                        }\n                        break;\n                    case LIBRARY:\n                        for (Card card : player.getLibrary().getUniqueCards(game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                if (filter.match(card, game)) {\n                                    possibleTargets++;\n                                    if (possibleTargets >= this.minNumberOfTargets) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    case EXILED:\n                        for (Card card : game.getExile().getPermanentExile().getCards(game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                if (filter.match(card, player.getId(), game)) {\n                                    possibleTargets++;\n                                    if (possibleTargets >= this.minNumberOfTargets) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        return possibleTargets(sourceControllerId, game);\n    }","id":87807,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (UUID playerId : game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null) {\n                switch (zone) {\n                    case HAND:\n                        for (Card card : player.getHand().getCards(filter, game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                possibleTargets.add(card.getId());\n                            }\n                        }\n                        break;\n                    case GRAVEYARD:\n                        for (Card card : player.getGraveyard().getCards(filter, game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                possibleTargets.add(card.getId());\n                            }\n                        }\n                        break;\n                    case LIBRARY:\n                        for (Card card : player.getLibrary().getUniqueCards(game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                if (filter.match(card, game)) {\n                                    possibleTargets.add(card.getId());\n                                }\n                            }\n                        }\n                        break;\n                    case EXILED:\n                        for (Card card : game.getExile().getPermanentExile().getCards(game)) {\n                            if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                                if (filter.match(card, player.getId(), game)) {\n                                    possibleTargets.add(card.getId());\n                                }\n                            }\n                        }\n                        break;\n                }\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<UUID>();\n        for (UUID playerId : game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null) {\n                switch (zone) {\n                    case HAND:\n                        for (Card card : player.getHand().getCards(filter, game)) {\n                            possibleTargets.add(card.getId());\n                        }\n                        break;\n                    case GRAVEYARD:\n                        for (Card card : player.getGraveyard().getCards(filter, game)) {\n                            possibleTargets.add(card.getId());\n                        }\n                        break;\n                    case LIBRARY:\n                        for (Card card : player.getLibrary().getUniqueCards(game)) {\n                            if (filter.match(card, game)) {\n                                possibleTargets.add(card.getId());\n                            }\n                        }\n                        break;\n                    case EXILED:\n                        for (Card card : game.getExile().getPermanentExile().getUniqueCards(game)) {\n                            if (filter.match(card, player.getId(), game)) {\n                                possibleTargets.add(card.getId());\n                            }\n                        }\n                        break;\n                }\n            }\n        }\n        return possibleTargets;\n    }","id":87808,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        return possibleTargets(null, sourceControllerId, game);\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        if (game.getPlayer(sourceControllerId).getGraveyard().count(filter, sourceId, sourceControllerId, game) >= this.minNumberOfTargets) {\n            return true;\n        }\n        return false;\n    }","id":87809,"modified_method":"@Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        Player player = game.getPlayer(sourceControllerId);\n        if (player != null) {\n            int possibleTargets = 0;\n            for (Card card : player.getGraveyard().getCards(filter, game)) {\n                if (sourceId == null || isNotTarget() || !game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.TARGET, card.getId(), sourceId, sourceControllerId))) {\n                    possibleTargets++;\n                    if (possibleTargets >= this.minNumberOfTargets) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<UUID>();\n        MageObject targetSource = game.getObject(sourceId);\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && player.canBeTargetedBy(targetSource, game) && filter.match(player, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (permanent.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(permanent, sourceId, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","id":87810,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        MageObject targetSource = game.getObject(sourceId);\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && player.canBeTargetedBy(targetSource, game) && filter.match(player, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (permanent.canBeTargetedBy(targetSource, sourceControllerId, game) && filter.match(permanent, sourceId, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<UUID>();\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && filter.match(player, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (filter.match(permanent, null, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","id":87811,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (UUID playerId: game.getPlayer(sourceControllerId).getInRange()) {\n            Player player = game.getPlayer(playerId);\n            if (player != null && filter.match(player, game)) {\n                possibleTargets.add(playerId);\n            }\n        }\n        for (Permanent permanent: game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), sourceControllerId, game)) {\n            if (filter.match(permanent, null, sourceControllerId, game)) {\n                possibleTargets.add(permanent.getId());\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void addTarget(UUID id, Ability source, Game game, boolean skipEvent) {\n        //20100423 - 113.3\n        if (maxNumberOfTargets == 0 || targets.size() < maxNumberOfTargets) {\n            if (!targets.containsKey(id)) {\n                if (source != null) {\n                    if (!game.replaceEvent(GameEvent.getEvent(EventType.TARGET, id, source.getId(), source.getControllerId()))) {\n                        targets.put(id, 0);\n                        rememberZoneChangeCounter(id, game);\n                        chosen = targets.size() >= minNumberOfTargets;\n                        if (!skipEvent) {\n                            game.fireEvent(GameEvent.getEvent(EventType.TARGETED, id, source.getId(), source.getControllerId()));\n                        }\n                    }\n                }\n                else {\n                    targets.put(id, 0);\n                }\n            }\n        }\n    }","id":87812,"modified_method":"@Override\n    public void addTarget(UUID id, Ability source, Game game, boolean skipEvent) {\n        //20100423 - 113.3\n        if (maxNumberOfTargets == 0 || targets.size() < maxNumberOfTargets) {\n            if (!targets.containsKey(id)) {\n                if (source != null) {\n                    if (!game.replaceEvent(GameEvent.getEvent(EventType.TARGET, id, source.getSourceId(), source.getControllerId()))) {\n                        targets.put(id, 0);\n                        rememberZoneChangeCounter(id, game);\n                        chosen = targets.size() >= minNumberOfTargets;\n                        if (!skipEvent) {\n                            game.fireEvent(GameEvent.getEvent(EventType.TARGETED, id, source.getSourceId(), source.getControllerId()));\n                        }\n                    }\n                }\n                else {\n                    targets.put(id, 0);\n                }\n            }\n        }\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<UUID>();\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, game)) {\n                possibleTargets.add(stackObject.getId());\n            }\n        }\n        return possibleTargets;\n    }","id":87813,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, game)) {\n                possibleTargets.add(stackObject.getId());\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"ba885fef91c27554516f505fbe3f8601a5633ecf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        return possibleTargets(sourceControllerId, game);\n    }","id":87814,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, sourceId, sourceControllerId, game)) {\n                possibleTargets.add(stackObject.getId());\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"6ec18de1fe637db463a976e75427efd3e832dde2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean canChoose(UUID sourceControllerId, Game game) {\n        int count = 0;\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":87815,"modified_method":"@Override\n    public boolean canChoose(UUID sourceControllerId, Game game) {\n        return canChoose(null, sourceControllerId, game);\n    }","commit_id":"6ec18de1fe637db463a976e75427efd3e832dde2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, game)) {\n                possibleTargets.add(stackObject.getId());\n            }\n        }\n        return possibleTargets;\n    }","id":87816,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        return this.possibleTargets(null, sourceControllerId, game);\n    }","commit_id":"6ec18de1fe637db463a976e75427efd3e832dde2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        return canChoose(sourceControllerId, game);\n    }","id":87817,"modified_method":"@Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        int count = 0;\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, sourceId, sourceControllerId, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"6ec18de1fe637db463a976e75427efd3e832dde2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean canTarget(UUID id, Ability source, Game game) {\n        StackObject stackObject = game.getStack().getStackObject(id);\n        if (stackObject != null) {\n            return filter.match(stackObject, game);\n        }\n        return false;\n    }","id":87818,"modified_method":"@Override\n    public boolean canTarget(UUID id, Ability source, Game game) {\n        StackObject stackObject = game.getStack().getStackObject(id);\n        if (stackObject != null) {\n            return filter.match(stackObject, source.getSourceId(), source.getControllerId(), game);\n        }\n        return false;\n    }","commit_id":"6ec18de1fe637db463a976e75427efd3e832dde2","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean canTarget(UUID id, Ability source, Game game) {\n        StackObject stackObject = game.getStack().getStackObject(id);\n        if (stackObject != null) {\n            return filter.match(stackObject, game);\n        }\n        return false;\n    }","id":87819,"modified_method":"@Override\n    public boolean canTarget(UUID id, Ability source, Game game) {\n        StackObject stackObject = game.getStack().getStackObject(id);\n        if (stackObject != null) {\n            return filter.match(stackObject, source.getSourceId(), source.getControllerId(), game);\n        }\n        return false;\n    }","commit_id":"f801477ab5ab8fec98e64d5f144db4ae88b991af","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        return canChoose(sourceControllerId, game);\n    }","id":87820,"modified_method":"@Override\n    public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {\n        int count = 0;\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, sourceId, sourceControllerId, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"f801477ab5ab8fec98e64d5f144db4ae88b991af","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, game)) {\n                possibleTargets.add(stackObject.getId());\n            }\n        }\n        return possibleTargets;\n    }","id":87821,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\n        return this.possibleTargets(null, sourceControllerId, game);\n    }","commit_id":"f801477ab5ab8fec98e64d5f144db4ae88b991af","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        return possibleTargets(sourceControllerId, game);\n    }","id":87822,"modified_method":"@Override\n    public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {\n        Set<UUID> possibleTargets = new HashSet<>();\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, sourceId, sourceControllerId, game)) {\n                possibleTargets.add(stackObject.getId());\n            }\n        }\n        return possibleTargets;\n    }","commit_id":"f801477ab5ab8fec98e64d5f144db4ae88b991af","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean canChoose(UUID sourceControllerId, Game game) {\n        int count = 0;\n        for (StackObject stackObject: game.getStack()) {\n            if (game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getControllerId()) && filter.match(stackObject, game)) {\n                count++;\n                if (count >= this.minNumberOfTargets) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":87823,"modified_method":"@Override\n    public boolean canChoose(UUID sourceControllerId, Game game) {\n        return canChoose(null, sourceControllerId, game);\n    }","commit_id":"f801477ab5ab8fec98e64d5f144db4ae88b991af","url":"https://github.com/magefree/mage"},{"original_method":"private List<AnnotationDescriptor> getAnnotations(Callable proto) {\n        return Flags.hasAnnotations(proto.getFlags())\n               ? annotationDeserializer.loadCallableAnnotations(proto)\n               : Collections.<AnnotationDescriptor>emptyList();\n    }","id":87824,"modified_method":"private List<AnnotationDescriptor> getAnnotations(Callable proto) {\n        return Flags.HAS_ANNOTATIONS.get(proto.getFlags())\n               ? annotationDeserializer.loadCallableAnnotations(proto)\n               : Collections.<AnnotationDescriptor>emptyList();\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private CallableMemberDescriptor loadFunction(@NotNull Callable proto) {\n        int flags = proto.getFlags();\n        SimpleFunctionDescriptorImpl function = new SimpleFunctionDescriptorImpl(\n                containingDeclaration,\n                getAnnotations(proto),\n                nameResolver.getName(proto.getName()),\n                memberKind(Flags.getMemberKind(flags))\n        );\n        DescriptorDeserializer local = createChildDeserializer(function);\n        List<TypeParameterDescriptor> typeParameters = local.typeParameters(proto.getTypeParametersList());\n        function.initialize(\n                local.typeDeserializer.typeOrNull(proto.hasReceiverType() ? proto.getReceiverType() : null),\n                // TODO: expectedThisObject\n                null,\n                typeParameters,\n                local.valueParameters(proto.getValueParametersList()),\n                local.typeDeserializer.type(proto.getReturnType()),\n                modality(Flags.getModality(flags)),\n                visibility(Flags.getVisibility(flags)),\n                Flags.isInline(flags)\n\n        );\n        return function;\n    }","id":87825,"modified_method":"@NotNull\n    private CallableMemberDescriptor loadFunction(@NotNull Callable proto) {\n        int flags = proto.getFlags();\n        SimpleFunctionDescriptorImpl function = new SimpleFunctionDescriptorImpl(\n                containingDeclaration,\n                getAnnotations(proto),\n                nameResolver.getName(proto.getName()),\n                memberKind(Flags.MEMBER_KIND.get(flags))\n        );\n        DescriptorDeserializer local = createChildDeserializer(function);\n        List<TypeParameterDescriptor> typeParameters = local.typeParameters(proto.getTypeParametersList());\n        function.initialize(\n                local.typeDeserializer.typeOrNull(proto.hasReceiverType() ? proto.getReceiverType() : null),\n                // TODO: expectedThisObject\n                null,\n                typeParameters,\n                local.valueParameters(proto.getValueParametersList()),\n                local.typeDeserializer.type(proto.getReturnType()),\n                modality(Flags.MODALITY.get(flags)),\n                visibility(Flags.VISIBILITY.get(flags)),\n                Flags.INLINE.get(flags)\n\n        );\n        return function;\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private ValueParameterDescriptor valueParameter(Callable.ValueParameter proto, int index) {\n        return new ValueParameterDescriptorImpl(\n                containingDeclaration,\n                index,\n                getAnnotations(proto),\n                nameResolver.getName(proto.getName()),\n                typeDeserializer.type(proto.getType()),\n                Flags.declaresDefaultValue(proto.getFlags()),\n                typeDeserializer.typeOrNull(proto.hasVarargElementType() ? proto.getVarargElementType() : null));\n    }","id":87826,"modified_method":"private ValueParameterDescriptor valueParameter(Callable.ValueParameter proto, int index) {\n        return new ValueParameterDescriptorImpl(\n                containingDeclaration,\n                index,\n                getAnnotations(proto),\n                nameResolver.getName(proto.getName()),\n                typeDeserializer.type(proto.getType()),\n                Flags.DECLARES_DEFAULT_VALUE.get(proto.getFlags()),\n                typeDeserializer.typeOrNull(proto.hasVarargElementType() ? proto.getVarargElementType() : null));\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private PropertyDescriptor loadProperty(@NotNull Callable proto) {\n        int flags = proto.getFlags();\n        PropertyDescriptorImpl property = new PropertyDescriptorImpl(\n                containingDeclaration,\n                getAnnotations(proto),\n                modality(Flags.getModality(flags)),\n                visibility(Flags.getVisibility(flags)),\n                Flags.getCallableKind(flags) == Callable.CallableKind.VAR,\n                nameResolver.getName(proto.getName()),\n                memberKind(Flags.getMemberKind(flags))\n        );\n        DescriptorDeserializer local = createChildDeserializer(property);\n        List<TypeParameterDescriptor> typeParameters = local.typeParameters(proto.getTypeParametersList());\n        property.setType(\n                local.typeDeserializer.type(proto.getReturnType()),\n                typeParameters,\n                // TODO: expected this object\n                null,\n                local.typeDeserializer.typeOrNull(proto.hasReceiverType() ? proto.getReceiverType() : null)\n        );\n        return property;\n    }","id":87827,"modified_method":"@NotNull\n    private PropertyDescriptor loadProperty(@NotNull Callable proto) {\n        int flags = proto.getFlags();\n        PropertyDescriptorImpl property = new PropertyDescriptorImpl(\n                containingDeclaration,\n                getAnnotations(proto),\n                modality(Flags.MODALITY.get(flags)),\n                visibility(Flags.VISIBILITY.get(flags)),\n                Flags.CALLABLE_KIND.get(flags) == Callable.CallableKind.VAR,\n                nameResolver.getName(proto.getName()),\n                memberKind(Flags.MEMBER_KIND.get(flags))\n        );\n        DescriptorDeserializer local = createChildDeserializer(property);\n        List<TypeParameterDescriptor> typeParameters = local.typeParameters(proto.getTypeParametersList());\n        property.setType(\n                local.typeDeserializer.type(proto.getReturnType()),\n                typeParameters,\n                // TODO: expected this object\n                null,\n                local.typeDeserializer.typeOrNull(proto.hasReceiverType() ? proto.getReceiverType() : null)\n        );\n        return property;\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private List<AnnotationDescriptor> getAnnotations(Callable.ValueParameter proto) {\n        return Flags.hasAnnotations(proto.getFlags())\n               ? annotationDeserializer.loadValueParameterAnnotations(proto)\n               : Collections.<AnnotationDescriptor>emptyList();\n    }","id":87828,"modified_method":"private List<AnnotationDescriptor> getAnnotations(Callable.ValueParameter proto) {\n        return Flags.HAS_ANNOTATIONS.get(proto.getFlags())\n               ? annotationDeserializer.loadValueParameterAnnotations(proto)\n               : Collections.<AnnotationDescriptor>emptyList();\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public CallableMemberDescriptor loadCallable(@NotNull Callable proto) {\n        Callable.CallableKind callableKind = Flags.getCallableKind(proto.getFlags());\n        switch (callableKind) {\n            case FUN:\n                return loadFunction(proto);\n            case VAL:\n            case VAR:\n                return loadProperty(proto);\n            case CONSTRUCTOR:\n                return loadConstructor(proto);\n        }\n        throw new IllegalArgumentException(\"Unsupported callable kind: \" + callableKind);\n    }","id":87829,"modified_method":"@NotNull\n    public CallableMemberDescriptor loadCallable(@NotNull Callable proto) {\n        Callable.CallableKind callableKind = Flags.CALLABLE_KIND.get(proto.getFlags());\n        switch (callableKind) {\n            case FUN:\n                return loadFunction(proto);\n            case VAL:\n            case VAR:\n                return loadProperty(proto);\n            case CONSTRUCTOR:\n                return loadConstructor(proto);\n        }\n        throw new IllegalArgumentException(\"Unsupported callable kind: \" + callableKind);\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private CallableMemberDescriptor loadConstructor(@NotNull Callable proto) {\n        ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n        ConstructorDescriptorImpl descriptor = new ConstructorDescriptorImpl(\n                classDescriptor,\n                getAnnotations(proto),\n                // TODO: primary\n                true);\n        DescriptorDeserializer local = createChildDeserializer(descriptor);\n        descriptor.initialize(\n                classDescriptor.getTypeConstructor().getParameters(),\n                local.valueParameters(proto.getValueParametersList()),\n                visibility(Flags.getVisibility(proto.getFlags())),\n                !classDescriptor.isInner()\n        );\n        return descriptor;\n    }","id":87830,"modified_method":"@NotNull\n    private CallableMemberDescriptor loadConstructor(@NotNull Callable proto) {\n        ClassDescriptor classDescriptor = (ClassDescriptor) containingDeclaration;\n        ConstructorDescriptorImpl descriptor = new ConstructorDescriptorImpl(\n                classDescriptor,\n                getAnnotations(proto),\n                // TODO: primary\n                true);\n        DescriptorDeserializer local = createChildDeserializer(descriptor);\n        descriptor.initialize(\n                classDescriptor.getTypeConstructor().getParameters(),\n                local.valueParameters(proto.getValueParametersList()),\n                visibility(Flags.VISIBILITY.get(proto.getFlags())),\n                !classDescriptor.isInner()\n        );\n        return descriptor;\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private List<AnnotationDescriptor> computeAnnotations() {\n        if (!Flags.hasAnnotations(classProto.getFlags())) {\n            return Collections.emptyList();\n        }\n        return annotationDeserializer.loadClassAnnotations(classProto);\n    }","id":87831,"modified_method":"private List<AnnotationDescriptor> computeAnnotations() {\n        if (!Flags.HAS_ANNOTATIONS.get(classProto.getFlags())) {\n            return Collections.emptyList();\n        }\n        return annotationDeserializer.loadClassAnnotations(classProto);\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public DeserializedClassDescriptor(\n            @NotNull DeclarationDescriptor containingDeclaration,\n            @NotNull NameResolver nameResolver,\n            @NotNull AnnotationDeserializer annotationResolver,\n            @NotNull ClassResolver classResolver,\n            @NotNull NestedClassResolver _nestedClassResolver,\n            @NotNull ProtoBuf.Class classProto,\n            @Nullable TypeDeserializer outerTypeDeserializer\n    ) {\n        this.classProto = classProto;\n        this.typeDeserializer = new TypeDeserializer(outerTypeDeserializer, nameResolver, classResolver);\n        this.deserializer = DescriptorDeserializer.create(typeDeserializer, this, nameResolver, annotationResolver);\n\n        this.containingDeclaration = containingDeclaration;\n        this.typeConstructor = new DeserializedClassTypeConstructor();\n        this.memberScope = new DeserializedClassMemberScope(this);\n        this.thisAsReceiverParameter = new ReceiverParameterDescriptorImpl(this, getDefaultType(), new ClassReceiver(this));\n\n        this.name = nameResolver.getName(classProto.getName());\n        int flags = classProto.getFlags();\n        this.modality = DescriptorDeserializer.modality(Flags.getModality(flags));\n        this.visibility = DescriptorDeserializer.visibility(Flags.getVisibility(flags));\n        this.kind = DescriptorDeserializer.classKind(Flags.getClassKind(flags));\n        this.isInner = Flags.isInner(flags);\n\n        this.annotationDeserializer = annotationResolver;\n        this.annotations = new NotNullLazyValueImpl<List<AnnotationDescriptor>>() {\n            @NotNull\n            @Override\n            protected List<AnnotationDescriptor> doCompute() {\n                return computeAnnotations();\n            }\n        };\n\n        this.primaryConstructor = new NullableLazyValueImpl<ConstructorDescriptor>() {\n            @Override\n            protected ConstructorDescriptor doCompute() {\n                return computePrimaryConstructor();\n            }\n        };\n\n        this.nestedClassResolver = _nestedClassResolver;\n        this.classObjectDescriptor = new NullableLazyValueImpl<ClassDescriptor>() {\n            @Override\n            protected ClassDescriptor doCompute() {\n                return computeClassObjectDecriptor();\n            }\n        };\n        this.nestedClasses = new NestedClassDescriptors(stringSet(classProto.getNestedClassNamesList(), nameResolver)) {\n            @Override\n            protected ClassDescriptor resolveNestedClass(@NotNull Name name) {\n                return nestedClassResolver.resolveNestedClass(DeserializedClassDescriptor.this, name);\n            }\n        };\n        this.nestedObjects = new NestedClassDescriptors(stringSet(classProto.getNestedObjectNamesList(), nameResolver)) {\n            @Override\n            protected ClassDescriptor resolveNestedClass(@NotNull Name name) {\n                return nestedClassResolver.resolveNestedClass(DeserializedClassDescriptor.this, name);\n            }\n        };\n    }","id":87832,"modified_method":"public DeserializedClassDescriptor(\n            @NotNull DeclarationDescriptor containingDeclaration,\n            @NotNull NameResolver nameResolver,\n            @NotNull AnnotationDeserializer annotationResolver,\n            @NotNull ClassResolver classResolver,\n            @NotNull NestedClassResolver _nestedClassResolver,\n            @NotNull ProtoBuf.Class classProto,\n            @Nullable TypeDeserializer outerTypeDeserializer\n    ) {\n        this.classProto = classProto;\n        this.typeDeserializer = new TypeDeserializer(outerTypeDeserializer, nameResolver, classResolver);\n        this.deserializer = DescriptorDeserializer.create(typeDeserializer, this, nameResolver, annotationResolver);\n\n        this.containingDeclaration = containingDeclaration;\n        this.typeConstructor = new DeserializedClassTypeConstructor();\n        this.memberScope = new DeserializedClassMemberScope(this);\n        this.thisAsReceiverParameter = new ReceiverParameterDescriptorImpl(this, getDefaultType(), new ClassReceiver(this));\n\n        this.name = nameResolver.getName(classProto.getName());\n        int flags = classProto.getFlags();\n        this.modality = DescriptorDeserializer.modality(Flags.MODALITY.get(flags));\n        this.visibility = DescriptorDeserializer.visibility(Flags.VISIBILITY.get(flags));\n        this.kind = DescriptorDeserializer.classKind(Flags.CLASS_KIND.get(flags));\n        this.isInner = Flags.INNER.get(flags);\n\n        this.annotationDeserializer = annotationResolver;\n        this.annotations = new NotNullLazyValueImpl<List<AnnotationDescriptor>>() {\n            @NotNull\n            @Override\n            protected List<AnnotationDescriptor> doCompute() {\n                return computeAnnotations();\n            }\n        };\n\n        this.primaryConstructor = new NullableLazyValueImpl<ConstructorDescriptor>() {\n            @Override\n            protected ConstructorDescriptor doCompute() {\n                return computePrimaryConstructor();\n            }\n        };\n\n        this.nestedClassResolver = _nestedClassResolver;\n        this.classObjectDescriptor = new NullableLazyValueImpl<ClassDescriptor>() {\n            @Override\n            protected ClassDescriptor doCompute() {\n                return computeClassObjectDecriptor();\n            }\n        };\n        this.nestedClasses = new NestedClassDescriptors(stringSet(classProto.getNestedClassNamesList(), nameResolver)) {\n            @Override\n            protected ClassDescriptor resolveNestedClass(@NotNull Name name) {\n                return nestedClassResolver.resolveNestedClass(DeserializedClassDescriptor.this, name);\n            }\n        };\n        this.nestedObjects = new NestedClassDescriptors(stringSet(classProto.getNestedObjectNamesList(), nameResolver)) {\n            @Override\n            protected ClassDescriptor resolveNestedClass(@NotNull Name name) {\n                return nestedClassResolver.resolveNestedClass(DeserializedClassDescriptor.this, name);\n            }\n        };\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private <D extends CallableMemberDescriptor> Collection<D> computeMembersByName(Name name, Filter<ProtoBuf.Callable.CallableKind> callableKind) {\n        List<ProtoBuf.Callable> memberProtos = membersProtos.get(name);\n\n        Collection<D> descriptors = new LinkedHashSet<D>(memberProtos != null ? memberProtos.size() : 0);\n        if (memberProtos != null) {\n            for (ProtoBuf.Callable memberProto : memberProtos) {\n                if (callableKind.accept(Flags.getCallableKind(memberProto.getFlags()))) {\n                    //noinspection unchecked\n                    descriptors.add((D) deserializer.loadCallable(memberProto));\n                }\n            }\n        }\n        return descriptors;\n    }","id":87833,"modified_method":"@NotNull\n    private <D extends CallableMemberDescriptor> Collection<D> computeMembersByName(Name name, Filter<ProtoBuf.Callable.CallableKind> callableKind) {\n        List<ProtoBuf.Callable> memberProtos = membersProtos.get(name);\n\n        Collection<D> descriptors = new LinkedHashSet<D>(memberProtos != null ? memberProtos.size() : 0);\n        if (memberProtos != null) {\n            for (ProtoBuf.Callable memberProto : memberProtos) {\n                if (callableKind.accept(Flags.CALLABLE_KIND.get(memberProto.getFlags()))) {\n                    //noinspection unchecked\n                    descriptors.add((D) deserializer.loadCallable(memberProto));\n                }\n            }\n        }\n        return descriptors;\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static int getCallableFlags(\n            boolean hasAnnotations, @NotNull Visibility visibility,\n            @NotNull Modality modality,\n            @NotNull CallableMemberDescriptor.Kind memberKind,\n            @NotNull ProtoBuf.Callable.CallableKind callableKind,\n            boolean inline\n    ) {\n        int hasAnnotationsInt = hasAnnotations ? 1 : 0;\n        int visibilityInt = visibility(visibility).getNumber();\n        int modalityInt = modality(modality).getNumber();\n        int memberKindInt = memberKind(memberKind).getNumber();\n        int callableKindInt = callableKind.getNumber();\n        int inlineInt = inline ? 1 : 0;\n        return hasAnnotationsInt << HAS_ANNOTATIONS_OFFSET\n               | modalityInt << MODALITY_OFFSET\n               | visibilityInt << VISIBILITY_OFFSET\n               | memberKindInt << MEMBER_KIND_OFFSET\n               | callableKindInt << CALLABLE_KIND_OFFSET\n               | inlineInt << INLINE_OFFSET\n               ;\n    }","id":87834,"modified_method":"public static int getCallableFlags(\n            boolean hasAnnotations,\n            @NotNull Visibility visibility,\n            @NotNull Modality modality,\n            @NotNull CallableMemberDescriptor.Kind memberKind,\n            @NotNull ProtoBuf.Callable.CallableKind callableKind,\n            boolean inline\n    ) {\n        return HAS_ANNOTATIONS.toFlags(hasAnnotations)\n               | MODALITY.toFlags(modality(modality))\n               | VISIBILITY.toFlags(visibility(visibility))\n               | MEMBER_KIND.toFlags(memberKind(memberKind))\n               | CALLABLE_KIND.toFlags(callableKind)\n               | INLINE.toFlags(inline)\n               ;\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static int getValueParameterFlags(boolean hasAnnotations, boolean declaresDefaultValue) {\n        int hasAnnotationsInt = hasAnnotations ? 1 : 0;\n        int declaresDefaultValueInt = declaresDefaultValue ? 1 : 0;\n        return hasAnnotationsInt << HAS_ANNOTATIONS_OFFSET\n               | declaresDefaultValueInt << DECLARES_DEFAULT_VALUE_OFFSET\n               ;\n    }","id":87835,"modified_method":"public static int getValueParameterFlags(boolean hasAnnotations, boolean declaresDefaultValue) {\n        return HAS_ANNOTATIONS.toFlags(hasAnnotations)\n               | DECLARES_DEFAULT_VALUE.toFlags(declaresDefaultValue)\n               ;\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static int getClassFlags(\n            boolean hasAnnotations,\n            Visibility visibility,\n            Modality modality,\n            ClassKind kind,\n            boolean inner\n    ) {\n        int hasAnnotationsInt = hasAnnotations ? 1 : 0;\n        int visibilityInt = visibility(visibility).getNumber();\n        int modalityInt = modality(modality).getNumber();\n        int classKindInt = classKind(kind).getNumber();\n        int innerInt = inner ? 1 : 0;\n        return hasAnnotationsInt << HAS_ANNOTATIONS_OFFSET\n               | modalityInt << MODALITY_OFFSET\n               | visibilityInt << VISIBILITY_OFFSET\n               | classKindInt << CLASS_KIND_OFFSET\n               | innerInt << INNER_OFFSET\n               ;\n    }","id":87836,"modified_method":"public static int getClassFlags(\n            boolean hasAnnotations,\n            Visibility visibility,\n            Modality modality,\n            ClassKind kind,\n            boolean inner\n    ) {\n        return HAS_ANNOTATIONS.toFlags(hasAnnotations)\n               | MODALITY.toFlags(modality(modality))\n               | VISIBILITY.toFlags(visibility(visibility))\n               | CLASS_KIND.toFlags(classKind(kind))\n               | INNER.toFlags(inner)\n               ;\n    }","commit_id":"76e01fa5525b4468108f7e9f8b5e698874d854a4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public GrVariableDeclaration createVariableDeclaration(String[] modifiers, GrExpression initializer, PsiType type, String... identifiers) {\n    StringBuffer text = writeModifiers(modifiers);\n\n    text.append(\"def \");\n    if (type != null) {\n      type = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      text.append(getTypeText(type)).append(\" \");\n    }\n\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n\n    GrExpression expr;\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement) {\n        expr = createMethodCallByAppCall(((GrApplicationStatement) initializer));\n      } else {\n        expr = initializer;\n      }\n      text.append(\" = \").append(expr.getText());\n    }\n\n    PsiFile file = createGroovyFile(text.toString());\n    return ((GrVariableDeclaration) ((GroovyFileBase) file).getTopStatements()[0]);\n  }","id":87837,"modified_method":"public GrVariableDeclaration createVariableDeclaration(String[] modifiers, GrExpression initializer, PsiType type, String... identifiers) {\n    StringBuffer text = writeModifiers(modifiers);\n\n    if (type != null) {\n      type = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      final String typeText = getTypeText(type);\n      int lastDot = typeText.lastIndexOf('.');\n      int idx = 0 < lastDot && lastDot < typeText.length() - 1 ? lastDot + 1 : 0;\n      char c = typeText.charAt(idx);\n      if (!Character.isLetter(c) || Character.isLowerCase(c) &&\n          !GroovyNamesUtil.isKeyword(typeText)) { //primitive type\n        text.append(\"def \");\n      }\n      text.append(typeText).append(\" \");\n    } else {\n      text.append(\"def \");\n    }\n\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n    GrExpression expr;\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement) {\n        expr = createMethodCallByAppCall(((GrApplicationStatement) initializer));\n      } else {\n        expr = initializer;\n      }\n      text.append(\" = \").append(expr.getText());\n    }\n\n    PsiFile file = createGroovyFile(text.toString());\n    return ((GrVariableDeclaration) ((GroovyFileBase) file).getTopStatements()[0]);\n  }","commit_id":"efb2b2904888eac22f4167267d105fb7dbf07ef9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrVariableDeclaration createSimpleVariableDeclaration(String name, String typeText) {\n    String classText;\n    if (Character.isLowerCase(typeText.charAt(0))) {\n      classText = \"class A { def \" + typeText + \" \" + name + \"}\";\n    } else {\n      classText = \"class A { \" + typeText + \" \" + name + \"}\";\n    }\n\n    GroovyFileBase file = (GroovyFileBase) createGroovyFile(classText);\n    final GrTypeDefinitionBody body = file.getTypeDefinitions()[0].getBody();\n    return (GrVariableDeclaration) body.getMemberDeclarations()[0];\n  }","id":87838,"modified_method":"public GrVariableDeclaration createSimpleVariableDeclaration(String name, String typeText) {\n    String classText = \"\";\n    if (Character.isLowerCase(typeText.charAt(0))) {\n      classText = \"class A { def \" + typeText + \" \" + name + \"}\";\n    } else {\n      classText = \"class A { \" + typeText + \" \" + name + \"}\";\n    }\n\n    GroovyFileBase file = (GroovyFileBase) createGroovyFile(classText);\n    final GrTypeDefinitionBody body = file.getTypeDefinitions()[0].getBody();\n    return (GrVariableDeclaration) body.getMemberDeclarations()[0];\n  }","commit_id":"efb2b2904888eac22f4167267d105fb7dbf07ef9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addMethodConflicts(MultiMap<PsiElement, String> conflicts) {\n    try {\n      GrMethod prototype;\n      final PsiMethod method = myChangeInfo.getMethod();\n      if (!(method instanceof GrMethod)) return;\n      PsiManager manager = method.getManager();\n      GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(manager.getProject());\n      final CanonicalTypes.Type returnType = myChangeInfo.getNewReturnType();\n      String newMethodName = myChangeInfo.getNewName();\n      if (returnType != null) {\n        prototype = factory.createMethodFromText(\"\", newMethodName, returnType.getTypeText(), ArrayUtil.EMPTY_STRING_ARRAY, method);\n      }\n      else {\n        prototype = factory.createConstructorFromText(newMethodName, ArrayUtil.EMPTY_STRING_ARRAY, ArrayUtil.EMPTY_STRING_ARRAY, \"{}\", method);\n      }\n      JavaParameterInfo[] parameters = myChangeInfo.getNewParameters();\n\n      for (JavaParameterInfo info : parameters) {\n        PsiParameter param = factory.createParameter(info.getName(), info.getTypeText(), (GroovyPsiElement)method);\n        prototype.getParameterList().add(param);\n      }\n\n      ConflictsUtil.checkMethodConflicts(method.getContainingClass(), method, prototype, conflicts);\n      GrMethodConflictUtil.checkMethodConflicts(method.getContainingClass(), prototype, ((GrMethod)method), conflicts, true);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":87839,"modified_method":"private void addMethodConflicts(MultiMap<PsiElement, String> conflicts) {\n    try {\n      GrMethod prototype;\n      final PsiMethod method = myChangeInfo.getMethod();\n      if (!(method instanceof GrMethod)) return;\n\n      PsiManager manager = method.getManager();\n      GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(manager.getProject());\n      final CanonicalTypes.Type returnType = myChangeInfo.getNewReturnType();\n      String newMethodName = myChangeInfo.getNewName();\n      if (returnType != null) {\n        prototype = factory.createMethodFromText(\"\", newMethodName, returnType.getTypeText(), ArrayUtil.EMPTY_STRING_ARRAY, method);\n      }\n      else {\n        prototype = factory.createConstructorFromText(newMethodName, ArrayUtil.EMPTY_STRING_ARRAY, ArrayUtil.EMPTY_STRING_ARRAY, \"{}\", method);\n      }\n      JavaParameterInfo[] parameters = myChangeInfo.getNewParameters();\n\n      for (JavaParameterInfo info : parameters) {\n        GrParameter param;\n        if (info instanceof GrParameterInfo) {\n          param = factory.createParameter(info.getName(), info.getTypeText(), ((GrParameterInfo)info).getDefaultInitializer(), (GroovyPsiElement)method);\n        }\n        else {\n          param = factory.createParameter(info.getName(), info.getTypeText(), (GroovyPsiElement)method);\n        }\n        prototype.getParameterList().add(param);\n      }\n\n      ConflictsUtil.checkMethodConflicts(method.getContainingClass(), method, prototype, conflicts);\n      GrMethodConflictUtil.checkMethodConflicts(method.getContainingClass(), prototype, ((GrMethod)method), conflicts, true);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"GrChangeSignatureConflictSearcher(JavaChangeInfo changeInfo) {\n    this.myChangeInfo = changeInfo;\n  }","id":87840,"modified_method":"GrChangeSignatureConflictSearcher(JavaChangeInfo changeInfo) {\n    myChangeInfo = changeInfo;\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addInaccessibilityDescriptions(Set<UsageInfo> usages, MultiMap<PsiElement, String> conflictDescriptions)\n    throws IncorrectOperationException {\n    PsiMethod method = myChangeInfo.getMethod();\n    PsiModifierList modifierList = (PsiModifierList)method.getModifierList().copy();\n    VisibilityUtil.setVisibility(modifierList, myChangeInfo.getNewVisibility());\n\n    for (Iterator<UsageInfo> iterator = usages.iterator(); iterator.hasNext();) {\n      UsageInfo usageInfo = iterator.next();\n      PsiElement element = usageInfo.getElement();\n      if (element != null) {\n        if (element instanceof GrReferenceExpression) {\n          PsiClass accessObjectClass = null;\n          GrExpression qualifier = ((GrReferenceExpression)element).getQualifierExpression();\n          if (qualifier != null) {\n            accessObjectClass = getAccessObjectClass(qualifier);\n          }\n\n          if (!JavaPsiFacade.getInstance(element.getProject()).getResolveHelper()\n            .isAccessible(method, modifierList, element, accessObjectClass, null)) {\n            String message =\n              RefactoringBundle.message(\"0.with.1.visibility.is.not.accessible.from.2\",\n                                        RefactoringUIUtil.getDescription(method, true),\n                                        myChangeInfo.getNewVisibility(),\n                                        RefactoringUIUtil.getDescription(ConflictsUtil.getContainer(element), true));\n            conflictDescriptions.putValue(method, message);\n            if (!needToChangeCalls()) {\n              iterator.remove();\n            }\n          }\n        }\n      }\n    }\n  }","id":87841,"modified_method":"private void addInaccessibilityDescriptions(Set<UsageInfo> usages, MultiMap<PsiElement, String> conflictDescriptions)\n    throws IncorrectOperationException {\n    PsiMethod method = myChangeInfo.getMethod();\n    PsiModifierList modifierList = (PsiModifierList)method.getModifierList().copy();\n    VisibilityUtil.setVisibility(modifierList, myChangeInfo.getNewVisibility());\n\n    for (Iterator<UsageInfo> iterator = usages.iterator(); iterator.hasNext();) {\n      UsageInfo usageInfo = iterator.next();\n      PsiElement element = usageInfo.getElement();\n      if (element != null) {\n        if (element instanceof GrReferenceExpression) {\n          PsiClass accessObjectClass = null;\n          GrExpression qualifier = ((GrReferenceExpression)element).getQualifierExpression();\n          if (qualifier != null) {\n            accessObjectClass = getAccessObjectClass(qualifier);\n          }\n\n          PsiResolveHelper helper = JavaPsiFacade.getInstance(element.getProject()).getResolveHelper();\n          if (!helper.isAccessible(method, modifierList, element, accessObjectClass, null)) {\n            String message =\n              RefactoringBundle.message(\"0.with.1.visibility.is.not.accessible.from.2\",\n                                        RefactoringUIUtil.getDescription(method, true),\n                                        myChangeInfo.getNewVisibility(),\n                                        RefactoringUIUtil.getDescription(ConflictsUtil.getContainer(element), true));\n            conflictDescriptions.putValue(method, message);\n            if (!needToChangeCalls()) {\n              iterator.remove();\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected String validateAndCommitData() {\n    if (!isGroovyMethodName(getMethodName())) {\n      return message(\"name.is.wrong\", getMethodName());\n    }\n\n    if (!checkType((PsiTypeCodeFragment)myReturnTypeCodeFragment, true)) {\n      return message(\"return.type.is.wrong\");\n    }\n\n    List<GrParameterTableModelItem> parameterInfos = myParametersTableModel.getItems();\n    int newParameterCount = parameterInfos.size();\n    for (int i = 0; i < newParameterCount; i++) {\n      GrParameterTableModelItem item = parameterInfos.get(i);\n\n      String name = item.parameter.getName();\n      if (!StringUtil.isJavaIdentifier(name)) {\n        return message(\"name.is.wrong\", name);\n      }\n\n      if (!checkType((PsiTypeCodeFragment)item.typeCodeFragment, i == newParameterCount - 1)) {\n        return message(\"type.for.parameter.is.incorrect\", name);\n      }\n      try {\n        item.parameter.setType(((PsiTypeCodeFragment)item.typeCodeFragment).getType());\n      }\n      catch (PsiTypeCodeFragment.TypeSyntaxException e) {\n        LOG.error(e);\n      }\n      catch (PsiTypeCodeFragment.NoTypeException e) {\n        item.parameter.setType(null);\n      }\n\n      String defaultValue = item.defaultValueCodeFragment.getText();\n      final String initializer = item.initializerCodeFragment.getText();\n      if (item.parameter.getOldIndex() < 0 && defaultValue.trim().length() == 0 && initializer.trim().length() == 0) {\n        return message(\"specify.default.value\", name);\n      }\n\n      item.parameter.setInitializer(initializer);\n    }\n\n    ThrownExceptionInfo[] exceptionInfos = myExceptionsModel.getThrownExceptions();\n    PsiTypeCodeFragment[] typeCodeFragments = myExceptionsModel.getTypeCodeFragments();\n    for (int i = 0; i < exceptionInfos.length; i++) {\n      ThrownExceptionInfo exceptionInfo = exceptionInfos[i];\n      PsiTypeCodeFragment typeCodeFragment = typeCodeFragments[i];\n      try {\n        PsiType type = typeCodeFragment.getType();\n        if (!(type instanceof PsiClassType)) {\n          return message(\"changeSignature.wrong.type.for.exception\", typeCodeFragment.getText());\n        }\n\n        PsiElementFactory factory = JavaPsiFacade.getInstance(getProject()).getElementFactory();\n        PsiClassType throwable = factory.createTypeByFQClassName(\"java.lang.Throwable\", myMethod.getMethod().getResolveScope());\n        if (!throwable.isAssignableFrom(type)) {\n          return message(\"changeSignature.not.throwable.type\", typeCodeFragment.getText());\n        }\n        exceptionInfo.setType((PsiClassType)type);\n      }\n      catch (PsiTypeCodeFragment.TypeSyntaxException e) {\n        return message(\"changeSignature.wrong.type.for.exception\", typeCodeFragment.getText());\n      }\n      catch (PsiTypeCodeFragment.NoTypeException e) {\n        return message(\"changeSignature.no.type.for.exception\");\n      }\n    }\n\n    return null;\n  }","id":87842,"modified_method":"@Nullable\n  @Override\n  protected String validateAndCommitData() {\n    if (!isGroovyMethodName(getMethodName())) {\n      return message(\"name.is.wrong\", getMethodName());\n    }\n\n    if (!checkType((PsiTypeCodeFragment)myReturnTypeCodeFragment, true)) {\n      return message(\"return.type.is.wrong\");\n    }\n\n    List<GrParameterTableModelItem> parameterInfos = myParametersTableModel.getItems();\n    int newParameterCount = parameterInfos.size();\n    for (int i = 0; i < newParameterCount; i++) {\n      GrParameterTableModelItem item = parameterInfos.get(i);\n\n      String name = item.parameter.getName();\n      if (!StringUtil.isJavaIdentifier(name)) {\n        return message(\"name.is.wrong\", name);\n      }\n\n      if (!checkType((PsiTypeCodeFragment)item.typeCodeFragment, i == newParameterCount - 1)) {\n        return message(\"type.for.parameter.is.incorrect\", name);\n      }\n      try {\n        item.parameter.setType(((PsiTypeCodeFragment)item.typeCodeFragment).getType());\n      }\n      catch (PsiTypeCodeFragment.TypeSyntaxException e) {\n        LOG.error(e);\n      }\n      catch (PsiTypeCodeFragment.NoTypeException e) {\n        item.parameter.setType(null);\n      }\n\n      String defaultValue = item.defaultValueCodeFragment.getText();\n      final String initializer = item.initializerCodeFragment.getText();\n      if (item.parameter.getOldIndex() < 0 && defaultValue.trim().length() == 0 && initializer.trim().length() == 0) {\n        return message(\"specify.default.value\", name);\n      }\n\n      item.parameter.setInitializer(initializer);\n      item.parameter.setDefaultValue(defaultValue);\n    }\n\n    ThrownExceptionInfo[] exceptionInfos = myExceptionsModel.getThrownExceptions();\n    PsiTypeCodeFragment[] typeCodeFragments = myExceptionsModel.getTypeCodeFragments();\n    for (int i = 0; i < exceptionInfos.length; i++) {\n      ThrownExceptionInfo exceptionInfo = exceptionInfos[i];\n      PsiTypeCodeFragment typeCodeFragment = typeCodeFragments[i];\n      try {\n        PsiType type = typeCodeFragment.getType();\n        if (!(type instanceof PsiClassType)) {\n          return message(\"changeSignature.wrong.type.for.exception\", typeCodeFragment.getText());\n        }\n\n        PsiElementFactory factory = JavaPsiFacade.getInstance(getProject()).getElementFactory();\n        PsiClassType throwable = factory.createTypeByFQClassName(\"java.lang.Throwable\", myMethod.getMethod().getResolveScope());\n        if (!throwable.isAssignableFrom(type)) {\n          return message(\"changeSignature.not.throwable.type\", typeCodeFragment.getText());\n        }\n        exceptionInfo.setType((PsiClassType)type);\n      }\n      catch (PsiTypeCodeFragment.TypeSyntaxException e) {\n        return message(\"changeSignature.wrong.type.for.exception\", typeCodeFragment.getText());\n      }\n      catch (PsiTypeCodeFragment.NoTypeException e) {\n        return message(\"changeSignature.no.type.for.exception\");\n      }\n    }\n\n    return null;\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages) {\n    MultiMap<PsiElement, String> conflictDescriptions = new MultiMap<PsiElement, String>();\n    for (ChangeSignatureUsageProcessor usageProcessor : ChangeSignatureUsageProcessor.EP_NAME.getExtensions()) {\n      final MultiMap<PsiElement, String> conflicts = usageProcessor.findConflicts(myChangeInfo, refUsages);\n      for (PsiElement key : conflicts.keySet()) {\n        Collection<String> collection = conflictDescriptions.get(key);\n        if (collection.size() == 0) collection = new HashSet<String>();\n        collection.addAll(conflicts.get(key));\n        conflictDescriptions.put(key, collection);\n      }\n    }\n\n    final UsageInfo[] usagesIn = refUsages.get();\n    RenameUtil.addConflictDescriptions(usagesIn, conflictDescriptions);\n    Set<UsageInfo> usagesSet = new HashSet<UsageInfo>(Arrays.asList(usagesIn));\n    RenameUtil.removeConflictUsages(usagesSet);\n    if (!conflictDescriptions.isEmpty()) {\n      ConflictsDialog dialog = prepareConflictsDialog(conflictDescriptions, usagesIn);\n      dialog.show();\n      if (!dialog.isOK()) {\n        if (dialog.isShowConflicts()) prepareSuccessful();\n        return false;\n      }\n    }\n    refUsages.set(usagesSet.toArray(new UsageInfo[usagesSet.size()]));\n    prepareSuccessful();\n    return true;\n  }","id":87843,"modified_method":"@Override\n  protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages) {\n    MultiMap<PsiElement, String> conflictDescriptions = new MultiMap<PsiElement, String>();\n    for (ChangeSignatureUsageProcessor usageProcessor : ChangeSignatureUsageProcessor.EP_NAME.getExtensions()) {\n      final MultiMap<PsiElement, String> conflicts = usageProcessor.findConflicts(myChangeInfo, refUsages);\n      for (PsiElement key : conflicts.keySet()) {\n        Collection<String> collection = conflictDescriptions.get(key);\n        if (collection.size() == 0) collection = new HashSet<String>();\n        collection.addAll(conflicts.get(key));\n        conflictDescriptions.put(key, collection);\n      }\n    }\n\n    final UsageInfo[] usagesIn = refUsages.get();\n    RenameUtil.addConflictDescriptions(usagesIn, conflictDescriptions);\n    Set<UsageInfo> usagesSet = new HashSet<UsageInfo>(Arrays.asList(usagesIn));\n    RenameUtil.removeConflictUsages(usagesSet);\n    if (!conflictDescriptions.isEmpty()) {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        throw new ConflictsInTestsException(conflictDescriptions.values());\n      }\n\n      ConflictsDialog dialog = prepareConflictsDialog(conflictDescriptions, usagesIn);\n      dialog.show();\n      if (!dialog.isOK()) {\n        if (dialog.isShowConflicts()) prepareSuccessful();\n        return false;\n      }\n    }\n    refUsages.set(usagesSet.toArray(new UsageInfo[usagesSet.size()]));\n    prepareSuccessful();\n    return true;\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getTypeText() {\n    if (myTypeWrapper != null) {\n      return myTypeWrapper.getTypeText();\n    }\n    return \"\";\n  }","id":87844,"modified_method":"@NotNull\n  public String getTypeText() {\n    return myTypeWrapper != null ? myTypeWrapper.getTypeText() : \"\";\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setInitializer(String initializer) {\n    myDefaultInitializer = initializer;\n  }","id":87845,"modified_method":"public void setInitializer(@Nullable String initializer) {\n    myDefaultInitializer = StringUtil.notNullize(initializer);\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrParameterInfo(@NotNull String name,\n                         @Nullable String defaultValue,\n                         @Nullable String defaultInitializer,\n                         @Nullable PsiType type,\n                         int position,\n                         boolean useAnySingleVariable) {\n    myName = name;\n    myDefaultValue = defaultValue;\n    myDefaultInitializer = defaultInitializer;\n    myPosition = position;\n    myUseAnySingleVariable = useAnySingleVariable;\n    setType(type);\n  }","id":87846,"modified_method":"public GrParameterInfo(@NotNull String name,\n                         @Nullable String defaultValue,\n                         @Nullable String defaultInitializer,\n                         @Nullable PsiType type,\n                         int position,\n                         boolean useAnySingleVariable) {\n    myName = name;\n    myPosition = position;\n    myUseAnySingleVariable = useAnySingleVariable;\n    setType(type);\n    setDefaultValue(defaultValue);\n    setInitializer(defaultInitializer);\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean forceOptional() {\n    return myPosition < 0 && myDefaultValue.length() == 0;\n  }","id":87847,"modified_method":"public boolean forceOptional() {\n    return myPosition < 0 && StringUtil.isEmpty(myDefaultValue);\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiType createType(PsiElement context, final PsiManager manager) throws IncorrectOperationException {\n    if (myTypeWrapper == null) return null;\n    return myTypeWrapper.getType(context, manager);\n  }","id":87848,"modified_method":"@Nullable\n  public PsiType createType(PsiElement context, final PsiManager manager) throws IncorrectOperationException {\n    return myTypeWrapper != null ? myTypeWrapper.getType(context, manager) : null;\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getDefaultValue() {\n    if (forceOptional()) return getDefaultInitializer();\n    return myDefaultValue;\n  }","id":87849,"modified_method":"@NotNull\n  public String getDefaultValue() {\n    return forceOptional() ? getDefaultInitializer() : myDefaultValue;\n  }","commit_id":"44b47f604ee0a76d4d6a5a04d44f5916e5365ff5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static String getPropertyType(final JSNamedElement jsNamedElement) {\n    if (jsNamedElement instanceof JSVariable) {\n      return ((JSVariable)jsNamedElement).getTypeString();\n    }\n    else {\n      JSType type = JSResolveUtil.getTypeFromSetAccessor(jsNamedElement);\n      return type != null ? type.getTypeText() : null;\n    }\n  }","id":87850,"modified_method":"static String getPropertyType(final JSNamedElement jsNamedElement) {\n    if (jsNamedElement instanceof JSVariable) {\n      return ((JSVariable)jsNamedElement).getTypeString();\n    }\n    else if (jsNamedElement instanceof JSFunctionItem) {\n      final JSType type = JSResolveUtil.getTypeFromSetAccessor((JSFunctionItem)jsNamedElement);\n      if (type != null) {\n        return type.getTypeText();\n      }\n    }\n    return null;\n  }","commit_id":"fa84b57e90c770ffad3358063652d19bb10fa979","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n     * Initialized the service implementation, and puts it in a sate where it\n     * could interoperate with other services. It is strongly recommended that\n     * properties in this Map be mapped to property names as specified by\n     * <tt>AccountProperties<\/tt>.\n     *\n     * @param screenname the account id/uin/screenname of the account that\n     * we're about to create\n     * @param accountID the identifier of the account that this protocol\n     * provider represents.\n     *\n     * @see net.java.sip.communicator.service.protocol.AccountID\n     */\n    protected void initialize(String screenname,\n                              AccountID accountID)\n    {\n        synchronized(initializationLock)\n        {\n            this.accountID = accountID;\n\n            // in case of modified account, we clear list of supported features\n            // and every state change listeners, otherwise we can have two\n            // OperationSet for same feature and it can causes problem (i.e.\n            // two OperationSetBasicTelephony can launch two ICE negociations\n            // (with different ufrag/passwd) and peer will failed call. And\n            // by the way user will see two dialog for answering/refusing the\n            // call\n            supportedFeatures.clear();\n            this.clearRegistrationStateChangeListener();\n            this.clearSupportedOperationSet();\n\n            synchronized(providerCreationLock)\n            {\n                if(providerManager == null)\n                {\n                    try\n                    {\n                        ProviderManager.setInstance(new ProviderManagerExt());\n                    }\n                    catch(Throwable t)\n                    {\n                        // once loaded if we try to set instance second time\n                        // IllegalStateException is thrown\n                    }\n                    finally\n                    {\n                        providerManager = ProviderManager.getInstance();\n                    }\n                }\n            }\n\n            String protocolIconPath\n                = accountID.getAccountPropertyString(\n                        ProtocolProviderFactory.PROTOCOL_ICON_PATH);\n\n            if (protocolIconPath == null)\n                protocolIconPath = \"resources/images/protocol/jabber\";\n\n            jabberIcon = new ProtocolIconJabberImpl(protocolIconPath);\n\n            jabberStatusEnum\n                = JabberStatusEnum.getJabberStatusEnum(protocolIconPath);\n\n            //this feature is mandatory to be compliant with Service Discovery\n            supportedFeatures.add(\"http://jabber.org/protocol/disco#info\");\n\n            String keepAliveStrValue\n                = accountID.getAccountPropertyString(\n                    ProtocolProviderFactory.KEEP_ALIVE_METHOD);\n            String resourcePriority\n                = accountID.getAccountPropertyString(\n                        ProtocolProviderFactory.RESOURCE_PRIORITY);\n\n            InfoRetreiver infoRetreiver = new InfoRetreiver(this, screenname);\n\n            //initialize the presence operationset\n            OperationSetPersistentPresenceJabberImpl persistentPresence =\n                new OperationSetPersistentPresenceJabberImpl(this, infoRetreiver);\n\n            if(resourcePriority != null)\n            {\n                persistentPresence\n                    .setResourcePriority(Integer.parseInt(resourcePriority));\n                // TODO : is this resource priority related to xep-0168\n                // (Resource Application Priority) ?\n                // see http://www.xmpp.org/extensions/xep-0168.html\n                // If the answer is no, comment the following lines please\n                supportedFeatures.add(\n                        \"http://www.xmpp.org/extensions/xep-0168.html#ns\");\n            }\n\n            addSupportedOperationSet(\n                OperationSetPersistentPresence.class,\n                persistentPresence);\n            // TODO: add the feature, if any, corresponding to persistent\n            // presence, if someone knows\n            // supportedFeatures.add(_PRESENCE_);\n\n            //register it once again for those that simply need presence\n            addSupportedOperationSet(\n                OperationSetPresence.class,\n                persistentPresence);\n\n            //initialize the IM operation set\n            OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging =\n                new OperationSetBasicInstantMessagingJabberImpl(this);\n\n            if (keepAliveStrValue == null\n                || keepAliveStrValue.equalsIgnoreCase(\"XEP-0199\"))\n            {\n                if(keepAliveManager == null)\n                    keepAliveManager = new KeepAliveManager(this);\n            }\n\n            addSupportedOperationSet(\n                OperationSetBasicInstantMessaging.class,\n                basicInstantMessaging);\n\n            // The http://jabber.org/protocol/xhtml-im feature is included\n            // already in smack.\n\n            addSupportedOperationSet(\n                OperationSetExtendedAuthorizations.class,\n                new OperationSetExtendedAuthorizationsJabberImpl(\n                    this,\n                    persistentPresence));\n\n            //initialize the Whiteboard operation set\n            addSupportedOperationSet(\n                OperationSetWhiteboarding.class,\n                new OperationSetWhiteboardingJabberImpl(this));\n\n            //initialize the typing notifications operation set\n            addSupportedOperationSet(\n                OperationSetTypingNotifications.class,\n                new OperationSetTypingNotificationsJabberImpl(this));\n\n            // The http://jabber.org/protocol/chatstates feature implemented in\n            // OperationSetTypingNotifications is included already in smack.\n\n            //initialize the multi user chat operation set\n            addSupportedOperationSet(\n                OperationSetMultiUserChat.class,\n                new OperationSetMultiUserChatJabberImpl(this));\n\n            addSupportedOperationSet(\n                OperationSetServerStoredContactInfo.class,\n                new OperationSetServerStoredContactInfoJabberImpl(\n                        infoRetreiver));\n\n            OperationSetServerStoredAccountInfo accountInfo =\n                new OperationSetServerStoredAccountInfoJabberImpl(this,\n                        infoRetreiver,\n                        screenname);\n\n            addSupportedOperationSet(\n                OperationSetServerStoredAccountInfo.class,\n                accountInfo);\n\n            // Initialize avatar operation set\n            addSupportedOperationSet(\n                OperationSetAvatar.class,\n                new OperationSetAvatarJabberImpl(this, accountInfo));\n\n            // initialize the file transfer operation set\n            addSupportedOperationSet(\n                OperationSetFileTransfer.class,\n                new OperationSetFileTransferJabberImpl(this));\n\n            addSupportedOperationSet(\n                OperationSetInstantMessageTransform.class,\n                new OperationSetInstantMessageTransformImpl());\n\n            // Include features we're supporting in addition to the four\n            // included by smack itself:\n            // http://jabber.org/protocol/si/profile/file-transfer\n            // http://jabber.org/protocol/si\n            // http://jabber.org/protocol/bytestreams\n            // http://jabber.org/protocol/ibb\n            supportedFeatures.add(\"urn:xmpp:thumbs:0\");\n            supportedFeatures.add(\"urn:xmpp:bob\");\n\n            // initialize the thumbnailed file factory operation set\n            addSupportedOperationSet(\n                OperationSetThumbnailedFileFactory.class,\n                new OperationSetThumbnailedFileFactoryImpl());\n\n            // TODO: this is the \"main\" feature to advertise when a client\n            // support muc. We have to add some features for\n            // specific functionality we support in muc.\n            // see http://www.xmpp.org/extensions/xep-0045.html\n\n            // The http://jabber.org/protocol/muc feature is already included in\n            // smack.\n            supportedFeatures.add(\"http://jabber.org/protocol/muc#rooms\");\n            supportedFeatures.add(\"http://jabber.org/protocol/muc#traffic\");\n\n            // RTP HDR extension\n            supportedFeatures.add(URN_XMPP_JINGLE_RTP_HDREXT);\n\n            //register our jingle provider\n            providerManager.addIQProvider( JingleIQ.ELEMENT_NAME,\n                                           JingleIQ.NAMESPACE,\n                                           new JingleIQProvider());\n\n            // register our input event provider\n            providerManager.addIQProvider(InputEvtIQ.ELEMENT_NAME,\n                                          InputEvtIQ.NAMESPACE,\n                                          new InputEvtIQProvider());\n\n            // register our coin provider\n            providerManager.addIQProvider(CoinIQ.ELEMENT_NAME,\n                                          CoinIQ.NAMESPACE,\n                                          new CoinIQProvider());\n            supportedFeatures.add(URN_XMPP_JINGLE_COIN);\n\n            //register our GTalk dialect provider\n            providerManager.addIQProvider( SessionIQ.ELEMENT_NAME,\n                                           SessionIQ.NAMESPACE,\n                                           new SessionIQProvider());\n\n            // register our JingleInfo provider\n            providerManager.addIQProvider(JingleInfoQueryIQ.ELEMENT_NAME,\n                                          JingleInfoQueryIQ.NAMESPACE,\n                                          new JingleInfoQueryIQProvider());\n\n            // Jitsi VideoBridge IQProvider and PacketExtensionProvider\n            providerManager.addIQProvider(\n                    CobriConferenceIQ.ELEMENT_NAME,\n                    CobriConferenceIQ.NAMESPACE,\n                    new CobriIQProvider());\n            providerManager.addExtensionProvider(\n                    PayloadTypePacketExtension.ELEMENT_NAME,\n                    CobriConferenceIQ.NAMESPACE,\n                    new DefaultPacketExtensionProvider<\n                                PayloadTypePacketExtension>(\n                            PayloadTypePacketExtension.class));\n            providerManager.addExtensionProvider(\n                    ParameterPacketExtension.ELEMENT_NAME,\n                    CobriConferenceIQ.NAMESPACE,\n                    new DefaultPacketExtensionProvider<\n                                ParameterPacketExtension>(\n                            ParameterPacketExtension.class));\n\n            //initialize the telephony operation set\n            boolean isCallingDisabled\n                = JabberActivator.getConfigurationService()\n                    .getBoolean(IS_CALLING_DISABLED, false);\n\n            boolean isCallingDisabledForAccount\n                = accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,\n                    false);\n\n            // Check if calling is enabled.\n            if (!isCallingDisabled && !isCallingDisabledForAccount)\n            {\n                OperationSetBasicTelephonyJabberImpl basicTelephony\n                    = new OperationSetBasicTelephonyJabberImpl(this);\n\n                addSupportedOperationSet(\n                    OperationSetAdvancedTelephony.class,\n                    basicTelephony);\n                addSupportedOperationSet(\n                    OperationSetBasicTelephony.class,\n                    basicTelephony);\n                addSupportedOperationSet(\n                    OperationSetSecureZrtpTelephony.class,\n                    basicTelephony);\n                addSupportedOperationSet(\n                    OperationSetSecureSDesTelephony.class,\n                    basicTelephony);\n\n                // initialize video telephony OperationSet\n                addSupportedOperationSet(\n                    OperationSetVideoTelephony.class,\n                    new OperationSetVideoTelephonyJabberImpl(basicTelephony));\n\n                addSupportedOperationSet(\n                    OperationSetTelephonyConferencing.class,\n                    new OperationSetTelephonyConferencingJabberImpl(this));\n\n                addSupportedOperationSet(\n                    OperationSetBasicAutoAnswer.class,\n                    new OperationSetAutoAnswerJabberImpl(this));\n\n                addSupportedOperationSet(\n                    OperationSetVideoBridge.class,\n                    new OperationSetVideoBridgeImpl(this));\n\n                // init DTMF\n                OperationSetDTMFJabberImpl operationSetDTMFSip\n                    = new OperationSetDTMFJabberImpl(this);\n                addSupportedOperationSet(\n                    OperationSetDTMF.class, operationSetDTMFSip);\n\n                addJingleFeatures();\n\n                // Check if desktop streaming is enabled.\n                boolean isDesktopStreamingDisabled\n                    = JabberActivator.getConfigurationService()\n                        .getBoolean(IS_DESKTOP_STREAMING_DISABLED, false);\n\n                boolean isAccountDesktopStreamingDisabled\n                    = accountID.getAccountPropertyBoolean(\n                        ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,\n                        false);\n\n                if (!isDesktopStreamingDisabled\n                    && !isAccountDesktopStreamingDisabled)\n                {\n                    // initialize desktop streaming OperationSet\n                    addSupportedOperationSet(\n                            OperationSetDesktopStreaming.class,\n                            new OperationSetDesktopStreamingJabberImpl(\n                                basicTelephony));\n\n                    // initialize desktop sharing OperationSets\n                    addSupportedOperationSet(\n                            OperationSetDesktopSharingServer.class,\n                            new OperationSetDesktopSharingServerJabberImpl(\n                                basicTelephony));\n\n                    // Adds extension to support remote control as a sharing\n                    // server (sharer).\n                    supportedFeatures.add(InputEvtIQ.NAMESPACE_SERVER);\n\n                    addSupportedOperationSet(\n                            OperationSetDesktopSharingClient.class,\n                            new OperationSetDesktopSharingClientJabberImpl(this)\n                            );\n                    // Adds extension to support remote control as a sharing\n                    // client (sharee).\n                    supportedFeatures.add(InputEvtIQ.NAMESPACE_CLIENT);\n                }\n            }\n\n            // OperationSetContactCapabilities\n            opsetContactCapabilities\n                = new OperationSetContactCapabilitiesJabberImpl(this);\n            if (discoveryManager != null)\n                opsetContactCapabilities.setDiscoveryManager(discoveryManager);\n            addSupportedOperationSet(\n                OperationSetContactCapabilities.class,\n                opsetContactCapabilities);\n\n            addSupportedOperationSet(\n                OperationSetGenericNotifications.class,\n                new OperationSetGenericNotificationsJabberImpl(this));\n\n            supportedFeatures.add(\"jabber:iq:version\");\n            if(versionManager == null)\n                versionManager = new VersionManager(this);\n\n            supportedFeatures.add(MessageCorrectionExtension.NAMESPACE);\n            addSupportedOperationSet(OperationSetMessageCorrection.class,\n                    basicInstantMessaging);\n\n            OperationSetChangePassword opsetChangePassword \n                    = new OperationSetChangePasswordJabberImpl(this);\n            addSupportedOperationSet(OperationSetChangePassword.class,\n                    opsetChangePassword);\n\n            isInitialized = true;\n        }\n    }","id":87851,"modified_method":"/**\n     * Initialized the service implementation, and puts it in a sate where it\n     * could interoperate with other services. It is strongly recommended that\n     * properties in this Map be mapped to property names as specified by\n     * <tt>AccountProperties<\/tt>.\n     *\n     * @param screenname the account id/uin/screenname of the account that\n     * we're about to create\n     * @param accountID the identifier of the account that this protocol\n     * provider represents.\n     *\n     * @see net.java.sip.communicator.service.protocol.AccountID\n     */\n    protected void initialize(String screenname,\n                              AccountID accountID)\n    {\n        synchronized(initializationLock)\n        {\n            this.accountID = accountID;\n\n            // in case of modified account, we clear list of supported features\n            // and every state change listeners, otherwise we can have two\n            // OperationSet for same feature and it can causes problem (i.e.\n            // two OperationSetBasicTelephony can launch two ICE negociations\n            // (with different ufrag/passwd) and peer will failed call. And\n            // by the way user will see two dialog for answering/refusing the\n            // call\n            supportedFeatures.clear();\n            this.clearRegistrationStateChangeListener();\n            this.clearSupportedOperationSet();\n\n            synchronized(providerCreationLock)\n            {\n                if(providerManager == null)\n                {\n                    try\n                    {\n                        ProviderManager.setInstance(new ProviderManagerExt());\n                    }\n                    catch(Throwable t)\n                    {\n                        // once loaded if we try to set instance second time\n                        // IllegalStateException is thrown\n                    }\n                    finally\n                    {\n                        providerManager = ProviderManager.getInstance();\n                    }\n                }\n            }\n\n            String protocolIconPath\n                = accountID.getAccountPropertyString(\n                        ProtocolProviderFactory.PROTOCOL_ICON_PATH);\n\n            if (protocolIconPath == null)\n                protocolIconPath = \"resources/images/protocol/jabber\";\n\n            jabberIcon = new ProtocolIconJabberImpl(protocolIconPath);\n\n            jabberStatusEnum\n                = JabberStatusEnum.getJabberStatusEnum(protocolIconPath);\n\n            //this feature is mandatory to be compliant with Service Discovery\n            supportedFeatures.add(\"http://jabber.org/protocol/disco#info\");\n\n            String keepAliveStrValue\n                = accountID.getAccountPropertyString(\n                    ProtocolProviderFactory.KEEP_ALIVE_METHOD);\n            String resourcePriority\n                = accountID.getAccountPropertyString(\n                        ProtocolProviderFactory.RESOURCE_PRIORITY);\n\n            InfoRetreiver infoRetreiver = new InfoRetreiver(this, screenname);\n\n            //initialize the presence operationset\n            OperationSetPersistentPresenceJabberImpl persistentPresence =\n                new OperationSetPersistentPresenceJabberImpl(this, infoRetreiver);\n\n            if(resourcePriority != null)\n            {\n                persistentPresence\n                    .setResourcePriority(Integer.parseInt(resourcePriority));\n                // TODO : is this resource priority related to xep-0168\n                // (Resource Application Priority) ?\n                // see http://www.xmpp.org/extensions/xep-0168.html\n                // If the answer is no, comment the following lines please\n                supportedFeatures.add(\n                        \"http://www.xmpp.org/extensions/xep-0168.html#ns\");\n            }\n\n            addSupportedOperationSet(\n                OperationSetPersistentPresence.class,\n                persistentPresence);\n            // TODO: add the feature, if any, corresponding to persistent\n            // presence, if someone knows\n            // supportedFeatures.add(_PRESENCE_);\n\n            //register it once again for those that simply need presence\n            addSupportedOperationSet(\n                OperationSetPresence.class,\n                persistentPresence);\n\n            //initialize the IM operation set\n            OperationSetBasicInstantMessagingJabberImpl basicInstantMessaging =\n                new OperationSetBasicInstantMessagingJabberImpl(this);\n\n            if (keepAliveStrValue == null\n                || keepAliveStrValue.equalsIgnoreCase(\"XEP-0199\"))\n            {\n                if(keepAliveManager == null)\n                    keepAliveManager = new KeepAliveManager(this);\n            }\n\n            addSupportedOperationSet(\n                OperationSetBasicInstantMessaging.class,\n                basicInstantMessaging);\n\n            // The http://jabber.org/protocol/xhtml-im feature is included\n            // already in smack.\n\n            addSupportedOperationSet(\n                OperationSetExtendedAuthorizations.class,\n                new OperationSetExtendedAuthorizationsJabberImpl(\n                    this,\n                    persistentPresence));\n\n            //initialize the Whiteboard operation set\n            addSupportedOperationSet(\n                OperationSetWhiteboarding.class,\n                new OperationSetWhiteboardingJabberImpl(this));\n\n            //initialize the typing notifications operation set\n            addSupportedOperationSet(\n                OperationSetTypingNotifications.class,\n                new OperationSetTypingNotificationsJabberImpl(this));\n\n            // The http://jabber.org/protocol/chatstates feature implemented in\n            // OperationSetTypingNotifications is included already in smack.\n\n            //initialize the multi user chat operation set\n            addSupportedOperationSet(\n                OperationSetMultiUserChat.class,\n                new OperationSetMultiUserChatJabberImpl(this));\n\n            addSupportedOperationSet(\n                OperationSetServerStoredContactInfo.class,\n                new OperationSetServerStoredContactInfoJabberImpl(\n                        infoRetreiver));\n\n            OperationSetServerStoredAccountInfo accountInfo =\n                new OperationSetServerStoredAccountInfoJabberImpl(this,\n                        infoRetreiver,\n                        screenname);\n\n            addSupportedOperationSet(\n                OperationSetServerStoredAccountInfo.class,\n                accountInfo);\n\n            // Initialize avatar operation set\n            addSupportedOperationSet(\n                OperationSetAvatar.class,\n                new OperationSetAvatarJabberImpl(this, accountInfo));\n\n            // initialize the file transfer operation set\n            addSupportedOperationSet(\n                OperationSetFileTransfer.class,\n                new OperationSetFileTransferJabberImpl(this));\n\n            addSupportedOperationSet(\n                OperationSetInstantMessageTransform.class,\n                new OperationSetInstantMessageTransformImpl());\n\n            // Include features we're supporting in addition to the four\n            // included by smack itself:\n            // http://jabber.org/protocol/si/profile/file-transfer\n            // http://jabber.org/protocol/si\n            // http://jabber.org/protocol/bytestreams\n            // http://jabber.org/protocol/ibb\n            supportedFeatures.add(\"urn:xmpp:thumbs:0\");\n            supportedFeatures.add(\"urn:xmpp:bob\");\n\n            // initialize the thumbnailed file factory operation set\n            addSupportedOperationSet(\n                OperationSetThumbnailedFileFactory.class,\n                new OperationSetThumbnailedFileFactoryImpl());\n\n            // TODO: this is the \"main\" feature to advertise when a client\n            // support muc. We have to add some features for\n            // specific functionality we support in muc.\n            // see http://www.xmpp.org/extensions/xep-0045.html\n\n            // The http://jabber.org/protocol/muc feature is already included in\n            // smack.\n            supportedFeatures.add(\"http://jabber.org/protocol/muc#rooms\");\n            supportedFeatures.add(\"http://jabber.org/protocol/muc#traffic\");\n\n            // RTP HDR extension\n            supportedFeatures.add(URN_XMPP_JINGLE_RTP_HDREXT);\n\n            //register our jingle provider\n            providerManager.addIQProvider( JingleIQ.ELEMENT_NAME,\n                                           JingleIQ.NAMESPACE,\n                                           new JingleIQProvider());\n\n            // register our input event provider\n            providerManager.addIQProvider(InputEvtIQ.ELEMENT_NAME,\n                                          InputEvtIQ.NAMESPACE,\n                                          new InputEvtIQProvider());\n\n            // register our coin provider\n            providerManager.addIQProvider(CoinIQ.ELEMENT_NAME,\n                                          CoinIQ.NAMESPACE,\n                                          new CoinIQProvider());\n            supportedFeatures.add(URN_XMPP_JINGLE_COIN);\n\n            //register our GTalk dialect provider\n            providerManager.addIQProvider( SessionIQ.ELEMENT_NAME,\n                                           SessionIQ.NAMESPACE,\n                                           new SessionIQProvider());\n\n            // register our JingleInfo provider\n            providerManager.addIQProvider(JingleInfoQueryIQ.ELEMENT_NAME,\n                                          JingleInfoQueryIQ.NAMESPACE,\n                                          new JingleInfoQueryIQProvider());\n\n            // Jitsi VideoBridge IQProvider and PacketExtensionProvider\n            providerManager.addIQProvider(\n                    CobriConferenceIQ.ELEMENT_NAME,\n                    CobriConferenceIQ.NAMESPACE,\n                    new CobriIQProvider());\n            providerManager.addExtensionProvider(\n                    PayloadTypePacketExtension.ELEMENT_NAME,\n                    CobriConferenceIQ.NAMESPACE,\n                    new DefaultPacketExtensionProvider<\n                                PayloadTypePacketExtension>(\n                            PayloadTypePacketExtension.class));\n            providerManager.addExtensionProvider(\n                    ParameterPacketExtension.ELEMENT_NAME,\n                    CobriConferenceIQ.NAMESPACE,\n                    new DefaultPacketExtensionProvider<\n                                ParameterPacketExtension>(\n                            ParameterPacketExtension.class));\n\n            //initialize the telephony operation set\n            boolean isCallingDisabled\n                = JabberActivator.getConfigurationService()\n                    .getBoolean(IS_CALLING_DISABLED, false);\n\n            boolean isCallingDisabledForAccount\n                = accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,\n                    false);\n\n            // Check if calling is enabled.\n            if (!isCallingDisabled && !isCallingDisabledForAccount)\n            {\n                OperationSetBasicTelephonyJabberImpl basicTelephony\n                    = new OperationSetBasicTelephonyJabberImpl(this);\n\n                addSupportedOperationSet(\n                    OperationSetAdvancedTelephony.class,\n                    basicTelephony);\n                addSupportedOperationSet(\n                    OperationSetBasicTelephony.class,\n                    basicTelephony);\n                addSupportedOperationSet(\n                    OperationSetSecureZrtpTelephony.class,\n                    basicTelephony);\n                addSupportedOperationSet(\n                    OperationSetSecureSDesTelephony.class,\n                    basicTelephony);\n\n                // initialize video telephony OperationSet\n                addSupportedOperationSet(\n                    OperationSetVideoTelephony.class,\n                    new OperationSetVideoTelephonyJabberImpl(basicTelephony));\n\n                addSupportedOperationSet(\n                    OperationSetTelephonyConferencing.class,\n                    new OperationSetTelephonyConferencingJabberImpl(this));\n\n                addSupportedOperationSet(\n                    OperationSetBasicAutoAnswer.class,\n                    new OperationSetAutoAnswerJabberImpl(this));\n\n                // Only init video bridge if enabled\n                boolean isVideoBridgeDisabled\n                    = JabberActivator.getConfigurationService()\n                      .getBoolean(OperationSetVideoBridge.\n                          IS_VIDEO_BRIDGE_DISABLED, false);\n\n                if (!isVideoBridgeDisabled)\n                {\n                    // init video bridge\n                    addSupportedOperationSet(\n                        OperationSetVideoBridge.class,\n                        new OperationSetVideoBridgeImpl(this));\n                }\n\n                // init DTMF\n                OperationSetDTMFJabberImpl operationSetDTMFSip\n                    = new OperationSetDTMFJabberImpl(this);\n                addSupportedOperationSet(\n                    OperationSetDTMF.class, operationSetDTMFSip);\n\n                addJingleFeatures();\n\n                // Check if desktop streaming is enabled.\n                boolean isDesktopStreamingDisabled\n                    = JabberActivator.getConfigurationService()\n                        .getBoolean(IS_DESKTOP_STREAMING_DISABLED, false);\n\n                boolean isAccountDesktopStreamingDisabled\n                    = accountID.getAccountPropertyBoolean(\n                        ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,\n                        false);\n\n                if (!isDesktopStreamingDisabled\n                    && !isAccountDesktopStreamingDisabled)\n                {\n                    // initialize desktop streaming OperationSet\n                    addSupportedOperationSet(\n                            OperationSetDesktopStreaming.class,\n                            new OperationSetDesktopStreamingJabberImpl(\n                                basicTelephony));\n\n                    // initialize desktop sharing OperationSets\n                    addSupportedOperationSet(\n                            OperationSetDesktopSharingServer.class,\n                            new OperationSetDesktopSharingServerJabberImpl(\n                                basicTelephony));\n\n                    // Adds extension to support remote control as a sharing\n                    // server (sharer).\n                    supportedFeatures.add(InputEvtIQ.NAMESPACE_SERVER);\n\n                    addSupportedOperationSet(\n                            OperationSetDesktopSharingClient.class,\n                            new OperationSetDesktopSharingClientJabberImpl(this)\n                            );\n                    // Adds extension to support remote control as a sharing\n                    // client (sharee).\n                    supportedFeatures.add(InputEvtIQ.NAMESPACE_CLIENT);\n                }\n            }\n\n            // OperationSetContactCapabilities\n            opsetContactCapabilities\n                = new OperationSetContactCapabilitiesJabberImpl(this);\n            if (discoveryManager != null)\n                opsetContactCapabilities.setDiscoveryManager(discoveryManager);\n            addSupportedOperationSet(\n                OperationSetContactCapabilities.class,\n                opsetContactCapabilities);\n\n            addSupportedOperationSet(\n                OperationSetGenericNotifications.class,\n                new OperationSetGenericNotificationsJabberImpl(this));\n\n            supportedFeatures.add(\"jabber:iq:version\");\n            if(versionManager == null)\n                versionManager = new VersionManager(this);\n\n            supportedFeatures.add(MessageCorrectionExtension.NAMESPACE);\n            addSupportedOperationSet(OperationSetMessageCorrection.class,\n                    basicInstantMessaging);\n\n            OperationSetChangePassword opsetChangePassword\n                    = new OperationSetChangePasswordJabberImpl(this);\n            addSupportedOperationSet(OperationSetChangePassword.class,\n                    opsetChangePassword);\n\n            isInitialized = true;\n        }\n    }","commit_id":"6104713520d64ecdddfa2a3c8e822a272aa4011c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the appropriate video bridge menu depending on how many\n     * registered providers do we have that support the\n     * <tt>OperationSetVideoBridge<\/tt>.\n     */\n    private void initVideoBridgeMenu()\n    {\n        if (!SwingUtilities.isEventDispatchThread())\n        {\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    initVideoBridgeMenu();\n                }\n            });\n            return;\n        }\n\n        // We create the video default video bridge menu item and set it\n        // disabled until we have more information on video bridge support.\n        if (videoBridgeMenuItem == null)\n        {\n            videoBridgeMenuItem = new VideoBridgeProviderMenuItem(\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.CREATE_VIDEO_BRIDGE\"),\n                        null);\n\n            videoBridgeMenuItem.setEnabled(false);\n\n            insert(videoBridgeMenuItem, 1);\n        }\n\n        // We re-init the video bridge menu item each time the\n        // parent menu is selected in order to be able to refresh the list\n        // of available video bridge active providers.\n        if (videoBridgeMenuListener == null)\n        {\n            videoBridgeMenuListener = new VideoBridgeMenuListener();\n\n            addMenuListener(videoBridgeMenuListener);\n        }\n\n        // Check the protocol providers supporting video bridge in a new thread.\n        if (initVideoBridgeMenuWorker == null)\n            initVideoBridgeMenuWorker\n                = (OSUtils.IS_MAC)\n                    ? new InitVideoBridgeMenuWorkerMacOSX()\n                    : new InitVideoBridgeMenuWorker();\n        else\n            initVideoBridgeMenuWorker.interrupt();\n\n        initVideoBridgeMenuWorker.start();\n    }","id":87852,"modified_method":"/**\n     * Initializes the appropriate video bridge menu depending on how many\n     * registered providers do we have that support the\n     * <tt>OperationSetVideoBridge<\/tt>.\n     */\n    private void initVideoBridgeMenu()\n    {\n        // If video bridge is enabled in the config then add the menu item\n        if (GuiActivator.getConfigurationService()\n             .getBoolean(OperationSetVideoBridge\n                .IS_VIDEO_BRIDGE_DISABLED, false))\n        {\n            return;\n        }\n\n        if (!SwingUtilities.isEventDispatchThread())\n        {\n            SwingUtilities.invokeLater(new Runnable()\n            {\n                public void run()\n                {\n                    initVideoBridgeMenu();\n                }\n            });\n            return;\n        }\n\n        // We create the video default video bridge menu item and set it\n        // disabled until we have more information on video bridge support.\n        if (videoBridgeMenuItem == null)\n        {\n            videoBridgeMenuItem = new VideoBridgeProviderMenuItem(\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.CREATE_VIDEO_BRIDGE\"),\n                        null);\n\n            videoBridgeMenuItem.setEnabled(false);\n\n            insert(videoBridgeMenuItem, 1);\n        }\n\n        // We re-init the video bridge menu item each time the\n        // parent menu is selected in order to be able to refresh the list\n        // of available video bridge active providers.\n        if (videoBridgeMenuListener == null)\n        {\n            videoBridgeMenuListener = new VideoBridgeMenuListener();\n\n            addMenuListener(videoBridgeMenuListener);\n        }\n\n        // Check the protocol providers supporting video bridge in a new thread.\n        if (initVideoBridgeMenuWorker == null)\n            initVideoBridgeMenuWorker\n                = (OSUtils.IS_MAC)\n                    ? new InitVideoBridgeMenuWorkerMacOSX()\n                    : new InitVideoBridgeMenuWorker();\n        else\n            initVideoBridgeMenuWorker.interrupt();\n\n        initVideoBridgeMenuWorker.start();\n    }","commit_id":"6104713520d64ecdddfa2a3c8e822a272aa4011c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Starts this bundle\r\n     *\r\n     * @param bundleContext <tt>BundleContext<\/tt> provided by OSGi framework\r\n     * @throws Exception if something goes wrong during start\r\n     */\r\n    public void start(BundleContext bundleContext) throws Exception\r\n    {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [STARTED]\");\r\n\r\n        UpdateActivator.bundleContext = bundleContext;\r\n\r\n        if (OSUtils.IS_WINDOWS)\r\n        {\r\n            updateService = new Update();\r\n\r\n            bundleContext.registerService(\r\n                UpdateService.class.getName(),\r\n                updateService,\r\n                null);\r\n\r\n            ConfigurationService cfg = getConfiguration();\r\n\r\n            // Register the \"Check for Updates\" menu item if\r\n            // the \"Check for Updates\" property isn't disabled.\r\n            if(!cfg.getBoolean(CHECK_FOR_UPDATES_MENU_DISABLED_PROP, false))\r\n            {\r\n                // Register the \"Check for Updates\" menu item.\r\n                CheckForUpdatesMenuItemComponent\r\n                    checkForUpdatesMenuItemComponent\r\n                    = new CheckForUpdatesMenuItemComponent(\r\n                            Container.CONTAINER_HELP_MENU);\r\n\r\n                Hashtable<String, String> toolsMenuFilter\r\n                    = new Hashtable<String, String>();\r\n                toolsMenuFilter.put(\r\n                        Container.CONTAINER_ID,\r\n                        Container.CONTAINER_HELP_MENU.getID());\r\n\r\n                bundleContext.registerService(\r\n                        PluginComponent.class.getName(),\r\n                        checkForUpdatesMenuItemComponent,\r\n                        toolsMenuFilter);\r\n            }\r\n\r\n            // Check for software update upon startup if enabled.\r\n            if(cfg.getBoolean(UPDATE_ENABLED, true))\r\n                updateService.checkForUpdates(false);\r\n        }\r\n\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [REGISTERED]\");\r\n\r\n        if (configuration.getBoolean(CHECK_FOR_UPDATES_DAILY_ENABLED_PROP,\r\n                                     false))\r\n        {\r\n            logger.info(\"Scheduled update checking enabled\");\r\n\r\n            // Schedule a \"check for updates\" task that will run once a day\r\n            int hoursToWait = calcHoursToWait();\r\n            Runnable updateRunnable = new Runnable()\r\n            {\r\n                public void run()\r\n                {\r\n                    logger.debug(\"Performing scheduled update check\");\r\n                    getUpdateService().checkForUpdates(false);\r\n                }\r\n            };\r\n\r\n            mUpdateExecutor = Executors.newSingleThreadScheduledExecutor();\r\n            mUpdateExecutor.scheduleAtFixedRate(updateRunnable,\r\n                                                hoursToWait,\r\n                                                24,\r\n                                                TimeUnit.HOURS);\r\n        }\r\n    }","id":87853,"modified_method":"/**\r\n     * Starts this bundle\r\n     *\r\n     * @param bundleContext <tt>BundleContext<\/tt> provided by OSGi framework\r\n     * @throws Exception if something goes wrong during start\r\n     */\r\n    public void start(BundleContext bundleContext) throws Exception\r\n    {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [STARTED]\");\r\n\r\n        UpdateActivator.bundleContext = bundleContext;\r\n\r\n        ConfigurationService cfg = getConfiguration();\r\n\r\n        if (OSUtils.IS_WINDOWS)\r\n        {\r\n            updateService = new Update();\r\n\r\n            bundleContext.registerService(\r\n                UpdateService.class.getName(),\r\n                updateService,\r\n                null);\r\n\r\n            // Register the \"Check for Updates\" menu item if\r\n            // the \"Check for Updates\" property isn't disabled.\r\n            if(!cfg.getBoolean(CHECK_FOR_UPDATES_MENU_DISABLED_PROP, false))\r\n            {\r\n                // Register the \"Check for Updates\" menu item.\r\n                CheckForUpdatesMenuItemComponent\r\n                    checkForUpdatesMenuItemComponent\r\n                    = new CheckForUpdatesMenuItemComponent(\r\n                            Container.CONTAINER_HELP_MENU);\r\n\r\n                Hashtable<String, String> toolsMenuFilter\r\n                    = new Hashtable<String, String>();\r\n                toolsMenuFilter.put(\r\n                        Container.CONTAINER_ID,\r\n                        Container.CONTAINER_HELP_MENU.getID());\r\n\r\n                bundleContext.registerService(\r\n                        PluginComponent.class.getName(),\r\n                        checkForUpdatesMenuItemComponent,\r\n                        toolsMenuFilter);\r\n            }\r\n\r\n            // Check for software update upon startup if enabled.\r\n            if(cfg.getBoolean(UPDATE_ENABLED, true))\r\n                updateService.checkForUpdates(false);\r\n        }\r\n\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Update checker [REGISTERED]\");\r\n\r\n        if (cfg.getBoolean(CHECK_FOR_UPDATES_DAILY_ENABLED_PROP,\r\n                                     false))\r\n        {\r\n            logger.info(\"Scheduled update checking enabled\");\r\n\r\n            // Schedule a \"check for updates\" task that will run once a day\r\n            int hoursToWait = calcHoursToWait();\r\n            Runnable updateRunnable = new Runnable()\r\n            {\r\n                public void run()\r\n                {\r\n                    logger.debug(\"Performing scheduled update check\");\r\n                    getUpdateService().checkForUpdates(false);\r\n                }\r\n            };\r\n\r\n            mUpdateExecutor = Executors.newSingleThreadScheduledExecutor();\r\n            mUpdateExecutor.scheduleAtFixedRate(updateRunnable,\r\n                                                hoursToWait,\r\n                                                24,\r\n                                                TimeUnit.HOURS);\r\n        }\r\n    }","commit_id":"6104713520d64ecdddfa2a3c8e822a272aa4011c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the service implementation, and puts it in a state where it\n     * could interoperate with other services.\n     *\n     * @param sipAddress the account id/uin/screenname of the account that we're\n     * about to create\n     * @param accountID the identifier of the account that this protocol\n     * provider represents.\n     *\n     * @throws OperationFailedException with code INTERNAL_ERROR if we fail\n     * initializing the SIP Stack.\n     * @throws java.lang.IllegalArgumentException if one or more of the account\n     * properties have invalid values.\n     *\n     * @see net.java.sip.communicator.service.protocol.AccountID\n     */\n    protected void initialize(String    sipAddress,\n                              SipAccountID accountID)\n        throws OperationFailedException, IllegalArgumentException\n    {\n        synchronized (initializationLock)\n        {\n\n            this.accountID = accountID;\n\n            String protocolIconPath =\n                accountID\n                    .getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);\n\n            if (protocolIconPath == null)\n                protocolIconPath = \"resources/images/protocol/sip\";\n\n            this.protocolIcon = new ProtocolIconSipImpl(protocolIconPath);\n\n            this.sipStatusEnum = new SipStatusEnum(protocolIconPath);\n\n            if(sipStackSharing == null)\n                sipStackSharing = new SipStackSharing();\n\n            // get the presence options\n            boolean enablePresence =\n                accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.IS_PRESENCE_ENABLED, true);\n\n            boolean forceP2P = accountID.getAccountPropertyBoolean(\n                            ProtocolProviderFactory.FORCE_P2P_MODE, true);\n\n            int pollingValue =\n                accountID.getAccountPropertyInt(\n                    ProtocolProviderFactory.POLLING_PERIOD, 30);\n\n            int subscriptionExpiration =\n                accountID.getAccountPropertyInt(\n                    ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION, 3600);\n\n            //create SIP factories.\n            headerFactory = new HeaderFactoryImpl();\n            addressFactory = new AddressFactoryImpl();\n\n            //initialize our display name\n            ourDisplayName = accountID.getAccountPropertyString(\n                                    ProtocolProviderFactory.DISPLAY_NAME);\n\n            if(ourDisplayName == null\n               || ourDisplayName.trim().length() == 0)\n            {\n                ourDisplayName = accountID.getUserID();\n            }\n\n            //init our call processor\n            OperationSetBasicTelephonySipImpl opSetBasicTelephonySipImpl\n                = new OperationSetBasicTelephonySipImpl(this);\n\n            boolean isCallingDisabled\n                = SipActivator.getConfigurationService()\n                    .getBoolean(IS_CALLING_DISABLED, false);\n\n            boolean isCallingDisabledForAccount\n                = accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,\n                    false);\n\n            if (!isCallingDisabled && !isCallingDisabledForAccount)\n            {\n                addSupportedOperationSet(\n                    OperationSetBasicTelephony.class,\n                    opSetBasicTelephonySipImpl);\n\n                addSupportedOperationSet(\n                    OperationSetAdvancedTelephony.class,\n                    opSetBasicTelephonySipImpl);\n\n                OperationSetAutoAnswerSipImpl autoAnswerOpSet\n                    = new OperationSetAutoAnswerSipImpl(this);\n                addSupportedOperationSet(\n                    OperationSetBasicAutoAnswer.class, autoAnswerOpSet);\n                addSupportedOperationSet(\n                    OperationSetAdvancedAutoAnswer.class, autoAnswerOpSet);\n\n                // init call security\n                addSupportedOperationSet(\n                    OperationSetSecureZrtpTelephony.class,\n                    opSetBasicTelephonySipImpl);\n                addSupportedOperationSet(\n                    OperationSetSecureSDesTelephony.class,\n                    opSetBasicTelephonySipImpl);\n\n                // OperationSetVideoTelephony\n                addSupportedOperationSet(\n                    OperationSetVideoTelephony.class,\n                    new OperationSetVideoTelephonySipImpl(\n                            opSetBasicTelephonySipImpl));\n\n                addSupportedOperationSet(\n                    OperationSetTelephonyConferencing.class,\n                    new OperationSetTelephonyConferencingSipImpl(this));\n\n                // init DTMF (from JM Heitz)\n                OperationSetDTMFSipImpl operationSetDTMFSip\n                    = new OperationSetDTMFSipImpl(this);\n                addSupportedOperationSet(\n                    OperationSetDTMF.class, operationSetDTMFSip);\n\n                addSupportedOperationSet(\n                    OperationSetIncomingDTMF.class,\n                    new OperationSetIncomingDTMFSipImpl(\n                            this, operationSetDTMFSip));\n\n                boolean isDesktopStreamingDisabled\n                    = SipActivator.getConfigurationService()\n                        .getBoolean(IS_DESKTOP_STREAMING_DISABLED, false);\n\n                boolean isAccountDesktopStreamingDisabled\n                    = accountID.getAccountPropertyBoolean(\n                        ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,\n                        false);\n\n                if (!isDesktopStreamingDisabled\n                    && !isAccountDesktopStreamingDisabled)\n                {\n                    // OperationSetDesktopStreaming\n                    addSupportedOperationSet(\n                        OperationSetDesktopStreaming.class,\n                        new OperationSetDesktopStreamingSipImpl(\n                                opSetBasicTelephonySipImpl));\n\n                    // OperationSetDesktopSharingServer\n                    addSupportedOperationSet(\n                       OperationSetDesktopSharingServer.class,\n                       new OperationSetDesktopSharingServerSipImpl(\n                               opSetBasicTelephonySipImpl));\n\n                    // OperationSetDesktopSharingClient\n                    addSupportedOperationSet(\n                        OperationSetDesktopSharingClient.class,\n                        new OperationSetDesktopSharingClientSipImpl(this));\n                }\n            }\n\n            if (enablePresence)\n            {\n                //init presence op set.\n                OperationSetPersistentPresence opSetPersPresence\n                    = new OperationSetPresenceSipImpl(this, enablePresence,\n                            forceP2P, pollingValue, subscriptionExpiration);\n\n                addSupportedOperationSet(\n                    OperationSetPersistentPresence.class,\n                    opSetPersPresence);\n                //also register with standard presence\n                addSupportedOperationSet(\n                    OperationSetPresence.class,\n                    opSetPersPresence);\n\n                // init instant messaging\n                OperationSetBasicInstantMessagingSipImpl opSetBasicIM =\n                    new OperationSetBasicInstantMessagingSipImpl(this);\n\n                addSupportedOperationSet(\n                    OperationSetBasicInstantMessaging.class,\n                    opSetBasicIM);\n\n                // init typing notifications\n                addSupportedOperationSet(\n                    OperationSetTypingNotifications.class,\n                    new OperationSetTypingNotificationsSipImpl(\n                            this,\n                            opSetBasicIM));\n\n                OperationSetServerStoredAccountInfoSipImpl opSetSSAccountInfo =\n                    new OperationSetServerStoredAccountInfoSipImpl(this);\n\n                // Set the display name.\n                if(opSetSSAccountInfo != null)\n                    opSetSSAccountInfo.setOurDisplayName(ourDisplayName);\n\n                // init avatar\n                addSupportedOperationSet(\n                    OperationSetServerStoredAccountInfo.class,\n                    opSetSSAccountInfo);\n\n                addSupportedOperationSet(\n                    OperationSetAvatar.class,\n                    new OperationSetAvatarSipImpl(this, opSetSSAccountInfo));\n            }\n\n            // MWI is enabled by default\n            if(accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.VOICEMAIL_ENABLED,\n                    true))\n            {\n                addSupportedOperationSet(\n                    OperationSetMessageWaiting.class,\n                    new OperationSetMessageWaitingSipImpl(this));\n            }\n\n            //initialize our OPTIONS handler\n            new ClientCapabilities(this);\n\n            //init the security manager\n            this.sipSecurityManager = new SipSecurityManager(accountID);\n            sipSecurityManager.setHeaderFactory(headerFactory);\n\n            // register any available custom extensions\n            ProtocolProviderExtensions.registerCustomOperationSets(this);\n\n            isInitialized = true;\n        }\n    }","id":87854,"modified_method":"/**\n     * Initializes the service implementation, and puts it in a state where it\n     * could interoperate with other services.\n     *\n     * @param sipAddress the account id/uin/screenname of the account that we're\n     * about to create\n     * @param accountID the identifier of the account that this protocol\n     * provider represents.\n     *\n     * @throws OperationFailedException with code INTERNAL_ERROR if we fail\n     * initializing the SIP Stack.\n     * @throws java.lang.IllegalArgumentException if one or more of the account\n     * properties have invalid values.\n     *\n     * @see net.java.sip.communicator.service.protocol.AccountID\n     */\n    protected void initialize(String    sipAddress,\n                              SipAccountID accountID)\n        throws OperationFailedException, IllegalArgumentException\n    {\n        synchronized (initializationLock)\n        {\n\n            this.accountID = accountID;\n\n            String protocolIconPath =\n                accountID\n                    .getAccountPropertyString(ProtocolProviderFactory.PROTOCOL_ICON_PATH);\n\n            if (protocolIconPath == null)\n                protocolIconPath = \"resources/images/protocol/sip\";\n\n            this.protocolIcon = new ProtocolIconSipImpl(protocolIconPath);\n\n            this.sipStatusEnum = new SipStatusEnum(protocolIconPath);\n\n            if(sipStackSharing == null)\n                sipStackSharing = new SipStackSharing();\n\n            // get the presence options\n            boolean enablePresence =\n                accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.IS_PRESENCE_ENABLED, true);\n\n            boolean forceP2P = accountID.getAccountPropertyBoolean(\n                            ProtocolProviderFactory.FORCE_P2P_MODE, true);\n\n            int pollingValue =\n                accountID.getAccountPropertyInt(\n                    ProtocolProviderFactory.POLLING_PERIOD, 30);\n\n            int subscriptionExpiration =\n                accountID.getAccountPropertyInt(\n                    ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION, 3600);\n\n            //create SIP factories.\n            headerFactory = new HeaderFactoryImpl();\n            addressFactory = new AddressFactoryImpl();\n\n            //initialize our display name\n            ourDisplayName = accountID.getAccountPropertyString(\n                                    ProtocolProviderFactory.DISPLAY_NAME);\n\n            if(ourDisplayName == null\n               || ourDisplayName.trim().length() == 0)\n            {\n                ourDisplayName = accountID.getUserID();\n            }\n\n            //init our call processor\n            OperationSetBasicTelephonySipImpl opSetBasicTelephonySipImpl\n                = new OperationSetBasicTelephonySipImpl(this);\n\n            boolean isCallingDisabled\n                = SipActivator.getConfigurationService()\n                    .getBoolean(IS_CALLING_DISABLED, false);\n\n            boolean isCallingDisabledForAccount\n                = accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.IS_CALLING_DISABLED_FOR_ACCOUNT,\n                    false);\n\n            if (!isCallingDisabled && !isCallingDisabledForAccount)\n            {\n                addSupportedOperationSet(\n                    OperationSetBasicTelephony.class,\n                    opSetBasicTelephonySipImpl);\n\n                addSupportedOperationSet(\n                    OperationSetAdvancedTelephony.class,\n                    opSetBasicTelephonySipImpl);\n\n                OperationSetAutoAnswerSipImpl autoAnswerOpSet\n                    = new OperationSetAutoAnswerSipImpl(this);\n                addSupportedOperationSet(\n                    OperationSetBasicAutoAnswer.class, autoAnswerOpSet);\n                addSupportedOperationSet(\n                    OperationSetAdvancedAutoAnswer.class, autoAnswerOpSet);\n\n                // init call security\n                addSupportedOperationSet(\n                    OperationSetSecureZrtpTelephony.class,\n                    opSetBasicTelephonySipImpl);\n                addSupportedOperationSet(\n                    OperationSetSecureSDesTelephony.class,\n                    opSetBasicTelephonySipImpl);\n\n                // OperationSetVideoTelephony\n                addSupportedOperationSet(\n                    OperationSetVideoTelephony.class,\n                    new OperationSetVideoTelephonySipImpl(\n                            opSetBasicTelephonySipImpl));\n\n                addSupportedOperationSet(\n                    OperationSetTelephonyConferencing.class,\n                    new OperationSetTelephonyConferencingSipImpl(this));\n\n                // init DTMF (from JM Heitz)\n                OperationSetDTMFSipImpl operationSetDTMFSip\n                    = new OperationSetDTMFSipImpl(this);\n                addSupportedOperationSet(\n                    OperationSetDTMF.class, operationSetDTMFSip);\n\n                addSupportedOperationSet(\n                    OperationSetIncomingDTMF.class,\n                    new OperationSetIncomingDTMFSipImpl(\n                            this, operationSetDTMFSip));\n\n                boolean isDesktopStreamingDisabled\n                    = SipActivator.getConfigurationService()\n                        .getBoolean(IS_DESKTOP_STREAMING_DISABLED, false);\n\n                boolean isAccountDesktopStreamingDisabled\n                    = accountID.getAccountPropertyBoolean(\n                        ProtocolProviderFactory.IS_DESKTOP_STREAMING_DISABLED,\n                        false);\n\n                if (!isDesktopStreamingDisabled\n                    && !isAccountDesktopStreamingDisabled)\n                {\n                    // OperationSetDesktopStreaming\n                    addSupportedOperationSet(\n                        OperationSetDesktopStreaming.class,\n                        new OperationSetDesktopStreamingSipImpl(\n                                opSetBasicTelephonySipImpl));\n\n                    // OperationSetDesktopSharingServer\n                    addSupportedOperationSet(\n                       OperationSetDesktopSharingServer.class,\n                       new OperationSetDesktopSharingServerSipImpl(\n                               opSetBasicTelephonySipImpl));\n\n                    // OperationSetDesktopSharingClient\n                    addSupportedOperationSet(\n                        OperationSetDesktopSharingClient.class,\n                        new OperationSetDesktopSharingClientSipImpl(this));\n                }\n            }\n\n            if (enablePresence)\n            {\n                //init presence op set.\n                OperationSetPersistentPresence opSetPersPresence\n                    = new OperationSetPresenceSipImpl(this, enablePresence,\n                            forceP2P, pollingValue, subscriptionExpiration);\n\n                addSupportedOperationSet(\n                    OperationSetPersistentPresence.class,\n                    opSetPersPresence);\n                //also register with standard presence\n                addSupportedOperationSet(\n                    OperationSetPresence.class,\n                    opSetPersPresence);\n\n                // Only init messaging and typing if enabled.\n                boolean isMessagingDisabled\n                    = SipActivator.getConfigurationService()\n                        .getBoolean(IS_MESSAGING_DISABLED, false);\n\n                if (!isMessagingDisabled)\n                {\n                    // init instant messaging\n                    OperationSetBasicInstantMessagingSipImpl opSetBasicIM =\n                        new OperationSetBasicInstantMessagingSipImpl(this);\n\n                    addSupportedOperationSet(\n                        OperationSetBasicInstantMessaging.class,\n                        opSetBasicIM);\n\n                    // init typing notifications\n                    addSupportedOperationSet(\n                        OperationSetTypingNotifications.class,\n                        new OperationSetTypingNotificationsSipImpl(\n                            this,\n                            opSetBasicIM));\n                }\n\n                OperationSetServerStoredAccountInfoSipImpl opSetSSAccountInfo =\n                    new OperationSetServerStoredAccountInfoSipImpl(this);\n\n                // Set the display name.\n                if(opSetSSAccountInfo != null)\n                    opSetSSAccountInfo.setOurDisplayName(ourDisplayName);\n\n                // init avatar\n                addSupportedOperationSet(\n                    OperationSetServerStoredAccountInfo.class,\n                    opSetSSAccountInfo);\n\n                addSupportedOperationSet(\n                    OperationSetAvatar.class,\n                    new OperationSetAvatarSipImpl(this, opSetSSAccountInfo));\n            }\n\n            // MWI is enabled by default\n            if(accountID.getAccountPropertyBoolean(\n                    ProtocolProviderFactory.VOICEMAIL_ENABLED,\n                    true))\n            {\n                addSupportedOperationSet(\n                    OperationSetMessageWaiting.class,\n                    new OperationSetMessageWaitingSipImpl(this));\n            }\n\n            //initialize our OPTIONS handler\n            new ClientCapabilities(this);\n\n            //init the security manager\n            this.sipSecurityManager = new SipSecurityManager(accountID);\n            sipSecurityManager.setHeaderFactory(headerFactory);\n\n            // register any available custom extensions\n            ProtocolProviderExtensions.registerCustomOperationSets(this);\n\n            isInitialized = true;\n        }\n    }","commit_id":"3450573e5abec06e227b37e08116e802033c4d11","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SimpleFieldSet getProgressFieldset() {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(false);\n\t\t// don't save basic infrastructure such as ctx and parent\n\t\t// only save details of the request\n\t\tfs.putSingle(\"Type\", \"SplitFileInserter\");\n\t\tfs.put(\"DataLength\", dataLength);\n\t\tfs.put(\"DecompressedLength\", decompressedLength);\n\t\tfs.putSingle(\"CompressionCodec\", compressionCodec.toString());\n\t\tfs.put(\"SplitfileCodec\", splitfileAlgorithm);\n\t\tfs.put(\"Finished\", finished);\n\t\tfs.put(\"SegmentSize\", segmentSize);\n\t\tfs.put(\"CheckSegmentSize\", checkSegmentSize);\n\t\tSimpleFieldSet segs = new SimpleFieldSet(false);\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tsegs.put(Integer.toString(i), segments[i].getProgressFieldset());\n\t\t}\n\t\tsegs.put(\"Count\", segments.length);\n\t\tfs.put(\"Segments\", segs);\n\t\treturn fs;\n\t}","id":87855,"modified_method":"public SimpleFieldSet getProgressFieldset() {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(false);\n\t\t// don't save basic infrastructure such as ctx and parent\n\t\t// only save details of the request\n\t\tfs.putSingle(\"Type\", \"SplitFileInserter\");\n\t\tfs.put(\"DataLength\", dataLength);\n\t\tfs.put(\"DecompressedLength\", decompressedLength);\n\t\tif(compressionCodec != null)\n\t\t\tfs.putSingle(\"CompressionCodec\", compressionCodec.toString());\n\t\tfs.put(\"SplitfileCodec\", splitfileAlgorithm);\n\t\tfs.put(\"Finished\", finished);\n\t\tfs.put(\"SegmentSize\", segmentSize);\n\t\tfs.put(\"CheckSegmentSize\", checkSegmentSize);\n\t\tSimpleFieldSet segs = new SimpleFieldSet(false);\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tsegs.put(Integer.toString(i), segments[i].getProgressFieldset());\n\t\t}\n\t\tsegs.put(\"Count\", segments.length);\n\t\tfs.put(\"Segments\", segs);\n\t\treturn fs;\n\t}","commit_id":"e17fac72cce37708f021d177413ed7c2438f2df6","url":"https://github.com/freenet/fred"},{"original_method":"public SplitFileInserter(BaseClientPutter parent, PutCompletionCallback cb, ClientMetadata clientMetadata, InsertContext ctx, boolean getCHKOnly, boolean metadata, Object token, ARCHIVE_TYPE archiveType, SimpleFieldSet fs) throws ResumeException {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tthis.parent = parent;\n\t\tthis.archiveType = archiveType;\n\t\tthis.token = token;\n\t\tthis.finished = false;\n\t\tthis.isMetadata = metadata;\n\t\tthis.cm = clientMetadata;\n\t\tthis.getCHKOnly = getCHKOnly;\n\t\tthis.cb = cb;\n\t\tthis.ctx = ctx;\n\t\t// Don't read finished, wait for the segmentFinished()'s.\n\t\tString length = fs.get(\"DataLength\");\n\t\tif(length == null) throw new ResumeException(\"No DataLength\");\n\t\ttry {\n\t\t\tdataLength = Long.parseLong(length);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt DataLength: \"+e+\" : \"+length);\n\t\t}\n\t\tlength = fs.get(\"DecompressedLength\");\n\t\tlong dl = 0; // back compat\n\t\tif(length != null) {\n\t\t\ttry {\n\t\t\t\tdl = Long.parseLong(length);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tdl = -1;\n\t\t\t}\n\t\t}\n\t\tdecompressedLength = dl;\n\t\tString tmp = fs.get(\"SegmentSize\");\n\t\tif(length == null) throw new ResumeException(\"No SegmentSize\");\n\t\ttry {\n\t\t\tsegmentSize = Integer.parseInt(tmp);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt SegmentSize: \"+e+\" : \"+length);\n\t\t}\n\t\ttmp = fs.get(\"CheckSegmentSize\");\n\t\tif(length == null) throw new ResumeException(\"No CheckSegmentSize\");\n\t\ttry {\n\t\t\tcheckSegmentSize = Integer.parseInt(tmp);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt CheckSegmentSize: \"+e+\" : \"+length);\n\t\t}\n\t\tString ccodec = fs.get(\"CompressionCodec\");\n\t\tif(ccodec == null)\n\t\t\tthrow new ResumeException(\"No compression codec\");\n\t\tcompressionCodec = COMPRESSOR_TYPE.valueOf(ccodec);\n\t\tString scodec = fs.get(\"SplitfileCodec\");\n\t\tif(scodec == null) throw new ResumeException(\"No splitfile codec\");\n\t\ttry {\n\t\t\tsplitfileAlgorithm = Short.parseShort(scodec);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt SplitfileCodec: \"+e+\" : \"+scodec);\n\t\t}\n\t\tSimpleFieldSet segFS = fs.subset(\"Segments\");\n\t\tif(segFS == null) throw new ResumeException(\"No segments\");\n\t\tString segc = segFS.get(\"Count\");\n\t\tif(segc == null) throw new ResumeException(\"No segment count\");\n\t\tint segmentCount;\n\t\ttry {\n\t\t\tsegmentCount = Integer.parseInt(segc);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt segment count: \"+e+\" : \"+segc);\n\t\t}\n\t\tsegments = new SplitFileInserterSegment[segmentCount];\n\t\t\n\t\tint dataBlocks = 0;\n\t\tint checkBlocks = 0;\n\t\t\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tString index = Integer.toString(i);\n\t\t\tSimpleFieldSet segment = segFS.subset(index);\n\t\t\tsegFS.removeSubset(index);\n\t\t\tif(segment == null) throw new ResumeException(\"No segment \"+i);\n\t\t\tsegments[i] = new SplitFileInserterSegment(this, segment, splitfileAlgorithm, ctx, getCHKOnly, i);\n\t\t\tdataBlocks += segments[i].countDataBlocks();\n\t\t\tcheckBlocks += segments[i].countCheckBlocks();\n\t\t}\n\t\t\n\t\tthis.countDataBlocks = dataBlocks;\n\t\tthis.countCheckBlocks = checkBlocks;\n\t}","id":87856,"modified_method":"public SplitFileInserter(BaseClientPutter parent, PutCompletionCallback cb, ClientMetadata clientMetadata, InsertContext ctx, boolean getCHKOnly, boolean metadata, Object token, ARCHIVE_TYPE archiveType, SimpleFieldSet fs) throws ResumeException {\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tthis.parent = parent;\n\t\tthis.archiveType = archiveType;\n\t\tthis.token = token;\n\t\tthis.finished = false;\n\t\tthis.isMetadata = metadata;\n\t\tthis.cm = clientMetadata;\n\t\tthis.getCHKOnly = getCHKOnly;\n\t\tthis.cb = cb;\n\t\tthis.ctx = ctx;\n\t\t// Don't read finished, wait for the segmentFinished()'s.\n\t\tString length = fs.get(\"DataLength\");\n\t\tif(length == null) throw new ResumeException(\"No DataLength\");\n\t\ttry {\n\t\t\tdataLength = Long.parseLong(length);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt DataLength: \"+e+\" : \"+length);\n\t\t}\n\t\tlength = fs.get(\"DecompressedLength\");\n\t\tlong dl = 0; // back compat\n\t\tif(length != null) {\n\t\t\ttry {\n\t\t\t\tdl = Long.parseLong(length);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tdl = -1;\n\t\t\t}\n\t\t}\n\t\tdecompressedLength = dl;\n\t\tString tmp = fs.get(\"SegmentSize\");\n\t\tif(length == null) throw new ResumeException(\"No SegmentSize\");\n\t\ttry {\n\t\t\tsegmentSize = Integer.parseInt(tmp);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt SegmentSize: \"+e+\" : \"+length);\n\t\t}\n\t\ttmp = fs.get(\"CheckSegmentSize\");\n\t\tif(length == null) throw new ResumeException(\"No CheckSegmentSize\");\n\t\ttry {\n\t\t\tcheckSegmentSize = Integer.parseInt(tmp);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt CheckSegmentSize: \"+e+\" : \"+length);\n\t\t}\n\t\tString ccodec = fs.get(\"CompressionCodec\");\n\t\tCOMPRESSOR_TYPE compressor = null;\n\t\tif(ccodec != null) {\n\t\t\ttry {\n\t\t\t\tcompressor = COMPRESSOR_TYPE.valueOf(ccodec);\n\t\t\t} catch (Throwable t) {\n\t\t\t\ttry {\n\t\t\t\t\tshort codecNo = Short.parseShort(ccodec);\n\t\t\t\t\tcompressor = COMPRESSOR_TYPE.getCompressorByMetadataID(codecNo);\n\t\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t\t\tthrow new ResumeException(\"Invalid compression codec: \"+ccodec);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcompressionCodec = compressor;\n\t\tString scodec = fs.get(\"SplitfileCodec\");\n\t\tif(scodec == null) throw new ResumeException(\"No splitfile codec\");\n\t\ttry {\n\t\t\tsplitfileAlgorithm = Short.parseShort(scodec);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt SplitfileCodec: \"+e+\" : \"+scodec);\n\t\t}\n\t\tSimpleFieldSet segFS = fs.subset(\"Segments\");\n\t\tif(segFS == null) throw new ResumeException(\"No segments\");\n\t\tString segc = segFS.get(\"Count\");\n\t\tif(segc == null) throw new ResumeException(\"No segment count\");\n\t\tint segmentCount;\n\t\ttry {\n\t\t\tsegmentCount = Integer.parseInt(segc);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ResumeException(\"Corrupt segment count: \"+e+\" : \"+segc);\n\t\t}\n\t\tsegments = new SplitFileInserterSegment[segmentCount];\n\t\t\n\t\tint dataBlocks = 0;\n\t\tint checkBlocks = 0;\n\t\t\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tString index = Integer.toString(i);\n\t\t\tSimpleFieldSet segment = segFS.subset(index);\n\t\t\tsegFS.removeSubset(index);\n\t\t\tif(segment == null) throw new ResumeException(\"No segment \"+i);\n\t\t\tsegments[i] = new SplitFileInserterSegment(this, segment, splitfileAlgorithm, ctx, getCHKOnly, i);\n\t\t\tdataBlocks += segments[i].countDataBlocks();\n\t\t\tcheckBlocks += segments[i].countCheckBlocks();\n\t\t}\n\t\t\n\t\tthis.countDataBlocks = dataBlocks;\n\t\tthis.countCheckBlocks = checkBlocks;\n\t}","commit_id":"e17fac72cce37708f021d177413ed7c2438f2df6","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic SimpleFieldSet getFieldSet() {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(true);\n\t\tfs.putSingle(\"Identifier\", identifier);\n\t\tfs.putSingle(\"URI\", uri.toString(false, false));\n\t\tfs.putSingle(\"PrivateURI\", privateURI.toString(false, false));\n\t\tfs.put(\"Verbosity\", verbosity);\n\t\tfs.put(\"PriorityClass\", priorityClass);\n\t\tfs.putSingle(\"UploadFrom\", ClientPutMessage.uploadFromString(uploadFrom));\n\t\tfs.putSingle(\"Persistence\", ClientRequest.persistenceTypeString(persistenceType));\n\t\tif(origFilename != null)\n\t\t\tfs.putSingle(\"Filename\", origFilename.getAbsolutePath());\n\t\tif(targetURI != null)\n\t\t\tfs.putSingle(\"TargetURI\", targetURI.toString());\n\t\tif(mimeType != null)\n\t\t\tfs.putSingle(\"Metadata.ContentType\", mimeType);\n\t\tfs.put(\"Global\", global);\n\t\tif(size != -1)\n\t\t\tfs.put(\"DataLength\", size);\n\t\tif(token != null)\n\t\t\tfs.putSingle(\"ClientToken\", token);\n\t\tfs.put(\"Started\", started);\n\t\tfs.put(\"MaxRetries\", maxRetries);\n\t\tif(targetFilename != null)\n\t\t\tfs.putSingle(\"TargetFilename\", targetFilename);\n\t\tif(binaryBlob)\n\t\t\tfs.put(\"BinaryBlob\", binaryBlob);\n\t\tfs.putOverwrite(\"CompatibilityMode\", compatMode.name());\n\t\tfs.put(\"DontCompress\", dontCompress);\n\t\tif(compressorDescriptor != null)\n\t\t\tfs.putSingle(\"Codecs\", compressorDescriptor);\n\t\tfs.put(\"RealTime\", realTime);\n\t\tif(splitfileCryptoKey != null)\n\t\t\tfs.putSingle(\"SplitfileCryptoKey\", HexUtil.bytesToHex(splitfileCryptoKey));\n\t\treturn fs;\n\t}","id":87857,"modified_method":"@Override\n\tpublic SimpleFieldSet getFieldSet() {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(true);\n\t\tfs.putSingle(\"Identifier\", identifier);\n\t\tfs.putSingle(\"URI\", uri.toString(false, false));\n\t\tif(privateURI != null)\n\t\t\tfs.putSingle(\"PrivateURI\", privateURI.toString(false, false));\n\t\tfs.put(\"Verbosity\", verbosity);\n\t\tfs.put(\"PriorityClass\", priorityClass);\n\t\tfs.putSingle(\"UploadFrom\", ClientPutMessage.uploadFromString(uploadFrom));\n\t\tfs.putSingle(\"Persistence\", ClientRequest.persistenceTypeString(persistenceType));\n\t\tif(origFilename != null)\n\t\t\tfs.putSingle(\"Filename\", origFilename.getAbsolutePath());\n\t\tif(targetURI != null)\n\t\t\tfs.putSingle(\"TargetURI\", targetURI.toString());\n\t\tif(mimeType != null)\n\t\t\tfs.putSingle(\"Metadata.ContentType\", mimeType);\n\t\tfs.put(\"Global\", global);\n\t\tif(size != -1)\n\t\t\tfs.put(\"DataLength\", size);\n\t\tif(token != null)\n\t\t\tfs.putSingle(\"ClientToken\", token);\n\t\tfs.put(\"Started\", started);\n\t\tfs.put(\"MaxRetries\", maxRetries);\n\t\tif(targetFilename != null)\n\t\t\tfs.putSingle(\"TargetFilename\", targetFilename);\n\t\tif(binaryBlob)\n\t\t\tfs.put(\"BinaryBlob\", binaryBlob);\n\t\tfs.putOverwrite(\"CompatibilityMode\", compatMode.name());\n\t\tfs.put(\"DontCompress\", dontCompress);\n\t\tif(compressorDescriptor != null)\n\t\t\tfs.putSingle(\"Codecs\", compressorDescriptor);\n\t\tfs.put(\"RealTime\", realTime);\n\t\tif(splitfileCryptoKey != null)\n\t\t\tfs.putSingle(\"SplitfileCryptoKey\", HexUtil.bytesToHex(splitfileCryptoKey));\n\t\treturn fs;\n\t}","commit_id":"be28dba1eec8133cdc93be652118bba9c27df5e3","url":"https://github.com/freenet/fred"},{"original_method":"private SimpleFieldSet generateFieldSet(ObjectContainer container) {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(false); // false because this can get HUGE\n\t\tfs.putSingle(\"Identifier\", identifier);\n\t\tfs.putSingle(\"URI\", uri.toString(false, false));\n\t\tfs.putSingle(\"PrivateURI\", privateURI.toString(false, false));\n\t\tfs.put(\"Verbosity\", verbosity);\n\t\tfs.putSingle(\"Persistence\", ClientRequest.persistenceTypeString(persistenceType));\n\t\tfs.put(\"PriorityClass\", priorityClass);\n\t\tfs.put(\"Global\", global);\n\t\tfs.putSingle(\"PutDirType\", wasDiskPut ? \"disk\" : \"complex\");\n\t\tSimpleFieldSet files = new SimpleFieldSet(false);\n\t\t// Flatten the hierarchy, it can be reconstructed on restarting.\n\t\t// Storing it directly would be a PITA.\n\t\t// FIXME/RESOLVE: The new BaseManifestPutter's container mode does not hold the origin data,\n\t\t//                 after composing the PutHandlers (done in BaseManifestPutter), they are 'lost':\n\t\t//                 A resumed half done container put can not get the complete file list from BaseManifestPutter.\n\t\t//                 Is it really necessary to include the file list here?\n\t\tManifestElement[] elements = SimpleManifestPutter.flatten(manifestElements);\n\t\tfs.putSingle(\"DefaultName\", defaultName);\n\t\tfor(int i=0;i<elements.length;i++) {\n\t\t\tString num = Integer.toString(i);\n\t\t\tManifestElement e = elements[i];\n\t\t\tString mimeOverride = e.getMimeTypeOverride();\n\t\t\tSimpleFieldSet subset = new SimpleFieldSet(false);\n\t\t\tFreenetURI tempURI = e.getTargetURI();\n\t\t\tsubset.putSingle(\"Name\", e.getName());\n\t\t\tif(tempURI != null) {\n\t\t\t\tsubset.putSingle(\"UploadFrom\", \"redirect\");\n\t\t\t\tsubset.putSingle(\"TargetURI\", tempURI.toString());\n\t\t\t} else {\n\t\t\t\t// Deactivate the top, not the middle.\n\t\t\t\t// Deactivating the middle can cause big problems.\n\t\t\t\tBucket origData = e.getData();\n\t\t\t\tBucket data = origData;\n\t\t\t\tboolean deactivate = false;\n\t\t\t\tif(persistenceType == ClientRequest.PERSIST_FOREVER)\n\t\t\t\t\tdeactivate = !container.ext().isActive(data);\n\t\t\t\tif(deactivate)\n\t\t\t\t\tcontainer.activate(data, 1);\n\t\t\t\tif(data instanceof DelayedFreeBucket) {\n\t\t\t\t\tdata = ((DelayedFreeBucket)data).getUnderlying();\n\t\t\t\t}\n\t\t\t\tsubset.put(\"DataLength\", e.getSize());\n\t\t\t\tif(mimeOverride != null)\n\t\t\t\t\tsubset.putSingle(\"Metadata.ContentType\", mimeOverride);\n\t\t\t\t// What to do with the bucket?\n\t\t\t\t// It is either a persistent encrypted bucket or a file bucket ...\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Bucket already freed: \"+e.getData()+\" for \"+e+\" for \"+e.getName()+\" for \"+identifier);\n\t\t\t\t} else if(data instanceof FileBucket) {\n\t\t\t\t\tsubset.putSingle(\"UploadFrom\", \"disk\");\n\t\t\t\t\tsubset.putSingle(\"Filename\", ((FileBucket)data).getFile().getPath());\n\t\t\t\t} else if (data instanceof PaddedEphemerallyEncryptedBucket || data instanceof NullBucket || data instanceof PersistentTempFileBucket || data instanceof TempBucketFactory.TempBucket) {\n\t\t\t\t\tsubset.putSingle(\"UploadFrom\", \"direct\");\n\t\t\t\t} else {\n\t\t\t\t\tthrow new IllegalStateException(\"Don't know what to do with bucket: \"+data);\n\t\t\t\t}\n\t\t\t\tif(deactivate)\n\t\t\t\t\tcontainer.deactivate(origData, 1);\n\t\t\t}\n\t\t\tfiles.put(num, subset);\n\t\t}\n\t\tfiles.put(\"Count\", elements.length);\n\t\tfs.put(\"Files\", files);\n\t\tif(token != null)\n\t\t\tfs.putSingle(\"ClientToken\", token);\n\t\tfs.put(\"Started\", started);\n\t\tfs.put(\"MaxRetries\", maxRetries);\n\t\tfs.put(\"DontCompress\", dontCompress);\n\t\tif(compressorDescriptor != null)\n\t\t\tfs.putSingle(\"Codecs\", compressorDescriptor);\n\t\tfs.put(\"RealTime\", realTime);\n\t\tif(splitfileCryptoKey != null)\n\t\t\tfs.putSingle(\"SplitfileCryptoKey\", HexUtil.bytesToHex(splitfileCryptoKey));\n\t\treturn fs;\n\t}","id":87858,"modified_method":"private SimpleFieldSet generateFieldSet(ObjectContainer container) {\n\t\tSimpleFieldSet fs = new SimpleFieldSet(false); // false because this can get HUGE\n\t\tfs.putSingle(\"Identifier\", identifier);\n\t\tfs.putSingle(\"URI\", uri.toString(false, false));\n\t\tif(privateURI != null)\n\t\t\tfs.putSingle(\"PrivateURI\", privateURI.toString(false, false));\n\t\tfs.put(\"Verbosity\", verbosity);\n\t\tfs.putSingle(\"Persistence\", ClientRequest.persistenceTypeString(persistenceType));\n\t\tfs.put(\"PriorityClass\", priorityClass);\n\t\tfs.put(\"Global\", global);\n\t\tfs.putSingle(\"PutDirType\", wasDiskPut ? \"disk\" : \"complex\");\n\t\tSimpleFieldSet files = new SimpleFieldSet(false);\n\t\t// Flatten the hierarchy, it can be reconstructed on restarting.\n\t\t// Storing it directly would be a PITA.\n\t\t// FIXME/RESOLVE: The new BaseManifestPutter's container mode does not hold the origin data,\n\t\t//                 after composing the PutHandlers (done in BaseManifestPutter), they are 'lost':\n\t\t//                 A resumed half done container put can not get the complete file list from BaseManifestPutter.\n\t\t//                 Is it really necessary to include the file list here?\n\t\tManifestElement[] elements = SimpleManifestPutter.flatten(manifestElements);\n\t\tfs.putSingle(\"DefaultName\", defaultName);\n\t\tfor(int i=0;i<elements.length;i++) {\n\t\t\tString num = Integer.toString(i);\n\t\t\tManifestElement e = elements[i];\n\t\t\tString mimeOverride = e.getMimeTypeOverride();\n\t\t\tSimpleFieldSet subset = new SimpleFieldSet(false);\n\t\t\tFreenetURI tempURI = e.getTargetURI();\n\t\t\tsubset.putSingle(\"Name\", e.getName());\n\t\t\tif(tempURI != null) {\n\t\t\t\tsubset.putSingle(\"UploadFrom\", \"redirect\");\n\t\t\t\tsubset.putSingle(\"TargetURI\", tempURI.toString());\n\t\t\t} else {\n\t\t\t\t// Deactivate the top, not the middle.\n\t\t\t\t// Deactivating the middle can cause big problems.\n\t\t\t\tBucket origData = e.getData();\n\t\t\t\tBucket data = origData;\n\t\t\t\tboolean deactivate = false;\n\t\t\t\tif(persistenceType == ClientRequest.PERSIST_FOREVER)\n\t\t\t\t\tdeactivate = !container.ext().isActive(data);\n\t\t\t\tif(deactivate)\n\t\t\t\t\tcontainer.activate(data, 1);\n\t\t\t\tif(data instanceof DelayedFreeBucket) {\n\t\t\t\t\tdata = ((DelayedFreeBucket)data).getUnderlying();\n\t\t\t\t}\n\t\t\t\tsubset.put(\"DataLength\", e.getSize());\n\t\t\t\tif(mimeOverride != null)\n\t\t\t\t\tsubset.putSingle(\"Metadata.ContentType\", mimeOverride);\n\t\t\t\t// What to do with the bucket?\n\t\t\t\t// It is either a persistent encrypted bucket or a file bucket ...\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Bucket already freed: \"+e.getData()+\" for \"+e+\" for \"+e.getName()+\" for \"+identifier);\n\t\t\t\t} else if(data instanceof FileBucket) {\n\t\t\t\t\tsubset.putSingle(\"UploadFrom\", \"disk\");\n\t\t\t\t\tsubset.putSingle(\"Filename\", ((FileBucket)data).getFile().getPath());\n\t\t\t\t} else if (data instanceof PaddedEphemerallyEncryptedBucket || data instanceof NullBucket || data instanceof PersistentTempFileBucket || data instanceof TempBucketFactory.TempBucket) {\n\t\t\t\t\tsubset.putSingle(\"UploadFrom\", \"direct\");\n\t\t\t\t} else {\n\t\t\t\t\tthrow new IllegalStateException(\"Don't know what to do with bucket: \"+data);\n\t\t\t\t}\n\t\t\t\tif(deactivate)\n\t\t\t\t\tcontainer.deactivate(origData, 1);\n\t\t\t}\n\t\t\tfiles.put(num, subset);\n\t\t}\n\t\tfiles.put(\"Count\", elements.length);\n\t\tfs.put(\"Files\", files);\n\t\tif(token != null)\n\t\t\tfs.putSingle(\"ClientToken\", token);\n\t\tfs.put(\"Started\", started);\n\t\tfs.put(\"MaxRetries\", maxRetries);\n\t\tfs.put(\"DontCompress\", dontCompress);\n\t\tif(compressorDescriptor != null)\n\t\t\tfs.putSingle(\"Codecs\", compressorDescriptor);\n\t\tfs.put(\"RealTime\", realTime);\n\t\tif(splitfileCryptoKey != null)\n\t\t\tfs.putSingle(\"SplitfileCryptoKey\", HexUtil.bytesToHex(splitfileCryptoKey));\n\t\treturn fs;\n\t}","commit_id":"be28dba1eec8133cdc93be652118bba9c27df5e3","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        Project project = getSelectedProject(builder.getUIContext());\n        final ResourcesFacet resourcesFacet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n\n        componentNameFilter.setValueChoices(CamelCommandsHelper.createComponentNameValues(project));\n        componentNameFilter.setDefaultValue(\"<all>\");\n        componentName.setValueChoices(CamelCommandsHelper.createComponentNameValues(project, componentNameFilter, false));\n\n        instanceName.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                String value = componentName.getValue();\n                if (value != null) {\n                    // the component may have a dash, so remove it\n                    value = value.replaceAll(\"-\", \"\");\n                }\n                List<CamelEndpointDetails> endpoints = new ArrayList<>();\n                ResourceVisitor visitor = new XmlResourcesCamelEndpointsVisitor(resourcesFacet, endpoints);\n                resourcesFacet.visitResources(visitor);\n                Iterator<CamelEndpointDetails> it = endpoints.iterator();\n                while (it.hasNext()) {\n                \tCamelEndpointDetails det = it.next();\n                \tif (det.getEndpointInstance() != null) {\n                \t\tif (det.getEndpointInstance().equals(instanceName)) {\n                \t\t\treturn null;\n                \t\t}\n                \t}\n                }\n                return value;\n            }\n        });\n\n        // use value choices instead of completer as that works better in web console\n        xml.setValueChoices(new XmlFileCompleter(resourcesFacet, webResourcesFacet).getFiles());\n        builder.add(componentNameFilter).add(componentName).add(instanceName).add(xml);\n    }","id":87859,"modified_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        Project project = getSelectedProject(builder.getUIContext());\n        final ResourcesFacet resourcesFacet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = null;\n        if (project.hasFacet(WebResourcesFacet.class)) {\n            webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n        }\n\n        componentNameFilter.setValueChoices(CamelCommandsHelper.createComponentNameValues(project));\n        componentNameFilter.setDefaultValue(\"<all>\");\n        componentName.setValueChoices(CamelCommandsHelper.createComponentNameValues(project, componentNameFilter, false));\n\n        instanceName.setDefaultValue(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                String value = componentName.getValue();\n                if (value != null) {\n                    // the component may have a dash, so remove it\n                    value = value.replaceAll(\"-\", \"\");\n                }\n                List<CamelEndpointDetails> endpoints = new ArrayList<>();\n                ResourceVisitor visitor = new XmlResourcesCamelEndpointsVisitor(resourcesFacet, endpoints);\n                resourcesFacet.visitResources(visitor);\n                Iterator<CamelEndpointDetails> it = endpoints.iterator();\n                while (it.hasNext()) {\n                \tCamelEndpointDetails det = it.next();\n                \tif (det.getEndpointInstance() != null) {\n                \t\tif (det.getEndpointInstance().equals(instanceName)) {\n                \t\t\treturn null;\n                \t\t}\n                \t}\n                }\n                return value;\n            }\n        });\n\n        // use value choices instead of completer as that works better in web console\n        xml.setValueChoices(new XmlFileCompleter(resourcesFacet, webResourcesFacet).getFiles());\n        builder.add(componentNameFilter).add(componentName).add(instanceName).add(xml);\n    }","commit_id":"49a1c90f1c2e56d6126d18fd6e6312bd5fd1504d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        Project project = getSelectedProject(builder.getUIContext());\n        ResourcesFacet resourcesFacet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n\n        // use value choices instead of completer as that works better in web console\n        completer = new XmlEndpointsCompleter(resourcesFacet, webResourcesFacet);\n        endpoints.setValueChoices(completer.getEndpointUris());\n\n        builder.add(endpoints);\n    }","id":87860,"modified_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        Project project = getSelectedProject(builder.getUIContext());\n        ResourcesFacet resourcesFacet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = null;\n        if (project.hasFacet(WebResourcesFacet.class)) {\n            webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n        }\n\n        // use value choices instead of completer as that works better in web console\n        completer = new XmlEndpointsCompleter(resourcesFacet, webResourcesFacet);\n        endpoints.setValueChoices(completer.getEndpointUris());\n\n        builder.add(endpoints);\n    }","commit_id":"49a1c90f1c2e56d6126d18fd6e6312bd5fd1504d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        Project project = getSelectedProject(builder.getUIContext());\n        ResourcesFacet resourcesFacet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n\n        // use value choices instead of completer as that works better in web console\n        completer = new XmlEndpointsCompleter(resourcesFacet, webResourcesFacet);\n        endpoints.setValueChoices(completer.getEndpointUris());\n        builder.add(endpoints);\n    }","id":87861,"modified_method":"@Override\n    public void initializeUI(UIBuilder builder) throws Exception {\n        Project project = getSelectedProject(builder.getUIContext());\n        ResourcesFacet resourcesFacet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = null;\n        if (project.hasFacet(WebResourcesFacet.class)) {\n            webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n        }\n\n        // use value choices instead of completer as that works better in web console\n        completer = new XmlEndpointsCompleter(resourcesFacet, webResourcesFacet);\n        endpoints.setValueChoices(completer.getEndpointUris());\n        builder.add(endpoints);\n    }","commit_id":"49a1c90f1c2e56d6126d18fd6e6312bd5fd1504d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected Result executeXml(UIExecutionContext context, Map<Object, Object> attributeMap) throws Exception {\n        String camelComponentName = optionalAttributeValue(attributeMap, \"componentName\");\n        String endpointInstanceName = optionalAttributeValue(attributeMap, \"instanceName\");\n        String endpointUrl = mandatoryAttributeValue(attributeMap, \"endpointUri\");\n        String xml = mandatoryAttributeValue(attributeMap, \"xml\");\n        String lineNumber = mandatoryAttributeValue(attributeMap, \"lineNumber\");\n\n        Project project = getSelectedProject(context);\n        ResourcesFacet facet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webFacet = project.getFacet(WebResourcesFacet.class);\n\n        // does the project already have camel?\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return Results.fail(\"The project does not include camel-core\");\n        }\n\n        // lets find the camel component class\n        CamelComponentDetails details = new CamelComponentDetails();\n        Result result = loadCamelComponentDetails(camelComponentName, details);\n        if (result != null) {\n            return result;\n        }\n        // and make sure its dependency is added\n        result = ensureCamelArtifactIdAdded(project, details, dependencyInstaller);\n        if (result != null) {\n            return result;\n        }\n\n        // collect all the options that was set\n        Map<String, String> options = new HashMap<String, String>();\n        for (InputComponent input : inputs) {\n            String key = input.getName();\n            // only use the value if a value was set (and the value is not the same as the default value)\n            if (input.hasValue()) {\n                String value = input.getValue().toString();\n                if (value != null) {\n                    // do not add the value if it match the default value\n                    boolean matchDefault = isDefaultValue(camelComponentName, key, value);\n                    if (!matchDefault) {\n                        options.put(key, value);\n                    }\n                }\n            } else if (input.isRequired() && input.hasDefaultValue()) {\n                // if its required then we need to grab the value\n                String value = input.getValue().toString();\n                if (value != null) {\n                    options.put(key, value);\n                }\n            }\n        }\n\n        CamelCatalog catalog = new DefaultCamelCatalog();\n        // TODO: Camel 2.15.3 asEndpointUriXml\n        String uri = catalog.asEndpointUri(camelComponentName, options);\n        if (uri == null) {\n            return Results.fail(\"Cannot create endpoint uri\");\n        }\n        // TODO need to replace & with &amp;\n        uri = org.apache.camel.util.StringHelper.xmlEncode(uri);\n\n        FileResource file = facet != null ? facet.getResource(xml) : null;\n        if (file == null || !file.exists()) {\n            file = webFacet != null ? webFacet.getWebResource(xml) : null;\n        }\n        if (file == null || !file.exists()) {\n            return Results.fail(\"Cannot find XML file \" + xml);\n        }\n\n        List<String> lines = LineNumberHelper.readLines(file.getResourceInputStream());\n\n        // grab existing line\n\n        // the list is 0-based, and line number is 1-based\n        int idx = lineNumber != null ? Integer.valueOf(lineNumber) - 1 : 0;\n        String line = lines.get(idx);\n\n        // replace uri with new value\n        line = StringHelper.replaceAll(line, endpointUrl, uri);\n        lines.set(idx, line);\n\n        // and save the file back\n        String content = LineNumberHelper.linesToString(lines);\n        file.setContents(content);\n\n        return Results.success(\"Update endpoint uri: \" + uri + \" in XML file \" + xml);\n    }","id":87862,"modified_method":"protected Result executeXml(UIExecutionContext context, Map<Object, Object> attributeMap) throws Exception {\n        String camelComponentName = optionalAttributeValue(attributeMap, \"componentName\");\n        String endpointInstanceName = optionalAttributeValue(attributeMap, \"instanceName\");\n        String endpointUrl = mandatoryAttributeValue(attributeMap, \"endpointUri\");\n        String xml = mandatoryAttributeValue(attributeMap, \"xml\");\n        String lineNumber = mandatoryAttributeValue(attributeMap, \"lineNumber\");\n\n        Project project = getSelectedProject(context);\n        ResourcesFacet facet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = null;\n        if (project.hasFacet(WebResourcesFacet.class)) {\n            webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n        }\n\n        // does the project already have camel?\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return Results.fail(\"The project does not include camel-core\");\n        }\n\n        // lets find the camel component class\n        CamelComponentDetails details = new CamelComponentDetails();\n        Result result = loadCamelComponentDetails(camelComponentName, details);\n        if (result != null) {\n            return result;\n        }\n        // and make sure its dependency is added\n        result = ensureCamelArtifactIdAdded(project, details, dependencyInstaller);\n        if (result != null) {\n            return result;\n        }\n\n        // collect all the options that was set\n        Map<String, String> options = new HashMap<String, String>();\n        for (InputComponent input : inputs) {\n            String key = input.getName();\n            // only use the value if a value was set (and the value is not the same as the default value)\n            if (input.hasValue()) {\n                String value = input.getValue().toString();\n                if (value != null) {\n                    // do not add the value if it match the default value\n                    boolean matchDefault = isDefaultValue(camelComponentName, key, value);\n                    if (!matchDefault) {\n                        options.put(key, value);\n                    }\n                }\n            } else if (input.isRequired() && input.hasDefaultValue()) {\n                // if its required then we need to grab the value\n                String value = input.getValue().toString();\n                if (value != null) {\n                    options.put(key, value);\n                }\n            }\n        }\n\n        CamelCatalog catalog = new DefaultCamelCatalog();\n        String uri = catalog.asEndpointUriXml(camelComponentName, options);\n        if (uri == null) {\n            return Results.fail(\"Cannot create endpoint uri\");\n        }\n\n        FileResource file = facet != null ? facet.getResource(xml) : null;\n        if (file == null || !file.exists()) {\n            file = webResourcesFacet != null ? webResourcesFacet.getWebResource(xml) : null;\n        }\n        if (file == null || !file.exists()) {\n            return Results.fail(\"Cannot find XML file \" + xml);\n        }\n\n        List<String> lines = LineNumberHelper.readLines(file.getResourceInputStream());\n\n        // grab existing line\n\n        // the list is 0-based, and line number is 1-based\n        int idx = lineNumber != null ? Integer.valueOf(lineNumber) - 1 : 0;\n        String line = lines.get(idx);\n\n        // replace uri with new value\n        line = StringHelper.replaceAll(line, endpointUrl, uri);\n        lines.set(idx, line);\n\n        // and save the file back\n        String content = LineNumberHelper.linesToString(lines);\n        file.setContents(content);\n\n        return Results.success(\"Update endpoint uri: \" + uri + \" in XML file \" + xml);\n    }","commit_id":"49a1c90f1c2e56d6126d18fd6e6312bd5fd1504d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected Result executeXml(UIExecutionContext context, Map<Object, Object> attributeMap) throws Exception {\n        String camelComponentName = mandatoryAttributeValue(attributeMap, \"componentName\");\n        String endpointInstanceName = mandatoryAttributeValue(attributeMap, \"instanceName\");\n        String xml = mandatoryAttributeValue(attributeMap, \"xml\");\n\n        Project project = getSelectedProject(context);\n        ResourcesFacet facet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webFacet = project.getFacet(WebResourcesFacet.class);\n\n        // does the project already have camel?\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return Results.fail(\"The project does not include camel-core\");\n        }\n\n        // lets find the camel component class\n        CamelComponentDetails details = new CamelComponentDetails();\n        Result result = loadCamelComponentDetails(camelComponentName, details);\n        if (result != null) {\n            return result;\n        }\n        // and make sure its dependency is added\n        result = ensureCamelArtifactIdAdded(project, details, dependencyInstaller);\n        if (result != null) {\n            return result;\n        }\n\n        // collect all the options that was set\n        Map<String, String> options = new HashMap<String, String>();\n        for (InputComponent input : inputs) {\n            String key = input.getName();\n            // only use the value if a value was set\n            if (input.hasValue()) {\n                String value = input.getValue().toString();\n                if (value != null) {\n                    options.put(key, value);\n                }\n            }\n        }\n\n        CamelCatalog catalog = new DefaultCamelCatalog();\n        String uri = catalog.asEndpointUri(camelComponentName, options);\n        if (uri == null) {\n            return Results.fail(\"Cannot create endpoint uri\");\n        }\n\n        // since this is XML we need to escape & as &amp;\n        // to be safe that & is not already &amp; we need to revert it first\n        uri = StringHelper.replaceAll(uri, \"&amp;\", \"&\");\n        uri = StringHelper.replaceAll(uri, \"&\", \"&amp;\");\n        uri = StringHelper.replaceAll(uri, \"<\", \"&lt;\");\n        uri = StringHelper.replaceAll(uri, \">\", \"&gt;\");\n\n        FileResource file = facet != null ? facet.getResource(xml) : null;\n        if (file == null || !file.exists()) {\n            file = webFacet != null ? webFacet.getWebResource(xml) : null;\n        }\n        if (file == null || !file.exists()) {\n            return Results.fail(\"Cannot find XML file \" + xml);\n        }\n\n        Document root = XmlLineNumberParser.parseXml(file.getResourceInputStream());\n\n        String lineNumber;\n\n        // The DOM api is so fucking terrible!\n        if (root != null) {\n            NodeList camels = root.getElementsByTagName(\"camelContext\");\n            // TODO: what about 2+ camel's ?\n            if (camels != null && camels.getLength() == 1) {\n                Node camel = camels.item(0);\n                Node camelContext = null;\n                boolean created = false;\n\n                // find existing by id\n                Node found = null;\n                for (int i = 0; i < camel.getChildNodes().getLength(); i++) {\n                    if (\"camelContext\".equals(camel.getNodeName())) {\n                        camelContext = camel;\n                    }\n\n                    Node child = camel.getChildNodes().item(i);\n                    if (\"camelContext\".equals(child.getNodeName())) {\n                        camelContext = child;\n                    }\n                    if (\"endpoint\".equals(child.getNodeName())) {\n                        // okay its an endpoint so if we can match by id attribute\n                        String id = child.getAttributes().getNamedItem(\"id\").getNodeValue();\n                        if (endpointInstanceName.equals(id)) {\n                            found = child;\n                            break;\n                        }\n                    }\n                }\n\n                int extraSpaces = 0;\n                int extraLines = 0;\n                if (found == null) {\n                    created = true;\n                    found = insertEndpointBefore(camel);\n                    if (found == null) {\n                        // empty so use <camelContext> node\n                        found = camelContext;\n                        extraSpaces = 2;\n                        extraLines = 1;\n                    }\n                }\n\n                if (found == null) {\n                    return Results.fail(\"Cannot find <camelContext> in XML file \" + xml);\n                }\n\n                lineNumber = (String) found.getUserData(XmlLineNumberParser.LINE_NUMBER);\n\n                // if we created a new endpoint, then insert a new line with the endpoint details\n                List<String> lines = LineNumberHelper.readLines(file.getResourceInputStream());\n                String line = String.format(\"<endpoint id=\\\"%s\\\" uri=\\\"%s\\\"/>\", endpointInstanceName, uri);\n\n                // the list is 0-based, and line number is 1-based\n                int idx = lineNumber != null ? Integer.valueOf(lineNumber) - 1 : 0;\n                idx += extraLines;\n                int spaces = LineNumberHelper.leadingSpaces(lines, idx) + extraSpaces;\n                line = LineNumberHelper.padString(line, spaces);\n                if (created) {\n                    lines.add(idx, line);\n                } else {\n                    lines.set(idx, line);\n                }\n\n                // and save the file back\n                String content = LineNumberHelper.linesToString(lines);\n                file.setContents(content);\n\n                if (created) {\n                    return Results.success(\"Added endpoint: \" + endpointInstanceName + \" with uri: \" + uri);\n                } else {\n                    return Results.success(\"Update endpoint: \" + endpointInstanceName + \" with uri: \" + uri);\n                }\n            }\n\n            return Results.fail(\"Cannot find <camelContext> in XML file \" + xml);\n        } else {\n            return Results.fail(\"Cannot parse XML file \" + xml);\n        }\n    }","id":87863,"modified_method":"protected Result executeXml(UIExecutionContext context, Map<Object, Object> attributeMap) throws Exception {\n        String camelComponentName = mandatoryAttributeValue(attributeMap, \"componentName\");\n        String endpointInstanceName = mandatoryAttributeValue(attributeMap, \"instanceName\");\n        String xml = mandatoryAttributeValue(attributeMap, \"xml\");\n\n        Project project = getSelectedProject(context);\n        ResourcesFacet facet = project.getFacet(ResourcesFacet.class);\n        WebResourcesFacet webResourcesFacet = null;\n        if (project.hasFacet(WebResourcesFacet.class)) {\n            webResourcesFacet = project.getFacet(WebResourcesFacet.class);\n        }\n\n        // does the project already have camel?\n        Dependency core = CamelProjectHelper.findCamelCoreDependency(project);\n        if (core == null) {\n            return Results.fail(\"The project does not include camel-core\");\n        }\n\n        // lets find the camel component class\n        CamelComponentDetails details = new CamelComponentDetails();\n        Result result = loadCamelComponentDetails(camelComponentName, details);\n        if (result != null) {\n            return result;\n        }\n        // and make sure its dependency is added\n        result = ensureCamelArtifactIdAdded(project, details, dependencyInstaller);\n        if (result != null) {\n            return result;\n        }\n\n        // collect all the options that was set\n        Map<String, String> options = new HashMap<String, String>();\n        for (InputComponent input : inputs) {\n            String key = input.getName();\n            // only use the value if a value was set\n            if (input.hasValue()) {\n                String value = input.getValue().toString();\n                if (value != null) {\n                    options.put(key, value);\n                }\n            }\n        }\n\n        CamelCatalog catalog = new DefaultCamelCatalog();\n        String uri = catalog.asEndpointUri(camelComponentName, options);\n        if (uri == null) {\n            return Results.fail(\"Cannot create endpoint uri\");\n        }\n\n        // since this is XML we need to escape & as &amp;\n        // to be safe that & is not already &amp; we need to revert it first\n        uri = StringHelper.replaceAll(uri, \"&amp;\", \"&\");\n        uri = StringHelper.replaceAll(uri, \"&\", \"&amp;\");\n        uri = StringHelper.replaceAll(uri, \"<\", \"&lt;\");\n        uri = StringHelper.replaceAll(uri, \">\", \"&gt;\");\n\n        FileResource file = facet != null ? facet.getResource(xml) : null;\n        if (file == null || !file.exists()) {\n            file = webResourcesFacet != null ? webResourcesFacet.getWebResource(xml) : null;\n        }\n        if (file == null || !file.exists()) {\n            return Results.fail(\"Cannot find XML file \" + xml);\n        }\n\n        Document root = XmlLineNumberParser.parseXml(file.getResourceInputStream());\n\n        String lineNumber;\n\n        // The DOM api is so fucking terrible!\n        if (root != null) {\n            NodeList camels = root.getElementsByTagName(\"camelContext\");\n            // TODO: what about 2+ camel's ?\n            if (camels != null && camels.getLength() == 1) {\n                Node camel = camels.item(0);\n                Node camelContext = null;\n                boolean created = false;\n\n                // find existing by id\n                Node found = null;\n                for (int i = 0; i < camel.getChildNodes().getLength(); i++) {\n                    if (\"camelContext\".equals(camel.getNodeName())) {\n                        camelContext = camel;\n                    }\n\n                    Node child = camel.getChildNodes().item(i);\n                    if (\"camelContext\".equals(child.getNodeName())) {\n                        camelContext = child;\n                    }\n                    if (\"endpoint\".equals(child.getNodeName())) {\n                        // okay its an endpoint so if we can match by id attribute\n                        String id = child.getAttributes().getNamedItem(\"id\").getNodeValue();\n                        if (endpointInstanceName.equals(id)) {\n                            found = child;\n                            break;\n                        }\n                    }\n                }\n\n                int extraSpaces = 0;\n                int extraLines = 0;\n                if (found == null) {\n                    created = true;\n                    found = insertEndpointBefore(camel);\n                    if (found == null) {\n                        // empty so use <camelContext> node\n                        found = camelContext;\n                        extraSpaces = 2;\n                        extraLines = 1;\n                    }\n                }\n\n                if (found == null) {\n                    return Results.fail(\"Cannot find <camelContext> in XML file \" + xml);\n                }\n\n                lineNumber = (String) found.getUserData(XmlLineNumberParser.LINE_NUMBER);\n\n                // if we created a new endpoint, then insert a new line with the endpoint details\n                List<String> lines = LineNumberHelper.readLines(file.getResourceInputStream());\n                String line = String.format(\"<endpoint id=\\\"%s\\\" uri=\\\"%s\\\"/>\", endpointInstanceName, uri);\n\n                // the list is 0-based, and line number is 1-based\n                int idx = lineNumber != null ? Integer.valueOf(lineNumber) - 1 : 0;\n                idx += extraLines;\n                int spaces = LineNumberHelper.leadingSpaces(lines, idx) + extraSpaces;\n                line = LineNumberHelper.padString(line, spaces);\n                if (created) {\n                    lines.add(idx, line);\n                } else {\n                    lines.set(idx, line);\n                }\n\n                // and save the file back\n                String content = LineNumberHelper.linesToString(lines);\n                file.setContents(content);\n\n                if (created) {\n                    return Results.success(\"Added endpoint: \" + endpointInstanceName + \" with uri: \" + uri);\n                } else {\n                    return Results.success(\"Update endpoint: \" + endpointInstanceName + \" with uri: \" + uri);\n                }\n            }\n\n            return Results.fail(\"Cannot find <camelContext> in XML file \" + xml);\n        } else {\n            return Results.fail(\"Cannot parse XML file \" + xml);\n        }\n    }","commit_id":"49a1c90f1c2e56d6126d18fd6e6312bd5fd1504d","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n\t * {@inheritDoc}\n\t * <p>\n\t * This method determines the SockJS path and handles SockJS static URLs. Session URLs\n\t * and raw WebSocket requests are delegated to abstract methods.\n\t */\n\t@Override\n\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tWebSocketHandler wsHandler) throws SockJsException {\n\n\t\tString sockJsPath = getSockJsPath(request);\n\t\tif (sockJsPath == null) {\n\t\t\tlogger.warn(\"Could not determine SockJS path for URL \\\"\" + request.getURI().getPath() +\n\t\t\t\t\t\". Consider setting validSockJsPrefixes.\");\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(request.getMethod() + \" with SockJS path [\" + sockJsPath + \"]\");\n\n\t\ttry {\n\t\t\trequest.getHeaders();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tlogger.warn(\"Invalid media type ignored: \" + ex.getMediaType());\n\t\t}\n\n\t\ttry {\n\t\t\tif (sockJsPath.equals(\"\") || sockJsPath.equals(\"/\")) {\n\t\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", Charset.forName(\"UTF-8\")));\n\t\t\t\tresponse.getBody().write(\"Welcome to SockJS!\\n\".getBytes(\"UTF-8\"));\n\t\t\t}\n\t\t\telse if (sockJsPath.equals(\"/info\")) {\n\t\t\t\tthis.infoHandler.handle(request, response);\n\t\t\t}\n\t\t\telse if (sockJsPath.matches(\"/iframe[0-9-.a-z_]*.html\")) {\n\t\t\t\tthis.iframeHandler.handle(request, response);\n\t\t\t}\n\t\t\telse if (sockJsPath.equals(\"/websocket\")) {\n\t\t\t\thandleRawWebSocketRequest(request, response, wsHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), \"/\");\n\t\t\t\tif (pathSegments.length != 3) {\n\t\t\t\t\tlogger.warn(\"Expected \\\"/{server}/{session}/{transport}\\\" but got \\\"\" + sockJsPath + \"\\\"\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString serverId = pathSegments[0];\n\t\t\t\tString sessionId = pathSegments[1];\n\t\t\t\tString transport = pathSegments[2];\n\n\t\t\t\tif (!validateRequest(serverId, sessionId, transport)) {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thandleTransportRequest(request, response, wsHandler, sessionId, transport);\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new SockJsException(\"Failed to write to the response\", null, ex);\n\t\t}\n\t}","id":87864,"modified_method":"/**\n\t * {@inheritDoc}\n\t * <p>\n\t * This method determines the SockJS path and handles SockJS static URLs. Session URLs\n\t * and raw WebSocket requests are delegated to abstract methods.\n\t */\n\t@Override\n\tpublic final void handleRequest(ServerHttpRequest request, ServerHttpResponse response,\n\t\t\tString sockJsPath, WebSocketHandler wsHandler) throws SockJsException {\n\n\t\tif (sockJsPath == null) {\n\t\t\tlogger.warn(\"No SockJS path provided, URI=\\\"\" + request.getURI());\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(request.getMethod() + \" with SockJS path [\" + sockJsPath + \"]\");\n\n\t\ttry {\n\t\t\trequest.getHeaders();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tlogger.warn(\"Invalid media type ignored: \" + ex.getMediaType());\n\t\t}\n\n\t\ttry {\n\t\t\tif (sockJsPath.equals(\"\") || sockJsPath.equals(\"/\")) {\n\t\t\t\tresponse.getHeaders().setContentType(new MediaType(\"text\", \"plain\", Charset.forName(\"UTF-8\")));\n\t\t\t\tresponse.getBody().write(\"Welcome to SockJS!\\n\".getBytes(\"UTF-8\"));\n\t\t\t}\n\t\t\telse if (sockJsPath.equals(\"/info\")) {\n\t\t\t\tthis.infoHandler.handle(request, response);\n\t\t\t}\n\t\t\telse if (sockJsPath.matches(\"/iframe[0-9-.a-z_]*.html\")) {\n\t\t\t\tthis.iframeHandler.handle(request, response);\n\t\t\t}\n\t\t\telse if (sockJsPath.equals(\"/websocket\")) {\n\t\t\t\thandleRawWebSocketRequest(request, response, wsHandler);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), \"/\");\n\t\t\t\tif (pathSegments.length != 3) {\n\t\t\t\t\tlogger.warn(\"Expected \\\"/{server}/{session}/{transport}\\\" but got \\\"\" + sockJsPath + \"\\\"\");\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tString serverId = pathSegments[0];\n\t\t\t\tString sessionId = pathSegments[1];\n\t\t\t\tString transport = pathSegments[2];\n\n\t\t\t\tif (!validateRequest(serverId, sessionId, transport)) {\n\t\t\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thandleTransportRequest(request, response, wsHandler, sessionId, transport);\n\t\t\t}\n\t\t\tresponse.close();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new SockJsException(\"Failed to write to the response\", null, ex);\n\t\t}\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleIframeRequest() throws Exception {\n\n\t\tthis.service.setValidSockJsPrefixes(\"/a\");\n\t\thandleRequest(\"GET\", \"/a/iframe.html\", HttpStatus.OK);\n\n\t\tassertEquals(\"text/html;charset=UTF-8\", this.servletResponse.getContentType());\n\t\tassertTrue(this.servletResponse.getContentAsString().startsWith(\"<!DOCTYPE html>\\n\"));\n\t\tassertEquals(496, this.servletResponse.getContentLength());\n\t\tassertEquals(\"public, max-age=31536000\", this.response.getHeaders().getCacheControl());\n\t\tassertEquals(\"\\\"0da1ed070012f304e47b83c81c48ad620\\\"\", this.response.getHeaders().getETag());\n\t}","id":87865,"modified_method":"@Test\n\tpublic void handleIframeRequest() throws Exception {\n\n\t\thandleRequest(\"GET\", \"/echo/iframe.html\", HttpStatus.OK);\n\n\t\tassertEquals(\"text/html;charset=UTF-8\", this.servletResponse.getContentType());\n\t\tassertTrue(this.servletResponse.getContentAsString().startsWith(\"<!DOCTYPE html>\\n\"));\n\t\tassertEquals(496, this.servletResponse.getContentLength());\n\t\tassertEquals(\"public, max-age=31536000\", this.response.getHeaders().getCacheControl());\n\t\tassertEquals(\"\\\"0da1ed070012f304e47b83c81c48ad620\\\"\", this.response.getHeaders().getETag());\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleInfoOptions() throws Exception {\n\n\t\tthis.servletRequest.addHeader(\"Access-Control-Request-Headers\", \"Last-Modified\");\n\n\t\thandleRequest(\"OPTIONS\", \"/a/info\", HttpStatus.NO_CONTENT);\n\t\tthis.response.flush();\n\n\t\tassertEquals(\"*\", this.servletResponse.getHeader(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.servletResponse.getHeader(\"Access-Control-Allow-Credentials\"));\n\t\tassertEquals(\"Last-Modified\", this.servletResponse.getHeader(\"Access-Control-Allow-Headers\"));\n\t\tassertEquals(\"OPTIONS, GET\", this.servletResponse.getHeader(\"Access-Control-Allow-Methods\"));\n\t\tassertEquals(\"31536000\", this.servletResponse.getHeader(\"Access-Control-Max-Age\"));\n\t}","id":87866,"modified_method":"@Test\n\tpublic void handleInfoOptions() throws Exception {\n\n\t\tthis.servletRequest.addHeader(\"Access-Control-Request-Headers\", \"Last-Modified\");\n\n\t\thandleRequest(\"OPTIONS\", \"/echo/info\", HttpStatus.NO_CONTENT);\n\t\tthis.response.flush();\n\n\t\tassertEquals(\"*\", this.servletResponse.getHeader(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.servletResponse.getHeader(\"Access-Control-Allow-Credentials\"));\n\t\tassertEquals(\"Last-Modified\", this.servletResponse.getHeader(\"Access-Control-Allow-Headers\"));\n\t\tassertEquals(\"OPTIONS, GET\", this.servletResponse.getHeader(\"Access-Control-Allow-Methods\"));\n\t\tassertEquals(\"31536000\", this.servletResponse.getHeader(\"Access-Control-Max-Age\"));\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleIframeRequestNotModified() throws Exception {\n\n\t\tthis.servletRequest.addHeader(\"If-None-Match\", \"\\\"0da1ed070012f304e47b83c81c48ad620\\\"\");\n\n\t\tthis.service.setValidSockJsPrefixes(\"/a\");\n\t\thandleRequest(\"GET\", \"/a/iframe.html\", HttpStatus.NOT_MODIFIED);\n\t}","id":87867,"modified_method":"@Test\n\tpublic void handleIframeRequestNotModified() throws Exception {\n\n\t\tthis.servletRequest.addHeader(\"If-None-Match\", \"\\\"0da1ed070012f304e47b83c81c48ad620\\\"\");\n\n\t\thandleRequest(\"GET\", \"/echo/iframe.html\", HttpStatus.NOT_MODIFIED);\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void handleRequest(String httpMethod, String uri, HttpStatus httpStatus) throws IOException {\n\t\tresetResponse();\n\t\tsetRequest(httpMethod, uri);\n\t\tthis.service.handleRequest(this.request, this.response, this.handler);\n\n\t\tassertEquals(httpStatus.value(), this.servletResponse.getStatus());\n\t}","id":87868,"modified_method":"private void handleRequest(String httpMethod, String uri, HttpStatus httpStatus) throws IOException {\n\t\tresetResponse();\n\t\tsetRequest(httpMethod, uri);\n\t\tString sockJsPath = uri.substring(\"/echo\".length());\n\t\tthis.service.handleRequest(this.request, this.response, sockJsPath, this.handler);\n\n\t\tassertEquals(httpStatus.value(), this.servletResponse.getStatus());\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void validateRequest() throws Exception {\n\n\t\tthis.service.setValidSockJsPrefixes(\"/echo\");\n\n\t\tthis.service.setWebSocketsEnabled(false);\n\t\thandleRequest(\"GET\", \"/echo/server/session/websocket\", HttpStatus.NOT_FOUND);\n\n\t\tthis.service.setWebSocketsEnabled(true);\n\t\thandleRequest(\"GET\", \"/echo/server/session/websocket\", HttpStatus.OK);\n\n\t\thandleRequest(\"GET\", \"/echo//\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo///\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/other\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo//service/websocket\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/server//websocket\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/server/session/\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/s.erver/session/websocket\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/server/s.ession/websocket\", HttpStatus.NOT_FOUND);\n\t}","id":87869,"modified_method":"@Test\n\tpublic void validateRequest() throws Exception {\n\n\t\tthis.service.setWebSocketsEnabled(false);\n\t\thandleRequest(\"GET\", \"/echo/server/session/websocket\", HttpStatus.NOT_FOUND);\n\n\t\tthis.service.setWebSocketsEnabled(true);\n\t\thandleRequest(\"GET\", \"/echo/server/session/websocket\", HttpStatus.OK);\n\n\t\thandleRequest(\"GET\", \"/echo//\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo///\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/other\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo//service/websocket\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/server//websocket\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/server/session/\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/s.erver/session/websocket\", HttpStatus.NOT_FOUND);\n\t\thandleRequest(\"GET\", \"/echo/server/s.ession/websocket\", HttpStatus.NOT_FOUND);\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleRawWebSocketRequest() throws Exception {\n\n\t\thandleRequest(\"GET\", \"/a\", HttpStatus.OK);\n\t\tassertEquals(\"Welcome to SockJS!\\n\", this.servletResponse.getContentAsString());\n\n\t\thandleRequest(\"GET\", \"/a/websocket\", HttpStatus.OK);\n\t\tassertNull(\"Raw WebSocket should not open a SockJS session\", this.service.sessionId);\n\t\tassertSame(this.handler, this.service.handler);\n\t}","id":87870,"modified_method":"@Test\n\tpublic void handleRawWebSocketRequest() throws Exception {\n\n\t\thandleRequest(\"GET\", \"/echo\", HttpStatus.OK);\n\t\tassertEquals(\"Welcome to SockJS!\\n\", this.servletResponse.getContentAsString());\n\n\t\thandleRequest(\"GET\", \"/echo/websocket\", HttpStatus.OK);\n\t\tassertNull(\"Raw WebSocket should not open a SockJS session\", this.service.sessionId);\n\t\tassertSame(this.handler, this.service.handler);\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleInfoGet() throws Exception {\n\n\t\thandleRequest(\"GET\", \"/a/info\", HttpStatus.OK);\n\n\t\tassertEquals(\"application/json;charset=UTF-8\", this.servletResponse.getContentType());\n\t\tassertEquals(\"*\", this.servletResponse.getHeader(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.servletResponse.getHeader(\"Access-Control-Allow-Credentials\"));\n\t\tassertEquals(\"no-store, no-cache, must-revalidate, max-age=0\", this.servletResponse.getHeader(\"Cache-Control\"));\n\n\t\tString body = this.servletResponse.getContentAsString();\n\t\tassertEquals(\"{\\\"entropy\\\"\", body.substring(0, body.indexOf(':')));\n\t\tassertEquals(\",\\\"origins\\\":[\\\"*:*\\\"],\\\"cookie_needed\\\":true,\\\"websocket\\\":true}\",\n\t\t\t\tbody.substring(body.indexOf(',')));\n\n\t\tthis.service.setSessionCookieNeeded(false);\n\t\tthis.service.setWebSocketsEnabled(false);\n\t\thandleRequest(\"GET\", \"/a/info\", HttpStatus.OK);\n\n\t\tbody = this.servletResponse.getContentAsString();\n\t\tassertEquals(\",\\\"origins\\\":[\\\"*:*\\\"],\\\"cookie_needed\\\":false,\\\"websocket\\\":false}\",\n\t\t\t\tbody.substring(body.indexOf(',')));\n\t}","id":87871,"modified_method":"@Test\n\tpublic void handleInfoGet() throws Exception {\n\n\t\thandleRequest(\"GET\", \"/echo/info\", HttpStatus.OK);\n\n\t\tassertEquals(\"application/json;charset=UTF-8\", this.servletResponse.getContentType());\n\t\tassertEquals(\"*\", this.servletResponse.getHeader(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.servletResponse.getHeader(\"Access-Control-Allow-Credentials\"));\n\t\tassertEquals(\"no-store, no-cache, must-revalidate, max-age=0\", this.servletResponse.getHeader(\"Cache-Control\"));\n\n\t\tString body = this.servletResponse.getContentAsString();\n\t\tassertEquals(\"{\\\"entropy\\\"\", body.substring(0, body.indexOf(':')));\n\t\tassertEquals(\",\\\"origins\\\":[\\\"*:*\\\"],\\\"cookie_needed\\\":true,\\\"websocket\\\":true}\",\n\t\t\t\tbody.substring(body.indexOf(',')));\n\n\t\tthis.service.setSessionCookieNeeded(false);\n\t\tthis.service.setWebSocketsEnabled(false);\n\t\thandleRequest(\"GET\", \"/echo/info\", HttpStatus.OK);\n\n\t\tbody = this.servletResponse.getContentAsString();\n\t\tassertEquals(\",\\\"origins\\\":[\\\"*:*\\\"],\\\"cookie_needed\\\":false,\\\"websocket\\\":false}\",\n\t\t\t\tbody.substring(body.indexOf(',')));\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleEmptyContentType() throws Exception {\n\n\t\tservletRequest.setContentType(\"\");\n\t\thandleRequest(\"GET\", \"/a/info\", HttpStatus.OK);\n\n\t\tassertEquals(\"Invalid/empty content should have been ignored\", 200, this.servletResponse.getStatus());\n\t}","id":87872,"modified_method":"@Test\n\tpublic void handleEmptyContentType() throws Exception {\n\n\t\tservletRequest.setContentType(\"\");\n\t\thandleRequest(\"GET\", \"/echo/info\", HttpStatus.OK);\n\n\t\tassertEquals(\"Invalid/empty content should have been ignored\", 200, this.servletResponse.getStatus());\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected SockJsService getSockJsService() {\n\t\t\treturn super.getSockJsService(paths);\n\t\t}","id":87873,"modified_method":"protected SockJsService getSockJsService() {\n\t\t\treturn super.getSockJsService();\n\t\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"final M getMappings() {\n\n\t\tM mappings = createMappings();\n\n\t\tif (this.sockJsServiceRegistration != null) {\n\t\t\tSockJsService sockJsService = this.sockJsServiceRegistration.getSockJsService(getAllPrefixes());\n\t\t\tfor (WebSocketHandler wsHandler : this.handlerMap.keySet()) {\n\t\t\t\tfor (String path : this.handlerMap.get(wsHandler)) {\n\t\t\t\t\tString pathPattern = path.endsWith(\"/\") ? path + \"**\" : path + \"/**\";\n\t\t\t\t\taddSockJsServiceMapping(mappings, sockJsService, wsHandler, pathPattern);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tHandshakeHandler handshakeHandler = getOrCreateHandshakeHandler();\n\t\t\tfor (WebSocketHandler wsHandler : this.handlerMap.keySet()) {\n\t\t\t\tfor (String path : this.handlerMap.get(wsHandler)) {\n\t\t\t\t\taddWebSocketHandlerMapping(mappings, wsHandler, handshakeHandler, this.interceptors, path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappings;\n\t}","id":87874,"modified_method":"final M getMappings() {\n\n\t\tM mappings = createMappings();\n\n\t\tif (this.sockJsServiceRegistration != null) {\n\t\t\tSockJsService sockJsService = this.sockJsServiceRegistration.getSockJsService();\n\t\t\tfor (WebSocketHandler wsHandler : this.handlerMap.keySet()) {\n\t\t\t\tfor (String path : this.handlerMap.get(wsHandler)) {\n\t\t\t\t\tString pathPattern = path.endsWith(\"/\") ? path + \"**\" : path + \"/**\";\n\t\t\t\t\taddSockJsServiceMapping(mappings, sockJsService, wsHandler, pathPattern);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tHandshakeHandler handshakeHandler = getOrCreateHandshakeHandler();\n\t\t\tfor (WebSocketHandler wsHandler : this.handlerMap.keySet()) {\n\t\t\t\tfor (String path : this.handlerMap.get(wsHandler)) {\n\t\t\t\t\taddWebSocketHandlerMapping(mappings, wsHandler, handshakeHandler, this.interceptors, path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mappings;\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleTransportRequestXhrSend() throws Exception {\n\n\t\tsetRequest(\"POST\", sessionUrlPrefix + \"xhr_send\");\n\t\tthis.service.handleRequest(this.request, this.response, this.wsHandler);\n\n\t\tassertEquals(404, this.servletResponse.getStatus()); // no session yet\n\n\t\tresetResponse();\n\t\tsetRequest(\"POST\", sessionUrlPrefix + \"xhr\");\n\t\tthis.service.handleRequest(this.request, this.response, this.wsHandler);\n\n\t\tassertEquals(200, this.servletResponse.getStatus()); // session created\n\t\tverify(this.xhrHandler).handleRequest(this.request, this.response, this.wsHandler, this.session);\n\n\t\tresetResponse();\n\t\tsetRequest(\"POST\", sessionUrlPrefix + \"xhr_send\");\n\t\tthis.service.handleRequest(this.request, this.response, this.wsHandler);\n\n\t\tassertEquals(200, this.servletResponse.getStatus()); // session exists\n\t\tverify(this.xhrSendHandler).handleRequest(this.request, this.response, this.wsHandler, this.session);\n\t}","id":87875,"modified_method":"@Test\n\tpublic void handleTransportRequestXhrSend() throws Exception {\n\n\t\tString sockJsPath = sessionUrlPrefix + \"xhr_send\";\n\t\tsetRequest(\"POST\", sockJsPrefix + sockJsPath);\n\t\tthis.service.handleRequest(this.request, this.response, sockJsPath, this.wsHandler);\n\n\t\tassertEquals(404, this.servletResponse.getStatus()); // no session yet\n\n\t\tresetResponse();\n\t\tsockJsPath = sessionUrlPrefix + \"xhr\";\n\t\tsetRequest(\"POST\", sockJsPrefix + sockJsPath);\n\t\tthis.service.handleRequest(this.request, this.response, sockJsPath, this.wsHandler);\n\n\t\tassertEquals(200, this.servletResponse.getStatus()); // session created\n\t\tverify(this.xhrHandler).handleRequest(this.request, this.response, this.wsHandler, this.session);\n\n\t\tresetResponse();\n\t\tsockJsPath = sessionUrlPrefix + \"xhr_send\";\n\t\tsetRequest(\"POST\", sockJsPrefix + sockJsPath);\n\t\tthis.service.handleRequest(this.request, this.response, sockJsPath, this.wsHandler);\n\n\t\tassertEquals(200, this.servletResponse.getStatus()); // session exists\n\t\tverify(this.xhrSendHandler).handleRequest(this.request, this.response, this.wsHandler, this.session);\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setup() {\n\n\t\tsuper.setUp();\n\n\t\tMockitoAnnotations.initMocks(this);\n\n\t\tMap<String, Object> attributes = Collections.emptyMap();\n\t\tthis.session = new TestSockJsSession(sessionId, new StubSockJsServiceConfig(), this.wsHandler, attributes);\n\n\t\twhen(this.xhrHandler.getTransportType()).thenReturn(TransportType.XHR);\n\t\twhen(this.xhrHandler.createSession(sessionId, this.wsHandler, attributes)).thenReturn(this.session);\n\t\twhen(this.xhrSendHandler.getTransportType()).thenReturn(TransportType.XHR_SEND);\n\n\t\tthis.service = new DefaultSockJsService(this.taskScheduler,\n\t\t\t\tArrays.<TransportHandler>asList(this.xhrHandler, this.xhrSendHandler));\n\t\tthis.service.setValidSockJsPrefixes(sockJsPrefix);\n\t}","id":87876,"modified_method":"@Before\n\tpublic void setup() {\n\n\t\tsuper.setUp();\n\n\t\tMockitoAnnotations.initMocks(this);\n\n\t\tMap<String, Object> attributes = Collections.emptyMap();\n\t\tthis.session = new TestSockJsSession(sessionId, new StubSockJsServiceConfig(), this.wsHandler, attributes);\n\n\t\twhen(this.xhrHandler.getTransportType()).thenReturn(TransportType.XHR);\n\t\twhen(this.xhrHandler.createSession(sessionId, this.wsHandler, attributes)).thenReturn(this.session);\n\t\twhen(this.xhrSendHandler.getTransportType()).thenReturn(TransportType.XHR_SEND);\n\n\t\tthis.service = new DefaultSockJsService(this.taskScheduler,\n\t\t\t\tArrays.<TransportHandler>asList(this.xhrHandler, this.xhrSendHandler));\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleTransportRequestNoSuitableHandler() throws Exception {\n\n\t\tsetRequest(\"POST\", sessionUrlPrefix + \"eventsource\");\n\t\tthis.service.handleRequest(this.request, this.response, this.wsHandler);\n\n\t\tassertEquals(404, this.servletResponse.getStatus());\n\t}","id":87877,"modified_method":"@Test\n\tpublic void handleTransportRequestNoSuitableHandler() throws Exception {\n\n\t\tString sockJsPath = sessionUrlPrefix + \"eventsource\";\n\t\tsetRequest(\"POST\", sockJsPrefix + sockJsPath);\n\t\tthis.service.handleRequest(this.request, this.response, sockJsPath, this.wsHandler);\n\n\t\tassertEquals(404, this.servletResponse.getStatus());\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleTransportRequestXhrOptions() throws Exception {\n\n\t\tsetRequest(\"OPTIONS\", sessionUrlPrefix + \"xhr\");\n\t\tthis.service.handleRequest(this.request, this.response, this.wsHandler);\n\n\t\tassertEquals(204, this.servletResponse.getStatus());\n\t\tassertEquals(\"*\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Credentials\"));\n\t\tassertEquals(\"OPTIONS, POST\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Methods\"));\n\t}","id":87878,"modified_method":"@Test\n\tpublic void handleTransportRequestXhrOptions() throws Exception {\n\n\t\tString sockJsPath = sessionUrlPrefix + \"xhr\";\n\t\tsetRequest(\"OPTIONS\", sockJsPrefix + sockJsPath);\n\t\tthis.service.handleRequest(this.request, this.response, sockJsPath, this.wsHandler);\n\n\t\tassertEquals(204, this.servletResponse.getStatus());\n\t\tassertEquals(\"*\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Credentials\"));\n\t\tassertEquals(\"OPTIONS, POST\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Methods\"));\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void handleTransportRequestXhr() throws Exception {\n\n\t\tsetRequest(\"POST\", sessionUrlPrefix + \"xhr\");\n\t\tthis.service.handleRequest(this.request, this.response, this.wsHandler);\n\n\t\tassertEquals(200, this.servletResponse.getStatus());\n\t\tverify(this.xhrHandler).handleRequest(this.request, this.response, this.wsHandler, this.session);\n\t\tverify(taskScheduler).scheduleAtFixedRate(any(Runnable.class), eq(service.getDisconnectDelay()));\n\n\t\tassertEquals(\"no-store, no-cache, must-revalidate, max-age=0\", this.response.getHeaders().getCacheControl());\n\t\tassertEquals(\"*\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Credentials\"));\n\t}","id":87879,"modified_method":"@Test\n\tpublic void handleTransportRequestXhr() throws Exception {\n\n\t\tString sockJsPath = sessionUrlPrefix + \"xhr\";\n\t\tsetRequest(\"POST\", sockJsPrefix + sockJsPath);\n\t\tthis.service.handleRequest(this.request, this.response, sockJsPath, this.wsHandler);\n\n\t\tassertEquals(200, this.servletResponse.getStatus());\n\t\tverify(this.xhrHandler).handleRequest(this.request, this.response, this.wsHandler, this.session);\n\t\tverify(taskScheduler).scheduleAtFixedRate(any(Runnable.class), eq(service.getDisconnectDelay()));\n\n\t\tassertEquals(\"no-store, no-cache, must-revalidate, max-age=0\", this.response.getHeaders().getCacheControl());\n\t\tassertEquals(\"*\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Origin\"));\n\t\tassertEquals(\"true\", this.response.getHeaders().getFirst(\"Access-Control-Allow-Credentials\"));\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\ttry {\n\t\t\tthis.sockJsService.handleRequest(request, response, this.wsHandler);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow new SockJsException(\"Uncaught failure in SockJS request, uri=\" + request.getURI(), t);\n\t\t}\n\t}","id":87880,"modified_method":"@Override\n\tpublic void handleRequest(HttpServletRequest servletRequest, HttpServletResponse servletResponse)\n\t\t\tthrows ServletException, IOException {\n\n\t\tServerHttpRequest request = new ServletServerHttpRequest(servletRequest);\n\t\tServerHttpResponse response = new ServletServerHttpResponse(servletResponse);\n\n\t\ttry {\n\t\t\tthis.sockJsService.handleRequest(request, response, getSockJsPath(servletRequest), this.wsHandler);\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tthrow new SockJsException(\"Uncaught failure in SockJS request, uri=\" + request.getURI(), t);\n\t\t}\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected SockJsService getSockJsService(String[] sockJsPrefixes) {\n\t\tDefaultSockJsService service = createSockJsService();\n\t\tif (sockJsPrefixes != null) {\n\t\t\tservice.setValidSockJsPrefixes(sockJsPrefixes);\n\t\t}\n\t\tif (this.clientLibraryUrl != null) {\n\t\t\tservice.setSockJsClientLibraryUrl(this.clientLibraryUrl);\n\t\t}\n\t\tif (this.streamBytesLimit != null) {\n\t\t\tservice.setStreamBytesLimit(this.streamBytesLimit);\n\t\t}\n\t\tif (this.sessionCookieNeeded != null) {\n\t\t\tservice.setSessionCookieNeeded(this.sessionCookieNeeded);\n\t\t}\n\t\tif (this.heartbeatTime != null) {\n\t\t\tservice.setHeartbeatTime(this.heartbeatTime);\n\t\t}\n\t\tif (this.disconnectDelay != null) {\n\t\t\tservice.setDisconnectDelay(this.heartbeatTime);\n\t\t}\n\t\tif (this.httpMessageCacheSize != null) {\n\t\t\tservice.setHttpMessageCacheSize(this.httpMessageCacheSize);\n\t\t}\n\t\tif (this.webSocketEnabled != null) {\n\t\t\tservice.setWebSocketsEnabled(this.webSocketEnabled);\n\t\t}\n\t\tservice.setHandshakeInterceptors(this.interceptors);\n\t\treturn service;\n\t}","id":87881,"modified_method":"protected SockJsService getSockJsService() {\n\t\tDefaultSockJsService service = createSockJsService();\n\t\tif (this.clientLibraryUrl != null) {\n\t\t\tservice.setSockJsClientLibraryUrl(this.clientLibraryUrl);\n\t\t}\n\t\tif (this.streamBytesLimit != null) {\n\t\t\tservice.setStreamBytesLimit(this.streamBytesLimit);\n\t\t}\n\t\tif (this.sessionCookieNeeded != null) {\n\t\t\tservice.setSessionCookieNeeded(this.sessionCookieNeeded);\n\t\t}\n\t\tif (this.heartbeatTime != null) {\n\t\t\tservice.setHeartbeatTime(this.heartbeatTime);\n\t\t}\n\t\tif (this.disconnectDelay != null) {\n\t\t\tservice.setDisconnectDelay(this.heartbeatTime);\n\t\t}\n\t\tif (this.httpMessageCacheSize != null) {\n\t\t\tservice.setHttpMessageCacheSize(this.httpMessageCacheSize);\n\t\t}\n\t\tif (this.webSocketEnabled != null) {\n\t\t\tservice.setWebSocketsEnabled(this.webSocketEnabled);\n\t\t}\n\t\tservice.setHandshakeInterceptors(this.interceptors);\n\t\treturn service;\n\t}","commit_id":"2a6c1f75e7f9601d736dfebe5823e7070edf1db5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/** {@inheritDoc} */\n        @Override public void onSessionWriteTimeout(GridNioSession ses) {\n            log.warning(\"Closing NIO session because of write timeout.\");\n\n            ses.close();\n        }","id":87882,"modified_method":"/** {@inheritDoc} */\n        @Override public void onSessionWriteTimeout(GridNioSession ses) {\n            if (log.isLoggable(Level.FINE))\n                log.fine(\"Closing NIO session because of write timeout.\");\n\n            ses.close();\n        }","commit_id":"909741a4bc1e9162a29b56c900892f42b5a01a7c","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n        @Override public void onSessionIdleTimeout(GridNioSession ses) {\n            log.warning(\"Closing NIO session because of idle timeout.\");\n\n            ses.close();\n        }","id":87883,"modified_method":"/** {@inheritDoc} */\n        @Override public void onSessionIdleTimeout(GridNioSession ses) {\n            if (log.isLoggable(Level.FINE))\n                log.fine(\"Closing NIO session because of idle timeout.\");\n\n            ses.close();\n        }","commit_id":"909741a4bc1e9162a29b56c900892f42b5a01a7c","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Constructs connection manager.\n     *\n     * @param clientId Client ID.\n     * @param sslCtx SSL context to enable secured connection or {@code null} to use unsecured one.\n     * @param cfg Client configuration.\n     * @param routers Routers or empty collection to use endpoints from topology info.\n     * @param top Topology.\n     * @param protoId Custom protocol ID (optional).\n     * @throws GridClientException If failed to start.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public GridClientConnectionManagerImpl(UUID clientId, SSLContext sslCtx, GridClientConfiguration cfg,\n        Collection<InetSocketAddress> routers, GridClientTopology top, Byte protoId) throws GridClientException {\n        assert clientId != null : \"clientId != null\";\n        assert cfg != null : \"cfg != null\";\n        assert routers != null : \"routers != null\";\n        assert top != null : \"top != null\";\n\n        this.clientId = clientId;\n        this.sslCtx = sslCtx;\n        this.cfg = cfg;\n        this.routers = new ArrayList<>(routers);\n        this.top = top;\n        this.protoId = protoId;\n\n        executor = cfg.getExecutorService() != null ? cfg.getExecutorService() :\n            Executors.newCachedThreadPool(new GridClientThreadFactory(\"exec\", true));\n\n        pingExecutor = cfg.getProtocol() == GridClientProtocol.TCP ?\n            Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors()) : null;\n\n        if (cfg.getProtocol() == GridClientProtocol.TCP) {\n            try {\n                GridLogger gridLog = new GridJavaLogger();\n\n                GridNioFilter[] filters;\n\n                GridNioMessageReader msgReader = new GridNioMessageReader() {\n                    @Override public boolean read(@Nullable UUID nodeId, GridTcpCommunicationMessageAdapter msg,\n                        ByteBuffer buf) {\n                        assert msg != null;\n                        assert buf != null;\n\n                        msg.messageReader(this, nodeId);\n\n                        return msg.readFrom(buf);\n                    }\n                };\n\n                GridNioFilter codecFilter = new GridNioCodecFilter(new NioParser(msgReader), gridLog, true);\n\n                if (sslCtx != null) {\n                    GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, gridLog);\n\n                    sslFilter.directMode(true);\n                    sslFilter.clientMode(true);\n\n                    filters = new GridNioFilter[]{codecFilter, sslFilter};\n                }\n                else\n                    filters = new GridNioFilter[]{codecFilter};\n\n                srv = GridNioServer.builder().address(U.getLocalHost())\n                    .port(-1)\n                    .listener(new NioListener())\n                    .filters(filters)\n                    .logger(gridLog)\n                    .selectorCount(Runtime.getRuntime().availableProcessors())\n                    .sendQueueLimit(1024)\n                    .byteOrder(ByteOrder.nativeOrder())\n                    .tcpNoDelay(cfg.isTcpNoDelay())\n                    .directBuffer(true)\n                    .directMode(true)\n                    .socketReceiveBufferSize(0)\n                    .socketSendBufferSize(0)\n                    .idleTimeout(Long.MAX_VALUE)\n                    .gridName(\"gridClient\")\n                    .messageWriter(msgWriter)\n                    .build();\n\n                srv.start();\n            }\n            catch (IOException | GridException e) {\n                throw new GridClientException(\"Failed to start connection server.\", e);\n            }\n        }\n    }","id":87884,"modified_method":"/**\n     * Constructs connection manager.\n     *\n     * @param clientId Client ID.\n     * @param sslCtx SSL context to enable secured connection or {@code null} to use unsecured one.\n     * @param cfg Client configuration.\n     * @param routers Routers or empty collection to use endpoints from topology info.\n     * @param top Topology.\n     * @param protoId Custom protocol ID (optional).\n     * @throws GridClientException If failed to start.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public GridClientConnectionManagerImpl(UUID clientId, SSLContext sslCtx, GridClientConfiguration cfg,\n        Collection<InetSocketAddress> routers, GridClientTopology top, Byte protoId) throws GridClientException {\n        assert clientId != null : \"clientId != null\";\n        assert cfg != null : \"cfg != null\";\n        assert routers != null : \"routers != null\";\n        assert top != null : \"top != null\";\n\n        this.clientId = clientId;\n        this.sslCtx = sslCtx;\n        this.cfg = cfg;\n        this.routers = new ArrayList<>(routers);\n        this.top = top;\n        this.protoId = protoId;\n\n        executor = cfg.getExecutorService() != null ? cfg.getExecutorService() :\n            Executors.newCachedThreadPool(new GridClientThreadFactory(\"exec\", true));\n\n        pingExecutor = cfg.getProtocol() == GridClientProtocol.TCP ?\n            Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors()) : null;\n\n        if (cfg.getProtocol() == GridClientProtocol.TCP) {\n            try {\n                GridLogger gridLog = new GridJavaLogger(false);\n\n                GridNioFilter[] filters;\n\n                GridNioMessageReader msgReader = new GridNioMessageReader() {\n                    @Override public boolean read(@Nullable UUID nodeId, GridTcpCommunicationMessageAdapter msg,\n                        ByteBuffer buf) {\n                        assert msg != null;\n                        assert buf != null;\n\n                        msg.messageReader(this, nodeId);\n\n                        return msg.readFrom(buf);\n                    }\n                };\n\n                GridNioFilter codecFilter = new GridNioCodecFilter(new NioParser(msgReader), gridLog, true);\n\n                if (sslCtx != null) {\n                    GridNioSslFilter sslFilter = new GridNioSslFilter(sslCtx, gridLog);\n\n                    sslFilter.directMode(true);\n                    sslFilter.clientMode(true);\n\n                    filters = new GridNioFilter[]{codecFilter, sslFilter};\n                }\n                else\n                    filters = new GridNioFilter[]{codecFilter};\n\n                srv = GridNioServer.builder().address(U.getLocalHost())\n                    .port(-1)\n                    .listener(new NioListener())\n                    .filters(filters)\n                    .logger(gridLog)\n                    .selectorCount(Runtime.getRuntime().availableProcessors())\n                    .sendQueueLimit(1024)\n                    .byteOrder(ByteOrder.nativeOrder())\n                    .tcpNoDelay(cfg.isTcpNoDelay())\n                    .directBuffer(true)\n                    .directMode(true)\n                    .socketReceiveBufferSize(0)\n                    .socketSendBufferSize(0)\n                    .idleTimeout(Long.MAX_VALUE)\n                    .gridName(\"gridClient\")\n                    .messageWriter(msgWriter)\n                    .build();\n\n                srv.start();\n            }\n            catch (IOException | GridException e) {\n                throw new GridClientException(\"Failed to start connection server.\", e);\n            }\n        }\n    }","commit_id":"909741a4bc1e9162a29b56c900892f42b5a01a7c","url":"https://github.com/apache/ignite"},{"original_method":"/**\r\n     * Get and resolve all documents names to include application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to include application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public Set getDocsNameToInclude(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNameSet(XWikiApplicationClass.FIELD_DOCSTOINCLUDE, recurse, false);\r\n    }","id":87885,"modified_method":"/**\r\n     * Get and resolve all documents names to include application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to include application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public Set getDocsNameToInclude(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNamesByType(XWikiApplicationClass.FIELD_DOCSTOINCLUDE, recurse, false);\r\n    }","commit_id":"1541f21d834658c7bcaeb6354397cbf4051a08aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocuments()\r\n     * @see XWikiApplicationClass#FIELD_DOCUMENTS\r\n     */\r\n    public Set getDocumentsNames(boolean recurse, boolean includeAppDesc) throws XWikiException\r\n    {\r\n        return getDocsNameSet(XWikiApplicationClass.FIELD_DOCUMENTS, recurse, includeAppDesc);\r\n    }","id":87886,"modified_method":"/**\r\n     * Get and resolve all documents names application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is added to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocuments()\r\n     * @see XWikiApplicationClass#FIELD_DOCUMENTS\r\n     */\r\n    public Set getDocumentsNames(boolean recurse, boolean includeAppDesc) throws XWikiException\r\n    {\r\n        return getDocsNamesByType(XWikiApplicationClass.FIELD_DOCUMENTS, recurse, includeAppDesc);\r\n    }","commit_id":"1541f21d834658c7bcaeb6354397cbf4051a08aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names to link application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to link application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public Set getDocsNameToLink(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNameSet(XWikiApplicationClass.FIELD_DOCSTOLINK, recurse, false);\r\n    }","id":87887,"modified_method":"/**\r\n     * Get and resolve all documents names to link application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to link application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public Set getDocsNameToLink(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNamesByType(XWikiApplicationClass.FIELD_DOCSTOLINK, recurse, false);\r\n    }","commit_id":"1541f21d834658c7bcaeb6354397cbf4051a08aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names to link <code>applications<\/code> XWikiApplication list\r\n     * contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to link <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public static Set getDocsNameToLink(Collection applications) throws XWikiException\r\n    {\r\n        Set docsToLink = new HashSet();\r\n\r\n        resolveApplicationsDocsNames(docsToLink, applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOLINK, false);\r\n\r\n        return docsToLink;\r\n    }","id":87888,"modified_method":"/**\r\n     * Get and resolve all documents names to link <code>applications<\/code> XWikiApplication list\r\n     * contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to link <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public static Set getDocsNameToLink(Collection applications) throws XWikiException\r\n    {\r\n        return getApplicationsDocsNamesByType(applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOLINK, false);\r\n    }","commit_id":"1541f21d834658c7bcaeb6354397cbf4051a08aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Insert in <code>docsNames<\/code> all documents names of type\r\n     * <code>type<\/code> <code>applications<\/code> XWikiApplication list contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param docsNames the collection to complete with resolved documents names.\r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @param type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param includeAppDesc if true application descriptor document names is add to\r\n     *            <code>docsNames<\/code>.\r\n     * @throws XWikiException error when resolving SQL matching.\r\n     */\r\n    private static void resolveApplicationsDocsNames(Collection docsNames,\r\n        Collection applications, String type, boolean includeAppDesc) throws XWikiException\r\n    {\r\n        for (Iterator it = applications.iterator(); it.hasNext();) {\r\n            XWikiApplication app = (XWikiApplication) it.next();\r\n\r\n            app.resolveDocumentsNames(docsNames, type, includeAppDesc);\r\n        }\r\n    }","id":87889,"modified_method":"/**\r\n     * Get and resolve all documents names of type <code>type<\/code> provided applications\r\n     * contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications from which to get documents names.\r\n     * @param type type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param includeAppDesc if true application descriptor document names is added to the returned\r\n     *            set.\r\n     * @return all documents names of type <code>type<\/code> provided applications contains.\r\n     * @throws XWikiException error when resolving SQL matching.\r\n     */\r\n    private static Set getApplicationsDocsNamesByType(Collection applications, String type,\r\n        boolean includeAppDesc) throws XWikiException\r\n    {\r\n        Set set = Collections.EMPTY_SET;\r\n        if (!applications.isEmpty()) {\r\n            List values = new ArrayList();\r\n\r\n            String where =\r\n                createApplicationsHqlFilter(applications, type, values, includeAppDesc);\r\n\r\n            XWikiApplication app = (XWikiApplication) applications.iterator().next();\r\n\r\n            if (where.isEmpty()) {\r\n                set = Collections.EMPTY_SET;\r\n            } else {\r\n                set =\r\n                    new HashSet(app.context.getWiki().getStore().searchDocumentsNames(\r\n                        HQL_WHERE + \" \" + where, values, app.context));\r\n            }\r\n        }\r\n\r\n        return set;\r\n    }","commit_id":"1541f21d834658c7bcaeb6354397cbf4051a08aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names to include <code>applications<\/code> XWikiApplication\r\n     * list contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to include <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public static Set getDocsNameToInclude(Collection applications) throws XWikiException\r\n    {\r\n        Set docsToInclude = new HashSet();\r\n\r\n        resolveApplicationsDocsNames(docsToInclude, applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOINCLUDE, false);\r\n\r\n        return docsToInclude;\r\n    }","id":87890,"modified_method":"/**\r\n     * Get and resolve all documents names to include <code>applications<\/code> XWikiApplication\r\n     * list contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to include <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public static Set getDocsNameToInclude(Collection applications) throws XWikiException\r\n    {\r\n        return getApplicationsDocsNamesByType(applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOINCLUDE, false);\r\n    }","commit_id":"1541f21d834658c7bcaeb6354397cbf4051a08aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names of type <code>type<\/code> application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names of type <code>type<\/code> application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     */\r\n    private Set getDocsNameSet(String type, boolean recurse, boolean includeAppDesc)\r\n        throws XWikiException\r\n    {\r\n        Set documents = new HashSet();\r\n\r\n        resolveDocumentsNames(documents, type, includeAppDesc);\r\n\r\n        if (recurse) {\r\n            resolveApplicationsDocsNames(documents, getXWikiApplicationSet(true, context), type,\r\n                includeAppDesc);\r\n        }\r\n\r\n        return documents;\r\n    }","id":87891,"modified_method":"/**\r\n     * Get and resolve all documents names of type <code>type<\/code> application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param type type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is added to the returned\r\n     *            set.\r\n     * @return all documents names of type <code>type<\/code> application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     */\r\n    private Set getDocsNamesByType(String type, boolean recurse, boolean includeAppDesc)\r\n        throws XWikiException\r\n    {\r\n        List values = new ArrayList();\r\n\r\n        String where = createHqlFilter(type, values, recurse, includeAppDesc);\r\n\r\n        return where.isEmpty() ? Collections.EMPTY_SET : new HashSet(context.getWiki().getStore()\r\n            .searchDocumentsNames(HQL_WHERE + \" \" + where, values, context));\r\n    }","commit_id":"1541f21d834658c7bcaeb6354397cbf4051a08aa","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names to include <code>applications<\/code> XWikiApplication\r\n     * list contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to include <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public static Set getDocsNameToInclude(Collection applications) throws XWikiException\r\n    {\r\n        Set docsToInclude = new HashSet();\r\n\r\n        resolveApplicationsDocsNames(docsToInclude, applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOINCLUDE, false);\r\n\r\n        return docsToInclude;\r\n    }","id":87892,"modified_method":"/**\r\n     * Get and resolve all documents names to include <code>applications<\/code> XWikiApplication\r\n     * list contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to include <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public static Set getDocsNameToInclude(Collection applications) throws XWikiException\r\n    {\r\n        return getApplicationsDocsNamesByType(applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOINCLUDE, false);\r\n    }","commit_id":"70d5366e8fdb64ddaeea1a2a65ca3f0b97080c4e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names to include application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to include application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public Set getDocsNameToInclude(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNameSet(XWikiApplicationClass.FIELD_DOCSTOINCLUDE, recurse, false);\r\n    }","id":87893,"modified_method":"/**\r\n     * Get and resolve all documents names to include application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to include application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToInclude()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOINCLUDE\r\n     */\r\n    public Set getDocsNameToInclude(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNamesByType(XWikiApplicationClass.FIELD_DOCSTOINCLUDE, recurse, false);\r\n    }","commit_id":"70d5366e8fdb64ddaeea1a2a65ca3f0b97080c4e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocuments()\r\n     * @see XWikiApplicationClass#FIELD_DOCUMENTS\r\n     */\r\n    public Set getDocumentsNames(boolean recurse, boolean includeAppDesc) throws XWikiException\r\n    {\r\n        return getDocsNameSet(XWikiApplicationClass.FIELD_DOCUMENTS, recurse, includeAppDesc);\r\n    }","id":87894,"modified_method":"/**\r\n     * Get and resolve all documents names application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is added to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocuments()\r\n     * @see XWikiApplicationClass#FIELD_DOCUMENTS\r\n     */\r\n    public Set getDocumentsNames(boolean recurse, boolean includeAppDesc) throws XWikiException\r\n    {\r\n        return getDocsNamesByType(XWikiApplicationClass.FIELD_DOCUMENTS, recurse, includeAppDesc);\r\n    }","commit_id":"70d5366e8fdb64ddaeea1a2a65ca3f0b97080c4e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Insert in <code>docsNames<\/code> all documents names of type\r\n     * <code>type<\/code> <code>applications<\/code> XWikiApplication list contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param docsNames the collection to complete with resolved documents names.\r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @param type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param includeAppDesc if true application descriptor document names is add to\r\n     *            <code>docsNames<\/code>.\r\n     * @throws XWikiException error when resolving SQL matching.\r\n     */\r\n    private static void resolveApplicationsDocsNames(Collection docsNames,\r\n        Collection applications, String type, boolean includeAppDesc) throws XWikiException\r\n    {\r\n        for (Iterator it = applications.iterator(); it.hasNext();) {\r\n            XWikiApplication app = (XWikiApplication) it.next();\r\n\r\n            app.resolveDocumentsNames(docsNames, type, includeAppDesc);\r\n        }\r\n    }","id":87895,"modified_method":"/**\r\n     * Get and resolve all documents names of type <code>type<\/code> provided applications\r\n     * contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications from which to get documents names.\r\n     * @param type type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param includeAppDesc if true application descriptor document names is added to the returned\r\n     *            set.\r\n     * @return all documents names of type <code>type<\/code> provided applications contains.\r\n     * @throws XWikiException error when resolving SQL matching.\r\n     */\r\n    private static Set getApplicationsDocsNamesByType(Collection applications, String type,\r\n        boolean includeAppDesc) throws XWikiException\r\n    {\r\n        Set set = Collections.EMPTY_SET;\r\n        if (!applications.isEmpty()) {\r\n            List values = new ArrayList();\r\n\r\n            String where =\r\n                createApplicationsHqlFilter(applications, type, values, includeAppDesc);\r\n\r\n            XWikiApplication app = (XWikiApplication) applications.iterator().next();\r\n\r\n            if (where.isEmpty()) {\r\n                set = Collections.EMPTY_SET;\r\n            } else {\r\n                set =\r\n                    new HashSet(app.context.getWiki().getStore().searchDocumentsNames(\r\n                        HQL_WHERE + \" \" + where, values, app.context));\r\n            }\r\n        }\r\n\r\n        return set;\r\n    }","commit_id":"70d5366e8fdb64ddaeea1a2a65ca3f0b97080c4e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names of type <code>type<\/code> application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names of type <code>type<\/code> application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     */\r\n    private Set getDocsNameSet(String type, boolean recurse, boolean includeAppDesc)\r\n        throws XWikiException\r\n    {\r\n        Set documents = new HashSet();\r\n\r\n        resolveDocumentsNames(documents, type, includeAppDesc);\r\n\r\n        if (recurse) {\r\n            resolveApplicationsDocsNames(documents, getXWikiApplicationSet(true, context), type,\r\n                includeAppDesc);\r\n        }\r\n\r\n        return documents;\r\n    }","id":87896,"modified_method":"/**\r\n     * Get and resolve all documents names of type <code>type<\/code> application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param type type the XWikiApplicationClass field where to find documents names list :\r\n     *            {@link XWikiApplicationClass#FIELD_DOCUMENTS},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOINCLUDE},\r\n     *            {@link XWikiApplicationClass#FIELD_DOCSTOLINK}.\r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @param includeAppDesc if true application descriptor document names is added to the returned\r\n     *            set.\r\n     * @return all documents names of type <code>type<\/code> application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     */\r\n    private Set getDocsNamesByType(String type, boolean recurse, boolean includeAppDesc)\r\n        throws XWikiException\r\n    {\r\n        List values = new ArrayList();\r\n\r\n        String where = createHqlFilter(type, values, recurse, includeAppDesc);\r\n\r\n        return where.isEmpty() ? Collections.EMPTY_SET : new HashSet(context.getWiki().getStore()\r\n            .searchDocumentsNames(HQL_WHERE + \" \" + where, values, context));\r\n    }","commit_id":"70d5366e8fdb64ddaeea1a2a65ca3f0b97080c4e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names to link application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to link application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public Set getDocsNameToLink(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNameSet(XWikiApplicationClass.FIELD_DOCSTOLINK, recurse, false);\r\n    }","id":87897,"modified_method":"/**\r\n     * Get and resolve all documents names to link application contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param recurse if true it follow recursively all applications dependencies, if false parse\r\n     *            only direct dependencies.\r\n     * @return all documents names to link application contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public Set getDocsNameToLink(boolean recurse) throws XWikiException\r\n    {\r\n        return getDocsNamesByType(XWikiApplicationClass.FIELD_DOCSTOLINK, recurse, false);\r\n    }","commit_id":"70d5366e8fdb64ddaeea1a2a65ca3f0b97080c4e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Get and resolve all documents names to link <code>applications<\/code> XWikiApplication list\r\n     * contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to link <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public static Set getDocsNameToLink(Collection applications) throws XWikiException\r\n    {\r\n        Set docsToLink = new HashSet();\r\n\r\n        resolveApplicationsDocsNames(docsToLink, applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOLINK, false);\r\n\r\n        return docsToLink;\r\n    }","id":87898,"modified_method":"/**\r\n     * Get and resolve all documents names to link <code>applications<\/code> XWikiApplication list\r\n     * contains.\r\n     * <p>\r\n     * For each of these documents names, if are between \"[\" and \"]\", are considered as SQL matching\r\n     * string to use with \"like\".\r\n     * \r\n     * @param applications the applications containing documents names to resolve and add to\r\n     *            <code>docsNames<\/code>.\r\n     * @return all documents names to link <code>applications<\/code> contains.\r\n     * @throws XWikiException error when:\r\n     *             <ul>\r\n     *             <li>resolving SQL matching.<\/li>\r\n     *             <li>or getting applications dependencies descriptors documents from the\r\n     *             database.<\/li>\r\n     *             <\/ul>\r\n     * @see #getDocsToLink()\r\n     * @see XWikiApplicationClass#FIELD_DOCSTOLINK\r\n     */\r\n    public static Set getDocsNameToLink(Collection applications) throws XWikiException\r\n    {\r\n        return getApplicationsDocsNamesByType(applications,\r\n            XWikiApplicationClass.FIELD_DOCSTOLINK, false);\r\n    }","commit_id":"70d5366e8fdb64ddaeea1a2a65ca3f0b97080c4e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void applyRule(final SNode closure, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    List<SNode> paramTypes = ListSequence.fromList(new ArrayList<SNode>());\n    for (SNode param : SLinkOperations.getTargets(closure, \"parameter\", true)) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(param, \"type\", true), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(param, \"type\", true), \"jetbrains.mps.baseLanguage.structure.UndefinedType\")) {\n        final SNode pt_typevar_1221579075465 = typeCheckingContext.createNewRuntimeTypesVariable();\n        {\n          SNode _nodeToCheck_1029348928467 = param;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075466\", 0, null);\n          typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(pt_typevar_1221579075465), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075470\", true), _info_12389875345);\n        }\n        ListSequence.fromList(paramTypes).addElement(typeCheckingContext.getRepresentative(pt_typevar_1221579075465));\n      } else if ((SLinkOperations.getTarget(param, \"type\", true) != null)) {\n        ListSequence.fromList(paramTypes).addElement(SLinkOperations.getTarget(param, \"type\", true));\n      }\n    }\n    List<SNode> allRets = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allYlds = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allYldAlls = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allStmts = ListSequence.fromList(new LinkedList<SNode>());\n    List<SNode> allThrows = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allCatches = ListSequence.fromList(new ArrayList<SNode>());\n    for (SNode c : SNodeOperations.getChildren(SLinkOperations.getTarget(closure, \"body\", true))) {\n      if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(c);\n      } else if (!(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n        ListSequence.fromList(allStmts).addElement(c);\n      }\n    }\n    while (!(ListSequence.fromList(allStmts).isEmpty())) {\n      SNode stmt = ListSequence.fromList(allStmts).removeElementAt(0);\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(stmt);\n      } else\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else {\n        if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ThrowStatement\")) {\n          final SNode tt_typevar_1221579075612 = typeCheckingContext.createNewRuntimeTypesVariable();\n          {\n            SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SNodeOperations.cast(stmt, \"jetbrains.mps.baseLanguage.structure.ThrowStatement\"), \"throwable\", true);\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075613\", 0, null);\n            typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(tt_typevar_1221579075612), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075617\", true), _info_12389875345);\n          }\n          ListSequence.fromList(allThrows).addElement(typeCheckingContext.getRepresentative(tt_typevar_1221579075612));\n        } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.TryStatement\")) {\n          for (SNode caught : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(stmt, \"jetbrains.mps.baseLanguage.structure.TryStatement\"), \"catchClause\", true)).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          }).select(new ISelector<SNode, SNode>() {\n            public SNode select(SNode it) {\n              return SNodeOperations.as(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          })) {\n            ListSequence.fromList(allCatches).addElement(caught);\n          }\n        } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\")) {\n          for (SNode caught : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(stmt, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\"), \"catchClause\", true)).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          }).select(new ISelector<SNode, SNode>() {\n            public SNode select(SNode it) {\n              return SNodeOperations.as(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          })) {\n            ListSequence.fromList(allCatches).addElement(caught);\n          }\n        } else {\n          for (SNode thr : ListSequence.fromList(SNodeOperations.getDescendants(stmt, \"jetbrains.mps.baseLanguage.structure.IMethodCall\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"})).translate(new ITranslator2<SNode, SNode>() {\n            public Iterable<SNode> translate(SNode it) {\n              return IMethodLike_Behavior.call_getThrowableTypes_6204026822016975623(SLinkOperations.getTarget(it, \"baseMethodDeclaration\", false));\n            }\n          })) {\n            ListSequence.fromList(allThrows).addElement(SNodeOperations.copyNode(thr));\n          }\n        }\n        List<SNode> allChildren = ListSequence.fromList(new LinkedList<SNode>());\n        ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(stmt)));\n        while (ListSequence.fromList(allChildren).isNotEmpty()) {\n          SNode c = ListSequence.fromList(allChildren).removeElementAt(0);\n          if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.StatementList\")) {\n            for (SNode cstmt : SLinkOperations.getTargets(SNodeOperations.cast(c, \"jetbrains.mps.baseLanguage.structure.StatementList\"), \"statement\", true)) {\n              if (!(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n                ListSequence.fromList(allStmts).addElement(cstmt);\n              }\n            }\n          } else if (!(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n            ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(c)));\n          }\n        }\n      }\n    }\n    List<SNode> realThrows = ListSequence.fromList(new ArrayList<SNode>());\nwith_allThrows:\n    for (SNode another : allThrows) {\n      if (SNodeOperations.isInstanceOf(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\")) {\n        for (SNode one : realThrows) {\n          if (SNodeOperations.isInstanceOf(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && (SLinkOperations.getTarget(SNodeOperations.cast(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false) == SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false)) || Classifier_Behavior.call_isDescendant_7165541881557222913(SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false), SLinkOperations.getTarget(SNodeOperations.cast(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false))) {\n            continue with_allThrows;\n          }\n          if (MatchingUtil.matchNodes(one, another)) {\n            continue with_allThrows;\n          }\n        }\n        for (SNode caught : allCatches) {\n          if (SNodeOperations.isInstanceOf(caught, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && (SLinkOperations.getTarget(SNodeOperations.cast(caught, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false) == SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false) || Classifier_Behavior.call_isDescendant_7165541881557222913(SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false), SLinkOperations.getTarget(SNodeOperations.cast(caught, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false)))) {\n            continue with_allThrows;\n          }\n          if (MatchingUtil.matchNodes(caught, another)) {\n            continue with_allThrows;\n          }\n        }\n      }\n      ListSequence.fromList(realThrows).addElement(another);\n    }\n    final SNode RLCS_typevar_1221579075692 = typeCheckingContext.createNewRuntimeTypesVariable();\n    boolean isVoid = false;\n    for (SNode rs : allRets) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(rs, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\"), \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\")) {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"3294521177951941138\", 0, null);\n          typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0a41a0().createNode(typeCheckingContext), false, true, _info_12389875345);\n        }\n      } else {\n        SNode retExpression = SLinkOperations.getTarget(SNodeOperations.cast(rs, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\"), \"expression\", true);\n        if (retExpression == null) {\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"4542977447015145880\", 0, null);\n            typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a1a0a0o0a().createNode(typeCheckingContext), _info_12389875345);\n          }\n          isVoid = true;\n        } else {\n          {\n            SNode _nodeToCheck_1029348928467 = retExpression;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"5604339164783014263\", 0, null);\n            typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"5604339164783014269\", true), false, true, _info_12389875345);\n          }\n        }\n      }\n    }\n    final SNode YLCS_typevar_1221579075693 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for (SNode ys : allYlds) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075724\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(YLCS_typevar_1221579075693), (SNode) (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(ys, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\"), \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\") ?\n          new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0q0a().createNode(typeCheckingContext) :\n          typeCheckingContext.typeOf(SLinkOperations.getTarget(SNodeOperations.cast(ys, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\"), \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"3294521177951978057\", true)\n        ), false, true, _info_12389875345);\n      }\n    }\n    final SNode YALCS_typevar_1229000934873 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for (SNode yas : allYldAlls) {\n      final SNode elementType_typevar_1229000969704 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SNodeOperations.cast(yas, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\"), \"expression\", true);\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229000989981\", 0, null);\n        typeCheckingContext.createLessThanInequality((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229000996769\", true), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a1a81a0().createNode(typeCheckingContext.getRepresentative(elementType_typevar_1229000969704), typeCheckingContext.getRepresentative(elementType_typevar_1229000969704), typeCheckingContext), false, true, _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001090979\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(YALCS_typevar_1229000934873), (SNode) typeCheckingContext.getRepresentative(elementType_typevar_1229000969704), false, true, _info_12389875345);\n      }\n    }\n    List<SNode> stmts = SLinkOperations.getTargets(SLinkOperations.getTarget(closure, \"body\", true), \"statement\", true);\n    SNode lastStmt = (stmts != null && ListSequence.fromList(stmts).count() > 0 ?\n      IMethodLike_Behavior.call_getLastStatement_1239354409446(closure) :\n      null\n    );\n    boolean returnsValue = !(ListSequence.fromList(allRets).isEmpty());\n    boolean returnsFromLast = !(isVoid) && SNodeOperations.isInstanceOf(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\") && !(IStatementListContainer_Behavior.call_isExecuteSynchronous_1230212745736(closure));\n    boolean yieldsValue = !(ListSequence.fromList(allYlds).isEmpty());\n    switch (ListSequence.fromList(allYldAlls).count()) {\n      case 0:\n        break;\n      case 1:\n        if (ListSequence.fromList(allYldAlls).getElement(0) == lastStmt && !(yieldsValue)) {\n          returnsValue = true;\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001407669\", 0, null);\n            typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a1a0a1y0a().createNode(typeCheckingContext.getRepresentative(YALCS_typevar_1229000934873), typeCheckingContext), false, true, _info_12389875345);\n          }\n          break;\n        }\n        //  fall through \n      default:\n        yieldsValue = true;\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229010820337\", 0, null);\n          typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(YLCS_typevar_1221579075693), (SNode) typeCheckingContext.getRepresentative(YALCS_typevar_1229000934873), false, true, _info_12389875345);\n        }\n    }\n    final SNode RESULT_typevar_1221579592331 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode RETURN_typevar_1232125235963 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode TERMINATE_typevar_1232105622932 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = closure;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131392781\", 0, null);\n      typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RETURN_typevar_1232125235963), (SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), false, true, _info_12389875345);\n    }\n    if (returnsFromLast && !(yieldsValue)) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"3294521177951941153\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), (SNode) (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\") ?\n          new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0db0a().createNode(typeCheckingContext) :\n          typeCheckingContext.typeOf(SLinkOperations.getTarget(SNodeOperations.cast(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), \"expression\", true), \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"3294521177951944160\", true)\n        ), _info_12389875345);\n      }\n      final SNode RET_AND_TERM_typevar_1232125197501 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232125205435\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RET_AND_TERM_typevar_1232125197501), (SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), false, true, _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075770\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RET_AND_TERM_typevar_1232125197501), (SNode) typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), false, true, _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221663085197\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(RESULT_typevar_1221579592331), (SNode) typeCheckingContext.getRepresentative(RET_AND_TERM_typevar_1232125197501), _info_12389875345);\n      }\n    } else {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131979682\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0db0a_0().createNode(typeCheckingContext), _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221663751995\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(RESULT_typevar_1221579592331), (SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), _info_12389875345);\n      }\n    }\n    if (returnsValue && yieldsValue) {\n      if (!(false)) {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(closure, \"closure must either return or yield value\", \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075859\", null, errorTarget);\n      }\n    } else\n    if ((returnsValue || returnsFromLast) && !(yieldsValue)) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718163909\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718156828\", true), (SNode) ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, typeCheckingContext.getRepresentative(RESULT_typevar_1221579592331), typeCheckingContext.getRepresentative(RETURN_typevar_1232125235963), typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), realThrows), _info_12389875345);\n      }\n    } else\n    if (yieldsValue) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718256918\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718251100\", true), (SNode) ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a2a0a0a0eb0a().createNode(typeCheckingContext.getRepresentative(YLCS_typevar_1221579075693), typeCheckingContext), null, null, realThrows), _info_12389875345);\n      }\n    } else {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718281813\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718277155\", true), (SNode) ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a2a0a0a0a03a0().createNode(typeCheckingContext), new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a3a0a0a0a03a0().createNode(typeCheckingContext), new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a4a0a0a0a03a0().createNode(typeCheckingContext), realThrows), _info_12389875345);\n      }\n    }\n  }","id":87899,"modified_method":"public void applyRule(final SNode closure, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    List<SNode> paramTypes = ListSequence.fromList(new ArrayList<SNode>());\n    for (SNode param : SLinkOperations.getTargets(closure, \"parameter\", true)) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(param, \"type\", true), \"jetbrains.mps.baseLanguage.structure.WildCardType\") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(param, \"type\", true), \"jetbrains.mps.baseLanguage.structure.UndefinedType\")) {\n        final SNode pt_typevar_1221579075465 = typeCheckingContext.createNewRuntimeTypesVariable();\n        {\n          SNode _nodeToCheck_1029348928467 = param;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075466\", 0, null);\n          typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(pt_typevar_1221579075465), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075470\", true), _info_12389875345);\n        }\n        ListSequence.fromList(paramTypes).addElement(typeCheckingContext.getRepresentative(pt_typevar_1221579075465));\n      } else if ((SLinkOperations.getTarget(param, \"type\", true) != null)) {\n        ListSequence.fromList(paramTypes).addElement(SLinkOperations.getTarget(param, \"type\", true));\n      }\n    }\n    List<SNode> allRets = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allYlds = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allYldAlls = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allStmts = ListSequence.fromList(new LinkedList<SNode>());\n    List<SNode> allThrows = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> allCatches = ListSequence.fromList(new ArrayList<SNode>());\n    for (SNode c : SNodeOperations.getChildren(SLinkOperations.getTarget(closure, \"body\", true))) {\n      if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(c);\n      } else if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(c);\n      } else if (!(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n        ListSequence.fromList(allStmts).addElement(c);\n      }\n    }\n    while (!(ListSequence.fromList(allStmts).isEmpty())) {\n      SNode stmt = ListSequence.fromList(allStmts).removeElementAt(0);\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\")) {\n        ListSequence.fromList(allRets).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\")) {\n        ListSequence.fromList(allYldAlls).addElement(stmt);\n      } else\n      if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\")) {\n        ListSequence.fromList(allYlds).addElement(stmt);\n      } else {\n        if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.ThrowStatement\")) {\n          final SNode tt_typevar_1221579075612 = typeCheckingContext.createNewRuntimeTypesVariable();\n          {\n            SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SNodeOperations.cast(stmt, \"jetbrains.mps.baseLanguage.structure.ThrowStatement\"), \"throwable\", true);\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075613\", 0, null);\n            typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(tt_typevar_1221579075612), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075617\", true), _info_12389875345);\n          }\n          ListSequence.fromList(allThrows).addElement(typeCheckingContext.getRepresentative(tt_typevar_1221579075612));\n        } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.TryStatement\")) {\n          for (SNode caught : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(stmt, \"jetbrains.mps.baseLanguage.structure.TryStatement\"), \"catchClause\", true)).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          }).select(new ISelector<SNode, SNode>() {\n            public SNode select(SNode it) {\n              return SNodeOperations.as(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          })) {\n            ListSequence.fromList(allCatches).addElement(caught);\n          }\n        } else if (SNodeOperations.isInstanceOf(stmt, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\")) {\n          for (SNode caught : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(stmt, \"jetbrains.mps.baseLanguage.structure.TryCatchStatement\"), \"catchClause\", true)).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          }).select(new ISelector<SNode, SNode>() {\n            public SNode select(SNode it) {\n              return SNodeOperations.as(SLinkOperations.getTarget(SLinkOperations.getTarget(it, \"throwable\", true), \"type\", true), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n            }\n          })) {\n            ListSequence.fromList(allCatches).addElement(caught);\n          }\n        } else {\n          for (SNode thr : ListSequence.fromList(SNodeOperations.getDescendants(stmt, \"jetbrains.mps.baseLanguage.structure.IMethodCall\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"})).translate(new ITranslator2<SNode, SNode>() {\n            public Iterable<SNode> translate(SNode it) {\n              return IMethodLike_Behavior.call_getThrowableTypes_6204026822016975623(SLinkOperations.getTarget(it, \"baseMethodDeclaration\", false));\n            }\n          })) {\n            ListSequence.fromList(allThrows).addElement(SNodeOperations.copyNode(thr));\n          }\n        }\n        List<SNode> allChildren = ListSequence.fromList(new LinkedList<SNode>());\n        ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(stmt)));\n        while (ListSequence.fromList(allChildren).isNotEmpty()) {\n          SNode c = ListSequence.fromList(allChildren).removeElementAt(0);\n          if (SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.StatementList\")) {\n            for (SNode cstmt : SLinkOperations.getTargets(SNodeOperations.cast(c, \"jetbrains.mps.baseLanguage.structure.StatementList\"), \"statement\", true)) {\n              if (!(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.CommentedStatementsBlock\")) && !(SNodeOperations.isInstanceOf(cstmt, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n                ListSequence.fromList(allStmts).addElement(cstmt);\n              }\n            }\n          } else if (!(SNodeOperations.isInstanceOf(c, \"jetbrains.mps.baseLanguage.structure.IStatementListContainer\"))) {\n            ListSequence.fromList(allChildren).addSequence(ListSequence.fromList(SNodeOperations.getChildren(c)));\n          }\n        }\n      }\n    }\n    List<SNode> realThrows = ListSequence.fromList(new ArrayList<SNode>());\nwith_allThrows:\n    for (SNode another : allThrows) {\n      if (SNodeOperations.isInstanceOf(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\")) {\n        for (SNode one : realThrows) {\n          if (SNodeOperations.isInstanceOf(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && (SLinkOperations.getTarget(SNodeOperations.cast(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false) == SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false)) || Classifier_Behavior.call_isDescendant_7165541881557222913(SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false), SLinkOperations.getTarget(SNodeOperations.cast(one, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false))) {\n            continue with_allThrows;\n          }\n          if (MatchingUtil.matchNodes(one, another)) {\n            continue with_allThrows;\n          }\n        }\n        for (SNode caught : allCatches) {\n          if (SNodeOperations.isInstanceOf(caught, \"jetbrains.mps.baseLanguage.structure.ClassifierType\") && (SLinkOperations.getTarget(SNodeOperations.cast(caught, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false) == SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false) || Classifier_Behavior.call_isDescendant_7165541881557222913(SLinkOperations.getTarget(SNodeOperations.cast(another, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false), SLinkOperations.getTarget(SNodeOperations.cast(caught, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false)))) {\n            continue with_allThrows;\n          }\n          if (MatchingUtil.matchNodes(caught, another)) {\n            continue with_allThrows;\n          }\n        }\n      }\n      ListSequence.fromList(realThrows).addElement(another);\n    }\n    final SNode RLCS_typevar_1221579075692 = typeCheckingContext.createNewRuntimeTypesVariable();\n    boolean isVoid = false;\n    for (SNode rs : allRets) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(rs, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\"), \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\")) {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"3294521177951941138\", 0, null);\n          typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0a41a0().createNode(typeCheckingContext), false, true, _info_12389875345);\n        }\n      } else {\n        SNode retExpression = SLinkOperations.getTarget(SNodeOperations.cast(rs, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\"), \"expression\", true);\n        if (retExpression == null) {\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502248\", 0, null);\n            typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a1a0a0o0a().createNode(typeCheckingContext), false, true, _info_12389875345);\n          }\n          isVoid = true;\n        } else {\n          {\n            SNode _nodeToCheck_1029348928467 = retExpression;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"5604339164783014263\", 0, null);\n            typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"5604339164783014269\", true), false, true, _info_12389875345);\n          }\n        }\n      }\n    }\n    final SNode YLCS_typevar_1221579075693 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for (SNode ys : allYlds) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(ys, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\"), \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\")) {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502122\", 0, null);\n          typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(YLCS_typevar_1221579075693), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0a61a0().createNode(typeCheckingContext), false, true, _info_12389875345);\n        }\n      } else {\n        {\n          SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SNodeOperations.cast(ys, \"jetbrains.mps.baseLanguage.closures.structure.YieldStatement\"), \"expression\", true);\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502152\", 0, null);\n          typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(YLCS_typevar_1221579075693), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502170\", true), false, true, _info_12389875345);\n        }\n      }\n    }\n    final SNode YALCS_typevar_1229000934873 = typeCheckingContext.createNewRuntimeTypesVariable();\n    for (SNode yas : allYldAlls) {\n      final SNode elementType_typevar_1229000969704 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SNodeOperations.cast(yas, \"jetbrains.mps.baseLanguage.closures.structure.YieldAllStatement\"), \"expression\", true);\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502247\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a1a81a0().createNode(typeCheckingContext.getRepresentative(elementType_typevar_1229000969704), typeCheckingContext.getRepresentative(elementType_typevar_1229000969704), typeCheckingContext), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229000996769\", true), false, true, _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001090979\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(YALCS_typevar_1229000934873), (SNode) typeCheckingContext.getRepresentative(elementType_typevar_1229000969704), false, true, _info_12389875345);\n      }\n    }\n    List<SNode> stmts = SLinkOperations.getTargets(SLinkOperations.getTarget(closure, \"body\", true), \"statement\", true);\n    SNode lastStmt = (stmts != null && ListSequence.fromList(stmts).count() > 0 ?\n      IMethodLike_Behavior.call_getLastStatement_1239354409446(closure) :\n      null\n    );\n    boolean returnsValue = !(ListSequence.fromList(allRets).isEmpty());\n    boolean returnsFromLast = !(isVoid) && SNodeOperations.isInstanceOf(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\") && !(IStatementListContainer_Behavior.call_isExecuteSynchronous_1230212745736(closure));\n    boolean yieldsValue = !(ListSequence.fromList(allYlds).isEmpty());\n    switch (ListSequence.fromList(allYldAlls).count()) {\n      case 0:\n        break;\n      case 1:\n        if (ListSequence.fromList(allYldAlls).getElement(0) == lastStmt && !(yieldsValue)) {\n          returnsValue = true;\n          {\n            SNode _nodeToCheck_1029348928467 = closure;\n            EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229001407669\", 0, null);\n            typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a1a0a1y0a().createNode(typeCheckingContext.getRepresentative(YALCS_typevar_1229000934873), typeCheckingContext), false, true, _info_12389875345);\n          }\n          break;\n        }\n        //  fall through \n      default:\n        yieldsValue = true;\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229010820337\", 0, null);\n          typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(YLCS_typevar_1221579075693), (SNode) typeCheckingContext.getRepresentative(YALCS_typevar_1229000934873), false, true, _info_12389875345);\n        }\n    }\n    final SNode RESULT_typevar_1221579592331 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode RETURN_typevar_1232125235963 = typeCheckingContext.createNewRuntimeTypesVariable();\n    final SNode TERMINATE_typevar_1232105622932 = typeCheckingContext.createNewRuntimeTypesVariable();\n    {\n      SNode _nodeToCheck_1029348928467 = closure;\n      EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131392781\", 0, null);\n      typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RETURN_typevar_1232125235963), (SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), false, true, _info_12389875345);\n    }\n    if (returnsFromLast && !(yieldsValue)) {\n      if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\")) {\n        {\n          SNode _nodeToCheck_1029348928467 = closure;\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502289\", 0, null);\n          typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0a92a0().createNode(typeCheckingContext), _info_12389875345);\n        }\n      } else {\n        {\n          SNode _nodeToCheck_1029348928467 = SLinkOperations.getTarget(SNodeOperations.cast(lastStmt, \"jetbrains.mps.baseLanguage.structure.ExpressionStatement\"), \"expression\", true);\n          EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502321\", 0, null);\n          typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502377\", true), _info_12389875345);\n        }\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502451\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RESULT_typevar_1221579592331), (SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), false, true, _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"7668447476859502480\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) typeCheckingContext.getRepresentative(RESULT_typevar_1221579592331), (SNode) typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), false, true, _info_12389875345);\n      }\n    } else {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1232131979682\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), (SNode) new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a0a0a0db0a().createNode(typeCheckingContext), _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221663751995\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(RESULT_typevar_1221579592331), (SNode) typeCheckingContext.getRepresentative(RLCS_typevar_1221579075692), _info_12389875345);\n      }\n    }\n    if (returnsValue && yieldsValue) {\n      if (!(false)) {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(closure, \"closure must either return or yield value\", \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1221579075859\", null, errorTarget);\n      }\n    } else\n    if ((returnsValue || returnsFromLast) && !(yieldsValue)) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718163909\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718156828\", true), (SNode) ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, typeCheckingContext.getRepresentative(RESULT_typevar_1221579592331), typeCheckingContext.getRepresentative(RETURN_typevar_1232125235963), typeCheckingContext.getRepresentative(TERMINATE_typevar_1232105622932), realThrows), _info_12389875345);\n      }\n    } else\n    if (yieldsValue) {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718256918\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718251100\", true), (SNode) ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a2a0a0a0eb0a().createNode(typeCheckingContext.getRepresentative(YLCS_typevar_1221579075693), typeCheckingContext), null, null, realThrows), _info_12389875345);\n      }\n    } else {\n      {\n        SNode _nodeToCheck_1029348928467 = closure;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718281813\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c89590337(jetbrains.mps.baseLanguage.closures.typesystem)\", \"1229718277155\", true), (SNode) ClosureLiteral_Behavior.call_getType_1229718192182(closure, paramTypes, new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a2a0a0a0a03a0().createNode(typeCheckingContext), new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a3a0a0a0a03a0().createNode(typeCheckingContext), new typeof_ClosureLiteral_InferenceRule.QuotationClass_nx7618_a4a0a0a0a03a0().createNode(typeCheckingContext), realThrows), _info_12389875345);\n      }\n    }\n  }","commit_id":"ee817bda2e50111d4c3075a3be141585d54f0b0f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode createNode() {\n      SNode result = null;\n      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();\n      SNode quotedNode_1 = null;\n      {\n        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassifierType\", null, GlobalScope.getInstance(), false);\n        SNode quotedNode1_2 = quotedNode_1;\n        quotedNode1_2.addReference(SReference.create(\"classifier\", quotedNode1_2, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(java.lang@java_stub)\"), SNodeId.fromString(\"~Object\")));\n        result = quotedNode1_2;\n      }\n      return result;\n    }","id":87900,"modified_method":"public SNode createNode() {\n      SNode result = null;\n      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();\n      SNode quotedNode_1 = null;\n      {\n        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, GlobalScope.getInstance(), false);\n        SNode quotedNode1_2 = quotedNode_1;\n        result = quotedNode1_2;\n      }\n      return result;\n    }","commit_id":"ee817bda2e50111d4c3075a3be141585d54f0b0f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode createNode(final TypeCheckingContext typeCheckingContext) {\n      SNode result = null;\n      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();\n      SNode quotedNode_1 = null;\n      {\n        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassifierType\", null, GlobalScope.getInstance(), false);\n        SNode quotedNode1_2 = quotedNode_1;\n        quotedNode1_2.addReference(SReference.create(\"classifier\", quotedNode1_2, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(java.lang@java_stub)\"), SNodeId.fromString(\"~Object\")));\n        result = quotedNode1_2;\n      }\n      return result;\n    }","id":87901,"modified_method":"public SNode createNode(final TypeCheckingContext typeCheckingContext) {\n      SNode result = null;\n      Set<SNode> _parameterValues_129834374 = new HashSet<SNode>();\n      SNode quotedNode_1 = null;\n      {\n        quotedNode_1 = SModelUtil_new.instantiateConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.VoidType\", null, GlobalScope.getInstance(), false);\n        SNode quotedNode1_2 = quotedNode_1;\n        result = quotedNode1_2;\n      }\n      return result;\n    }","commit_id":"ee817bda2e50111d4c3075a3be141585d54f0b0f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode scpd, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(scpd), \"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\") && SNodeOperations.isInstanceOf(SNodeOperations.getParent(SNodeOperations.getParent(scpd)), \"jetbrains.mps.baseLanguage.structure.IOperation\")) {\n      final SNode paramType_typevar_1230315924141 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = IOperation_Behavior.call_getOperand_1213877410070(SNodeOperations.cast(SNodeOperations.getParent(SNodeOperations.getParent(scpd)), \"jetbrains.mps.baseLanguage.structure.IOperation\"));\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"2233481601211199538\", 0, null);\n        typeCheckingContext.createGreaterThanInequality((SNode) new typeof_SmartClosureParameterDeclaration_InferenceRule.QuotationClass_5rdbtv_a0a1a0a0().createNode(typeCheckingContext.getRepresentative(paramType_typevar_1230315924141), typeCheckingContext), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1230315907236\", true), false, true, _info_12389875345);\n      }\n      {\n        SNode _nodeToCheck_1029348928467 = scpd;\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1230315977451\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"1230315969555\", true), (SNode) typeCheckingContext.getRepresentative(paramType_typevar_1230315924141), _info_12389875345);\n      }\n    }\n  }","id":87902,"modified_method":"public void applyRule(final SNode scpd, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(scpd), \"jetbrains.mps.baseLanguage.closures.structure.ClosureLiteral\") && SNodeOperations.isInstanceOf(SNodeOperations.getParent(SNodeOperations.getParent(scpd)), \"jetbrains.mps.baseLanguage.structure.IOperation\")) {\n      final SNode paramType_typevar_1230315924141 = typeCheckingContext.createNewRuntimeTypesVariable();\n      final SNode seqType_typevar_2684739085678948053 = typeCheckingContext.createNewRuntimeTypesVariable();\n      {\n        SNode _nodeToCheck_1029348928467 = IOperation_Behavior.call_getOperand_1213877410070(SNodeOperations.cast(SNodeOperations.getParent(SNodeOperations.getParent(scpd)), \"jetbrains.mps.baseLanguage.structure.IOperation\"));\n        EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"2684739085678948077\", 0, null);\n        typeCheckingContext.createEquation((SNode) typeCheckingContext.getRepresentative(seqType_typevar_2684739085678948053), (SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"2684739085678948083\", true), _info_12389875345);\n      }\n      {\n        final SNode sequenceTypeConcrete = typeCheckingContext.getRepresentative(seqType_typevar_2684739085678948053);\n        typeCheckingContext.whenConcrete(sequenceTypeConcrete, new Runnable() {\n          public void run() {\n            {\n              IMatchingPattern pattern_sg6z08_a0d0a0 = HUtil.createMatchingPatternByConceptFQName(\"jetbrains.mps.baseLanguage.collections.structure.SequenceType\");\n              SNode coercedNode_sg6z08_a0d0a0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(typeCheckingContext.getExpandedNode(sequenceTypeConcrete), pattern_sg6z08_a0d0a0);\n              if (coercedNode_sg6z08_a0d0a0 != null) {\n                {\n                  SNode _nodeToCheck_1029348928467 = scpd;\n                  EquationInfo _info_12389875345 = new EquationInfo(_nodeToCheck_1029348928467, null, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"2684739085678948105\", 0, null);\n                  typeCheckingContext.createEquation((SNode) typeCheckingContext.typeOf(_nodeToCheck_1029348928467, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"2684739085678948109\", true), (SNode) SLinkOperations.getTarget(coercedNode_sg6z08_a0d0a0, \"elementType\", true), _info_12389875345);\n                }\n              } else {\n                {\n                  MessageTarget errorTarget = new NodeMessageTarget();\n                  IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(scpd, \"Unable to compute type\", \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"2684739085678948143\", null, errorTarget);\n                }\n              }\n            }\n          }\n        }, \"r:00000000-0000-4000-0000-011c8959032b(jetbrains.mps.baseLanguage.collections.typesystem)\", \"2684739085678948093\", false, false);\n      }\n      // <node> \n      // <node> \n    }\n  }","commit_id":"45b7611b388e132298b56dbe02697f24786bea40","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void disposeComponent() {\n  }","id":87903,"modified_method":"@Override\n  public void disposeComponent() {\n    ModelAccess.instance().dispose();\n  }","commit_id":"7e17b66602a106a083c0004f8631405492921695","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    res[0] = new CommandComputable<T>(r, project).compute();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87904,"modified_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              res[0] = new CommandComputable<T>(r, project).compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException ignore) {}\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"7e17b66602a106a083c0004f8631405492921695","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    new CommandRunnable(r, project).run();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                  res[0] = true;\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87905,"modified_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              new CommandRunnable(r, project).run();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException e) {\n          return;\n        }\n        res[0] = true;\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"7e17b66602a106a083c0004f8631405492921695","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n//    if (!getWriteLock().tryLock()) {\n//      return false;\n//    }\n//    getWriteLock().unlock();\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87906,"modified_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n         try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return new TryWriteActionComputable<Boolean> (computable).compute();\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"7e17b66602a106a083c0004f8631405492921695","url":"https://github.com/JetBrains/MPS"},{"original_method":"public WorkbenchModelAccess() {\n  }","id":87907,"modified_method":"public WorkbenchModelAccess() {\n    this.myInterruptingThread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (; ;) {\n          try {\n            DelayedInterrupt di = myInterruptQueue.take();\n            di.timeIsUp();\n          } catch (InterruptedException e) {\n            Application app = ApplicationManager.getApplication();\n            if (app == null || app.isDisposeInProgress() || app.isDisposed()) {\n              return;\n            }\n          }\n        }\n      }\n    }, \"MPS interrupting thread\");\n    myInterruptingThread.start();\n  }","commit_id":"7e17b66602a106a083c0004f8631405492921695","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87908,"modified_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return new TryWriteActionComputable<T> (computable).compute();\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"7e17b66602a106a083c0004f8631405492921695","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void disposeComponent() {\n  }","id":87909,"modified_method":"@Override\n  public void disposeComponent() {\n    ModelAccess.instance().dispose();\n  }","commit_id":"045fc945e5bbb7e01ae8471335b44a73d25615b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    new CommandRunnable(r, project).run();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                  res[0] = true;\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87910,"modified_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              new CommandRunnable(r, project).run();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException e) {\n          return;\n        }\n        res[0] = true;\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"045fc945e5bbb7e01ae8471335b44a73d25615b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    res[0] = new CommandComputable<T>(r, project).compute();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87911,"modified_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              res[0] = new CommandComputable<T>(r, project).compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException ignore) {}\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"045fc945e5bbb7e01ae8471335b44a73d25615b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n//    if (!getWriteLock().tryLock()) {\n//      return false;\n//    }\n//    getWriteLock().unlock();\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87912,"modified_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n         try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      Boolean res = new TryWriteActionComputable<Boolean>(computable).compute();\n      return res != null ? res : false;\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"045fc945e5bbb7e01ae8471335b44a73d25615b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87913,"modified_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return new TryWriteActionComputable<T> (computable).compute();\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"045fc945e5bbb7e01ae8471335b44a73d25615b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public WorkbenchModelAccess() {\n  }","id":87914,"modified_method":"public WorkbenchModelAccess() {\n    this.myInterruptingThread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (; ;) {\n          try {\n            DelayedInterrupt di = myInterruptQueue.take();\n            di.timeIsUp();\n          } catch (InterruptedException e) {\n            Application app = ApplicationManager.getApplication();\n            if (app == null || app.isDisposeInProgress() || app.isDisposed()) {\n              return;\n            }\n          }\n        }\n      }\n    }, \"MPS interrupting thread\");\n    myInterruptingThread.start();\n  }","commit_id":"045fc945e5bbb7e01ae8471335b44a73d25615b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void disposeComponent() {\n  }","id":87915,"modified_method":"@Override\n  public void disposeComponent() {\n    ModelAccess.instance().dispose();\n  }","commit_id":"6dbcbff9dbe1558b5b66d24f4bff5e2beac19619","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n//    if (!getWriteLock().tryLock()) {\n//      return false;\n//    }\n//    getWriteLock().unlock();\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87916,"modified_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n         try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return new TryWriteActionComputable<Boolean> (computable).compute();\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"6dbcbff9dbe1558b5b66d24f4bff5e2beac19619","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87917,"modified_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return new TryWriteActionComputable<T> (computable).compute();\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"6dbcbff9dbe1558b5b66d24f4bff5e2beac19619","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    new CommandRunnable(r, project).run();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                  res[0] = true;\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87918,"modified_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              new CommandRunnable(r, project).run();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException e) {\n          return;\n        }\n        res[0] = true;\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"6dbcbff9dbe1558b5b66d24f4bff5e2beac19619","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    res[0] = new CommandComputable<T>(r, project).compute();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87919,"modified_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              res[0] = new CommandComputable<T>(r, project).compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException ignore) {}\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"6dbcbff9dbe1558b5b66d24f4bff5e2beac19619","url":"https://github.com/JetBrains/MPS"},{"original_method":"public WorkbenchModelAccess() {\n  }","id":87920,"modified_method":"public WorkbenchModelAccess() {\n    this.myInterruptingThread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (; ;) {\n          try {\n            DelayedInterrupt di = myInterruptQueue.take();\n            di.timeIsUp();\n          } catch (InterruptedException e) {\n            Application app = ApplicationManager.getApplication();\n            if (app == null || app.isDisposeInProgress() || app.isDisposed()) {\n              return;\n            }\n          }\n        }\n      }\n    }, \"MPS interrupting thread\");\n    myInterruptingThread.start();\n  }","commit_id":"6dbcbff9dbe1558b5b66d24f4bff5e2beac19619","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void disposeComponent() {\n  }","id":87921,"modified_method":"@Override\n  public void disposeComponent() {\n    ModelAccess.instance().dispose();\n  }","commit_id":"ace68db40332694a8472b52c6fa59a926d0e41f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    res[0] = new CommandComputable<T>(r, project).compute();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87922,"modified_method":"@Override\n  public <T> T tryWriteInCommand(final Computable<T> r, Project p) {\n    if(myDistributedLocksMode) {\n      return null;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final T[] res = (T[])new Object[]{null};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              res[0] = new CommandComputable<T>(r, project).compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException ignore) {}\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"ace68db40332694a8472b52c6fa59a926d0e41f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new Runnable() {\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            public void run() {\n              try {\n                if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n                  try {\n                    new CommandRunnable(r, project).run();\n                  } finally {\n                    getWriteLock().unlock();\n                  }\n                  res[0] = true;\n                }\n              } catch (InterruptedException ignore) {}\n            }\n          });\n        }\n      },\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","id":87923,"modified_method":"@Override\n  public boolean tryWriteInCommand(final Runnable r, Project p) {\n    if(myDistributedLocksMode) {\n      return false;\n    }\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final boolean[] res = new boolean[]{false};\n\n    final Project project = p != null ? p : CurrentProjectAccessUtil.getProjectFromUI();\n\n    Runnable commandRunnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              new CommandRunnable(r, project).run();\n            } finally {\n              getWriteLock().unlock();\n            }\n          }\n        } catch (InterruptedException e) {\n          return;\n        }\n        res[0] = true;\n      }\n    };\n\n    CommandProcessor.getInstance().executeCommand(\n      project,\n      new TryWriteActionRunnable(commandRunnable),\n      \"\", null, UndoConfirmationPolicy.DO_NOT_REQUEST_CONFIRMATION);\n\n    return res[0];\n  }","commit_id":"ace68db40332694a8472b52c6fa59a926d0e41f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87924,"modified_method":"@Override\n  public <T> T tryWrite(final Computable<T> c) {\n    if(canWrite()) {\n      return c.compute();\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return null;\n    }\n\n    Computable<T> computable = new Computable<T>() {\n      public T compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              return c.compute();\n            } finally {\n              getWriteLock().unlock();\n            }\n          } else {\n            return null;\n          }\n        } catch (InterruptedException e) {\n          return null;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return new TryWriteActionComputable<T> (computable).compute();\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"ace68db40332694a8472b52c6fa59a926d0e41f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n//    if (!getWriteLock().tryLock()) {\n//      return false;\n//    }\n//    getWriteLock().unlock();\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n        try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      return ApplicationManager.getApplication().runWriteAction(computable);\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","id":87925,"modified_method":"@Override\n  public boolean tryWrite(final Runnable r) {\n    if(canWrite()) {\n      r.run();\n      return true;\n    }\n\n    if(myDistributedLocksMode && ApplicationManager.getApplication().isDispatchThread()) {\n      return false;\n    }\n\n    Computable<Boolean> computable = new Computable<Boolean>() {\n      public Boolean compute() {\n         try {\n          if (getWriteLock().tryLock(WAIT_FOR_WRITE_LOCK_MILLIS, MILLISECONDS)) {\n            try {\n              r.run();\n            } finally {\n              getWriteLock().unlock();\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } catch (InterruptedException e) {\n          return false;\n        }\n      }\n    };\n\n    if (ThreadUtils.isEventDispatchThread()) {\n      Boolean res = new TryWriteActionComputable<Boolean>(computable).compute();\n      return res != null ? res : false;\n    } else {\n      return ApplicationManager.getApplication().runReadAction(computable);\n    }\n  }","commit_id":"ace68db40332694a8472b52c6fa59a926d0e41f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public WorkbenchModelAccess() {\n  }","id":87926,"modified_method":"public WorkbenchModelAccess() {\n    this.myInterruptingThread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        for (; ;) {\n          try {\n            DelayedInterrupt di = myInterruptQueue.take();\n            di.timeIsUp();\n          } catch (InterruptedException e) {\n            Application app = ApplicationManager.getApplication();\n            if (app == null || app.isDisposeInProgress() || app.isDisposed()) {\n              return;\n            }\n          }\n        }\n      }\n    }, \"MPS interrupting thread\");\n    myInterruptingThread.start();\n  }","commit_id":"ace68db40332694a8472b52c6fa59a926d0e41f5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void importXAR(File xarFile, String wiki) throws IOException, XWikiException\n    {\n        if (wiki == null) {\n            XWikiContext context = getXWikiContext();\n            if (context.getWiki().isVirtualMode()) {\n                List<String> wikis = getXWikiContext().getWiki().getVirtualWikisDatabaseNames(context);\n\n                if (!wikis.contains(context.getMainXWiki())) {\n                    importXARToWiki(xarFile, context.getMainXWiki());\n                }\n\n                for (String subwiki : wikis) {\n                    importXARToWiki(xarFile, subwiki);\n                }\n            } else {\n                importXARToWiki(xarFile, context.getMainXWiki());\n            }\n        } else {\n            importXARToWiki(xarFile, wiki);\n        }\n    }","id":87927,"modified_method":"public void importXAR(XarFile previousXarFile, File xarFile, String wiki) throws IOException, XWikiException\n    {\n        if (wiki == null) {\n            XWikiContext context = getXWikiContext();\n            if (context.getWiki().isVirtualMode()) {\n                List<String> wikis = getXWikiContext().getWiki().getVirtualWikisDatabaseNames(context);\n\n                if (!wikis.contains(context.getMainXWiki())) {\n                    importXARToWiki(previousXarFile, xarFile, context.getMainXWiki());\n                }\n\n                for (String subwiki : wikis) {\n                    importXARToWiki(previousXarFile, xarFile, subwiki);\n                }\n            } else {\n                importXARToWiki(previousXarFile, xarFile, context.getMainXWiki());\n            }\n        } else {\n            importXARToWiki(previousXarFile, xarFile, wiki);\n        }\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List<XarEntry> getEntries(File xarFile) throws IOException\n    {\n        List<XarEntry> documents = null;\n\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        XarPageLimitedHandler documentHandler = new XarPageLimitedHandler(this.componentManager);\n\n                        parseDocument(zis, documentHandler);\n\n                        if (documents == null) {\n                            documents = new ArrayList<XarEntry>();\n                        }\n\n                        XarEntry xarEntry = documentHandler.getXarEntry();\n                        xarEntry.setPath(entry.getName());\n\n                        documents.add(xarEntry);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n\n        return documents != null ? documents : Collections.<XarEntry> emptyList();\n    }","id":87928,"modified_method":"public List<XarEntry> getEntries(File xarFile) throws IOException\n    {\n        List<XarEntry> documents = null;\n\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry zipEntry = zis.getNextEntry(); zipEntry != null; zipEntry = zis.getNextEntry()) {\n                if (!zipEntry.isDirectory()) {\n                    try {\n                        XarPageLimitedHandler documentHandler = new XarPageLimitedHandler(this.componentManager);\n\n                        parseDocument(zis, documentHandler);\n\n                        if (documents == null) {\n                            documents = new ArrayList<XarEntry>();\n                        }\n\n                        XarEntry xarEntry = documentHandler.getXarEntry();\n                        xarEntry.setZipEntry(zipEntry);\n\n                        documents.add(xarEntry);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + zipEntry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n\n        return documents != null ? documents : Collections.<XarEntry> emptyList();\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void importXARToWiki(File xarFile, String wiki) throws IOException\n    {\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        DocumentImporterHandler documentHandler =\n                            new DocumentImporterHandler(this.componentManager, wiki);\n\n                        parseDocument(zis, documentHandler);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }","id":87929,"modified_method":"public void importXARToWiki(XarFile previousXarFile, File xarFile, String wiki) throws IOException\n    {\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        DocumentImporterHandler documentHandler =\n                            new DocumentImporterHandler(this.componentManager, wiki);\n\n                        parseDocument(zis, documentHandler);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endElementInternal(String uri, String localName, String qName) throws SAXException\n    {\n        if (qName.equals(\"attachment\")) {\n            if (!getDocument().getAttachmentList().isEmpty()) {\n                saveDocument(\"Import: save first attachment\");\n            }\n\n            AttachmentHandler handler = (AttachmentHandler) getCurrentHandler();\n\n            getDocument().getAttachmentList().add(handler.getAttachment());\n\n            // TODO: add attachment to document\n            saveDocument(\"Import: add attachment\");\n        } else if (qName.equals(\"object\")) {\n            try {\n                BaseObject baseObject = new BaseObject();\n                baseObject.fromXML(this.domBuilder.getDocument().getRootElement());\n                getDocument().setXObject(baseObject.getNumber(), baseObject);\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else if (qName.equals(\"class\")) {\n            try {\n                getDocument().getXClass().fromXML(this.domBuilder.getDocument().getRootElement());\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else {\n            super.endElementInternal(uri, localName, qName);\n        }\n    }","id":87930,"modified_method":"@Override\n    public void endElementInternal(String uri, String localName, String qName) throws SAXException\n    {\n        if (qName.equals(\"attachment\")) {\n            AttachmentHandler handler = (AttachmentHandler) getCurrentHandler();\n\n            saveAttachment(handler.getAttachment(), \"Import: add attachment\");\n        } else if (qName.equals(\"object\")) {\n            try {\n                BaseObject baseObject = new BaseObject();\n                baseObject.fromXML(this.domBuilder.getDocument().getRootElement());\n                getDocument().setXObject(baseObject.getNumber(), baseObject);\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else if (qName.equals(\"class\")) {\n            try {\n                getDocument().getXClass().fromXML(this.domBuilder.getDocument().getRootElement());\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else {\n            super.endElementInternal(uri, localName, qName);\n        }\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected void endHandlerElement(String uri, String localName, String qName) throws SAXException\n    {\n        if (this.needSave) {\n            saveDocument(this.fromDatabase ? \"Import: final save\" : \"Import\");\n        }\n    }","id":87931,"modified_method":"@Override\n    protected void endHandlerElement(String uri, String localName, String qName) throws SAXException\n    {\n        if (this.needSave) {\n            saveDocument(getDocument().getAttachmentList().isEmpty() ? \"Import\" : \"Import: final save\");\n        }\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n            XWikiDocument document = getDocument();\n\n            if (!this.fromDatabase) {\n                XWikiDocument existingDocument =\n                    context.getWiki().getDocument(document.getDocumentReference(), context);\n                existingDocument = existingDocument.getTranslatedDocument(document.getLanguage(), context);\n\n                if (!existingDocument.isNew()) {\n                    document.setVersion(existingDocument.getVersion());\n                }\n\n                this.fromDatabase = true;\n            }\n\n            context.getWiki().saveDocument(document, comment, context);\n\n            setCurrentBean(getXWikiContext().getWiki().getDocument(document.getDocumentReference(), context));\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n\n        this.needSave = false;\n    }","id":87932,"modified_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument document = getDocument();\n            XWikiDocument dbDocument = getDatabaseDocument();\n            // TODO: get previous document\n\n            // TODO: diff previous and new document\n            // TODO: if there is differences\n            // TODO: ..apply diff to db document\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n\n        this.needSave = false;\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void upgrade(LocalExtension previousLocalExtension, LocalExtension newLocalExtension, String namespace)\n        throws InstallException\n    {\n        // TODO\n        // 1) find all modified pages between old and new version\n        // 2) compare old version and wiki (to find pages modified by user)\n        // 3) delete pages removed in new version (even if modified ?)\n        // 4) merge xar\n        // 4.1) merge modified pages in wiki with diff between old/new version\n        // 4.2) update unmodified pages different between old and new version\n\n        // CURRENT\n\n        // Produce a pages diff between previous and new version\n        Set<XarEntry> previousPages = new HashSet<XarEntry>();\n        try {\n            XarLocalExtension previousXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(previousLocalExtension.getId());\n            previousPages.addAll(previousXarExtension.getPages());\n        } catch (ResolveException e) {\n            // Not supposed to be possible\n            throw new InstallException(\"Failed to get xar extension [\" + previousLocalExtension.getId()\n                + \"] from xar repository\", e);\n        }\n\n        List<XarEntry> newPages;\n        try {\n            XarLocalExtension newXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(newLocalExtension.getId());\n            newPages = newXarExtension.getPages();\n        } catch (ResolveException e) {\n            try {\n                newPages = this.packager.getEntries(newLocalExtension.getFile());\n            } catch (IOException e1) {\n                throw new InstallException(\"Failed to get xar extension [\" + newLocalExtension.getId() + \"] pages\", e);\n            }\n        }\n\n        for (XarEntry entry : newPages) {\n            previousPages.remove(entry);\n        }\n\n        // Install new pages\n        install(newLocalExtension, namespace);\n\n        // Remove old version pages not anymore in the new version\n        try {\n            this.packager.unimportPages(previousPages, namespace);\n        } catch (Exception e) {\n            // TODO: log warning\n        }\n    }","id":87933,"modified_method":"@Override\n    public void upgrade(LocalExtension previousLocalExtension, LocalExtension newLocalExtension, String namespace)\n        throws InstallException\n    {\n        // TODO\n        // 1) find all modified pages between old and new version\n        // 2) compare old version and wiki (to find pages modified by user)\n        // 3) delete pages removed in new version (even if modified ?)\n        // 4) merge xar\n        // 4.1) merge modified pages in wiki with diff between old/new version\n        // 4.2) update unmodified pages different between old and new version\n\n        // CURRENT\n\n        XarLocalExtension previousXarExtension;\n        try {\n            previousXarExtension = (XarLocalExtension) this.xarRepository.resolve(previousLocalExtension.getId());\n        } catch (ResolveException e) {\n            // Not supposed to be possible\n            throw new InstallException(\"Failed to get xar extension [\" + previousLocalExtension.getId()\n                + \"] from xar repository\", e);\n        }\n\n        // Install new pages\n        install(previousXarExtension, newLocalExtension, namespace);\n\n        // Uninstall old version pages not anymore in the new version\n        Set<XarEntry> previousPages = new HashSet<XarEntry>(previousXarExtension.getPages());\n\n        List<XarEntry> newPages;\n        try {\n            XarLocalExtension newXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(newLocalExtension.getId());\n            newPages = newXarExtension.getPages();\n        } catch (ResolveException e) {\n            try {\n                newPages = this.packager.getEntries(newLocalExtension.getFile());\n            } catch (IOException e1) {\n                throw new InstallException(\"Failed to get xar extension [\" + newLocalExtension.getId() + \"] pages\", e);\n            }\n        }\n\n        for (XarEntry entry : newPages) {\n            previousPages.remove(entry);\n        }\n\n        try {\n            this.packager.unimportPages(previousPages, namespace);\n        } catch (Exception e) {\n            this.logger.warn(\"Exception when cleaning pages removed since previous xar extension version\", e);\n        }\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void install(LocalExtension localExtension, String wiki) throws InstallException\n    {\n        // import xar into wiki (add new version when the page already exists)\n        try {\n            this.packager.importXAR(localExtension.getFile(), wiki);\n        } catch (Exception e) {\n            throw new InstallException(\"Failed to import xar for extension [\" + localExtension + \"]\", e);\n        }\n    }","id":87934,"modified_method":"public void install(LocalExtension localExtension, String wiki) throws InstallException\n    {\n        install(null, localExtension, wiki);\n    }","commit_id":"a81e4d814e1bf30886acb193c33afe32001dc614","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List<XarEntry> getEntries(File xarFile) throws IOException\n    {\n        List<XarEntry> documents = null;\n\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry zipEntry = zis.getNextEntry(); zipEntry != null; zipEntry = zis.getNextEntry()) {\n                if (!zipEntry.isDirectory()) {\n                    try {\n                        XarPageLimitedHandler documentHandler = new XarPageLimitedHandler(this.componentManager);\n\n                        parseDocument(zis, documentHandler);\n\n                        if (documents == null) {\n                            documents = new ArrayList<XarEntry>();\n                        }\n\n                        XarEntry xarEntry = documentHandler.getXarEntry();\n                        xarEntry.setZipEntry(zipEntry);\n\n                        documents.add(xarEntry);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + zipEntry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n\n        return documents != null ? documents : Collections.<XarEntry> emptyList();\n    }","id":87935,"modified_method":"public List<XarEntry> getEntries(File xarFile) throws IOException\n    {\n        List<XarEntry> documents = null;\n\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        XarPageLimitedHandler documentHandler = new XarPageLimitedHandler(this.componentManager);\n\n                        parseDocument(zis, documentHandler);\n\n                        if (documents == null) {\n                            documents = new ArrayList<XarEntry>();\n                        }\n\n                        XarEntry xarEntry = documentHandler.getXarEntry();\n                        xarEntry.setPath(entry.getName());\n\n                        documents.add(xarEntry);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n\n        return documents != null ? documents : Collections.<XarEntry> emptyList();\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void importXAR(XarFile previousXarFile, File xarFile, String wiki) throws IOException, XWikiException\n    {\n        if (wiki == null) {\n            XWikiContext context = getXWikiContext();\n            if (context.getWiki().isVirtualMode()) {\n                List<String> wikis = getXWikiContext().getWiki().getVirtualWikisDatabaseNames(context);\n\n                if (!wikis.contains(context.getMainXWiki())) {\n                    importXARToWiki(previousXarFile, xarFile, context.getMainXWiki());\n                }\n\n                for (String subwiki : wikis) {\n                    importXARToWiki(previousXarFile, xarFile, subwiki);\n                }\n            } else {\n                importXARToWiki(previousXarFile, xarFile, context.getMainXWiki());\n            }\n        } else {\n            importXARToWiki(previousXarFile, xarFile, wiki);\n        }\n    }","id":87936,"modified_method":"public void importXAR(File xarFile, String wiki) throws IOException, XWikiException\n    {\n        if (wiki == null) {\n            XWikiContext context = getXWikiContext();\n            if (context.getWiki().isVirtualMode()) {\n                List<String> wikis = getXWikiContext().getWiki().getVirtualWikisDatabaseNames(context);\n\n                if (!wikis.contains(context.getMainXWiki())) {\n                    importXARToWiki(xarFile, context.getMainXWiki());\n                }\n\n                for (String subwiki : wikis) {\n                    importXARToWiki(xarFile, subwiki);\n                }\n            } else {\n                importXARToWiki(xarFile, context.getMainXWiki());\n            }\n        } else {\n            importXARToWiki(xarFile, wiki);\n        }\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void importXARToWiki(XarFile previousXarFile, File xarFile, String wiki) throws IOException\n    {\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        DocumentImporterHandler documentHandler =\n                            new DocumentImporterHandler(this.componentManager, wiki);\n\n                        parseDocument(zis, documentHandler);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }","id":87937,"modified_method":"public void importXARToWiki(File xarFile, String wiki) throws IOException\n    {\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        DocumentImporterHandler documentHandler =\n                            new DocumentImporterHandler(this.componentManager, wiki);\n\n                        parseDocument(zis, documentHandler);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endElementInternal(String uri, String localName, String qName) throws SAXException\n    {\n        if (qName.equals(\"attachment\")) {\n            AttachmentHandler handler = (AttachmentHandler) getCurrentHandler();\n\n            saveAttachment(handler.getAttachment(), \"Import: add attachment\");\n        } else if (qName.equals(\"object\")) {\n            try {\n                BaseObject baseObject = new BaseObject();\n                baseObject.fromXML(this.domBuilder.getDocument().getRootElement());\n                getDocument().setXObject(baseObject.getNumber(), baseObject);\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else if (qName.equals(\"class\")) {\n            try {\n                getDocument().getXClass().fromXML(this.domBuilder.getDocument().getRootElement());\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else {\n            super.endElementInternal(uri, localName, qName);\n        }\n    }","id":87938,"modified_method":"@Override\n    public void endElementInternal(String uri, String localName, String qName) throws SAXException\n    {\n        if (qName.equals(\"attachment\")) {\n            if (!getDocument().getAttachmentList().isEmpty()) {\n                saveDocument(\"Import: save first attachment\");\n            }\n\n            AttachmentHandler handler = (AttachmentHandler) getCurrentHandler();\n\n            getDocument().getAttachmentList().add(handler.getAttachment());\n\n            // TODO: add attachment to document\n            saveDocument(\"Import: add attachment\");\n        } else if (qName.equals(\"object\")) {\n            try {\n                BaseObject baseObject = new BaseObject();\n                baseObject.fromXML(this.domBuilder.getDocument().getRootElement());\n                getDocument().setXObject(baseObject.getNumber(), baseObject);\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else if (qName.equals(\"class\")) {\n            try {\n                getDocument().getXClass().fromXML(this.domBuilder.getDocument().getRootElement());\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else {\n            super.endElementInternal(uri, localName, qName);\n        }\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected void endHandlerElement(String uri, String localName, String qName) throws SAXException\n    {\n        if (this.needSave) {\n            saveDocument(getDocument().getAttachmentList().isEmpty() ? \"Import\" : \"Import: final save\");\n        }\n    }","id":87939,"modified_method":"@Override\n    protected void endHandlerElement(String uri, String localName, String qName) throws SAXException\n    {\n        if (this.needSave) {\n            saveDocument(this.fromDatabase ? \"Import: final save\" : \"Import\");\n        }\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument document = getDocument();\n            XWikiDocument dbDocument = getDatabaseDocument();\n            // TODO: get previous document\n\n            // TODO: diff previous and new document\n            // TODO: if there is differences\n            // TODO: ..apply diff to db document\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n\n        this.needSave = false;\n    }","id":87940,"modified_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n            XWikiDocument document = getDocument();\n\n            if (!this.fromDatabase) {\n                XWikiDocument existingDocument =\n                    context.getWiki().getDocument(document.getDocumentReference(), context);\n                existingDocument = existingDocument.getTranslatedDocument(document.getLanguage(), context);\n\n                if (!existingDocument.isNew()) {\n                    document.setVersion(existingDocument.getVersion());\n                }\n\n                this.fromDatabase = true;\n            }\n\n            context.getWiki().saveDocument(document, comment, context);\n\n            setCurrentBean(getXWikiContext().getWiki().getDocument(document.getDocumentReference(), context));\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n\n        this.needSave = false;\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void install(LocalExtension localExtension, String wiki) throws InstallException\n    {\n        install(null, localExtension, wiki);\n    }","id":87941,"modified_method":"public void install(LocalExtension localExtension, String wiki) throws InstallException\n    {\n        // import xar into wiki (add new version when the page already exists)\n        try {\n            this.packager.importXAR(localExtension.getFile(), wiki);\n        } catch (Exception e) {\n            throw new InstallException(\"Failed to import xar for extension [\" + localExtension + \"]\", e);\n        }\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void upgrade(LocalExtension previousLocalExtension, LocalExtension newLocalExtension, String namespace)\n        throws InstallException\n    {\n        // TODO\n        // 1) find all modified pages between old and new version\n        // 2) compare old version and wiki (to find pages modified by user)\n        // 3) delete pages removed in new version (even if modified ?)\n        // 4) merge xar\n        // 4.1) merge modified pages in wiki with diff between old/new version\n        // 4.2) update unmodified pages different between old and new version\n\n        // CURRENT\n\n        XarLocalExtension previousXarExtension;\n        try {\n            previousXarExtension = (XarLocalExtension) this.xarRepository.resolve(previousLocalExtension.getId());\n        } catch (ResolveException e) {\n            // Not supposed to be possible\n            throw new InstallException(\"Failed to get xar extension [\" + previousLocalExtension.getId()\n                + \"] from xar repository\", e);\n        }\n\n        // Install new pages\n        install(previousXarExtension, newLocalExtension, namespace);\n\n        // Uninstall old version pages not anymore in the new version\n        Set<XarEntry> previousPages = new HashSet<XarEntry>(previousXarExtension.getPages());\n\n        List<XarEntry> newPages;\n        try {\n            XarLocalExtension newXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(newLocalExtension.getId());\n            newPages = newXarExtension.getPages();\n        } catch (ResolveException e) {\n            try {\n                newPages = this.packager.getEntries(newLocalExtension.getFile());\n            } catch (IOException e1) {\n                throw new InstallException(\"Failed to get xar extension [\" + newLocalExtension.getId() + \"] pages\", e);\n            }\n        }\n\n        for (XarEntry entry : newPages) {\n            previousPages.remove(entry);\n        }\n\n        try {\n            this.packager.unimportPages(previousPages, namespace);\n        } catch (Exception e) {\n            this.logger.warn(\"Exception when cleaning pages removed since previous xar extension version\", e);\n        }\n    }","id":87942,"modified_method":"@Override\n    public void upgrade(LocalExtension previousLocalExtension, LocalExtension newLocalExtension, String namespace)\n        throws InstallException\n    {\n        // TODO\n        // 1) find all modified pages between old and new version\n        // 2) compare old version and wiki (to find pages modified by user)\n        // 3) delete pages removed in new version (even if modified ?)\n        // 4) merge xar\n        // 4.1) merge modified pages in wiki with diff between old/new version\n        // 4.2) update unmodified pages different between old and new version\n\n        // CURRENT\n\n        // Produce a pages diff between previous and new version\n        Set<XarEntry> previousPages = new HashSet<XarEntry>();\n        try {\n            XarLocalExtension previousXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(previousLocalExtension.getId());\n            previousPages.addAll(previousXarExtension.getPages());\n        } catch (ResolveException e) {\n            // Not supposed to be possible\n            throw new InstallException(\"Failed to get xar extension [\" + previousLocalExtension.getId()\n                + \"] from xar repository\", e);\n        }\n\n        List<XarEntry> newPages;\n        try {\n            XarLocalExtension newXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(newLocalExtension.getId());\n            newPages = newXarExtension.getPages();\n        } catch (ResolveException e) {\n            try {\n                newPages = this.packager.getEntries(newLocalExtension.getFile());\n            } catch (IOException e1) {\n                throw new InstallException(\"Failed to get xar extension [\" + newLocalExtension.getId() + \"] pages\", e);\n            }\n        }\n\n        for (XarEntry entry : newPages) {\n            previousPages.remove(entry);\n        }\n\n        // Install new pages\n        install(newLocalExtension, namespace);\n\n        // Remove old version pages not anymore in the new version\n        try {\n            this.packager.unimportPages(previousPages, namespace);\n        } catch (Exception e) {\n            // TODO: log warning\n        }\n    }","commit_id":"cdc4075ddbc642f3a82b8c2a0e6120636e2cbd0f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void importXAR(File xarFile, String wiki) throws IOException, XWikiException\n    {\n        if (wiki == null) {\n            XWikiContext context = getXWikiContext();\n            if (context.getWiki().isVirtualMode()) {\n                List<String> wikis = getXWikiContext().getWiki().getVirtualWikisDatabaseNames(context);\n\n                if (!wikis.contains(context.getMainXWiki())) {\n                    importXARToWiki(xarFile, context.getMainXWiki());\n                }\n\n                for (String subwiki : wikis) {\n                    importXARToWiki(xarFile, subwiki);\n                }\n            } else {\n                importXARToWiki(xarFile, context.getMainXWiki());\n            }\n        } else {\n            importXARToWiki(xarFile, wiki);\n        }\n    }","id":87943,"modified_method":"public void importXAR(XarFile previousXarFile, File xarFile, String wiki) throws IOException, XWikiException\n    {\n        if (wiki == null) {\n            XWikiContext context = getXWikiContext();\n            if (context.getWiki().isVirtualMode()) {\n                List<String> wikis = getXWikiContext().getWiki().getVirtualWikisDatabaseNames(context);\n\n                if (!wikis.contains(context.getMainXWiki())) {\n                    importXARToWiki(previousXarFile, xarFile, context.getMainXWiki());\n                }\n\n                for (String subwiki : wikis) {\n                    importXARToWiki(previousXarFile, xarFile, subwiki);\n                }\n            } else {\n                importXARToWiki(previousXarFile, xarFile, context.getMainXWiki());\n            }\n        } else {\n            importXARToWiki(previousXarFile, xarFile, wiki);\n        }\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void importXARToWiki(File xarFile, String wiki) throws IOException\n    {\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        DocumentImporterHandler documentHandler =\n                            new DocumentImporterHandler(this.componentManager, wiki);\n\n                        parseDocument(zis, documentHandler);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }","id":87944,"modified_method":"public void importXARToWiki(XarFile previousXarFile, File xarFile, String wiki) throws IOException\n    {\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        DocumentImporterHandler documentHandler =\n                            new DocumentImporterHandler(this.componentManager, wiki);\n\n                        parseDocument(zis, documentHandler);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public List<XarEntry> getEntries(File xarFile) throws IOException\n    {\n        List<XarEntry> documents = null;\n\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry entry = zis.getNextEntry(); entry != null; entry = zis.getNextEntry()) {\n                if (!entry.isDirectory()) {\n                    try {\n                        XarPageLimitedHandler documentHandler = new XarPageLimitedHandler(this.componentManager);\n\n                        parseDocument(zis, documentHandler);\n\n                        if (documents == null) {\n                            documents = new ArrayList<XarEntry>();\n                        }\n\n                        XarEntry xarEntry = documentHandler.getXarEntry();\n                        xarEntry.setPath(entry.getName());\n\n                        documents.add(xarEntry);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + entry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n\n        return documents != null ? documents : Collections.<XarEntry> emptyList();\n    }","id":87945,"modified_method":"public List<XarEntry> getEntries(File xarFile) throws IOException\n    {\n        List<XarEntry> documents = null;\n\n        FileInputStream fis = new FileInputStream(xarFile);\n        ZipInputStream zis = new ZipInputStream(fis);\n\n        try {\n            for (ZipEntry zipEntry = zis.getNextEntry(); zipEntry != null; zipEntry = zis.getNextEntry()) {\n                if (!zipEntry.isDirectory()) {\n                    try {\n                        XarPageLimitedHandler documentHandler = new XarPageLimitedHandler(this.componentManager);\n\n                        parseDocument(zis, documentHandler);\n\n                        if (documents == null) {\n                            documents = new ArrayList<XarEntry>();\n                        }\n\n                        XarEntry xarEntry = documentHandler.getXarEntry();\n                        xarEntry.setZipEntry(zipEntry);\n\n                        documents.add(xarEntry);\n                    } catch (NotADocumentException e) {\n                        // Impossible to know that before parsing\n                    } catch (Exception e) {\n                        this.logger.error(\"Failed to parse document [\" + zipEntry.getName() + \"]\", e);\n                    }\n                }\n            }\n        } finally {\n            zis.close();\n        }\n\n        return documents != null ? documents : Collections.<XarEntry> emptyList();\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected void endHandlerElement(String uri, String localName, String qName) throws SAXException\n    {\n        if (this.needSave) {\n            saveDocument(this.fromDatabase ? \"Import: final save\" : \"Import\");\n        }\n    }","id":87946,"modified_method":"@Override\n    protected void endHandlerElement(String uri, String localName, String qName) throws SAXException\n    {\n        if (this.needSave) {\n            saveDocument(getDocument().getAttachmentList().isEmpty() ? \"Import\" : \"Import: final save\");\n        }\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n            XWikiDocument document = getDocument();\n\n            if (!this.fromDatabase) {\n                XWikiDocument existingDocument =\n                    context.getWiki().getDocument(document.getDocumentReference(), context);\n                existingDocument = existingDocument.getTranslatedDocument(document.getLanguage(), context);\n\n                if (!existingDocument.isNew()) {\n                    document.setVersion(existingDocument.getVersion());\n                }\n\n                this.fromDatabase = true;\n            }\n\n            context.getWiki().saveDocument(document, comment, context);\n\n            setCurrentBean(getXWikiContext().getWiki().getDocument(document.getDocumentReference(), context));\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n\n        this.needSave = false;\n    }","id":87947,"modified_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument document = getDocument();\n            XWikiDocument dbDocument = getDatabaseDocument();\n            // TODO: get previous document\n\n            // TODO: diff previous and new document\n            // TODO: if there is differences\n            // TODO: ..apply diff to db document\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n\n        this.needSave = false;\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void endElementInternal(String uri, String localName, String qName) throws SAXException\n    {\n        if (qName.equals(\"attachment\")) {\n            if (!getDocument().getAttachmentList().isEmpty()) {\n                saveDocument(\"Import: save first attachment\");\n            }\n\n            AttachmentHandler handler = (AttachmentHandler) getCurrentHandler();\n\n            getDocument().getAttachmentList().add(handler.getAttachment());\n\n            // TODO: add attachment to document\n            saveDocument(\"Import: add attachment\");\n        } else if (qName.equals(\"object\")) {\n            try {\n                BaseObject baseObject = new BaseObject();\n                baseObject.fromXML(this.domBuilder.getDocument().getRootElement());\n                getDocument().setXObject(baseObject.getNumber(), baseObject);\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else if (qName.equals(\"class\")) {\n            try {\n                getDocument().getXClass().fromXML(this.domBuilder.getDocument().getRootElement());\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else {\n            super.endElementInternal(uri, localName, qName);\n        }\n    }","id":87948,"modified_method":"@Override\n    public void endElementInternal(String uri, String localName, String qName) throws SAXException\n    {\n        if (qName.equals(\"attachment\")) {\n            AttachmentHandler handler = (AttachmentHandler) getCurrentHandler();\n\n            saveAttachment(handler.getAttachment(), \"Import: add attachment\");\n        } else if (qName.equals(\"object\")) {\n            try {\n                BaseObject baseObject = new BaseObject();\n                baseObject.fromXML(this.domBuilder.getDocument().getRootElement());\n                getDocument().setXObject(baseObject.getNumber(), baseObject);\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else if (qName.equals(\"class\")) {\n            try {\n                getDocument().getXClass().fromXML(this.domBuilder.getDocument().getRootElement());\n            } catch (XWikiException e) {\n                throw new SAXException(\"Failed to parse object\", e);\n            }\n\n            this.needSave = true;\n        } else {\n            super.endElementInternal(uri, localName, qName);\n        }\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void install(LocalExtension localExtension, String wiki) throws InstallException\n    {\n        // import xar into wiki (add new version when the page already exists)\n        try {\n            this.packager.importXAR(localExtension.getFile(), wiki);\n        } catch (Exception e) {\n            throw new InstallException(\"Failed to import xar for extension [\" + localExtension + \"]\", e);\n        }\n    }","id":87949,"modified_method":"public void install(LocalExtension localExtension, String wiki) throws InstallException\n    {\n        install(null, localExtension, wiki);\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void upgrade(LocalExtension previousLocalExtension, LocalExtension newLocalExtension, String namespace)\n        throws InstallException\n    {\n        // TODO\n        // 1) find all modified pages between old and new version\n        // 2) compare old version and wiki (to find pages modified by user)\n        // 3) delete pages removed in new version (even if modified ?)\n        // 4) merge xar\n        // 4.1) merge modified pages in wiki with diff between old/new version\n        // 4.2) update unmodified pages different between old and new version\n\n        // CURRENT\n\n        // Produce a pages diff between previous and new version\n        Set<XarEntry> previousPages = new HashSet<XarEntry>();\n        try {\n            XarLocalExtension previousXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(previousLocalExtension.getId());\n            previousPages.addAll(previousXarExtension.getPages());\n        } catch (ResolveException e) {\n            // Not supposed to be possible\n            throw new InstallException(\"Failed to get xar extension [\" + previousLocalExtension.getId()\n                + \"] from xar repository\", e);\n        }\n\n        List<XarEntry> newPages;\n        try {\n            XarLocalExtension newXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(newLocalExtension.getId());\n            newPages = newXarExtension.getPages();\n        } catch (ResolveException e) {\n            try {\n                newPages = this.packager.getEntries(newLocalExtension.getFile());\n            } catch (IOException e1) {\n                throw new InstallException(\"Failed to get xar extension [\" + newLocalExtension.getId() + \"] pages\", e);\n            }\n        }\n\n        for (XarEntry entry : newPages) {\n            previousPages.remove(entry);\n        }\n\n        // Install new pages\n        install(newLocalExtension, namespace);\n\n        // Remove old version pages not anymore in the new version\n        try {\n            this.packager.unimportPages(previousPages, namespace);\n        } catch (Exception e) {\n            // TODO: log warning\n        }\n    }","id":87950,"modified_method":"@Override\n    public void upgrade(LocalExtension previousLocalExtension, LocalExtension newLocalExtension, String namespace)\n        throws InstallException\n    {\n        // TODO\n        // 1) find all modified pages between old and new version\n        // 2) compare old version and wiki (to find pages modified by user)\n        // 3) delete pages removed in new version (even if modified ?)\n        // 4) merge xar\n        // 4.1) merge modified pages in wiki with diff between old/new version\n        // 4.2) update unmodified pages different between old and new version\n\n        // CURRENT\n\n        XarLocalExtension previousXarExtension;\n        try {\n            previousXarExtension = (XarLocalExtension) this.xarRepository.resolve(previousLocalExtension.getId());\n        } catch (ResolveException e) {\n            // Not supposed to be possible\n            throw new InstallException(\"Failed to get xar extension [\" + previousLocalExtension.getId()\n                + \"] from xar repository\", e);\n        }\n\n        // Install new pages\n        install(previousXarExtension, newLocalExtension, namespace);\n\n        // Uninstall old version pages not anymore in the new version\n        Set<XarEntry> previousPages = new HashSet<XarEntry>(previousXarExtension.getPages());\n\n        List<XarEntry> newPages;\n        try {\n            XarLocalExtension newXarExtension =\n                (XarLocalExtension) this.xarRepository.resolve(newLocalExtension.getId());\n            newPages = newXarExtension.getPages();\n        } catch (ResolveException e) {\n            try {\n                newPages = this.packager.getEntries(newLocalExtension.getFile());\n            } catch (IOException e1) {\n                throw new InstallException(\"Failed to get xar extension [\" + newLocalExtension.getId() + \"] pages\", e);\n            }\n        }\n\n        for (XarEntry entry : newPages) {\n            previousPages.remove(entry);\n        }\n\n        try {\n            this.packager.unimportPages(previousPages, namespace);\n        } catch (Exception e) {\n            this.logger.warn(\"Exception when cleaning pages removed since previous xar extension version\", e);\n        }\n    }","commit_id":"0d0cc1870f45e3ea2df9abd19efc5143312f5f74","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public int getLineHeight() {\n    synchronized (myLock) {\n      if (myLineHeight < 0) {\n        EditorColorsScheme colorsScheme = myEditor.getColorsScheme();\n        FontMetrics fm = myEditor.getContentComponent().getFontMetrics(colorsScheme.getFont(EditorFontType.PLAIN));\n        int fontMetricsHeight = FontLayoutService.getInstance().getHeight(fm);\n        myLineHeight = (int)(fontMetricsHeight * (myEditor.isOneLineMode() ? 1 : colorsScheme.getLineSpacing()));\n        if (myLineHeight <= 0) {\n          myLineHeight = fontMetricsHeight;\n          if (myLineHeight <= 0) {\n            myLineHeight = 12;\n          }\n        }\n      }\n      return myLineHeight;\n    }\n  }","id":87951,"modified_method":"public int getLineHeight() {\n    synchronized (myLock) {\n      if (myLineHeight < 0) {\n        FontMetrics fm = myEditor.getContentComponent().getFontMetrics(myEditor.getColorsScheme().getFont(EditorFontType.PLAIN));\n        int fontMetricsHeight = FontLayoutService.getInstance().getHeight(fm);\n        myLineHeight = (int)Math.ceil(fontMetricsHeight * getVerticalScalingFactor());\n      }\n      return myLineHeight;\n    }\n  }","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getDescent() {\n    synchronized (myLock) {\n      if (myDescent < 0) {\n        FontMetrics fm = myEditor.getContentComponent().getFontMetrics(myEditor.getColorsScheme().getFont(EditorFontType.PLAIN));\n        myDescent = FontLayoutService.getInstance().getDescent(fm);\n      }\n      return myDescent;\n    }\n  }","id":87952,"modified_method":"public int getDescent() {\n    synchronized (myLock) {\n      return getLineHeight() - getAscent();\n    }\n  }","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getAscent() {\n    synchronized (myLock) {\n      return getLineHeight() - getDescent();\n    }\n  }","id":87953,"modified_method":"public int getAscent() {\n    synchronized (myLock) {\n      if (myAscent < 0) {\n        FontMetrics fm = myEditor.getContentComponent().getFontMetrics(myEditor.getColorsScheme().getFont(EditorFontType.PLAIN));\n        int ascent = FontLayoutService.getInstance().getAscent(fm);\n        myAscent = (int)Math.ceil(ascent * getVerticalScalingFactor());\n      }\n      return myAscent;\n    }\n  }","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String dumpState() {\n    return \"[prefix text: \" + myPrefixText + \n           \", prefix attributes: \" + myPrefixAttributes + \n           \", space width: \" + myPlainSpaceWidth +\n           \", line height: \" + myLineHeight +\n           \", descent: \" + myDescent +\n           \", char height: \" + myCharHeight +\n           \", max char width: \" + myMaxCharWidth +\n           \", tab size: \" + myTabSize + \n           \" ,size manager: \" + mySizeManager.dumpState() + \n           \" ,logical position cache: \" + myLogicalPositionCache.dumpState() +\n           \"]\";\n  }","id":87954,"modified_method":"@NotNull\n  @Override\n  public String dumpState() {\n    return \"[prefix text: \" + myPrefixText + \n           \", prefix attributes: \" + myPrefixAttributes + \n           \", space width: \" + myPlainSpaceWidth +\n           \", line height: \" + myLineHeight +\n           \", ascent: \" + myAscent +\n           \", char height: \" + myCharHeight +\n           \", max char width: \" + myMaxCharWidth +\n           \", tab size: \" + myTabSize + \n           \" ,size manager: \" + mySizeManager.dumpState() + \n           \" ,logical position cache: \" + myLogicalPositionCache.dumpState() +\n           \"]\";\n  }","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reinitSettings() {\n    assertIsDispatchThread();\n    myPlainSpaceWidth = -1;\n    synchronized (myLock) {\n      myLineHeight = -1;\n      myDescent = -1;\n      myCharHeight = -1;\n      myMaxCharWidth = -1;\n      myTabSize = -1;\n    }\n    myLogicalPositionCache.reset(false);\n    myTextLayoutCache.resetToDocumentSize(false);\n    invalidateFoldRegionLayouts();\n    setPrefix(myPrefixText, myPrefixAttributes); // recreate prefix layout\n    mySizeManager.reset();\n  }","id":87955,"modified_method":"public void reinitSettings() {\n    assertIsDispatchThread();\n    myPlainSpaceWidth = -1;\n    synchronized (myLock) {\n      myLineHeight = -1;\n      myAscent = -1;\n      myCharHeight = -1;\n      myMaxCharWidth = -1;\n      myTabSize = -1;\n    }\n    myLogicalPositionCache.reset(false);\n    myTextLayoutCache.resetToDocumentSize(false);\n    invalidateFoldRegionLayouts();\n    setPrefix(myPrefixText, myPrefixAttributes); // recreate prefix layout\n    mySizeManager.reset();\n  }","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public int getDescent(@NotNull FontMetrics fontMetrics) {\n      return fontMetrics.getDescent();\n    }","id":87956,"modified_method":"@Override\n    public int getAscent(@NotNull FontMetrics fontMetrics) {\n      return fontMetrics.getAscent();\n    }","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public abstract int getDescent(@NotNull FontMetrics fontMetrics);","id":87957,"modified_method":"public abstract int getAscent(@NotNull FontMetrics fontMetrics);","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getDescent(@NotNull FontMetrics fontMetrics) {\n    return myDescent;\n  }","id":87958,"modified_method":"@Override\n  public int getAscent(@NotNull FontMetrics fontMetrics) {\n    return myLineHeight - myDescent;\n  }","commit_id":"c0589fa7dffb600977153a5bf1009e3c7c99ee88","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public TextAttributes getTextAttributes(@Nullable final PsiElement element, @Nullable final EditorColorsScheme editorColorsScheme) {\n    if (forcedTextAttributes != null) {\n      return forcedTextAttributes;\n    }\n\n    EditorColorsScheme colorsScheme = getColorsScheme(editorColorsScheme);\n\n    if (forcedTextAttributesKey != null) {\n      return colorsScheme.getAttributes(forcedTextAttributesKey);\n    }\n\n    TextAttributes attributes = getAttributesByType(element, type, colorsScheme);\n    if (RainbowHighlighter.isRainbowEnabled() &&\n        isLikeVariable(type.getAttributesKey()) && element != null) {\n      String text = element.getContainingFile().getText();\n      String name = text.substring(startOffset, endOffset);\n      TextAttributes rainAttributes = new RainbowHighlighter(colorsScheme).getAttributes(name);\n      attributes = TextAttributes.merge(attributes, rainAttributes);\n    }\n    return attributes;\n  }","id":87959,"modified_method":"@Nullable\n  public TextAttributes getTextAttributes(@Nullable final PsiElement element, @Nullable final EditorColorsScheme editorColorsScheme) {\n    if (forcedTextAttributes != null) {\n      return forcedTextAttributes;\n    }\n\n    EditorColorsScheme colorsScheme = getColorsScheme(editorColorsScheme);\n\n    if (forcedTextAttributesKey != null) {\n      return colorsScheme.getAttributes(forcedTextAttributesKey);\n    }\n\n    TextAttributes attributes = getAttributesByType(element, type, colorsScheme);\n    if (element != null &&\n        RainbowHighlighter.isRainbowEnabled() &&\n        !RainbowHighlighter.isByPassLanguage(element.getLanguage()) &&\n        isLikeVariable(type.getAttributesKey())) {\n      String text = element.getContainingFile().getText();\n      String name = text.substring(startOffset, endOffset);\n      attributes = new RainbowHighlighter(colorsScheme).getAttributes(name, attributes);\n    }\n    return attributes;\n  }","commit_id":"7469f78ea6cdc9145f883bc61a4dacb05f4eafed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RainbowHighlighter(@NotNull TextAttributesScheme colorsScheme) {\n    myColorsSchemeAttributes = colorsScheme.getAttributes(DefaultLanguageHighlighterColors.CONSTANT);\n    float[] components = myColorsSchemeAttributes.getForegroundColor().getRGBColorComponents(null);\n    myFloats = Color.RGBtoHSB((int)(255 * components[0]), (int)(255 * components[0]), (int)(255 * components[0]), null);\n  }","id":87960,"modified_method":"public RainbowHighlighter(@NotNull TextAttributesScheme colorsScheme) {\n    float[] components = colorsScheme.getAttributes(DefaultLanguageHighlighterColors.CONSTANT).getForegroundColor().getRGBColorComponents(null);\n    myFloats = Color.RGBtoHSB((int)(255 * components[0]), (int)(255 * components[0]), (int)(255 * components[0]), null);\n  }","commit_id":"7469f78ea6cdc9145f883bc61a4dacb05f4eafed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public TextAttributes getAttributes(@NotNull String name) {\n    int hash = StringHash.murmur(name, 0);\n    final float colors = 36.0f;\n    final float v = Math.round(Math.abs(colors * hash) / Integer.MAX_VALUE) / colors;\n    //System.out.println(\"name = \" + name + \" \\tv=\" + v);\n    final Color color = Color.getHSBColor(v, 0.7f, myFloats[2] + .3f);\n\n    final TextAttributes attributes = TextAttributes.fromFlyweight(myColorsSchemeAttributes\n                                                                     .getFlyweight()\n                                                                     .withForeground(color)\n    //fixme: uta: foreground color is not activated for local variables without background color reset\n                                                                     .withBackground(UIManager.getColor(\"EditorPane.background\")));\n\n    return attributes;\n  }","id":87961,"modified_method":"@NotNull\n  public TextAttributes getAttributes(@NotNull String name, @NotNull TextAttributes origin) {\n    int hash = StringHash.murmur(name, 0);\n    final float colors = 36.0f;\n    final float v = Math.round(Math.abs(colors * hash) / Integer.MAX_VALUE) / colors;\n    //System.out.println(\"name = \" + name + \" \\tv=\" + v);\n    final Color color = Color.getHSBColor(v, 0.7f, myFloats[2] + .3f);\n\n    return TextAttributes.fromFlyweight(origin\n                                          .getFlyweight()\n                                          .withForeground(color)\n    //fixme: uta: foreground color is not activated for local variables without background color reset\n                                          .withBackground(UIManager.getColor(\"EditorPane.background\"))\n    );\n  }","commit_id":"7469f78ea6cdc9145f883bc61a4dacb05f4eafed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected RainbowIdentifierHighlighterPass(@NotNull PsiFile file, @NotNull Editor editor) {\n    super(file.getProject(), editor.getDocument(), false);\n    myFile = file;\n    myRainbowHighlighter = new RainbowHighlighter(editor.getColorsScheme());\n  }","id":87962,"modified_method":"protected RainbowIdentifierHighlighterPass(@NotNull PsiFile file, @NotNull Editor editor) {\n    super(file.getProject(), editor.getDocument(), false);\n    myFile = file;\n    myEditorColorsScheme = editor.getColorsScheme();\n    myRainbowHighlighter = new RainbowHighlighter(myEditorColorsScheme);\n  }","commit_id":"7469f78ea6cdc9145f883bc61a4dacb05f4eafed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected HighlightInfo getInfo(@Nullable String colorKey, @Nullable PsiElement id) {\n    if (id == null || colorKey == null || StringUtil.isEmpty(colorKey)) return null;\n    final TextAttributes attributes = myRainbowHighlighter.getAttributes(colorKey);\n    return HighlightInfo\n      .newHighlightInfo(RainbowHighlighter.RAINBOW_ELEMENT)\n      .textAttributes(attributes)\n      .range(id)\n      .create();\n  }","id":87963,"modified_method":"protected HighlightInfo getInfo(@Nullable String nameKey, @Nullable PsiElement id, @Nullable TextAttributesKey colorKey) {\n    if (id == null || nameKey == null || StringUtil.isEmpty(nameKey)) return null;\n    if (colorKey == null) colorKey = DefaultLanguageHighlighterColors.LOCAL_VARIABLE;\n    final TextAttributes attributes = myRainbowHighlighter.getAttributes(nameKey,\n                                                                         myEditorColorsScheme.getAttributes(colorKey));\n    return HighlightInfo\n      .newHighlightInfo(RainbowHighlighter.RAINBOW_ELEMENT)\n      .textAttributes(attributes)\n      .range(id)\n      .create();\n  }","commit_id":"7469f78ea6cdc9145f883bc61a4dacb05f4eafed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void doCollectInformation(@NotNull final ProgressIndicator progress) {\n    // reference implementation!\n    final List<HighlightInfo> infos = new ArrayList<>();\n    myFile.accept(new PsiRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitElement(PsiElement e) {\n        final HighlightInfo attrs;\n        if (e instanceof PsiReference) {\n          attrs = getInfo(e.getText(), e);\n        }\n        else if (e instanceof PsiNameIdentifierOwner) {\n          PsiNameIdentifierOwner identifierOwner = (PsiNameIdentifierOwner)e;\n          attrs = getInfo(identifierOwner.getName(), identifierOwner.getNameIdentifier());\n        }\n        else {\n          attrs = null;\n        }\n        if (attrs != null) {\n          infos.add(attrs);\n        }\n        super.visitElement(e);\n      }\n    });\n    toHighlight = infos;\n  }","id":87964,"modified_method":"@Override\n  public void doCollectInformation(@NotNull final ProgressIndicator progress) {\n    // reference implementation!\n    final List<HighlightInfo> infos = new ArrayList<>();\n    myFile.accept(new PsiRecursiveElementWalkingVisitor() {\n      @Override\n      public void visitElement(PsiElement e) {\n        final HighlightInfo attrs;\n        if (e instanceof PsiReference) {\n          attrs = getInfo(e.getText(), e, null);\n        }\n        else if (e instanceof PsiNameIdentifierOwner) {\n          PsiNameIdentifierOwner identifierOwner = (PsiNameIdentifierOwner)e;\n          attrs = getInfo(identifierOwner.getName(), identifierOwner.getNameIdentifier(), null);\n        }\n        else {\n          attrs = null;\n        }\n        if (attrs != null) {\n          infos.add(attrs);\n        }\n        super.visitElement(e);\n      }\n    });\n    toHighlight = infos;\n  }","commit_id":"7469f78ea6cdc9145f883bc61a4dacb05f4eafed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reinitSettings() {\n    myBackgroundColor = null;\n    revalidateMarkup();\n    repaint();\n  }","id":87965,"modified_method":"public void reinitSettings() {\n    revalidateMarkup();\n    repaint();\n  }","commit_id":"f7092c7cf5005cc854958b8bc139eadb9c25a538","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void paint(Graphics g) {\n    ((ApplicationImpl)ApplicationManager.getApplication()).editorPaintStart();\n    try {\n      Rectangle clip = g.getClipBounds();\n      if (clip.height < 0) return;\n\n      final Graphics2D g2 = (Graphics2D)g;\n      final AffineTransform old = g2.getTransform();\n\n      if (isMirrored()) {\n        final AffineTransform transform = new AffineTransform(old);\n        transform.scale(-1, 1);\n        transform.translate(-getWidth(), 0);\n        g2.setTransform(transform);\n      }\n\n      UISettings.setupAntialiasing(g);\n      paintLineNumbersBackground(g, clip);\n      paintAnnotationsBackground(g, clip);\n\n      Object hint = g2.getRenderingHint(RenderingHints.KEY_ANTIALIASING);\n      if (!UIUtil.isRetina()) g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n\n      try {\n        int firstVisibleOffset = myEditor.logicalPositionToOffset(myEditor.xyToLogicalPosition(new Point(0, clip.y - myEditor.getLineHeight())));\n        int lastVisibleOffset = myEditor.logicalPositionToOffset(myEditor.xyToLogicalPosition(new Point(0, clip.y + clip.height + myEditor.getLineHeight())));\n        paintFoldingBackground(g, clip);\n        paintLineMarkersBackground(g, clip);\n        paintBackground(g, clip, getLineMarkerAreaOffset(), getLineMarkerAreaWidth());\n        paintEditorBackgrounds(g, firstVisibleOffset, lastVisibleOffset);\n        paintAnnotations(g, clip);\n        paintLineMarkers(g, firstVisibleOffset, lastVisibleOffset);\n        paintFoldingLines((Graphics2D)g, clip);\n        paintFoldingTree(g, clip, firstVisibleOffset, lastVisibleOffset);\n        paintLineNumbers(g, clip);\n      }\n      finally {\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, hint);\n      }\n\n      g2.setTransform(old);\n    }\n    finally {\n      ((ApplicationImpl)ApplicationManager.getApplication()).editorPaintFinish();\n    }\n  }","id":87966,"modified_method":"@Override\n  public void paint(Graphics g) {\n    ((ApplicationImpl)ApplicationManager.getApplication()).editorPaintStart();\n    try {\n      Rectangle clip = g.getClipBounds();\n      if (clip.height < 0) return;\n\n      final Graphics2D g2 = (Graphics2D)g;\n      final AffineTransform old = g2.getTransform();\n\n      if (isMirrored()) {\n        final AffineTransform transform = new AffineTransform(old);\n        transform.scale(-1, 1);\n        transform.translate(-getWidth(), 0);\n        g2.setTransform(transform);\n      }\n\n      UISettings.setupAntialiasing(g);\n      Color backgroundColor = getBackground();\n      paintLineNumbersBackground(g, clip, backgroundColor);\n      paintAnnotationsBackground(g, clip, backgroundColor);\n\n      Object hint = g2.getRenderingHint(RenderingHints.KEY_ANTIALIASING);\n      if (!UIUtil.isRetina()) g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n\n      try {\n        int firstVisibleOffset = myEditor.logicalPositionToOffset(myEditor.xyToLogicalPosition(new Point(0, clip.y - myEditor.getLineHeight())));\n        int lastVisibleOffset = myEditor.logicalPositionToOffset(myEditor.xyToLogicalPosition(new Point(0, clip.y + clip.height + myEditor.getLineHeight())));\n        paintFoldingBackground(g, clip, backgroundColor);\n        paintLineMarkersBackground(g, clip, backgroundColor);\n        paintBackground(g, clip, getLineMarkerAreaOffset(), getLineMarkerAreaWidth(), backgroundColor);\n        paintEditorBackgrounds(g, firstVisibleOffset, lastVisibleOffset);\n        paintAnnotations(g, clip);\n        paintLineMarkers(g, firstVisibleOffset, lastVisibleOffset);\n        paintFoldingLines((Graphics2D)g, clip);\n        paintFoldingTree(g, clip, firstVisibleOffset, lastVisibleOffset);\n        paintLineNumbers(g, clip);\n      }\n      finally {\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, hint);\n      }\n\n      g2.setTransform(old);\n    }\n    finally {\n      ((ApplicationImpl)ApplicationManager.getApplication()).editorPaintFinish();\n    }\n  }","commit_id":"f7092c7cf5005cc854958b8bc139eadb9c25a538","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintAnnotationsBackground(Graphics g, Rectangle clip) {\n    int w = getAnnotationsAreaWidthEx();\n    if (w == 0) return;\n    final Color background = myEditor.isInDistractionFreeMode() ? myEditor.getBackgroundColor() : getBackground();\n    paintBackground(g, clip, getAnnotationsAreaOffset(), w, background);\n  }","id":87967,"modified_method":"private void paintAnnotationsBackground(Graphics g, Rectangle clip, Color backgroundColor) {\n    int w = getAnnotationsAreaWidthEx();\n    if (w == 0) return;\n    paintBackground(g, clip, getAnnotationsAreaOffset(), w, backgroundColor);\n  }","commit_id":"f7092c7cf5005cc854958b8bc139eadb9c25a538","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintFoldingBackground(Graphics g, Rectangle clip) {\n    int lineX = getWhitespaceSeparatorOffset();\n    paintBackground(g, clip, getFoldingAreaOffset(), getFoldingAreaWidth());\n\n    g.setColor(myEditor.getBackgroundColor());\n    g.fillRect(lineX, clip.y, getFoldingAreaWidth(), clip.height);\n\n    paintCaretRowBackground(g, lineX, getFoldingAnchorWidth());\n  }","id":87968,"modified_method":"private void paintFoldingBackground(Graphics g, Rectangle clip, Color bgColor) {\n    int lineX = getWhitespaceSeparatorOffset();\n    paintBackground(g, clip, getFoldingAreaOffset(), getFoldingAreaWidth(), bgColor);\n\n    g.setColor(myEditor.getBackgroundColor());\n    g.fillRect(lineX, clip.y, getFoldingAreaWidth(), clip.height);\n\n    paintCaretRowBackground(g, lineX, getFoldingAnchorWidth());\n  }","commit_id":"f7092c7cf5005cc854958b8bc139eadb9c25a538","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintLineNumbersBackground(Graphics g, Rectangle clip) {\n    if (isLineNumbersShown()) {\n      paintBackground(g, clip, getLineNumberAreaOffset(), getLineNumberAreaWidth());\n    }\n  }","id":87969,"modified_method":"private void paintLineNumbersBackground(Graphics g, Rectangle clip, Color bgColor) {\n    if (isLineNumbersShown()) {\n      paintBackground(g, clip, getLineNumberAreaOffset(), getLineNumberAreaWidth(), bgColor);\n    }\n  }","commit_id":"f7092c7cf5005cc854958b8bc139eadb9c25a538","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Color getBackground() {\n    if (myBackgroundColor == null) {\n      EditorColorsScheme colorsScheme = myEditor.getColorsScheme();\n      boolean distractionMode = myEditor.isInDistractionFreeMode();\n      Color color = distractionMode ? colorsScheme.getDefaultBackground() : colorsScheme.getColor(EditorColors.GUTTER_BACKGROUND);\n      myBackgroundColor = color == null ? EditorColors.GUTTER_BACKGROUND.getDefaultColor() : color;\n    }\n    return myBackgroundColor;\n  }","id":87970,"modified_method":"@Override\n  public Color getBackground() {\n    if (myEditor.isInDistractionFreeMode()) {\n      return myEditor.getBackgroundColor();\n    }\n    Color color = myEditor.getColorsScheme().getColor(EditorColors.GUTTER_BACKGROUND);\n    return color != null ? color : EditorColors.GUTTER_BACKGROUND.getDefaultColor();\n  }","commit_id":"f7092c7cf5005cc854958b8bc139eadb9c25a538","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void paintLineMarkersBackground(Graphics g, Rectangle clip) {\n    if (isLineMarkersShown()) {\n      paintBackground(g, clip, getLineMarkerAreaOffset(), getLineMarkerAreaWidth());\n    }\n  }","id":87971,"modified_method":"private void paintLineMarkersBackground(Graphics g, Rectangle clip, Color bgColor) {\n    if (isLineMarkersShown()) {\n      paintBackground(g, clip, getLineMarkerAreaOffset(), getLineMarkerAreaWidth(), bgColor);\n    }\n  }","commit_id":"f7092c7cf5005cc854958b8bc139eadb9c25a538","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\r\n        Set<UUID> possibleTargets = new HashSet<>();\r\n        for (StackObject stackObject :  game.getStack()) {\r\n            if (stackObject.getStackAbility() != null && (stackObject.getStackAbility() instanceof ActivatedAbility) && game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getStackAbility().getControllerId())) {\r\n                possibleTargets.add(stackObject.getStackAbility().getId());\r\n            }\r\n        }\r\n        return possibleTargets;\r\n    }","id":87972,"modified_method":"@Override\r\n    public Set<UUID> possibleTargets(UUID sourceControllerId, Game game) {\r\n        Set<UUID> possibleTargets = new HashSet<>();\r\n        for (StackObject stackObject :  game.getStack()) {\r\n            if (stackObject.getStackAbility().getAbilityType().equals(AbilityType.ACTIVATED) && game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getStackAbility().getControllerId())) {\r\n                possibleTargets.add(stackObject.getStackAbility().getId());\r\n            }\r\n        }\r\n        return possibleTargets;\r\n    }","commit_id":"da0c7d4d063dd37f5e97e8d76771fd50beffde13","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean canChoose(UUID sourceControllerId, Game game) {\r\n        for (StackObject stackObject :  game.getStack()) {\r\n            if (stackObject.getStackAbility() != null && (stackObject.getStackAbility() instanceof ActivatedAbility) && game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getStackAbility().getControllerId())) {\r\n                    return true;\r\n                }\r\n            }\r\n        return false;\r\n    }","id":87973,"modified_method":"@Override\r\n    public boolean canChoose(UUID sourceControllerId, Game game) {\r\n        for (StackObject stackObject :  game.getStack()) {\r\n            if (stackObject.getStackAbility() != null \r\n                    && stackObject.getStackAbility().getAbilityType().equals(AbilityType.ACTIVATED)\r\n                    && game.getPlayer(sourceControllerId).getInRange().contains(stackObject.getStackAbility().getControllerId())) {\r\n                    return true;\r\n                }\r\n            }\r\n        return false;\r\n    }","commit_id":"da0c7d4d063dd37f5e97e8d76771fd50beffde13","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean canTarget(UUID id, Ability source, Game game) {\r\n        if (source != null && source.getSourceId().equals(id)) {\r\n            return false;\r\n        }\r\n\r\n        StackObject stackObject = game.getStack().getStackObject(id);\r\n        if (stackObject.getStackAbility() != null && (stackObject.getStackAbility() instanceof ActivatedAbility)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":87974,"modified_method":"@Override\r\n    public boolean canTarget(UUID id, Ability source, Game game) {\r\n        if (source != null && source.getSourceId().equals(id)) {\r\n            return false;\r\n        }\r\n\r\n        StackObject stackObject = game.getStack().getStackObject(id);\r\n        return stackObject != null && stackObject.getStackAbility() != null && stackObject.getStackAbility().getAbilityType().equals(AbilityType.ACTIVATED);\r\n    }","commit_id":"da0c7d4d063dd37f5e97e8d76771fd50beffde13","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n  public void patchJavaParameters(@Nullable Module module, JavaParameters javaParameters) {\n    if (module == null) return;\n\n    MavenProject mavenProject = MavenProjectsManager.getInstance(module.getProject()).findProject(module);\n    if (mavenProject == null) return;\n\n    Element config = mavenProject.getPluginConfiguration(\"org.apache.maven.plugins\", \"maven-surefire-plugin\");\n    if (config == null) return;\n\n    List<String> paths = MavenJDOMUtil.findChildrenValuesByPath(config, \"additionalClasspathElements\", \"additionalClasspathElement\");\n\n    if (paths.size() > 0) {\n      MavenDomProjectModel domModel = MavenDomUtil.getMavenDomProjectModel(module.getProject(), mavenProject.getFile());\n\n      for (String path : paths) {\n        if (domModel != null) {\n          path = MavenPropertyResolver.resolve(path, domModel);\n        }\n\n        javaParameters.getClassPath().add(resolveSurefireProperties(path));\n      }\n    }\n\n    Element systemPropertyVariables = config.getChild(\"systemPropertyVariables\");\n    if (systemPropertyVariables != null && isEnabled(\"systemPropertyVariables\")) {\n      for (Element element : systemPropertyVariables.getChildren()) {\n        String propertyName = element.getName();\n\n        if (!javaParameters.getVMParametersList().hasProperty(propertyName)) {\n          javaParameters.getVMParametersList().addProperty(propertyName, resolveSurefireProperties(element.getValue()));\n        }\n      }\n    }\n\n    Element environmentVariables = config.getChild(\"environmentVariables\");\n    if (environmentVariables != null && isEnabled(\"environmentVariables\")) {\n      for (Element element : environmentVariables.getChildren()) {\n        String variableName = element.getName();\n\n        if (javaParameters.getEnv() == null || !javaParameters.getEnv().containsKey(variableName)) {\n          javaParameters.addEnv(variableName, resolveSurefireProperties(element.getValue()));\n        }\n      }\n    }\n\n    Element argLine = config.getChild(\"argLine\");\n    if (argLine != null && isEnabled(\"argLine\")) {\n      String value = argLine.getTextTrim();\n      if (StringUtil.isNotEmpty(value)) {\n        javaParameters.getVMParametersList().addParametersString(resolveSurefireProperties(value));\n      }\n    }\n  }","id":87975,"modified_method":"@Override\n  public void patchJavaParameters(@Nullable Module module, JavaParameters javaParameters) {\n    if (module == null) return;\n\n    MavenProject mavenProject = MavenProjectsManager.getInstance(module.getProject()).findProject(module);\n    if (mavenProject == null) return;\n\n    Element config = mavenProject.getPluginConfiguration(\"org.apache.maven.plugins\", \"maven-surefire-plugin\");\n    if (config == null) return;\n\n    List<String> paths = MavenJDOMUtil.findChildrenValuesByPath(config, \"additionalClasspathElements\", \"additionalClasspathElement\");\n\n    if (paths.size() > 0) {\n      MavenDomProjectModel domModel = MavenDomUtil.getMavenDomProjectModel(module.getProject(), mavenProject.getFile());\n\n      for (String path : paths) {\n        if (domModel != null) {\n          path = MavenPropertyResolver.resolve(path, domModel);\n        }\n\n        javaParameters.getClassPath().add(resolveSurefireProperties(path));\n      }\n    }\n\n    Element systemPropertyVariables = config.getChild(\"systemPropertyVariables\");\n    if (systemPropertyVariables != null && isEnabled(\"systemPropertyVariables\")) {\n      for (Element element : systemPropertyVariables.getChildren()) {\n        String propertyName = element.getName();\n\n        if (!javaParameters.getVMParametersList().hasProperty(propertyName)) {\n          String value = resolveSurefireProperties(element.getValue());\n          if (isResolved(value)) {\n            javaParameters.getVMParametersList().addProperty(propertyName, value);\n          }\n        }\n      }\n    }\n\n    Element environmentVariables = config.getChild(\"environmentVariables\");\n    if (environmentVariables != null && isEnabled(\"environmentVariables\")) {\n      for (Element element : environmentVariables.getChildren()) {\n        String variableName = element.getName();\n\n        if (javaParameters.getEnv() == null || !javaParameters.getEnv().containsKey(variableName)) {\n          String value = resolveSurefireProperties(element.getValue());\n          if (isResolved(value)) {\n            javaParameters.addEnv(variableName, value);\n          }\n        }\n      }\n    }\n\n    Element argLine = config.getChild(\"argLine\");\n    if (argLine != null && isEnabled(\"argLine\")) {\n      String value = resolveSurefireProperties(argLine.getTextTrim());\n      if (StringUtil.isNotEmpty(value) && isResolved(value)) {\n        javaParameters.getVMParametersList().addParametersString(value);\n      }\n    }\n  }","commit_id":"71ebc41273571909a88e020ad3a555be5dd6ec4c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void processPluginPackageProperties(\n\t\t\tFile srcFile, String displayName, PluginPackage pluginPackage)\n\t\tthrows Exception {\n\n\t\tif (pluginPackage == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tProperties props = getPluginPackageProperties(srcFile);\n\n\t\tif ((props == null) || (props.size() == 0)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString moduleGroupId = pluginPackage.getGroupId();\n\t\tString moduleArtifactId = pluginPackage.getArtifactId();\n\t\tString moduleVersion = pluginPackage.getVersion();\n\n\t\tString pluginName = pluginPackage.getName();\n\t\tString pluginType = (String)pluginPackage.getTypes().get(0);\n\t\tString pluginTypeName = TextFormatter.format(\n\t\t\tpluginType, TextFormatter.J);\n\n\t\tif (!pluginType.equals(\"theme\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tString tags = getPluginPackageTagsXml(pluginPackage.getTags());\n\t\tString shortDescription = pluginPackage.getShortDescription();\n\t\tString longDescription = pluginPackage.getLongDescription();\n\t\tString changeLog = pluginPackage.getChangeLog();\n\t\tString pageURL = pluginPackage.getPageURL();\n\t\tString author = pluginPackage.getAuthor();\n\t\tString licenses = getPluginPackageLicensesXml(\n\t\t\tpluginPackage.getLicenses());\n\t\tString liferayVersions = getPluginPackageLiferayVersionsXml(\n\t\t\tpluginPackage.getLiferayVersions());\n\n\t\tint pos = moduleArtifactId.indexOf(\"-theme\");\n\n\t\tString themeId = moduleArtifactId.substring(0, pos);\n\t\tString themeName = pluginName;\n\n\t\tMap filterMap = new HashMap();\n\n\t\tfilterMap.put(\"module_group_id\", moduleGroupId);\n\t\tfilterMap.put(\"module_artifact_id\", moduleArtifactId);\n\t\tfilterMap.put(\"module_version\", moduleVersion);\n\n\t\tfilterMap.put(\"plugin_name\", pluginName);\n\t\tfilterMap.put(\"plugin_type\", pluginType);\n\t\tfilterMap.put(\"plugin_type_name\", pluginTypeName);\n\n\t\tfilterMap.put(\"tags\", tags);\n\t\tfilterMap.put(\"short_description\", shortDescription);\n\t\tfilterMap.put(\"long_description\", longDescription);\n\t\tfilterMap.put(\"change_log\", changeLog);\n\t\tfilterMap.put(\"page_url\", pageURL);\n\t\tfilterMap.put(\"author\", author);\n\t\tfilterMap.put(\"licenses\", licenses);\n\t\tfilterMap.put(\"liferay_versions\", liferayVersions);\n\n\t\tfilterMap.put(\"theme_id\", themeId);\n\t\tfilterMap.put(\"theme_name\", themeName);\n\n\t\tcopyDependencyXml(\n\t\t\t\"liferay-look-and-feel.xml\", srcFile + \"/WEB-INF\", filterMap, true);\n\t\tcopyDependencyXml(\n\t\t\t\"liferay-plugin-package.xml\", srcFile + \"/WEB-INF\", filterMap,\n\t\t\ttrue);\n\t}","id":87976,"modified_method":"protected void processPluginPackageProperties(\n\t\t\tFile srcFile, String displayName, PluginPackage pluginPackage)\n\t\tthrows Exception {\n\n\t\tif (pluginPackage == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tProperties props = getPluginPackageProperties(srcFile);\n\n\t\tif ((props == null) || (props.size() == 0)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString moduleGroupId = pluginPackage.getGroupId();\n\t\tString moduleArtifactId = pluginPackage.getArtifactId();\n\t\tString moduleVersion = pluginPackage.getVersion();\n\n\t\tString pluginName = pluginPackage.getName();\n\t\tString pluginType = (String)pluginPackage.getTypes().get(0);\n\t\tString pluginTypeName = TextFormatter.format(\n\t\t\tpluginType, TextFormatter.J);\n\n\t\tif (!pluginType.equals(\"theme\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tString tags = getPluginPackageTagsXml(pluginPackage.getTags());\n\t\tString shortDescription = pluginPackage.getShortDescription();\n\t\tString longDescription = pluginPackage.getLongDescription();\n\t\tString changeLog = pluginPackage.getChangeLog();\n\t\tString pageURL = pluginPackage.getPageURL();\n\t\tString author = pluginPackage.getAuthor();\n\t\tString licenses = getPluginPackageLicensesXml(\n\t\t\tpluginPackage.getLicenses());\n\t\tString liferayVersions = getPluginPackageLiferayVersionsXml(\n\t\t\tpluginPackage.getLiferayVersions());\n\n\t\tint pos = moduleArtifactId.indexOf(\"-theme\");\n\n\t\tString themeId = moduleArtifactId.substring(0, pos);\n\t\tString themeName = pluginName;\n\n\t\tMap filterMap = new HashMap();\n\n\t\tfilterMap.put(\"module_group_id\", moduleGroupId);\n\t\tfilterMap.put(\"module_artifact_id\", moduleArtifactId);\n\t\tfilterMap.put(\"module_version\", moduleVersion);\n\n\t\tfilterMap.put(\"plugin_name\", pluginName);\n\t\tfilterMap.put(\"plugin_type\", pluginType);\n\t\tfilterMap.put(\"plugin_type_name\", pluginTypeName);\n\n\t\tfilterMap.put(\"tags\", tags);\n\t\tfilterMap.put(\"short_description\", shortDescription);\n\t\tfilterMap.put(\"long_description\", longDescription);\n\t\tfilterMap.put(\"change_log\", changeLog);\n\t\tfilterMap.put(\"page_url\", pageURL);\n\t\tfilterMap.put(\"author\", author);\n\t\tfilterMap.put(\"licenses\", licenses);\n\t\tfilterMap.put(\"liferay_versions\", liferayVersions);\n\n\t\tfilterMap.put(\"theme_id\", themeId);\n\t\tfilterMap.put(\"theme_name\", themeName);\n\t\tfilterMap.put(\n\t\t\t\"theme_versions\",\n\t\t\tStringUtil.replace(liferayVersions, \"liferay-version\", \"version\"));\n\n\t\tcopyDependencyXml(\n\t\t\t\"liferay-look-and-feel.xml\", srcFile + \"/WEB-INF\", filterMap, true);\n\t\tcopyDependencyXml(\n\t\t\t\"liferay-plugin-package.xml\", srcFile + \"/WEB-INF\", filterMap,\n\t\t\ttrue);\n\t}","commit_id":"2bcd6b7dab7cd7defbcf28f76f20d63d47c0f269","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Set _readThemes(\n\t\t\tString servletContextName, ServletContext ctx, String themesPath,\n\t\t\tboolean loadFromServletContext, String xml,\n\t\t\tPluginPackage pluginPackage)\n\t\tthrows DocumentException, IOException {\n\n\t\tSet themeIds = new HashSet();\n\n\t\tif (xml == null) {\n\t\t\treturn themeIds;\n\t\t}\n\n\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\tDocument doc = reader.read(new XMLSafeReader(xml));\n\n\t\tElement root = doc.getRootElement();\n\n\t\tSet compatibleVersions = new HashSet();\n\n\t\tElement compatibilityEl = root.element(\"compatibility\");\n\n\t\tif (compatibilityEl != null) {\n\t\t\tIterator itr = compatibilityEl.elements(\"version\").iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tElement versionEl = (Element)itr.next();\n\n\t\t\t\tString version = versionEl.getTextTrim();\n\n\t\t\t\tversion = _getVersion(version);\n\n\t\t\t\tcompatibleVersions.add(version);\n\t\t\t}\n\t\t}\n\n\t\tif (!compatibleVersions.contains(\n\t\t\t\t_getVersion(ReleaseInfo.getVersion()))) {\n\n\t\t\t_log.error(\n\t\t\t\t\"Themes in this WAR are not compatible with \" +\n\t\t\t\t\tReleaseInfo.getServerInfo());\n\n\t\t\treturn themeIds;\n\t\t}\n\n\t\tThemeCompanyLimit companyLimit = null;\n\n\t\tElement companyLimitEl = root.element(\"company-limit\");\n\n\t\tif (companyLimitEl != null) {\n\t\t\tcompanyLimit = new ThemeCompanyLimit();\n\n\t\t\tElement companyIncludesEl =\n\t\t\t\tcompanyLimitEl.element(\"company-includes\");\n\n\t\t\tif (companyIncludesEl != null) {\n\t\t\t\tcompanyLimit.setIncludes(\n\t\t\t\t\t_getCompanyLimitIncludes(companyIncludesEl));\n\t\t\t}\n\n\t\t\tElement companyExcludesEl =\n\t\t\t\tcompanyLimitEl.element(\"company-excludes\");\n\n\t\t\tif (companyExcludesEl != null) {\n\t\t\t\tcompanyLimit.setExcludes(\n\t\t\t\t\t_getCompanyLimitExcludes(companyExcludesEl));\n\t\t\t}\n\t\t}\n\n\t\tThemeGroupLimit groupLimit = null;\n\n\t\tElement groupLimitEl = root.element(\"group-limit\");\n\n\t\tif (groupLimitEl != null) {\n\t\t\tgroupLimit = new ThemeGroupLimit();\n\n\t\t\tElement groupIncludesEl = groupLimitEl.element(\"group-includes\");\n\n\t\t\tif (groupIncludesEl != null) {\n\t\t\t\tgroupLimit.setIncludes(_getGroupLimitIncludes(groupIncludesEl));\n\t\t\t}\n\n\t\t\tElement groupExcludesEl =\n\t\t\t\tgroupLimitEl.element(\"group-excludes\");\n\n\t\t\tif (groupExcludesEl != null) {\n\t\t\t\tgroupLimit.setExcludes(_getGroupLimitExcludes(groupExcludesEl));\n\t\t\t}\n\t\t}\n\n\t\tIterator itr1 = root.elements(\"theme\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement theme = (Element)itr1.next();\n\n\t\t\tContextReplace themeContextReplace = new ContextReplace();\n\n\t\t\tthemeContextReplace.addValue(\"themes-path\", themesPath);\n\n\t\t\tString themeId = theme.attributeValue(\"id\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tthemeId =\n\t\t\t\t\tthemeId + PortletImpl.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tthemeId = PortalUtil.getJsSafePortletName(themeId);\n\n\t\t\tthemeContextReplace.addValue(\"theme-id\", themeId);\n\n\t\t\tthemeIds.add(themeId);\n\n\t\t\tTheme themeModel = (Theme)_themes.get(themeId);\n\n\t\t\tif (themeModel == null) {\n\t\t\t\tthemeModel = new ThemeImpl(themeId);\n\n\t\t\t\t_themes.put(themeId, themeModel);\n\t\t\t}\n\n\t\t\tPluginSetting pluginSetting =\n\t\t\t\tPluginSettingLocalServiceUtil.getDefaultPluginSetting();\n\n\t\t\tthemeModel.setPluginPackage(pluginPackage);\n\t\t\tthemeModel.setDefaultPluginSetting(pluginSetting);\n\n\t\t\tthemeModel.setThemeCompanyLimit(companyLimit);\n\t\t\tthemeModel.setThemeGroupLimit(groupLimit);\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tthemeModel.setServletContextName(servletContextName);\n\t\t\t}\n\n\t\t\tthemeModel.setLoadFromServletContext(loadFromServletContext);\n\n\t\t\tthemeModel.setTimestamp(System.currentTimeMillis());\n\n\t\t\tString name = GetterUtil.getString(\n\t\t\t\ttheme.attributeValue(\"name\"), themeModel.getName());\n\n\t\t\tString rootPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"root-path\"), themeModel.getRootPath());\n\n\t\t\trootPath = themeContextReplace.replace(rootPath);\n\n\t\t\tthemeContextReplace.addValue(\"root-path\", rootPath);\n\n\t\t\tString templatesPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"templates-path\"),\n\t\t\t\tthemeModel.getTemplatesPath());\n\n\t\t\ttemplatesPath = themeContextReplace.replace(templatesPath);\n\t\t\ttemplatesPath = StringUtil.safePath(templatesPath);\n\n\t\t\tthemeContextReplace.addValue(\"templates-path\", templatesPath);\n\n\t\t\tString cssPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"css-path\"), themeModel.getCssPath());\n\n\t\t\tcssPath = themeContextReplace.replace(cssPath);\n\t\t\tcssPath = StringUtil.safePath(cssPath);\n\n\t\t\tthemeContextReplace.addValue(\"css-path\", cssPath);\n\n\t\t\tString imagesPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"images-path\"),\n\t\t\t\tthemeModel.getImagesPath());\n\n\t\t\timagesPath = themeContextReplace.replace(imagesPath);\n\t\t\timagesPath = StringUtil.safePath(imagesPath);\n\n\t\t\tthemeContextReplace.addValue(\"images-path\", imagesPath);\n\n\t\t\tString javaScriptPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"javascript-path\"),\n\t\t\t\tthemeModel.getJavaScriptPath());\n\n\t\t\tjavaScriptPath = themeContextReplace.replace(javaScriptPath);\n\t\t\tjavaScriptPath = StringUtil.safePath(javaScriptPath);\n\n\t\t\tthemeContextReplace.addValue(\"javascript-path\", javaScriptPath);\n\n\t\t\tString virtualPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"virtual-path\"), themeModel.getVirtualPath());\n\n\t\t\tString templateExtension = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"template-extension\"),\n\t\t\t\tthemeModel.getTemplateExtension());\n\n\t\t\tthemeModel.setName(name);\n\t\t\tthemeModel.setRootPath(rootPath);\n\t\t\tthemeModel.setTemplatesPath(templatesPath);\n\t\t\tthemeModel.setCssPath(cssPath);\n\t\t\tthemeModel.setImagesPath(imagesPath);\n\t\t\tthemeModel.setJavaScriptPath(javaScriptPath);\n\t\t\tthemeModel.setVirtualPath(virtualPath);\n\t\t\tthemeModel.setTemplateExtension(templateExtension);\n\n\t\t\tElement settingsEl = theme.element(\"settings\");\n\n\t\t\tif (settingsEl != null) {\n\t\t\t\tIterator itr2 = settingsEl.elements(\"setting\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement settingEl = (Element)itr2.next();\n\n\t\t\t\t\tString key = settingEl.attributeValue(\"key\");\n\t\t\t\t\tString value = settingEl.attributeValue(\"value\");\n\n\t\t\t\t\tthemeModel.setSetting(key, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthemeModel.setWapTheme(GetterUtil.getBoolean(\n\t\t\t\ttheme.elementText(\"wap-theme\"), themeModel.isWapTheme()));\n\n\t\t\tElement rolesEl = theme.element(\"roles\");\n\n\t\t\tif (rolesEl != null) {\n\t\t\t\tIterator itr2 = rolesEl.elements(\"role-name\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement roleNameEl = (Element)itr2.next();\n\n\t\t\t\t\tpluginSetting.addRole(roleNameEl.getText());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_readColorSchemes(\n\t\t\t\ttheme, themeModel.getColorSchemesMap(), themeContextReplace);\n\t\t\t_readColorSchemes(\n\t\t\t\ttheme, themeModel.getColorSchemesMap(), themeContextReplace);\n\n\t\t\tElement layoutTemplatesEl = theme.element(\"layout-templates\");\n\n\t\t\tif (layoutTemplatesEl != null) {\n\t\t\t\tElement standardEl = layoutTemplatesEl.element(\"standard\");\n\n\t\t\t\tif (standardEl != null) {\n\t\t\t\t\tLayoutTemplateLocalUtil.readLayoutTemplate(\n\t\t\t\t\t\tservletContextName, ctx, null, standardEl, true,\n\t\t\t\t\t\tthemeId, pluginPackage);\n\t\t\t\t}\n\n\t\t\t\tElement customEl = layoutTemplatesEl.element(\"custom\");\n\n\t\t\t\tif (customEl != null) {\n\t\t\t\t\tLayoutTemplateLocalUtil.readLayoutTemplate(\n\t\t\t\t\t\tservletContextName, ctx, null, customEl, false, themeId,\n\t\t\t\t\t\tpluginPackage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn themeIds;\n\t}","id":87977,"modified_method":"private static Set _readThemes(\n\t\t\tString servletContextName, ServletContext ctx, String themesPath,\n\t\t\tboolean loadFromServletContext, String xml,\n\t\t\tPluginPackage pluginPackage)\n\t\tthrows DocumentException, IOException {\n\n\t\tSet themeIds = new HashSet();\n\n\t\tif (xml == null) {\n\t\t\treturn themeIds;\n\t\t}\n\n\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\tDocument doc = reader.read(new XMLSafeReader(xml));\n\n\t\tElement root = doc.getRootElement();\n\n\t\tVersion portalVersion = _getVersion(ReleaseInfo.getVersion());\n\n\t\tboolean compatible = false;\n\n\t\tElement compatibilityEl = root.element(\"compatibility\");\n\n\t\tif (compatibilityEl != null) {\n\t\t\tIterator itr = compatibilityEl.elements(\"version\").iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tElement versionEl = (Element)itr.next();\n\n\t\t\t\tVersion version = _getVersion(versionEl.getTextTrim());\n\n\t\t\t\tif (version.includes(portalVersion)) {\n\t\t\t\t\tcompatible = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!compatible) {\n\t\t\t_log.error(\n\t\t\t\t\"Themes in this WAR are not compatible with \" +\n\t\t\t\t\tReleaseInfo.getServerInfo());\n\n\t\t\treturn themeIds;\n\t\t}\n\n\t\tThemeCompanyLimit companyLimit = null;\n\n\t\tElement companyLimitEl = root.element(\"company-limit\");\n\n\t\tif (companyLimitEl != null) {\n\t\t\tcompanyLimit = new ThemeCompanyLimit();\n\n\t\t\tElement companyIncludesEl =\n\t\t\t\tcompanyLimitEl.element(\"company-includes\");\n\n\t\t\tif (companyIncludesEl != null) {\n\t\t\t\tcompanyLimit.setIncludes(\n\t\t\t\t\t_getCompanyLimitIncludes(companyIncludesEl));\n\t\t\t}\n\n\t\t\tElement companyExcludesEl =\n\t\t\t\tcompanyLimitEl.element(\"company-excludes\");\n\n\t\t\tif (companyExcludesEl != null) {\n\t\t\t\tcompanyLimit.setExcludes(\n\t\t\t\t\t_getCompanyLimitExcludes(companyExcludesEl));\n\t\t\t}\n\t\t}\n\n\t\tThemeGroupLimit groupLimit = null;\n\n\t\tElement groupLimitEl = root.element(\"group-limit\");\n\n\t\tif (groupLimitEl != null) {\n\t\t\tgroupLimit = new ThemeGroupLimit();\n\n\t\t\tElement groupIncludesEl = groupLimitEl.element(\"group-includes\");\n\n\t\t\tif (groupIncludesEl != null) {\n\t\t\t\tgroupLimit.setIncludes(_getGroupLimitIncludes(groupIncludesEl));\n\t\t\t}\n\n\t\t\tElement groupExcludesEl =\n\t\t\t\tgroupLimitEl.element(\"group-excludes\");\n\n\t\t\tif (groupExcludesEl != null) {\n\t\t\t\tgroupLimit.setExcludes(_getGroupLimitExcludes(groupExcludesEl));\n\t\t\t}\n\t\t}\n\n\t\tIterator itr1 = root.elements(\"theme\").iterator();\n\n\t\twhile (itr1.hasNext()) {\n\t\t\tElement theme = (Element)itr1.next();\n\n\t\t\tContextReplace themeContextReplace = new ContextReplace();\n\n\t\t\tthemeContextReplace.addValue(\"themes-path\", themesPath);\n\n\t\t\tString themeId = theme.attributeValue(\"id\");\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tthemeId =\n\t\t\t\t\tthemeId + PortletImpl.WAR_SEPARATOR + servletContextName;\n\t\t\t}\n\n\t\t\tthemeId = PortalUtil.getJsSafePortletName(themeId);\n\n\t\t\tthemeContextReplace.addValue(\"theme-id\", themeId);\n\n\t\t\tthemeIds.add(themeId);\n\n\t\t\tTheme themeModel = (Theme)_themes.get(themeId);\n\n\t\t\tif (themeModel == null) {\n\t\t\t\tthemeModel = new ThemeImpl(themeId);\n\n\t\t\t\t_themes.put(themeId, themeModel);\n\t\t\t}\n\n\t\t\tPluginSetting pluginSetting =\n\t\t\t\tPluginSettingLocalServiceUtil.getDefaultPluginSetting();\n\n\t\t\tthemeModel.setPluginPackage(pluginPackage);\n\t\t\tthemeModel.setDefaultPluginSetting(pluginSetting);\n\n\t\t\tthemeModel.setThemeCompanyLimit(companyLimit);\n\t\t\tthemeModel.setThemeGroupLimit(groupLimit);\n\n\t\t\tif (servletContextName != null) {\n\t\t\t\tthemeModel.setServletContextName(servletContextName);\n\t\t\t}\n\n\t\t\tthemeModel.setLoadFromServletContext(loadFromServletContext);\n\n\t\t\tthemeModel.setTimestamp(System.currentTimeMillis());\n\n\t\t\tString name = GetterUtil.getString(\n\t\t\t\ttheme.attributeValue(\"name\"), themeModel.getName());\n\n\t\t\tString rootPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"root-path\"), themeModel.getRootPath());\n\n\t\t\trootPath = themeContextReplace.replace(rootPath);\n\n\t\t\tthemeContextReplace.addValue(\"root-path\", rootPath);\n\n\t\t\tString templatesPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"templates-path\"),\n\t\t\t\tthemeModel.getTemplatesPath());\n\n\t\t\ttemplatesPath = themeContextReplace.replace(templatesPath);\n\t\t\ttemplatesPath = StringUtil.safePath(templatesPath);\n\n\t\t\tthemeContextReplace.addValue(\"templates-path\", templatesPath);\n\n\t\t\tString cssPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"css-path\"), themeModel.getCssPath());\n\n\t\t\tcssPath = themeContextReplace.replace(cssPath);\n\t\t\tcssPath = StringUtil.safePath(cssPath);\n\n\t\t\tthemeContextReplace.addValue(\"css-path\", cssPath);\n\n\t\t\tString imagesPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"images-path\"),\n\t\t\t\tthemeModel.getImagesPath());\n\n\t\t\timagesPath = themeContextReplace.replace(imagesPath);\n\t\t\timagesPath = StringUtil.safePath(imagesPath);\n\n\t\t\tthemeContextReplace.addValue(\"images-path\", imagesPath);\n\n\t\t\tString javaScriptPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"javascript-path\"),\n\t\t\t\tthemeModel.getJavaScriptPath());\n\n\t\t\tjavaScriptPath = themeContextReplace.replace(javaScriptPath);\n\t\t\tjavaScriptPath = StringUtil.safePath(javaScriptPath);\n\n\t\t\tthemeContextReplace.addValue(\"javascript-path\", javaScriptPath);\n\n\t\t\tString virtualPath = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"virtual-path\"), themeModel.getVirtualPath());\n\n\t\t\tString templateExtension = GetterUtil.getString(\n\t\t\t\ttheme.elementText(\"template-extension\"),\n\t\t\t\tthemeModel.getTemplateExtension());\n\n\t\t\tthemeModel.setName(name);\n\t\t\tthemeModel.setRootPath(rootPath);\n\t\t\tthemeModel.setTemplatesPath(templatesPath);\n\t\t\tthemeModel.setCssPath(cssPath);\n\t\t\tthemeModel.setImagesPath(imagesPath);\n\t\t\tthemeModel.setJavaScriptPath(javaScriptPath);\n\t\t\tthemeModel.setVirtualPath(virtualPath);\n\t\t\tthemeModel.setTemplateExtension(templateExtension);\n\n\t\t\tElement settingsEl = theme.element(\"settings\");\n\n\t\t\tif (settingsEl != null) {\n\t\t\t\tIterator itr2 = settingsEl.elements(\"setting\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement settingEl = (Element)itr2.next();\n\n\t\t\t\t\tString key = settingEl.attributeValue(\"key\");\n\t\t\t\t\tString value = settingEl.attributeValue(\"value\");\n\n\t\t\t\t\tthemeModel.setSetting(key, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthemeModel.setWapTheme(GetterUtil.getBoolean(\n\t\t\t\ttheme.elementText(\"wap-theme\"), themeModel.isWapTheme()));\n\n\t\t\tElement rolesEl = theme.element(\"roles\");\n\n\t\t\tif (rolesEl != null) {\n\t\t\t\tIterator itr2 = rolesEl.elements(\"role-name\").iterator();\n\n\t\t\t\twhile (itr2.hasNext()) {\n\t\t\t\t\tElement roleNameEl = (Element)itr2.next();\n\n\t\t\t\t\tpluginSetting.addRole(roleNameEl.getText());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_readColorSchemes(\n\t\t\t\ttheme, themeModel.getColorSchemesMap(), themeContextReplace);\n\t\t\t_readColorSchemes(\n\t\t\t\ttheme, themeModel.getColorSchemesMap(), themeContextReplace);\n\n\t\t\tElement layoutTemplatesEl = theme.element(\"layout-templates\");\n\n\t\t\tif (layoutTemplatesEl != null) {\n\t\t\t\tElement standardEl = layoutTemplatesEl.element(\"standard\");\n\n\t\t\t\tif (standardEl != null) {\n\t\t\t\t\tLayoutTemplateLocalUtil.readLayoutTemplate(\n\t\t\t\t\t\tservletContextName, ctx, null, standardEl, true,\n\t\t\t\t\t\tthemeId, pluginPackage);\n\t\t\t\t}\n\n\t\t\t\tElement customEl = layoutTemplatesEl.element(\"custom\");\n\n\t\t\t\tif (customEl != null) {\n\t\t\t\t\tLayoutTemplateLocalUtil.readLayoutTemplate(\n\t\t\t\t\t\tservletContextName, ctx, null, customEl, false, themeId,\n\t\t\t\t\t\tpluginPackage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn themeIds;\n\t}","commit_id":"2bcd6b7dab7cd7defbcf28f76f20d63d47c0f269","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _getVersion(String version) {\n\t\tif (version.equals(\"${current-version}\")) {\n\t\t\tversion = ReleaseInfo.getVersion();\n\t\t}\n\n\t\tint x = version.indexOf(StringPool.PERIOD);\n\t\tint y = version.indexOf(StringPool.PERIOD, x + 1);\n\n\t\tif ((x == -1) || (y == -1)) {\n\t\t\treturn version;\n\t\t}\n\t\telse {\n\t\t\treturn version.substring(0, y);\n\t\t}\n\t}","id":87978,"modified_method":"private static Version _getVersion(String version) {\n\t\tif (version.equals(\"${current-version}\")) {\n\t\t\tversion = ReleaseInfo.getVersion();\n\t\t}\n\n\t\treturn Version.getInstance(version);\n\t}","commit_id":"2bcd6b7dab7cd7defbcf28f76f20d63d47c0f269","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String findChildValueByPath(@Nullable Element element, String path, String defaultValue) {\n    Element child = findChildByPath(element, path);\n    String childValue = child == null ? null : child.getTextTrim();\n    return StringUtil.isEmptyOrSpaces(childValue) ? defaultValue : childValue;\n  }","id":87979,"modified_method":"public static String findChildValueByPath(@Nullable Element element, String path, String defaultValue) {\n    Element child = findChildByPath(element, path);\n    if (child == null) return defaultValue;\n    String childValue = child.getTextTrim();\n    return childValue.isEmpty() ? defaultValue : childValue;\n  }","commit_id":"1e68c690afa79c8c11b43f3e5d229ff0ff592392","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Element doRead(String text, final ErrorHandler handler) {\n    final LinkedList<Element> stack = new LinkedList<Element>();\n\n    final Element[] result = {null};\n    XmlBuilderDriver driver = new XmlBuilderDriver(text);\n    XmlBuilder builder = new XmlBuilder() {\n      public void doctype(@Nullable CharSequence publicId, @Nullable CharSequence systemId, int startOffset, int endOffset) {\n      }\n\n      public ProcessingOrder startTag(CharSequence localName, String namespace, int startoffset, int endoffset, int headerEndOffset) {\n        String name = localName.toString();\n        if (StringUtil.isEmptyOrSpaces(name)) return ProcessingOrder.TAGS;\n\n        Element newElement = new Element(name);\n\n        Element parent = stack.isEmpty() ? null : stack.getLast();\n        if (parent == null) {\n          result[0] = newElement;\n        }\n        else {\n          parent.addContent(newElement);\n        }\n        stack.addLast(newElement);\n\n        return ProcessingOrder.TAGS_AND_TEXTS;\n      }\n\n      public void endTag(CharSequence localName, String namespace, int startoffset, int endoffset) {\n        String name = localName.toString();\n        if (isEmptyOrSpaces(name)) return;\n\n        int index = -1;\n        for (int i = stack.size() - 1; i >= 0; i--) {\n          if (stack.get(i).getName().equals(name)) {\n            index = i;\n            break;\n          }\n        }\n        if (index == -1) return;\n        while (stack.size() > index) {\n          stack.removeLast();\n        }\n      }\n\n      public void textElement(CharSequence text, CharSequence physical, int startoffset, int endoffset) {\n        stack.getLast().addContent(JDOMUtil.legalizeText(text.toString()));\n      }\n\n      public void attribute(CharSequence name, CharSequence value, int startoffset, int endoffset) {\n      }\n\n      public void entityRef(CharSequence ref, int startOffset, int endOffset) {\n      }\n\n      public void error(String message, int startOffset, int endOffset) {\n        if (handler != null) handler.onSyntaxError();\n      }\n    };\n\n    driver.build(builder);\n    return result[0];\n  }","id":87980,"modified_method":"@Nullable\n  private static Element doRead(String text, final ErrorHandler handler) {\n    final LinkedList<Element> stack = new LinkedList<Element>();\n\n    final Element[] result = {null};\n    XmlBuilderDriver driver = new XmlBuilderDriver(text);\n    XmlBuilder builder = new XmlBuilder() {\n      public void doctype(@Nullable CharSequence publicId, @Nullable CharSequence systemId, int startOffset, int endOffset) {\n      }\n\n      public ProcessingOrder startTag(CharSequence localName, String namespace, int startoffset, int endoffset, int headerEndOffset) {\n        String name = localName.toString();\n        if (StringUtil.isEmptyOrSpaces(name)) return ProcessingOrder.TAGS;\n\n        Element newElement = new Element(name);\n\n        Element parent = stack.isEmpty() ? null : stack.getLast();\n        if (parent == null) {\n          result[0] = newElement;\n        }\n        else {\n          parent.addContent(newElement);\n        }\n        stack.addLast(newElement);\n\n        return ProcessingOrder.TAGS_AND_TEXTS;\n      }\n\n      public void endTag(CharSequence localName, String namespace, int startoffset, int endoffset) {\n        String name = localName.toString();\n        if (StringUtil.isEmptyOrSpaces(name)) return;\n\n        int index = -1;\n        for (int i = stack.size() - 1; i >= 0; i--) {\n          if (stack.get(i).getName().equals(name)) {\n            index = i;\n            break;\n          }\n        }\n        if (index == -1) return;\n        while (stack.size() > index) {\n          stack.removeLast();\n        }\n      }\n\n      public void textElement(CharSequence text, CharSequence physical, int startoffset, int endoffset) {\n        stack.getLast().addContent(JDOMUtil.legalizeText(text.toString()));\n      }\n\n      public void attribute(CharSequence name, CharSequence value, int startoffset, int endoffset) {\n      }\n\n      public void entityRef(CharSequence ref, int startOffset, int endOffset) {\n      }\n\n      public void error(String message, int startOffset, int endOffset) {\n        if (handler != null) handler.onSyntaxError();\n      }\n    };\n\n    driver.build(builder);\n    return result[0];\n  }","commit_id":"1e68c690afa79c8c11b43f3e5d229ff0ff592392","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<String> findChildrenValuesByPath(@Nullable Element element, String path, String childrenName) {\n    List<String> result = new ArrayList<String>();\n    for (Element each : findChildrenByPath(element, path, childrenName)) {\n      String value = each.getTextTrim();\n      if (!StringUtil.isEmptyOrSpaces(value)) {\n        result.add(value);\n      }\n    }\n    return result;\n  }","id":87981,"modified_method":"public static List<String> findChildrenValuesByPath(@Nullable Element element, String path, String childrenName) {\n    List<String> result = new ArrayList<String>();\n    for (Element each : findChildrenByPath(element, path, childrenName)) {\n      String value = each.getTextTrim();\n      if (!value.isEmpty()) {\n        result.add(value);\n      }\n    }\n    return result;\n  }","commit_id":"1e68c690afa79c8c11b43f3e5d229ff0ff592392","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<Element> collectChildren(@Nullable Element container, String subPath) {\n    if (container == null) return Collections.emptyList();\n\n    List<String> subParts = StringUtil.split(subPath, \".\");\n    String childName = subParts.get(0);\n    String pathInChild = subParts.size() > 1 ? StringUtil.join(subParts.subList(1, subParts.size()), \".\") : null;\n\n    List<Element> result = new ArrayList<Element>();\n    for (Element each : (Iterable<? extends Element>)container.getChildren(childName)) {\n      Element child = pathInChild == null ? each : findChildByPath(each, pathInChild);\n      if (child != null) result.add(child);\n    }\n    return result;\n  }","id":87982,"modified_method":"private static List<Element> collectChildren(@Nullable Element container, String subPath) {\n    if (container == null) return Collections.emptyList();\n\n    int firstDot = subPath.indexOf('.');\n\n    if (firstDot == -1) {\n      //noinspection unchecked\n      return (List<Element>)container.getChildren(subPath);\n    }\n\n    String childName = subPath.substring(0, firstDot);\n    String pathInChild = subPath.substring(firstDot + 1);\n\n    List<Element> result = new ArrayList<Element>();\n    //noinspection unchecked\n    for (Element each : (Iterable<? extends Element>)container.getChildren(childName)) {\n      Element child = findChildByPath(each, pathInChild);\n      if (child != null) result.add(child);\n    }\n    return result;\n  }","commit_id":"1e68c690afa79c8c11b43f3e5d229ff0ff592392","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Element findChildByPath(@Nullable Element element, String path) {\n    if (element == null) return null;\n\n    List<String> parts = StringUtil.split(path, \".\");\n    Element current = element;\n    for (String each : parts) {\n      current = current.getChild(each);\n      if (current == null) break;\n    }\n    return current;\n  }","id":87983,"modified_method":"@Nullable\n  public static Element findChildByPath(@Nullable Element element, String path) {\n    int i = 0;\n    while (element != null) {\n      int dot = path.indexOf('.', i);\n      if (dot == -1) {\n        return element.getChild(path.substring(i));\n      }\n\n      element = element.getChild(path.substring(i, dot));\n      i = dot + 1;\n    }\n\n    return null;\n  }","commit_id":"1e68c690afa79c8c11b43f3e5d229ff0ff592392","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getUserName(long userId, ThemeDisplay themeDisplay) {\n\t\ttry {\n\t\t\tif (userId <= 0) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\tif (user.getUserId() == themeDisplay.getUserId()) {\n\t\t\t\treturn user.getFirstName();\n\t\t\t}\n\n\t\t\tString userName = user.getFullName();\n\n\t\t\tGroup group = user.getGroup();\n\n\t\t\tif (group.getGroupId() == themeDisplay.getScopeGroupId()) {\n\t\t\t\treturn userName;\n\t\t\t}\n\n\t\t\tString userDisplayURL = user.getDisplayURL(themeDisplay);\n\n\t\t\tuserName =\n\t\t\t\t\"<a href=\\\"\" + userDisplayURL + \"\\\">\" + userName + \"<\/a>\";\n\n\t\t\treturn userName;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","id":87984,"modified_method":"public String getUserName(long userId, ThemeDisplay themeDisplay) {\n\t\ttry {\n\t\t\tif (userId <= 0) {\n\t\t\t\treturn StringPool.BLANK;\n\t\t\t}\n\n\t\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\t\tif (user.getUserId() == themeDisplay.getUserId()) {\n\t\t\t\treturn user.getFirstName();\n\t\t\t}\n\n\t\t\tString userName = user.getFullName();\n\n\t\t\tGroup group = user.getGroup();\n\n\t\t\tif (group.getGroupId() == themeDisplay.getScopeGroupId()) {\n\t\t\t\treturn userName;\n\t\t\t}\n\n\t\t\tString userDisplayURL = user.getDisplayURL(themeDisplay);\n\n\t\t\tuserName =\n\t\t\t\t\"<a class=\\\"user\\\" href=\\\"\" + userDisplayURL + \"\\\">\" +\n\t\t\t\t\tuserName + \"<\/a>\";\n\n\t\t\treturn userName;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\t}","commit_id":"4c03d1884cad064232c0d9899d9720014e8886fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BlogsEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\tJSONObject extraData = null;\n\n\t\tif (Validator.isNotNull(activity.getExtraData())) {\n\t\t\textraData = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivity.getExtraData());\n\t\t}\n\n\t\t// Link\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/blogs/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(activity.getGroupId());\n\n\t\t\tgroupName = group.getDescriptiveName();\n\t\t}\n\n\t\tString titlePattern = null;\n\t\tObject[] titleArguments = null;\n\n\t\tif (activityType == BlogsActivityKeys.ADD_COMMENT) {\n\t\t\ttitlePattern = \"activity-blogs-add-comment\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\n\t\t\ttitleArguments = new Object[] {\n\t\t\t\tcreatorUserName, receiverUserName, groupName\n\t\t\t};\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\ttitlePattern = \"activity-blogs-add-entry\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\n\t\t\ttitleArguments = new Object[] {creatorUserName, groupName};\n\t\t}\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\");\n\n\t\tif (activityType == BlogsActivityKeys.ADD_COMMENT) {\n\t\t\tlong messageId = extraData.getInt(\"messageId\");\n\n\t\t\ttry {\n\t\t\t\tMBMessage message = MBMessageLocalServiceUtil.getMessage(\n\t\t\t\t\tmessageId);\n\n\t\t\t\tsb.append(cleanContent(message.getBody()));\n\t\t\t}\n\t\t\tcatch (NoSuchMessageException nsme) {\n\t\t\t\tSocialActivityLocalServiceUtil.deleteActivity(\n\t\t\t\t\tactivity.getActivityId());\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\tsb.append(entry.getTitle());\n\t\t}\n\n\t\tsb.append(\"<\/a><br />\");\n\n\t\tif (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\tsb.append(cleanContent(entry.getContent()));\n\t\t}\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":87985,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!BlogsEntryPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\tJSONObject extraData = null;\n\n\t\tif (Validator.isNotNull(activity.getExtraData())) {\n\t\t\textraData = JSONFactoryUtil.createJSONObject(\n\t\t\t\tactivity.getExtraData());\n\t\t}\n\n\t\t// Link\n\n\t\tBlogsEntry entry = BlogsEntryLocalServiceUtil.getEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/blogs/find_entry?entryId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(entry.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString entryTitle = sb.toString();\n\n\t\tif (activityType == BlogsActivityKeys.ADD_COMMENT) {\n\t\t\ttitlePattern = \"activity-blogs-add-comment\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\t\t}\n\t\telse if (activityType == BlogsActivityKeys.ADD_ENTRY) {\n\t\t\ttitlePattern = \"activity-blogs-add-entry\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, entryTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"4c03d1884cad064232c0d9899d9720014e8886fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!CalEventPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tCalEvent event = CalEventLocalServiceUtil.getEvent(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/calendar/find_event?eventId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(activity.getGroupId());\n\n\t\t\tgroupName = group.getDescriptiveName();\n\t\t}\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == CalendarActivityKeys.ADD_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-add-event\";\n\t\t}\n\t\telse if (activityType == CalendarActivityKeys.UPDATE_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-update-event\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {creatorUserName, groupName};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\");\n\t\tsb.append(cleanContent(event.getTitle()));\n\t\tsb.append(\"<\/a><br />\");\n\t\tsb.append(cleanContent(event.getDescription()));\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":87986,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!CalEventPermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tCalEvent event = CalEventLocalServiceUtil.getEvent(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/calendar/find_event?eventId=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(event.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString eventTitle = sb.toString();\n\n\t\tif (activityType == CalendarActivityKeys.ADD_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-add-event\";\n\t\t}\n\t\telse if (activityType == CalendarActivityKeys.UPDATE_EVENT) {\n\t\t\ttitlePattern = \"activity-calendar-update-event\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, eventTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"4c03d1884cad064232c0d9899d9720014e8886fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tDLFileEntry fileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tif (!DLFileEntryPermission.contains(\n\t\t\t\tpermissionChecker, fileEntry, ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/get_file?folderId=\" +\n\t\t\t\t\tfileEntry.getFolderId() + \"&name=\" + fileEntry.getName();\n\n\t\t// Title\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(activity.getGroupId());\n\n\t\t\tgroupName = group.getDescriptiveName();\n\t\t}\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == DLActivityKeys.ADD_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-add-file\";\n\t\t}\n\t\telse if (activityType == DLActivityKeys.UPDATE_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-update-file\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {creatorUserName, groupName};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\");\n\t\tsb.append(cleanContent(fileEntry.getTitle()));\n\t\tsb.append(\"<\/a><br />\");\n\t\tsb.append(cleanContent(fileEntry.getDescription()));\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":87987,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tDLFileEntry fileEntry = DLFileEntryLocalServiceUtil.getDLFileEntry(\n\t\t\tactivity.getClassPK());\n\n\t\tif (!DLFileEntryPermission.contains(\n\t\t\t\tpermissionChecker, fileEntry, ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/document_library/get_file?folderId=\" +\n\t\t\t\t\tfileEntry.getFolderId() + \"&name=\" + fileEntry.getName();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(fileEntry.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString fileTitle = sb.toString();\n\n\t\tif (activityType == DLActivityKeys.ADD_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-add-file\";\n\t\t}\n\t\telse if (activityType == DLActivityKeys.UPDATE_FILE_ENTRY) {\n\t\t\ttitlePattern = \"activity-document-library-update-file\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, fileTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"4c03d1884cad064232c0d9899d9720014e8886fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!MBMessagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tMBMessage message = MBMessageLocalServiceUtil.getMessage(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/message_boards/find_message?messageId=\" +\n\t\t\t\t\tactivity.getClassPK();\n\n\t\t// Title\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(activity.getGroupId());\n\n\t\t\tgroupName = group.getDescriptiveName();\n\t\t}\n\n\t\tString titlePattern = null;\n\t\tObject[] titleArguments = null;\n\n\t\tif (activityType == MBActivityKeys.ADD_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-add-message\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\n\t\t\ttitleArguments = new Object[] {creatorUserName, groupName};\n\t\t}\n\t\telse if (activityType == MBActivityKeys.REPLY_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\n\t\t\tif (Validator.isNotNull(groupName)) {\n\t\t\t\ttitlePattern += \"-in\";\n\t\t\t}\n\n\t\t\ttitleArguments = new Object[] {\n\t\t\t\tcreatorUserName, receiverUserName, groupName\n\t\t\t};\n\t\t}\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\");\n\t\tsb.append(cleanContent(message.getSubject()));\n\t\tsb.append(\"<\/a><br />\");\n\t\tsb.append(cleanContent(BBCodeUtil.getHTML(message)));\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":87988,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!MBMessagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\t\tString receiverUserName = getUserName(\n\t\t\tactivity.getReceiverUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tMBMessage message = MBMessageLocalServiceUtil.getMessage(\n\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/message_boards/find_message?messageId=\" +\n\t\t\t\t\tmessage.getMessageId();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(message.getSubject()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString messageSubject = sb.toString();\n\n\t\tif (activityType == MBActivityKeys.ADD_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-add-message\";\n\t\t}\n\t\telse if (activityType == MBActivityKeys.REPLY_MESSAGE) {\n\t\t\ttitlePattern = \"activity-message-boards-reply-message\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, receiverUserName, messageSubject\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"4c03d1884cad064232c0d9899d9720014e8886fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!WikiPagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/wiki/find_page?pageResourcePrimKey=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tGroup group = GroupLocalServiceUtil.getGroup(activity.getGroupId());\n\n\t\t\tgroupName = group.getDescriptiveName();\n\t\t}\n\n\t\tString titlePattern = null;\n\n\t\tif (activityType == WikiActivityKeys.ADD_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-add-page\";\n\t\t}\n\t\telse if (activityType == WikiActivityKeys.UPDATE_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-update-page\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {creatorUserName, groupName};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\");\n\t\tsb.append(cleanContent(pageResource.getTitle()));\n\t\tsb.append(\"<\/a>\");\n\n\t\tString body = sb.toString();\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","id":87989,"modified_method":"protected SocialActivityFeedEntry doInterpret(\n\t\t\tSocialActivity activity, ThemeDisplay themeDisplay)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tif (!WikiPagePermission.contains(\n\t\t\t\tpermissionChecker, activity.getClassPK(), ActionKeys.VIEW)) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString groupName = StringPool.BLANK;\n\n\t\tif (activity.getGroupId() != themeDisplay.getScopeGroupId()) {\n\t\t\tgroupName = getGroupName(activity.getGroupId(), themeDisplay);\n\t\t}\n\n\t\tString creatorUserName = getUserName(\n\t\t\tactivity.getUserId(), themeDisplay);\n\n\t\tint activityType = activity.getType();\n\n\t\t// Link\n\n\t\tWikiPageResource pageResource =\n\t\t\tWikiPageResourceLocalServiceUtil.getPageResource(\n\t\t\t\tactivity.getClassPK());\n\n\t\tString link =\n\t\t\tthemeDisplay.getURLPortal() + themeDisplay.getPathMain() +\n\t\t\t\t\"/wiki/find_page?pageResourcePrimKey=\" + activity.getClassPK();\n\n\t\t// Title\n\n\t\tString titlePattern = null;\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"<a href=\\\"\");\n\t\tsb.append(link);\n\t\tsb.append(\"\\\">\\\"\");\n\t\tsb.append(cleanContent(pageResource.getTitle()));\n\t\tsb.append(\"\\\"<\/a>\");\n\n\t\tString pageTitle = sb.toString();\n\n\t\tif (activityType == WikiActivityKeys.ADD_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-add-page\";\n\t\t}\n\t\telse if (activityType == WikiActivityKeys.UPDATE_PAGE) {\n\t\t\ttitlePattern = \"activity-wiki-update-page\";\n\t\t}\n\n\t\tif (Validator.isNotNull(groupName)) {\n\t\t\ttitlePattern += \"-in\";\n\t\t}\n\n\t\tObject[] titleArguments = new Object[] {\n\t\t\tgroupName, creatorUserName, pageTitle\n\t\t};\n\n\t\tString title = themeDisplay.translate(titlePattern, titleArguments);\n\n\t\t// Body\n\n\t\tString body = StringPool.BLANK;\n\n\t\treturn new SocialActivityFeedEntry(link, title, body);\n\t}","commit_id":"4c03d1884cad064232c0d9899d9720014e8886fc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void refreshTree() {\r\n    try {\r\n      loadTransformation();\r\n      \r\n      treeItemTargetMap = new HashMap<TreeItem, TargetStepAttribute>();\r\n      \r\n      wTree.removeAll();\r\n      \r\n      TreeItem transItem = new TreeItem(wTree, SWT.NONE);\r\n      transItem.setExpanded(true);\r\n      transItem.setText(injectTransMeta.getName());\r\n      List<StepMeta> injectSteps = new ArrayList<StepMeta>();\r\n      for (StepMeta stepMeta : injectTransMeta.getUsedSteps()) {\r\n        if (stepMeta.getStepMetaInterface().getStepMetaInjectionInterface()!=null) {\r\n          injectSteps.add(stepMeta);\r\n        }\r\n      }\r\n      Collections.sort(injectSteps);\r\n      \r\n      for (StepMeta stepMeta : injectSteps) {\r\n        TreeItem stepItem = new TreeItem(transItem, SWT.NONE);\r\n        stepItem.setText(stepMeta.getName());\r\n        stepItem.setExpanded(true);\r\n        \r\n        // For each step, add the keys\r\n        // \r\n        StepMetaInjectionInterface injection = stepMeta.getStepMetaInterface().getStepMetaInjectionInterface();\r\n        List<StepInjectionMetaEntry> entries = injection.getStepInjectionMetadataEntries();\r\n        for (final StepInjectionMetaEntry entry : entries) {\r\n          if (entry.getValueType()!=ValueMetaInterface.TYPE_NONE) {\r\n            TreeItem entryItem = new TreeItem(stepItem, SWT.NONE);\r\n            entryItem.setText(entry.getKey());\r\n            entryItem.setText(1, entry.getDescription());\r\n            TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), entry.getKey(), false);\r\n            treeItemTargetMap.put(entryItem, target);\r\n            \r\n            SourceStepField source = targetSourceMapping.get(target);\r\n            if (source!=null) {\r\n              entryItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n              entryItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n            }\r\n          } else {\r\n            // Fields...\r\n            //\r\n            TreeItem listsItem = new TreeItem(stepItem, SWT.NONE);\r\n            listsItem.setText(entry.getKey());\r\n            listsItem.setText(1, entry.getDescription());\r\n            \r\n            // Field...\r\n            //\r\n            StepInjectionMetaEntry listEntry = entry.getDetails().get(0);\r\n            TreeItem listItem = new TreeItem(listsItem, SWT.NONE);\r\n            listItem.setText(listEntry.getKey());\r\n            listItem.setText(1, listEntry.getDescription());\r\n            \r\n            for (StepInjectionMetaEntry me : listEntry.getDetails()) {\r\n              TreeItem treeItem = new TreeItem(listItem, SWT.NONE);\r\n              treeItem.setText(me.getKey());\r\n              treeItem.setText(1, me.getDescription());\r\n\r\n              TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), me.getKey(), true);\r\n              treeItemTargetMap.put(treeItem, target);\r\n              \r\n              SourceStepField source = targetSourceMapping.get(target);\r\n              if (source!=null) {\r\n                treeItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n                treeItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n              }              \r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n    } catch (Throwable t) {\r\n    }\r\n    \r\n    for (TreeItem item : wTree.getItems()) {\r\n      expandItemAndChildren(item);\r\n    }\r\n    \r\n    // Also set the source step combo values\r\n    //\r\n    String[] sourceSteps = injectTransMeta.getStepNames();\r\n    Arrays.sort(sourceSteps);\r\n    wSourceStep.setItems(sourceSteps);\r\n  }","id":87990,"modified_method":"private void refreshTree() {\r\n    try {\r\n      loadTransformation();\r\n      \r\n      treeItemTargetMap = new HashMap<TreeItem, TargetStepAttribute>();\r\n      \r\n      wTree.removeAll();\r\n      \r\n      TreeItem transItem = new TreeItem(wTree, SWT.NONE);\r\n      transItem.setExpanded(true);\r\n      transItem.setText(injectTransMeta.getName());\r\n      List<StepMeta> injectSteps = new ArrayList<StepMeta>();\r\n      for (StepMeta stepMeta : injectTransMeta.getUsedSteps()) {\r\n        if (stepMeta.getStepMetaInterface().getStepMetaInjectionInterface()!=null) {\r\n          injectSteps.add(stepMeta);\r\n        }\r\n      }\r\n      Collections.sort(injectSteps);\r\n      \r\n      for (StepMeta stepMeta : injectSteps) {\r\n        TreeItem stepItem = new TreeItem(transItem, SWT.NONE);\r\n        stepItem.setText(stepMeta.getName());\r\n        stepItem.setExpanded(true);\r\n        \r\n        // For each step, add the keys\r\n        // \r\n        StepMetaInjectionInterface injection = stepMeta.getStepMetaInterface().getStepMetaInjectionInterface();\r\n        List<StepInjectionMetaEntry> entries = injection.getStepInjectionMetadataEntries();\r\n        for (final StepInjectionMetaEntry entry : entries) {\r\n          if (entry.getValueType()!=ValueMetaInterface.TYPE_NONE) {\r\n            TreeItem entryItem = new TreeItem(stepItem, SWT.NONE);\r\n            entryItem.setText(entry.getKey());\r\n            entryItem.setText(1, entry.getDescription());\r\n            TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), entry.getKey(), false);\r\n            treeItemTargetMap.put(entryItem, target);\r\n            \r\n            SourceStepField source = targetSourceMapping.get(target);\r\n            if (source!=null) {\r\n              entryItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n              entryItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n            }\r\n          } else {\r\n            // Fields...\r\n            //\r\n            TreeItem listsItem = new TreeItem(stepItem, SWT.NONE);\r\n            listsItem.setText(entry.getKey());\r\n            listsItem.setText(1, entry.getDescription());\r\n            \r\n            // Field...\r\n            //\r\n            StepInjectionMetaEntry listEntry = entry.getDetails().get(0);\r\n            TreeItem listItem = new TreeItem(listsItem, SWT.NONE);\r\n            listItem.setText(listEntry.getKey());\r\n            listItem.setText(1, listEntry.getDescription());\r\n            \r\n            for (StepInjectionMetaEntry me : listEntry.getDetails()) {\r\n              TreeItem treeItem = new TreeItem(listItem, SWT.NONE);\r\n              treeItem.setText(me.getKey());\r\n              treeItem.setText(1, me.getDescription());\r\n\r\n              TargetStepAttribute target = new TargetStepAttribute(stepMeta.getName(), me.getKey(), true);\r\n              treeItemTargetMap.put(treeItem, target);\r\n              \r\n              SourceStepField source = targetSourceMapping.get(target);\r\n              if (source!=null) {\r\n                treeItem.setText(2, Const.NVL(source.getStepname(), \"\"));\r\n                treeItem.setText(3, Const.NVL(source.getField(), \"\"));\r\n              }              \r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n    } catch (Throwable t) {\r\n    }\r\n    \r\n    for (TreeItem item : wTree.getItems()) {\r\n      expandItemAndChildren(item);\r\n    }\r\n    \r\n    // Also set the source step combo values\r\n    //\r\n    if (injectTransMeta!=null) {\r\n      String[] sourceSteps = injectTransMeta.getStepNames();\r\n      Arrays.sort(sourceSteps);\r\n      wSourceStep.setItems(sourceSteps);\r\n    }\r\n  }","commit_id":"ae89fb7890d505c5ccd95357daca41ab12c8ab7d","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getGeneratorConfig() {\n\t\treturn generatorConfigurationField.getItems()[generatorConfigurationField.getSelectionIndex()];\n\t}","id":87991,"modified_method":"public String getGeneratorConfig() {\n\t\tif (generatorConfigurationField==null)\n\t\t\treturn WizardContribution.getFromRegistry().values().iterator().next().getName();\n\t\treturn generatorConfigurationField.getItems()[generatorConfigurationField.getSelectionIndex()];\n\t}","commit_id":"b0698b9c1e6af2a5179a6fb0e4597307d7cb215a","url":"https://github.com/eclipse/xtext"},{"original_method":"private void fillMweSnippet() {\n\t\tMap<String, WizardContribution> contributions = WizardContribution.getFromRegistry();\n\n\t\tList<String> names = new ArrayList<String>(contributions.keySet());\n\n\t\tCollections.sort(names);\n\n\t\tgeneratorConfigurationField.setItems(names.toArray(new String[names.size()]));\n\t\tgeneratorConfigurationField.select(indexOfDefault(names));\n\t}","id":87992,"modified_method":"private void fillMweSnippet() {\n\t\tMap<String, WizardContribution> contributions = WizardContribution.getFromRegistry();\n\n\t\tList<String> names = new ArrayList<String>(contributions.keySet());\n\n\t\tCollections.sort(names);\n\t\tif (generatorConfigurationField != null) {\n\t\t\tgeneratorConfigurationField.setItems(names.toArray(new String[names.size()]));\n\t\t\tgeneratorConfigurationField.select(indexOfDefault(names));\n\t\t}\n\t}","commit_id":"b0698b9c1e6af2a5179a6fb0e4597307d7cb215a","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Create language selection group\n\t * \n\t * @param parent\n\t *            the parent composite\n\t */\n\tprotected void createLanguageSelectionGroup(Composite parent) {\n\t\tGroup languageGroup = new Group(parent, SWT.NONE);\n\t\tlanguageGroup.setFont(parent.getFont());\n\t\tlanguageGroup.setText(Messages.WizardNewXtextProjectCreationPage_LabelLanguage);\n\t\tlanguageGroup.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\n\t\tlanguageGroup.setLayout(new GridLayout(1, false));\n\n\t\tComposite composite = new Composite(languageGroup, SWT.NONE);\n\t\tcomposite.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\n\t\tcomposite.setLayout(new GridLayout(2, false));\n\n\t\tLabel languageLabel = new Label(composite, SWT.NONE);\n\t\tGridData data = new GridData(GridData.FILL_HORIZONTAL);\n\t\tdata.horizontalSpan = 1;\n\t\tlanguageLabel.setText(Messages.WizardNewXtextProjectCreationPage_LabelName);\n\n\t\tlanguageNameField = new Text(composite, SWT.BORDER);\n\t\tdata = new GridData(GridData.FILL_HORIZONTAL);\n\t\tdata.horizontalSpan = 1;\n\t\tlanguageNameField.setLayoutData(data);\n\t\tlanguageNameField.setFont(parent.getFont());\n\n\t\tLabel extensionsLabel = new Label(composite, SWT.NONE);\n\t\textensionsLabel.setText(Messages.WizardNewXtextProjectCreationPage_LabelExtensions);\n\n\t\textensionsField = new Text(composite, SWT.BORDER);\n\t\tGridData textData = new GridData(SWT.FILL, SWT.CENTER, true, false);\n\t\ttextData.horizontalSpan = 1;\n\t\ttextData.horizontalIndent = 0;\n\t\textensionsField.setLayoutData(textData);\n\n\t\tLabel generatorConfigLabel = new Label(composite, SWT.NONE);\n\t\tgeneratorConfigLabel.setText(Messages.WizardNewXtextProjectCreationPage_GeneratorConfiguration);\n\n\t\tgeneratorConfigurationField = new Combo(composite, SWT.NONE);\n\t\tdata = new GridData(GridData.FILL_HORIZONTAL);\n\t\tdata.horizontalSpan = 1;\n\t\tgeneratorConfigurationField.setLayoutData(data);\n\t\tgeneratorConfigurationField.setFont(parent.getFont());\n\n\t\tnew Label(composite, SWT.NONE);\n\t\tgeneratorProjectField = new Button(composite, SWT.CHECK);\n\t\tdata = new GridData(GridData.FILL_HORIZONTAL);\n\t\tdata.horizontalSpan = 1;\n\t\tgeneratorProjectField.setLayoutData(data);\n\t\tgeneratorProjectField.setText(Messages.WizardNewXtextProjectCreationPage_CreateAGeneratorProject);\n\t\tgeneratorProjectField.setSelection(true);\n\n\t\tListener modifyListener = new Listener() {\n\t\t\tpublic void handleEvent(Event event) {\n\t\t\t\tsetPageComplete(validatePage());\n\t\t\t}\n\t\t};\n\t\tlanguageNameField.addListener(SWT.Modify, modifyListener);\n\t\textensionsField.addListener(SWT.Modify, modifyListener);\n\t}","id":87993,"modified_method":"/**\n\t * Create language selection group\n\t * \n\t * @param parent\n\t *            the parent composite\n\t */\n\tprotected void createLanguageSelectionGroup(Composite parent) {\n\t\tGroup languageGroup = new Group(parent, SWT.NONE);\n\t\tlanguageGroup.setFont(parent.getFont());\n\t\tlanguageGroup.setText(Messages.WizardNewXtextProjectCreationPage_LabelLanguage);\n\t\tlanguageGroup.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\n\t\tlanguageGroup.setLayout(new GridLayout(1, false));\n\n\t\tComposite composite = new Composite(languageGroup, SWT.NONE);\n\t\tcomposite.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));\n\t\tcomposite.setLayout(new GridLayout(2, false));\n\n\t\tLabel languageLabel = new Label(composite, SWT.NONE);\n\t\tGridData data = new GridData(GridData.FILL_HORIZONTAL);\n\t\tdata.horizontalSpan = 1;\n\t\tlanguageLabel.setText(Messages.WizardNewXtextProjectCreationPage_LabelName);\n\n\t\tlanguageNameField = new Text(composite, SWT.BORDER);\n\t\tdata = new GridData(GridData.FILL_HORIZONTAL);\n\t\tdata.horizontalSpan = 1;\n\t\tlanguageNameField.setLayoutData(data);\n\t\tlanguageNameField.setFont(parent.getFont());\n\n\t\tLabel extensionsLabel = new Label(composite, SWT.NONE);\n\t\textensionsLabel.setText(Messages.WizardNewXtextProjectCreationPage_LabelExtensions);\n\n\t\textensionsField = new Text(composite, SWT.BORDER);\n\t\tGridData textData = new GridData(SWT.FILL, SWT.CENTER, true, false);\n\t\ttextData.horizontalSpan = 1;\n\t\ttextData.horizontalIndent = 0;\n\t\textensionsField.setLayoutData(textData);\n\n\t\tif (WizardContribution.getFromRegistry().size() > 1) {\n\t\t\tLabel generatorConfigLabel = new Label(composite, SWT.NONE);\n\t\t\tgeneratorConfigLabel.setText(Messages.WizardNewXtextProjectCreationPage_GeneratorConfiguration);\n\n\t\t\tgeneratorConfigurationField = new Combo(composite, SWT.NONE);\n\t\t\tdata = new GridData(GridData.FILL_HORIZONTAL);\n\t\t\tdata.horizontalSpan = 1;\n\t\t\tgeneratorConfigurationField.setLayoutData(data);\n\t\t\tgeneratorConfigurationField.setFont(parent.getFont());\n\t\t}\n\t\tnew Label(composite, SWT.NONE);\n\t\tgeneratorProjectField = new Button(composite, SWT.CHECK);\n\t\tdata = new GridData(GridData.FILL_HORIZONTAL);\n\t\tdata.horizontalSpan = 1;\n\t\tgeneratorProjectField.setLayoutData(data);\n\t\tgeneratorProjectField.setText(Messages.WizardNewXtextProjectCreationPage_CreateAGeneratorProject);\n\t\tgeneratorProjectField.setSelection(true);\n\n\t\tListener modifyListener = new Listener() {\n\t\t\tpublic void handleEvent(Event event) {\n\t\t\t\tsetPageComplete(validatePage());\n\t\t\t}\n\t\t};\n\t\tlanguageNameField.addListener(SWT.Modify, modifyListener);\n\t\textensionsField.addListener(SWT.Modify, modifyListener);\n\t}","commit_id":"b0698b9c1e6af2a5179a6fb0e4597307d7cb215a","url":"https://github.com/eclipse/xtext"},{"original_method":"private IProject createProject(XtextProjectInfo xtextProjectInfo, String projectName,\n\t\t\tSet<String> requiredBundles, List<String> srcFolderList, String templateName,\n\t\t\tfinal IProgressMonitor monitor) throws CoreException {\n\t\tmonitor.beginTask(Messages.XtextProjectCreator_CreatingProjectsMessage + projectName, 3);\n\t\tfinal IProject dslProject = EclipseResourceUtil.createProject(projectName,xtextProjectInfo.getLocation(),\n\t\t\t\tsrcFolderList, Collections.<IProject> emptyList(), requiredBundles, null, null, null, monitor,\n\t\t\t\tnull,PROJECT_NATURES,xtextProjectInfo.getWorkingSets(),xtextProjectInfo.getWorkbench());\n\n\t\tif (dslProject == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tIFolder srcFolder = (IFolder) dslProject.findMember(srcFolderList.get(0));\n\n\t\tOutputImpl output = new OutputImpl();\n\t\toutput.addOutlet(new Outlet(false, getEncoding(), null, true, srcFolder.getLocation().makeAbsolute()\n\t\t\t\t.toOSString()));\n\n\t\tXpandExecutionContextImpl execCtx = new XpandExecutionContextImpl(output, null);\n\t\texecCtx.setFileEncoding(\"iso-8859-1\"); //$NON-NLS-1$\n\t\texecCtx.registerMetaModel(new JavaBeansMetaModel());\n\n\t\t// generate generator and activator for dsl and dsl.ui project\n\t\tXpandFacade facade = XpandFacade.create(execCtx);\n\t\tfacade.evaluate(templateName, xtextProjectInfo);\n\n\t\tmonitor.worked(1);\n\n\t\t// refresh folder and select file to edit\n\t\tdslProject.refreshLocal(IResource.DEPTH_INFINITE, monitor);\n\n\t\tmonitor.worked(1);\n\n\t\treturn dslProject;\n\t}","id":87994,"modified_method":"private IProject createProject(XtextProjectInfo xtextProjectInfo, String projectName,\n\t\t\tSet<String> requiredBundles, List<String> importPackages, List<String> srcFolderList, String templateName,\n\t\t\tfinal IProgressMonitor monitor) throws CoreException {\n\t\tmonitor.beginTask(Messages.XtextProjectCreator_CreatingProjectsMessage + projectName, 3);\n\t\tfinal IProject dslProject = EclipseResourceUtil.createProject(projectName,xtextProjectInfo.getLocation(),\n\t\t\t\tsrcFolderList, Collections.<IProject> emptyList(), requiredBundles, null, importPackages, null, monitor,\n\t\t\t\tnull,PROJECT_NATURES,xtextProjectInfo.getWorkingSets(),xtextProjectInfo.getWorkbench());\n\n\t\tif (dslProject == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tIFolder srcFolder = (IFolder) dslProject.findMember(srcFolderList.get(0));\n\n\t\tOutputImpl output = new OutputImpl();\n\t\toutput.addOutlet(new Outlet(false, getEncoding(), null, true, srcFolder.getLocation().makeAbsolute()\n\t\t\t\t.toOSString()));\n\n\t\tXpandExecutionContextImpl execCtx = new XpandExecutionContextImpl(output, null);\n\t\texecCtx.setFileEncoding(\"iso-8859-1\"); //$NON-NLS-1$\n\t\texecCtx.registerMetaModel(new JavaBeansMetaModel());\n\n\t\t// generate generator and activator for dsl and dsl.ui project\n\t\tXpandFacade facade = XpandFacade.create(execCtx);\n\t\tfacade.evaluate(templateName, xtextProjectInfo);\n\n\t\tmonitor.worked(1);\n\n\t\t// refresh folder and select file to edit\n\t\tdslProject.refreshLocal(IResource.DEPTH_INFINITE, monitor);\n\n\t\tmonitor.worked(1);\n\n\t\treturn dslProject;\n\t}","commit_id":"b0698b9c1e6af2a5179a6fb0e4597307d7cb215a","url":"https://github.com/eclipse/xtext"},{"original_method":"private IProject createDslUiProject(final IProgressMonitor monitor) throws CoreException {\n\t\tString projectName = getXtextProjectInfo().getUiProjectName();\n\n\t\tLinkedHashSet<String> requiredBundles = new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\tgetXtextProjectInfo().getProjectName().toLowerCase() + \";visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext.ui.core\", \"org.eclipse.xtext.ui.common\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\"org.eclipse.xtext.log4j;bundle-version=\\\"1.2.15\\\"\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.ui.editors;bundle-version=\\\"3.5.0\\\"\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.ui.ide;bundle-version=\\\"3.5.0\\\"\")); //$NON-NLS-1$\n\n\t\tString templateName = pathToTemplates()+\"DslUiProject::main\"; //$NON-NLS-1$\n\n\t\treturn createProject(getXtextProjectInfo(), projectName, requiredBundles, SRC_FOLDER_LIST, templateName,monitor);\n\t}","id":87995,"modified_method":"private IProject createDslUiProject(final IProgressMonitor monitor) throws CoreException {\n\t\tString projectName = getXtextProjectInfo().getUiProjectName();\n\n\t\tLinkedHashSet<String> requiredBundles = new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\tgetXtextProjectInfo().getProjectName().toLowerCase() + \";visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext.ui.core\", \"org.eclipse.xtext.ui.common\", //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t\"org.eclipse.ui.editors;bundle-version=\\\"3.5.0\\\"\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.ui.ide;bundle-version=\\\"3.5.0\\\"\")); //$NON-NLS-1$\n\n\t\tString templateName = pathToTemplates()+\"DslUiProject::main\"; //$NON-NLS-1$\n\n\t\treturn createProject(getXtextProjectInfo(), projectName, requiredBundles, Collections.singletonList(\"org.apache.log4j\"),SRC_FOLDER_LIST, templateName,monitor);\n\t}","commit_id":"b0698b9c1e6af2a5179a6fb0e4597307d7cb215a","url":"https://github.com/eclipse/xtext"},{"original_method":"private IProject createGeneratorProject(final IProgressMonitor monitor) throws CoreException {\n\t\tString projectName = getXtextProjectInfo().getGeneratorProjectName();\n\n\t\tLinkedHashSet<String> requiredBundles = new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\tgetXtextProjectInfo().getProjectName().toLowerCase() + \";visibility:=reexport\",\n\t\t\t\t\"org.eclipse.xpand;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtend;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.core;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.utils;visibility:=reexport\",//$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtend.typesystem.emf;visibility:=reexport\")); //$NON-NLS-1$\n\n\t\tString templateName = pathToTemplates()+\"GeneratorProject::main\"; //$NON-NLS-1$\n\n\t\treturn createProject(getXtextProjectInfo(), projectName, requiredBundles, SRC_FOLDER_LIST, templateName, monitor);\n\t}","id":87996,"modified_method":"private IProject createGeneratorProject(final IProgressMonitor monitor) throws CoreException {\n\t\tString projectName = getXtextProjectInfo().getGeneratorProjectName();\n\n\t\tLinkedHashSet<String> requiredBundles = new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\tgetXtextProjectInfo().getProjectName().toLowerCase() + \";visibility:=reexport\",\n\t\t\t\t\"org.eclipse.xpand;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtend;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.core;visibility:=reexport\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.utils;visibility:=reexport\",//$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtend.typesystem.emf;visibility:=reexport\")); //$NON-NLS-1$\n\n\t\tString templateName = pathToTemplates()+\"GeneratorProject::main\"; //$NON-NLS-1$\n\n\t\treturn createProject(getXtextProjectInfo(), projectName, requiredBundles, Collections.singletonList(\"org.apache.log4j\"), SRC_FOLDER_LIST, templateName, monitor);\n\t}","commit_id":"b0698b9c1e6af2a5179a6fb0e4597307d7cb215a","url":"https://github.com/eclipse/xtext"},{"original_method":"private IProject createDslProject(final IProgressMonitor monitor) throws CoreException {\n\t\tString projectName = getXtextProjectInfo().getProjectName();\n\n\t\tLinkedHashSet<String> requiredBundles = new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\t\"org.eclipse.xtext\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext.generator;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"de.itemis.xtext.antlr;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.apache.commons.logging;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.codegen.ecore;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext.log4j;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.utils;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.core;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"com.ibm.icu;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext.xtend;resolution:=optional\")); //$NON-NLS-1$\n\t\t\n\t\tString[] bundles = getXtextProjectInfo().getWizardContribution().getRequiredBundles();\n\t\tfor (String bundleId : bundles) {\n\t\t\trequiredBundles.add(bundleId.trim() + \";resolution:=optional\"); //$NON-NLS-1$\n\t\t}\n\n\t\tString templateName = pathToTemplates()+\"DslProject::main\"; //$NON-NLS-1$\n\t\treturn createProject(getXtextProjectInfo(), projectName, requiredBundles, SRC_FOLDER_LIST, templateName,\n\t\t\t\tmonitor);\n\t}","id":87997,"modified_method":"private IProject createDslProject(final IProgressMonitor monitor) throws CoreException {\n\t\tString projectName = getXtextProjectInfo().getProjectName();\n\n\t\tLinkedHashSet<String> requiredBundles = new LinkedHashSet<String>(Arrays.asList(\n\t\t\t\t\"org.eclipse.xtext\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext.generator;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"de.itemis.xtext.antlr;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.apache.commons.logging;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.codegen.ecore;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.utils;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.emf.mwe.core;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"com.ibm.icu;resolution:=optional\", //$NON-NLS-1$\n\t\t\t\t\"org.eclipse.xtext.xtend;resolution:=optional\")); //$NON-NLS-1$\n\t\t\n\t\tString[] bundles = getXtextProjectInfo().getWizardContribution().getRequiredBundles();\n\t\tfor (String bundleId : bundles) {\n\t\t\trequiredBundles.add(bundleId.trim() + \";resolution:=optional\"); //$NON-NLS-1$\n\t\t}\n\n\t\tString templateName = pathToTemplates()+\"DslProject::main\"; //$NON-NLS-1$\n\t\treturn createProject(getXtextProjectInfo(), projectName, requiredBundles, Collections.singletonList(\"org.apache.log4j\"),SRC_FOLDER_LIST, templateName,\n\t\t\t\tmonitor);\n\t}","commit_id":"b0698b9c1e6af2a5179a6fb0e4597307d7cb215a","url":"https://github.com/eclipse/xtext"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(BaseMessages.getString(PKG, \"JavaFilterDialog.DialogTitle\"));\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\t\t\n\t\t// Send 'True' data to...\n\t\tLabel wlTrueTo = new Label(shell, SWT.RIGHT);\n\t\twlTrueTo.setText(BaseMessages.getString(PKG, \"JavaFilterDialog.SendTrueTo.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTrueTo);\n\t\tFormData fdlTrueTo = new FormData();\n\t\tfdlTrueTo.left = new FormAttachment(0, 0);\n\t\tfdlTrueTo.right= new FormAttachment(middle, -margin);\n\t\tfdlTrueTo.top  = new FormAttachment(wStepname, margin);\n\t\twlTrueTo.setLayoutData(fdlTrueTo);\n\t\twTrueTo=new CCombo(shell, SWT.BORDER );\n \t\tprops.setLook(wTrueTo);\n\n\t\tStepMeta stepinfo = transMeta.findStep(stepname);\n\t\tif (stepinfo!=null)\n\t\t{\n\t\t\tList<StepMeta> nextSteps = transMeta.findNextSteps(stepinfo);\n\t\t\tfor (int i=0;i<nextSteps.size();i++)\n\t\t\t{\n\t\t\t\tStepMeta stepMeta = nextSteps.get(i);\n\t\t\t\twTrueTo.add(stepMeta.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\twTrueTo.addModifyListener(lsMod);\n\t\tFormData fdTrueTo = new FormData();\n\t\tfdTrueTo.left = new FormAttachment(middle, 0);\n\t\tfdTrueTo.top  = new FormAttachment(wStepname, margin);\n\t\tfdTrueTo.right= new FormAttachment(100, 0);\n\t\twTrueTo.setLayoutData(fdTrueTo);\n\n\t\t// Send 'False' data to...\n\t\tLabel wlFalseTo = new Label(shell, SWT.RIGHT);\n\t\twlFalseTo.setText(BaseMessages.getString(PKG, \"JavaFilterDialog.SendFalseTo.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlFalseTo);\n\t\tFormData fdlFalseTo = new FormData();\n\t\tfdlFalseTo.left = new FormAttachment(0, 0);\n\t\tfdlFalseTo.right= new FormAttachment(middle, -margin);\n\t\tfdlFalseTo.top  = new FormAttachment(wTrueTo, margin);\n\t\twlFalseTo.setLayoutData(fdlFalseTo);\n\t\twFalseTo=new CCombo(shell, SWT.BORDER );\n \t\tprops.setLook(wFalseTo);\n\n\t\tstepinfo = transMeta.findStep(stepname);\n\t\tif (stepinfo!=null)\n\t\t{\n\t\t\tList<StepMeta> nextSteps = transMeta.findNextSteps(stepinfo);\n\t\t\tfor (int i=0;i<nextSteps.size();i++)\n\t\t\t{\n\t\t\t\tStepMeta stepMeta = nextSteps.get(i);\n\t\t\t\twFalseTo.add(stepMeta.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\twFalseTo.addModifyListener(lsMod);\n\t\tFormData fdFalseFrom = new FormData();\n\t\tfdFalseFrom.left = new FormAttachment(middle, 0);\n\t\tfdFalseFrom.top  = new FormAttachment(wTrueTo, margin);\n\t\tfdFalseFrom.right= new FormAttachment(100, 0);\n\t\twFalseTo.setLayoutData(fdFalseFrom);\n\t\t\n\t\t// bufferSize\n\t\t//\n\t\tLabel wlCondition = new Label(shell, SWT.RIGHT);\n\t\twlCondition.setText(BaseMessages.getString(PKG, \"JavaFIlterDialog.Condition.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCondition);\n\t\tFormData fdlCondition = new FormData();\n\t\tfdlCondition.top  = new FormAttachment(wFalseTo, margin);\n\t\tfdlCondition.left = new FormAttachment(0, 0);\n\t\tfdlCondition.right= new FormAttachment(middle, -margin);\n\t\twlCondition.setLayoutData(fdlCondition);\n\t\twCondition = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n \t\tprops.setLook(wCondition);\n\t\twCondition.addModifyListener(lsMod);\n\t\tFormData fdCondition = new FormData();\n\t\tfdCondition.top  = new FormAttachment(wFalseTo, margin);\n\t\tfdCondition.left = new FormAttachment(middle, 0);\n\t\tfdCondition.right= new FormAttachment(100, 0);\n\t\twCondition.setLayoutData(fdCondition);\n        \n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\t\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":87998,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n        setShellImage(shell, input);\n\n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(BaseMessages.getString(PKG, \"JavaFilterDialog.DialogTitle\"));\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(BaseMessages.getString(PKG, \"System.Label.StepName\"));\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\n\t\t\n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\"));\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\"));\n\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\n\t\t\n\t\t\n\t\t// /////////////////////////////////\n\t\t// START OF Settings GROUP\n\t\t// /////////////////////////////////\n\n\t\twSettingsGroup = new Group(shell, SWT.SHADOW_NONE);\n\t\tprops.setLook(wSettingsGroup);\n\t\twSettingsGroup.setText(BaseMessages.getString(PKG, \"JavaFIlterDialog.Settings.Label\"));\n\t\tFormLayout settingsLayout = new FormLayout();\n\t\tsettingsLayout.marginWidth = 10;\n\t\tsettingsLayout.marginHeight = 10;\n\t\twSettingsGroup.setLayout(settingsLayout);\n\t\t\n\t\t// Send 'True' data to...\n\t\tLabel wlTrueTo = new Label(wSettingsGroup, SWT.RIGHT);\n\t\twlTrueTo.setText(BaseMessages.getString(PKG, \"JavaFilterDialog.SendTrueTo.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlTrueTo);\n\t\tFormData fdlTrueTo = new FormData();\n\t\tfdlTrueTo.left = new FormAttachment(0, 0);\n\t\tfdlTrueTo.right= new FormAttachment(middle, -margin);\n\t\tfdlTrueTo.top  = new FormAttachment(wStepname, margin);\n\t\twlTrueTo.setLayoutData(fdlTrueTo);\n\t\twTrueTo=new CCombo(wSettingsGroup, SWT.BORDER );\n \t\tprops.setLook(wTrueTo);\n\n\t\tStepMeta stepinfo = transMeta.findStep(stepname);\n\t\tif (stepinfo!=null)\n\t\t{\n\t\t\tList<StepMeta> nextSteps = transMeta.findNextSteps(stepinfo);\n\t\t\tfor (int i=0;i<nextSteps.size();i++)\n\t\t\t{\n\t\t\t\tStepMeta stepMeta = nextSteps.get(i);\n\t\t\t\twTrueTo.add(stepMeta.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\twTrueTo.addModifyListener(lsMod);\n\t\tFormData fdTrueTo = new FormData();\n\t\tfdTrueTo.left = new FormAttachment(middle, 0);\n\t\tfdTrueTo.top  = new FormAttachment(wStepname, margin);\n\t\tfdTrueTo.right= new FormAttachment(100, 0);\n\t\twTrueTo.setLayoutData(fdTrueTo);\n\n\t\t// Send 'False' data to...\n\t\tLabel wlFalseTo = new Label(wSettingsGroup, SWT.RIGHT);\n\t\twlFalseTo.setText(BaseMessages.getString(PKG, \"JavaFilterDialog.SendFalseTo.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlFalseTo);\n\t\tFormData fdlFalseTo = new FormData();\n\t\tfdlFalseTo.left = new FormAttachment(0, 0);\n\t\tfdlFalseTo.right= new FormAttachment(middle, -margin);\n\t\tfdlFalseTo.top  = new FormAttachment(wTrueTo, margin);\n\t\twlFalseTo.setLayoutData(fdlFalseTo);\n\t\twFalseTo=new CCombo(wSettingsGroup, SWT.BORDER );\n \t\tprops.setLook(wFalseTo);\n\n\t\tstepinfo = transMeta.findStep(stepname);\n\t\tif (stepinfo!=null)\n\t\t{\n\t\t\tList<StepMeta> nextSteps = transMeta.findNextSteps(stepinfo);\n\t\t\tfor (int i=0;i<nextSteps.size();i++)\n\t\t\t{\n\t\t\t\tStepMeta stepMeta = nextSteps.get(i);\n\t\t\t\twFalseTo.add(stepMeta.getName());\n\t\t\t}\n\t\t}\n\t\t\n\t\twFalseTo.addModifyListener(lsMod);\n\t\tFormData fdFalseFrom = new FormData();\n\t\tfdFalseFrom.left = new FormAttachment(middle, 0);\n\t\tfdFalseFrom.top  = new FormAttachment(wTrueTo, margin);\n\t\tfdFalseFrom.right= new FormAttachment(100, 0);\n\t\twFalseTo.setLayoutData(fdFalseFrom);\n\t\t\n\t\t// bufferSize\n\t\t//\n\t\tLabel wlCondition = new Label(wSettingsGroup, SWT.RIGHT);\n\t\twlCondition.setText(BaseMessages.getString(PKG, \"JavaFIlterDialog.Condition.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlCondition);\n\t\tFormData fdlCondition = new FormData();\n\t\tfdlCondition.top  = new FormAttachment(wFalseTo, margin);\n\t\tfdlCondition.left = new FormAttachment(0, 0);\n\t\tfdlCondition.right= new FormAttachment(middle, -margin);\n\t\twlCondition.setLayoutData(fdlCondition);\n\t\twCondition=new StyledTextComp(wSettingsGroup, SWT.MULTI | SWT.LEFT | SWT.BORDER | SWT.H_SCROLL | SWT.V_SCROLL, \"\");\n\t\tprops.setLook(wCondition);\n\t\twCondition.addModifyListener(lsMod);\n\t\tFormData fdCondition = new FormData();\n\t\tfdCondition.top  = new FormAttachment(wFalseTo, margin);\n\t\tfdCondition.left = new FormAttachment(middle, 0);\n\t\tfdCondition.right= new FormAttachment(100, 0);\n\t\tfdCondition.bottom = new FormAttachment(100, -margin);\n\t\twCondition.setLayoutData(fdCondition);\n        \n\t\tfdSettingsGroup = new FormData();\n\t\tfdSettingsGroup.left = new FormAttachment(0, margin);\n\t\tfdSettingsGroup.top = new FormAttachment(wStepname, margin);\n\t\tfdSettingsGroup.right = new FormAttachment(100, -margin);\n\t\tfdSettingsGroup.bottom = new FormAttachment(wOK, -margin);\n\t\twSettingsGroup.setLayoutData(fdSettingsGroup);\n\t\t\n\t\t// ///////////////////////////////////////////////////////////\n\t\t// / END OF Settings GROUP\n\t\t// ///////////////////////////////////////////////////////////\n\t\t\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\t\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"3a1d3403292d03aadf2b2715b4fcd4feb51c8bdb","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getModulesList()\r\n\t  {\r\n\t\t  if (!gotModule){\r\n\t\t\t  SalesforceConnection connection=null;\r\n\r\n\t\t\t  try{\r\n\t\t\t\t  SalesforceInputMeta meta = new SalesforceInputMeta();\r\n\t\t\t\t  getInfo(meta);\r\n\t\t\t\t  String url = transMeta.environmentSubstitute(meta.getTargetURL());\r\n\t\t\t\t  \r\n\t\t\t\t  String selectedField=transMeta.environmentSubstitute(meta.getModule());\r\n\t\t\t\t  wModule.removeAll();\r\n\r\n\t\t\t\t  // Define a new Salesforce connection\r\n\t\t\t\t  connection=new SalesforceConnection(log, url, transMeta.environmentSubstitute(meta.getUserName()),transMeta.environmentSubstitute(meta.getPassword())); \r\n\t\t\t\t  // connect to Salesforce\r\n\t\t\t\t  connection.connect();\r\n\t\t\t\t  // return \r\n\t\t\t\t  wModule.setItems(connection.getModules());\t\t\t\t  \r\n\t\t\t\t  \r\n\t\t\t\t  if(!Const.isEmpty(selectedField)) wModule.setText(selectedField);\r\n\t\t\t\t  \r\n\t\t\t      gotModule = true;\r\n\t        \t  getModulesListError = false;\r\n\t\t\t\t  \r\n\t\t\t  }catch(Exception e)\r\n\t\t\t  {\r\n\t\t\t\t\tnew ErrorDialog(shell,BaseMessages.getString(PKG, \"SalesforceInputDialog.ErrorRetrieveModules.DialogTitle\"),\r\n\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.ErrorRetrieveData.ErrorRetrieveModules\"),e);\r\n\t\t\t\t\tgetModulesListError = true;\r\n\t\t\t  } finally{\r\n\t\t\t\t  if(connection!=null) {\r\n\t\t\t\t\t\ttry {connection.close();}catch(Exception e){};\r\n\t\t\t\t\t}\r\n\t\t \t }\r\n\t\t  }\r\n\t  }","id":87999,"modified_method":"private void getModulesList()\r\n\t  {\r\n\t\t  if (!gotModule){\r\n\t\t\t  SalesforceConnection connection=null;\r\n\t\t\t  String selectedField=transMeta.environmentSubstitute(wModule.getText());\r\n\t\t\t  wModule.removeAll();\r\n\r\n\t\t\t  try{\r\n\t\t\t\t  SalesforceInputMeta meta = new SalesforceInputMeta();\r\n\t\t\t\t  getInfo(meta);\r\n\t\t\t\t  String url = transMeta.environmentSubstitute(meta.getTargetURL());\r\n\t\t\t\t  \r\n\t\t\t\t  // Define a new Salesforce connection\r\n\t\t\t\t  connection=new SalesforceConnection(log, url, transMeta.environmentSubstitute(meta.getUserName()),transMeta.environmentSubstitute(meta.getPassword())); \r\n\t\t\t\t  // connect to Salesforce\r\n\t\t\t\t  connection.connect();\r\n\t\t\t\t  \r\n\t\t\t\t  // retrieve modules list\r\n\t\t\t\t  String[] modules = connection.getModules();\r\n\t\t\t\t  if(modules!=null && modules.length>0) {\r\n\t\t\t\t\t  // populate Combo\r\n\t\t\t\t\t  wModule.setItems(connection.getModules());\t\r\n\t\t\t\t  }\r\n\t\t\t\t  \r\n\t\t\t      gotModule = true;\r\n\t        \t  getModulesListError = false;\r\n\t\t\t  }catch(Exception e) {\r\n\t\t\t\t\tnew ErrorDialog(shell,BaseMessages.getString(PKG, \"SalesforceInputDialog.ErrorRetrieveModules.DialogTitle\"),\r\n\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"SalesforceInputDialog.ErrorRetrieveData.ErrorRetrieveModules\"),e);\r\n\t\t\t\t\tgetModulesListError = true;\r\n\t\t\t  } finally{\r\n\t\t\t\t  if(!Const.isEmpty(selectedField)) wModule.setText(selectedField);\r\n\t\t\t\t  if(connection!=null) {\r\n\t\t\t\t\t\ttry {connection.close();}catch(Exception e){};\r\n\t\t\t\t\t}\r\n\t\t \t }\r\n\t\t  }\r\n\t  }","commit_id":"3a1d3403292d03aadf2b2715b4fcd4feb51c8bdb","url":"https://github.com/pentaho/pentaho-kettle"}]